Palette(HPALETTE hpal)
     : m_pbQuantizationTable(NULL)
{
        m_logpal.palVersion = 0x0300;
        Regenerate( hpal );
}


CHalftonePalette::~CHalftonePalette()
{
        if (m_pbQuantizationTable)
        {
                Delete [] m_pbQuantizationTable;
                m_pbQuantizationTable = NULL;
        }
}


STDMETHODIMP CHalftonePalette::Regenerate( HPALETTE hPal )
{
        GetObject(hPal, sizeof(WORD), &m_logpal.palNumEntries);
        ::GetPaletteEntries(hPal, 0, m_logpal.palNumEntries, &m_logpal.palPalEntry[0]);
        return Initialize( );
}

STDMETHODIMP CHalftonePalette::Initialize(void)
{
        LPPALETTEENTRY pPalEntry;
        int cPaletteEntries;
        static int dRedStep   = 255 / (RED_SHADES -1);
        static int dGreenStep = 255 / (GREEN_SHADES -1);
        static int dBlueStep  = 255 / (BLUE_SHADES -1);

        if( NULL == m_pbQuantizationTable )
        {
                m_pbQuantizationTable = New BYTE[ RED_SHADES * GREEN_SHADES * BLUE_SHADES ];    
        }

        if( m_pbQuantizationTable )
        {
                LPBYTE pbCurrent = m_pbQuantizationTable;

                for (int iRed = 0; iRed <= 255; iRed += dRedStep)
                {
                        for (int iGreen = 0; iGreen <= 255; iGreen += dGreenStep)
                        {
                                for (int iBlue = 0; iBlue <= 255; iBlue += dBlueStep)
                                {
                                long lMinDistance = 0x7FFFFFFFL;

                                        pPalEntry = &m_logpal.palPalEntry[0];
                                        cPaletteEntries = m_logpal.palNumEntries;

                                for (int i = 0; i < cPaletteEntries; i++, pPalEntry++)
                                {
                                        long lRedError   = iRed   - pPalEntry->peRed;
                                        long lGreenError = iGreen - pPalEntry->peGreen;
                                        long lBlueError  = iBlue  - pPalEntry->peBlue;
                                        long lDistance   = (lRedError * lRedError)  + 
                                                                                   (lGreenError * lGreenError) + 
                                                                                   (lBlueError * lBlueError);

                                        if (lDistance < lMinDistance)
                                        {
                                                lMinDistance = lDistance;
                                                *pbCurrent = (BYTE) i;

                                        if (lMinDistance == 0)  // Early out for exact color!
                                                break;
                                        }
                                }
                                        ++pbCurrent;
                                }
                        }
                }
                return S_OK;
        }
        return E_OUTOFMEMORY;
}

/*
********************************************************************
*
*
*
*
*
*
*
********************************************************************
*/

CHalftone::CHalftone(HPALETTE hpal) : m_cpal(hpal)
{
        Initialize();
}

CHalftone::~CHalftone()
{
}

STDMETHODIMP CHalftone::Initialize(void)
{
        LPBYTE pbCurrent = m_rgPattern;

        for (int iY = 0; iY < PATTERN_ROWS; iY++)
        {
                for (int iX = 0; iX < PATTERN_COLS; iX++)
                {
                        for (int iZ = 0; iZ < 256; iZ++)
                        {
                                int iColor = iZ + g_i4x4[iX][iY];
                                iColor = min(max(0, iColor), 255);
                                *(pbCurrent++) = (BYTE)iColor;
                        }
                }
        }
        return S_OK;
}


STDMETHODIMP CHalftone::Dither32to1( IDirectDrawSurface* pSrc, LPRECT prectSrc, 
                                                                         IDirectDrawSurface* pDst, LPRECT prectDst )
{
        if (!pSrc || !pDst || !prectSrc || !prectDst)   //sanity checks
        return E_INVALIDARG;

        DDSURFACEDESC     ddsDescSrc;
    DDSURFACEDESC     ddsDescDst;       
        const int       iWidthSrc  = prectSrc->right - prectSrc->left;
        const int       iHeightSrc = prectSrc->bottom - prectSrc->top;
        const int       iWidthDst  = prectDst->right - prectDst->left;
        const int       iHeightDst = prectDst->bottom - prectDst->top;
        const int   ctRowsToDither = min( iHeightSrc, iHeightDst );
        const int   ctColsToDither = min( iWidthSrc, iWidthDst );
        HRESULT         hr;
        RGBQUAD *       prgbSrc;
        LPBYTE          pbDst;
        LONG            lStrideSrc;
        LONG            lStrideDst;
        int                     iRow;   

        ddsDescSrc.dwSize = sizeof(ddsDescSrc);
    hr = pSrc->Lock(prectSrc, &ddsDescSrc, 0, NULL );
        if (FAILED(hr))
                goto CleanUp;

        ddsDescDst.dwSize = sizeof(ddsDescDst);
    hr = pDst->Lock(prectDst, &ddsDescDst, 0, NULL );
        if (FAILED(hr))
                goto CleanUp;

        lStrideSrc = ddsDescSrc.lPitch - (iWidthSrc * sizeof(RGBQUAD));
        lStrideDst = ddsDescDst.lPitch - (iWidthDst * sizeof(BYTE));

        prgbSrc = static_cast<RGBQUAD *>(ddsDescSrc.lpSurface);
        pbDst = static_cast<BYTE *>(ddsDescDst.lpSurface);

        for (iRow = 0; iRow < ctRowsToDither; iRow++)
        {                       
                int         iCol = ctColsToDither;
                int         pre  = prectDst->left % 8;
                BYTE        fTemp;

                        // Take care of left non-aligned
                if( pre )
                {
                        fTemp = 0;
                        do
                        {
                                if( prgbSrc->rgbReserved )
                                        fTemp |= (1 << pre);
                                ++prgbSrc;
                                ++pre;
                                --iCol;
                        } while( pre % 8 );
                        *pbDst++ = fTemp;
                }

                while( iCol >= 8 )
                {
                        fTemp = (!prgbSrc[0].rgbReserved)      | 
                                        (!prgbSrc[1].rgbReserved << 1) | 
                                        (!prgbSrc[2].rgbReserved << 2) | 
                                        (!prgbSrc[3].rgbReserved << 3) | 
                                        (!prgbSrc[4].rgbReserved << 4) | 
                                        (!prgbSrc[5].rgbReserved << 5) | 
                                        (!prgbSrc[6].rgbReserved << 6) | 
                                        (!prgbSrc[7].rgbReserved << 7);
                        prgbSrc += 8;
                        iCol  -= 8;
                        *pbDst++ = ~fTemp;
                }

                        // Take care of non-aligned endpoint
                if( iCol )
                {       
                        const int iInv = iCol;
                        fTemp = 0;
                        while( iCol )
                        {
                                if( prgbSrc->rgbReserved )
                                        fTemp |= (1 << (iInv-iCol));
                                ++prgbSrc;
                                --iCol;
                        }
                        *pbDst = fTemp;
                }
                prgbSrc = OffsetPtr( prgbSrc, lStrideSrc);
                pbDst += lStrideDst;
        }
CleanUp:
        if (ddsDescSrc.lpSurface)
        pSrc->Unlock( ddsDescSrc.lpSurface );
        if (ddsDescDst.lpSurface)
        pDst->Unlock( ddsDescDst.lpSurface );
        return hr;
}


STDMETHODIMP CHalftone::Dither32to8(IDirectDrawSurface* pSrc, LPRECT prectSrc, IDirectDrawSurface* pDst, LPRECT prectDst)
{
        if (!pSrc || !pDst || !prectSrc || !prectDst)   //sanity checks
        return E_INVALIDARG;


    DDSURFACEDESC     ddsDescSrc;
    DDSURFACEDESC     ddsDescDst;
        const int       iWidthSrc  = prectSrc->right - prectSrc->left;
        const int       iHeightSrc = prectSrc->bottom - prectSrc->top;
        const int       iWidthDst  = prectDst->right - prectDst->left;
        const int       iHeightDst = prectDst->bottom - prectDst->top;
        const int   ctRowsToDither = min( iHeightSrc, iHeightDst );
        const int   ctColsToDither = min( iWidthSrc, iWidthDst );
    int         iMulSrc;
    int         iMulDst;        
        BYTE    bBlueDst;
        BYTE    bGreenDst;
        BYTE    bRedDst;
        HRESULT hr;
        LPBYTE  pbSrc;
        LPBYTE  pbDst;
        LONG    lStrideSrc;
        LONG    lStrideDst;
        int             iRow;
        int             iCol;
        LPBYTE  pbPattern;
        long    lPatternOffset;
        BYTE    bBlueSrc;
        BYTE    bGreenSrc;
        BYTE    bRedSrc;

        ddsDescSrc.dwSize = sizeof(ddsDescSrc);
    hr = pSrc->Lock(prectSrc, &ddsDescSrc, 0, NULL );
        if (FAILED(hr))
                goto CleanUp;

        ddsDescDst.dwSize = sizeof(ddsDescDst);
    hr = pDst->Lock(prectDst, &ddsDescDst, 0, NULL );
        if (FAILED(hr))
                goto CleanUp;

        lStrideSrc = ddsDescSrc.lPitch - (iWidthSrc * sizeof(RGBQUAD));
        lStrideDst = ddsDescDst.lPitch - (iWidthDst * sizeof(BYTE));

        pbSrc = static_cast<BYTE *>(ddsDescSrc.lpSurface);
        pbDst = static_cast<BYTE *>(ddsDescDst.lpSurface);

        for (iRow = 0; iRow < ctRowsToDither; iRow++)
        {
                pbPattern = &m_rgPattern[((iRow%PATTERN_ROWS)<<10) + ((prectSrc->left%PATTERN_COLS)<<8)];
                lPatternOffset = 0;
                iCol = ctColsToDither;

                while (iCol)
                {
                        if (pbSrc[BGRA_ALPHA])                          //skip if transparent
                        {
                                //get noisy color components from 4x4 pattern table
                                bBlueSrc  = m_rgPattern[lPatternOffset + pbSrc[BGRA_BLUE]];
                                bGreenSrc = m_rgPattern[lPatternOffset + pbSrc[BGRA_GREEN]];
                                bRedSrc   = m_rgPattern[lPatternOffset + pbSrc[BGRA_RED]];

                                if (pbSrc[BGRA_ALPHA] != 0xFF)                  //alpha channel!
                                {
                                        //expand 8-bit index to 24-bit color values
                                        m_cpal.GetPaletteEntry(*pbDst, &bRedDst, &bGreenDst, &bBlueDst);

                                        //setup multipliers
                        iMulSrc   = pbSrc[BGRA_ALPHA];
                        iMulDst   = iMulSrc ^ 0xFF;

                                        //now combine color components here
                        bRedSrc   = (BYTE)(INT_MULT(bRedSrc,  iMulSrc) + INT_MULT(bRedDst,  iMulDst));
                        bGreenSrc = (BYTE)(INT_MULT(bGreenSrc,iMulSrc) + INT_MULT(bGreenDst,iMulDst));
                        bBlueSrc  = (BYTE)(INT_MULT(bBlueSrc, iMulSrc) + INT_MULT(bBlueDst, iMulDst));
                                }
                                //convert to 8-bit index
                                *pbDst = m_cpal.GetNearestPaletteIndex(bRedSrc, bGreenSrc, bBlueSrc);
                        }
                        pbDst++;
                        pbSrc += sizeof(RGBQUAD);
                        lPatternOffset = ((lPatternOffset + 256) & 0x000003FF);
                        iCol--;
                }
                pbSrc += lStrideSrc;
                pbDst += lStrideDst;
        }
CleanUp:
        if (ddsDescSrc.lpSurface)
        pSrc->Unlock( ddsDescSrc.lpSurface );
        if (ddsDescDst.lpSurface)
        pDst->Unlock( ddsDescDst.lpSurface );
        return hr;
}

STDMETHODIMP CHalftone::Blt32to555(IDirectDrawSurface* pSrc, LPRECT prectSrc, IDirectDrawSurface* pDst, LPRECT prectDst)
{
        if (!pSrc || !pDst || !prectSrc || !prectDst)   //sanity checks
                return E_INVALIDARG;

        DDSURFACEDESC     ddsDescSrc;
    DDSURFACEDESC     ddsDescDst;
        const int       iWidthSrc  = prectSrc->right - prectSrc->left;
        const int       iHeightSrc = prectSrc->bottom - prectSrc->top;
        const int       iWidthDst  = prectDst->right - prectDst->left;
        const int       iHeightDst = prectDst->bottom - prectDst->top;
        const int   ctRowsToDither = min( iHeightSrc, iHeightDst );
        const int   ctColsToDither = min( iWidthSrc, iWidthDst );
    int         iMulSrc;
    int         iMulDst;        
        BYTE    bBlueDst;
        BYTE    bGreenDst;
        BYTE    bRedDst;
        HRESULT hr;
        LPBYTE  pbSrc;
        LPBYTE  pbDst;
        LONG    lStrideSrc;
        LONG    lStrideDst;
        int             iRow;
        int             iCol;
        BYTE    bBlueSrc;
        BYTE    bGreenSrc;
        BYTE    bRedSrc;
        
        ddsDescSrc.dwSize = sizeof(ddsDescSrc);
    hr = pSrc->Lock(prectSrc, &ddsDescSrc, 0, NULL );
        if (FAILED(hr))
                goto CleanUp;

        ddsDescDst.dwSize = sizeof(ddsDescDst);
    hr = pDst->Lock(prectDst, &ddsDescDst, 0, NULL );
        if (FAILED(hr))
                goto CleanUp;

        lStrideSrc = ddsDescSrc.lPitch - (iWidthSrc * sizeof(RGBQUAD));
        lStrideDst = ddsDescDst.lPitch - (iWidthDst * sizeof(WORD));

        pbSrc = static_cast<BYTE *>(ddsDescSrc.lpSurface);
        pbDst = static_cast<BYTE *>(ddsDescDst.lpSurface);

        for (iRow = 0; iRow < ctRowsToDither; iRow++)
        {
                iCol = ctColsToDither;

                while (iCol)
                {
                        if (pbSrc[BGRA_ALPHA])                                  //skip if transparent
                        {
                                bBlueSrc  = pbSrc[BGRA_BLUE];
                                bGreenSrc = pbSrc[BGRA_GREEN];
                                bRedSrc   = pbSrc[BGRA_RED];

                                if (pbSrc[BGRA_ALPHA] != 0xFF)                  //alpha channel!
                                {
                                        WORD wDst = *(LPWORD)pbDst;
                                        bRedDst   = (wDst & 0x7C00) >> 7;
                                        bGreenDst = (wDst & 0x03E0) >> 2;
                                        bBlueDst  = (wDst & 0x001F) << 3;

                                        //setup multipliers
                        iMulSrc   = pbSrc[BGRA_ALPHA];
                        iMulDst   = iMulSrc ^ 0xFF;

                                        //now combine color components here
                        bRedSrc   = (BYTE)(INT_MULT(bRedSrc,  iMulSrc) + INT_MULT(bRedDst,  iMulDst));
                        bGreenSrc = (BYTE)(INT_MULT(bGreenSrc,iMulSrc) + INT_MULT(bGreenDst,iMulDst));
                        bBlueSrc  = (BYTE)(INT_MULT(bBlueSrc, iMulSrc) + INT_MULT(bBlueDst, iMulDst));
                                }
                                //convert to 555 color
                                *(LPWORD)pbDst = (WORD)(((bRedSrc>>3)<<10)+((bGreenSrc>>3)<<5)+(bBlueSrc>>3));
                        }
                        pbSrc += sizeof(RGBQUAD);
                        pbDst += sizeof(WORD);
                        iCol--;
                }
                pbSrc += lStrideSrc;
                pbDst += lStrideDst;
        }
CleanUp:
        if (ddsDescSrc.lpSurface)
        pSrc->Unlock( ddsDescSrc.lpSurface );
        if (ddsDescDst.lpSurface)
        pDst->Unlock( ddsDescDst.lpSurface );
        return hr;

}

STDMETHODIMP CHalftone::Blt32to565(IDirectDrawSurface* pSrc, LPRECT prectSrc, IDirectDrawSurface* pDst, LPRECT prectDst)
{
        if (!pSrc || !pDst || !prectSrc || !prectDst)   //sanity checks
                return E_INVALIDARG;

        DDSURFACEDESC     ddsDescSrc;
    DDSURFACEDESC     ddsDescDst;
        const int       iWidthSrc  = prectSrc->right - prectSrc->left;
        const int       iHeightSrc = prectSrc->bottom - prectSrc->top;
        const int       iWidthDst  = prectDst->right - prectDst->left;
        const int       iHeightDst = prectDst->bottom - prectDst->top;
        const int   ctRowsToDither = min( iHeightSrc, iHeightDst );
        const int   ctColsToDither = min( iWidthSrc, iWidthDst );
    int         iMulSrc;
    int         iMulDst;        
        BYTE    bBlueDst;
        BYTE    bGreenDst;
        BYTE    bRedDst;
        HRESULT hr;
        LPBYTE  pbSrc;
        LPBYTE  pbDst;
        LONG    lStrideSrc;
        LONG    lStrideDst;
        int             iRow;
        int             iCol;
        BYTE    bBlueSrc;
        BYTE    bGreenSrc;
        BYTE    bRedSrc;
        
        ddsDescSrc.dwSize = sizeof(ddsDescSrc);
    hr = pSrc->Lock(prectSrc, &ddsDescSrc, 0, NULL );
        if (FAILED(hr))
                goto CleanUp;

        ddsDescDst.dwSize = sizeof(ddsDescDst);
    hr = pDst->Lock(prectDst, &ddsDescDst, 0, NULL );
        if (FAILED(hr))
                goto CleanUp;

        lStrideSrc = ddsDescSrc.lPitch - (iWidthSrc * sizeof(RGBQUAD));
        lStrideDst = ddsDescDst.lPitch - (iWidthDst * sizeof(WORD));

        pbSrc = static_cast<BYTE *>(ddsDescSrc.lpSurface);
        pbDst = static_cast<BYTE *>(ddsDescDst.lpSurface);

        for (iRow = 0; iRow < ctRowsToDither; iRow++)
        {
                iCol = ctColsToDither;

                while (iCol)
                {
                        if (pbSrc[BGRA_ALPHA])                                          //skip if transparent
                        {
                                bBlueSrc  = pbSrc[BGRA_BLUE];
                                bGreenSrc = pbSrc[BGRA_GREEN];
                                bRedSrc   = pbSrc[BGRA_RED];

                                if (pbSrc[BGRA_ALPHA] != 0xFF)                  //alpha channel!
                                {
                                        WORD wDst = *(LPWORD)pbDst;
                                        bRedDst   = (wDst & 0xF800) >> 8;
                                        bGreenDst = (wDst & 0x07E0) >> 3;
                                        bBlueDst  = (wDst & 0x001F) << 3;

                                        //setup multipliers
                        iMulSrc   = pbSrc[BGRA_ALPHA];
                        iMulDst   = iMulSrc ^ 0xFF;

                                        //now combine color components here
                        bRedSrc   = (BYTE)(INT_MULT(bRedSrc,  iMulSrc) + INT_MULT(bRedDst,  iMulDst));
                        bGreenSrc = (BYTE)(INT_MULT(bGreenSrc,iMulSrc) + INT_MULT(bGreenDst,iMulDst));
                        bBlueSrc  = (BYTE)(INT_MULT(bBlueSrc, iMulSrc) + INT_MULT(bBlueDst, iMulDst));
                                }
                                //convert to 565 color
                                *(LPWORD)pbDst = (WORD)(((bRedSrc>>3)<<11)+((bGreenSrc>>2)<<5)+(bBlueSrc>>3));
                        }
                        pbSrc += sizeof(RGBQUAD);
                        pbDst += sizeof(WORD);
                        iCol--;
                }
                pbSrc += lStrideSrc;
                pbDst += lStrideDst;
        }
CleanUp:
        if (ddsDescSrc.lpSurface)
        pSrc->Unlock( ddsDescSrc.lpSurface );
        if (ddsDescDst.lpSurface)
        pDst->Unlock( ddsDescDst.lpSurface );
        return hr;
}

STDMETHODIMP CHalftone::Blt32to24(IDirectDrawSurface* pSrc, LPRECT prectSrc, IDirectDrawSurface* pDst, LPRECT prectDst)
{
        if (!pSrc || !pDst || !prectSrc || !prectDst)   //sanity checks
                return E_INVALIDARG;

        DDSURFACEDESC     ddsDescSrc;
    DDSURFACEDESC     ddsDescDst;
        const int       iWidthSrc  = prectSrc->right - prectSrc->left;
        const int       iHeightSrc = prectSrc->bottom - prectSrc->top;
        const int       iWidthDst  = prectDst->right - prectDst->left;
        const int       iHeightDst = prectDst->bottom - prectDst->top;
        const int   ctRowsToDither = min( iHeightSrc, iHeightDst );
        const int   ctColsToDither = min( iWidthSrc, iWidthDst );
    int         iMulSrc;
    int         iMulDst;        
        HRESULT hr;
        LPBYTE  pbSrc;
        LPBYTE  pbDst;
        LONG    lStrideSrc;
        LONG    lStrideDst;
        int             iRow;
        int             iCol;
                
        ddsDescSrc.dwSize = sizeof(ddsDescSrc);
    hr = pSrc->Lock(prectSrc, &ddsDescSrc, 0, NULL );
        if (FAILED(hr))
                goto CleanUp;

        ddsDescDst.dwSize = sizeof(ddsDescDst);
    hr = pDst->Lock(prectDst, &ddsDescDst, 0, NULL );
        if (FAILED(hr))
                goto CleanUp;

    lStrideSrc = ddsDescSrc.lPitch - (iWidthSrc * sizeof(RGBQUAD));
        lStrideDst = ddsDescDst.lPitch - (iWidthDst * sizeof(RGBTRIPLE));       

        pbSrc = static_cast<BYTE *>(ddsDescSrc.lpSurface);
        pbDst = static_cast<BYTE *>(ddsDescDst.lpSurface);

        for (iRow = 0; iRow < ctRowsToDither; iRow++)
        {
                iCol = ctColsToDither;

                while (iCol)
                {
                        if (pbSrc[BGRA_ALPHA])                                          //only if visible
                        {
                                if (pbSrc[BGRA_ALPHA] != 0xFF)                  //alpha channel!
                                {
                                        //setup multipliers
                        iMulSrc   = pbSrc[BGRA_ALPHA];
                        iMulDst   = iMulSrc ^ 0xFF;

                                        //now combine color components here
                                        pbDst[BGRA_BLUE] = (BYTE)(INT_MULT(pbSrc[BGRA_BLUE], iMulSrc) + 
                                                                                  INT_MULT(pbDst[BGRA_BLUE], iMulDst));
                                        pbDst[BGRA_GREEN]= (BYTE)(INT_MULT(pbSrc[BGRA_GREEN],iMulSrc) + 
                                                                                  INT_MULT(pbDst[BGRA_GREEN],iMulDst));
                                        pbDst[BGRA_RED]  = (BYTE)(INT_MULT(pbSrc[BGRA_RED],  iMulSrc) + 
                                                                          INT_MULT(pbDst[BGRA_RED],  iMulDst));
                                }
                                else
                                {
                                        pbDst[BGRA_BLUE]  = pbSrc[BGRA_BLUE];
                                        pbDst[BGRA_GREEN] = pbSrc[BGRA_GREEN];
                                        pbDst[BGRA_RED]   = pbSrc[BGRA_RED];
                                }
                        }
                        pbSrc += sizeof(RGBQUAD);
                        pbDst += sizeof(RGBTRIPLE);
                        iCol--;
                }
                pbSrc += lStrideSrc;
                pbDst += lStrideDst;
        }
CleanUp:
        if (ddsDescSrc.lpSurface)
        pSrc->Unlock( ddsDescSrc.lpSurface );
        if (ddsDescDst.lpSurface)
        pDst->Unlock( ddsDescDst.lpSurface );
        return hr;
}


STDMETHODIMP CHalftone::Blt32to32(IDirectDrawSurface* pSrc, LPRECT prectSrc, IDirectDrawSurface* pDst, LPRECT prectDst)
{
        if (!pSrc || !pDst || !prectSrc || !prectDst)   //sanity checks
                return E_INVALIDARG;

        DDSURFACEDESC     ddsDescSrc;
    DDSURFACEDESC     ddsDescDst;
        const int       iWidthSrc  = prectSrc->right - prectSrc->left;
        const int       iHeightSrc = prectSrc->bottom - prectSrc->top;
        const int       iWidthDst  = prectDst->right - prectDst->left;
        const int       iHeightDst = prectDst->bottom - prectDst->top;
        const int   ctRowsToDither = min( iHeightSrc, iHeightDst );
        const int   ctColsToDither = min( iWidthSrc, iWidthDst );
    int         iMulSrc;
    int         iMulDst;        
        HRESULT hr;
        LPBYTE  pbSrc;
        LPBYTE  pbDst;
        LONG    lStrideSrc;
        LONG    lStrideDst;
        int             iRow;
        int             iCol;

        ddsDescSrc.dwSize = sizeof(ddsDescSrc);
    hr = pSrc->Lock(prectSrc, &ddsDescSrc, 0, NULL );
        if (FAILED(hr))
                goto CleanUp;

        ddsDescDst.dwSize = sizeof(ddsDescDst);
    hr = pDst->Lock(prectDst, &ddsDescDst, 0, NULL );
        if (FAILED(hr))
                goto CleanUp;
        
    lStrideSrc = ddsDescSrc.lPitch - (iWidthSrc * sizeof(RGBQUAD));
        lStrideDst = ddsDescDst.lPitch - (iWidthDst * sizeof(RGBQUAD));

        pbSrc = static_cast<BYTE *>(ddsDescSrc.lpSurface);
        pbDst = static_cast<BYTE *>(ddsDescDst.lpSurface);

        for (iRow = 0; iRow < ctRowsToDither; iRow++)
        {
                iCol = ctColsToDither;

                while (iCol)
                {
                        if (pbSrc[BGRA_ALPHA])                          //skip if transparent
                        {
                                if (pbSrc[BGRA_ALPHA] != 0xFF)                  //alpha channel!
                                {
                                        //setup multipliers
                        iMulSrc = pbSrc[BGRA_ALPHA];
                        iMulDst = iMulSrc ^ 0xFF;

                                        //now combine color components here
                                        pbDst[BGRA_BLUE] = (BYTE)(INT_MULT(pbSrc[BGRA_BLUE], iMulSrc) + 
                                                                                  INT_MULT(pbDst[BGRA_BLUE], iMulDst));
                                        pbDst[BGRA_GREEN]= (BYTE)(INT_MULT(pbSrc[BGRA_GREEN],iMulSrc) + 
                                                                                  INT_MULT(pbDst[BGRA_GREEN],iMulDst));
                                        pbDst[BGRA_RED]  = (BYTE)(INT_MULT(pbSrc[BGRA_RED],  iMulSrc) + 
                                                                          INT_MULT(pbDst[BGRA_RED],  iMulDst));
                                }
                                else
                                {
                                        pbDst[BGRA_BLUE]  = pbSrc[BGRA_BLUE];
                                        pbDst[BGRA_GREEN] = pbSrc[BGRA_GREEN];
                                        pbDst[BGRA_RED]   = pbSrc[BGRA_RED];
                                }
                                pbDst[BGRA_ALPHA] = pbSrc[BGRA_ALPHA];
                        }
                        pbSrc += sizeof(RGBQUAD);
                        pbDst += sizeof(RGBQUAD);
                        iCol--;
                }
                pbSrc += lStrideSrc;
                pbDst += lStrideDst;
        }
CleanUp:
        if (ddsDescSrc.lpSurface)
        pSrc->Unlock( ddsDescSrc.lpSurface );
        if (ddsDescDst.lpSurface)
        pDst->Unlock( ddsDescDst.lpSurface );
        return hr;
}


// ----------------------------- HANDY UTILITIES -------------------------------
DLINKAGE DWORD  GetSigBitsFrom16BPP( HDC hdc )
{
        struct {
                BITMAPINFOHEADER bih;
                DWORD bf[3];
        }       bmi;
        HBITMAP hbmp;
        DWORD   dwDepth = 15u;

    hbmp = CreateCompatibleBitmap(hdc, 1, 1);
    ZeroMemory(&bmi, sizeof(bmi));
    bmi.bih.biSize = sizeof(BITMAPINFOHEADER);
    // first call will fill in the optimal biBitCount
    GetDIBits(hdc, hbmp, 0, 1, NULL, (BITMAPINFO*)&bmi, DIB_RGB_COLORS);

    if(bmi.bih.biBitCount != 16)
                return bmi.bih.biBitCount;

    // second call will get the optimal bitfields
    GetDIBits(hdc, hbmp, 0, 1, NULL, (BITMAPINFO*)&bmi, DIB_RGB_COLORS);
    DeleteObject(hbmp);
    // Win95 only supports 555 and 565
    // For NT we'll assume this covers the majority cases too
    if( (bmi.bf[0] == 0xF800) && 
                (bmi.bf[1] == 0x07E0) && 
                (bmi.bf[2] == 0x001F) ) // RGB mask
    {
                dwDepth = 16u;
    }
    return dwDepth;
}


#pragma optimize( "", on )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\util\dds_bs.cpp ===
/***********************************************
 *   DDS_BS.cpp -
 *	Implementation of an adapter-class to take
 *  an IBitmapSurface interface pointer and
 *  make it function in clients expecting
 *  IDirectDrawSurface.  
 *  Note: Only the barest-subset of DirectDraw
 *  methods are adapted here:
 *        GetSurfaceDesc(), 
 *        GetPixelFormat(),
 *        Lock(),
 *        Unlock()
 *  sufficient to get IHammer M2 to function
 *  in both IE4 Beta1 and Beta2.
 *
 *  Author:  Norm Bryar
 *  History:
 *		4/22/97 - Created.
 *
 **********************************************/
#include <ihammer.h>
#include <htmlfilter.h>	  // IBitmapSurface, BFID_RGB_..., etc.
#include <surface.h>
#include <dds_bs.h>

	// If it's possible IBitmapSurface can accept
	// many locks on different (or overlapping)
	// regions of the image, define MANY_LOCKS
#define MANY_LOCKS

#ifdef MANY_LOCKS
  #include <memlayer>   // STL-ized IHammer mem-mgr, HAMMOC
  #include <functional> // less<>
  #include <set>		// multiset<>
#endif // MANY_LOCKS


#pragma warning( disable: 4786 )  // STL decls > 255 char, so?

const DWORD  ALPHAMASK32 = 0xFF000000;
const DWORD  REDMASK24   = 0x00FF0000;
const DWORD  GRNMASK24   = 0x0000FF00;
const DWORD  BLUMASK24   = 0x000000FF;
const DWORD  REDMASK16   = 0x0000F800;
const DWORD  GRNMASK16   = 0x000007E0;
const DWORD  BLUMASK16   = 0x0000001F;
const DWORD  REDMASK15   = 0x00007C00;
const DWORD  GRNMASK15   = 0x000003E0;
const DWORD  BLUMASK15   = 0x0000001F;


struct lockpair
{
	void * pv;
	RECT   rc;

	lockpair( ) 
	{ pv=NULL; SetRectEmpty(&rc); }

	lockpair( void* p, const RECT * pr = NULL )
	{ 
		pv=p; 
		SetRectEmpty( &rc );
		if( NULL != pr )
		{
			  rc = *pr;
		}		
	}
};


#ifdef MANY_LOCKS
	struct std::less< lockpair > 
		: public std::binary_function<lockpair, lockpair, bool> 
	{
		bool operator()(const lockpair& _X, const lockpair& _Y) const
		{return (_X.pv < _Y.pv); }
	};
	typedef std::less<lockpair> lockcmp;

	typedef HAMMOC<lockpair>    lockalloc;

	class lockcollection : public std::multiset< lockpair, 
												 lockcmp,
												 lockalloc >
	{
	};
#else
	class lockcollection : public lockpair
	{
	};
#endif // MANY_LOCKS

// ----------------------------------
									  


EXPORT CDDSBitmapSurface::CDDSBitmapSurface( IBitmapSurface * pibs ) 
	   : m_pibs(pibs),
		 m_plockcollection(NULL),
		 m_ctRef(0u)
{ 
	if( pibs )
	{
		m_ctRef = 1u;
	}
	memset( &m_ddpixformat, 0, sizeof(m_ddpixformat) );
}


CDDSBitmapSurface::~CDDSBitmapSurface( )
{ 
	Proclaim( !m_ctRef );  // Should have released a held pibs
}


STDMETHODIMP CDDSBitmapSurface::QueryInterface( REFIID riid, void * * ppv )
{
	if( m_pibs )
	{
		return m_pibs->QueryInterface( riid, ppv );
	}
	return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG)   CDDSBitmapSurface::AddRef( void )
{	
	if( m_pibs )
	{
		m_pibs->AddRef(  );
	}
	return ++m_ctRef;
}


STDMETHODIMP_(ULONG)   CDDSBitmapSurface::Release( void )
{
	ULONG  ul = --m_ctRef;
	if( m_pibs )
	{
		if( 0u == m_pibs->Release(  ) )
		{
				// How did this die out from under us?
			Proclaim( 0u == ul );
			m_pibs = NULL;
		}
	}
	if( 0u == ul )
		Delete this;
	return ul;
}


	// --- Forwarded IDirectDrawSurface methods ---
STDMETHODIMP  CDDSBitmapSurface::GetPixelFormat( DDPIXELFORMAT * pddpf )
{
	if( NULL == pddpf )
		return E_POINTER;

	if( 0u == m_ddpixformat.dwSize )
	{
		HRESULT hr = UpdatePixFormat( );
		if( FAILED(hr) )
			return hr;
	}

	*pddpf = m_ddpixformat;
	return m_ddpixformat.dwSize ? S_OK : S_FALSE;
}

STDMETHODIMP  CDDSBitmapSurface::GetSurfaceDesc( DDSURFACEDESC * pddsDesc )
{
	HRESULT hr = E_FAIL;
	if( NULL == pddsDesc )
		return E_POINTER;

	if( m_pibs )
	{
		pddsDesc->dwSize  = sizeof( *pddsDesc );
		pddsDesc->dwFlags = DDSD_HEIGHT | DDSD_WIDTH;
		hr = m_pibs->GetSize( (long *) &pddsDesc->dwWidth,
							  (long *) &pddsDesc->dwHeight );
		if( FAILED(hr) )
			return hr;

		hr = GetPixelFormat( &(pddsDesc->ddpfPixelFormat) );
		if( S_OK == hr )
		{
			pddsDesc->dwFlags |= DDSD_PIXELFORMAT | 
								 DDSD_ALPHABITDEPTH;
			pddsDesc->dwAlphaBitDepth = 
				m_ddpixformat.dwRGBAlphaBitMask ? 8 : 0;
		}		
	}
	return hr;
}


STDMETHODIMP  CDDSBitmapSurface::Lock( RECT * pRect, DDSURFACEDESC * pddsDesc,
									   DWORD, HANDLE )
{
	HRESULT hr;

	if( NULL == pddsDesc )
		return E_POINTER;	

	hr = GetSurfaceDesc( pddsDesc );
	if( FAILED(hr) )
		return hr;

	hr = m_pibs->LockBits( pRect, 
						   0,
						   (void * *) &(pddsDesc->lpSurface),
						   &(pddsDesc->lPitch) );
	if( SUCCEEDED(hr) )
	{
		pddsDesc->dwFlags  |= DDSD_PITCH;
		hr = AddLockPair( lockpair(pddsDesc->lpSurface, pRect) );
	}
	return hr;
}


STDMETHODIMP  CDDSBitmapSurface::Unlock( void * pVoid )
{
	if( NULL == pVoid )
		return E_POINTER;

	if( (NULL == m_plockcollection) || (NULL == m_pibs) )
		return E_FAIL;

	HRESULT   hr = E_FAIL;
	lockpair  lp( pVoid );	
	lockcollection::iterator  i = m_plockcollection->find( lp );

	if( i != m_plockcollection->end() )
	{
		hr = m_pibs->UnlockBits( const_cast<RECT *>(&(*i).rc), 
							     (*i).pv );
		(void) RemoveLockPair( pVoid );
	}
	else
	{
		Proclaim( FALSE && "unlock pointer not locked" );
	}
	return hr;
}


	// --- Private utilities --- 
HRESULT  CDDSBitmapSurface::AddLockPair( lockpair & lp )
{
#ifdef MANY_LOCKS
	if( NULL == m_plockcollection )
	{
		m_plockcollection = New lockcollection;
		if( NULL == m_plockcollection )
			return E_OUTOFMEMORY;
	}

	m_plockcollection->insert( lp );
#else
	static lockpair  s_theLockPair;
	if( NULL == m_plockcollection )
	{
		m_plockcollection = &s_theLockPair;
	}

		// Just one lock at a time, please!!
	Proclaim( NULL == s_theLockPair.pv ); 

	*m_plockcollection = lp;
#endif // MANY_LOCKS
	return S_OK;
}


HRESULT  CDDSBitmapSurface::RemoveLockPair( void * pv )
{
	if( NULL == m_plockcollection )
		return E_FAIL;

#ifdef MANY_LOCKS
	lockpair  lp;
	lp.pv = pv;	

	lockcollection::iterator  i = m_plockcollection->find( lp );
	if( i != m_plockcollection->end() )
	{
		m_plockcollection->erase( i );
	}
	else
	{
		Proclaim( FALSE && "pointer not-locked" );
	}
#else
	*m_plockcollection = lockpair( NULL, NULL );
#endif // MANY_LOCKS

	return S_OK;
}


HRESULT  CDDSBitmapSurface::UpdatePixFormat( void )
{
	if( NULL == m_pibs )
		return S_FALSE;

	BFID     bfid;
	HRESULT hr = m_pibs->GetFormat( &bfid );
	if( FAILED(hr) )
		return hr;

	memset( &m_ddpixformat, 0, sizeof(m_ddpixformat) );	
	m_ddpixformat.dwFlags = DDPF_RGB;

	if( IsEqualGUID( bfid, BFID_RGB_8 ) )
	{
		m_ddpixformat.dwFlags |= DDPF_PALETTEINDEXED8;
		m_ddpixformat.dwRGBBitCount = DD_8BIT;
	}
	else if( IsEqualGUID( bfid, BFID_RGB_555 ) )
	{
		m_ddpixformat.dwRGBBitCount = DD_16BIT;
		m_ddpixformat.dwRBitMask = REDMASK15;
		m_ddpixformat.dwGBitMask = GRNMASK15;
		m_ddpixformat.dwBBitMask = BLUMASK15;
	}
	else if( IsEqualGUID( bfid, BFID_RGB_565 ) )
	{
		m_ddpixformat.dwRGBBitCount = DD_16BIT;
		m_ddpixformat.dwRBitMask = REDMASK16;
		m_ddpixformat.dwGBitMask = GRNMASK16;
		m_ddpixformat.dwBBitMask = BLUMASK16;
	}
	else if( IsEqualGUID( bfid, BFID_RGB_24 ) )
	{
		m_ddpixformat.dwRGBBitCount = DD_24BIT;
		m_ddpixformat.dwRBitMask = REDMASK24;
		m_ddpixformat.dwGBitMask = GRNMASK24;
		m_ddpixformat.dwBBitMask = BLUMASK24;
	}
	else if( IsEqualGUID( bfid, BFID_RGB_32 ) )
	{
		// m_ddpixformat.dwAlphaBitDepth = DDBD_8; -DO NOT DO THIS!
		m_ddpixformat.dwFlags |= DDPF_ALPHAPIXELS;
		m_ddpixformat.dwRGBBitCount = DD_32BIT;
		m_ddpixformat.dwRBitMask = REDMASK24;
		m_ddpixformat.dwGBitMask = GRNMASK24;
		m_ddpixformat.dwBBitMask = BLUMASK24;
		m_ddpixformat.dwRGBAlphaBitMask = ALPHAMASK32;
	}
	else if( IsEqualGUID( bfid, BFID_RGB_4 ) )
	{
		m_ddpixformat.dwFlags |= DDPF_PALETTEINDEXED4;
		m_ddpixformat.dwRGBBitCount = DD_4BIT;
	}
	else if( IsEqualGUID( bfid, BFID_MONOCHROME ) )
	{
		m_ddpixformat.dwFlags |= DDPF_PALETTEINDEXED1;
		m_ddpixformat.dwRGBBitCount = DD_1BIT;
	}
	else
	{
		return E_FAIL;
	}

	m_ddpixformat.dwSize  = sizeof(m_ddpixformat);
	return S_OK;
}




	// --- Stubbed IDirectDrawSurface methods ---
STDMETHODIMP  CDDSBitmapSurface::AddAttachedSurface( LPDIRECTDRAWSURFACE )
{
	return E_NOTIMPL;
}


STDMETHODIMP  CDDSBitmapSurface::AddOverlayDirtyRect( LPRECT )
{
	return E_NOTIMPL;
}


STDMETHODIMP  CDDSBitmapSurface::Blt( LPRECT,LPDIRECTDRAWSURFACE, LPRECT,DWORD, LPDDBLTFX )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::BltBatch( LPDDBLTBATCH, DWORD, DWORD )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::BltFast( DWORD,DWORD,LPDIRECTDRAWSURFACE, LPRECT,DWORD )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::DeleteAttachedSurface( DWORD,LPDIRECTDRAWSURFACE )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::EnumAttachedSurfaces( LPVOID,LPDDENUMSURFACESCALLBACK )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::EnumOverlayZOrders( DWORD,LPVOID,LPDDENUMSURFACESCALLBACK )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::Flip( LPDIRECTDRAWSURFACE, DWORD )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::GetAttachedSurface( LPDDSCAPS, LPDIRECTDRAWSURFACE FAR * )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::GetBltStatus( DWORD )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::GetCaps( LPDDSCAPS )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::GetClipper( LPDIRECTDRAWCLIPPER FAR* )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::GetColorKey( DWORD, LPDDCOLORKEY )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::GetDC( HDC FAR * )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::GetFlipStatus( DWORD )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::GetOverlayPosition( LPLONG, LPLONG  )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::GetPalette( LPDIRECTDRAWPALETTE FAR* )
{
	return E_NOTIMPL;
}


STDMETHODIMP  CDDSBitmapSurface::Initialize( LPDIRECTDRAW, LPDDSURFACEDESC )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::IsLost( )
{
	return E_NOTIMPL;
}


STDMETHODIMP  CDDSBitmapSurface::ReleaseDC( HDC )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::Restore( )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::SetClipper( LPDIRECTDRAWCLIPPER )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::SetColorKey( DWORD, LPDDCOLORKEY )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::SetOverlayPosition( LONG, LONG  )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::SetPalette( LPDIRECTDRAWPALETTE )
{
	return E_NOTIMPL;
}


STDMETHODIMP  CDDSBitmapSurface::UpdateOverlay( LPRECT, LPDIRECTDRAWSURFACE,LPRECT,DWORD, LPDDOVERLAYFX )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::UpdateOverlayDisplay( DWORD )
{
	return E_NOTIMPL;
}

STDMETHODIMP  CDDSBitmapSurface::UpdateOverlayZOrder( DWORD, LPDIRECTDRAWSURFACE )
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\util\ctstr.cpp ===
/*++

Module:
	ctstr.cpp

Description:
	Implementation of TSTR wrapper class

Author:
	Simon Bernstein (simonb)

--*/

#include <ihammer.h>
#include <ctstr.h>
#include <debug.h>

EXPORT CTStr::CTStr(LPWSTR pszStringW)
{
	m_pszString = NULL;
	SetString(pszStringW);
}


EXPORT CTStr::CTStr(LPSTR pszStringA)
{
	m_pszString = NULL;
	SetString(pszStringA);
}


EXPORT CTStr::CTStr(int iAllocateLength)
{
	m_iLen = 0;
	
	if (iAllocateLength > 0)
	{
		m_pszString = New TCHAR[iAllocateLength];
		m_pszString[0] = 0;
	}
	else
	{
		m_pszString = NULL;
	}
}

// Copy constructor
EXPORT CTStr::CTStr(CTStr &rhs)
{
	m_iLen = rhs.m_iLen;
	
	if (m_iLen > 0)
	{
		m_pszString = New TCHAR [m_iLen + 1];
		
		if (NULL != m_pszString)
			lstrcpy(m_pszString, rhs.m_pszString);
	}
	else
	{
		m_pszString = NULL;
	}
}
	

EXPORT CTStr::~CTStr()
{
	if (m_pszString)
		Delete [] m_pszString;
}
	

EXPORT BOOL CTStr::SetString(LPWSTR pszStringW)
{
	if (m_pszString)
		Delete [] m_pszString;

	if (NULL == pszStringW)
	{
		m_iLen = 0;
		m_pszString = NULL;
	}
	else
	{
		m_iLen = lstrlenW(pszStringW);
		m_pszString = New TCHAR[m_iLen + 1];
	}

	if (NULL != m_pszString)
	{
#ifdef _UNICODE
		lstrcpy (m_pszString, pszStringW);
#else
		UNICODEToANSI(m_pszString, pszStringW, m_iLen + 1);
#endif
	}
	else if (NULL != pszStringW)
	{
		return FALSE;
	}

	return TRUE;
}


EXPORT BOOL CTStr::SetString(LPSTR pszStringA)
{
	if (m_pszString)
		Delete [] m_pszString;

	if (NULL == pszStringA)
	{
		m_iLen = 0;
		m_pszString = NULL;
	}
	else
	{
		m_iLen = lstrlenA(pszStringA);
		m_pszString = New TCHAR[m_iLen + 1];
	}
	
	if (NULL != m_pszString)
	{
#ifdef _UNICODE
		ANSIToUNICODE(m_pszLine,pszStringA, m_iLen + 1);
#else
		lstrcpy (m_pszString, pszStringA);
#endif
	}
	else if (NULL != pszStringA)
	{
		return FALSE;
	}

	return TRUE;
}


EXPORT BOOL CTStr::SetStringPointer(LPTSTR pszString, BOOL fDealloc)
{
	if ( fDealloc && (NULL != m_pszString) )
		Delete [] m_pszString;

	m_pszString = pszString;
	
	if (NULL != m_pszString)
		m_iLen = lstrlen(m_pszString);

	return TRUE;
}


EXPORT BOOL CTStr::AllocBuffer(int iAllocateLength, BOOL fDealloc)
{
	if (NULL != m_pszString)
	{
        if (fDealloc)
        {
            Delete [] m_pszString;
        }
        else
        {
            return FALSE;
        }

	}

    m_iLen = 0;
	m_pszString = New TCHAR[iAllocateLength];

	return (m_pszString != NULL);
}


EXPORT void CTStr::FreeBuffer()
{
	if (m_pszString)
	{
		Delete [] m_pszString;
		m_pszString = NULL;
	}
	m_iLen = 0;

}


EXPORT BSTR CTStr::SysAllocString()
{

#ifdef _UNICODE
	return ::SysAllocString(m_pszString);
#else

	// Handle the conversion to ANSI
	LPWSTR pwszTemp = pszW();

	if (NULL != pwszTemp)
	{
		BSTR bstrRet = NULL;
		
		bstrRet = ::SysAllocString(pwszTemp);
		Delete [] pwszTemp;

		return bstrRet;
	}
	else
	{
		return NULL;
	}
#endif
}

EXPORT LPSTR CTStr::pszA()
{
	if (NULL == m_pszString)
		return NULL;

	LPSTR pszNew = New char[m_iLen + 1];

	if (NULL != pszNew)
	{
#ifdef _UNICODE
		// Convert from UNICODE to ANSI
		UNICODEToANSI(pszNew, m_pszString, m_iLen + 1);
#else
		lstrcpy(pszNew, m_pszString);
#endif
	}
	return pszNew;
}


EXPORT LPWSTR CTStr::pszW()
{
	if (NULL == m_pszString)
		return NULL;

	m_iLen = lstrlen(m_pszString);

	LPWSTR pszNew = New WCHAR[m_iLen + 1];

	if (NULL != pszNew)
	{
#ifdef _UNICODE
		lstrcpy(pszNew, m_pszString);
#else
		// Convert from ANSI to UNICODE
		ANSIToUNICODE(pszNew, m_pszString, m_iLen + 1);
#endif
	}
	return pszNew;
}


EXPORT void CTStr::ResetLength()
{
	if (NULL != m_pszString)
		m_iLen = lstrlen(m_pszString);
}


int CTStr::UNICODEToANSI(LPSTR pchDst, LPCWSTR pwchSrc, int cchDstMax)
{
	Proclaim( pchDst );

    // Initialize destination string in case WideCharToMultiByte fails
    if(cchDstMax >= 1)
        pchDst[0] = '\0';
    
    return WideCharToMultiByte(CP_ACP, 0, pwchSrc ? pwchSrc : OLESTR( "" ), 
									-1, pchDst, cchDstMax, NULL, NULL); 
}

int CTStr::ANSIToUNICODE(LPWSTR pwchDst, LPCSTR pchSrc, int cwchDstMax)
{
	Proclaim( pwchDst );
	Proclaim( pchSrc );

    return MultiByteToWideChar(CP_ACP, 0, pchSrc, -1, pwchDst, cwchDstMax);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\util\idcol.cpp ===
//	IDispatch collection, with augment and enumerate interfaces.
//	Van Kichline, 7/26/96
//
//	Changed 8/27/96:
//		Next now addrefs pointers.
//		IEnumIDispatch changed to IEnumDispatch
//
//	A simple implementation of an IDispatch collection.
//	Currently, a fixed array is used to store the IDispatch pointers.
//	This implementation will be improved upon later if required.
//
//	CreateIDispatchCollection returns an IUnknown interface pointer to a
//	new, empty collection.  These classes are not CoCreatable (yet.)
//
//	CDispatchCollectionEnum, exposed through IEnumDispatch, is a standard OLE
//	enumerator, returning IDispatch pointers.  Pointers objtained from Next ARE
//	AddRefed, they need not be released by the obtainer.  Pointers are AddRefed when
//	added to the collection or when the collection is Cloned, and Released when the
//	collection is disposed of.
//
//	CDispatchCollectionAugment, exposed through IIDispatchCollectionAugment, is a
//	class of convenience, allowing IDispatch pointers to be added to the collection.
//	No other functions are provided at this stage; this is enough for these tests.

#include "utilpre.h"
#include <ole2.h>
#include "IdCol.h"
#include "IdGuids.h"

//	Static routine for creating the IDispatch collection
//
BOOL EXPORT WINAPI CreateIDispatchCollection ( IUnknown **ppUnk )
{
	PCIDispatchCollection	pIdC;
	HRESULT					hr;

	Proclaim ( NULL != ppUnk );	// Must be a pointer to a memory location
	if ( NULL == ppUnk )
	{
		return FALSE;
	}
	*ppUnk = NULL;	// Initialize once it's known to be safe

	// Create the object
	pIdC = new CIDispatchCollection ();

	Proclaim ( NULL != pIdC );	// Make certain an object was allocated.
	if ( NULL == pIdC )
	{
		return FALSE;
	}

	// Get the interface, which calls AddRef
	hr = pIdC->QueryInterface ( IID_IUnknown, (void **)ppUnk );
	return SUCCEEDED ( hr );
}


//	Base object constructor, contining the other two objects
//
#pragma warning(disable:4355)	// Using 'this' in constructor
CIDispatchCollection::CIDispatchCollection ( void ) :
	m_oAugment ( this ), m_oEnum ( this )
{
	// Clear the array
	for ( int i = 0; i < CPTRS; i++ )
	{
		m_rpid[i] = NULL;
	}

	m_cRef	= 0;	// Ref counts always start at zero
	m_cPtrs	= 0;	// Array is currently empty
}
#pragma warning(default:4355)	// Using 'this' in constructor


//	Base object destructor, responsible for all AddRefed IDispatch pointers in the collection
//
CIDispatchCollection::~CIDispatchCollection ( void )
{
	ULONG	ulCount	= 0;	// Used for debugging AddRef/Release

    for ( ULONG i = 0; i < m_cPtrs; i++ )
	{
		Proclaim ( NULL != m_rpid[i] );	// Every counted interface is expected to have a value
		ulCount = m_rpid[i]->Release();	// ulCount just for single-stepping verification
		m_rpid[i] = NULL;
	}
}


//	Base object QI.  Contained objects delgate to this QI.
//
STDMETHODIMP CIDispatchCollection::QueryInterface ( REFIID riid, void** ppv )
{
	Proclaim ( NULL != ppv );	// Must be a pointer to a memory location
	*ppv = NULL;

	if ( IID_IUnknown == riid )
	{
		*ppv = this;
	}
	else if ( IID_IEnumDispatch == riid )
	{
		*ppv = &m_oEnum;
	}
	else if ( IID_IDispatchCollectionAugment == riid )
	{
		*ppv = &m_oAugment;
	}
	else
	{
		Proclaim ( FALSE );		// Who's calling this with a bad interface ID?
		return E_NOINTERFACE;
	}

	((LPUNKNOWN)*ppv)->AddRef();

	return NOERROR;
}


//	Base object AddRef.  Contained objects may contain independant reference counts
//	for debugging purposes.
//	but they are not used for deletion.
//
STDMETHODIMP_(ULONG) CIDispatchCollection::AddRef ( void )
{
	return ++m_cRef;
}


//	Base object Release.  Contained objects may contain independant reference counts,
//	but they are not used for deletion.
//
STDMETHODIMP_(ULONG) CIDispatchCollection::Release ( void )
{
	if (0 != --m_cRef)
	{
		return m_cRef;
	}

	delete this;
	return 0;
}



/******************************************************************************

CDispatchCollectionAugment: allows IDispatch pointers to be added to the collection

******************************************************************************/


CIDispatchCollection::CDispatchCollectionAugment::CDispatchCollectionAugment
(
	CIDispatchCollection* pObj
)
{
	m_cRef		= 0;	// Private reference count, used for debugging purposes.
	m_poBackPtr	= pObj;	// Back pointer to containing object
}


CIDispatchCollection::CDispatchCollectionAugment::~CDispatchCollectionAugment ()
{
	Proclaim ( 0 == m_cRef );	// Refcount must be zero when deleted.  Imbalance?
}


STDMETHODIMP CIDispatchCollection::CDispatchCollectionAugment::QueryInterface
(
	REFIID	riid,
	void**	ppv
)
{
	return m_poBackPtr->QueryInterface ( riid, ppv );
}


STDMETHODIMP_(ULONG) CIDispatchCollection::CDispatchCollectionAugment::AddRef ()
{
	m_cRef++;
	return m_poBackPtr->AddRef();
}


STDMETHODIMP_(ULONG) CIDispatchCollection::CDispatchCollectionAugment::Release ()
{
	m_cRef--;
	return m_poBackPtr->Release();
}


//	Add an IDispatch pointer to the end of the array if there's room.
//
STDMETHODIMP CIDispatchCollection::CDispatchCollectionAugment::AddToCollection
(
	IDispatch*	pid
)
{
	HRESULT	hr		= S_OK;
	ULONG	ulCount	= 0;	// Used for debugging AddRef/Release

	Proclaim ( NULL != pid );	// Must be a pointer to a memory location

	if ( m_poBackPtr->m_cPtrs >= ( CPTRS - 1 ) )
	{
		return E_OUTOFMEMORY;	// A better error needed, but implementation will change...
	}

	if ( NULL == pid )
	{
		return E_FAIL;
	}
	
	// AddRef the pointer.
	ulCount = pid->AddRef();	// ulCount just for single-stepping verification
	m_poBackPtr->m_rpid[m_poBackPtr->m_cPtrs++] = pid;

	return hr;
}


/******************************************************************************

CDispatchCollectionEnum: standard OLE enumerator

******************************************************************************/


CIDispatchCollection::CDispatchCollectionEnum::CDispatchCollectionEnum
(
	CIDispatchCollection*	pObj
)
{
	m_cRef		= 0;	// Private reference count, used for debugging purposes.
	m_iCur		= 0;	// Current pointer is the first element.
	m_poBackPtr = pObj;	// Back pointer to containing object
}

CIDispatchCollection::CDispatchCollectionEnum::~CDispatchCollectionEnum ()
{
	Proclaim ( 0 == m_cRef );	// Refcount must be zero when deleted.  Imbalance?
}


STDMETHODIMP CIDispatchCollection::CDispatchCollectionEnum::QueryInterface
(
	REFIID	riid,
	void**	ppv
)
{
	return m_poBackPtr->QueryInterface ( riid, ppv );
}


STDMETHODIMP_(ULONG) CIDispatchCollection::CDispatchCollectionEnum::AddRef ()
{
	m_cRef++;
	return m_poBackPtr->AddRef();
}


STDMETHODIMP_(ULONG) CIDispatchCollection::CDispatchCollectionEnum::Release ()
{
	m_cRef--;
	return m_poBackPtr->Release();
}


//	IDispatch pointers returned to the caller ARE ADDREFED. (Changed 8/26/96)
//	They are valid only as long as the collection is retained, unless the caller AddRefs.
//
STDMETHODIMP CIDispatchCollection::CDispatchCollectionEnum::Next
(
	ULONG		cPtrs,
	IDispatch	**pid,
	ULONG		*pcPtrs
)
{
	ULONG	cPtrsReturn = 0L;

	Proclaim ( 0 != cPtrs );	// Misuse?  Why get zero items?
	Proclaim ( NULL != pid );	// Must point to a memory location.
	// Must have a pointer to count returned, if count requested is other than 1
	Proclaim ( !( ( NULL == pcPtrs ) && ( 1 != cPtrs ) ) );

	if ( NULL == pcPtrs )	// Null is only allowed when one IDispatch is being requested
	{
		if ( 1L != cPtrs )
		{
			return E_FAIL;
		}
	}
	else
	{
		*pcPtrs = 0L;
	}

	if ( NULL == pid || ( m_iCur >= m_poBackPtr->m_cPtrs ) )
	{
		return S_FALSE;
	}

	while ( m_iCur < m_poBackPtr->m_cPtrs && cPtrs > 0 )
	{
		IDispatch*	pidElement = m_poBackPtr->m_rpid[m_iCur++];;
		Proclaim ( pidElement );
		pidElement->AddRef ();
		*pid++ = pidElement;
		cPtrsReturn++;
		cPtrs--;
	}

	if ( NULL != pcPtrs )
	{
		*pcPtrs = cPtrsReturn;
	}

	return NOERROR;
}


//	If the number to skip falls beyond the last element, the cursor is not moved.
//
STDMETHODIMP CIDispatchCollection::CDispatchCollectionEnum::Skip
(
	ULONG	cSkip
)
{
	Proclaim ( 0 != cSkip );	// Misuse?  Why skip zero pointers?

	if ( ( m_iCur + cSkip ) >= m_poBackPtr->m_cPtrs )
	{
		return S_FALSE;
	}

	m_iCur += cSkip;
	return NOERROR;
}


STDMETHODIMP CIDispatchCollection::CDispatchCollectionEnum::Reset ()
{
	m_iCur = 0;
	return NOERROR;
}


//	After duplicating the list of IDispatch pointers, AddRef each pointer.
//	The destructor will Release each pointer.
//	The enumerator's m_iCur is left initalized to 0, not copied from the source.
//
STDMETHODIMP CIDispatchCollection::CDispatchCollectionEnum::Clone
(
	PENUMDISPATCH	*ppEnum
)
{
	IDispatch	*pid	= NULL;
	ULONG		ulCount	= 0;		// Used for debugging AddRef/Release
	HRESULT		hr		= S_OK;

	Proclaim ( NULL != ppEnum );	// Must be a pointer to a memory location
	if ( NULL == ppEnum )
	{
		return E_FAIL;
	}

	*ppEnum = NULL;	// Initialize the result nce it's known to be safe
	
	CIDispatchCollection *pIdc = new CIDispatchCollection ();	// Create a new collection
	Proclaim ( NULL != pIdc );		// Allocation failure
	if ( NULL == pIdc )
	{
		return E_FAIL;
	}

	// Copy the existing array of IDispatch pointers over, addrefing each one.
	for ( ULONG i = 0; i < m_poBackPtr->m_cPtrs; i++ )
	{
		pid = m_poBackPtr->m_rpid[i];
		Proclaim ( NULL != pid );	// The elements included by m_cPtrs should have no NULLs
		ulCount = pid->AddRef();	// ulCount just for single-stepping verification
		pIdc->m_rpid[i] = pid;
	}
	pIdc->m_cPtrs = m_poBackPtr->m_cPtrs;	// Copy the number of elements in the array

	hr = pIdc->QueryInterface ( IID_IEnumDispatch, (void **)ppEnum );	// Get interface pointer
	Proclaim ( NULL != *ppEnum );	// No good reason the QI should fail
	Proclaim ( SUCCEEDED ( hr ) );	// Failure at this point should be impossible
	if ( FAILED ( hr ) )
	{
		delete pIdc;				// Kill it, it won't work
	}
	return hr;
}

//	End of IdCol.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\util\idguids.cpp ===
#include "UtilPre.h"

#include <objbase.h>
#include <initguid.h>

#include <IdGuids.h>
#include <ddraw.h>      // IID_IDirectDrawSurface
#include "bfid_rgb.h"	// BFID_RGB_... shit
#include "debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\util\drg.cpp ===
/*+********************************************************
MODULE: DRG.CPP
AUTHOR: Outlaw
DATE: summer '93

DESCRIPTION: Implements CDrg dynamic array class.
*********************************************************-*/

#include <stdlib.h>
#include <minmax.h>
#include "utilpre.h"
#include "utils.h"
#include "memlayer.h"
#include "memory.h"
#include "drg.h"

const UINT  DEF_REALLOC_BYTES      = 512u;  // Byte-count or
const UINT  DEF_REALLOC_MULTIPLES  = 1u;    // object ct to grow.
                                            // Bigger size used.


/*+*******************************************************
AUTHOR: Outlaw
DATE:   summer '93

PUBLIC METHOD

Initializes element size and increment size.  If this routine
is not called before other operations on array, drg will use
defaults for these.
*********************************************************-*/
void EXPORT WINAPI CDrg::SetNonDefaultSizes(UINT cElSize, UINT cResizeIncrement)
{
    m_cElementSize=cElSize;
    if( 0u == cResizeIncrement )
        cResizeIncrement = max( DEF_REALLOC_MULTIPLES,
                                DEF_REALLOC_BYTES / cElSize );
    m_cResizeIncrement=cResizeIncrement;
}







/*+*******************************************************
AUTHOR: Outlaw
DATE:   summer '93

PUBLIC METHOD

Called to insert an element on the dynamic array.  If array
must expand to accomodate it, it does so.  No gaps can be
left in array, so value passed must be <= m_lmac.

Note that upon an insertion, elements are scooted up.

Routine will fail on OOM.

Allocates array buffer upon first invocation.
*********************************************************-*/
BOOL EXPORT WINAPI CDrg::Insert(void FAR *qEl, LONG cpos)
{
    HANDLE hTemp, h;
    LONG i;

    if (cpos==DRG_APPEND)
        cpos=m_lmac;

    // WILL IT BE NECESSARY TO RESIZE ARRAY?  IF SO, GET AFTER IT....
    if (m_lmac >= m_lmax)
    {
        // INITIAL ALLOCATION?
        if (!m_qBuf)
        {
            Proclaim(!m_lmac && !m_lmax);
            h=MemAllocZeroInit(m_cResizeIncrement * m_cElementSize);
            if (!h)
                return(FALSE);
            m_qBuf=(BYTE *)MemLock(h);
            m_lmax=m_cResizeIncrement;
        }
        else    // WE'RE RESIZING
        {
            h=MemGetHandle(m_qBuf);
            MemUnlock(h);
            hTemp=MemReallocZeroInit(h, (m_lmax+m_cResizeIncrement)*m_cElementSize);
            if (!hTemp)
            {
                Echo("Memory failure reallocating buffer in CDrg::Insert()!  Failing!");
                m_qBuf=(BYTE FAR *)MemLock(h);
                return(FALSE);
            }
            m_qBuf=(BYTE FAR *)MemLock(hTemp);
            m_lmax+=m_cResizeIncrement;
        }
    }

    // SCOOT UP ELEMENTS THAT NEED TO BE SCOOTED UP (STARTING AT END) IF WE'RE NOT APPENDING
    if (cpos < m_lmac)
    {
        for (i=m_lmac; i>cpos; i--)
            memcpy(m_qBuf+(i*m_cElementSize), m_qBuf+((i-1)*m_cElementSize), m_cElementSize);
    }

    // INSERT NEW ELEMENT....
    memcpy(m_qBuf+(cpos*m_cElementSize), (BYTE *)qEl, m_cElementSize);

    // INCREMENT NUMBER OF ELEMENTS IN ARRAY....
    ++m_lmac;

    return(TRUE);
}






/*+*******************************************************
AUTHOR: Outlaw
DATE:   summer '93

PUBLIC METHOD

Called to delete an element from the dynamic array.

If array hasn't been initialized, this routine will return
false as it will upon a weird resizing error.

Value at specified position will be copied to passed pointer
location -- if the pointer is non-null.  If it's null, nothing
is copied.

This routine will also return FALSE if the specified index
value is out of range.

Note that deleting an entry will not immediately cause the
array buffer to shrink.  Rather, only when the disparity
between m_lmac and m_lmax reaches m_cResizeIncrement will
the array resize downward....

Note that when the array DOES resize, it does so by scooting
everything down....
*********************************************************-*/
BOOL EXPORT WINAPI CDrg::Remove(void FAR *q, LONG cpos)
{
    if (cpos >= m_lmac)
    {
//      Echo("CDrg::Delete(%ld) out of range deletion!  Returning!", (LONG)cpos);
        return(FALSE);
    }

    // COPY DELETED ELEMENT TO RETURN BUFFER
    if (q)
        memcpy((BYTE *)q, m_qBuf+(cpos*m_cElementSize), m_cElementSize);

    // SCOOT EVERYTHING DOWN
    if (cpos < m_lmac-1)
        memcpy(m_qBuf+(cpos * m_cElementSize), m_qBuf+((cpos+1) * m_cElementSize), (m_lmac-(cpos+1)) * m_cElementSize);

    // DECREMENT NUMBER OF ELEMENTS IN ARRAY....
    --m_lmac;

    // IF IT'S NECESSARY TO SHRINK, SHRINK
    if (m_lmac < m_lmax-(LONG)m_cResizeIncrement)
    {
        HANDLE h=MemGetHandle(m_qBuf);
        MemUnlock(h);
        if (!m_lmac)
        {
// REVIEW PAULD            Free(h);
            MemFree(h);
            m_lmax=0;
            m_qBuf=NULL;
        }
        else
        {
            HANDLE hTemp=MemReallocZeroInit(h, m_lmac*m_cElementSize);
            if (!hTemp)
            {
                Echo("Weird!  Resize shrink error in CDrg::Remove()!  Failing!");
                m_qBuf=(BYTE *)MemLock(h);
                return(FALSE);
            }
            m_qBuf=(BYTE *)MemLock(hTemp);
            m_lmax=m_lmac;
        }
    }

    return(TRUE);
}




/* Note: It is up to the application to ascertain which array elements
are actually in use. */


//void EXPORT WINAPI CNonCollapsingDrg::SetNonDefaultSizes(UINT cSizeElement, UINT cResizeIncrement)
//{
//    m_cElementSize=cSizeElement;
//    m_cResizeIncrement=cResizeIncrement;
//}


LPVOID EXPORT WINAPI CNonCollapsingDrg::GetFirst(void)
{
    LPBYTE pbyte=NULL;

    if (m_qBuf)
    {
        pbyte = m_qBuf;
        m_lIdxCurrent=0;
    }
    return (LPVOID)pbyte;
}


LPVOID EXPORT WINAPI CNonCollapsingDrg::GetNext(void)
{
    LPBYTE pbyte=NULL;

    if (m_qBuf && m_lIdxCurrent + 1 < m_lmax )
    {
        ++m_lIdxCurrent;
        pbyte = m_qBuf + (m_lIdxCurrent * m_cElementSize);
    }
    return (LPVOID)pbyte;
}


BOOL EXPORT WINAPI CNonCollapsingDrg::Remove(void FAR *q, LONG cpos)
{
    BOOL fRet=FALSE;
    if (m_qBuf && cpos < m_lmax)
    {
        memcpy( q, (LPBYTE)m_qBuf+(cpos*m_cElementSize), m_cElementSize);
        memset( (LPBYTE)m_qBuf+(cpos*m_cElementSize), 0, m_cElementSize);
        --m_lmac;
        fRet=TRUE;
    }
    return fRet;
}




BOOL EXPORT WINAPI CNonCollapsingDrg::SetAt(void FAR *q, LONG cpos)
{
    LPBYTE pbyte;

    if (!m_qBuf)
    {
        Proclaim(!m_lmac && !m_lmax);
        HANDLE h=MemAllocZeroInit(m_cResizeIncrement * m_cElementSize);
        if (!h)
            return(FALSE);
        m_qBuf=(BYTE *)MemLock(h);
        m_lmax=m_cResizeIncrement;
    }

    if (cpos >= m_lmax)
    {
        LONG lmaxNew = ((cpos + m_cResizeIncrement)/m_cResizeIncrement)*m_cResizeIncrement;
        HANDLE h=MemGetHandle(m_qBuf);
        MemUnlock(h);
        h=MemReallocZeroInit(h, lmaxNew * m_cElementSize);
        if (!h)
        {
            Echo("Memory failure reallocating buffer in CDrg::Insert()!  Failing!");
            m_qBuf=(BYTE FAR *)MemLock(h);
            return(FALSE);
        }
        m_qBuf=(BYTE FAR *)MemLock(h);
        m_lmax=lmaxNew;
    }
    pbyte = m_qBuf+(cpos*m_cElementSize);
    memcpy(pbyte, q, m_cElementSize);
    ++m_lmac;
    return(TRUE);
}

LPVOID EXPORT WINAPI CNonCollapsingDrg::GetAt(LONG cpos)
{
    LPBYTE pbyte = NULL;
    if (m_qBuf && cpos >= 0 && cpos < m_lmax)
    {
        pbyte = m_qBuf + (m_cElementSize*cpos);
    }
    return (LPVOID)pbyte;
}


BOOL EXPORT WINAPI CNonCollapsingDrg::CopyFrom(CDrg FAR *qdrg)
{
    LONG i;
    MakeNull();
    LPVOID pvoid;

    Proclaim(m_cElementSize==((CNonCollapsingDrg*)qdrg)->m_cElementSize);

    for (i=0; i < ((CNonCollapsingDrg*)qdrg)->m_lmax; i++)
    {
        if (pvoid=((CNonCollapsingDrg*)qdrg)->GetAt(i)) SetAt( pvoid, i );
    }
    return(TRUE);
}

VOID EXPORT WINAPI CNonCollapsingDrg::SetArray(BYTE *qBuf, LONG lElements, UINT uElementSize)
{
    LONG i;
    MakeNull();
    m_cElementSize = 1 + uElementSize;
    for (i = 0; i < lElements; i++)
        SetAt( (qBuf+(i*m_cElementSize)), i);
}


    // NOTE: Keep this in sync with drgx.h's SavePtrDrg()!!!
EXPORT DWORD OverheadOfSavePtrDrg( void )
{
    return sizeof(int);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\util\mmx.cpp ===
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <mmx.h>

	// Define or undef the following to allow
	// HKCU\Software\Microsoft\Internet Explorer  "TestMMX"=DWORD
	// We logical AND this reg value with fIsMMX.
#define TEST_MMX

const  int  s_mmxvaruninit = 0xabcd;
static BOOL s_fIsMMX       = s_mmxvaruninit;

// ----------------------------------------------------------------------------------------

__declspec(dllexport)  BOOL    IsMMXCpu( void )
{

    if( s_mmxvaruninit == s_fIsMMX )
    {
		BOOL   fIsMMX = FALSE;

#if _M_IX86 >= 300  // INTEL TARGET
        __try               // THIS REQUIRES THE CRT
        {        
                // The 0x0fA2 opcode was a late addtion to the 486
                // Some 486 and all 386 chips will not have it.
                // Doubt it's emulated.  Execution on these chips will 
                // raise (and handle) EXCEPTION_ILLEGAL_INSTRUCTION.
		    #define _cpuid _emit 0x0f _asm _emit 0xa2
		    _asm {
			    mov eax,1
			    _cpuid
			    and edx, 00800000h
			    mov fIsMMX, edx
		    } // end asm
        }

        __except( EXCEPTION_EXECUTE_HANDLER )
        {            
            fIsMMX = FALSE;  // No 0x0fA2 opcode?  No MMX either!
        }
#endif // END _M_IX86 INTEL TARGET


#ifdef TEST_MMX
		HKEY  hkeyIE;
		if( ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_USER,
				   TEXT("Software\\Microsoft\\Internet Explorer"),
				   0u, KEY_READ, &hkeyIE ) )
		{
			DWORD  dwVal = TRUE;
			DWORD  dwType = REG_DWORD;
			DWORD  dwSize = sizeof(dwVal);

			if ( ERROR_SUCCESS == 
				 RegQueryValueEx( hkeyIE, 
								  TEXT("TestMMX"), 
								  NULL, 
								  &dwType, 
								  reinterpret_cast<BYTE*>(&dwVal),
								  &dwSize ) )
			{
				fIsMMX = fIsMMX && dwVal;
			}
		}
#endif // TEST_MMX

        s_fIsMMX = fIsMMX;
    }

    return s_fIsMMX;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\util\mathwrap.cpp ===
#include "math.h"
#include "utilpre.h"
#include "utils.h"
#include "otrig.h"
#include "mathwrap.h"

#pragma optimize( "agt", on )
#pragma intrinsic( sqrt, sin, cos )
#pragma intrinsic( pow )    // not a true intrinsic form, 
                            // but loads FP registes directly


OTrig CMathWrapper::s_otrig;

CMathWrapper::CMathWrapper (void)
{
}

CMathWrapper::~CMathWrapper (void)
{
}

float
CMathWrapper::Pow (double x, double y)
{
	return (float)pow(x, y);
}

float  __fastcall
CMathWrapper::Sqrt (float x)
{
	return (float)sqrt(x);
}

float	__fastcall
CMathWrapper::SinDeg(float	fltAngle)
{
	return s_otrig.Sin(fltAngle);
}

float	__fastcall
CMathWrapper::CosDeg(float	fltAngle)
{
	return s_otrig.Cos(fltAngle);
}

float	__fastcall
CMathWrapper::SinDeg(long	lAngleOneTenths)
{
	return s_otrig.Sin(lAngleOneTenths);
}

float	__fastcall
CMathWrapper::CosDeg(long lAngleOneTenths)
{
	return s_otrig.Cos(lAngleOneTenths);
}


float	__fastcall
CMathWrapper::SinDegWrap(float	fltAngle)
{
	return s_otrig.SinWrap(fltAngle);
}

float	__fastcall
CMathWrapper::CosDegWrap(float	fltAngle)
{
	return s_otrig.CosWrap(fltAngle);
}

float	__fastcall
CMathWrapper::SinDegWrap(long	lAngleOneTenths)
{
	return s_otrig.SinWrap(lAngleOneTenths);
}

float	__fastcall
CMathWrapper::CosDegWrap(long lAngleOneTenths)
{
	return s_otrig.CosWrap(lAngleOneTenths);
}


double __fastcall
CMathWrapper::SinRad (double dblRads)
{
	return ::sin(dblRads);
}

double __fastcall
CMathWrapper::CosRad (double dblRads)
{
	return ::cos(dblRads);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\util\memlayer.cpp ===
/*=========================================================================*\

    File    : MEMMAN.CPP
    Purpose : CMemManager Class Implementation
    Author  : Michael Byrd
    Date    : 07/10/96

\*=========================================================================*/

#include "UtilPre.h"
#include <minmax.h>

/*=========================================================================*\
     Global Variables:
\*=========================================================================*/

// Global instance of memory manager (MUST BE GLOBAL!)
CMemManager CMemManager::g_CMemManager;

/*=========================================================================*\
     Single entry point for external debugging:
\*=========================================================================*/

VOID EXPORT WINAPI ExternalDumpAllocations(LPSTR lpstrFilename)
{
    CMemManager::DumpAllocationsGlb(lpstrFilename);
}

/*=========================================================================*\
     CMemUser Class:
\*=========================================================================*/

EXPORT CMemUser::CMemUser(void)
{
    CMemManager::RegisterMemUserGlb(this);
}

/*=========================================================================*/

EXPORT CMemUser::~CMemUser(void)
{
    CMemManager::UnRegisterMemUserGlb(this);
}

/*=========================================================================*/

LPMEMBLOCK EXPORT CMemUser::AllocBuffer(DWORD dwBytesToAlloc, WORD wFlags)
{
    LPMEMBLOCK lpResult = (LPMEMBLOCK)NULL;

    return lpResult;
}

/*=========================================================================*/

void EXPORT CMemUser::FreeBuffer(LPMEMBLOCK lpMemBlock)
{
}

/*=========================================================================*/

LPVOID EXPORT CMemUser::LockBuffer(LPMEMBLOCK lpMemBlock)
{
    LPVOID lpResult = (LPVOID)NULL;

    return lpResult;
}

/*=========================================================================*/

void EXPORT CMemUser::UnLockBuffer(LPMEMBLOCK lpMemBlock)
{
}

/*=========================================================================*/

BOOL EXPORT CMemUser::NotifyMemUser(LPMEMNOTIFY lpMemNotify)
{
    BOOL fResult = FALSE;

    return fResult;
}

/*=========================================================================*\
     CMemManager Class:
\*=========================================================================*/

EXPORT CMemManager::CMemManager(void)
{
    // Zero out our member variables...
    m_iNumHeaps     = 0;
    m_lpHeapHeader  = (LPHEAPHEADER)NULL;

    m_iNumMemUsers  = 0;
    m_lpMemUserInfo = (LPMEMUSERINFO)NULL;

    m_iNumMemBlocks = 0;
    m_lplpMemBlocks = (LPMEMBLOCK *)NULL;

    m_iMemBlockFree = 0;

    // Initialize the critical sections...
    InitializeCriticalSection(&m_CriticalHeap);
    InitializeCriticalSection(&m_CriticalMemUser);
    InitializeCriticalSection(&m_CriticalMemBlock);

    // The m_lpMemHeader, m_lpMemUserInfo, and m_lplpMemBlocks arrays
    // are allocated on the default process heap:
    m_handleProcessHeap = GetProcessHeap();

    // Create the "Standard" size heaps...
    CreateHeap(  16);
    CreateHeap(  32);
    CreateHeap(  64);
    CreateHeap( 128);
    CreateHeap( 256);
    CreateHeap( 512);
    CreateHeap(1024);
    CreateHeap(2048);
    CreateHeap(4096);
    CreateHeap(8192);
}

/*=========================================================================*/

EXPORT CMemManager::~CMemManager(void)
{
    // Free up the buffers that we allocated...
    Cleanup();

    // Get rid of the critical sections...
    DeleteCriticalSection(&m_CriticalHeap);
    DeleteCriticalSection(&m_CriticalMemUser);
    DeleteCriticalSection(&m_CriticalMemBlock);
}

/*=========================================================================*/

void CMemManager::Cleanup(void)
{
    int iItemIndex=0;

#ifdef _DEBUG
    // Dump a list of the allocations...
    DumpAllocations(NULL);
#endif // _DEBUG

    // Free all of the currently allocated CMemUser's first...
    EnterCriticalSection(&m_CriticalMemUser);
    LeaveCriticalSection(&m_CriticalMemUser);

    // Free all of the currently allocated LPMEMBLOCK's next...
    EnterCriticalSection(&m_CriticalMemBlock);

    // Release the memory from the proper heap...
    for(iItemIndex=0;iItemIndex<m_iNumMemBlocks;iItemIndex++)
    {
        LPMEMBLOCK lpCurrentMemBlock = m_lplpMemBlocks[iItemIndex];

        if (lpCurrentMemBlock)
        {
            FreeBufferMemBlock(lpCurrentMemBlock);

            // Prevent the code below from accessing bogus pointers!
            if (lpCurrentMemBlock->wFlags & MEM_SUBALLOC)
                m_lplpMemBlocks[iItemIndex] = NULL;
        }
    }

    // Now free the memory blocks that are not sub-allocations...
    for(iItemIndex=0;iItemIndex<m_iNumMemBlocks;iItemIndex++)
    {
        LPMEMBLOCK lpCurrentMemBlock = m_lplpMemBlocks[iItemIndex];

        if (lpCurrentMemBlock && ((lpCurrentMemBlock->wFlags & MEM_SUBALLOC) == 0))
        {
            // Kill the MEMBLOCK structure that we allocated...
            HeapFree(
                m_handleProcessHeap,
                (DWORD)0,
                lpCurrentMemBlock);
        }

        m_lplpMemBlocks[iItemIndex] = NULL;
    }

    // Now kill the array of memblock pointers...
    m_iNumMemBlocks = 0;
    HeapFree(
        m_handleProcessHeap,
        (DWORD)0,
        m_lplpMemBlocks);
    m_lplpMemBlocks = NULL;

    LeaveCriticalSection(&m_CriticalMemBlock);

    // Free all of the currently allocated HEAPBLOCK's last...
    EnterCriticalSection(&m_CriticalHeap);
    for(iItemIndex=0;iItemIndex<m_iNumHeaps;iItemIndex++)
    {
        LPHEAPHEADER lpHeapHeader = &m_lpHeapHeader[iItemIndex];

        if (lpHeapHeader->fInUse && lpHeapHeader->handleHeap)
        {
            if (HeapDestroy(lpHeapHeader->handleHeap))
            {
                lpHeapHeader->fInUse     = FALSE;
                lpHeapHeader->handleHeap = (HANDLE)NULL;
            }
        }
    }

    // Now kill the array of HEAPHEADERs
    m_iNumHeaps = 0;
    HeapFree(
        m_handleProcessHeap,
        (DWORD)0,
        m_lpHeapHeader);
    m_lpHeapHeader = NULL;

    LeaveCriticalSection(&m_CriticalHeap);
}

/*=========================================================================*/

BOOL CMemManager::CreateHeap(DWORD dwHeapBlockSize)
{
    BOOL fResult = FALSE;
    BOOL fDone   = FALSE;

    EnterCriticalSection(&m_CriticalHeap);

    while(!fDone)
    {
        // Look through the list if we are not done...
        if (m_iNumHeaps && m_lpHeapHeader)
        {
            int iHeapIndex = 0;

            for(iHeapIndex=0;iHeapIndex<m_iNumHeaps;iHeapIndex++)
            {
                LPHEAPHEADER lpHeapHeader = &m_lpHeapHeader[iHeapIndex];

                if (!lpHeapHeader->fInUse)
                {
                    fDone = TRUE;

                    // Create the new heap...
                    lpHeapHeader->handleHeap = HeapCreate(
                        (DWORD)0,
                        (dwHeapBlockSize * HEAPINITIALITEMCOUNT),
                        (DWORD)0);

                    if (lpHeapHeader->handleHeap)
                    {
                        lpHeapHeader->fInUse           = TRUE;
                        lpHeapHeader->dwBlockAllocSize = dwHeapBlockSize;
                        lpHeapHeader->iNumBlocks       = 0; // Informational only

                        fResult = TRUE;
                    }
                    else
                    {
                        // We could not create the heap!
                        fDone = TRUE;
                    }

                    // Break out of the for loop...
                    break;
                }
            }
        }

        // We haven't finished yet...
        if (!fDone)
        {
            if (!m_iNumHeaps || !m_lpHeapHeader)
            {
                // We haven't allocated the array yet!
                m_lpHeapHeader = (LPHEAPHEADER)HeapAlloc(
                    m_handleProcessHeap,
                    HEAP_ZERO_MEMORY,
                    sizeof(HEAPHEADER) * MEMHEAPGROW);

                if (m_lpHeapHeader)
                {
                    m_iNumHeaps = MEMHEAPGROW;
                }
                else
                {
                    // Break out of the while loop...
                    fDone = TRUE;
                }
            }
            else
            {
                LPHEAPHEADER lpHeapHeader = (LPHEAPHEADER)NULL;

                // We have a HEAPHEADER array,  but no empty entries,
                // So increase the size of the m_lpHeapHeader array!

                lpHeapHeader = (LPHEAPHEADER)HeapReAlloc(
                    m_handleProcessHeap,
                    HEAP_ZERO_MEMORY,
                    m_lpHeapHeader,
                    sizeof(HEAPHEADER) * (m_iNumHeaps + MEMHEAPGROW));

                if (lpHeapHeader)
                {
                    m_lpHeapHeader = lpHeapHeader;
                    m_iNumHeaps += MEMHEAPGROW;
                }
                else
                {
                    // Break out of the while loop...
                    fDone = TRUE;
                }
            }
        }
    }

    LeaveCriticalSection(&m_CriticalHeap);

    return fResult;
}

/*=========================================================================*/

BOOL CMemManager::DestroyHeap(HANDLE handleHeap)
{
    BOOL fResult = FALSE;

    EnterCriticalSection(&m_CriticalHeap);

    if (handleHeap && m_iNumHeaps && m_lpHeapHeader)
    {
        int iHeapIndex = 0;

        for(iHeapIndex=0;iHeapIndex<m_iNumHeaps;iHeapIndex++)
        {
            LPHEAPHEADER lpHeapHeader = &m_lpHeapHeader[iHeapIndex];

            if (lpHeapHeader->fInUse && (lpHeapHeader->handleHeap == handleHeap))
            {
                Proclaim(lpHeapHeader->iNumBlocks == 0);

                // We can only destroy the heap if it is empty!
                if (lpHeapHeader->iNumBlocks == 0)
                {
                    if (HeapDestroy(handleHeap))
                    {
                        lpHeapHeader->fInUse     = FALSE;
                        lpHeapHeader->handleHeap = (HANDLE)NULL;

                        fResult = TRUE;
                    }
                }

                break;
            }
        }
    }

    LeaveCriticalSection(&m_CriticalHeap);

    return fResult;
}

/*=========================================================================*/

int CMemManager::FindHeap(DWORD dwAllocationSize, LPHEAPHEADER lpHeapHeader)
{
    int iResult = -1;
    DWORD dwMinWasted = (DWORD)0x80000000; // Must be bigger than object!

    // Prevent other heap management functions from intercepting us...
    EnterCriticalSection(&m_CriticalHeap);

    // This will find the heap that wastes the least amount of space...
    if (dwAllocationSize && m_iNumHeaps && m_lpHeapHeader && lpHeapHeader)
    {
        int iHeapIndex = 0;

        for(iHeapIndex = 0;iHeapIndex<m_iNumHeaps;iHeapIndex++)
        {
            LPHEAPHEADER lpCurrentHeapHeader = &m_lpHeapHeader[iHeapIndex];

            if (lpCurrentHeapHeader->fInUse && lpCurrentHeapHeader->handleHeap)
            {
                if (lpCurrentHeapHeader->dwBlockAllocSize >= dwAllocationSize)
                {
                    DWORD dwWasted = lpCurrentHeapHeader->dwBlockAllocSize - dwAllocationSize;

                    if (dwWasted < dwMinWasted)
                    {
                        iResult = iHeapIndex;
                        dwMinWasted = dwWasted;

                        // Early-out for exact match!
                        if (dwWasted == 0)
                            break;
                    }
                }
            }
        }

        if (iResult >= 0)
            *lpHeapHeader = m_lpHeapHeader[iResult];
    }

    // Allow heap management to continue...
    LeaveCriticalSection(&m_CriticalHeap);

    return iResult;
}

/*=========================================================================*/

LPVOID CMemManager::AllocFromHeap(int iHeapIndex, DWORD dwAllocationSize)
{
    LPVOID lpResult = (LPVOID)NULL;

#ifdef _DEBUG
    if (FFailMemFailSim())
        return lpResult;
#endif // _DEBUG

    // Prevent other heap management functions from intercepting us...
    EnterCriticalSection(&m_CriticalHeap);

    if (m_iNumHeaps && m_lpHeapHeader && iHeapIndex >=0 && iHeapIndex < m_iNumHeaps)
    {
        LPHEAPHEADER lpCurrentHeapHeader = &m_lpHeapHeader[iHeapIndex];

        if (lpCurrentHeapHeader->fInUse && lpCurrentHeapHeader->handleHeap)
        {
            if (lpCurrentHeapHeader->dwBlockAllocSize >= dwAllocationSize)
            {
                // Allocate the memory from the selected heap...
                lpResult = HeapAlloc(
                    lpCurrentHeapHeader->handleHeap,
                    HEAP_ZERO_MEMORY,
                    lpCurrentHeapHeader->dwBlockAllocSize+ALLOC_EXTRA);

                if (lpResult)
                {
                    // Make sure this heap's object count is incremented...
                    lpCurrentHeapHeader->iNumBlocks++;
                }
            }
        }
    }

    // Allow heap management to continue...
    LeaveCriticalSection(&m_CriticalHeap);

    return lpResult;
}

/*=========================================================================*/

BOOL CMemManager::FreeFromHeap(int iHeapIndex, LPVOID lpBuffer)
{
    BOOL fResult = FALSE;

    // Prevent other heap management functions from intercepting us...
    EnterCriticalSection(&m_CriticalHeap);

    if (lpBuffer && m_iNumHeaps && m_lpHeapHeader && (iHeapIndex >= 0) && (iHeapIndex < m_iNumHeaps))
    {
        LPHEAPHEADER lpHeapHeader = &m_lpHeapHeader[iHeapIndex];

        if (lpHeapHeader->fInUse && lpHeapHeader->handleHeap)
        {
            // Allocate the memory from the selected heap...
            fResult = HeapFree(
                lpHeapHeader->handleHeap,
                (DWORD)0,
                lpBuffer);

            if (fResult)
            {
                // Make sure this heap's object count is decremented...
                lpHeapHeader->iNumBlocks--;
            }
        }
    }

    // Allow heap management to continue...
    LeaveCriticalSection(&m_CriticalHeap);

    return fResult;
}

/*=========================================================================*/

BOOL EXPORT CMemManager::RegisterMemUser(CMemUser *lpMemUser)
{
    BOOL fResult = FALSE;
    BOOL fDone   = FALSE;

#ifdef _DEBUG
    if (FFailMemFailSim())
        return fResult;
#endif // _DEBUG

    EnterCriticalSection(&m_CriticalMemUser);

    while(!fDone)
    {
        // Look through the list if we are not done...
        if (m_iNumMemUsers && m_lpMemUserInfo)
        {
            int iMemUserIndex = 0;

            for(iMemUserIndex=0;iMemUserIndex<m_iNumHeaps;iMemUserIndex++)
            {
                LPMEMUSERINFO lpMemUserInfo = &m_lpMemUserInfo[iMemUserIndex];

                if (!lpMemUserInfo->fInUse)
                {
                    fDone = TRUE;
                    fResult = TRUE;

                    // Fill in the info about this mem user...
                    lpMemUserInfo->fInUse     = TRUE;
                    lpMemUserInfo->dwThreadID = GetCurrentThreadId();
                    lpMemUserInfo->lpMemUser  = lpMemUser;

                    // Break out of the for loop...
                    break;
                }
            }
        }

        // We haven't finished yet...
        if (!fDone)
        {
            if (!m_iNumMemUsers || !m_lpMemUserInfo)
            {
                // We haven't allocated the array yet!
                m_lpMemUserInfo = (LPMEMUSERINFO)HeapAlloc(
                    m_handleProcessHeap,
                    HEAP_ZERO_MEMORY,
                    sizeof(MEMUSERINFO) * MEMUSERGROW);

                if (m_lpMemUserInfo)
                {
                    m_iNumMemUsers = MEMUSERGROW;
                }
                else
                {
                    // Break out of the while loop...
                    fDone = TRUE;
                }
            }
            else
            {
                LPMEMUSERINFO lpMemUserInfo = (LPMEMUSERINFO)NULL;

                // We have a MEMUSERINFO array,  but no empty entries,
                // So increase the size of the m_lpMemUserInfo array!

                lpMemUserInfo = (LPMEMUSERINFO)HeapReAlloc(
                    m_handleProcessHeap,
                    HEAP_ZERO_MEMORY,
                    m_lpMemUserInfo,
                    sizeof(MEMUSERINFO) * (m_iNumMemUsers + MEMUSERGROW));

                if (lpMemUserInfo)
                {
                    m_lpMemUserInfo = lpMemUserInfo;
                    m_iNumMemUsers += MEMUSERGROW;
                }
                else
                {
                    // Break out of the while loop...
                    fDone = TRUE;
                }
            }
        }
    }

    LeaveCriticalSection(&m_CriticalMemUser);

    return fResult;
}

/*=========================================================================*/

BOOL EXPORT CMemManager::UnRegisterMemUser(CMemUser *lpMemUser)
{
    BOOL fResult = FALSE;

    EnterCriticalSection(&m_CriticalMemUser);

    if (lpMemUser && m_iNumMemUsers && m_lpMemUserInfo)
    {
        int iMemUserIndex = 0;

        for(iMemUserIndex = 0;iMemUserIndex < m_iNumMemUsers;iMemUserIndex++)
        {
            LPMEMUSERINFO lpMemUserInfo = &m_lpMemUserInfo[iMemUserIndex];

            // We found the CMemUser!
            if (lpMemUserInfo->fInUse && (lpMemUserInfo->lpMemUser == lpMemUser))
            {
                Proclaim(lpMemUserInfo->iNumBlocks == 0);

                if (lpMemUserInfo->iNumBlocks == 0)
                {
                    lpMemUserInfo->fInUse     = FALSE;
                    lpMemUserInfo->lpMemUser  = (CMemUser *)NULL;
                    lpMemUserInfo->dwThreadID = (DWORD)0;

                    fResult = TRUE;
                }
                else
                {
                    // We MUST set this to NULL to prevent notification
                    // callback from getting called.
                    lpMemUserInfo->lpMemUser = (CMemUser *)NULL;
                }

                break;
            }
        }
    }

    LeaveCriticalSection(&m_CriticalMemUser);

    return fResult;
}

/*=========================================================================*/

LPMEMBLOCK CMemManager::AllocMemBlock(int far *piIndex)
{
    LPMEMBLOCK lpResult = (LPMEMBLOCK)NULL;
    BOOL fDone = FALSE;

#ifdef _DEBUG
    if (FFailMemFailSim())
        return lpResult;
#endif // _DEBUG

    if (!piIndex)
        return lpResult;

    EnterCriticalSection(&m_CriticalMemBlock);

    while(!fDone)
    {
        // Look through the list if we are not done...
        if (m_iNumMemBlocks && m_lplpMemBlocks)
        {
            int iMemBlockIndex = 0;

            // Look for a free mem block...
            for(iMemBlockIndex=m_iMemBlockFree;iMemBlockIndex<m_iNumMemBlocks;iMemBlockIndex++)
            {
                LPMEMBLOCK lpMemBlock = m_lplpMemBlocks[iMemBlockIndex];

                if (!lpMemBlock->fInUse)
                {
                    if (!fDone)
                    {
                        fDone    = TRUE;
                        lpResult = lpMemBlock;

                        // Fill in the info about this mem block...
                        lpMemBlock->fInUse          = TRUE;
                        lpMemBlock->lpData          = NULL;
                        lpMemBlock->dwSize          = (DWORD)0;
                        lpMemBlock->wFlags          = (lpMemBlock->wFlags & MEM_INTERNAL_FLAGS);
                        lpMemBlock->wLockCount      = 0;
                        lpMemBlock->iHeapIndex      = 0;
                        lpMemBlock->iMemUserIndex   = -1;
#ifdef _DEBUG
                        lpMemBlock->iLineNum        = 0;
                        lpMemBlock->rgchFileName[0] = 0;
#endif // _DEBUG
                        *piIndex = iMemBlockIndex;
                    }
                    else
                    {
                        // Set the min mark...
                        m_iMemBlockFree = iMemBlockIndex;
                        break;
                    }
                }
            }
        }

        // We haven't finished yet...
        if (!fDone)
        {
            LPMEMBLOCK lpNewMemBlocks = (LPMEMBLOCK)NULL;

            // We ALWAYS need to allocate the MEMBLOCK's here...
            lpNewMemBlocks = (LPMEMBLOCK)HeapAlloc(
                m_handleProcessHeap,
                HEAP_ZERO_MEMORY,
                sizeof(MEMBLOCK) * MEMBLOCKGROW);

            if (lpNewMemBlocks)
            {
                if (!m_iNumMemBlocks || !m_lplpMemBlocks)
                {
                    // We haven't allocated the array yet!
                    m_lplpMemBlocks = (LPMEMBLOCK *)HeapAlloc(
                        m_handleProcessHeap,
                        HEAP_ZERO_MEMORY,
                        sizeof(LPMEMBLOCK) * MEMBLOCKGROW);

                    if (!m_lplpMemBlocks)
                    {
                        // Break out of the while loop...
                        fDone = TRUE;
                    }
                }
                else
                {
                    LPMEMBLOCK *lplpMemBlock = (LPMEMBLOCK *)NULL;

                    // We have a MEMBLOCK array,  but no empty entries,
                    // So increase the size of the m_lplpMemBlocks array!

                    lplpMemBlock = (LPMEMBLOCK *)HeapReAlloc(
                        m_handleProcessHeap,
                        HEAP_ZERO_MEMORY,
                        m_lplpMemBlocks,
                        sizeof(LPMEMBLOCK) * (m_iNumMemBlocks + MEMBLOCKGROW));

                    if (lplpMemBlock)
                    {
                        m_lplpMemBlocks = lplpMemBlock;
                    }
                    else
                    {
                        // Break out of the while loop...
                        fDone = TRUE;
                    }
                }

                // We should only do this if the allocations succeeded!
                if (!fDone)
                {
                    int iMemBlockIndex = 0;

                    // Fill in the pointer array...
                    for(iMemBlockIndex=0;iMemBlockIndex<MEMBLOCKGROW;iMemBlockIndex++)
                    {
                        LPMEMBLOCK lpMemBlock = &lpNewMemBlocks[iMemBlockIndex];

                        m_lplpMemBlocks[iMemBlockIndex+m_iNumMemBlocks] =
                            lpMemBlock;

                        // Initialize the flags...
                        if (iMemBlockIndex == 0)
                            lpMemBlock->wFlags = 0;
                        else
                            lpMemBlock->wFlags = MEM_SUBALLOC;
                    }

                    // Set the index of the first free block...
                    m_iMemBlockFree = m_iNumMemBlocks;

                    m_iNumMemBlocks += MEMBLOCKGROW;
                }
                else
                {
                    // Free the MEMBLOCK array that we allocated!
                    HeapFree(
                        m_handleProcessHeap,
                        (DWORD)0,
                        lpNewMemBlocks);
                }
            }
            else
            {
                // Couldn't allocate the MEMBLOCK structures!
                fDone = TRUE;
            }
        }
    }

    LeaveCriticalSection(&m_CriticalMemBlock);

    return lpResult;
}

/*=========================================================================*/

BOOL CMemManager::FreeMemBlock(LPMEMBLOCK lpMemBlock, int iMemBlockIndex)
{
    BOOL fResult = FALSE;

    EnterCriticalSection(&m_CriticalMemBlock);

    if (lpMemBlock && m_iNumMemBlocks && m_lplpMemBlocks)
    {
        // The MEMBLOCK always comes from our list...
        if (lpMemBlock->fInUse)
        {
            Proclaim(lpMemBlock->wLockCount == 0);

            if (iMemBlockIndex == -1)
            {
                int iBlockIndex=0;

                for(iBlockIndex = 0;iBlockIndex < m_iNumMemBlocks;iBlockIndex++)
                {
                    if (lpMemBlock == m_lplpMemBlocks[iBlockIndex])
                    {
                        iMemBlockIndex = iBlockIndex;
                        break;
                    }
                }
            }

			Proclaim(iMemBlockIndex >= 0);

            if (iMemBlockIndex < m_iMemBlockFree &&
                iMemBlockIndex >= 0)
            {
                // reset the low-water mark...
                m_iMemBlockFree = iMemBlockIndex;
            }

            if (lpMemBlock->wLockCount == 0)
            {
                lpMemBlock->fInUse          = FALSE;
                lpMemBlock->lpData          = NULL;
                lpMemBlock->dwSize          = (DWORD)0;
                lpMemBlock->wFlags          = (lpMemBlock->wFlags & MEM_INTERNAL_FLAGS);
                lpMemBlock->wLockCount      = 0;
                lpMemBlock->iHeapIndex      = 0;
                lpMemBlock->iMemUserIndex   = -1;
#ifdef _DEBUG
                lpMemBlock->iLineNum        = 0;
                lpMemBlock->rgchFileName[0] = 0;
#endif // _DEBUG

                fResult = TRUE;
            }
        }
    }

    LeaveCriticalSection(&m_CriticalMemBlock);

    return fResult;
}

/*=========================================================================*/

LPMEMBLOCK CMemManager::FindMemBlock(LPVOID lpBuffer, int *piIndex)
{
    LPMEMBLOCK lpResult = (LPMEMBLOCK)NULL;

    EnterCriticalSection(&m_CriticalMemBlock);

    if (lpBuffer && m_iNumMemBlocks && m_lplpMemBlocks)
    {
        LPBYTE lpByte = (LPBYTE)lpBuffer;
        int iRetIndex = -1;

        lpByte -= ALLOC_EXTRA;

        iRetIndex = *(int *)lpByte;

        if (iRetIndex <= m_iNumMemBlocks && iRetIndex >= 0)
        {
            LPMEMBLOCK lpMemBlock = m_lplpMemBlocks[iRetIndex];
            LPBYTE     lpData = (LPBYTE)lpMemBlock->lpData;

            lpData += ALLOC_EXTRA;

            if (lpData == lpBuffer)
            {
                lpResult = lpMemBlock;
            }
        }

        Proclaim(lpResult != NULL);

        if (piIndex)
            *piIndex = iRetIndex;
    }

    LeaveCriticalSection(&m_CriticalMemBlock);

    return lpResult;
}

/*=========================================================================*/

LPVOID EXPORT CMemManager::AllocBuffer(
    DWORD dwBytesToAlloc,
#ifdef _DEBUG
    WORD  wFlags,
    int   iLine,
    LPSTR lpstrFile)
#else // !_DEBUG
    WORD  wFlags)
#endif // !_DEBUG
{
    LPVOID lpResult = (LPVOID)NULL;

#ifdef _DEBUG
    if (FFailMemFailSim())
        return lpResult;
#endif // _DEBUG

    // Restrict flags to externally available
    wFlags &= MEM_EXTERNAL_FLAGS;

    if (dwBytesToAlloc)
    {
        int iHeapIndex = 0;
        HEAPHEADER heapHeader;
        LPBYTE lpByte = (LPBYTE)NULL;

        // Find the proper heap to allocate from...
        iHeapIndex = FindHeap(dwBytesToAlloc, &heapHeader);

        if (iHeapIndex >= 0)
        {
            // Allocate the memory for the object from the selected heap...
            lpByte = (LPBYTE)AllocFromHeap(iHeapIndex, dwBytesToAlloc);
        }
        else
        {
            // Allocate the memory for the object from the process heap...
            lpByte = (LPBYTE)HeapAlloc(
                m_handleProcessHeap,
                HEAP_ZERO_MEMORY,
                dwBytesToAlloc+ALLOC_EXTRA);
        }

        if (lpByte)
        {
            int iIndexBlock = -1;
            LPMEMBLOCK lpMemBlock = AllocMemBlock(&iIndexBlock);

            if (lpMemBlock && iIndexBlock >= 0)
            {
                lpMemBlock->lpData        = lpByte;
                lpMemBlock->dwSize        = dwBytesToAlloc;
                lpMemBlock->wFlags        = (lpMemBlock->wFlags & MEM_INTERNAL_FLAGS) | wFlags;
                lpMemBlock->wLockCount    = 0;
                lpMemBlock->iHeapIndex    = iHeapIndex;
                lpMemBlock->iMemUserIndex = -1;
#ifdef _DEBUG
                lpMemBlock->iLineNum      = iLine;
                lstrcpyn(lpMemBlock->rgchFileName, lpstrFile, MAX_SOURCEFILENAME);
#endif // _DEBUG

                *(int *)lpByte = iIndexBlock;
                lpByte += ALLOC_EXTRA;

                lpResult = (LPVOID)lpByte;
            }
            else
            {
                if (iHeapIndex >= 0)
                {
                    FreeFromHeap(iHeapIndex, lpByte);
                }
                else
                {
                    HeapFree(
                        m_handleProcessHeap,
                        (DWORD)0,
                        lpByte);
                }
            }
        }
    }

    return lpResult;
}

/*=========================================================================*/

LPVOID EXPORT CMemManager::ReAllocBuffer(
    LPVOID lpBuffer,
    DWORD dwBytesToAlloc,
#ifdef _DEBUG
    WORD  wFlags,
    int   iLine,
    LPSTR lpstrFile)
#else // !_DEBUG
    WORD  wFlags)
#endif // !_DEBUG
{
    LPVOID lpResult = NULL;

#ifdef _DEBUG
    if (FFailMemFailSim())
        return lpResult;
#endif // _DEBUG

    // Restrict flags to externally available
    wFlags &= MEM_EXTERNAL_FLAGS;

    if (lpBuffer && dwBytesToAlloc)
    {
        int iIndexBlock = -1;
        LPMEMBLOCK lpMemBlock = FindMemBlock(lpBuffer, &iIndexBlock);

        if (lpMemBlock && iIndexBlock >= 0)
        {
            int iHeapIndex = 0;
            HEAPHEADER heapHeader;
            LPBYTE lpByte = NULL;

            if (lpMemBlock->iHeapIndex >= 0)
            {
                // Get the heap info about this memory block...
                iHeapIndex = FindHeap(lpMemBlock->dwSize, &heapHeader);

                // No need to actually re-alloc (we have enough room already!)
                if ((iHeapIndex == lpMemBlock->iHeapIndex) &&
                    heapHeader.dwBlockAllocSize >= dwBytesToAlloc)
                {
                    lpByte = (LPBYTE)lpMemBlock->lpData;

                    lpByte += ALLOC_EXTRA;

                    lpResult = (LPVOID)lpByte;

                    // Re-zero the extra memory...
                    if (lpMemBlock->dwSize > dwBytesToAlloc)
                    {
                        lpByte += dwBytesToAlloc;

                        memset(lpByte, 0, (lpMemBlock->dwSize-dwBytesToAlloc));
                    }

                    lpMemBlock->dwSize = dwBytesToAlloc;

                    return lpResult;
                }
            }
            else
            {
                // Re-allocate from the current process heap!
                lpByte = (LPBYTE)HeapReAlloc(
                    m_handleProcessHeap,
                    HEAP_ZERO_MEMORY,
                    lpMemBlock->lpData,
                    dwBytesToAlloc+ALLOC_EXTRA);

                // Don't affect the memblock if the re-alloc fails!
                if (lpByte)
                {
                    lpMemBlock->lpData = (LPVOID)lpByte;
                    lpMemBlock->dwSize = dwBytesToAlloc;

                    lpByte += ALLOC_EXTRA;

                    lpResult = (LPVOID)lpByte;
                }

                return lpResult;
            }

            // Find the proper heap to allocate from...
            iHeapIndex = FindHeap(dwBytesToAlloc, &heapHeader);

            if (iHeapIndex >= 0)
            {
                // Allocate the memory for the object from the selected heap...
                lpByte = (LPBYTE)AllocFromHeap(iHeapIndex, dwBytesToAlloc);
            }
            else
            {
                // Allocate the memory for the object from the process heap...
                lpByte = (LPBYTE)HeapAlloc(
                    m_handleProcessHeap,
                    HEAP_ZERO_MEMORY,
                    dwBytesToAlloc+ALLOC_EXTRA);
            }

            if (lpByte)
            {
                LPBYTE lpBase = (LPBYTE)lpByte;
                LPBYTE lpData = (LPBYTE)lpMemBlock->lpData;

                *(int *)lpByte = iIndexBlock;

                lpByte += ALLOC_EXTRA;
                lpData += ALLOC_EXTRA;

                // Copy the data...
                memcpy(lpByte, lpData, min(lpMemBlock->dwSize, dwBytesToAlloc));

                // Free the memory from the proper heap...
                if (lpMemBlock->iHeapIndex >= 0)
                {
                    FreeFromHeap(lpMemBlock->iHeapIndex, lpMemBlock->lpData);
                }
                else
                {
                    HeapFree(
                        m_handleProcessHeap,
                        (DWORD)0,
                        lpMemBlock->lpData);
                }

                // Remember the new allocation's info...
                lpMemBlock->iHeapIndex = iHeapIndex;
                lpMemBlock->lpData     = lpBase;
                lpMemBlock->dwSize     = dwBytesToAlloc;

                lpResult = lpByte;
            }
        }
    }

    return lpResult;
}

/*=========================================================================*/

void EXPORT CMemManager::FreeBufferMemBlock(LPMEMBLOCK lpMemBlock)
{
    if (lpMemBlock && lpMemBlock->fInUse)
    {
        // Free the memory from the proper heap...
        if (lpMemBlock->iHeapIndex >= 0)
        {
            FreeFromHeap(lpMemBlock->iHeapIndex, lpMemBlock->lpData);
        }
        else
        {
            HeapFree(
                m_handleProcessHeap,
                (DWORD)0,
                lpMemBlock->lpData);
        }

		// REVIEW PAULD - defer resetting fInUse until FreeMemBlock is called.
		// Since we're called in sequence (except from Cleanup), this
		// should not be a problem.
        lpMemBlock->lpData = NULL;
        lpMemBlock->dwSize = (DWORD)0;
    }
}

/*=========================================================================*/

void EXPORT CMemManager::FreeBuffer(LPVOID lpBuffer)
{
    if (lpBuffer)
    {
        int iIndexBlock = -1;
        LPMEMBLOCK lpMemBlock = FindMemBlock(lpBuffer, &iIndexBlock);

        FreeBufferMemBlock(lpMemBlock);

        // This clears out the block...
        FreeMemBlock(lpMemBlock, iIndexBlock);
    }
}

/*=========================================================================*/

DWORD EXPORT CMemManager::SizeBuffer(LPVOID lpBuffer)
{
    DWORD dwResult = 0;

    if (lpBuffer)
    {
        LPMEMBLOCK lpMemBlock = FindMemBlock(lpBuffer);

        if (lpMemBlock)
        {
            dwResult = lpMemBlock->dwSize;
        }
    }

    return dwResult;
}

/*=========================================================================*/

VOID EXPORT CMemManager::DumpHeapHeader(LPHEAPHEADER lpHeapHeader, FILE *fileOutput)
{
    char rgOutput[256];

    wsprintf(rgOutput, "HEAP(0x%08X);SIZE(0x%08X);COUNT(0x%08X) ===================================================\n",
        lpHeapHeader,
        lpHeapHeader->dwBlockAllocSize,
        lpHeapHeader->iNumBlocks);

    if (fileOutput)
        fwrite(rgOutput, 1, lstrlen(rgOutput), fileOutput);
    else
        OutputDebugString(rgOutput);
}

/*=========================================================================*/

VOID EXPORT CMemManager::DumpMemUserInfo(LPMEMUSERINFO lpMemUserInfo, FILE *fileOutput)
{
}

/*=========================================================================*/

VOID EXPORT CMemManager::DumpMemBlock(LPMEMBLOCK lpMemBlock, FILE *fileOutput)
{
    if (lpMemBlock)
    {
        char rgOutput[256];

#ifdef _DEBUG
        wsprintf(rgOutput, "MEM(0x%08X);DATA(0x%08X);SIZE(0x%08X);LINE;(%05d);FILE(%s)\n",
            lpMemBlock,
            lpMemBlock->lpData,
            lpMemBlock->dwSize,
            lpMemBlock->iLineNum,
            lpMemBlock->rgchFileName);
#else // !_DEBUG
        wsprintf(rgOutput, "MEM(0x%08X);DATA(0x%08X);SIZE(0x%08X)\n",
            lpMemBlock,
            lpMemBlock->lpData,
            lpMemBlock->dwSize);
#endif // !_DEBUG

        if (fileOutput)
            fwrite(rgOutput, 1, lstrlen(rgOutput), fileOutput);
        else
            OutputDebugString(rgOutput);
    }
}

/*=========================================================================*/

VOID EXPORT CMemManager::DumpAllocations(LPSTR lpstrFilename)
{
    FILE *fileOutput = (FILE *)NULL;
    int iItemIndex = 0;
    int iHeapIndex = 0;
    BOOL fProcessBlocks = FALSE;
    char rgOutput[256];

    if (lpstrFilename)
    {
        fileOutput = fopen(lpstrFilename, "w");

        // Just get out now...
        if (!fileOutput)
            return;
    }

    if (fileOutput)
        fwrite(rgOutput, 1, lstrlen(rgOutput), fileOutput);
    else
        OutputDebugString(rgOutput);

    EnterCriticalSection(&m_CriticalHeap);
    EnterCriticalSection(&m_CriticalMemBlock);

    for(iHeapIndex=0;iHeapIndex < m_iNumHeaps;iHeapIndex++)
    {
        LPHEAPHEADER lpHeapHeader = &m_lpHeapHeader[iHeapIndex];

        if (lpHeapHeader && lpHeapHeader->fInUse && lpHeapHeader->iNumBlocks)
        {
            DumpHeapHeader(lpHeapHeader, fileOutput);

            // Dump a readable list of the memory blocks...
            for(iItemIndex=0;iItemIndex < m_iNumMemBlocks;iItemIndex++)
            {
                LPMEMBLOCK lpMemBlock = m_lplpMemBlocks[iItemIndex];

                if (lpMemBlock->fInUse)
                {
                    if (lpMemBlock->iHeapIndex == iHeapIndex)
                        DumpMemBlock(lpMemBlock, fileOutput);

                    if (lpMemBlock->iHeapIndex == -1)
                        fProcessBlocks = TRUE;
                }
            }
        }
    }

    if (fProcessBlocks)
    {
        wsprintf(rgOutput, "HEAP(PROCESS) ===================================================\n");

        if (fileOutput)
            fwrite(rgOutput, 1, lstrlen(rgOutput), fileOutput);
        else
            OutputDebugString(rgOutput);

        // Dump a readable list of the memory blocks...
        for(iItemIndex=0;iItemIndex < m_iNumMemBlocks;iItemIndex++)
        {
            LPMEMBLOCK lpMemBlock = m_lplpMemBlocks[iItemIndex];

            if (lpMemBlock->fInUse && (lpMemBlock->iHeapIndex == -1))
                DumpMemBlock(lpMemBlock, fileOutput);
        }
    }

    LeaveCriticalSection(&m_CriticalMemBlock);
    LeaveCriticalSection(&m_CriticalHeap);

    if (fileOutput)
        fwrite(rgOutput, 1, lstrlen(rgOutput), fileOutput);
    else
        OutputDebugString(rgOutput);

    if (fileOutput)
        fclose(fileOutput);
}

/*=========================================================================*/

LPVOID EXPORT CMemManager::AllocBufferGlb(
    DWORD dwBytesToAlloc,
#ifdef _DEBUG
    WORD wFlags,
    int iLine,
    LPSTR lpstrFile)
#else // !_DEBUG
    WORD wFlags)
#endif // !_DEBUG
{
    return g_CMemManager.AllocBuffer(
        dwBytesToAlloc,
#ifdef _DEBUG
        wFlags,
        iLine,
        lpstrFile);
#else // !_DEBUG
        wFlags);
#endif // !_DEBUG
}

/*=========================================================================*/

LPVOID EXPORT CMemManager::ReAllocBufferGlb(
    LPVOID lpBuffer,
    DWORD  dwBytesToAlloc,
#ifdef _DEBUG
    WORD   wFlags,
    int    iLine,
    LPSTR  lpstrFile)
#else // !_DEBUG
    WORD   wFlags)
#endif // !_DEBUG
{
    return g_CMemManager.ReAllocBuffer(
        lpBuffer,
        dwBytesToAlloc,
#ifdef _DEBUG
        wFlags,
        iLine,
        lpstrFile);
#else // !_DEBUG
        wFlags);
#endif // !_DEBUG
}

/*=========================================================================*/

VOID EXPORT CMemManager::FreeBufferGlb(LPVOID lpBuffer)
{
    g_CMemManager.FreeBuffer(lpBuffer);
}

/*=========================================================================*/

DWORD EXPORT CMemManager::SizeBufferGlb(LPVOID lpBuffer)
{
    return g_CMemManager.SizeBuffer(lpBuffer);
}

/*=========================================================================*/

BOOL EXPORT CMemManager::RegisterMemUserGlb(CMemUser *lpMemUser)
{
    return g_CMemManager.RegisterMemUser(lpMemUser);
}

/*=========================================================================*/

BOOL EXPORT CMemManager::UnRegisterMemUserGlb(CMemUser *lpMemUser)
{
    return g_CMemManager.UnRegisterMemUser(lpMemUser);
}

/*=========================================================================*/

VOID EXPORT CMemManager::DumpAllocationsGlb(LPSTR lpstrFilename)
{
    g_CMemManager.DumpAllocations(lpstrFilename);
}

/*=========================================================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\util\otrig.cpp ===
/*+********************************************************
MODULE: OTRIG.CPP
AUTHOR: PhaniV
DATE: Jan 97

DESCRIPTION: Implements OTrig class which implements table look for
for sin and cos functions which are calculated at increments of 0.1 degree.
*********************************************************-*/
#include <math.h>
#include "utilpre.h"
#include "otrig.h"
#include "quickie.h"

#define PI          3.1415927f
#define PIINDEG     180.0f
#define PI2INDEG    360.0f
#define PI2         (PI * 2.0f)
#define PI2INDEGINV (1.0f / PI2INDEG)
#define ANGLEENTRIES (10.0f)

float OTrig::s_rgfltSin[cSinCosEntries];
float OTrig::s_rgfltCos[cSinCosEntries];

BOOL OTrig::s_fCalculated = FALSE;

#pragma intrinsic (sin, cos)
#pragma optimize( "agt", on )

// Precalculate the sin and cos table for look up.
void OTrig::PreCalcRgSinCos(void)
{
    float fltAngle = 0.0f;
    float fltAngleInc = PI2/((float)(cSinCosEntries - 1));
    int   iSinCos = 0;

    if(s_fCalculated)
        return;

    while(fltAngle <= PI2)
    {
        s_rgfltSin[iSinCos] = (float)::sin((double)fltAngle);
        s_rgfltCos[iSinCos] = (float)::cos((double)fltAngle);
        fltAngle += fltAngleInc;
        iSinCos++;
    }

    // Now close the circle.
    s_rgfltSin[cSinCosEntries - 1] = s_rgfltSin[0];
    s_rgfltCos[cSinCosEntries - 1] = s_rgfltCos[0];
    s_fCalculated = TRUE;
}

EXPORT OTrig::OTrig(void)
{
    if(!s_fCalculated)
        PreCalcRgSinCos();
}

EXPORT float __fastcall OTrig::Sin(float fltAngle)
{    
    Proclaim( (fltAngle >= 0.0f) && (fltAngle <= 360.0f) );
    return s_rgfltSin[Float2Int(fltAngle * ANGLEENTRIES)];
}

EXPORT float __fastcall OTrig::Cos(float fltAngle)
{
    Proclaim( (fltAngle >= 0.0f) && (fltAngle <= 360.0f) );
    return s_rgfltCos[Float2Int(fltAngle * ANGLEENTRIES)];
}

EXPORT float  __fastcall OTrig::Sin(long lAngleOneTenths)
{
    Proclaim( (lAngleOneTenths >= 0) && (lAngleOneTenths <cSinCosEntries) );
    return s_rgfltSin[lAngleOneTenths];
}

EXPORT float  __fastcall OTrig::Cos(long lAngleOneTenths)
{
    Proclaim( (lAngleOneTenths >= 0) && (lAngleOneTenths <cSinCosEntries) );
    return  s_rgfltCos[lAngleOneTenths];
}

// ==================================================

EXPORT float __fastcall OTrig::SinWrap(float fltAngle)
{
    while(fltAngle < 0.0f)
        fltAngle += 360.0f;

    while(fltAngle > 360.0f)
        fltAngle -= 360.0f;

    return s_rgfltSin[Float2Int(fltAngle * ANGLEENTRIES)];
}

EXPORT float __fastcall OTrig::CosWrap(float fltAngle)
{
    while(fltAngle < 0.0f)
        fltAngle += 360.0f;

    while(fltAngle > 360.0f)
        fltAngle -= 360.0f;

    return s_rgfltCos[Float2Int(fltAngle * ANGLEENTRIES)];
}

EXPORT float  __fastcall OTrig::SinWrap(long lAngleOneTenths)
{
    lAngleOneTenths = lAngleOneTenths % (cSinCosEntries - 1);
    return s_rgfltSin[lAngleOneTenths];
}

EXPORT float  __fastcall OTrig::CosWrap(long lAngleOneTenths)
{
    lAngleOneTenths = lAngleOneTenths % (cSinCosEntries - 1);
    return  s_rgfltCos[lAngleOneTenths];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\util\proputil.cpp ===
#include "utilpre.h"
#include "olectl.h"
#include "malloc.h"
#include "proputil.h"

// Note: cgeorges, 11/98
// To remove 64-bit warnings, I'm changing defn of WIDESTR() to always do an ANSI->UNICODE conversion.
// As of now, this code is never called, and since this is purely legacy code, it should be safe


//#define WIDESTR(x)        ((HIWORD((ULONG)(x)) != 0) ? strcpyWfromA((LPWSTR) _alloca((strlen(x)+1) * 2), (x)) : (LPWSTR)(x))
#define WIDESTR(x)        (strcpyWfromA((LPWSTR) _alloca((strlen(x)+1) * 2), (x)))

LPSTR strcpyAfromW(LPSTR dest, LPCOLESTR src);
LPWSTR strcpyWfromA(LPOLESTR dest, LPCSTR src);

// ansi <-> unicode conversion
LPSTR strcpyAfromW(LPSTR dest, LPCOLESTR src)
{
        UINT cch;

        if (NULL == src)
                src = OLESTR("");

        cch = WideCharToMultiByte(CP_ACP, 0, src, -1, dest, (wcslen(src)*2)+1, NULL, NULL);
        return dest;
}

LPWSTR strcpyWfromA(LPOLESTR dest, LPCSTR src)
{
        MultiByteToWideChar(CP_ACP, 0, src, -1, dest, (strlen(src)+1));
        return dest;
}

/////////////////////////////////////////////////////////////////////////////
// ReadBstrFromPropBag - Read a BSTR saved with WriteBstrToPropBag.

HRESULT ReadBstrFromPropBag(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog, LPSTR pszName, OLECHAR ** pbstr)
{
        HRESULT hr;
        VARIANT var;
        LPWSTR pOleStr;

        Proclaim (pszName);

        // Convert Ansi to Ole string
        pOleStr = WIDESTR(pszName);

        if (!pOleStr)
        {
                DWORD dw = GetLastError();
                hr = dw ? HRESULT_FROM_WIN32(dw) : E_FAIL;
                goto Error;
        }

    memset(&var, 0, sizeof var);
        var.vt = VT_BSTR;
        hr = pPropBag->Read(pOleStr, &var, pErrorLog);
        if (FAILED(hr))
                goto Error;
        
        // Coerce the type if needed.
        if (var.vt != VT_BSTR)
        {
                hr = VariantChangeType(&var, &var, 0, VT_BSTR);
                if (FAILED(hr)) 
                        goto Error;
        }

        *pbstr = var.bstrVal;

        return NOERROR;

Error:
        if (pErrorLog)
        {
                EXCEPINFO excepinfo;

                memset(&excepinfo, 0, sizeof(EXCEPINFO));
                excepinfo.scode = hr;
                LPWSTR pErrStr = pOleStr;
                if (pErrStr)
                        pErrorLog->AddError(pErrStr, (EXCEPINFO *)&excepinfo);
        }

        return hr;
}


/////////////////////////////////////////////////////////////////////////////
// WriteBstrToPropBag - Write a BSTR to Property Bag.

HRESULT WriteBstrToPropBag(LPPROPERTYBAG pPropBag, LPSTR pszName, LPOLESTR bstrVal)
{
        HRESULT hr = NOERROR;
        VARIANT var;
        LPWSTR pOleStr;

        assert(NULL != pszName);

        if (NULL != bstrVal)
        {
                // Convert Ansi to Ole string
                pOleStr = WIDESTR(pszName);

                if (!pOleStr)
                {
                        DWORD dw = GetLastError();
                        hr = dw ? HRESULT_FROM_WIN32(dw) : E_FAIL;
                        return hr;
                }

            memset(&var, 0, sizeof var);
                var.vt = VT_BSTR;
                var.bstrVal = bstrVal;
                hr = pPropBag->Write(pOleStr, &var);
                assert(SUCCEEDED(hr));
        }

        return hr;
}

HRESULT WriteLongToPropBag(IPropertyBag* pPropBag, LPSTR pszName, LONG lValue)
{
        assert( pszName && pPropBag );
        if (!pszName || !pPropBag)
                return E_INVALIDARG;

        VARIANT var;
        memset(&var, 0, sizeof var);
        var.vt = VT_I4;
        var.lVal = lValue;
        return pPropBag->Write(WIDESTR(pszName), &var);
}

HRESULT ReadLongFromPropBag(IPropertyBag* pPropBag, LPERRORLOG pErrorLog, LPSTR pszName, LONG* plValue)
{
        HRESULT hr;
        assert( pszName && pPropBag && plValue);
        if (!pszName || !pPropBag || !plValue)
                return E_INVALIDARG;

        VARIANT var;
        memset(&var, 0, sizeof var);
        var.vt = VT_I4;
        LPOLESTR pOleStr = WIDESTR(pszName);
        hr = pPropBag->Read(pOleStr, &var, pErrorLog);
        if (FAILED(hr))
                goto Error;

        // Coerce the type if needed.
        if (var.vt != VT_I4)
        {
                hr = VariantChangeType(&var, &var, 0, VT_I4);
                if (FAILED(hr)) 
                        goto Error;
        }

        *plValue = var.lVal;
        return NOERROR;

Error:
        if (pErrorLog)
        {
                EXCEPINFO excepinfo;

                memset(&excepinfo, 0, sizeof(EXCEPINFO));
                excepinfo.scode = hr;
                LPWSTR pErrStr = pOleStr;
                if (pErrStr)
                        pErrorLog->AddError(pErrStr, (EXCEPINFO *)&excepinfo);
        }

        return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\util\strconv.cpp ===
/***
*strtol.c - Contains Modified C runtimes strtol and strtoul
*
*       Copyright (c) 1989-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       strtol - convert ascii string to long signed integer
*       strtoul - convert ascii string to long unsigned integer
*
*       These are modified to skip any "," occuring in the number
*
*******************************************************************************/

// #include <cruntime.h>
#include <windows.h>
#include <stdlib.h>
#include <limits.h>
#include <errno.h>
#include <ctype.h>
#include <strconv.h>

#ifdef LATER_ALIGATOR
#include <oleauto.h>
#endif


/***
*strtol, strtoul(nptr,endptr,ibase) - Convert ascii string to long un/signed
*       int.
*
*Purpose:
*       Convert an ascii string to a long 32-bit value.  The base
*       used for the caculations is supplied by the caller.  The base
*       must be in the range 0, 2-36.  If a base of 0 is supplied, the
*       ascii string must be examined to determine the base of the
*       number:
*               (a) First char = '0', second char = 'x' or 'X',
*                   use base 16.
*               (b) First char = '0', use base 8
*               (c) First char in range '1' - '9', use base 10.
*
*       If the 'endptr' value is non-NULL, then strtol/strtoul places
*       a pointer to the terminating character in this value.
*       See ANSI standard for details
*
*Entry:
*       nptr == NEAR/FAR pointer to the start of string.
*       endptr == NEAR/FAR pointer to the end of the string.
*       ibase == integer base to use for the calculations.
*
*       string format: [whitespace] [sign] [0] [x] [digits/letters]
*
*Exit:
*       Good return:
*               result
*
*       Overflow return:
*               strtol -- LONG_MAX or LONG_MIN
*               strtoul -- ULONG_MAX
*               strtol/strtoul -- errno == ERANGE
*
*       No digits or bad base return:
*               0
*               endptr = nptr*
*
*Exceptions:
*       None.
*******************************************************************************/



unsigned long EXPORT WINAPI CStrConv::StrToLX(
        const char *nptr,
        const char **endptr,
        int ibase,
        int flags
        ) 
{
        const char *p;
        char c;
        unsigned long number;
        unsigned digval;
        unsigned long maxval;

        p = nptr;                       /* p is our scanning pointer */
        number = 0;                     /* start with zero */

        c = *p++;                       /* read char */
        while ( isspace((int)(unsigned char)c) )
                c = *p++;               /* skip whitespace */

        if (c == '-') {
                flags |= FL_NEG;        /* remember minus sign */
                c = *p++;
        }
        else if (c == '+')
                c = *p++;               /* skip sign */

        if (ibase < 0 || ibase == 1 || ibase > 36) {
                /* bad base! */
                if (endptr)
                        /* store beginning of string in endptr */
                        *endptr = nptr;
                return 0L;              /* return 0 */
        }
        else if (ibase == 0) {
                /* determine base free-lance, based on first two chars of
                   string */
                if (c != '0')
                        ibase = 10;
                else if (*p == 'x' || *p == 'X')
                        ibase = 16;
                else
                        ibase = 8;
        }

        if (ibase == 16) {
                /* we might have 0x in front of number; remove if there */
                if (c == '0' && (*p == 'x' || *p == 'X')) {
                        ++p;
                        c = *p++;       /* advance past prefix */
                }
        }

        /* if our number exceeds this, we will overflow on multiply */
        maxval = ULONG_MAX / ibase;


        for (;;) {      /* exit in middle of loop */
                /* convert c to value */
                if(',' == c) {
                        if(flags & FL_READDIGIT) {
                            c = *p++; /* read next digit */
                            continue; /* skip ',' character if occurs after a digit */
                        } else {
                            break;
                        }
                }
                else if ( isdigit((int)(unsigned char)c) )
                        digval = c - '0';
                else if ( isalpha((int)(unsigned char)c) )
                        digval = toupper(c) - 'A' + 10;
                else
                        break;
                if (digval >= (unsigned)ibase)
                        break;          /* exit loop if bad digit found */

                /* record the fact we have read one digit */
                flags |= FL_READDIGIT;

                /* we now need to compute number = number * base + digval,
                   but we need to know if overflow occured.  This requires
                   a tricky pre-check. */

                if (number < maxval || (number == maxval &&
                (unsigned long)digval <= ULONG_MAX % ibase)) {
                        /* we won't overflow, go ahead and multiply */
                        number = number * ibase + digval;
                }
                else {
                        /* we would have overflowed -- set the overflow flag */
                        flags |= FL_OVERFLOW;
                }

                c = *p++;               /* read next digit */
        }

        --p;                            /* point to place that stopped scan */

        if (!(flags & FL_READDIGIT)) {
                /* no number there; return 0 and point to beginning of
                   string */
                if (endptr)
                        /* store beginning of string in endptr later on */
                        p = nptr;
                number = 0L;            /* return 0 */
        }
        else if ( (flags & FL_OVERFLOW) ||
                  ( !(flags & FL_UNSIGNED) &&
                    ( ( (flags & FL_NEG) && (number > -LONG_MIN) ) ||
                      ( !(flags & FL_NEG) && (number > LONG_MAX) ) ) ) )
        {
                /* overflow or signed overflow occurred */
                errno = ERANGE;
                if ( flags & FL_UNSIGNED )
                        number = ULONG_MAX;
                else if ( flags & FL_NEG )
                        number = (unsigned long)(-LONG_MIN);
                else
                        number = LONG_MAX;
        }

        if (endptr != NULL)
                /* store pointer to char that stopped the scan */
                *endptr = p;

        if (flags & FL_NEG)
                /* negate result if there was a neg sign */
                number = (unsigned long)(-(long)number);

        return number;                  /* done. */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\util\strwrap.cpp ===
#include "utilpre.h"
#include "string.h"
#include "utils.h"
#include "strwrap.h"
#include <minmax.h>

//#pragma optimize( "agt", on )
#pragma intrinsic( memcmp, memset, memcpy )


CStringWrapper::CStringWrapper (void)
{
}

CStringWrapper::~CStringWrapper (void)
{
}

LPTSTR 
CStringWrapper::Strcpy (LPTSTR szDest, LPCTSTR szSource)
{
	return _tcscpy(szDest, szSource);
}

LPTSTR 
CStringWrapper::Strncpy (LPTSTR szDest, LPCTSTR szSource, size_t nCount)
{
	return _tcsncpy(szDest, szSource, nCount);
}

LPTSTR 
CStringWrapper::Strcat (LPTSTR szDest, LPCTSTR szSource)
{
	return _tcscat(szDest, szSource);
}

wchar_t *
CStringWrapper::WStrcat (wchar_t *szDest, const wchar_t *szSource)
{
	return wcscat(szDest, szSource);
}

int 
CStringWrapper::WStrlen (const wchar_t *szSource)
{
	return wcslen(szSource);
}

wchar_t *
CStringWrapper::WStrcpy (wchar_t *szDest, const wchar_t *szSource)
{
	return wcscpy(szDest, szSource);
}

wchar_t *
CStringWrapper::WStrncpy (wchar_t *szDest, const wchar_t *szSource, size_t nSize)
{
	return wcsncpy(szDest, szSource, nSize);
}


	// A case-insensitive string comparison up to ct characters
	// required because CompareStringW() is stubbed on Win95.
EXPORT int  CStringWrapper::WStrCmpin( const wchar_t * sz1,
		                               const wchar_t * sz2,
									   size_t          ct )
{
	if( !sz1 || !sz2 )
	{
		return 0x0BADBAAD;
	}

	int       iRes = 0x0BADBAAD;
	wchar_t * p1 = NULL;
	wchar_t * p2 = NULL;
	size_t  size1 = lstrlenW(sz1);
	size_t  size2 = lstrlenW(sz2);
	size_t  size_least = min( min( size1, size2 ), ct );

	p1 = New wchar_t[ size_least + 1 ];
	p2 = New wchar_t[ size_least + 1 ];
	if( p1 && p2 )
	{
		wcsncpy( p1, sz1, size_least );
		wcsncpy( p2, sz2, size_least );
		p1[ size_least ] = L'\0';
		p2[ size_least ] = L'\0';
		iRes = _wcsicmp( p1, p2 );
	}
	Delete [] p1;
	Delete [] p2;

	return iRes;
}


	// A LoadStringW() substitute because
	// the real API is stubbed on Win95.
EXPORT int  CStringWrapper::LoadStringW(HINSTANCE hInst, 
										UINT uID, 
										wchar_t * szString, 
										int nMaxLen )
{
	int     iRes = 0;
	char *  pch = NULL;

	if( 0 >= nMaxLen )
	{
		SetLastError( ERROR_INVALID_DATA );
		return 0;
	}

	if( szString )
	{
		pch = New char[ nMaxLen ];
		if( !pch )
		{
			SetLastError( ERROR_OUTOFMEMORY );
			return 0;
		}
	}

	iRes = LoadStringA( hInst, uID, pch, nMaxLen );
	if( iRes && pch )
	{
		iRes = CStringWrapper::Mbstowcs( szString, pch, nMaxLen );
		if( iRes == nMaxLen )
		{
			szString[ nMaxLen - 1 ] = L'\0';
		}
	}

	Delete [] pch;
	return iRes;
}


int 
CStringWrapper::Iswspace (wint_t c)
{
	return iswspace(c);
}

int         
CStringWrapper::Strlen (LPCTSTR szSource)
{
	return _tcslen(szSource);
}

int         
CStringWrapper::Strcmp (LPCTSTR szLeft, LPCTSTR szRight)
{
	return _tcscmp(szLeft, szRight);
}

int         
CStringWrapper::Stricmp (LPCTSTR szLeft, LPCTSTR szRight)
{
	return _tcsicmp(szLeft, szRight);
}

int         
CStringWrapper::Strncmp (LPCTSTR szLeft, LPCTSTR szRight, size_t nSize)
{
	return _tcsncmp(szLeft, szRight, nSize);
}

int         
CStringWrapper::Strnicmp (LPCTSTR szLeft, LPCTSTR szRight, size_t nSize)
{
	return _tcsnicmp(szLeft, szRight, nSize);
}

LPTSTR 
CStringWrapper::Strchr (LPCTSTR szSource, TCHAR chSearch)
{
	return _tcschr(szSource, chSearch);
}

LPTSTR 
CStringWrapper::Strrchr (LPCTSTR szSource, TCHAR chSearch)
{
	return _tcsrchr(szSource, chSearch);
}

LPTSTR 
CStringWrapper::Strstr (LPCTSTR szOne, LPCTSTR szTwo)
{
	return _tcsstr(szOne, szTwo);
}

LPTSTR 
CStringWrapper::Strtok (LPTSTR szTarget, LPCTSTR szTokens)
{
	return _tcstok(szTarget, szTokens);
}

LPTSTR 
CStringWrapper::Strinc (LPCTSTR szTarget)
{
	return _tcsinc(szTarget);
}

int
CStringWrapper::Sscanf1 (LPCTSTR szSource, LPCTSTR szFormat, LPVOID pvParam1)
{
	return _stscanf(szSource, szFormat, pvParam1);
}

int
CStringWrapper::Sscanf2 (LPCTSTR szSource, LPCTSTR szFormat, LPVOID pvParam1, LPVOID pvParam2)
{
	return _stscanf(szSource, szFormat, pvParam1, pvParam2);
}

int
CStringWrapper::Sscanf3 (LPCTSTR szSource, LPCTSTR szFormat, LPVOID pvParam1, LPVOID pvParam2, LPVOID pvParam3)
{
	return _stscanf(szSource, szFormat, pvParam1, pvParam2, pvParam3);
}

/*
int         
CStringWrapper::Sscanf (LPCTSTR szSource, LPCTSTR szFormat, ... )
{
	va_list argList;
	va_start(argList, szFormat);
	int iRet = _stscanf(szSource, szFormat, argList);
	va_end(argList);
	return iRet;
}
*/

int         
CStringWrapper::Sprintf (LPTSTR szDest, LPCTSTR szFormat, ... )
{
	va_list argList;
	va_start(argList, szFormat);
	int iRet = _vstprintf(szDest, szFormat, argList);
	va_end(argList);
	return iRet;
}

long       
CStringWrapper::Atol (LPCTSTR szSource)
{
	return _ttol(szSource);
}

int         
CStringWrapper::Atoi (LPCTSTR szSource)
{
	return _ttoi(szSource);
}

LPTSTR 
CStringWrapper::Ltoa (long lSource, LPTSTR szDest, int iRadix)
{
	return _ltot(lSource, szDest, iRadix);
}

LPTSTR 
CStringWrapper::Itoa (int iSource, LPTSTR szDest, int iRadix)
{
	return _itot(iSource, szDest, iRadix);
}

LPTSTR 
CStringWrapper::Gcvt ( double dblValue, int iDigits, LPTSTR szBuffer )
{
	return _gcvt(dblValue, iDigits, szBuffer);
}

size_t 
CStringWrapper::Wcstombs ( char *mbstr, const wchar_t *wcstr, size_t count )
{
	return wcstombs ( mbstr, wcstr, count );
}

size_t 
CStringWrapper::Mbstowcs ( wchar_t *wcstr, const char *mbstr, size_t count )
{
	return mbstowcs (wcstr, mbstr, count);
}

int         
CStringWrapper::Memcmp (const void * pvLeft, const void * pvRight, size_t nSize)
{
	return memcmp(pvLeft, pvRight, nSize);
}

void *
CStringWrapper::Memset (void * pvLeft, int iValue, size_t nSize)
{
	return memset(pvLeft, iValue, nSize);
}

void *
CStringWrapper::Memcpy( void * pvDest, const void * pvSrc, size_t count )
{
	return memcpy(pvDest, pvSrc, count);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\util\utilpre.h ===
// utilpre.h : Header files commonly included by util source code files.

#include <windows.h>
#include <windowsx.h>
#include <winuser.h>
#include <tchar.h>
#include <commctrl.h>
#include <limits.h>
#include <ihammer.h>
#include "objbase.h"
#include "debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\capphandler\apphandler.cpp ===
// AppHandler.cpp : Implementation of CAppHandler
#include "stdafx.h"
#include "cacheapp.h"
#include "AppHandler.h"

/////////////////////////////////////////////////////////////////////////////
// CAppHandler

CAppHandler::~CAppHandler()
{
    if(m_hUrlCacheStream)
    {
        BOOL f= UnlockUrlCacheEntryStream(m_hUrlCacheStream, 0);
        _ASSERTE(f);
    }
}


// IInternetProtocolRoot
HRESULT STDMETHODCALLTYPE CAppHandler::Start( 
    /* [in] */ LPCWSTR szUrl,
    /* [in] */ IInternetProtocolSink *pOIProtSink,
    /* [in] */ IInternetBindInfo *pOIBindInfo,
    /* [in] */ DWORD grfPI,
    /* [in] */ DWORD dwReserved)
{
    HRESULT hr = S_OK;

    DWORD dwcbIcei = sizeof(INTERNET_CACHE_ENTRY_INFO);
    
    for(;;)
    {
        INTERNET_CACHE_ENTRY_INFO *picei = (INTERNET_CACHE_ENTRY_INFO *)_alloca(dwcbIcei);

        _ASSERTE(m_hUrlCacheStream == 0);
        USES_CONVERSION;
        m_hUrlCacheStream = RetrieveUrlCacheEntryStream(
            W2T(szUrl),
            picei,
            &dwcbIcei,
            FALSE,              // not random but sequential access
            0);                 // reserved
        if(m_hUrlCacheStream)
        {
            m_byteOffset = 0;

            // do the "fake" download synchronously

            // DA and dshow do something different than mshtml that
            // causes urlmon to want the name of the cache file.
            hr = pOIProtSink->ReportProgress(
                BINDSTATUS_CACHEFILENAMEAVAILABLE,
                T2CW(picei->lpszLocalFileName));
            
            if(SUCCEEDED(hr))
            {
                // everything should be in the cache.
                hr = pOIProtSink->ReportData(
                    BSCF_FIRSTDATANOTIFICATION | BSCF_INTERMEDIATEDATANOTIFICATION | BSCF_LASTDATANOTIFICATION,
                    picei->dwSizeLow,
                    picei->dwSizeLow);

                if(SUCCEEDED(hr))
                {
                    hr = pOIProtSink->ReportResult(S_OK, 0, L"");
                }
            }
        }
        else
        {
            DWORD dw = GetLastError();
            if(dw == ERROR_INSUFFICIENT_BUFFER)
            {
                // dwcbIcei has the right size now.
                continue;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(dw);
            }
        }

        break;
    }
            
            
    return hr;
}

// Allows the pluggable protocol handler to continue processing data
// on the apartment thread. This method is called in response to a
// call to IInternetProtocolSink::Switch.
// 
HRESULT STDMETHODCALLTYPE CAppHandler::Continue( 
    /* [in] */ PROTOCOLDATA *pProtocolData)
{
    // I never call IInternetProtocolSink::Switch, so it will never call this?
    _ASSERTE(!"CAppHandler::Continue");    
    return S_OK;
}
        
HRESULT STDMETHODCALLTYPE CAppHandler::Abort( 
    /* [in] */ HRESULT hrReason,
    /* [in] */ DWORD dwOptions)
{
    // we're not actually doing anything asynchronously
    return S_OK;
}
        
HRESULT STDMETHODCALLTYPE CAppHandler::Terminate( 
    /* [in] */ DWORD dwOptions)
{
    // nothing to do
    return S_OK;
}
        
HRESULT STDMETHODCALLTYPE CAppHandler::Suspend( void)
{
    // docs say "not implemented"
    return E_NOTIMPL;
}
        
HRESULT STDMETHODCALLTYPE CAppHandler::Resume( void)
{
    // docs say "not implemented"
    return E_NOTIMPL;
}

// IInternetProtocol
HRESULT STDMETHODCALLTYPE CAppHandler::Read( 
    /* [length_is][size_is][out][in] */ void *pv,
    /* [in] */ ULONG cb,
    /* [out] */ ULONG *pcbRead)
{
    _ASSERTE(m_hUrlCacheStream);
    HRESULT hr = S_OK;
    
    *pcbRead = cb;
    BOOL f = ReadUrlCacheEntryStream(
        m_hUrlCacheStream,
        m_byteOffset,
        pv,
        pcbRead,
        0);                     // reserved
    if(f)
    {
        m_byteOffset += *pcbRead;
        hr = (cb == *pcbRead ? S_OK : S_FALSE);
    }
    else
    {
        DWORD dw = GetLastError();
        hr = (dw == ERROR_HANDLE_EOF ? S_FALSE :  HRESULT_FROM_WIN32(dw));
    }
        
    return hr;
}
        
HRESULT STDMETHODCALLTYPE CAppHandler::Seek( 
    /* [in] */ LARGE_INTEGER dlibMove,
    /* [in] */ DWORD dwOrigin,
    /* [out] */ ULARGE_INTEGER *plibNewPosition)
{
    // the protocol does not support seekable data retrieval. 
    return E_FAIL;
}
        
HRESULT STDMETHODCALLTYPE CAppHandler::LockRequest( 
    /* [in] */ DWORD dwOptions)
{
    return S_OK;
}
        
HRESULT STDMETHODCALLTYPE CAppHandler::UnlockRequest( void)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\util\urlarchv.cpp ===
#include <windows.h>
#include <stdlib.h>
#include <minmax.h>

#include <urlarchv.h>

#define MAX_URL  2060

#ifndef ARRAYDIM
  #define ARRAYDIM(a)   (sizeof(a) / sizeof(a[0]))
#endif // ARRAYDIM

#ifndef LOOPFOREVER
  #define LOOPFOREVER  for(;;)
#endif // LOOPFOREVER


// --------------------------------


EXPORT CURLArchive::CURLArchive( IUnknown * pUnk ) :
    m_pStream(NULL), m_pUnk(pUnk)
{
    if (m_pUnk)
    	m_pUnk->AddRef();
}


    // These are private methods; 
    // no one, even CURLArchive, should be calling them
CURLArchive::CURLArchive( const CURLArchive & )
{ NULL; }


CURLArchive & CURLArchive::operator=( const CURLArchive & )
{ return *this; }


EXPORT CURLArchive::~CURLArchive()
{
    Close( );
    if( m_pUnk )
        m_pUnk->Release();
}


EXPORT HRESULT CURLArchive::Close( )
{    
    if( m_pStream )
    {
        m_pStream->Release( );
        m_pStream = NULL;
    }
    return S_OK;
}


        
EXPORT HRESULT CURLArchive::CopyLocal( LPSTR szLocalFile, int ctChars )
{
    return E_NOTIMPL;
}



EXPORT HRESULT CURLArchive::CopyLocal( LPWSTR szwLocalFile, int ctChars )
{
    return E_NOTIMPL;
}



EXPORT HRESULT CURLArchive::Create( LPCSTR szURL )
{
    HRESULT  hr = E_FAIL;

    if( m_pStream )
        return E_ACCESSDENIED;

    if( !szURL )
        return E_INVALIDARG;

    hr = URLOpenBlockingStreamA( m_pUnk,
        szURL,
        &m_pStream,
        0u,
        NULL );

    return hr;
}


EXPORT HRESULT CURLArchive::Create( LPCWSTR szwURL )
{
    HRESULT  hr = E_FAIL;

    if( m_pStream )
        return E_ACCESSDENIED;

    if( !szwURL )
        return E_INVALIDARG;

    hr = URLOpenBlockingStreamW( m_pUnk,
        szwURL,
        &m_pStream,
        0u,
        NULL );

    return hr;
}



EXPORT HRESULT    CURLArchive::GetFileSize( long & lSize )
{
    lSize = -1;
    if( m_pStream )
    {
        HRESULT  hr;
        STATSTG  statStg;

        hr = m_pStream->Stat( &statStg, STATFLAG_NONAME );
        if( SUCCEEDED(hr) )
        {
            if( 0u == statStg.cbSize.HighPart )
            {
                lSize = statStg.cbSize.LowPart;
            }
            else
            {
                lSize = -1;
            }            
        }
        return hr;
    }
    return E_ACCESSDENIED;    
}


EXPORT IStream * CURLArchive::GetStreamInterface( void ) const
{
    return m_pStream;
}


EXPORT DWORD     CURLArchive::Read( LPBYTE lpb,
                             DWORD ctBytes )
{
    DWORD  ctBytesRead = 0u;

    if( m_pStream )
    {
        HRESULT hr;

        hr = m_pStream->Read( lpb, ctBytes, &ctBytesRead );
        if( FAILED(hr) )
            ctBytesRead = 0u;    
    }
    return ctBytesRead;
}


EXPORT DWORD     CURLArchive::ReadLine( LPSTR lpstr,
                                        DWORD ctBytes )
{
    if( !m_pStream || (ctBytes < 1) || !lpstr )
        return 0u;

    DWORD   ctBytesRead      = 0u;
    LPSTR   lpstrXfer        = lpstr;
    DWORD   ctBytesRemaining = ctBytes - 1u;
    char    chTemp[ 512 + 1 ];
    
    lpstr[0] = '\0';
    ZeroMemory( chTemp, sizeof(chTemp) );
    LOOPFOREVER
    {
        HRESULT hr;
        DWORD   ctBytesToRead;
        DWORD   ctBytesJustRead;

        ctBytesToRead = min( (DWORD) ctBytesRemaining, 
                             sizeof(chTemp) - 1u );
        hr = m_pStream->Read( chTemp, 
                              ctBytesToRead,
                              &ctBytesJustRead );

        for( DWORD i=0u; i<ctBytesJustRead; ++i )
        {
                // Is there a CRLF in here?
            if( ('\r' == chTemp[i]) || ('\n' == chTemp[i]) )
            {
                LARGE_INTEGER  li;

                    // Skip past any other line-breaks
                while( (++i < ctBytesJustRead) && 
                       (('\r' == chTemp[i]) || ('\n' == chTemp[i])) )
                {
                    NULL;  // increment i in while eval
                }
                       
                    // Rewind stream to the next non-empty line
                if( i < ctBytesJustRead )
                {
                    li.HighPart = -1L;
                    li.LowPart  = (DWORD)((long) i - 
                                          (long) ctBytesJustRead);
                    m_pStream->Seek( li, current, NULL );
                }

                *lpstrXfer = '\0';
                return ctBytesRead;
            }

            *lpstrXfer++ = chTemp[i];
            --ctBytesRemaining;
            ++ctBytesRead;
        }

           // IStream docs say EOF may or may not return S_ hr
           // Review(normb): What does failed hr mean given this?           
        if( FAILED(hr) || 
            (ctBytesJustRead != ctBytesToRead) || 
            (ctBytesRemaining < 1) )
        {
            break;
        }
    }

    return ctBytesRead;
}


EXPORT DWORD     CURLArchive::ReadLine( LPWSTR lpstrw,
                                        DWORD  ctChars )
{
    return 0u;
}




EXPORT long CURLArchive::Seek( long ctBytes, origin orig )
{
    long  lNewPos = -1L;

    if( m_pStream )
    {
        ULARGE_INTEGER  uli;
        LARGE_INTEGER   li;
        HRESULT         hr = E_FAIL;

        li.LowPart = ctBytes;
        if( ctBytes < 0 )
            li.HighPart = -1L;

        hr = m_pStream->Seek( li, orig, &uli );
        if( FAILED(hr) || uli.HighPart )
            return -1L;

        lNewPos = (long) uli.LowPart;
    }
    return lNewPos;
}


EXPORT DWORD     CURLArchive::Write( LPBYTE lpb,
                              DWORD ctBytes )
{   
    DWORD  ctBytesWritten = 0u;

    if( m_pStream )
    {
        HRESULT hr;

        hr = m_pStream->Read( lpb, ctBytes, &ctBytesWritten );
        if( FAILED(hr) )
            ctBytesWritten = 0u;
    }
    return ctBytesWritten;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\util\surface.cpp ===
/*
********************************************************************
*
*
*
*
*
*
*
********************************************************************
*/
#include <iHammer.h>
#include <strwrap.h>
#include <surface.h>


const DWORD  ALPHAMASK32 = 0xFF000000;
const DWORD  REDMASK24   = 0x00FF0000;
const DWORD  GRNMASK24   = 0x0000FF00;
const DWORD  BLUMASK24   = 0x000000FF;
const DWORD  REDMASK16   = 0x0000F800;
const DWORD  GRNMASK16   = 0x000007E0;
const DWORD  BLUMASK16   = 0x0000001F;
const DWORD  REDMASK15   = 0x00007C00;
const DWORD  GRNMASK15   = 0x000003E0;
const DWORD  BLUMASK15   = 0x0000001F;


static inline long CalcPitch( long width, long bitsperpixel )
{
        return ((((width * bitsperpixel)+31L)&(~31L)) >> 3);
}

static inline long CalcImageSize( int width, int height, int bitsperpixel )
{
        return height * CalcPitch( width, bitsperpixel );
}


// ---------------------------------------


EXPORT IHammer::CDirectDrawSurface::CDirectDrawSurface(
        HPALETTE hpal, 
        DWORD dwColorDepth, 
    const SIZE* psize, 
        HRESULT * phr )
{
        HDC hdc;
        HWND hwnd;
        PALETTEENTRY pe[256];
        int iCount;

                // For the GetDC(), ReleaseDC() stuff
        m_ctDCRefs      = 0;
        m_hdcMem        = NULL;
        m_hbmpDCOld = NULL;

        m_pvBits = NULL;
        m_cRef = 1;
        m_size = *psize;
        m_ptOrigin.x = (m_ptOrigin.y = 0);

        ZeroMemory(&m_bmi, sizeof(m_bmi));
        m_bmi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
        m_bmi.bmiHeader.biWidth       = m_size.cx;
        m_bmi.bmiHeader.biHeight      = -m_size.cy;
        m_bmi.bmiHeader.biPlanes      = 1;
        m_bmi.bmiHeader.biCompression = BI_RGB;
        m_bmi.bmiColors[0].rgbRed =     m_bmi.bmiColors[0].rgbGreen = m_bmi.bmiColors[0].rgbBlue = 0;
        m_bmi.bmiColors[1].rgbRed =     m_bmi.bmiColors[1].rgbGreen = m_bmi.bmiColors[1].rgbBlue = 255;

    switch( dwColorDepth ) 
    {
        case 1:
            m_bmi.bmiHeader.biBitCount = 1;
            break;

        case 4:
            m_bmi.bmiHeader.biBitCount = 4;
                    m_bmi.bmiHeader.biClrUsed  = 2;
            break;

        case 8:
            {
                    m_bmi.bmiHeader.biBitCount = 8;
                    iCount = GetPaletteEntries(hpal, 0, 256, (PALETTEENTRY*)&pe);
                    for (int i = 0; i < iCount; i++)
                    {
                                // Review(normb): Do we want to copy rgbReserved?                               
                            m_bmi.bmiColors[i].rgbRed   = pe[i].peRed;
                            m_bmi.bmiColors[i].rgbGreen = pe[i].peGreen;
                            m_bmi.bmiColors[i].rgbBlue  = pe[i].peBlue;
                    }
            }
        break;

        case 15:                // 555 encoded 16-bit            
            m_bmi.bmiHeader.biBitCount = 16;
            break;
            
        case 16:                // 565 encoded 16-bit
            m_bmi.bmiHeader.biBitCount = 16;
            m_bmi.bmiHeader.biCompression = BI_BITFIELDS;                   
            {
                        LPDWORD pdw = (LPDWORD)&m_bmi.bmiColors[0];
                        pdw[0] = 0x0000F800;
                        pdw[1] = 0x000007E0;
                        pdw[2] = 0x0000001F;
            }
            break;

        case 24:
                m_bmi.bmiHeader.biBitCount = 24;
            break;

        case 32: 
            m_bmi.bmiHeader.biBitCount = 32;
            break;
        
        default:
            Proclaim( FALSE && "Bad color-depth" );
            break;
    }
    m_lBitCount = m_bmi.bmiHeader.biBitCount;

                // Review(normb): require the ctor to take a HDC
                // and make a compatible DIB from it.  
                // Who says desktop and Trident must be similar bitdepths?
    hwnd   = ::GetDesktopWindow();
    hdc    = ::GetDC(hwnd);
        m_hbmp = CreateDIBSection(hdc, (LPBITMAPINFO)&m_bmi, DIB_RGB_COLORS, &m_pvBits, NULL, NULL);
    ::ReleaseDC(hwnd, hdc);

        if (phr)
        {
                *phr = (m_hbmp) ? S_OK : E_FAIL;
        }

#ifdef _DEBUG
        m_ctLocks = 0;
#endif // _DEBUG

    // Don't try to clear a bitmap if it was never allocated!
    if (m_pvBits)
    {
            memset( m_pvBits, 0, 
                        CalcImageSize(m_size.cx, m_size.cy ,m_lBitCount) );
    }
}

IHammer::CDirectDrawSurface::~CDirectDrawSurface()
{
        if (m_hbmp)
        {
                DeleteObject(m_hbmp);
                m_hbmp = NULL;
        }
        
        Proclaim( 0 == m_ctLocks );

                // No one should have a dangling dc from our GetDC()
        Proclaim( 0 == m_ctDCRefs );
        while( m_hdcMem && 
                   SUCCEEDED(this->ReleaseDC(m_hdcMem)) )
        {
                NULL;
        }
}

HBITMAP IHammer::CDirectDrawSurface::GetBitmap( void )
{
    return m_hbmp;
}

void IHammer::CDirectDrawSurface::GetOrigin( int & left, int & top  ) const
{
        left = m_ptOrigin.x;
        top  = m_ptOrigin.y;
}


void IHammer::CDirectDrawSurface::SetOrigin( int left, int top  )
{
        m_ptOrigin.x = left;
        m_ptOrigin.y = top;
}


STDMETHODIMP IHammer::CDirectDrawSurface::QueryInterface(THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
        if (!ppvObj)
                return E_INVALIDARG;
        if (IsEqualGUID(riid, IID_IUnknown))
    {
        IDirectDrawSurface *   pThis = this;
                *ppvObj = (LPVOID) pThis;
    }
        else
        if (IsEqualGUID(riid, IID_IDirectDrawSurface))
    {
                IDirectDrawSurface * pThis = this;
        *ppvObj = (LPVOID) pThis;
    }
        else
                return E_NOINTERFACE;
        AddRef();
        return S_OK;
}

STDMETHODIMP_(ULONG) IHammer::CDirectDrawSurface::AddRef(THIS) 
{
        ULONG cRef = InterlockedIncrement((LPLONG)&m_cRef);
        return cRef;
}

STDMETHODIMP_(ULONG) IHammer::CDirectDrawSurface::Release(THIS)
{
        ULONG cRef = InterlockedDecrement((LPLONG)&m_cRef);

        if (0 == cRef)
                Delete this;
        return cRef;
}


STDMETHODIMP IHammer::CDirectDrawSurface::GetSurfaceDesc( DDSURFACEDESC * pddsDesc )
{
    if( !pddsDesc )
        return E_POINTER;

    pddsDesc->dwFlags = DDSD_HEIGHT | DDSD_WIDTH | DDSD_PITCH | 
                        DDSD_PIXELFORMAT;

    pddsDesc->dwHeight = (DWORD) m_size.cy;
    pddsDesc->dwWidth  = (DWORD) m_size.cx;
        pddsDesc->lPitch   = CalcPitch( m_size.cx, m_lBitCount );
    pddsDesc->ddpfPixelFormat.dwSize = sizeof(pddsDesc->ddpfPixelFormat);
    return GetPixelFormat( &pddsDesc->ddpfPixelFormat );
}


STDMETHODIMP IHammer::CDirectDrawSurface::GetPixelFormat( DDPIXELFORMAT * pddpixFormat )
{
    if( !pddpixFormat )
        return E_POINTER;
    //if( sizeof(DDPIXELFORMAT) != pddpixFormat->dwSize )
    //    return E_INVALIDARG;

    CStringWrapper::Memset( pddpixFormat, 0, sizeof(DDPIXELFORMAT) );
    pddpixFormat->dwSize = sizeof(DDPIXELFORMAT);

    pddpixFormat->dwFlags = DDPF_RGB;
    switch( m_lBitCount )
    {
                case 1:                 
                        pddpixFormat->dwFlags |= DDPF_PALETTEINDEXED1;
            pddpixFormat->dwRGBBitCount = DDBD_1;
                        break;

                case 4:
                        pddpixFormat->dwFlags |= DDPF_PALETTEINDEXED4;
            pddpixFormat->dwRGBBitCount = DDBD_4;
                        break;

        case 8:
            pddpixFormat->dwFlags |= DDPF_PALETTEINDEXED8;
            pddpixFormat->dwRGBBitCount = DDBD_8;
            break;

        case 16:
            pddpixFormat->dwRGBBitCount     = DDBD_16;
            pddpixFormat->dwRBitMask        = REDMASK16;
            pddpixFormat->dwGBitMask        = GRNMASK16;
            pddpixFormat->dwBBitMask        = BLUMASK16;
            break;

        case 24:            
            pddpixFormat->dwRGBBitCount     = DDBD_24;
            pddpixFormat->dwRBitMask        = REDMASK24;
            pddpixFormat->dwGBitMask        = GRNMASK24;
            pddpixFormat->dwBBitMask        = BLUMASK24;
            break;

        case 32:
            // DO NOT SET pddpixFormat->dwAlphaBitDepth   = DDBD_8
            pddpixFormat->dwFlags |= DDPF_ALPHAPIXELS;
            pddpixFormat->dwRGBBitCount     = DDBD_32;
            pddpixFormat->dwRGBAlphaBitMask = ALPHAMASK32;
            pddpixFormat->dwRBitMask        = REDMASK24;
            pddpixFormat->dwGBitMask        = GRNMASK24;
            pddpixFormat->dwBBitMask        = BLUMASK24;
            break;

                default:
                        Proclaim( FALSE && "bad color depth" );
                        break;
    }
    return S_OK;
}


STDMETHODIMP IHammer::CDirectDrawSurface::Lock(RECT *prcBounds, 
                                      DDSURFACEDESC *pddsDesc, 
                                      DWORD dwFlags, 
                                      HANDLE hEvent )
{
        HRESULT hr = E_FAIL;
        
        Proclaim( prcBounds && pddsDesc );
        if (!prcBounds || !pddsDesc )
                return E_POINTER;

    hr = GetSurfaceDesc( pddsDesc );
    if( FAILED(hr) )
        return hr;

        if (m_hbmp && m_pvBits )
        {
                RECT rectBounds = *prcBounds;
                int  dLeft;
                int  dTop;
                int  doffset;
                GetOrigin( dLeft, dTop );
                ::OffsetRect( &rectBounds, -dLeft, -dTop );

                doffset = (rectBounds.top * pddsDesc->lPitch) + 
                                  ((rectBounds.left * m_lBitCount)/8);

                        // Sanity checks...
                        // Don't lock anything outside our block.
                Proclaim( 0 <= doffset );
                //Proclaim( rectBounds.right  <= m_size.cx );
                //Proclaim( rectBounds.bottom <= m_size.cy );
                if( (0 > doffset) ||
                        (rectBounds.right  > m_size.cx) ||
                        (rectBounds.bottom > m_size.cy) )
                {
                        return E_FAIL;
                }

            pddsDesc->lpSurface  =
                    (void *)( ((LPBYTE) m_pvBits) + doffset );
                hr = S_OK;

#ifdef _DEBUG
                        // Yes, we do allow multiple locks on our surfaces.
                        // Probably contrary to IDirectDrawSurface spec.
                        // but (cowardly) done to replace IBitmapSurface
                        // rules exploited by IHammer Transition code!!!
                        // At least we require (for _DEBUG) identical regions.
                ++m_ctLocks;
                m_pvLocked = pddsDesc->lpSurface;
#endif // _DEBUG

        }
        return hr;
}


STDMETHODIMP  IHammer::CDirectDrawSurface::Unlock( void *pBits )
{
#ifdef _DEBUG
        Proclaim( pBits == m_pvLocked );
        if( 0 == --m_ctLocks )
        {
                m_pvLocked = NULL;
        }
#endif // _DEBUG

        return S_OK;
}


STDMETHODIMP  IHammer::CDirectDrawSurface::GetDC( HDC * phdc )
{  
        HRESULT  hr = S_OK;

        Proclaim( phdc );
        if( !phdc )
                return E_POINTER;

        if( !m_hdcMem )
        {
                HBITMAP  hBmp        = GetBitmap( );

                Proclaim( hBmp && "insane CDirectDrawSurface object" );
                hr = E_FAIL;   // Guilty 'til proven innocent...
                if( hBmp )
                {
                        HWND     hWndDesktop = ::GetDesktopWindow( );
                        HDC      hDCDesktop  = ::GetDC( hWndDesktop );
                        m_hdcMem = ::CreateCompatibleDC( hDCDesktop );

                        if( m_hdcMem )
                        {
                                m_hbmpDCOld = (HBITMAP)::SelectObject( m_hdcMem, hBmp );
                                if( m_hbmpDCOld )
                                {
                                        hr = S_OK;
                                }
                                else
                                {
                                        ::DeleteDC( m_hdcMem );
   
                                        m_hdcMem = NULL;
                                        hr = E_FAIL;
                                }
                        }
                        else
                        {
                                hr = E_OUTOFMEMORY;
                        }

                        if (hDCDesktop)
                            ::ReleaseDC(hWndDesktop, hDCDesktop);
                }
        }

        *phdc = m_hdcMem;

        if( SUCCEEDED(hr) )
        {
                ++m_ctDCRefs;
        }
        return hr;
}


STDMETHODIMP  IHammer::CDirectDrawSurface::ReleaseDC( HDC hDC )
{  
        HRESULT  hr = E_INVALIDARG;

        if( m_hdcMem && (hDC == m_hdcMem) )  // NULL==NULL still bad
        {
                hr = S_OK;
                if( !--m_ctDCRefs )
                {
                        if( GetBitmap() == 
                                ::SelectObject( hDC, m_hbmpDCOld ) )
                        {
                                ::DeleteDC( hDC );  // m_hdcMem created using CreateCompatibleDC, so can use DeleteDC
                                m_hdcMem = NULL;                                
                        }
                        else
                        {
                                Proclaim( FALSE && "Unexpected bitmap in DC" );
                                hr = E_FAIL;
                        }
                }               
        }
        
        return hr;
}



// Yeah yeah yeah...

STDMETHODIMP  IHammer::CDirectDrawSurface::AddAttachedSurface( LPDIRECTDRAWSURFACE)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::AddOverlayDirtyRect( LPRECT)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::Blt( LPRECT,LPDIRECTDRAWSURFACE, LPRECT,DWORD, LPDDBLTFX)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::BltBatch( LPDDBLTBATCH, DWORD, DWORD )
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::BltFast( DWORD,DWORD,LPDIRECTDRAWSURFACE, LPRECT,DWORD)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::DeleteAttachedSurface( DWORD,LPDIRECTDRAWSURFACE)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::EnumAttachedSurfaces( LPVOID,LPDDENUMSURFACESCALLBACK)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::EnumOverlayZOrders( DWORD,LPVOID,LPDDENUMSURFACESCALLBACK)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::Flip( LPDIRECTDRAWSURFACE, DWORD)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::GetAttachedSurface( LPDDSCAPS, LPDIRECTDRAWSURFACE FAR *)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::GetBltStatus( DWORD)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::GetCaps( LPDDSCAPS)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::GetClipper( LPDIRECTDRAWCLIPPER FAR*)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::GetColorKey( DWORD, LPDDCOLORKEY)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::GetFlipStatus( DWORD)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::GetOverlayPosition( LPLONG, LPLONG )
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::GetPalette( LPDIRECTDRAWPALETTE * )
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::Initialize( LPDIRECTDRAW, LPDDSURFACEDESC)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::IsLost( )
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::Restore( )
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::SetClipper( LPDIRECTDRAWCLIPPER)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::SetColorKey( DWORD, LPDDCOLORKEY)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::SetOverlayPosition( LONG, LONG )
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::SetPalette( LPDIRECTDRAWPALETTE)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::UpdateOverlay( LPRECT, LPDIRECTDRAWSURFACE,LPRECT,DWORD, LPDDOVERLAYFX)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::UpdateOverlayDisplay( DWORD)
{  return E_NOTIMPL; }

STDMETHODIMP  IHammer::CDirectDrawSurface::UpdateOverlayZOrder( DWORD, LPDIRECTDRAWSURFACE)
{  return E_NOTIMPL; }


// ----------------------- Other utilities --------------


EXPORT long  BitCountFromDDPIXELFORMAT( const DDPIXELFORMAT & ddpf )
{       
        long lBitCount = -1L;

    switch( ddpf.dwRGBBitCount )
    {
        case DD_1BIT:
                case DDBD_1:
            lBitCount = 1;
            break;

        case DD_4BIT:
                case DDBD_4:
            lBitCount = 4;
            break;

        case DD_8BIT:
                case DDBD_8:
            lBitCount = 8;
            break;

        case DD_16BIT:
                case DDBD_16:
            if( GRNMASK15 == ddpf.dwGBitMask )
            {
                lBitCount = 15;
            }
            else
            {
                lBitCount = 16;
            }
            break;

        case DD_24BIT:
                case DDBD_24:
            lBitCount = 24;
            break;

        case DD_32BIT:
                case DDBD_32:
            lBitCount = 32;
            break;
                    
        default:
            Proclaim(FALSE && "unexpected color-depth");            
            break; 
    
    } // end switch

        return lBitCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\capphandler\apphandler.h ===
// AppHandler.h : Declaration of the CAppHandler

#ifndef __APPHANDLER_H_
#define __APPHANDLER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CAppHandler
class ATL_NO_VTABLE CAppHandler : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAppHandler, &CLSID_AppHandler>,
	public IInternetProtocol
{

    // IInternetProtocolRoot
    HRESULT STDMETHODCALLTYPE Start( 
        /* [in] */ LPCWSTR szUrl,
        /* [in] */ IInternetProtocolSink *pOIProtSink,
        /* [in] */ IInternetBindInfo *pOIBindInfo,
        /* [in] */ DWORD grfPI,
        /* [in] */ DWORD dwReserved);
        
    HRESULT STDMETHODCALLTYPE Continue( 
        /* [in] */ PROTOCOLDATA *pProtocolData);
        
    HRESULT STDMETHODCALLTYPE Abort( 
        /* [in] */ HRESULT hrReason,
        /* [in] */ DWORD dwOptions);
        
    HRESULT STDMETHODCALLTYPE Terminate( 
        /* [in] */ DWORD dwOptions);
        
    HRESULT STDMETHODCALLTYPE Suspend( void);
        
    HRESULT STDMETHODCALLTYPE Resume( void);

    // IInternetProtocol
    HRESULT STDMETHODCALLTYPE Read( 
        /* [length_is][size_is][out][in] */ void *pv,
        /* [in] */ ULONG cb,
        /* [out] */ ULONG *pcbRead);
        
    HRESULT STDMETHODCALLTYPE Seek( 
        /* [in] */ LARGE_INTEGER dlibMove,
        /* [in] */ DWORD dwOrigin,
        /* [out] */ ULARGE_INTEGER *plibNewPosition);
        
    HRESULT STDMETHODCALLTYPE LockRequest( 
        /* [in] */ DWORD dwOptions);
        
    HRESULT STDMETHODCALLTYPE UnlockRequest( void);

    //

    HANDLE m_hUrlCacheStream;
    ULONG m_byteOffset;
    
public:

    CAppHandler()
    {
        m_hUrlCacheStream = 0;
    }

    ~CAppHandler();

DECLARE_REGISTRY_RESOURCEID(IDR_APPHANDLER)

BEGIN_COM_MAP(CAppHandler)
	COM_INTERFACE_ENTRY(IInternetProtocol)
	COM_INTERFACE_ENTRY(IInternetProtocolRoot)
END_COM_MAP()

};

#endif //__APPHANDLER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\daxctl\util\util.cpp ===
// Fossil file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\capphandler\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\capphandler\cacheapp.cpp ===
// cacheapp.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f cacheappps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "cacheapp.h"

#include "cacheapp_i.c"
#include "AppHandler.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_AppHandler, CAppHandler)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\capphandler\cacheapp.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Mon Feb 02 09:39:11 1998
 */
/* Compiler settings for cacheapp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __cacheapp_h__
#define __cacheapp_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IAppHandler_FWD_DEFINED__
#define __IAppHandler_FWD_DEFINED__
typedef interface IAppHandler IAppHandler;
#endif 	/* __IAppHandler_FWD_DEFINED__ */


#ifndef __AppHandler_FWD_DEFINED__
#define __AppHandler_FWD_DEFINED__

#ifdef __cplusplus
typedef class AppHandler AppHandler;
#else
typedef struct AppHandler AppHandler;
#endif /* __cplusplus */

#endif 	/* __AppHandler_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IAppHandler_INTERFACE_DEFINED__
#define __IAppHandler_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAppHandler
 * at Mon Feb 02 09:39:11 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][helpstring][uuid] */ 



EXTERN_C const IID IID_IAppHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("A4181900-9A8E-11D1-ADF0-0000F8754B99")
    IAppHandler : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IAppHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAppHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAppHandler __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAppHandler __RPC_FAR * This);
        
        END_INTERFACE
    } IAppHandlerVtbl;

    interface IAppHandler
    {
        CONST_VTBL struct IAppHandlerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAppHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAppHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAppHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAppHandler_INTERFACE_DEFINED__ */



#ifndef __CACHEAPPLib_LIBRARY_DEFINED__
#define __CACHEAPPLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: CACHEAPPLib
 * at Mon Feb 02 09:39:11 1998
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_CACHEAPPLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_AppHandler;

class DECLSPEC_UUID("A4181901-9A8E-11D1-ADF0-0000F8754B99")
AppHandler;
#endif
#endif /* __CACHEAPPLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\capphandler\cacheapp_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.01.75 */
/* at Mon Feb 02 09:39:11 1998
 */
/* Compiler settings for cacheapp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IAppHandler = {0xA4181900,0x9A8E,0x11D1,{0xAD,0xF0,0x00,0x00,0xF8,0x75,0x4B,0x99}};


const IID LIBID_CACHEAPPLib = {0xA41818F3,0x9A8E,0x11D1,{0xAD,0xF0,0x00,0x00,0xF8,0x75,0x4B,0x99}};


const CLSID CLSID_AppHandler = {0xA4181901,0x9A8E,0x11D1,{0xAD,0xF0,0x00,0x00,0xF8,0x75,0x4B,0x99}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\capphandler\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/


#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( cacheapp )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( cacheapp ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\capphandler\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cacheapp.rc
//
#define IDS_PROJNAME                    100
#define IDR_APPHANDLER                  101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\lmauth\header.h ===
#include "source.h"
#include <stdio.h>

static const CLSID CLSID_ImageSrc = { /* 3437851e-9119-11d1-adea-0000f8754b99 */
    0x3437851e,
    0x9119,
    0x11d1,
    {0xad, 0xea, 0x00, 0x00, 0xf8, 0x75, 0x4b, 0x99}
  };

class CDiSrcStream : public CSourceStream
{
    HRESULT OnThreadCreate(void);
    HRESULT OnThreadDestroy(void);
    HRESULT FillBuffer(IMediaSample *pms);

    HRESULT DecideBufferSize(IMemAllocator * pAlloc, ALLOCATOR_PROPERTIES * ppropInputRequest) ;
    HRESULT GetMediaType(int iPosition, CMediaType *pmt);
    HRESULT GetMediaType(CMediaType *pMediaType);
    
    FILE *m_pFile;

public:

    CDiSrcStream(class CDiSrc *pParent, HRESULT *phr);
};

class CDiSrc : public CSource, IFileSourceFilter
{
    CDiSrc(LPUNKNOWN punk, HRESULT *phr);

    DECLARE_IUNKNOWN;
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    STDMETHODIMP Load(LPCOLESTR pszFileName, const AM_MEDIA_TYPE *mt);
    STDMETHODIMP GetCurFile(LPOLESTR * ppszFileName, AM_MEDIA_TYPE *mt);
    WCHAR m_wszFileName[MAX_PATH];

    CDiSrcStream m_outpin;

public:
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN punk, HRESULT *phr) { return new CDiSrc(punk, phr); }

    friend class CDiSrcStream;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\capphandler\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A41818F7_9A8E_11D1_ADF0_0000F8754B99__INCLUDED_)
#define AFX_STDAFX_H__A41818F7_9A8E_11D1_ADF0_0000F8754B99__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <urlmon.h>
#include <wininet.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A41818F7_9A8E_11D1_ADF0_0000F8754B99__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\lmauth\simpread.cpp ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved


// Simple parser filter
//
// Positional information is supported by the pins, which expose IMediaPosition.
// upstream pins will use this to tell us the start/stop position and rate to
// use
//

#include <streams.h>
#include "simpread.h"

// ok to use this as it is not dereferenced
#pragma warning(disable:4355)


/* Implements the CSimpleReader public member functions */


// constructors etc
CSimpleReader::CSimpleReader(
    TCHAR *pName,
    LPUNKNOWN pUnk,
    REFCLSID refclsid,
    CCritSec *pLock,
    HRESULT *phr)
    : m_pLock(pLock),
      CBaseFilter(pName, pUnk, pLock, refclsid),
      m_Input(this, pLock, phr, L"Reader"),
      m_Output(NAME("Output pin"), phr, this, pLock, L"Out"),
      m_pAsyncReader(NULL)
{
}

CSimpleReader::~CSimpleReader()
{
}


// pin enumerator calls this
int CSimpleReader::GetPinCount() {
    // only expose output pin if we have a reader.
    return m_pAsyncReader ? 2 : 1;
};

// return a non-addrefed pointer to the CBasePin.
CBasePin *
CSimpleReader::GetPin(int n)
{
    if (n == 0)
	return &m_Input;

    if (n == 1)
	return &m_Output;
    
    return NULL;
}

HRESULT CSimpleReader::NotifyInputConnected(IAsyncReader *pAsyncReader)
{
    // these are reset when disconnected
    ASSERT(m_pAsyncReader == 0);

    // m_iStreamSeekingIfExposed = -1;

    // fail if any output pins are connected.
    if (m_Output.GetConnected()) {
	// !!! can't find a good error.
	return VFW_E_FILTER_ACTIVE;
    }

    // done here because CreateOutputPins uses m_pAsyncReader
    m_pAsyncReader = pAsyncReader;
    pAsyncReader->AddRef();

    HRESULT hr = ParseNewFile();

    if (FAILED(hr)) {
	m_pAsyncReader->Release();
	m_pAsyncReader = 0;
	return hr;
    }

    // set duration and length of stream
    m_Output.SetDuration(m_sLength, SampleToRefTime(m_sLength));
    
     // !!! anything else to set up here?
    
    return hr;
}

HRESULT CSimpleReader::NotifyInputDisconnected()
{
    if (m_pAsyncReader) {
	m_pAsyncReader->Release();
	m_pAsyncReader = 0;
    }

    // !!! disconnect output???

    return S_OK;
}


HRESULT CSimpleReader::SetOutputMediaType(const CMediaType* mtOut)
{
    m_Output.SetMediaType(mtOut);

    return S_OK;
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// input pin

CReaderInPin::CReaderInPin(CSimpleReader *pFilter,
			   CCritSec *pLock,
			   HRESULT *phr,
			   LPCWSTR pPinName) :
   CBasePin(NAME("in pin"), pFilter, pLock, phr, pPinName, PINDIR_INPUT)
{
    m_pFilter = pFilter;
}

CReaderInPin::~CReaderInPin()
{
}

HRESULT CReaderInPin::CheckMediaType(const CMediaType *mtOut)
{
    return m_pFilter->CheckMediaType(mtOut);
}

HRESULT CReaderInPin::CheckConnect(IPin * pPin)
{
    HRESULT hr;

    hr = CBasePin::CheckConnect(pPin);
    if (FAILED(hr))
	return hr;

    IAsyncReader *pAsyncReader = 0;
    hr = pPin->QueryInterface(IID_IAsyncReader, (void**)&pAsyncReader);
    if(SUCCEEDED(hr))
	pAsyncReader->Release();

    // E_NOINTERFACE is a reasonable error
    return hr;
}

// ------------------------------------------------------------------------
// calls the filter to parse the file and create the output pins.

HRESULT CReaderInPin::CompleteConnect(
  IPin *pReceivePin)
{
    HRESULT hr = CBasePin::CompleteConnect(pReceivePin);
    if(FAILED(hr))
	return hr;

    IAsyncReader *pAsyncReader = 0;
    hr = pReceivePin->QueryInterface(IID_IAsyncReader, (void**)&pAsyncReader);
    if(FAILED(hr))
	return hr;

    hr = m_pFilter->NotifyInputConnected(pAsyncReader);
    pAsyncReader->Release();

    return hr;
}

HRESULT CReaderInPin::BreakConnect()
{
    HRESULT hr = CBasePin::BreakConnect();
    if(FAILED(hr))
	return hr;

    return m_pFilter->NotifyInputDisconnected();
}

/* Implements the CReaderStream class */


CReaderStream::CReaderStream(
    TCHAR *pObjectName,
    HRESULT * phr,
    CSimpleReader * pFilter,
    CCritSec *pLock,
    LPCWSTR wszPinName)
    : CBaseOutputPin(pObjectName, pFilter, pLock, phr, wszPinName)
    , CSourceSeeking(NAME("source position"), (IPin*) this, phr, &m_WorkerLock)
    , m_pFilter(pFilter)
{
}

CReaderStream::~CReaderStream()
{
}

STDMETHODIMP
CReaderStream::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IMediaSeeking) {
	return GetInterface((IMediaSeeking *) this, ppv);
    } else {
	return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}


// IPin interfaces


// return default media type & format
HRESULT
CReaderStream::GetMediaType(int iPosition, CMediaType* pt)
{
    // check it is the single type they want
    if (iPosition<0) {
	return E_INVALIDARG;
    }
    if (iPosition>0) {
	return VFW_S_NO_MORE_ITEMS;
    }

    CopyMediaType(pt, &m_mt);

    return S_OK;
}

// check if the pin can support this specific proposed type&format
HRESULT
CReaderStream::CheckMediaType(const CMediaType* pt)
{
    // we support exactly the type specified in the file header, and
    // no other.

    if (m_mt == *pt) {
	return NOERROR;
    } else {
	return E_INVALIDARG;
    }
}

HRESULT
CReaderStream::DecideBufferSize(IMemAllocator * pAllocator,
			     ALLOCATOR_PROPERTIES *pProperties)
{
    ASSERT(pAllocator);
    ASSERT(pProperties);

    // !!! how do we decide how many to get ?
    pProperties->cBuffers = 4;

    pProperties->cbBuffer = m_pFilter->GetMaxSampleSize();

    // ask the allocator for these buffers
    ALLOCATOR_PROPERTIES Actual;
    HRESULT hr = pAllocator->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
	return hr;
    }

    return NOERROR;
}

// this pin has gone active. Start the thread pushing
HRESULT
CReaderStream::Active()
{
    // do nothing if not connected - its ok not to connect to
    // all pins of a source filter
    if (m_Connected == NULL) {
	return NOERROR;
    }

    HRESULT hr = CBaseOutputPin::Active();
    if (FAILED(hr)) {
	return hr;
    }


    // start the thread
    if (!ThreadExists()) {
	if (!Create()) {
	    return E_FAIL;
	}
    }

    return RunThread();
}

// pin has gone inactive. Stop and exit the worker thread
HRESULT
CReaderStream::Inactive()
{
    if (m_Connected == NULL) {
	return NOERROR;
    }

    HRESULT hr;
    if (ThreadExists()) {
	hr = StopThread();

	if (FAILED(hr)) {
	    return hr;
	}

	hr = ExitThread();
	if (FAILED(hr)) {
	    return hr;
	}
    }
    return CBaseOutputPin::Inactive();
}

#if 0  // MIDL and structs don't match well
STDMETHODIMP
CReaderStream::Notify(IBaseFilter * pSender, Quality q)
{
   // ??? Try to adjust the quality to avoid flooding/starving the
   // components downstream.
   //
   // ideas anyone?

   return E_NOTIMPL;  // We are (currently) NOT handling this
}
#endif

// worker thread stuff


BOOL
CReaderStream::Create()
{
    CAutoLock lock(&m_AccessLock);

    return CAMThread::Create();
}


HRESULT
CReaderStream::RunThread()
{
    return CallWorker(CMD_RUN);
}

HRESULT
CReaderStream::StopThread()
{
    return CallWorker(CMD_STOP);
}


HRESULT
CReaderStream::ExitThread()
{
    CAutoLock lock(&m_AccessLock);

    HRESULT hr = CallWorker(CMD_EXIT);
    if (FAILED(hr)) {
	return hr;
    }

    // wait for thread completion and then close
    // handle (and clear so we can start another later)
    Close();

    return NOERROR;
}


// called on the worker thread to do all the work. Thread exits when this
// function returns.
DWORD
CReaderStream::ThreadProc()
{

    BOOL bExit = FALSE;
    while (!bExit) {

	Command cmd = GetRequest();

	switch (cmd) {

	case CMD_EXIT:
	    bExit = TRUE;
	    Reply(NOERROR);
	    break;

	case CMD_RUN:
	    Reply(NOERROR);
	    DoRunLoop();
	    break;

	case CMD_STOP:
	    Reply(NOERROR);
	    break;

	default:
	    Reply(E_NOTIMPL);
	    break;
	}
    }
    return NOERROR;
}

void
CReaderStream::DoRunLoop(void)
{
    // snapshot start and stop times from the other thread
    CRefTime tStart, tStopAt;
    double dRate;
    LONG sStart;
    LONG sStopAt;

    while (TRUE) {

	// each time before re-entering the push loop, check for changes
	// in start, stop or rate. If start has not changed, pick up from the
	// same current position.
	{
	    CAutoLock lock(&m_WorkerLock);

	    tStart = Start();
	    tStopAt = Stop();
	    dRate = Rate();

	    sStart = m_pFilter->RefTimeToSample(tStart);
	    sStopAt = m_pFilter->RefTimeToSample(tStopAt);

	    // if the stream is temporally compressed, we need to start from
	    // the previous key frame and play from there. All samples until the
	    // actual start will be marked with negative times.
	    // we send tStart as time 0, and start from tCurrent which may be
	    // negative

	}

	LONG sCurrent = m_pFilter->StartFrom(sStart);

	// check we are not going over the end
	sStopAt = min(sStopAt, (LONG) m_pFilter->m_sLength-1);

	// set the variables checked by PushLoop - these can also be set
	// on the fly
	SetRateInternal(dRate);
	SetStopAt(sStopAt, tStopAt);
	ASSERT(sCurrent >= 0);

	// returns S_OK if reached end
	HRESULT hr = PushLoop(sCurrent, sStart, tStart, dRate);
	if (VFW_S_NO_MORE_ITEMS == hr) {

	    DbgLog((LOG_ERROR,1,TEXT("Sending EndOfStream")));
	    // all done
	    // reached end of stream - notify downstream
	    DeliverEndOfStream();
	
	    break;
	} else if (FAILED(hr)) {

	    // signal an error to the filter graph and stop

	    // This could be the error reported from GetBuffer when we
	    // are stopping. In that case, nothing is wrong, really
	    if (hr != VFW_E_NOT_COMMITTED) {
		DbgLog((LOG_ERROR,1,TEXT("PushLoop failed! hr=%lx"), hr));
		m_pFilter->NotifyEvent(EC_ERRORABORT, hr, 0);

		DeliverEndOfStream();
	    } else {
		DbgLog((LOG_TRACE,1,TEXT("PushLoop failed! But I don't care")));
	    }

	    break;
	} else if(hr == S_OK) {
	    // not my error to report. or someone wants to stop. queitly
	    // exit.
	    break;
	} // else S_FALSE - go round again

	Command com;
	if (CheckRequest(&com)) {
	    // if it's a run command, then we're already running, so
	    // eat it now.
	    if (com == CMD_RUN) {
		GetRequest();
		Reply(NOERROR);
	    } else {
		break;
	    }
	}
    }

    DbgLog((LOG_TRACE,1,TEXT("Leaving streaming loop")));
}


// return S_OK if reach sStop, S_FALSE if pos changed, or else error
HRESULT
CReaderStream::PushLoop(
    LONG sCurrent,
    LONG sStart,
    CRefTime tStart,
    double dRate
    )
{
    DbgLog((LOG_TRACE,1,TEXT("Entering streaming loop: start = %d, stop=%d"),
	    sCurrent, GetStopAt()));

    LONG sFirst = sCurrent; // remember the first thing we're sending

    // since we are starting on a new segment, notify the downstream pin
    DeliverNewSegment(tStart, GetStopTime(), GetRate());


    // we send one sample at m_sStopAt, but we set the time stamp such that
    // it won't get rendered except for media types that understand static
    // rendering (eg video). This means that play from 10 to 10 does the right
    // thing (completing, with frame 10 visible and no audio).

    while (sCurrent <= GetStopAt()) {

	DWORD sCount;

	// get a buffer
	DbgLog((LOG_TRACE,5,TEXT("Getting buffer...")));

	IMediaSample *pSample;
	HRESULT hr = GetDeliveryBuffer(&pSample, NULL, NULL, 0);

	if (FAILED(hr)) {
	    DbgLog((LOG_ERROR,1,TEXT("Error %lx getting delivery buffer"), hr));
	    return hr;
	}

	DbgLog((LOG_TRACE,5,TEXT("Got buffer, size=%d"), pSample->GetSize()));

	// mark sample as preroll or not....
	pSample->SetPreroll(sCurrent < sStart);
	
	// If this is the first thing we're sending, it is discontinuous
	// from the last thing they received.
	if (sCurrent == sFirst)
	    pSample->SetDiscontinuity(TRUE);
	else
	    pSample->SetDiscontinuity(FALSE);

	// !!! actually get data here!!!!!!
	hr = m_pFilter->FillBuffer(pSample, sCurrent, &sCount);

	if (FAILED(hr)) {
	    DbgLog((LOG_ERROR,1,TEXT("FillBuffer failed!  hr = %x"), hr));

	    return hr;
	}
	
	// set the start/stop time for this sample.
	CRefTime tThisStart = m_pFilter->SampleToRefTime(sCurrent) - tStart;
	CRefTime tThisEnd = m_pFilter->SampleToRefTime(sCurrent + sCount) - tStart;

	// we may have pushed a sample past the stop time, but we need to
	// make sure that the stop time is correct
	tThisEnd = min(tThisEnd, GetStopTime());

	// adjust both times by Rate... unless Rate is 0

	if (dRate && (dRate!=1.0)) {
	    tThisStart = LONGLONG( tThisStart.GetUnits() / dRate);
	    tThisEnd = LONGLONG( tThisEnd.GetUnits() / dRate);
	}

	pSample->SetTime((REFERENCE_TIME *)&tThisStart,
			 (REFERENCE_TIME *)&tThisEnd);


	DbgLog((LOG_TRACE,5,TEXT("Sending buffer, size = %d"), pSample->GetActualDataLength()));
	hr = Deliver(pSample);

	// done with buffer. connected pin may have its own addref
	DbgLog((LOG_TRACE,4,TEXT("Sample is delivered - releasing")));
	pSample->Release();
	if (FAILED(hr)) {
	    DbgLog((LOG_ERROR,1,TEXT("... but sample FAILED to deliver! hr=%lx"), hr));
	    // pretend everything's OK.  If we return an error, we'll panic
	    // and send EC_ERRORABORT and EC_COMPLETE, which is the wrong thing
	    // to do if we've tried to deliver something downstream.  Only
	    // if the downstream guy never got a chance to see the data do I
	    // feel like panicing.  For instance, the downstream guy could
	    // be failing because he's already seen EndOfStream (this thread
	    // hasn't noticed it yet) and he's already sent EC_COMPLETE and I
	    // would send another one!
	    return S_OK;
	}
	sCurrent += sCount;
	
	// what about hr==S_FALSE... I thought this would mean that
	// no more data should be sent down the pipe.
	if (hr == S_FALSE) {
	    DbgLog((LOG_ERROR,1,TEXT("Received S_FALSE from Deliver, stopping delivery")));
	    return S_OK;
	}
	
	// any other requests ?
	Command com;
	if (CheckRequest(&com)) {
	    return S_FALSE;
	}

    }

    DbgLog((LOG_TRACE,1,TEXT("Leaving streaming loop: current = %d, stop=%d"),
	    sCurrent, GetStopAt()));
    return VFW_S_NO_MORE_ITEMS;
}

// ------ IMediaPosition implementation -----------------------

HRESULT
CReaderStream::ChangeStart()
{
    // this lock should not be the same as the lock that protects access
    // to the start/stop/rate values. The worker thread will need to lock
    // that on some code paths before responding to a Stop and thus will
    // cause deadlock.

    // what we are locking here is access to the worker thread, and thus we
    // should hold the lock that prevents more than one client thread from
    // accessing the worker thread.

    CAutoLock lock(&m_AccessLock);

    if (ThreadExists()) {

	// next time round the loop the worker thread will
	// pick up the position change.
	// We need to flush all the existing data - we must do that here
	// as our thread will probably be blocked in GetBuffer otherwise

	DeliverBeginFlush();

	// make sure we have stopped pushing
	StopThread();

	// complete the flush
	DeliverEndFlush();

	// restart
	RunThread();
    }
    return S_OK;
}

HRESULT
CReaderStream::ChangeRate()
{
    // changing the rate can be done on the fly

    SetRateInternal(Rate());
    return S_OK;
}

HRESULT
CReaderStream::ChangeStop()
{
    // we don't need to restart the worker thread to handle stop changes
    // and in any case that would be wrong since it would then start
    // pushing from the wrong place. Set the variables used by
    // the PushLoop
    REFERENCE_TIME tStopAt;
    {
        CAutoLock lock(&m_WorkerLock);
        tStopAt = Stop();
    }
    LONG sStopAt = m_pFilter->RefTimeToSample(tStopAt);
    SetStopAt(sStopAt, tStopAt);

    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\lmauth\simpread.h ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved

//
//
// implements quartz stream handler interfaces by mapping to avifile apis.
//

// forward declarations

#ifndef __SIMPLEREADER__
#define __SIMPLEREADER__

class CReaderStream;     // owns a particular stream
class CSimpleReader;     // overall container class

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// input pin. uses IAsyncReader and not IMemInputPin

class CReaderInPin : public CBasePin
{
protected:
    class CSimpleReader* m_pFilter;

public:
    CReaderInPin(
		 class CSimpleReader *pFilter,
		 CCritSec *pLock,
		 HRESULT *phr,
		 LPCWSTR pPinName);

    virtual ~CReaderInPin();

    // CBasePin overrides
    virtual HRESULT CheckMediaType(const CMediaType* mtOut);
    virtual HRESULT CheckConnect(IPin * pPin);
    virtual HRESULT CompleteConnect(IPin *pReceivePin);
    virtual HRESULT BreakConnect();

    STDMETHODIMP BeginFlush(void) { return E_UNEXPECTED; }
    STDMETHODIMP EndFlush(void) { return E_UNEXPECTED; }
};

// CReaderStream
// represents one stream of data within the file
// responsible for delivering data to connected components
//
// supports IPin
//
// never created by COM, so no CreateInstance or entry in global
// FactoryTemplate table. Only ever created by a CSimpleReader object and
// returned via the EnumPins interface.
//

class CReaderStream : public CBaseOutputPin, public CAMThread, public CSourceSeeking
{

public:

    CReaderStream(
	TCHAR *pObjectName,
	HRESULT * phr,
	CSimpleReader * pFilter,
	CCritSec *pLock,
	LPCWSTR wszPinName);

    ~CReaderStream();

    // expose IMediaPosition via CImplPosition, rest via CBaseOutputPin
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** pv);

    // IPin

    HRESULT GetMediaType(int iPosition,CMediaType* pt);

    // check if the pin can support this specific proposed type&format
    HRESULT CheckMediaType(const CMediaType*);

    // say how big our buffers should be and how many we want
    HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES *pProperties);

    // Override to start & stop thread
    HRESULT Active();
    HRESULT Inactive();


    // ----- called by worker thread ---

    // access the stop and rate variables used by PushLoop
    // called by worker thread and
    double GetRate(void) {
        // not atomic - so use critsec
        CAutoLock lock(&m_WorkerLock);
        return m_dRate;
    }
    void SetRateInternal(double dRate) {
        // not atomic so hold critsec
        CAutoLock lock(&m_WorkerLock);
        m_dRate = dRate;
    }
    LONG GetStopAt(void) {
        // atomic so no critsec
        return m_sStopAt;
    }
    REFERENCE_TIME GetStopTime(void) {
        // not atomic - so use critsec
        CAutoLock lock(&m_WorkerLock);
        return m_rtStop;
    }
    void SetStopAt(DWORD sStop, REFERENCE_TIME tStop) {
        // not atomic - so use critsec
        CAutoLock lock(&m_WorkerLock);
        m_rtStop = tStop;
	m_sStopAt = sStop;
    }

    void SetDuration(DWORD sDuration, REFERENCE_TIME tDuration) {
        // not atomic - so use critsec
        CAutoLock lock(&m_WorkerLock);

	m_sStopAt = sDuration;

        // set them in the base class
	m_rtDuration = tDuration;
	m_rtStop = tDuration;
    }

private:

    CSimpleReader * m_pFilter;

    // CSourcePosition stuff
    // the worker thread PushLoop is checking against these for every sample
    // Use Get/SetRate Get/SetStop to access from worker thread
    LONG m_sStopAt;


    HRESULT ChangeStart();
    HRESULT ChangeStop();
    HRESULT ChangeRate();

#if 0    // MIDL and structs don't match well
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);
#endif
    
    double Rate() {
	return m_dRateSeeking;
    };
    CRefTime Start() {
        // not atomic, so use critsec
        ASSERT(CritCheckIn(&m_WorkerLock));
	return m_rtStart;
    };
    CRefTime Stop() {
        // not atomic, so use critsec
        ASSERT(CritCheckIn(&m_WorkerLock));
	return m_rtStop;
    };

    // worker thread stuff
    enum Command { CMD_RUN, CMD_STOP, CMD_EXIT };

    // type-corrected overrides of communication funcs
    Command GetRequest() {
	return (Command) CAMThread::GetRequest();
    };

    BOOL CheckRequest(Command * pCom) {
	return CAMThread::CheckRequest( (DWORD *) pCom);
    };

    void DoRunLoop(void);

    // return S_OK if reach sStop, S_FALSE if pos changed, or else error
    HRESULT PushLoop(
		LONG sCurrent,
		LONG sStart,
		CRefTime tStart,
		double dRate
		);

    CCritSec m_WorkerLock;
    CCritSec m_AccessLock;
    
public:
    BOOL Create();

    DWORD ThreadProc();

    // commands we can give the thread
    HRESULT RunThread();
    HRESULT StopThread();

    HRESULT ExitThread();

};

//
// CSimpleReader represents an avifile
//
// responsible for
// -- finding file and enumerating streams
// -- giving access to individual streams within the file
// -- control of streaming
//

class CSimpleReader : public CBaseFilter
{
public:

    // constructors etc
    CSimpleReader(TCHAR *, LPUNKNOWN, REFCLSID, CCritSec *, HRESULT *);
    ~CSimpleReader();

    // create a new instance of this class
    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    // pin enumerator calls this
    int GetPinCount();

    CBasePin * GetPin(int n);

    // input pin notifies filter of connection and gives the
    // IAsyncReader interface this way. parse the file here and create
    // output pins (leave pins in a state ready to connect downstream).
    virtual HRESULT NotifyInputConnected(IAsyncReader *pAsyncReader);

    virtual HRESULT NotifyInputDisconnected();

    // these must be overridden....
    virtual HRESULT ParseNewFile() = 0;
    virtual HRESULT CheckMediaType(const CMediaType* mtOut) = 0;
    virtual LONG StartFrom(LONG sStart) = 0;
    virtual HRESULT FillBuffer(IMediaSample *pSample, LONG &dwStart, DWORD *cSamples) = 0;
    
    HRESULT SetOutputMediaType(const CMediaType* mtOut);
    
    
private:

    friend class CReaderStream;
    friend class CReaderInPin;

protected:
    CReaderStream m_Output;
private:
    CReaderInPin m_Input;

    CCritSec *m_pLock;
    
public:
    IAsyncReader *m_pAsyncReader;
    DWORD	m_sLength;

protected:
    // returns the sample number starting at or after time t
    virtual LONG RefTimeToSample(CRefTime t) = 0;

    // returns the RefTime for s (media time)
    virtual CRefTime SampleToRefTime(LONG s) = 0;

    virtual ULONG GetMaxSampleSize() = 0;
};


#endif // __SIMPLEREADER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\lmauth\parse.x.cpp ===
#include <streams.h>
#include "simpread.h"
#include "header.h"

// {689C8D50-70CA-11d1-ADE4-0000F8754B99}
static const GUID CLSID_DotXParser = 
{ 0x689c8d50, 0x70ca, 0x11d1, { 0xad, 0xe4, 0x0, 0x0, 0xf8, 0x75, 0x4b, 0x99 } };

// this is a FourCC Guid - FOURCCMap(FCC('DOTX')). but it doesn't need
// to be a 4cc guid
// {58544f44-0000-0010-8000-00AA00389B71}
static const GUID CLSID_DotXStream = 
{ 0x58544f44, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71} };

struct SizeWidthHeight
{
    DWORD dwcbMax;
    DWORD dwWidth;
    DWORD dwHeight;
};


// space for the max sample size up front.
#define INITIAL_OFFSET sizeof(SizeWidthHeight) + sizeof(GUID)


AMOVIESETUP_MEDIATYPE sudDOTXInPinTypes =   {
  &MEDIATYPE_Stream,            // clsMajorType
  &CLSID_DotXStream };          // clsMinorType

AMOVIESETUP_MEDIATYPE sudDOTXOutPinTypes =   {
  &MEDIATYPE_LMRT,              // clsMajorType
  &GUID_NULL };                 // clsMinorType



AMOVIESETUP_PIN psudDOTXPins[] =
{
  { L"Input"                    // strName
    , FALSE                     // bRendered
    , FALSE                     // bOutput
    , FALSE                     // bZero
    , FALSE                     // bMany
    , &CLSID_NULL               // clsConnectsToFilter
    , L""                       // strConnectsToPin
    , 1                         // nTypes
    , &sudDOTXInPinTypes        // lpTypes
  }
  ,
  { L"Output"                   // strName
    , FALSE                     // bRendered
    , TRUE                      // bOutput
    , FALSE                     // bZero
    , FALSE                     // bMany
    , &CLSID_NULL               // clsConnectsToFilter
    , L""                       // strConnectsToPin
    , 1                         // nTypes
    , &sudDOTXOutPinTypes       // lpTypes
  }
};


const AMOVIESETUP_FILTER sudDOTX =
{
  &CLSID_DotXParser             // clsID
  , L".X parser"                // strName
  , MERIT_NORMAL                // dwMerit
  , NUMELMS(psudDOTXPins)       // nPins
  , psudDOTXPins                // lpPin
};

STDAPI DllRegisterServer()
{
    // register what files should go with my media types
    HKEY hk;
    LONG lRsult = RegCreateKeyEx(
        HKEY_CLASSES_ROOT,
        TEXT("Media Type\\{e436eb83-524f-11ce-9f53-0020af0ba770}\\{58544f44-0000-0010-8000-00AA00389B71}"),
        0,                      // reserved
        0,                      // class string
        0,                      // options
        KEY_WRITE,
        0,                      // security,
        &hk,
        0);                     // disposition
    if(lRsult == ERROR_SUCCESS)
    {
        if(lRsult == ERROR_SUCCESS) {
            static const char szval[] = "0,16,,444f545800001000800000aa00389b71";
            lRsult = RegSetValueExA(hk, "0", 0, REG_SZ, (BYTE *)szval, sizeof(szval));
        }
        if(lRsult == ERROR_SUCCESS) {
            static const char szval[] = "{E436EBB5-524F-11CE-9F53-0020AF0BA770}";
            lRsult = RegSetValueExA(hk, "Source Filter", 0, REG_SZ, (BYTE *)szval, NUMELMS(szval));
        }

        EXECUTE_ASSERT(RegCloseKey(hk) == ERROR_SUCCESS);
    }
    if(lRsult == ERROR_SUCCESS)
    {
        lRsult = RegCreateKeyEx(
            HKEY_CLASSES_ROOT,
            TEXT("Media Type\\Extensions\\.urls"),
            0,                      // reserved
            0,                      // class string
            0,                      // options
            KEY_WRITE,
            0,                      // security,
            &hk,
            0);                     // disposition
        if(lRsult == ERROR_SUCCESS)
        {
            if(lRsult == ERROR_SUCCESS) {
                static const char szval[] = "{3437851e-9119-11d1-adea-0000f8754b99}";
                lRsult = RegSetValueExA(hk, "Source Filter", 0, REG_SZ, (BYTE *)szval, sizeof(szval));
            }

            EXECUTE_ASSERT(RegCloseKey(hk) == ERROR_SUCCESS);
        }
    }
    if(lRsult == ERROR_SUCCESS)
    {
        return AMovieDllRegisterServer2(TRUE);
    } else
    {
        return HRESULT_FROM_WIN32(lRsult);
    }
}

STDAPI DllUnregisterServer()
{
    LONG lResult = RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Media Type\\{e436eb83-524f-11ce-9f53-0020af0ba770}\\{58544f44-0000-0010-8000-00AA00389B71}"));
    ASSERT(lResult == ERROR_SUCCESS || lResult == ERROR_FILE_NOT_FOUND);
    lResult = RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Media Type\\Extensions\\.urls"));
    ASSERT(lResult == ERROR_SUCCESS || lResult == ERROR_FILE_NOT_FOUND);
    return AMovieDllRegisterServer2(FALSE);
}



class CParseDotX : public CSimpleReader
{
    CCritSec m_cs;

    DWORD m_dwMaxSampleSize;
    LONG m_lLastTimeStamp;
    DWORDLONG m_qwLastFileOffsetRead;
    DWORDLONG m_qwInitOffset;
    LONGLONG m_llFileLength;

    HRESULT ReadOneBlock(BYTE *pb, ULONG *pcb, LONG &lStart);


public:
    CParseDotX(LPUNKNOWN punk, HRESULT *phr);
    ~CParseDotX() {; }

    static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    // pure CSimpleReader overrides
    HRESULT ParseNewFile();
    HRESULT CheckMediaType(const CMediaType* mtIn);
    LONG StartFrom(LONG sStart) ;
    HRESULT FillBuffer(IMediaSample *pSample, LONG &lStart, DWORD *pcSamples);
    LONG RefTimeToSample(CRefTime t) { return t.Millisecs(); }
    CRefTime SampleToRefTime(LONG s) { return CRefTime(s); } // ms to 100ns
    ULONG GetMaxSampleSize() { return m_dwMaxSampleSize; }
};

static const AMOVIESETUP_FILTER sudDiSrc =
{
    &CLSID_ImageSrc,              // clsID
    L"Data Image Source",         // strName
    MERIT_DO_NOT_USE,             // dwMerit
    0,                            // nPins
    0                             // lpPin
};

CFactoryTemplate g_Templates[]= {
  {L"DOTX Parser",        &CLSID_DotXParser, CParseDotX::CreateInstance, NULL,  &sudDOTX},
  {L"Data Image Source" , &CLSID_ImageSrc ,  CDiSrc::CreateInstance ,    NULL , &sudDiSrc}
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);;

CUnknown *CParseDotX::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CParseDotX *ppdx = 0;
    if(SUCCEEDED(*phr))
    {
        ppdx = new CParseDotX(lpunk, phr);
        if(ppdx == 0) {
            *phr = E_OUTOFMEMORY;
        }

        // ignore error
    }

    return ppdx;
}

CParseDotX::CParseDotX(LPUNKNOWN punk, HRESULT *phr) :
        CSimpleReader(NAME(".X parser"), punk, CLSID_DotXParser, &m_cs, phr),
        m_qwInitOffset(INITIAL_OFFSET)
{
};

HRESULT CParseDotX::CheckMediaType(const CMediaType *pmtIn)
{
    if(pmtIn->majortype == MEDIATYPE_Stream && pmtIn->subtype == CLSID_DotXStream)
        return S_OK;
    else
        return S_FALSE;
}


HRESULT CParseDotX::ReadOneBlock(BYTE *pb, ULONG *pcb, LONG &lStart)
{
#include <pshpack4.h>
    struct Dw2
    {
        double dt;         // milliseconds
        DWORD dwcb;         // byte count
    } dw2;
#include <poppack.h>

    HRESULT hr = S_OK;
    for(;;)
    {
        hr = m_pAsyncReader->SyncRead(m_qwLastFileOffsetRead, sizeof(Dw2), (BYTE *)&dw2);
        if(hr == S_OK)
        {
            m_lLastTimeStamp = dw2.dt * 1000;

            if(dw2.dwcb <= m_dwMaxSampleSize)
            {
                if(m_lLastTimeStamp >= lStart)
                {
                    hr = m_pAsyncReader->SyncRead(m_qwLastFileOffsetRead + sizeof(Dw2), dw2.dwcb, pb);
                    if(SUCCEEDED(hr))
                    {
                        m_qwLastFileOffsetRead += sizeof(Dw2) + dw2.dwcb;
                        lStart = dw2.dt * 1000;

                        if((LONGLONG)m_qwLastFileOffsetRead < m_llFileLength)
                        {
                        }
                        else
                        {
                            m_Output.SetStopAt(0, MAX_TIME);
                        }

                        *pcb = dw2.dwcb;
                    } 
                    break;
                }
            }
            else
            {
                DbgLog((LOG_ERROR, 0, TEXT("sample in file larger than promised.")));
                hr = VFW_E_INVALID_FILE_FORMAT;
            }

            m_qwLastFileOffsetRead += sizeof(Dw2) + dw2.dwcb;
        }
        else 
        {
            // S_FALSE or an error

            // base class ignores S_FALSE so make it an error
            if(SUCCEEDED(hr)) {
                hr = HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
            }
            break;
        }


        if(FAILED(hr)) {
            break;
        }
    }

    return hr;
}

HRESULT CParseDotX::ParseNewFile()
{
    m_lLastTimeStamp = 0;
    m_sLength = 3600 * 1000 * 10; // 10 hours

    LONGLONG llAvailable;
    
    HRESULT hr = m_pAsyncReader->Length(&m_llFileLength, &llAvailable);
    if(SUCCEEDED(hr))
    {
        SizeWidthHeight swh;
        
        hr = m_pAsyncReader->SyncRead(sizeof(GUID), sizeof(swh), (BYTE *)&swh);
        if(hr == S_OK)
        {
            m_dwMaxSampleSize = swh.dwcbMax;
            
            m_qwLastFileOffsetRead = INITIAL_OFFSET;

            CMediaType mt;
            mt.SetType(&MEDIATYPE_LMRT);
            mt.SetFormatType(&CLSID_DotXStream);
            mt.SetFormat((BYTE *)&swh, sizeof(swh));

            BYTE *pb = new BYTE[m_dwMaxSampleSize];
            if(pb)
            {
                DWORDLONG dwlOldPos = m_qwLastFileOffsetRead;
                LONG lStart = -1000;
                ULONG cb;
                HRESULT hr = ReadOneBlock(pb, &cb, lStart);
                if(SUCCEEDED(hr) && lStart == -1000)
                {
                    ASSERT(cb <= m_dwMaxSampleSize);
                    mt.ReallocFormatBuffer(sizeof(swh) + cb);
                    CopyMemory(mt.pbFormat + sizeof(swh), pb, cb);
                    m_qwInitOffset = m_qwLastFileOffsetRead;
                }
                else
                {
                    m_qwLastFileOffsetRead = dwlOldPos;
                }
                mt.SetVariableSize();
                mt.SetTemporalCompression(FALSE);
                hr =  SetOutputMediaType(&mt);
                
                delete[] pb;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
            
        }
        else
        {
            hr = VFW_E_INVALID_FILE_FORMAT;
        }
    } 

    return hr;
}

HRESULT CParseDotX::FillBuffer(IMediaSample *pSample, LONG &lStart, DWORD *pcSamples)
{
    BYTE *pb;
    ULONG cb;
    pSample->GetPointer(&pb);
    HRESULT hr = ReadOneBlock(pb, &cb, lStart);
    pSample->SetActualDataLength(cb);
    *pcSamples = 100;
    return hr;
}

LONG CParseDotX::StartFrom(LONG sStart)
{
    // start from the beginning.
    { m_qwLastFileOffsetRead = m_qwInitOffset; return sStart; };
}


extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE, ULONG, LPVOID);
BOOL WINAPI DllMain(  HINSTANCE hinstDLL,  // handle to DLL module
  DWORD fdwReason,     // reason for calling function
  LPVOID lpvReserved   // reserved
)
{
    return DllEntryPoint( hinstDLL, fdwReason, lpvReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\lmauth\copyfile.cpp ===
#include <streams.h>

#undef _ATL_STATIC_REGISTRY
#include <atlbase.h>
#include <atlimpl.cpp>

#ifdef COPYFILE_EXE

#include <stdio.h>
#define CHECK_ERROR(x) if (FAILED(hr = (x))) { printf(#x": %08x\n", hr); goto Exit; }
bool g_fVerbose = false;

#else

#define CHECK_ERROR(x) if (FAILED(hr = (x))) { DbgLog((LOG_ERROR, 0, #x": %08x")); goto Exit; }

#endif

HRESULT SetNoClock(IFilterGraph *graph)
{
    // Keep a useless clock from being instantiated....
    IMediaFilter *graphF;
    HRESULT hr = graph->QueryInterface(IID_IMediaFilter, (void **) &graphF);

    if (SUCCEEDED(hr)) {
	hr = graphF->SetSyncSource(NULL);
	graphF->Release();
    }

    return hr;
}

HRESULT RenderOneOutputPin(ICaptureGraphBuilder *pBuilder, IBaseFilter *pMux, IPin *pPin);

HRESULT RenderAllOutputPins(ICaptureGraphBuilder *pBuilder, IBaseFilter *pMux, IBaseFilter *pFilter)
{
    IEnumPins *pep;
    HRESULT hr = pFilter->EnumPins(&pep);
    if(SUCCEEDED(hr))
    {
        IPin *rgppin[1];
        ULONG cFetched;
        while(pep->Next(1, rgppin, &cFetched) == S_OK)
        {
            PIN_DIRECTION dir;
            if(rgppin[0]->QueryDirection(&dir) == S_OK && dir == PINDIR_OUTPUT) {
                hr = RenderOneOutputPin(pBuilder, pMux, rgppin[0]);
            }
            rgppin[0]->Release();

            if(FAILED(hr)) {
                break;
            }
        }

        pep->Release();
    }

    return hr;
}

HRESULT RenderInputPin(ICaptureGraphBuilder *pBuilder, IBaseFilter *pMux, IPin *pPin)
{
    HRESULT hr = S_OK;

    CComPtr<IPin> rgpin[100];
    ULONG cSlots = NUMELMS(rgpin);
    hr = pPin->QueryInternalConnections((IPin **)rgpin, &cSlots);
    if(SUCCEEDED(hr))
    {
        for(ULONG iPin = 0; iPin < cSlots; iPin++) {
            hr = RenderOneOutputPin(pBuilder, pMux, rgpin[iPin]);
        }
    }
    else
    {
        PIN_INFO pi;
        hr = pPin->QueryPinInfo(&pi);
        if(SUCCEEDED(hr))
        {
            ASSERT(pi.dir == PINDIR_INPUT);
            hr = RenderAllOutputPins(pBuilder, pMux, pi.pFilter);
            pi.pFilter->Release();
        }
    }

    return hr;
}

HRESULT RenderOneOutputPin(ICaptureGraphBuilder *pBuilder, IBaseFilter *pMux, IPin *pPin)
{
    HRESULT hr = S_OK;
    
    IPin *pPinCon;
    hr = pPin->ConnectedTo(&pPinCon);
    if(SUCCEEDED(hr))
    {
        PIN_INFO pi;
        hr = pPinCon->QueryPinInfo(&pi);
        if(SUCCEEDED(hr))
        {
            ASSERT(pi.dir == PINDIR_INPUT);
            hr = RenderAllOutputPins(pBuilder, pMux, pi.pFilter);
            pi.pFilter->Release();
        }

        pPinCon->Release();
    }
    else                // not connected
    {
        hr = pBuilder->RenderStream(0, pPin, 0, pMux);
        // if(hr == VFW_S_PARTIAL_RENDER)
        if(SUCCEEDED(hr))
        {
            hr = pPin->ConnectedTo(&pPinCon);
            if(SUCCEEDED(hr))
            {
                hr = RenderInputPin(pBuilder, pMux, pPinCon);
                pPinCon->Release();
            }
        }
    }

    return hr;
}

#define DllExport   __declspec( dllexport )
DllExport STDAPI LmrtCopyfile(
    LPCWSTR szOutputFile,
    const CLSID *pmtFile,
    ULONG cbps,                 // zero to pick a default
    UINT cInputs,
    LPCWSTR *rgSzInputs,
    ULONG *pmsPreroll);

STDAPI LmrtCopyfile(
    LPCWSTR szOutputFile,
    const CLSID *pmtFile,
    ULONG cbps,                 // zero to pick a default
    UINT cInputs,
    LPCWSTR *rgSzInputs,
    ULONG *pmsPreroll)
{
    HRESULT hr = S_OK;
    USES_CONVERSION;

    CComPtr <ICaptureGraphBuilder> pBuilder;
    CComPtr <IFileSinkFilter> pFileSinkWriter;
    CComPtr <IBaseFilter> pMuxFilter;
    CComPtr <IGraphBuilder> pGraph;
    CComQIPtr <IMediaControl, &IID_IMediaControl> pGraphC;
    CComQIPtr <IMediaEvent, &IID_IMediaEvent> pEvent;
    CComQIPtr<IConfigInterleaving, &IID_IConfigInterleaving> pInterleaving;
    CComQIPtr<IConfigAviMux, &IID_IConfigAviMux> pCfgMux;
    CComQIPtr<IFileSinkFilter2, &IID_IFileSinkFilter2> pCfgFw;


    CHECK_ERROR(CoCreateInstance(CLSID_CaptureGraphBuilder, NULL, CLSCTX_INPROC_SERVER,
                                 IID_ICaptureGraphBuilder, (void **)&pBuilder));

    CHECK_ERROR(pBuilder->SetOutputFileName(
        pmtFile,
        szOutputFile,
        &pMuxFilter, &pFileSinkWriter));

    CHECK_ERROR(pBuilder->GetFiltergraph(&pGraph));

    if(cbps != 0)
    {
        CComQIPtr<IConfigAsfMux, &IID_IConfigAsfMux> pcfgasf(pMuxFilter);
        if(pcfgasf)
        {
            CHECK_ERROR(pcfgasf->SetPeakBitRate(cbps));
        }
        else
        {
#ifdef COPYFILE_EXE
            fprintf(stderr, "bitrate not supported\n");
#endif
        }
    }

    pInterleaving = pMuxFilter;// auto QI
    if(pInterleaving)
    {
        // set interleaving mode to FULL (should this be a command
        // line option?)
        CHECK_ERROR(pInterleaving->put_Mode(INTERLEAVE_FULL));
    }
        
    pCfgMux = pMuxFilter;   // auto qi
    if(pCfgMux) {
        // waste less space. The Compatiblity Index is for VFW
        // playback support. We only care about DShow
        CHECK_ERROR(pCfgMux->SetOutputCompatibilityIndex(FALSE));
    }

        
    // create new files each time
    pCfgFw = pFileSinkWriter; // auto qi
    if(pCfgFw) {
        CHECK_ERROR(pCfgFw->SetMode(AM_FILE_OVERWRITE));
    }
    
    
    CHECK_ERROR(SetNoClock(pGraph));

    {
        for(UINT i = 0; i < cInputs; i++)
        {
            CComPtr<IBaseFilter> pSrcFilter;
            
            CHECK_ERROR(pGraph->AddSourceFilter(rgSzInputs[i], rgSzInputs[i], &pSrcFilter));

            // Just calling RenderStream will connect just one stream
            // if source file has multiple streams, so we traverse the
            // graph looking for unconnected output pins. Note some
            // source filters may have more than one output pin.
            hr = RenderAllOutputPins(pBuilder, pMuxFilter, pSrcFilter);

#ifdef COPYFILE_EXE
            printf("Rendering  %S : %08x\n", rgSzInputs[i], hr);
#endif
        }
    }

    pGraphC = pGraph;           // auto qi

        // auto QI for IMediaEvent. Do this before we run or else we
        // may lose some events (graph discards events if nobody can
        // collect them.
    pEvent = pGraph;
    
    CHECK_ERROR(pGraphC->Run());

#ifdef COPYFILE_EXE
    printf("Waiting for completion....\n");
#endif
    LONG lEvCode, lParam1, lParam2;
    for(;;)
    {
        CHECK_ERROR(pEvent->GetEvent(&lEvCode, &lParam1, &lParam2, INFINITE));
        CHECK_ERROR(pEvent->FreeEventParams(lEvCode, lParam1, lParam2));

        if(lEvCode == EC_COMPLETE ||
           lEvCode == EC_USERABORT ||
           lEvCode == EC_ERRORABORT ||
           lEvCode == EC_STREAM_ERROR_STOPPED)
        {
            if(lEvCode != EC_COMPLETE) {
#ifdef COPYFILE_EXE
                printf("failed  hr = %x\n", lParam1);
#endif
            }
            break;
        }
    }
        

#ifdef COPYFILE_EXE
    if (g_fVerbose) {
        printf("Done, event = %x  hr = %x\n", lEvCode, lParam1);
    }
#endif
    
    if(FAILED(lParam1)) {
        hr = lParam1;
    }

    // auto release everything

Exit:
    return hr;

}

#ifdef COPYFILE_EXE

int __cdecl
main(
    int argc,
    char *argv[]
    )
{
    BOOL fVerbose = FALSE, fAsf = FALSE;;
    USES_CONVERSION;
    HRESULT hr = S_OK;

    ULONG cbps = 0;
    char *szOut = 0;

    int i = 1;
    while (i < argc && (argv[i][0] == '-' || argv[i][0] == '/'))
    {
	// options

        if (lstrcmpi(argv[i] + 1, "v") == 0) {
            fVerbose = TRUE;
        }
        else if (lstrcmpi(argv[i] + 1, "asf") == 0) {
            fAsf = TRUE;
        }
        else if(i + 1 < argc && lstrcmpi(argv[i] + 1, "bps") == 0) {
            cbps = atoi(argv[++i]);
        }
        else if(i + 1 < argc && lstrcmpi(argv[i] + 1, "o") == 0) {
            szOut = argv[++i];
        }
        else {
            fprintf(stderr, "Unrecognised switch %s\n", argv[i]);
        }

	i++;
    }
    
    UINT cFiles = argc - i;
    if (cFiles < 1 || !szOut) {
        printf("usage: copyfile [/v] [/asf] [/bps n] /o target file1 [ file2 ...] \n");
        return -1;
    }

    CoInitialize(NULL);

    const WCHAR **rgszIn = (const WCHAR **)_alloca(sizeof(WCHAR *) * cFiles);
    
    for(UINT iFile = 0; iFile < cFiles; iFile++) {
        rgszIn[iFile] = A2CW(argv[i + iFile]);
    }

    ULONG msPreroll;
    hr = LmrtCopyfile(
        A2CW(szOut),
        fAsf ? &MEDIASUBTYPE_Asf : &MEDIASUBTYPE_Avi,
        cbps,
        cFiles,
        rgszIn,
        &msPreroll);

    printf("all done %08x. preroll = %d ms.\n", hr, msPreroll);
    if(SUCCEEDED(hr))
    {
        CoUninitialize();
        return 0;
    }

Exit:

    CoUninitialize();
    return -1;
}

#endif // COPYFILE_EXE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\lmauth\source.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Classes to simplify creation of ActiveX source filters that support
// continuous generation of data. It provides no support for IMediaControl
// or IMediaPosition
//
// Derive your source filter from CSource.
// During construction either:
//    Create some CSourceStream objects to manage your pins
//    Provide the user with a means of doing so eg, an IPersistFile interface.
//
// CSource provides:
//    IBaseFilter interface management
//    IMediaFilter interface management, via CBaseFilter
//    Pin counting for CBaseFilter
//
// Derive a class from CSourceStream to manage your output pin types
//  Implement GetMediaType/1 to return the type you support. If you support multiple
//   types then overide GetMediaType/3, CheckMediaType and GetMediaTypeCount.
//  Implement Fillbuffer() to put data into one buffer.
//
// CSourceStream provides:
//    IPin management via CBaseOutputPin
//    Worker thread management

#ifndef __CSOURCE__
#define __CSOURCE__

class CSourceStream;  // The class that will handle each pin


//
// CSource
//
// Override construction to provide a means of creating
// CSourceStream derived objects - ie a way of creating pins.
class CSource : public CBaseFilter {
public:

    CSource(TCHAR *pName, LPUNKNOWN lpunk, CLSID clsid, HRESULT *phr);
    CSource(TCHAR *pName, LPUNKNOWN lpunk, CLSID clsid);
    ~CSource();

    int       GetPinCount(void);
    CBasePin *GetPin(int n);

    // -- Utilities --

    CCritSec*	pStateLock(void) { return &m_cStateLock; }	// provide our critical section

    HRESULT     AddPin(CSourceStream *);
    HRESULT     RemovePin(CSourceStream *);

    STDMETHODIMP FindPin(
        LPCWSTR Id,
        IPin ** ppPin
    );

    int FindPinNumber(IPin *iPin);
    
protected:

    int             m_iPins;       // The number of pins on this filter. Updated by CSourceStream
    	   			   // constructors & destructors.
    CSourceStream **m_paStreams;   // the pins on this filter.

    CCritSec m_cStateLock;	// Lock this to serialize function accesses to the filter state

};


//
// CSourceStream
//
// Use this class to manage a stream of data that comes from a
// pin.
// Uses a worker thread to put data on the pin.
class CSourceStream : public CAMThread, public CBaseOutputPin {
public:

    CSourceStream(TCHAR *pObjectName,
                  HRESULT *phr,
                  CSource *pms,
                  LPCWSTR pName);

    virtual ~CSourceStream(void);  // virtual destructor ensures derived class destructors are called too.

protected:

    CSource *m_pFilter;	// The parent of this stream

    // *
    // * Data Source
    // *
    // * The following three functions: FillBuffer, OnThreadCreate/Destroy, are
    // * called from within the ThreadProc. They are used in the creation of
    // * the media samples this pin will provide
    // *

    // Override this to provide the worker thread a means
    // of processing a buffer
    virtual HRESULT FillBuffer(IMediaSample *pSamp) PURE;

    // Called as the thread is created/destroyed - use to perform
    // jobs such as start/stop streaming mode
    // If OnThreadCreate returns an error the thread will exit.
    virtual HRESULT OnThreadCreate(void) {return NOERROR;};
    virtual HRESULT OnThreadDestroy(void) {return NOERROR;};
    virtual HRESULT OnThreadStartPlay(void) {return NOERROR;};

    // *
    // * Worker Thread
    // *

    HRESULT Active(void);    // Starts up the worker thread
    HRESULT Inactive(void);  // Exits the worker thread.

public:
    // thread commands
    enum Command {CMD_INIT, CMD_PAUSE, CMD_RUN, CMD_STOP, CMD_EXIT};
    HRESULT Init(void) { return CallWorker(CMD_INIT); }
    HRESULT Exit(void) { return CallWorker(CMD_EXIT); }
    HRESULT Run(void) { return CallWorker(CMD_RUN); }
    HRESULT Pause(void) { return CallWorker(CMD_PAUSE); }
    HRESULT Stop(void) { return CallWorker(CMD_STOP); }

protected:
    Command GetRequest(void) { return (Command) CAMThread::GetRequest(); }
    BOOL    CheckRequest(Command *pCom) { return CAMThread::CheckRequest( (DWORD *) pCom); }

    // override these if you want to add thread commands
    virtual DWORD ThreadProc(void);  		// the thread function

    virtual HRESULT DoBufferProcessingLoop(void);    // the loop executed whilst running


    // *
    // * AM_MEDIA_TYPE support
    // *

    // If you support more than one media type then override these 2 functions
    virtual HRESULT CheckMediaType(const CMediaType *pMediaType);
    virtual HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);  // List pos. 0-n

    // If you support only one type then override this fn.
    // This will only be called by the default implementations
    // of CheckMediaType and GetMediaType(int, CMediaType*)
    // You must override this fn. or the above 2!
    virtual HRESULT GetMediaType(CMediaType *pMediaType) {return E_UNEXPECTED;}

    STDMETHODIMP QueryId(
        LPWSTR * Id
    );
};

#endif // __CSOURCE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\lmauth\urlssrc.cpp ===
#include <streams.h>
#include "source.h"
#include "header.h"

// !!!!!
#undef _ATL_STATIC_REGISTRY

#include <atlbase.h>


#define CB_MAX (1024 * 1024)




CDiSrcStream::CDiSrcStream(CDiSrc *pParent, HRESULT *phr)
        : CSourceStream(NAME("pin"), phr, pParent, L"out")
{
    ;
}

HRESULT CDiSrcStream::OnThreadCreate(void)
{
    USES_CONVERSION;
    if(((CDiSrc *)m_pFilter)->m_wszFileName[0] != (WCHAR)-1) {
        m_pFile = fopen(W2A(((CDiSrc *)m_pFilter)->m_wszFileName), "r");
        if(m_pFile) {
            return CSourceStream::OnThreadCreate();
        }
        return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    };
    
    return E_UNEXPECTED;
}

HRESULT CDiSrcStream::OnThreadDestroy()
{
    if(m_pFile) {
        fclose(m_pFile);
    }
    return CSourceStream::OnThreadDestroy();
}

HRESULT CDiSrcStream::FillBuffer(IMediaSample *pms)
{
    BYTE *pb; EXECUTE_ASSERT(SUCCEEDED(pms->GetPointer(&pb)));
            
    char szImage[4000];
    ULONG tms;                  // time in millisec
    int x = fscanf(m_pFile, "%s %s %d", szImage, pb, &tms);
    if(x == 3)
    {
        FILE *pFile = fopen(szImage, "rb");
        if(pFile)
        {
            int cchUrl = strlen((char *)pb) + 1;
            
            long cbRead = fread(pb + cchUrl, 1, CB_MAX - cchUrl, pFile);
            EXECUTE_ASSERT(SUCCEEDED(pms->SetActualDataLength(cchUrl + cbRead)));

            REFERENCE_TIME rts = tms * (UNITS / MILLISECONDS), rte = rts + UNITS / 10;
            EXECUTE_ASSERT(SUCCEEDED(pms->SetTime(&rts, &rte)));
            
            fclose(pFile);
            return S_OK;
        }
        return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }
    else if(x == EOF)
    {
        return S_FALSE;
    }
    else
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }
}

HRESULT CDiSrcStream::DecideBufferSize(IMemAllocator * pAlloc, ALLOCATOR_PROPERTIES * ppropInputRequest)
{
    ALLOCATOR_PROPERTIES Actual, Request = *ppropInputRequest;
    Request.cbBuffer = CB_MAX;
    Request.cBuffers = 1;
    
    HRESULT hr = pAlloc->SetProperties(&Request,&Actual);
    return hr;
}

HRESULT CDiSrcStream::GetMediaType(CMediaType *pmt)
{
    pmt->majortype = MEDIATYPE_URL_STREAM;
    return S_OK;
}

HRESULT CDiSrcStream::GetMediaType(int iPosition, CMediaType *pmt)
{
    if(iPosition == 0) {
        return GetMediaType(pmt);
    }

    return VFW_S_NO_MORE_ITEMS;
}



CDiSrc::CDiSrc(LPUNKNOWN punk, HRESULT *phr) :
        CSource(NAME("image data src"), punk, CLSID_ImageSrc),
        m_outpin(this, phr)
{
    m_wszFileName[0] = (WCHAR)-1;
}

HRESULT CDiSrc::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    return riid == IID_IFileSourceFilter ?
        GetInterface((IFileSourceFilter *)this, ppv) :
        CSource::NonDelegatingQueryInterface(riid, ppv);
}

HRESULT CDiSrc:: Load(LPCOLESTR pszFileName, const AM_MEDIA_TYPE *mt)
{
    if(m_wszFileName[0] == (WCHAR)-1) {
        lstrcpyW(m_wszFileName, pszFileName);
        return S_OK;
    }
    return E_UNEXPECTED;
}

HRESULT CDiSrc::GetCurFile(LPOLESTR * ppszFileName, AM_MEDIA_TYPE *mt)
{
    if(m_wszFileName[0] != (WCHAR)-1) {
        *ppszFileName = (WCHAR *)CoTaskMemAlloc(lstrlenW(m_wszFileName) * sizeof(WCHAR) + sizeof(WCHAR));
        lstrcpyW(*ppszFileName, m_wszFileName);
        return S_OK;
    }
    return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\lmrtrend\lmrtrend.h ===
#include "lmrttype.h"
#include "danim.h"
#include "lmrt.h"

// {3C89D120-6F65-11d1-A520-000000000000}
DEFINE_GUID(IID_ILMRTRenderer,
0x3c89d120, 0x6f65, 0x11d1, 0xa5, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);

static const GUID CLSID_UrlStreamRenderer = { /* bf0b4b00-8c6c-11d1-ade9-0000f8754b99 */
    0xbf0b4b00,
    0x8c6c,
    0x11d1,
    {0xad, 0xe9, 0x00, 0x00, 0xf8, 0x75, 0x4b, 0x99}
  };



interface ILMRTRenderer : IUnknown
{
//  virtual HRESULT SetLMReader(ILMReader *pLMReader) = 0;
	virtual HRESULT SetLMEngine(ILMEngine *pLMEngine) = 0;
};

// {3C89D121-6F65-11d1-A520-000000000000}
DEFINE_GUID(CLSID_LMRTRenderer,
0x3c89d121, 0x6f65, 0x11d1, 0xa5, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);

#ifdef _STREAMS_

extern const AMOVIESETUP_FILTER sudLMRTRend;

class CLMRTRenderer : public CBaseRenderer , public ILMRTRenderer
{
public:

    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

    CLMRTRenderer(LPUNKNOWN pUnk,HRESULT *phr);
    ~CLMRTRenderer();

    DECLARE_IUNKNOWN
	    
    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);

    STDMETHODIMP Pause();
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType *pmt);
    void OnReceiveFirstSample(IMediaSample *pMediaSample);
    HRESULT DoRenderSample(IMediaSample *pMediaSample);
	HRESULT OnStopStreaming(void);
    HRESULT OnStartStreaming();
	STDMETHOD(JoinFilterGraph)( IFilterGraph *pGraph, LPCWSTR szName );
    // HRESULT EndOfStream();

	//ILMRTRenderer
//    HRESULT SetLMReader(ILMReader *pLMReader);
	HRESULT SetLMEngine(ILMEngine *pLMEngine);

protected:
//	IBindStatusCallback	*m_pIbsc;
	ILMEngine2 *m_pEngine;
	ILMReader2 *m_pReader;
	IUnknown *m_punkControl;
//	BYTE	*m_pMem;
//	IStream	*m_pstm;
//	ULONG	m_dwSize;
//	BSCF	m_bscf;

	DWORD	m_dwWidth;
	DWORD	m_dwHeight;

    BYTE *m_pbFirstPacketFromHeader;
    ULONG m_cbFirstPacketFromHeader;
    bool m_fFirstPause;

}; // CLMRTRenderer

class CUrlInPin : public CBaseInputPin
{
public:
    CUrlInPin(
        CBaseFilter *pFilter,
        CCritSec *pLock,
        HRESULT *phr
        );

    ~CUrlInPin();

    STDMETHODIMP Receive(IMediaSample *pSample);
    HRESULT CheckMediaType(const CMediaType *) ;

private:

    friend class CUrlStreamRenderer;
    TCHAR m_szTempDir[MAX_PATH];
};

class CUrlStreamRenderer :
    public CBaseFilter,
    public IPropertyBag
{
    CCritSec m_cs;
    CUrlInPin m_inPin;

    int GetPinCount() { return 1; }
    CBasePin *GetPin(int n) { ASSERT(n == 0); return &m_inPin; }

    DECLARE_IUNKNOWN;
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
    
    // IPropertyBag

    STDMETHODIMP Read(
        LPCOLESTR pszPropName, LPVARIANT pVar,
        LPERRORLOG pErrorLog);

    STDMETHODIMP Write(LPCOLESTR pszPropName, LPVARIANT pVar);
    
    CUrlStreamRenderer(LPUNKNOWN punk, HRESULT *phr);
    ~CUrlStreamRenderer() {; }


public:

    static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);
};
#endif // _STREAMS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\lmrtrend\ourcrt.cpp ===
#include <streams.h>

#ifndef _M_ALPHA

extern "C" const int _fltused = 0;

void * _cdecl operator new(size_t size)
{
    void * pv;
    pv = (void *)LocalAlloc(LMEM_FIXED, size);
    DbgLog((LOG_MEMORY, 4, TEXT("Allocating: %lx = %d"), pv, size));

    return pv;
}
void _cdecl operator delete(void *ptr)
{
    DbgLog((LOG_MEMORY, 4, TEXT("Freeing: %lx"), ptr));
    if (ptr)
	LocalFree(ptr);
}

/*
 * This function serves to avoid linking CRT code
 */

int __cdecl  _purecall(void)
{
#ifdef DEBUG
    DebugBreak();
#endif

    return(FALSE);
}

#if 0
#ifdef _X86_

// ---------------------------------------------------
//	asm_ftol()
// ---------------------------------------------------
extern "C" long __cdecl _ftol(float flX)
{
	long lResult;
	WORD wCW;
	WORD wNewCW;

	_asm
	{
		fld       flX			// Push the float onto the stack
		wait
		fnstcw    wCW			// Store the control word
		wait
		mov       ax,wCW		// Setup our rounding
		or        ah,0x0c
		mov       wNewCW,ax
		fldcw     wNewCW		// Set Control word to our new value
		fistp     lResult		// Round off top of stack into result
		fldcw     wCW			// Restore control word
		fnclex					// clear the status word of exceptions
	}

	return(lResult);
}

#endif
#endif
#endif / _M_ALPHA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\lmauth\source.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Implements CSource. A Quartz source filter 'template', March 1995

// Locking Strategy.
//
// Hold the filter critical section (m_pFilter->pStateLock()) to serialise
// access to functions. Note that, in general, this lock may be held
// by a function when the worker thread may want to hold it. Therefore
// if you wish to access shared state from the worker thread you will
// need to add another critical section object. The execption is during
// the threads processing loop, when it is safe to get the filter critical
// section from within FillBuffer().

#include <streams.h>
#include "source.h"


//
// CSource::Constructor
//
// Initialise the pin count for the filter. The user will create the pins in
// the derived class.
CSource::CSource(TCHAR *pName, LPUNKNOWN lpunk, CLSID clsid)
    : CBaseFilter(pName, lpunk, &m_cStateLock, clsid),
      m_iPins(0),
      m_paStreams(NULL)
{
}

CSource::CSource(TCHAR *pName, LPUNKNOWN lpunk, CLSID clsid, HRESULT *phr)
    : CBaseFilter(pName, lpunk, &m_cStateLock, clsid),
      m_iPins(0),
      m_paStreams(NULL)
{
    UNREFERENCED_PARAMETER(phr);
}

//
// CSource::Destructor
//
CSource::~CSource()
{
    /*  Free our pins and pin array */
    while (m_iPins != 0) {
	// deleting the pins causes them to be removed from the array...
	delete m_paStreams[m_iPins - 1];
    }

    ASSERT(m_paStreams == NULL);
}


//
//  Add a new pin
//
HRESULT CSource::AddPin(CSourceStream *pStream)
{
    CAutoLock lock(&m_cStateLock);

    /*  Allocate space for this pin and the old ones */
    CSourceStream **paStreams = new CSourceStream *[m_iPins + 1];
    if (paStreams == NULL) {
        return E_OUTOFMEMORY;
    }
    if (m_paStreams != NULL) {
        CopyMemory((PVOID)paStreams, (PVOID)m_paStreams,
                   m_iPins * sizeof(m_paStreams[0]));
        paStreams[m_iPins] = pStream;
        delete [] m_paStreams;
    }
    m_paStreams = paStreams;
    m_paStreams[m_iPins] = pStream;
    m_iPins++;
    return S_OK;
}

//
//  Remove a pin - pStream is NOT deleted
//
HRESULT CSource::RemovePin(CSourceStream *pStream)
{
    int i;
    for (i = 0; i < m_iPins; i++) {
        if (m_paStreams[i] == pStream) {
            if (m_iPins == 1) {
                delete [] m_paStreams;
                m_paStreams = NULL;
            } else {
                /*  no need to reallocate */
		while (++i < m_iPins)
		    m_paStreams[i - 1] = m_paStreams[i];
            }
            m_iPins--;
            return S_OK;
        }
    }
    return S_FALSE;
}

//
// FindPin
//
// Set *ppPin to the IPin* that has the id Id.
// or to NULL if the Id cannot be matched.
STDMETHODIMP CSource::FindPin(LPCWSTR Id, IPin **ppPin)
{
    CheckPointer(ppPin,E_POINTER);
    ValidateReadWritePtr(ppPin,sizeof(IPin *));
    // The -1 undoes the +1 in QueryId and ensures that totally bogus
    // strings (for which WstrToInt delivers 0) give a deliver a NULL pin.
    int i = WstrToInt(Id) -1;
    *ppPin = GetPin(i);
    if (*ppPin!=NULL){
        (*ppPin)->AddRef();
        return NOERROR;
    } else {
        return VFW_E_NOT_FOUND;
    }
}

//
// FindPinNumber
//
// return the number of the pin with this IPin* or -1 if none
int CSource::FindPinNumber(IPin *iPin) {
    int i;
    for (i=0; i<m_iPins; ++i) {
        if ((IPin *)(m_paStreams[i])==iPin) {
            return i;
        }
    }
    return -1;
}

//
// GetPinCount
//
// Returns the number of pins this filter has
int CSource::GetPinCount(void) {

    CAutoLock lock(&m_cStateLock);
    return m_iPins;
}


//
// GetPin
//
// Return a non-addref'd pointer to pin n
// needed by CBaseFilter
CBasePin *CSource::GetPin(int n) {

    CAutoLock lock(&m_cStateLock);

    // n must be in the range 0..m_iPins-1
    // if m_iPins>n  && n>=0 it follows that m_iPins>0
    // which is what used to be checked (i.e. checking that we have a pin)
    if ((n >= 0) && (n < m_iPins)) {

        ASSERT(m_paStreams[n]);
	return m_paStreams[n];
    }
    return NULL;
}


//


// *
// * --- CSourceStream ----
// *

//
// Set Id to point to a CoTaskMemAlloc'd
STDMETHODIMP CSourceStream::QueryId(LPWSTR *Id) {
    CheckPointer(Id,E_POINTER);
    ValidateReadWritePtr(Id,sizeof(LPWSTR));

    // We give the pins id's which are 1,2,...
    // FindPinNumber returns -1 for a bogus pin
    int i = 1+ m_pFilter->FindPinNumber(this);
    if (i<1) return VFW_E_NOT_FOUND;
    *Id = (LPWSTR)CoTaskMemAlloc(8);
    if (*Id==NULL) {
       return E_OUTOFMEMORY;
    }
    IntToWstr(i, *Id);
    return NOERROR;
}



//
// CSourceStream::Constructor
//
// increments the number of pins present on the filter
CSourceStream::CSourceStream(
    TCHAR *pObjectName,
    HRESULT *phr,
    CSource *ps,
    LPCWSTR pPinName)
    : CBaseOutputPin(pObjectName, ps, ps->pStateLock(), phr, pPinName),
      m_pFilter(ps) {

     *phr = m_pFilter->AddPin(this);
}


//
// CSourceStream::Destructor
//
// Decrements the number of pins on this filter
CSourceStream::~CSourceStream(void) {

     m_pFilter->RemovePin(this);
}


//
// CheckMediaType
//
// Do we support this type? Provides the default support for 1 type.
HRESULT CSourceStream::CheckMediaType(const CMediaType *pMediaType) {

    CAutoLock lock(m_pFilter->pStateLock());

    CMediaType mt;
    GetMediaType(&mt);

    if (mt == *pMediaType) {
        return NOERROR;
    }

    return E_FAIL;
}


//
// GetMediaType/3
//
// By default we support only one type
// iPosition indexes are 0-n
HRESULT CSourceStream::GetMediaType(int iPosition, CMediaType *pMediaType) {

    CAutoLock lock(m_pFilter->pStateLock());

    if (iPosition<0) {
        return E_INVALIDARG;
    }
    if (iPosition>0) {
        return VFW_S_NO_MORE_ITEMS;
    }
    return GetMediaType(pMediaType);
}


//
// Active
//
// The pin is active - start up the worker thread
HRESULT CSourceStream::Active(void) {

    CAutoLock lock(m_pFilter->pStateLock());

    HRESULT hr;

    if (m_pFilter->IsActive()) {
	return S_FALSE;	// succeeded, but did not allocate resources (they already exist...)
    }

    // do nothing if not connected - its ok not to connect to
    // all pins of a source filter
    if (!IsConnected()) {
        return NOERROR;
    }

    hr = CBaseOutputPin::Active();
    if (FAILED(hr)) {
        return hr;
    }

    ASSERT(!ThreadExists());

    // start the thread
    if (!Create()) {
        return E_FAIL;
    }

    // Tell thread to initialize. If OnThreadCreate Fails, so does this.
    hr = Init();
    if (FAILED(hr))
	return hr;

    return Pause();
}


//
// Inactive
//
// Pin is inactive - shut down the worker thread
// Waits for the worker to exit before returning.
HRESULT CSourceStream::Inactive(void) {

    CAutoLock lock(m_pFilter->pStateLock());

    HRESULT hr;

    // do nothing if not connected - its ok not to connect to
    // all pins of a source filter
    if (!IsConnected()) {
        return NOERROR;
    }

    // !!! need to do this before trying to stop the thread, because
    // we may be stuck waiting for our own allocator!!!

    hr = CBaseOutputPin::Inactive();  // call this first to Decommit the allocator
    if (FAILED(hr)) {
	return hr;
    }

    if (ThreadExists()) {
	hr = Stop();

	if (FAILED(hr)) {
	    return hr;
	}

	hr = Exit();
	if (FAILED(hr)) {
	    return hr;
	}

	Close();	// Wait for the thread to exit, then tidy up.
    }

    // hr = CBaseOutputPin::Inactive();  // call this first to Decommit the allocator
    //if (FAILED(hr)) {
    //	return hr;
    //}

    return NOERROR;
}


//
// ThreadProc
//
// When this returns the thread exits
// Return codes > 0 indicate an error occured
DWORD CSourceStream::ThreadProc(void) {

    HRESULT hr;  // the return code from calls
    Command com;

    do {
	com = GetRequest();
	if (com != CMD_INIT) {
	    DbgLog((LOG_ERROR, 1, TEXT("Thread expected init command")));
	    Reply((DWORD) E_UNEXPECTED);
	}
    } while (com != CMD_INIT);

    DbgLog((LOG_TRACE, 1, TEXT("CSourceStream worker thread initializing")));

    hr = OnThreadCreate(); // perform set up tasks
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 1, TEXT("CSourceStream::OnThreadCreate failed. Aborting thread.")));
        OnThreadDestroy();
	Reply(hr);	// send failed return code from OnThreadCreate
        return 1;
    }

    // Initialisation suceeded
    Reply(NOERROR);

    Command cmd;
    do {
	cmd = GetRequest();

	switch (cmd) {

	case CMD_EXIT:
	    Reply(NOERROR);
	    break;

	case CMD_RUN:
	    DbgLog((LOG_ERROR, 1, TEXT("CMD_RUN received before a CMD_PAUSE???")));
	    // !!! fall through???
	
	case CMD_PAUSE:
	    Reply(NOERROR);
	    DoBufferProcessingLoop();
	    break;

	case CMD_STOP:
	    Reply(NOERROR);
	    break;

	default:
	    DbgLog((LOG_ERROR, 1, TEXT("Unknown command %d received!"), cmd));
	    Reply((DWORD) E_NOTIMPL);
	    break;
	}
    } while (cmd != CMD_EXIT);

    hr = OnThreadDestroy();	// tidy up.
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 1, TEXT("CSourceStream::OnThreadDestroy failed. Exiting thread.")));
        return 1;
    }

    DbgLog((LOG_TRACE, 1, TEXT("CSourceStream worker thread exiting")));
    return 0;
}


//
// DoBufferProcessingLoop
//
// Grabs a buffer and calls the users processing function.
// Overridable, so that different delivery styles can be catered for.
HRESULT CSourceStream::DoBufferProcessingLoop(void) {

    Command com;

    OnThreadStartPlay();

    do {
	while (!CheckRequest(&com)) {

	    IMediaSample *pSample;

	    HRESULT hr = GetDeliveryBuffer(&pSample,NULL,NULL,0);
	    if (FAILED(hr)) {
                Sleep(1);
		continue;	// go round again. Perhaps the error will go away
			    // or the allocator is decommited & we will be asked to
			    // exit soon.
	    }

	    // Virtual function user will override.
	    hr = FillBuffer(pSample);

	    if (hr == S_OK) {
		hr = Deliver(pSample);
                pSample->Release();

                // downstream filter returns S_FALSE if it wants us to
                // stop or an error if it's reporting an error.
                if(hr != S_OK)
                {
                  DbgLog((LOG_TRACE, 2, TEXT("Deliver() returned %08x; stopping"), hr));
                  return S_OK;
                }

	    } else if (hr == S_FALSE) {
                // derived class wants us to stop pushing data
		pSample->Release();
		DeliverEndOfStream();
		return S_OK;
	    } else {
                // derived class encountered an error
                pSample->Release();
		DbgLog((LOG_ERROR, 1, TEXT("Error %08lX from FillBuffer!!!"), hr));
                DeliverEndOfStream();
                m_pFilter->NotifyEvent(EC_ERRORABORT, hr, 0);
                return hr;
	    }

            // all paths release the sample
	}

        // For all commands sent to us there must be a Reply call!

	if (com == CMD_RUN || com == CMD_PAUSE) {
	    Reply(NOERROR);
	} else if (com != CMD_STOP) {
	    Reply((DWORD) E_UNEXPECTED);
	    DbgLog((LOG_ERROR, 1, TEXT("Unexpected command!!!")));
	}
    } while (com != CMD_STOP);

    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\lmrtrend\lmrttype.h ===
// LMRT media type

// 74726c6d-0000-0010-8000-00AA00389B71  'lmrt' == MEDIATYPE_LMRT
//EXTERN_GUID(MEDIATYPE_LMRT,
//0x74726c6d, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

// we might also need some kind of structure for header or per-sample information,
// if it isn't as simple as just "find an LMRT engine and give it the data".
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\lmrtrend\lmrtrend.cpp ===
#include <streams.h>
#include <urlmon.h>
#include <atlbase.h>
#include <ddrawex.h>
#include <htmlfilter.h>


// ! copied from h\evcodei.h in the netshow tree.
#define EC_VIDEOFRAMEREADY		    0x49
// (void, void) : application
// sent to notify the application that the first video frame is about to be drawn


// Things that are still really broken:
//
// RefCount issues, could be really an OCX problem instead
// Position reporting, why isn't this working?
// seeking, respecting run/pause
//


#ifdef FILTER_DLL
#include <initguid.h>
#endif

#pragma warning(disable:4355)

#include "lmrtrend.h"

// Setup data

const IID IID_ILMReader = {0x183C2599,0x0480,0x11d1,{0x87,0xEA,0x00,0xC0,0x4F,0xC2,0x9D,0x46}};

const AMOVIESETUP_MEDIATYPE sudLMRTPinTypes[] =
{
    { &MEDIATYPE_LMRT, &MEDIASUBTYPE_NULL }
};

const AMOVIESETUP_PIN sudLMRTPin =
{
    L"Input",                     // The Pins name
    TRUE,                         // Is rendered
    FALSE,                        // Is an output pin
    FALSE,                        // Allowed none
    FALSE,                        // Allowed many
    &CLSID_NULL,                  // Connects to filter
    NULL,                         // Connects to pin
    NUMELMS(sudLMRTPinTypes),     // Number of types
    sudLMRTPinTypes               // Pin details
};

const AMOVIESETUP_FILTER sudLMRTRend =
{
    &CLSID_LMRTRenderer,            // Filter CLSID
    L"Internal LMRT Renderer",      // String name
    MERIT_PREFERRED + 1,            // Filter merit high, since we're the only one who likes this type
    1,                              // Number of pins
    &sudLMRTPin                     // Pin details
};

AMOVIESETUP_MEDIATYPE sudURLSPinTypes[] =   {
  &MEDIATYPE_URL_STREAM,        // clsMajorType
  &MEDIATYPE_URL_STREAM };      // clsMinorType

AMOVIESETUP_PIN sudURLSPins[] =
{
  { L"Input"                    // strName
    , TRUE                      // bRendered
    , FALSE                     // bOutput
    , FALSE                     // bZero
    , FALSE                     // bMany
    , &CLSID_NULL               // clsConnectsToFilter
    , 0                         // strConnectsToPin
    , NUMELMS(sudURLSPinTypes)  // nTypes
    , sudURLSPinTypes           // lpTypes
  }
};


const AMOVIESETUP_FILTER sudURLS =
{
  &CLSID_UrlStreamRenderer      // clsID
  , L"URL StreamRenderer"       // strName
  , MERIT_NORMAL                // dwMerit
  , NUMELMS(sudURLSPins)        // nPins
  , sudURLSPins                 // lpPin
};



CFactoryTemplate g_Templates[] = {
    { L"Internal LMRT Renderer" , &CLSID_LMRTRenderer , CLMRTRenderer::CreateInstance , NULL , &sudLMRTRend },
    {L"URL StreamRenderer", &CLSID_UrlStreamRenderer, CUrlStreamRenderer::CreateInstance, NULL, &sudURLS},
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}



//
CLMRTRenderer::CLMRTRenderer(LPUNKNOWN pUnk,HRESULT *phr) :
    CBaseRenderer(CLSID_LMRTRenderer, NAME("LMRT Filter"), pUnk, phr),
    m_fFirstPause(true),
    m_pbFirstPacketFromHeader(0)
{
//	m_pIbsc = NULL;
	m_pEngine = NULL;
	m_pReader = 0;
	m_punkControl = 0;
//	HGLOBAL hMem = GlobalAlloc(GMEM_FIXED, 10000); 
//	m_pMem = (BYTE*)hMem;
//	m_dwSize = 0;
//	CreateStreamOnHGlobal(hMem, true, &m_pstm);
	m_dwWidth = 0;
	m_dwHeight = 0;
//         DbgLog((LOG_TRACE, 0, TEXT("**** m_cRef: %08x = %d"), &m_cRef, m_cRef));
//         if(GetFileAttributes(TEXT("C:/kassert")) != 0xFFFFFFFF) {
//             _asm int 3
//         }
} // (Constructor)


//
// Destructor
//
CLMRTRenderer::~CLMRTRenderer()
{
    // we artificially lowered our reference count after calling
    // put_ViewerControl.
    AddRef();
    AddRef();

//  if (m_pIbsc)
//	m_pIbsc->Release();
    if (m_pEngine)
        m_pEngine->Release();
    if (m_pReader) {
        LONG l = m_pReader->Release();
        ASSERT(l == 0);
    }
    if (m_punkControl)
        m_punkControl->Release();
    //  if (m_pstm)
    //	m_pstm->Release();

    delete[] m_pbFirstPacketFromHeader;
}


//
// CreateInstance
//
// This goes in the factory template table to create new instances
//
CUnknown * WINAPI CLMRTRenderer::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    CLMRTRenderer *pLMRTFilter = new CLMRTRenderer(pUnk,phr);
    if (pLMRTFilter == NULL) {
        return NULL;
    }
    return (CBaseMediaFilter *) pLMRTFilter;

} // CreateInstance



// !!! stolen from atlctl.cpp

#define HIMETRIC_PER_INCH   2540
#define MAP_PIX_TO_LOGHIM(x,ppli)   ( (HIMETRIC_PER_INCH*(x) + ((ppli)>>1)) / (ppli) )
#define MAP_LOGHIM_TO_PIX(x,ppli)   ( ((ppli)*(x) + HIMETRIC_PER_INCH/2) / HIMETRIC_PER_INCH )

void ConvertPixelToHiMetric(const SIZEL * lpSizeInPix, LPSIZEL lpSizeInHiMetric)
{
    int nPixelsPerInchX = 0;    // Pixels per logical inch along width
    int nPixelsPerInchY = 0;    // Pixels per logical inch along height

    HDC hDCScreen = GetDC(NULL);
    nPixelsPerInchX = GetDeviceCaps(hDCScreen, LOGPIXELSX);
    nPixelsPerInchY = GetDeviceCaps(hDCScreen, LOGPIXELSY);
    ReleaseDC(NULL, hDCScreen);

    if (!nPixelsPerInchX || !nPixelsPerInchY)
	return;

    lpSizeInHiMetric->cx = MAP_PIX_TO_LOGHIM(lpSizeInPix->cx, nPixelsPerInchX);
    lpSizeInHiMetric->cy = MAP_PIX_TO_LOGHIM(lpSizeInPix->cy, nPixelsPerInchY);
}


//
// NonDelegatingQueryInterface
//
// Overriden to say what interfaces we support and where
//
STDMETHODIMP
CLMRTRenderer::NonDelegatingQueryInterface(REFIID riid,void **ppv)
{
    CheckPointer(ppv,E_POINTER);

    if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking) {
//         // explicity disable seeking.
//         return E_NOINTERFACE;
    } else if (riid == IID_ILMRTRenderer) {
	return GetInterface((ILMRTRenderer *)this, ppv);
    } else if (riid == IID_IOleObject ||
    	   riid == IID_IOleInPlaceObjectWindowless ||
	       riid == IID_IOleInPlaceObject ||
	       riid == IID_IViewObject ||
	       riid == IID_IViewObject2 ||
	       riid == IID_IOleWindow ||
	       riid == IID_IOleControl ||
	       riid == IID_IOleObject ||
	       riid == IID_IQuickActivate ||
	       riid == IID_ISpecifyPropertyPages ||
	       riid == IID_IDAViewerControl ||
	       riid == IID_IDASite ||
	       riid == IID_IDAViewSite ||
	       riid == IID_IDispatch ||
	       riid == IID_IOleInPlaceActiveObject ||
	       riid == IID_IViewObjectEx) { // !!! is this a complete list of interfaces?
	// in the standalone case, we aggregate the DAViewer control
	if (!m_punkControl) {
	    HRESULT hr = S_OK; 
	    // create the DA control aggregated 
        bool bTridentServicesAvailable = false;
        
        // TODO: Enable this if/when the embedded case will work windowless.
        /*       
        CComPtr<IObjectWithSite> pObjWithSite;
        if(SUCCEEDED(m_pGraph->QueryInterface(IID_IObjectWithSite, (void**)&pObjWithSite))) {
            CComPtr<IServiceProvider> pServiceProvider;
            if(SUCCEEDED(pObjWithSite->GetSite(IID_IServiceProvider, (void**)&pServiceProvider))) {                        
                bTridentServicesAvailable = true;
                
                // Additional checks for the two trident services required by DA
                CComPtr<ITimerService> pTimerService;
                CComPtr<IDirectDraw3> pDirectDraw3;
                
                if(FAILED( pServiceProvider->QueryService(SID_STimerService,
                                               IID_ITimerService, (void**)&pTimerService))) {
                    bTridentServicesAvailable = false;    
                }
                // Can't link this in...
                
                if(FAILED( pServiceProvider->QueryService(SID_SDirectDraw3,
                                               IID_IDirectDraw3, (void**)&pDirectDraw3))) {
                    bTridentServicesAvailable = false; 
                }       
            }
        }
        pObjWithSite.Release();  // done with this
        */

        IDAViewerControl *pControl;
        if(bTridentServicesAvailable) {	        
       	    if(FAILED(CoCreateInstance(__uuidof(DAViewerControl), (IBaseFilter *) this,
				  CLSCTX_INPROC_SERVER, IID_IUnknown, (void **) &m_punkControl))) {
		        ASSERT(0);
		        return E_NOINTERFACE;
	        }

	        if(FAILED(m_punkControl->QueryInterface(IID_IDAViewerControl,
			    	  (void **) &pControl))) { 
		        ASSERT(0);                         
		        return E_NOINTERFACE;
            }
        }
        else {        
            if(FAILED(CoCreateInstance(__uuidof(DAViewerControlWindowed), (IBaseFilter *) this,
                  CLSCTX_INPROC_SERVER, IID_IUnknown, (void **) &m_punkControl))) { 
                ASSERT(0);                         
                return E_NOINTERFACE;
            }    

            if(FAILED(m_punkControl->QueryInterface(IID_IDAViewerControlWindowed,
                      (void **) &pControl))) { 
                ASSERT(0);
                return E_NOINTERFACE;
            }

            if (FAILED(pControl->put_TimerSource(DAWMTimer))) {
                ASSERT(0);
                return hr;
            }                                      
        }          

	    if (m_dwWidth) {
		    SIZEL sizeControl;

		    sizeControl.cx = m_dwWidth;
		    sizeControl.cy = m_dwHeight;

		    ConvertPixelToHiMetric(&sizeControl, &sizeControl);

		    IOleObject *pOleObj;
		    hr = m_punkControl->QueryInterface(IID_IOleObject, (void **) &pOleObj);

		    if (SUCCEEDED(hr)) {
		        hr = pOleObj->SetExtent(DVASPECT_CONTENT, &sizeControl);

		        pOleObj->Release();
		    }
	    }	    

	    // create the LM reader
	    hr = CoCreateInstance(__uuidof(LMReader), NULL,
				  CLSCTX_INPROC_SERVER,
				  __uuidof(ILMReader),
				  (void **) &m_pReader);

	    if (FAILED(hr)) {
		ASSERT(0);
		return E_NOINTERFACE;
	    }
	    
		ILMEngine *pEngine = NULL;
	    hr = m_pReader->createAsyncEngine(&pEngine);
	    if (FAILED(hr)) {
		ASSERT(0);
		return E_NOINTERFACE;		
	    }

		hr = pEngine->QueryInterface( __uuidof(ILMEngine2), (void **)&m_pEngine);
		if (FAILED(hr)) {
		ASSERT(0);
		return E_NOINTERFACE;		
	    }
		pEngine->Release();

	    hr = m_pReader->put_ViewerControl(pControl);
	    if (FAILED(hr)) {
            ASSERT(0);
            return E_NOINTERFACE;
	    }

        // just created a circular reference since we aggregated
        // pControl. get rid of it artificially. we'll bump the
        // refcount up twice in the destructor when it releases
        // m_pReader to avoid hitting 0 again.
        Release();

	    IDAStatics *pMeterLibrary;
	    hr = pControl->get_MeterLibrary(&pMeterLibrary);

	    if (SUCCEEDED(hr)) {
		// check whether this is DA version 1 by seeing if the IDA2Statics
		// interface is not present.
		IUnknown *pStatics2 = NULL;
		hr = pMeterLibrary->QueryInterface(__uuidof(IDA2Statics), (void **) &pStatics2);

		if (SUCCEEDED(hr)) {
		    pStatics2->Release();
		}

		// if no IDA2Statics, it's the IE4 version of DA.
		m_pReader->put_NoExports(pStatics2 ? OAFALSE : OATRUE);
		
		pMeterLibrary->Release();
	    }
        	    
	    pControl->Release();
	}
	
	return m_punkControl->QueryInterface(riid, ppv);
    }


    return CBaseRenderer::NonDelegatingQueryInterface(riid,ppv);
    
} // NonDelegatingQueryInterface


//
// CheckMediaType
//
// Check that we can support a given proposed type
//
HRESULT CLMRTRenderer::CheckMediaType(const CMediaType *pmt)
{
    // Accept only LMRT data

    if (pmt->majortype != MEDIATYPE_LMRT) {
	return E_INVALIDARG;
    }

    // !!! check other things about the format?
    
    return NOERROR;

} // CheckMediaType

//
// SetMediaType
//
// Called when the media type is really chosen
//
HRESULT CLMRTRenderer::SetMediaType(const CMediaType *pmt)
{
    // possibly actually look at the type?
#define CB_SWH_HEADER ((3 * sizeof(DWORD)))

    HRESULT hr = CheckMediaType(pmt);

    if (pmt->cbFormat >= CB_SWH_HEADER) {
	DWORD *pdw = (DWORD *) pmt->pbFormat;

	m_dwWidth = pdw[1];
	m_dwHeight = pdw[2];
    }

    // strictly greater than
    if (pmt->cbFormat > CB_SWH_HEADER)
    {
        // any extra data in the format block is the first lm
        // packet. save it off and send it in stop->pause.
        ULONG cb = pmt->cbFormat - CB_SWH_HEADER;
        delete[] m_pbFirstPacketFromHeader;
        m_pbFirstPacketFromHeader = new BYTE[cb];
        if(m_pbFirstPacketFromHeader)
        {
            CopyMemory(m_pbFirstPacketFromHeader, pmt->pbFormat + CB_SWH_HEADER, cb);
            m_cbFirstPacketFromHeader = cb;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
                
    }
    
    return hr;

} // CheckMediaType


//
// OnReceiveFirstSample
//
// Display an image if not streaming
//
void CLMRTRenderer::OnReceiveFirstSample(IMediaSample *pMediaSample)
{
}

//
// DoRenderSample
//
// This is called when a sample is ready for rendering
//
HRESULT CLMRTRenderer::DoRenderSample(IMediaSample *pMediaSample)
{
    ASSERT(pMediaSample);
    BYTE *pData;        // Pointer to image data

    pMediaSample->GetPointer(&pData);
    ASSERT(pData != NULL);

    REFERENCE_TIME rtStart, rtEnd;
    ASSERT(pMediaSample->GetTime(&rtStart, &rtEnd) == S_OK);
    DbgLog((LOG_TRACE, 15, TEXT("** CLMRTRenderer: %d"), (LONG)(rtStart / (UNITS / MILLISECONDS))));

    DWORD cbData = pMediaSample->GetActualDataLength();
/*
    // !!! send data to LMRT 
	if (m_pIbsc)
	{
		FORMATETC	format;
		STGMEDIUM	stgMedium;
		CopyMemory(m_pMem, pData, cbData);
		m_pMem += cbData;
		m_dwSize += cbData;
		stgMedium.pstm = m_pstm;
		stgMedium.tymed = TYMED_ISTREAM;
		m_pIbsc->OnDataAvailable(m_bscf, m_dwSize, &format, &stgMedium);
		if (m_bscf == BSCF_FIRSTDATANOTIFICATION)
			m_bscf = BSCF_INTERMEDIATEDATANOTIFICATION;
	}
*/
    if(m_pEngine) {
        m_pEngine->OnMemDataAvailable(FALSE, cbData, pData);
    }
    return NOERROR;

} // DoRenderSample


// OnStartStreaming
HRESULT CLMRTRenderer::OnStartStreaming()
{
//    m_bscf = BSCF_FIRSTDATANOTIFICATION;


    // !!! start control here?
    if(m_pEngine)
    {
        REFERENCE_TIME rtNow = 0;

        if(m_pClock)
        {
            HRESULT hrTmp = m_pClock->GetTime(&rtNow);
            ASSERT(hrTmp == S_OK || hrTmp == S_FALSE);
            rtNow -= m_tStart;

            // rtNow could be negative if we've just been told to run
            // 100ms from now.
            ASSERT(rtNow >= -UNITS);
        }
        
        m_pEngine->Start(rtNow);

    }

    return S_OK;
} // OnStartStreaming

HRESULT CLMRTRenderer::Pause()
{
    CAutoLock cRendererLock(&m_InterfaceLock);
    FILTER_STATE fsOld = m_State;
    HRESULT hrPause = CBaseRenderer::Pause();
    if(SUCCEEDED(hrPause) && fsOld == State_Stopped)
    {
        // look for the magic cache directory from the urlcache
        // filter. really we should find related filters (common
        // upstream source) first. !!!! this should go in Pause()
        IEnumFilters *pEnum;
        HRESULT hr = m_pGraph->EnumFilters(&pEnum);
        if(SUCCEEDED(hr))
        {
            IBaseFilter *pFilter;
            // find the first filter in the graph that supports riid interface
            while(pEnum->Next(1, &pFilter, NULL) == S_OK)
            {
                CLSID clsid;
                if(pFilter->GetClassID( &clsid) == S_OK)
                {
                    if(clsid == CLSID_UrlStreamRenderer)
                    {
                        IPropertyBag *ppb;
                        hr =pFilter->QueryInterface(IID_IPropertyBag, (void **)&ppb);
                        ASSERT(hr == S_OK); // our filter
                        if(SUCCEEDED(hr))
                        {
                            VARIANT var;
                            var.vt = VT_EMPTY;
                            hr = ppb->Read(L"lmrtcache", &var, 0);
                            if(SUCCEEDED(hr))
                            {
                                m_pEngine->SetMediaCacheDir(var.bstrVal);
                                VariantClear(&var);

                            }
                            ppb->Release();
                        }
                    }
                }
                pFilter->Release();
            }

            pEnum->Release();
        }

        if(m_fFirstPause && m_pEngine && m_pbFirstPacketFromHeader)
        {
            m_pEngine->OnMemDataAvailable(
                FALSE,          // boolLastBlock
                m_cbFirstPacketFromHeader,
                m_pbFirstPacketFromHeader);

            // netshow doesn't know we can paint something, so we need
            // to stop the netshow logo from appearing on top of the
            // animation.
            NotifyEvent( EC_VIDEOFRAMEREADY, NULL, NULL );
        }
        m_fFirstPause = false;
    }

    return hrPause;
}

// OnStopStreaming
HRESULT CLMRTRenderer::OnStopStreaming(void)
{
/*
	FORMATETC	format;
	STGMEDIUM	stgMedium;
	stgMedium.pstm = m_pstm;
	m_pIbsc->OnDataAvailable(BSCF_LASTDATANOTIFICATION, m_dwSize, &format, &stgMedium);
*/
    if(m_pEngine) {
            m_pEngine->OnMemDataAvailable(TRUE, 0, 0);
    }

	// !!! stop model here?
    if(m_pEngine) {
        m_pEngine->Stop();
    }
	
	return S_OK;
}

// HRESULT CLMRTRenderer::EndOfStream()
// {
//     // avoid signaling EC_COMPLETE because msdxm.ocx will paint a
//     // static image.
//     return S_OK;
// }

/*
HRESULT CLMRTRenderer::SetLMReader(ILMReader *pReader)
{
	HRESULT		hr;
	ILMEngine	*pEngine;

	if (!SUCCEEDED(hr = pReader->createAsyncEngine(&pEngine)))
		return hr;

	hr = pEngine->QueryInterface(IID_IBindStatusCallback, (void **)&m_pIbsc);
	pEngine->Release();
	return hr;
}
*/

HRESULT CLMRTRenderer::SetLMEngine(ILMEngine *pEngine)
{
	if( m_pEngine != NULL )
		m_pEngine->Release();

	if( FAILED( pEngine->QueryInterface( __uuidof(ILMEngine2), (void **)&m_pEngine ) ) )
		return E_NOINTERFACE;

	return S_OK;
}

STDMETHODIMP CLMRTRenderer::JoinFilterGraph( IFilterGraph *pGraph, LPCWSTR szName )
{
	HRESULT hr = CBaseRenderer::JoinFilterGraph( pGraph, szName);

	if( pGraph == NULL && m_pEngine != NULL )
	{
		m_pEngine->releaseAllFilterGraph();
	}

	return hr;
}

#if defined(DEVELOPER_DEBUG) || defined(_M_ALPHA)

extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE, ULONG, LPVOID);


BOOL WINAPI DllMain(  HINSTANCE hinstDLL,  // handle to DLL module
  DWORD fdwReason,     // reason for calling function
  LPVOID lpvReserved   // reserved
)
{
    return DllEntryPoint( hinstDLL, fdwReason, lpvReserved);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\lmrtrend\urlcache.cpp ===
#include <streams.h>
// !!!!!
#undef _ATL_STATIC_REGISTRY
#include <atlbase.h>
#include <atlimpl.cpp>
#include "lmrtrend.h"




// AMOVIESETUP_MEDIATYPE sudURLSPinTypes[] =   {
//   &MEDIATYPE_URL_STREAM,        // clsMajorType
//   &MEDIATYPE_URL_STREAM };      // clsMinorType

// AMOVIESETUP_PIN sudURLSPins[] =
// {
//   { L"Input"                    // strName
//     , TRUE                      // bRendered
//     , FALSE                     // bOutput
//     , FALSE                     // bZero
//     , FALSE                     // bMany
//     , &CLSID_NULL               // clsConnectsToFilter
//     , 0                         // strConnectsToPin
//     , NUMELMS(sudURLSPinTypes)  // nTypes
//     , sudURLSPinTypes           // lpTypes
//   }
// };


// const AMOVIESETUP_FILTER sudURLS =
// {
//   &CLSID_UrlStreamRenderer      // clsID
//   , L"URL StreamRenderer"       // strName
//   , MERIT_NORMAL                // dwMerit
//   , NUMELMS(sudURLSPins)        // nPins
//   , sudURLSPins                 // lpPin
// };

// STDAPI DllRegisterServer()
// {
//   return AMovieDllRegisterServer2(TRUE);
// }

// STDAPI DllUnregisterServer()
// {
//   return AMovieDllRegisterServer2(FALSE);
// }




CUrlInPin::CUrlInPin(CBaseFilter *pFilter, CCritSec *pLock, HRESULT *phr) :
        CBaseInputPin(NAME("url in pin"), pFilter, pLock, phr, L"In")
{
    m_szTempDir[0] = 0;
    if(SUCCEEDED(*phr))
    {
        TCHAR szTmpDir[MAX_PATH];
        DWORD dw = GetTempPath(NUMELMS(szTmpDir), szTmpDir);
        if(dw)
        {
            while(SUCCEEDED(*phr))
            {
                TCHAR szTempFile[MAX_PATH];
                UINT ui = GetTempFileName(
                    szTmpDir,
                    TEXT("lmrtasf"),
                    timeGetTime(),
                    szTempFile);
                if(ui)
                {

                    BOOL f = CreateDirectory(szTempFile, 0);
                    if(f)
                    {
                        DbgLog((LOG_TRACE, 1, TEXT("CUrlInPin using %s"), m_szTempDir));
                        lstrcpy(m_szTempDir, szTempFile);
                        break;
                    }

                    DWORD dw = GetLastError();
                    if(dw == ERROR_ALREADY_EXISTS)
                    {
                        DbgLog((LOG_TRACE, 1, TEXT("CUrlInPin %s exists"), szTempFile));
                        Sleep(1);
                        continue;
                    }
                    else
                    {
                        DbgLog((LOG_ERROR, 0, TEXT("CUrlInPin %s failed"), szTempFile));
                        *phr = HRESULT_FROM_WIN32(dw);
                    }
                }
                else
                {
                    DWORD dw = GetLastError();
                    *phr = HRESULT_FROM_WIN32(dw);
                    DbgLog((LOG_ERROR, 0, TEXT("CUrlInPin GetTempFileName ")));
                }
            }
        }
        else
        {
            DWORD dw = GetLastError();
            *phr = HRESULT_FROM_WIN32(dw);
            DbgLog((LOG_ERROR, 0, TEXT("CUrlInPin GetTempPath ")));
        }
    }
}

void DeleteFiles(TCHAR  *szTmp)
{
    if(szTmp[0] != 0)
    {
        WIN32_FIND_DATA wfd;
        TCHAR szwildcard[MAX_PATH + 10];
        lstrcpy(szwildcard, szTmp);
        lstrcat(szwildcard, TEXT("/*"));
        HANDLE h = FindFirstFile(szwildcard, &wfd);
        if(h != INVALID_HANDLE_VALUE)
        {
            do
            {
                if(wfd.cFileName[0] == TEXT('.') &&
                   (wfd.cFileName[1] == 0 ||
                    wfd.cFileName[1] == TEXT('.') && wfd.cFileName[2] == 0))
                {
                    continue;
                }
                
                TCHAR sz[MAX_PATH * 3];
                lstrcpy(sz, szTmp);
                lstrcat(sz, TEXT("/"));
                lstrcat(sz, wfd.cFileName);
                EXECUTE_ASSERT(DeleteFile(sz));
                
            } while (FindNextFile(h, &wfd));
        
            EXECUTE_ASSERT(FindClose(h));
        }
        EXECUTE_ASSERT(RemoveDirectory(szTmp));
    }

}

CUrlInPin::~CUrlInPin()
{
    DeleteFiles(m_szTempDir);
}



HRESULT CUrlInPin::CheckMediaType(const CMediaType *pmt)
{
    if(pmt->majortype == MEDIATYPE_URL_STREAM)
    {
        return S_OK;
    }
    return S_FALSE;
}

HRESULT CUrlInPin::Receive(IMediaSample *ps)
{
    HRESULT hrSignal = S_OK;
    
    HRESULT hr = CBaseInputPin::Receive(ps);
    if(hr == S_OK)
    {
        bool fInvalid = false;
        BYTE *pbLastPeriod = 0;
        // determine length of url without expecting a null at the end
        for(LONG ib = 0; ib < m_SampleProps.lActual; ib++)
        {
            BYTE &rsz = m_SampleProps.pbBuffer[ib];
            if(rsz == 0)
                break;

            // avoid creating some malicious file names (eg
            // c:/config.sys, ..\dsound.dll)
            if(rsz == ':'  && ib != 4 ||
               rsz == '/' ||
               rsz == '\\')
            {
                DbgBreak("bad filename");
                fInvalid = true;
                break;
            }

            if(rsz == '.') {
                pbLastPeriod = &rsz;
            }
        }

        if(!fInvalid && (ib >= m_SampleProps.lActual || ib >= MAX_PATH)) {
            fInvalid = true;
        }

        // these can be malicious, but it's not an exhaustive
        // list. (if you stream in a .wav and a rogue dsound.dll and
        // the user finds and double clicks on the .wav, he'll pick up
        // the rogue dsound.dll from the current directory). perhaps
        // we can compile a list of stuff it is ok to import!!!
        if(!fInvalid && pbLastPeriod) {
            if(lstrcmpiA((char *)pbLastPeriod, ".dll") == 0 ||
               lstrcmpiA((char *)pbLastPeriod, ".cmd") == 0 ||
               lstrcmpiA((char *)pbLastPeriod, ".bat") == 0 ||
               lstrcmpiA((char *)pbLastPeriod, ".url") == 0 ||
               lstrcmpiA((char *)pbLastPeriod, ".exe") == 0)
            {
                fInvalid = true;
            }
        }
        if(!fInvalid)
        {
            ULONG cbSz = ib + 1; // incl null
            BYTE *pbImage = m_SampleProps.pbBuffer + ib + 1;
            ULONG ibImage = ib + 1; // image starts here
            ULONG cbImage = m_SampleProps.lActual - cbSz;
            

            char *szUrl = (char *)m_SampleProps.pbBuffer;
            if(*szUrl++ == 'l' &&
               *szUrl++ == 'm' &&
               *szUrl++ == 'r' &&
               *szUrl++ == 't' &&
               *szUrl++ == ':')
            {
                ASSERT(ib - 5 == lstrlen(szUrl));

                TCHAR szThisFile[MAX_PATH * 2+ 10];
                lstrcpy(szThisFile, m_szTempDir);
                lstrcat(szThisFile, TEXT("\\"));
                lstrcat(szThisFile, szUrl);

                HANDLE hFile = CreateFile(
                    szThisFile,
                    GENERIC_WRITE,
                    0,  // share
                    0,  // lpSecurityAttribytes
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    0);
                if(hFile != INVALID_HANDLE_VALUE)
                {
                    DWORD cbWritten;
                            
                    BOOL b = WriteFile(
                        hFile,
                        pbImage,
                        cbImage,
                        &cbWritten,
                        0); // overlapped

                    if(b)
                    {
                        ASSERT(cbWritten == cbImage);
                    }
                    else
                    {
                        DWORD dw = GetLastError();
                        hrSignal = HRESULT_FROM_WIN32(dw);
                    }

                    EXECUTE_ASSERT(CloseHandle(hFile));
                }
                else
                {
                    DWORD dw = GetLastError();
                    hrSignal = HRESULT_FROM_WIN32(dw);
                }
            }
            else
            {
                // no "lmrt:"
                hrSignal = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }
        }
        else
        {
            // no null terminator on string
            hrSignal = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }
        
    } // base class receive

    if(SUCCEEDED(hrSignal))
    {
        return hr;
    }
    else
    {
        m_pFilter->NotifyEvent(EC_STREAM_ERROR_STOPPED, hrSignal, 0);
        return S_FALSE;
    }
}


// CFactoryTemplate g_Templates[]= {
//   {L"URL StreamRenderer", &CLSID_UrlStreamRenderer, CUrlStreamRenderer::CreateInstance, NULL, &sudURLS},
// };
// int g_cTemplates = NUMELMS(g_Templates);

CUnknown *CUrlStreamRenderer::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    if(SUCCEEDED(*phr))
        return new CUrlStreamRenderer(lpunk, phr);
    else
        return 0;
}

#pragma warning(disable:4355)

CUrlStreamRenderer::CUrlStreamRenderer(LPUNKNOWN punk, HRESULT *phr) :
        CBaseFilter(NAME("URL Stream Filter"), punk, &m_cs, CLSID_UrlStreamRenderer),
        m_inPin(this, &m_cs, phr)
{
}

HRESULT CUrlStreamRenderer::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if(riid == IID_IPropertyBag) {
        return GetInterface((IPropertyBag *)this, ppv);
    } else {
        return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }
}

HRESULT CUrlStreamRenderer::Read(
    LPCOLESTR pszPropName, LPVARIANT pVar,
    LPERRORLOG pErrorLog)
{
    if(lstrcmpW(pszPropName, L"lmrtcache") == 0 &&
       (pVar->vt == VT_BSTR || pVar->vt == VT_EMPTY))
    {
        EXECUTE_ASSERT(VariantClear(pVar) == S_OK);
        USES_CONVERSION;
        pVar->vt = VT_BSTR;
        pVar->bstrVal = SysAllocString(T2W(m_inPin.m_szTempDir));
        return pVar->bstrVal ? S_OK : E_OUTOFMEMORY;
    }
    else
    {
        return E_FAIL;
    }
}

HRESULT CUrlStreamRenderer::Write(
    LPCOLESTR pszPropName, LPVARIANT pVar)
{
    return E_FAIL;
}

// extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE, ULONG, LPVOID);


// BOOL WINAPI DllMain(  HINSTANCE hinstDLL,  // handle to DLL module
//   DWORD fdwReason,     // reason for calling function
//   LPVOID lpvReserved   // reserved
// )
// {
//     return DllEntryPoint( hinstDLL, fdwReason, lpvReserved);
// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\amvideo.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Video related definitions and interfaces for ActiveMovie

#ifndef __AMVIDEO__
#define __AMVIDEO__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <ddraw.h>


// This is an interface on the video renderer that provides information about
// DirectDraw with respect to its use by the renderer. For example it allows
// an application to get details of the surface and any hardware capabilities
// that are available. It also allows someone to adjust the surfaces that the
// renderer should use and furthermore even set the DirectDraw instance. We
// allow someone to set the DirectDraw instance because DirectDraw can only
// be opened once per process so it helps resolve conflicts. There is some
// duplication in this interface as the hardware/emulated/FOURCCs available
// can all be found through the IDirectDraw interface, this interface allows
// simple access to that information without calling the DirectDraw provider
// itself. The AMDDS prefix is ActiveMovie DirectDraw Switches abbreviated.

#define AMDDS_NONE 0x00             // No use for DCI/DirectDraw
#define AMDDS_DCIPS 0x01            // Use DCI primary surface
#define AMDDS_PS 0x02               // Use DirectDraw primary
#define AMDDS_RGBOVR 0x04           // RGB overlay surfaces
#define AMDDS_YUVOVR 0x08           // YUV overlay surfaces
#define AMDDS_RGBOFF 0x10           // RGB offscreen surfaces
#define AMDDS_YUVOFF 0x20           // YUV offscreen surfaces
#define AMDDS_RGBFLP 0x40           // RGB flipping surfaces
#define AMDDS_YUVFLP 0x80           // YUV flipping surfaces
#define AMDDS_ALL 0xFF              // ALL the previous flags
#define AMDDS_DEFAULT AMDDS_ALL     // Use all available surfaces

#define AMDDS_YUV (AMDDS_YUVOFF | AMDDS_YUVOVR | AMDDS_YUVFLP)
#define AMDDS_RGB (AMDDS_RGBOFF | AMDDS_RGBOVR | AMDDS_RGBFLP)
#define AMDDS_PRIMARY (AMDDS_DCIPS | AMDDS_PS)

// be nice to our friends in C
#undef INTERFACE
#define INTERFACE IDirectDrawVideo

DECLARE_INTERFACE_(IDirectDrawVideo, IUnknown)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IDirectDrawVideo methods

    STDMETHOD(GetSwitches)(THIS_ DWORD *pSwitches) PURE;
    STDMETHOD(SetSwitches)(THIS_ DWORD Switches) PURE;
    STDMETHOD(GetCaps)(THIS_ DDCAPS *pCaps) PURE;
    STDMETHOD(GetEmulatedCaps)(THIS_ DDCAPS *pCaps) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ DDSURFACEDESC *pSurfaceDesc) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_ DWORD *pCount,DWORD *pCodes) PURE;
    STDMETHOD(SetDirectDraw)(THIS_ LPDIRECTDRAW pDirectDraw) PURE;
    STDMETHOD(GetDirectDraw)(THIS_ LPDIRECTDRAW *ppDirectDraw) PURE;
    STDMETHOD(GetSurfaceType)(THIS_ DWORD *pSurfaceType) PURE;
    STDMETHOD(SetDefault)(THIS) PURE;
    STDMETHOD(UseScanLine)(THIS_ long UseScanLine) PURE;
    STDMETHOD(CanUseScanLine)(THIS_ long *UseScanLine) PURE;
    STDMETHOD(UseOverlayStretch)(THIS_ long UseOverlayStretch) PURE;
    STDMETHOD(CanUseOverlayStretch)(THIS_ long *UseOverlayStretch) PURE;
    STDMETHOD(UseWhenFullScreen)(THIS_ long UseWhenFullScreen) PURE;
    STDMETHOD(WillUseFullScreen)(THIS_ long *UseWhenFullScreen) PURE;
};


// be nice to our friends in C
#undef INTERFACE
#define INTERFACE IQualProp

DECLARE_INTERFACE_(IQualProp, IUnknown)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // Compare these with the functions in class CGargle in gargle.h

    STDMETHOD(get_FramesDroppedInRenderer)(THIS_ int *pcFrames) PURE;  // Out
    STDMETHOD(get_FramesDrawn)(THIS_ int *pcFramesDrawn) PURE;         // Out
    STDMETHOD(get_AvgFrameRate)(THIS_ int *piAvgFrameRate) PURE;       // Out
    STDMETHOD(get_Jitter)(THIS_ int *iJitter) PURE;                    // Out
    STDMETHOD(get_AvgSyncOffset)(THIS_ int *piAvg) PURE;               // Out
    STDMETHOD(get_DevSyncOffset)(THIS_ int *piDev) PURE;               // Out
};


// This interface allows an application or plug in distributor to control a
// full screen renderer. The Modex renderer supports this interface. When
// connected a renderer should load the display modes it has available
// The number of modes available can be obtained through CountModes. Then
// information on each individual mode is available by calling GetModeInfo
// and IsModeAvailable. An application may enable and disable any modes
// by calling the SetEnabled flag with OATRUE or OAFALSE (not C/C++ TRUE
// and FALSE values) - the current value may be queried by IsModeEnabled

// A more generic way of setting the modes enabled that is easier to use
// when writing applications is the clip loss factor. This defines the
// amount of video that can be lost when deciding which display mode to
// use. Assuming the decoder cannot compress the video then playing an
// MPEG file (say 352x288) into a 320x200 display will lose about 25% of
// the image. The clip loss factor specifies the upper range permissible.
// To allow typical MPEG video to be played in 320x200 it defaults to 25%

// be nice to our friends in C
#undef INTERFACE
#define INTERFACE IFullScreenVideo

DECLARE_INTERFACE_(IFullScreenVideo, IUnknown)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IFullScreenVideo methods

    STDMETHOD(CountModes)(THIS_ long *pModes) PURE;
    STDMETHOD(GetModeInfo)(THIS_ long Mode,long *pWidth,long *pHeight,long *pDepth) PURE;
    STDMETHOD(GetCurrentMode)(THIS_ long *pMode) PURE;
    STDMETHOD(IsModeAvailable)(THIS_ long Mode) PURE;
    STDMETHOD(IsModeEnabled)(THIS_ long Mode) PURE;
    STDMETHOD(SetEnabled)(THIS_ long Mode,long bEnabled) PURE;
    STDMETHOD(GetClipFactor)(THIS_ long *pClipFactor) PURE;
    STDMETHOD(SetClipFactor)(THIS_ long ClipFactor) PURE;
    STDMETHOD(SetMessageDrain)(THIS_ HWND hwnd) PURE;
    STDMETHOD(GetMessageDrain)(THIS_ HWND *hwnd) PURE;
    STDMETHOD(SetMonitor)(THIS_ long Monitor) PURE;
    STDMETHOD(GetMonitor)(THIS_ long *Monitor) PURE;
    STDMETHOD(HideOnDeactivate)(THIS_ long Hide) PURE;
    STDMETHOD(IsHideOnDeactivate)(THIS) PURE;
    STDMETHOD(SetCaption)(THIS_ BSTR strCaption) PURE;
    STDMETHOD(GetCaption)(THIS_ BSTR *pstrCaption) PURE;
    STDMETHOD(SetDefault)(THIS) PURE;
};


// This adds the accelerator table capabilities in fullscreen. This is being
// added between the original runtime release and the full SDK release. We
// cannot just add the method to IFullScreenVideo as we don't want to force
// applications to have to ship the ActiveMovie support DLLs - this is very
// important to applications that plan on being downloaded over the Internet

// be nice to our friends in C
#undef INTERFACE
#define INTERFACE IFullScreenVideoEx

DECLARE_INTERFACE_(IFullScreenVideoEx, IFullScreenVideo)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IFullScreenVideo methods

    STDMETHOD(CountModes)(THIS_ long *pModes) PURE;
    STDMETHOD(GetModeInfo)(THIS_ long Mode,long *pWidth,long *pHeight,long *pDepth) PURE;
    STDMETHOD(GetCurrentMode)(THIS_ long *pMode) PURE;
    STDMETHOD(IsModeAvailable)(THIS_ long Mode) PURE;
    STDMETHOD(IsModeEnabled)(THIS_ long Mode) PURE;
    STDMETHOD(SetEnabled)(THIS_ long Mode,long bEnabled) PURE;
    STDMETHOD(GetClipFactor)(THIS_ long *pClipFactor) PURE;
    STDMETHOD(SetClipFactor)(THIS_ long ClipFactor) PURE;
    STDMETHOD(SetMessageDrain)(THIS_ HWND hwnd) PURE;
    STDMETHOD(GetMessageDrain)(THIS_ HWND *hwnd) PURE;
    STDMETHOD(SetMonitor)(THIS_ long Monitor) PURE;
    STDMETHOD(GetMonitor)(THIS_ long *Monitor) PURE;
    STDMETHOD(HideOnDeactivate)(THIS_ long Hide) PURE;
    STDMETHOD(IsHideOnDeactivate)(THIS) PURE;
    STDMETHOD(SetCaption)(THIS_ BSTR strCaption) PURE;
    STDMETHOD(GetCaption)(THIS_ BSTR *pstrCaption) PURE;
    STDMETHOD(SetDefault)(THIS) PURE;

    // IFullScreenVideoEx

    STDMETHOD(SetAcceleratorTable)(THIS_ HWND hwnd,HACCEL hAccel) PURE;
    STDMETHOD(GetAcceleratorTable)(THIS_ HWND *phwnd,HACCEL *phAccel) PURE;
    STDMETHOD(KeepPixelAspectRatio)(THIS_ long KeepAspect) PURE;
    STDMETHOD(IsKeepPixelAspectRatio)(THIS_ long *pKeepAspect) PURE;
};


// The SDK base classes contain a base video mixer class. Video mixing in a
// software environment is tricky because we typically have multiple streams
// each sending data at unpredictable times. To work with this we defined a
// pin that is the lead pin, when data arrives on this pin we do a mix. As
// an alternative we may not want to have a lead pin but output samples at
// predefined spaces, like one every 1/15 of a second, this interfaces also
// supports that mode of operations (there is a working video mixer sample)

// be nice to our friends in C
#undef INTERFACE
#define INTERFACE IBaseVideoMixer

DECLARE_INTERFACE_(IBaseVideoMixer, IUnknown)
{
    STDMETHOD(SetLeadPin)(THIS_ int iPin) PURE;
    STDMETHOD(GetLeadPin)(THIS_ int *piPin) PURE;
    STDMETHOD(GetInputPinCount)(THIS_ int *piPinCount) PURE;
    STDMETHOD(IsUsingClock)(THIS_ int *pbValue) PURE;
    STDMETHOD(SetUsingClock)(THIS_ int bValue) PURE;
    STDMETHOD(GetClockPeriod)(THIS_ int *pbValue) PURE;
    STDMETHOD(SetClockPeriod)(THIS_ int bValue) PURE;
};

#define iPALETTE_COLORS 256     // Maximum colours in palette
#define iEGA_COLORS 16          // Number colours in EGA palette
#define iMASK_COLORS 3          // Maximum three components
#define iTRUECOLOR 16           // Minimum true colour device
#define iRED 0                  // Index position for RED mask
#define iGREEN 1                // Index position for GREEN mask
#define iBLUE 2                 // Index position for BLUE mask
#define iPALETTE 8              // Maximum colour depth using a palette
#define iMAXBITS 8              // Maximum bits per colour component


// Used for true colour images that also have a palette

typedef struct tag_TRUECOLORINFO {
    DWORD   dwBitMasks[iMASK_COLORS];
    RGBQUAD bmiColors[iPALETTE_COLORS];
} TRUECOLORINFO;


// The BITMAPINFOHEADER contains all the details about the video stream such
// as the actual image dimensions and their pixel depth. A source filter may
// also request that the sink take only a section of the video by providing a
// clipping rectangle in rcSource. In the worst case where the sink filter
// forgets to check this on connection it will simply render the whole thing
// which isn't a disaster. Ideally a sink filter will check the rcSource and
// if it doesn't support image extraction and the rectangle is not empty then
// it will reject the connection. A filter should use SetRectEmpty to reset a
// rectangle to all zeroes (and IsRectEmpty to later check the rectangle).
// The rcTarget specifies the destination rectangle for the video, for most
// source filters they will set this to all zeroes, a downstream filter may
// request that the video be placed in a particular area of the buffers it
// supplies in which case it will call QueryAccept with a non empty target

typedef struct tagVIDEOINFOHEADER {

    RECT            rcSource;          // The bit we really want to use
    RECT            rcTarget;          // Where the video should go
    DWORD           dwBitRate;         // Approximate bit data rate
    DWORD           dwBitErrorRate;    // Bit error rate for this stream
    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

    BITMAPINFOHEADER bmiHeader;

} VIDEOINFOHEADER;

// make sure the pbmi is initialized before using these macros
#define TRUECOLOR(pbmi)  ((TRUECOLORINFO *)(((LPBYTE)&((pbmi)->bmiHeader)) \
					+ (pbmi)->bmiHeader.biSize))
#define COLORS(pbmi)	((RGBQUAD *)(((LPBYTE)&((pbmi)->bmiHeader)) 	\
					+ (pbmi)->bmiHeader.biSize))
#define BITMASKS(pbmi)	((DWORD *)(((LPBYTE)&((pbmi)->bmiHeader)) 	\
					+ (pbmi)->bmiHeader.biSize))

// All the image based filters use this to communicate their media types. It's
// centred principally around the BITMAPINFO. This structure always contains a
// BITMAPINFOHEADER followed by a number of other fields depending on what the
// BITMAPINFOHEADER contains. If it contains details of a palettised format it
// will be followed by one or more RGBQUADs defining the palette. If it holds
// details of a true colour format then it may be followed by a set of three
// DWORD bit masks that specify where the RGB data can be found in the image
// (For more information regarding BITMAPINFOs see the Win32 documentation)

// The rcSource and rcTarget fields are not for use by filters supplying the
// data. The destination (target) rectangle should be set to all zeroes. The
// source may also be zero filled or set with the dimensions of the video. So
// if the video is 352x288 pixels then set it to (0,0,352,288). These fields
// are mainly used by downstream filters that want to ask the source filter
// to place the image in a different position in an output buffer. So when
// using for example the primary surface the video renderer may ask a filter
// to place the video images in a destination position of (100,100,452,388)
// on the display since that's where the window is positioned on the display

// !!! WARNING !!!
// DO NOT use this structure unless you are sure that the BITMAPINFOHEADER
// has a normal biSize == sizeof(BITMAPINFOHEADER) !
// !!! WARNING !!!

typedef struct tagVIDEOINFO {

    RECT            rcSource;          // The bit we really want to use
    RECT            rcTarget;          // Where the video should go
    DWORD           dwBitRate;         // Approximate bit data rate
    DWORD           dwBitErrorRate;    // Bit error rate for this stream
    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

    BITMAPINFOHEADER bmiHeader;

    union {
        RGBQUAD         bmiColors[iPALETTE_COLORS];     // Colour palette
        DWORD           dwBitMasks[iMASK_COLORS];       // True colour masks
        TRUECOLORINFO   TrueColorInfo;                  // Both of the above
    };

} VIDEOINFO;

// These macros define some standard bitmap format sizes

#define SIZE_EGA_PALETTE (iEGA_COLORS * sizeof(RGBQUAD))
#define SIZE_PALETTE (iPALETTE_COLORS * sizeof(RGBQUAD))
#define SIZE_MASKS (iMASK_COLORS * sizeof(DWORD))
#define SIZE_PREHEADER (FIELD_OFFSET(VIDEOINFOHEADER,bmiHeader))
#define SIZE_VIDEOHEADER (sizeof(BITMAPINFOHEADER) + SIZE_PREHEADER)
// !!! for abnormal biSizes
// #define SIZE_VIDEOHEADER(pbmi) ((pbmi)->bmiHeader.biSize + SIZE_PREHEADER)

// DIBSIZE calculates the number of bytes required by an image

#define WIDTHBYTES(bits) ((DWORD)(((bits)+31) & (~31)) / 8)
#define DIBWIDTHBYTES(bi) (DWORD)WIDTHBYTES((DWORD)(bi).biWidth * (DWORD)(bi).biBitCount)
#define _DIBSIZE(bi) (DIBWIDTHBYTES(bi) * (DWORD)(bi).biHeight)
#define DIBSIZE(bi) ((bi).biHeight < 0 ? (-1)*(_DIBSIZE(bi)) : _DIBSIZE(bi))

// This compares the bit masks between two VIDEOINFOHEADERs

#define BIT_MASKS_MATCH(pbmi1,pbmi2)                                \
    (((pbmi1)->dwBitMasks[iRED] == (pbmi2)->dwBitMasks[iRED]) &&        \
     ((pbmi1)->dwBitMasks[iGREEN] == (pbmi2)->dwBitMasks[iGREEN]) &&    \
     ((pbmi1)->dwBitMasks[iBLUE] == (pbmi2)->dwBitMasks[iBLUE]))

// These zero fill different parts of the VIDEOINFOHEADER structure

// Only use these macros for pbmi's with a normal BITMAPINFOHEADER biSize
#define RESET_MASKS(pbmi) (ZeroMemory((PVOID)(pbmi)->dwBitFields,SIZE_MASKS))
#define RESET_HEADER(pbmi) (ZeroMemory((PVOID)(pbmi),SIZE_VIDEOHEADER))
#define RESET_PALETTE(pbmi) (ZeroMemory((PVOID)(pbmi)->bmiColors,SIZE_PALETTE));

#if 0
// !!! This is the right way to do it, but may break existing code
#define RESET_MASKS(pbmi) (ZeroMemory((PVOID)(((LPBYTE)(pbmi)->bmiHeader) + \
			(pbmi)->bmiHeader.biSize,SIZE_MASKS)))
#define RESET_HEADER(pbmi) (ZeroMemory((PVOID)(pbmi), SIZE_PREHEADER +	    \
			sizeof(BITMAPINFOHEADER)))
#define RESET_PALETTE(pbmi) (ZeroMemory((PVOID)(((LPBYTE)(pbmi)->bmiHeader) + \
			(pbmi)->bmiHeader.biSize,SIZE_PALETTE))
#endif

// Other (hopefully) useful bits and bobs

#define PALETTISED(pbmi) ((pbmi)->bmiHeader.biBitCount <= iPALETTE)
#define PALETTE_ENTRIES(pbmi) ((DWORD) 1 << (pbmi)->bmiHeader.biBitCount)

// Returns the address of the BITMAPINFOHEADER from the VIDEOINFOHEADER
#define HEADER(pVideoInfo) (&(((VIDEOINFOHEADER *) (pVideoInfo))->bmiHeader))


// MPEG variant - includes a DWORD length followed by the
// video sequence header after the video header.
//
// The sequence header includes the sequence header start code and the
// quantization matrices associated with the first sequence header in the
// stream so is a maximum of 140 bytes long.

typedef struct tagMPEG1VIDEOINFO {

    VIDEOINFOHEADER hdr;                    // Compatible with VIDEOINFO
    DWORD           dwStartTimeCode;        // 25-bit Group of pictures time code
                                            // at start of data
    DWORD           cbSequenceHeader;       // Length in bytes of bSequenceHeader
    BYTE            bSequenceHeader[1];     // Sequence header including
                                            // quantization matrices if any
} MPEG1VIDEOINFO;

#define MAX_SIZE_MPEG1_SEQUENCE_INFO 140
#define SIZE_MPEG1VIDEOINFO(pv) (FIELD_OFFSET(MPEG1VIDEOINFO, bSequenceHeader[0]) + (pv)->cbSequenceHeader)
#define MPEG1_SEQUENCE_INFO(pv) ((const BYTE *)(pv)->bSequenceHeader)


// Analog video variant - Use this when the format is FORMAT_AnalogVideo
//
// rcSource defines the portion of the active video signal to use
// rcTarget defines the destination rectangle
//    both of the above are relative to the dwActiveWidth and dwActiveHeight fields
// dwActiveWidth is currently set to 720 for all formats (but could change for HDTV)
// dwActiveHeight is 483 for NTSC and 575 for PAL/SECAM  (but could change for HDTV)

typedef struct tagAnalogVideoInfo {
    RECT            rcSource;           // Width max is 720, height varies w/ TransmissionStd
    RECT            rcTarget;           // Where the video should go
    DWORD           dwActiveWidth;      // Always 720 (CCIR-601 active samples per line)
    DWORD           dwActiveHeight;     // 483 for NTSC, 575 for PAL/SECAM
    REFERENCE_TIME  AvgTimePerFrame;    // Normal ActiveMovie units (100 nS)
} ANALOGVIDEOINFO;


#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __AMVIDEO__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\amfilter.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Base class hierarchy for streams architecture, December 1994

#ifndef __FILTER__
#define __FILTER__

/* The following classes are declared in this header: */

class CBaseMediaFilter;     // IMediaFilter support
class CBaseFilter;          // IBaseFilter,IMediaFilter support
class CBasePin;             // Abstract base class for IPin interface
class CEnumPins;            // Enumerate input and output pins
class CEnumMediaTypes;      // Enumerate the pin's preferred formats
class CBaseOutputPin;       // Adds data provider member functions
class CBaseInputPin;        // Implements IMemInputPin interface
class CMediaSample;         // Basic transport unit for IMemInputPin
class CBaseAllocator;       // General list guff for most allocators
class CMemAllocator;        // Implements memory buffer allocation


//=====================================================================
//=====================================================================
//
// QueryFilterInfo and QueryPinInfo AddRef the interface pointers
// they return.  You can use the macro below to release the interface.
//
//=====================================================================
//=====================================================================

#define QueryFilterInfoReleaseGraph(fi) if ((fi).pGraph) (fi).pGraph->Release();

#define QueryPinInfoReleaseFilter(pi) if ((pi).pFilter) (pi).pFilter->Release();

//=====================================================================
//=====================================================================
// Defines CBaseMediaFilter
//
// Abstract base class implementing IMediaFilter.
//
// Typically you will derive your filter from CBaseFilter rather than
// this,  unless you are implementing an object such as a plug-in
// distributor that needs to support IMediaFilter but not IBaseFilter.
//
// Note that IMediaFilter is derived from IPersist to allow query of
// class id.
//=====================================================================
//=====================================================================

class AM_NOVTABLE CBaseMediaFilter : public CUnknown,
                                     public IMediaFilter
{

protected:

    FILTER_STATE    m_State;            // current state: running, paused
    IReferenceClock *m_pClock;          // this filter's reference clock
    // note: all filters in a filter graph use the same clock

    // offset from stream time to reference time
    CRefTime        m_tStart;

    CLSID	    m_clsid;            // This filters clsid
                                        // used for serialization
    CCritSec        *m_pLock;           // Object we use for locking

public:

    CBaseMediaFilter(
        const TCHAR     *pName,
        LPUNKNOWN pUnk,
        CCritSec  *pLock,
	REFCLSID   clsid);

    virtual ~CBaseMediaFilter();

    DECLARE_IUNKNOWN

    // override this to say what interfaces we support where
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    //
    // --- IPersist method ---
    //

    STDMETHODIMP GetClassID(CLSID *pClsID);

    // --- IMediaFilter methods ---

    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);

    STDMETHODIMP SetSyncSource(IReferenceClock *pClock);

    STDMETHODIMP GetSyncSource(IReferenceClock **pClock);

    // default implementation of Stop and Pause just record the
    // state. Override to activate or de-activate your filter.
    // Note that Run when called from Stopped state will call Pause
    // to ensure activation, so if you are a source or transform
    // you will probably not need to override Run.
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();


    // the start parameter is the difference to be added to the
    // sample's stream time to get the reference time for
    // its presentation
    STDMETHODIMP Run(REFERENCE_TIME tStart);

    // --- helper methods ---

    // return the current stream time - ie find out what
    // stream time should be appearing now
    virtual HRESULT StreamTime(CRefTime& rtStream);

    // Is the filter currently active? (running or paused)
    BOOL IsActive() {
        CAutoLock cObjectLock(m_pLock);
        return ((m_State == State_Paused) || (m_State == State_Running));
    };
};

//=====================================================================
//=====================================================================
// Defines CBaseFilter
//
// An abstract class providing basic IBaseFilter support for pin
// enumeration and filter information reading.
//
// We cannot derive from CBaseMediaFilter since methods in IMediaFilter
// are also in IBaseFilter and would be ambiguous. Since much of the code
// assumes that they derive from a class that has m_State and other state
// directly available, we duplicate code from CBaseMediaFilter rather than
// having a member variable.
//
// Derive your filter from this, or from a derived object such as
// CTransformFilter.
//=====================================================================
//=====================================================================


class AM_NOVTABLE CBaseFilter : public CUnknown,        // Handles an IUnknown
                    public IBaseFilter,     // The Filter Interface
                    public IAMovieSetup     // For un/registration
{

friend class CBasePin;

protected:
    FILTER_STATE    m_State;            // current state: running, paused
    IReferenceClock *m_pClock;          // this graph's ref clock
    CRefTime        m_tStart;           // offset from stream time to reference time
    CLSID	    m_clsid;            // This filters clsid
                                        // used for serialization
    CCritSec        *m_pLock;           // Object we use for locking

    WCHAR           *m_pName;           // Full filter name
    IFilterGraph    *m_pGraph;          // Graph we belong to
    IMediaEventSink *m_pSink;           // Called with notify events
    LONG            m_PinVersion;       // Current pin version

public:

    CBaseFilter(
        const TCHAR *pName,     // Object description
        LPUNKNOWN pUnk,         // IUnknown of delegating object
        CCritSec  *pLock,       // Object who maintains lock
	REFCLSID   clsid);      // The clsid to be used to serialize this filter

    CBaseFilter(
        TCHAR     *pName,       // Object description
        LPUNKNOWN pUnk,         // IUnknown of delegating object
        CCritSec  *pLock,       // Object who maintains lock
	REFCLSID   clsid,       // The clsid to be used to serialize this filter
        HRESULT   *phr);        // General OLE return code

    ~CBaseFilter();

    DECLARE_IUNKNOWN

    // override this to say what interfaces we support where
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
#ifdef DEBUG
    STDMETHODIMP_(ULONG) NonDelegatingRelease();
#endif

    //
    // --- IPersist method ---
    //

    STDMETHODIMP GetClassID(CLSID *pClsID);

    // --- IMediaFilter methods ---

    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);

    STDMETHODIMP SetSyncSource(IReferenceClock *pClock);

    STDMETHODIMP GetSyncSource(IReferenceClock **pClock);


    // override Stop and Pause so we can activate the pins.
    // Note that Run will call Pause first if activation needed.
    // Override these if you want to activate your filter rather than
    // your pins.
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();

    // the start parameter is the difference to be added to the
    // sample's stream time to get the reference time for
    // its presentation
    STDMETHODIMP Run(REFERENCE_TIME tStart);

    // --- helper methods ---

    // return the current stream time - ie find out what
    // stream time should be appearing now
    virtual HRESULT StreamTime(CRefTime& rtStream);

    // Is the filter currently active?
    BOOL IsActive() {
        CAutoLock cObjectLock(m_pLock);
        return ((m_State == State_Paused) || (m_State == State_Running));
    };

    // Is this filter stopped (without locking)
    BOOL IsStopped() {
        return (m_State == State_Stopped);
    };

    //
    // --- IBaseFilter methods ---
    //

    // pin enumerator
    STDMETHODIMP EnumPins(
                    IEnumPins ** ppEnum);


    // default behaviour of FindPin assumes pin ids are their names
    STDMETHODIMP FindPin(
        LPCWSTR Id,
        IPin ** ppPin
    );

    STDMETHODIMP QueryFilterInfo(
                    FILTER_INFO * pInfo);

    STDMETHODIMP JoinFilterGraph(
                    IFilterGraph * pGraph,
                    LPCWSTR pName);

    // return a Vendor information string. Optional - may return E_NOTIMPL.
    // memory returned should be freed using CoTaskMemFree
    // default implementation returns E_NOTIMPL
    STDMETHODIMP QueryVendorInfo(
                    LPWSTR* pVendorInfo
            );

    // --- helper methods ---

    // send an event notification to the filter graph if we know about it.
    // returns S_OK if delivered, S_FALSE if the filter graph does not sink
    // events, or an error otherwise.
    HRESULT NotifyEvent(
        long EventCode,
        LONG_PTR EventParam1,
        LONG_PTR EventParam2);

    // return the filter graph we belong to
    IFilterGraph *GetFilterGraph() {
        return m_pGraph;
    }

    // Request reconnect
    // pPin is the pin to reconnect
    // pmt is the type to reconnect with - can be NULL
    // Calls ReconnectEx on the filter graph
    HRESULT ReconnectPin(IPin *pPin, AM_MEDIA_TYPE const *pmt);

    // find out the current pin version (used by enumerators)
    virtual LONG GetPinVersion();
    void IncrementPinVersion();

    // you need to supply these to access the pins from the enumerator
    // and for default Stop and Pause/Run activation.
    virtual int GetPinCount() PURE;
    virtual CBasePin *GetPin(int n) PURE;

    // --- IAMovieSetup methods ---

    STDMETHODIMP Register();    // ask filter to register itself
    STDMETHODIMP Unregister();  // and unregister itself

    // --- setup helper methods ---
    // (override to return filters setup data)

    virtual LPAMOVIESETUP_FILTER GetSetupData(){ return NULL; }

};


//=====================================================================
//=====================================================================
// Defines CBasePin
//
// Abstract class that supports the basics of IPin
//=====================================================================
//=====================================================================

class  AM_NOVTABLE CBasePin : public CUnknown, public IPin, public IQualityControl
{

protected:

    WCHAR *         m_pName;		        // This pin's name
    IPin            *m_Connected;               // Pin we have connected to
    CMediaType      m_mt;                       // Media type of connection
    PIN_DIRECTION   m_dir;                      // Direction of this pin
    CCritSec        *m_pLock;                   // Object we use for locking
    BOOL            m_bRunTimeError;            // Run time error generated
    CBaseFilter    *m_pFilter;                  // Filter we were created by
    IQualityControl *m_pQSink;                  // Target for Quality messages
    LONG            m_TypeVersion;              // Holds current type version

    CRefTime        m_tStart;                   // time from NewSegment call
    CRefTime        m_tStop;                    // time from NewSegment
    double          m_dRate;                    // rate from NewSegment

#ifdef DEBUG
    LONG            m_cRef;                     // Ref count tracing
#endif

    // displays pin connection information

#ifdef DEBUG
    void DisplayPinInfo(IPin *pReceivePin);
    void DisplayTypeInfo(IPin *pPin, const CMediaType *pmt);
#else
    void DisplayPinInfo(IPin *pReceivePin) {};
    void DisplayTypeInfo(IPin *pPin, const CMediaType *pmt) {};
#endif

    // used to agree a media type for a pin connection

    // given a specific media type, attempt a connection (includes
    // checking that the type is acceptable to this pin)
    HRESULT
    AttemptConnection(
        IPin* pReceivePin,      // connect to this pin
        const CMediaType* pmt   // using this type
    );

    // try all the media types in this enumerator - for each that
    // we accept, try to connect using ReceiveConnection.
    HRESULT TryMediaTypes(
                        IPin *pReceivePin,      // connect to this pin
                        const CMediaType *pmt,        // proposed type from Connect
                        IEnumMediaTypes *pEnum);    // try this enumerator

    // establish a connection with a suitable mediatype. Needs to
    // propose a media type if the pmt pointer is null or partially
    // specified - use TryMediaTypes on both our and then the other pin's
    // enumerator until we find one that works.
    HRESULT AgreeMediaType(
                        IPin *pReceivePin,      // connect to this pin
                        const CMediaType *pmt);       // proposed type from Connect

public:

    CBasePin(
        TCHAR *pObjectName,         // Object description
        CBaseFilter *pFilter,       // Owning filter who knows about pins
        CCritSec *pLock,            // Object who implements the lock
        HRESULT *phr,               // General OLE return code
        LPCWSTR pName,              // Pin name for us
        PIN_DIRECTION dir);         // Either PINDIR_INPUT or PINDIR_OUTPUT

    virtual ~CBasePin();

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG) NonDelegatingRelease();
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();

    // --- IPin methods ---

    // take lead role in establishing a connection. Media type pointer
    // may be null, or may point to partially-specified mediatype
    // (subtype or format type may be GUID_NULL).
    STDMETHODIMP Connect(
        IPin * pReceivePin,
        const AM_MEDIA_TYPE *pmt   // optional media type
    );

    // (passive) accept a connection from another pin
    STDMETHODIMP ReceiveConnection(
        IPin * pConnector,      // this is the initiating connecting pin
        const AM_MEDIA_TYPE *pmt   // this is the media type we will exchange
    );

    STDMETHODIMP Disconnect();

    STDMETHODIMP ConnectedTo(IPin **pPin);

    STDMETHODIMP ConnectionMediaType(AM_MEDIA_TYPE *pmt);

    STDMETHODIMP QueryPinInfo(
        PIN_INFO * pInfo
    );

    STDMETHODIMP QueryDirection(
    	PIN_DIRECTION * pPinDir
    );

    STDMETHODIMP QueryId(
        LPWSTR * Id
    );

    // does the pin support this media type
    STDMETHODIMP QueryAccept(
        const AM_MEDIA_TYPE *pmt
    );

    // return an enumerator for this pins preferred media types
    STDMETHODIMP EnumMediaTypes(
        IEnumMediaTypes **ppEnum
    );

    // return an array of IPin* - the pins that this pin internally connects to
    // All pins put in the array must be AddReffed (but no others)
    // Errors: "Can't say" - FAIL, not enough slots - return S_FALSE
    // Default: return E_NOTIMPL
    // The filter graph will interpret NOT_IMPL as any input pin connects to
    // all visible output pins and vice versa.
    // apPin can be NULL if nPin==0 (not otherwise).
    STDMETHODIMP QueryInternalConnections(
        IPin* *apPin,     // array of IPin*
        ULONG *nPin       // on input, the number of slots
                          // on output  the number of pins
    ) { return E_NOTIMPL; }

    // Called when no more data will be sent
    STDMETHODIMP EndOfStream(void);

    // Begin/EndFlush still PURE

    // NewSegment notifies of the start/stop/rate applying to the data
    // about to be received. Default implementation records data and
    // returns S_OK.
    // Override this to pass downstream.
    STDMETHODIMP NewSegment(
                    REFERENCE_TIME tStart,
                    REFERENCE_TIME tStop,
                    double dRate);

    //================================================================================
    // IQualityControl methods
    //================================================================================

    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);

    STDMETHODIMP SetSink(IQualityControl * piqc);

    // --- helper methods ---

    // Returns true if the pin is connected. false otherwise.
    BOOL IsConnected(void) {return (m_Connected != NULL); };
    // Return the pin this is connected to (if any)
    IPin * GetConnected() { return m_Connected; };

    // Check if our filter is currently stopped
    BOOL IsStopped() {
        return (m_pFilter->m_State == State_Stopped);
    };

    // find out the current type version (used by enumerators)
    virtual LONG GetMediaTypeVersion();
    void IncrementTypeVersion();

    // switch the pin to active (paused or running) mode
    // not an error to call this if already active
    virtual HRESULT Active(void);

    // switch the pin to inactive state - may already be inactive
    virtual HRESULT Inactive(void);

    // Notify of Run() from filter
    virtual HRESULT Run(REFERENCE_TIME tStart);

    // check if the pin can support this specific proposed type and format
    virtual HRESULT CheckMediaType(const CMediaType *) PURE;

    // set the connection to use this format (previously agreed)
    virtual HRESULT SetMediaType(const CMediaType *);

    // check that the connection is ok before verifying it
    // can be overridden eg to check what interfaces will be supported.
    virtual HRESULT CheckConnect(IPin *);

    // Set and release resources required for a connection
    virtual HRESULT BreakConnect();
    virtual HRESULT CompleteConnect(IPin *pReceivePin);

    // returns the preferred formats for a pin
    virtual HRESULT GetMediaType(int iPosition,CMediaType *pMediaType);

    // access to NewSegment values
    REFERENCE_TIME CurrentStopTime() {
        return m_tStop;
    }
    REFERENCE_TIME CurrentStartTime() {
        return m_tStart;
    }
    double CurrentRate() {
        return m_dRate;
    }

    //  Access name
    LPWSTR Name() { return m_pName; };

};


//=====================================================================
//=====================================================================
// Defines CEnumPins
//
// Pin enumerator class that works by calling CBaseFilter. This interface
// is provided by CBaseFilter::EnumPins and calls GetPinCount() and
// GetPin() to enumerate existing pins. Needs to be a separate object so
// that it can be cloned (creating an existing object at the same
// position in the enumeration)
//
// NOTE It overrides the non delegating IUnknown so that it can not
// only keep it's own reference counting lifetime but it will also still
// delegate to the outer owner. This ensures the owner is around all the
// time we are
//=====================================================================
//=====================================================================

class CEnumPins : public IEnumPins      // The interface we support
{
    int m_Position;                 // Current ordinal position
    int m_PinCount;                 // Number of pins available
    CBaseFilter *m_pFilter;         // The filter who owns us
    LONG m_Version;                 // Pin version information
    LONG m_cRef;

    typedef CGenericList<CBasePin> CPinList;

    CPinList m_PinCache;	    // These pointers have not been AddRef'ed and
				    // so they should not be dereferenced.  They are
				    // merely kept to ID which pins have been enumerated.

#ifdef DEBUG
    DWORD m_dwCookie;
#endif

    /* If while we are retrieving a pin for example from the filter an error
       occurs we assume that our internal state is stale with respect to the
       filter (someone may have deleted all the pins). We can check before
       starting whether or not the operation is likely to fail by asking the
       filter what it's current version number is. If the filter has not
       overriden the GetPinVersion method then this will always match */

    BOOL AreWeOutOfSync() {
        return (m_pFilter->GetPinVersion() == m_Version ? FALSE : TRUE);
    };

    /* This method performs the same operations as Reset, except is does not clear
       the cache of pins already enumerated. */

    STDMETHODIMP Refresh();

public:

    CEnumPins(
        CBaseFilter *pFilter,
        CEnumPins *pEnumPins);

    virtual ~CEnumPins();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IEnumPins
    STDMETHODIMP Next(
        ULONG cPins,         // place this many pins...
        IPin ** ppPins,      // ...in this array of IPin*
        ULONG * pcFetched    // actual count passed returned here
    );

    STDMETHODIMP Skip(ULONG cPins);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumPins **ppEnum);


};


//=====================================================================
//=====================================================================
// Defines CEnumMediaTypes
//
// Enumerates the preferred formats for input and output pins
//=====================================================================
//=====================================================================

class CEnumMediaTypes : public IEnumMediaTypes    // The interface we support
{
    int m_Position;           // Current ordinal position
    CBasePin *m_pPin;         // The pin who owns us
    LONG m_Version;           // Media type version value
    LONG m_cRef;
#ifdef DEBUG
    DWORD m_dwCookie;
#endif

    /* The media types a filter supports can be quite dynamic so we add to
       the general IEnumXXXX interface the ability to be signaled when they
       change via an event handle the connected filter supplies. Until the
       Reset method is called after the state changes all further calls to
       the enumerator (except Reset) will return E_UNEXPECTED error code */

    BOOL AreWeOutOfSync() {
        return (m_pPin->GetMediaTypeVersion() == m_Version ? FALSE : TRUE);
    };

public:

    CEnumMediaTypes(
        CBasePin *pPin,
        CEnumMediaTypes *pEnumMediaTypes);

    virtual ~CEnumMediaTypes();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IEnumMediaTypes
    STDMETHODIMP Next(
        ULONG cMediaTypes,          // place this many pins...
        AM_MEDIA_TYPE ** ppMediaTypes,  // ...in this array
        ULONG * pcFetched           // actual count passed
    );

    STDMETHODIMP Skip(ULONG cMediaTypes);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumMediaTypes **ppEnum);
};




//=====================================================================
//=====================================================================
// Defines CBaseOutputPin
//
// class derived from CBasePin that can pass buffers to a connected pin
// that supports IMemInputPin. Supports IPin.
//
// Derive your output pin from this.
//
//=====================================================================
//=====================================================================

class  AM_NOVTABLE CBaseOutputPin : public CBasePin
{

protected:

    IMemAllocator *m_pAllocator;
    IMemInputPin *m_pInputPin;        // interface on the downstreaminput pin
                                      // set up in CheckConnect when we connect.

public:

    CBaseOutputPin(
        TCHAR *pObjectName,
        CBaseFilter *pFilter,
        CCritSec *pLock,
        HRESULT *phr,
        LPCWSTR pName);

    // override CompleteConnect() so we can negotiate an allocator
    virtual HRESULT CompleteConnect(IPin *pReceivePin);

    // negotiate the allocator and its buffer size/count and other properties
    // Calls DecideBufferSize to set properties
    virtual HRESULT DecideAllocator(IMemInputPin * pPin, IMemAllocator ** pAlloc);

    // override this to set the buffer size and count. Return an error
    // if the size/count is not to your liking.
    // The allocator properties passed in are those requested by the
    // input pin - use eg the alignment and prefix members if you have
    // no preference on these.
    virtual HRESULT DecideBufferSize(
        IMemAllocator * pAlloc,
        ALLOCATOR_PROPERTIES * ppropInputRequest
    ) PURE;

    // returns an empty sample buffer from the allocator
    virtual HRESULT GetDeliveryBuffer(IMediaSample ** ppSample,
                                      REFERENCE_TIME * pStartTime,
                                      REFERENCE_TIME * pEndTime,
                                      DWORD dwFlags);

    // deliver a filled-in sample to the connected input pin
    // note - you need to release it after calling this. The receiving
    // pin will addref the sample if it needs to hold it beyond the
    // call.
    virtual HRESULT Deliver(IMediaSample *);

    // override this to control the connection
    virtual HRESULT InitAllocator(IMemAllocator **ppAlloc);
    HRESULT CheckConnect(IPin *pPin);
    HRESULT BreakConnect();

    // override to call Commit and Decommit
    HRESULT Active(void);
    HRESULT Inactive(void);

    // we have a default handling of EndOfStream which is to return
    // an error, since this should be called on input pins only
    STDMETHODIMP EndOfStream(void);

    // called from elsewhere in our filter to pass EOS downstream to
    // our connected input pin
    virtual HRESULT DeliverEndOfStream(void);

    // same for Begin/EndFlush - we handle Begin/EndFlush since it
    // is an error on an output pin, and we have Deliver methods to
    // call the methods on the connected pin
    STDMETHODIMP BeginFlush(void);
    STDMETHODIMP EndFlush(void);
    virtual HRESULT DeliverBeginFlush(void);
    virtual HRESULT DeliverEndFlush(void);

    // deliver NewSegment to connected pin - you will need to
    // override this if you queue any data in your output pin.
    virtual HRESULT DeliverNewSegment(
                        REFERENCE_TIME tStart,
                        REFERENCE_TIME tStop,
                        double dRate);

    //================================================================================
    // IQualityControl methods
    //================================================================================

    // All inherited from CBasePin and not overridden here.
    // STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);
    // STDMETHODIMP SetSink(IQualityControl * piqc);
};


//=====================================================================
//=====================================================================
// Defines CBaseInputPin
//
// derive your standard input pin from this.
// you need to supply GetMediaType and CheckConnect etc (see CBasePin),
// and you need to supply Receive to do something more useful.
//
//=====================================================================
//=====================================================================

class AM_NOVTABLE CBaseInputPin : public CBasePin,
                                  public IMemInputPin
{

protected:

    IMemAllocator *m_pAllocator;    // Default memory allocator

    // allocator is read-only, so received samples
    // cannot be modified (probably only relevant to in-place
    // transforms
    BYTE m_bReadOnly;

//private:  this should really be private... only the MPEG code
// currently looks at it directly and it should use IsFlushing().
    // in flushing state (between BeginFlush and EndFlush)
    // if TRUE, all Receives are returned with S_FALSE
    BYTE m_bFlushing;

    // Sample properties - initalized in Receive
    AM_SAMPLE2_PROPERTIES m_SampleProps;

public:

    CBaseInputPin(
        TCHAR *pObjectName,
        CBaseFilter *pFilter,
        CCritSec *pLock,
        HRESULT *phr,
        LPCWSTR pName);

    virtual ~CBaseInputPin();

    DECLARE_IUNKNOWN

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    // return the allocator interface that this input pin
    // would like the output pin to use
    STDMETHODIMP GetAllocator(IMemAllocator ** ppAllocator);

    // tell the input pin which allocator the output pin is actually
    // going to use.
    STDMETHODIMP NotifyAllocator(
                    IMemAllocator * pAllocator,
                    BOOL bReadOnly);

    // override to release our stored allocator
    STDMETHODIMP Disconnect();

    // do something with this media sample
    STDMETHODIMP Receive(IMediaSample *pSample);

    // do something with these media samples
    STDMETHODIMP ReceiveMultiple (
        IMediaSample **pSamples,
        long nSamples,
        long *nSamplesProcessed);

    // See if Receive() blocks
    STDMETHODIMP ReceiveCanBlock();

    // Default handling for BeginFlush - call at the beginning
    // of your implementation (makes sure that all Receive calls
    // fail). After calling this, you need to free any queued data
    // and then call downstream.
    STDMETHODIMP BeginFlush(void);

    // default handling for EndFlush - call at end of your implementation
    // - before calling this, ensure that there is no queued data and no thread
    // pushing any more without a further receive, then call downstream,
    // then call this method to clear the m_bFlushing flag and re-enable
    // receives
    STDMETHODIMP EndFlush(void);

    // this method is optional (can return E_NOTIMPL).
    // default implementation returns E_NOTIMPL. Override if you have
    // specific alignment or prefix needs, but could use an upstream
    // allocator
    STDMETHODIMP GetAllocatorRequirements(ALLOCATOR_PROPERTIES*pProps);

    // helper method to check the read-only flag
    BOOL IsReadOnly() {
        return m_bReadOnly;
    };

    // helper method to see if we are flushing
    BOOL IsFlushing() {
        return m_bFlushing;
    };

    //  Override this for checking whether it's OK to process samples
    //  Also call this from EndOfStream.
    virtual HRESULT CheckStreaming();

    // Pass a Quality notification on to the appropriate sink
    HRESULT PassNotify(Quality& q);


    //================================================================================
    // IQualityControl methods (from CBasePin)
    //================================================================================

    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);

    // no need to override:
    // STDMETHODIMP SetSink(IQualityControl * piqc);


    // switch the pin to inactive state - may already be inactive
    virtual HRESULT Inactive(void);

    // Return sample properties pointer
    AM_SAMPLE2_PROPERTIES * SampleProps() {
        ASSERT(m_SampleProps.cbData != 0);
        return &m_SampleProps;
    }
};



//=====================================================================
//=====================================================================
// Memory allocators
//
// the shared memory transport between pins requires the input pin
// to provide a memory allocator that can provide sample objects. A
// sample object supports the IMediaSample interface.
//
// CBaseAllocator handles the management of free and busy samples. It
// allocates CMediaSample objects. CBaseAllocator is an abstract class:
// in particular it has no method of initializing the list of free
// samples. CMemAllocator is derived from CBaseAllocator and initializes
// the list of samples using memory from the standard IMalloc interface.
//
// If you want your buffers to live in some special area of memory,
// derive your allocator object from CBaseAllocator. If you derive your
// IMemInputPin interface object from CBaseMemInputPin, you will get
// CMemAllocator-based allocation etc for free and will just need to
// supply the Receive handling, and media type / format negotiation.
//=====================================================================
//=====================================================================


//=====================================================================
//=====================================================================
// Defines CMediaSample
//
// an object of this class supports IMediaSample and represents a buffer
// for media data with some associated properties. Releasing it returns
// it to a freelist managed by a CBaseAllocator derived object.
//=====================================================================
//=====================================================================

class CMediaSample : public IMediaSample2    // The interface we support
{

protected:

    friend class CBaseAllocator;

    /*  Values for dwFlags - these are used for backward compatiblity
        only now - use AM_SAMPLE_xxx
    */
    enum { Sample_SyncPoint       = 0x01,   /* Is this a sync point */
           Sample_Preroll         = 0x02,   /* Is this a preroll sample */
           Sample_Discontinuity   = 0x04,   /* Set if start of new segment */
           Sample_TypeChanged     = 0x08,   /* Has the type changed */
           Sample_TimeValid       = 0x10,   /* Set if time is valid */
           Sample_MediaTimeValid  = 0x20,   /* Is the media time valid */
           Sample_TimeDiscontinuity = 0x40, /* Time discontinuity */
           Sample_StopValid       = 0x100,  /* Stop time valid */
           Sample_ValidFlags      = 0x1FF
         };

    /* Properties, the media sample class can be a container for a format
       change in which case we take a copy of a type through the SetMediaType
       interface function and then return it when GetMediaType is called. As
       we do no internal processing on it we leave it as a pointer */

    DWORD            m_dwFlags;         /* Flags for this sample */
                                        /* Type specific flags are packed
                                           into the top word
                                        */
    DWORD            m_dwTypeSpecificFlags; /* Media type specific flags */
    LPBYTE           m_pBuffer;         /* Pointer to the complete buffer */
    LONG             m_lActual;         /* Length of data in this sample */
    LONG             m_cbBuffer;        /* Size of the buffer */
    CBaseAllocator  *m_pAllocator;      /* The allocator who owns us */
    CMediaSample     *m_pNext;          /* Chaining in free list */
    REFERENCE_TIME   m_Start;           /* Start sample time */
    REFERENCE_TIME   m_End;             /* End sample time */
    LONGLONG         m_MediaStart;      /* Real media start position */
    LONG             m_MediaEnd;        /* A difference to get the end */
    AM_MEDIA_TYPE    *m_pMediaType;     /* Media type change data */
    DWORD            m_dwStreamId;      /* Stream id */
public:
    LONG             m_cRef;            /* Reference count */


public:

    CMediaSample(
        TCHAR *pName,
        CBaseAllocator *pAllocator,
        HRESULT *phr,
        LPBYTE pBuffer = NULL,
        LONG length = 0);

    virtual ~CMediaSample();

    /* Note the media sample does not delegate to its owner */

    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // set the buffer pointer and length. Used by allocators that
    // want variable sized pointers or pointers into already-read data.
    // This is only available through a CMediaSample* not an IMediaSample*
    // and so cannot be changed by clients.
    HRESULT SetPointer(BYTE * ptr, LONG cBytes);

    // Get me a read/write pointer to this buffer's memory.
    STDMETHODIMP GetPointer(BYTE ** ppBuffer);

    STDMETHODIMP_(LONG) GetSize(void);

    // get the stream time at which this sample should start and finish.
    STDMETHODIMP GetTime(
        REFERENCE_TIME * pTimeStart,     // put time here
        REFERENCE_TIME * pTimeEnd
    );

    // Set the stream time at which this sample should start and finish.
    STDMETHODIMP SetTime(
        REFERENCE_TIME * pTimeStart,     // put time here
        REFERENCE_TIME * pTimeEnd
    );
    STDMETHODIMP IsSyncPoint(void);
    STDMETHODIMP SetSyncPoint(BOOL bIsSyncPoint);
    STDMETHODIMP IsPreroll(void);
    STDMETHODIMP SetPreroll(BOOL bIsPreroll);

    STDMETHODIMP_(LONG) GetActualDataLength(void);
    STDMETHODIMP SetActualDataLength(LONG lActual);

    // these allow for limited format changes in band

    STDMETHODIMP GetMediaType(AM_MEDIA_TYPE **ppMediaType);
    STDMETHODIMP SetMediaType(AM_MEDIA_TYPE *pMediaType);

    // returns S_OK if there is a discontinuity in the data (this same is
    // not a continuation of the previous stream of data
    // - there has been a seek).
    STDMETHODIMP IsDiscontinuity(void);
    // set the discontinuity property - TRUE if this sample is not a
    // continuation, but a new sample after a seek.
    STDMETHODIMP SetDiscontinuity(BOOL bDiscontinuity);

    // get the media times for this sample
    STDMETHODIMP GetMediaTime(
    	LONGLONG * pTimeStart,
	LONGLONG * pTimeEnd
    );

    // Set the media times for this sample
    STDMETHODIMP SetMediaTime(
    	LONGLONG * pTimeStart,
	LONGLONG * pTimeEnd
    );

    // Set and get properties (IMediaSample2)
    STDMETHODIMP GetProperties(
        DWORD cbProperties,
        BYTE * pbProperties
    );

    STDMETHODIMP SetProperties(
        DWORD cbProperties,
        const BYTE * pbProperties
    );
};


//=====================================================================
//=====================================================================
// Defines CBaseAllocator
//
// Abstract base class that manages a list of media samples
//
// This class provides support for getting buffers from the free list,
// including handling of commit and (asynchronous) decommit.
//
// Derive from this class and override the Alloc and Free functions to
// allocate your CMediaSample (or derived) objects and add them to the
// free list, preparing them as necessary.
//=====================================================================
//=====================================================================

class AM_NOVTABLE CBaseAllocator : public CUnknown,         // A non delegating IUnknown
                       public IMemAllocator,    // The interface we support
                       public CCritSec          // Provides object locking
{
    class CSampleList;
    friend class CSampleList;

    /*  Hack to get at protected member in CMediaSample */
    static CMediaSample * &NextSample(CMediaSample *pSample)
    {
        return pSample->m_pNext;
    };

    /*  Mini list class for the free list */
    class CSampleList
    {
    public:
        CSampleList() : m_List(NULL), m_nOnList(0) {};
#ifdef DEBUG
        ~CSampleList()
        {
            ASSERT(m_nOnList == 0);
        };
#endif
        CMediaSample *Head() const { return m_List; };
        CMediaSample *Next(CMediaSample *pSample) const { return CBaseAllocator::NextSample(pSample); };
        int GetCount() const { return m_nOnList; };
        void Add(CMediaSample *pSample)
        {
            ASSERT(pSample != NULL);
            CBaseAllocator::NextSample(pSample) = m_List;
            m_List = pSample;
            m_nOnList++;
        };
        CMediaSample *RemoveHead()
        {
            CMediaSample *pSample = m_List;
            if (pSample != NULL) {
                m_List = CBaseAllocator::NextSample(m_List);
                m_nOnList--;
            }
            return pSample;
        };
        void Remove(CMediaSample *pSample);

    public:
        CMediaSample *m_List;
        int           m_nOnList;
    };
protected:

    CSampleList m_lFree;        // Free list

    /*  Note to overriders of CBaseAllocator.

        We use a lazy signalling mechanism for waiting for samples.
        This means we don't call the OS if no waits occur.

        In order to implement this:

        1. When a new sample is added to m_lFree call NotifySample() which
           calls ReleaseSemaphore on m_hSem with a count of m_lWaiting and
           sets m_lWaiting to 0.
           This must all be done holding the allocator's critical section.

        2. When waiting for a sample call SetWaiting() which increments
           m_lWaiting BEFORE leaving the allocator's critical section.

        3. Actually wait by calling WaitForSingleObject(m_hSem, INFINITE)
           having left the allocator's critical section.  The effect of
           this is to remove 1 from the semaphore's count.  You MUST call
           this once having incremented m_lWaiting.

        The following are then true when the critical section is not held :
            (let nWaiting = number about to wait or waiting)

            (1) if (m_lFree.GetCount() != 0) then (m_lWaiting == 0)
            (2) m_lWaiting + Semaphore count == nWaiting

        We would deadlock if
           nWaiting != 0 &&
           m_lFree.GetCount() != 0 &&
           Semaphore count == 0

           But from (1) if m_lFree.GetCount() != 0 then m_lWaiting == 0 so
           from (2) Semaphore count == nWaiting (which is non-0) so the
           deadlock can't happen.
    */

    HANDLE m_hSem;              // For signalling
    long m_lWaiting;            // Waiting for a free element
    long m_lCount;              // how many buffers we have agreed to provide
    long m_lAllocated;          // how many buffers are currently allocated
    long m_lSize;               // agreed size of each buffer
    long m_lAlignment;          // agreed alignment
    long m_lPrefix;             // agreed prefix (preceeds GetPointer() value)
    BOOL m_bChanged;            // Have the buffer requirements changed

    // if true, we are decommitted and can't allocate memory
    BOOL m_bCommitted;
    // if true, the decommit has happened, but we haven't called Free yet
    // as there are still outstanding buffers
    BOOL m_bDecommitInProgress;

    // called to decommit the memory when the last buffer is freed
    // pure virtual - need to override this
    virtual void Free(void) PURE;

    // override to allocate the memory when commit called
    virtual HRESULT Alloc(void);

public:

    CBaseAllocator(TCHAR *, LPUNKNOWN, HRESULT *, BOOL bEvent = TRUE);
    virtual ~CBaseAllocator();

    DECLARE_IUNKNOWN

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    STDMETHODIMP SetProperties(
		    ALLOCATOR_PROPERTIES* pRequest,
		    ALLOCATOR_PROPERTIES* pActual);

    // return the properties actually being used on this allocator
    STDMETHODIMP GetProperties(
		    ALLOCATOR_PROPERTIES* pProps);

    // override Commit to allocate memory. We handle the GetBuffer
    //state changes
    STDMETHODIMP Commit();

    // override this to handle the memory freeing. We handle any outstanding
    // GetBuffer calls
    STDMETHODIMP Decommit();

    // get container for a sample. Blocking, synchronous call to get the
    // next free buffer (as represented by an IMediaSample interface).
    // on return, the time etc properties will be invalid, but the buffer
    // pointer and size will be correct. The two time parameters are
    // optional and either may be NULL, they may alternatively be set to
    // the start and end times the sample will have attached to it
    // bPrevFramesSkipped is not used (used only by the video renderer's
    // allocator where it affects quality management in direct draw).

    STDMETHODIMP GetBuffer(IMediaSample **ppBuffer,
                           REFERENCE_TIME * pStartTime,
                           REFERENCE_TIME * pEndTime,
                           DWORD dwFlags);

    // final release of a CMediaSample will call this
    STDMETHODIMP ReleaseBuffer(IMediaSample *pBuffer);
    // obsolete:: virtual void PutOnFreeList(CMediaSample * pSample);

    // Notify that a sample is available
    void NotifySample();

    // Notify that we're waiting for a sample
    void SetWaiting() { m_lWaiting++; };
};


//=====================================================================
//=====================================================================
// Defines CMemAllocator
//
// this is an allocator based on CBaseAllocator that allocates sample
// buffers in main memory (from 'new'). You must call SetProperties
// before calling Commit.
//
// we don't free the memory when going into Decommit state. The simplest
// way to implement this without complicating CBaseAllocator is to
// have a Free() function, called to go into decommit state, that does
// nothing and a ReallyFree function called from our destructor that
// actually frees the memory.
//=====================================================================
//=====================================================================

//  Make me one from quartz.dll
STDAPI CreateMemoryAllocator(IMemAllocator **ppAllocator);

class CMemAllocator : public CBaseAllocator
{

protected:

    LPBYTE m_pBuffer;   // combined memory for all buffers

    // override to free the memory when decommit completes
    // - we actually do nothing, and save the memory until deletion.
    void Free(void);

    // called from the destructor (and from Alloc if changing size/count) to
    // actually free up the memory
    void ReallyFree(void);

    // overriden to allocate the memory when commit called
    HRESULT Alloc(void);

public:
    /* This goes in the factory template table to create new instances */
    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    STDMETHODIMP SetProperties(
		    ALLOCATOR_PROPERTIES* pRequest,
		    ALLOCATOR_PROPERTIES* pActual);

    CMemAllocator(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CMemAllocator();
};

// helper used by IAMovieSetup implementation
STDAPI
AMovieSetupRegisterFilter( const AMOVIESETUP_FILTER * const psetupdata
                         , IFilterMapper *                  pIFM
                         , BOOL                             bRegister  );


#endif /* __FILTER__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\amvideo.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Helper functions for bitmap formats, March 1995

#include <streams.h>
#include <limits.h>

// These are bit field masks for true colour devices

const DWORD bits555[] = {0x007C00,0x0003E0,0x00001F};
const DWORD bits565[] = {0x00F800,0x0007E0,0x00001F};
const DWORD bits888[] = {0xFF0000,0x00FF00,0x0000FF};

// This maps bitmap subtypes into a bits per pixel value and also a name

const struct {
    const GUID *pSubtype;
    WORD BitCount;
    TCHAR *pName;
} BitCountMap[] = { &MEDIASUBTYPE_RGB1,        1,   TEXT("RGB Monochrome"),
                    &MEDIASUBTYPE_RGB4,        4,   TEXT("RGB VGA"),
                    &MEDIASUBTYPE_RGB8,        8,   TEXT("RGB 8"),
                    &MEDIASUBTYPE_RGB565,      16,  TEXT("RGB 565 (16 bit)"),
                    &MEDIASUBTYPE_RGB555,      16,  TEXT("RGB 555 (16 bit)"),
                    &MEDIASUBTYPE_RGB24,       24,  TEXT("RGB 24"),
                    &MEDIASUBTYPE_RGB32,       32,  TEXT("RGB 32"),
                    &MEDIASUBTYPE_Overlay,     0,   TEXT("Overlay"),
                    &GUID_NULL,                0,   TEXT("UNKNOWN") };


// Return the size of the bitmap as defined by this header

STDAPI_(DWORD) GetBitmapSize(const BITMAPINFOHEADER *pHeader)
{
    return DIBSIZE(*pHeader);
}


// This is called if the header has a 16 bit colour depth and needs to work
// out the detailed type from the bit fields (either RGB 565 or RGB 555)

STDAPI_(const GUID) GetTrueColorType(const BITMAPINFOHEADER *pbmiHeader)
{
    BITMAPINFO *pbmInfo = (BITMAPINFO *) pbmiHeader;
    ASSERT(pbmiHeader->biBitCount == 16);

    // If its BI_RGB then it's RGB 555 by default

    if (pbmiHeader->biCompression == BI_RGB) {
        return MEDIASUBTYPE_RGB555;
    }

    // Compare the bit fields with RGB 555

    DWORD *pMask = (DWORD *) pbmInfo->bmiColors;
    if (pMask[0] == bits555[0]) {
        if (pMask[1] == bits555[1]) {
            if (pMask[2] == bits555[2]) {
                return MEDIASUBTYPE_RGB555;
            }
        }
    }

    // Compare the bit fields with RGB 565

    pMask = (DWORD *) pbmInfo->bmiColors;
    if (pMask[0] == bits565[0]) {
        if (pMask[1] == bits565[1]) {
            if (pMask[2] == bits565[2]) {
                return MEDIASUBTYPE_RGB565;
            }
        }
    }
    return GUID_NULL;
}


// Given a BITMAPINFOHEADER structure this returns the GUID sub type that is
// used to describe it in format negotiations. For example a video codec fills
// in the format block with a VIDEOINFO structure, it also fills in the major
// type with MEDIATYPE_VIDEO and the subtype with a GUID that matches the bit
// count, for example if it is an eight bit image then MEDIASUBTYPE_RGB8

STDAPI_(const GUID) GetBitmapSubtype(const BITMAPINFOHEADER *pbmiHeader)
{
    ASSERT(pbmiHeader);

    // If it's not RGB then create a GUID from the compression type

    if (pbmiHeader->biCompression != BI_RGB) {
        if (pbmiHeader->biCompression != BI_BITFIELDS) {
            FOURCCMap FourCCMap(pbmiHeader->biCompression);
            return (const GUID) FourCCMap;
        }
    }

    // Map the RGB DIB bit depth to a image GUID

    switch(pbmiHeader->biBitCount) {
        case 1    :   return MEDIASUBTYPE_RGB1;
        case 4    :   return MEDIASUBTYPE_RGB4;
        case 8    :   return MEDIASUBTYPE_RGB8;
        case 16   :   return GetTrueColorType(pbmiHeader);
        case 24   :   return MEDIASUBTYPE_RGB24;
        case 32   :   return MEDIASUBTYPE_RGB32;
    }
    return GUID_NULL;
}


// Given a video bitmap subtype we return the number of bits per pixel it uses
// We return a WORD bit count as thats what the BITMAPINFOHEADER uses. If the
// GUID subtype is not found in the table we return an invalid USHRT_MAX

STDAPI_(WORD) GetBitCount(const GUID *pSubtype)
{
    ASSERT(pSubtype);
    const GUID *pMediaSubtype;
    INT iPosition = 0;

    // Scan the mapping list seeing if the source GUID matches any known
    // bitmap subtypes, the list is terminated by a GUID_NULL entry

    while (TRUE) {
        pMediaSubtype = BitCountMap[iPosition].pSubtype;
        if (IsEqualGUID(*pMediaSubtype,GUID_NULL)) {
            return USHRT_MAX;
        }
        if (IsEqualGUID(*pMediaSubtype,*pSubtype)) {
            return BitCountMap[iPosition].BitCount;
        }
        iPosition++;
    }
}


// Given a bitmap subtype we return a description name that can be used for
// debug purposes. In a retail build this function still returns the names
// If the subtype isn't found in the lookup table we return string UNKNOWN

STDAPI_(TCHAR *) GetSubtypeName(const GUID *pSubtype)
{
    ASSERT(pSubtype);
    const GUID *pMediaSubtype;
    INT iPosition = 0;

    // Scan the mapping list seeing if the source GUID matches any known
    // bitmap subtypes, the list is terminated by a GUID_NULL entry

    while (TRUE) {
        pMediaSubtype = BitCountMap[iPosition].pSubtype;
        if (IsEqualGUID(*pMediaSubtype,*pSubtype)) {
            return BitCountMap[iPosition].pName;
        }
        if (IsEqualGUID(*pMediaSubtype,GUID_NULL)) {
            return TEXT("UNKNOWN");
        }
        iPosition++;
    }
}


// The mechanism for describing a bitmap format is with the BITMAPINFOHEADER
// This is really messy to deal with because it invariably has fields that
// follow it holding bit fields, palettes and the rest. This function gives
// the number of bytes required to hold a VIDEOINFO that represents it. This
// count includes the prefix information (like the rcSource rectangle) the
// BITMAPINFOHEADER field, and any other colour information on the end.
//
// WARNING If you want to copy a BITMAPINFOHEADER into a VIDEOINFO always make
// sure that you use the HEADER macro because the BITMAPINFOHEADER field isn't
// right at the start of the VIDEOINFO (there are a number of other fields),
//
//     CopyMemory(HEADER(pVideoInfo),pbmi,sizeof(BITMAPINFOHEADER));
//

STDAPI_(LONG) GetBitmapFormatSize(const BITMAPINFOHEADER *pHeader)
{
    // Everyone has this to start with this  
    LONG Size = SIZE_PREHEADER + pHeader->biSize;

    ASSERT(pHeader->biSize >= sizeof(BITMAPINFOHEADER));
    
    // Does this format use a palette, if the number of colours actually used
    // is zero then it is set to the maximum that are allowed for that colour
    // depth (an example is 256 for eight bits). Truecolour formats may also
    // pass a palette with them in which case the used count is non zero

    // This would scare me.
    ASSERT(pHeader->biBitCount <= iPALETTE || pHeader->biClrUsed == 0);

    if (pHeader->biBitCount <= iPALETTE || pHeader->biClrUsed) {
        LONG Entries = (DWORD) 1 << pHeader->biBitCount;
        if (pHeader->biClrUsed) {
            Entries = pHeader->biClrUsed;
        }
        Size += Entries * sizeof(RGBQUAD);
    }

    // Truecolour formats may have a BI_BITFIELDS specifier for compression
    // type which means that room for three DWORDs should be allocated that
    // specify where in each pixel the RGB colour components may be found

    if (pHeader->biCompression == BI_BITFIELDS) {
        Size += SIZE_MASKS;
    }

    // A BITMAPINFO for a palettised image may also contain a palette map that
    // provides the information to map from a source palette to a destination
    // palette during a BitBlt for example, because this information is only
    // ever processed during drawing you don't normally store the palette map
    // nor have any way of knowing if it is present in the data structure

    return Size;
}


// Returns TRUE if the VIDEOINFO contains a palette

STDAPI_(BOOL) ContainsPalette(const VIDEOINFOHEADER *pVideoInfo)
{
    if (PALETTISED(pVideoInfo) == FALSE) {
        if (pVideoInfo->bmiHeader.biClrUsed == 0) {
            return FALSE;
        }
    }
    return TRUE;
}


// Return a pointer to the first entry in a palette

STDAPI_(const RGBQUAD *) GetBitmapPalette(const VIDEOINFOHEADER *pVideoInfo)
{
    if (pVideoInfo->bmiHeader.biCompression == BI_BITFIELDS) {
        return TRUECOLOR(pVideoInfo)->bmiColors;
    }
    return COLORS(pVideoInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\amfilter.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Base class hierachy for streams architecture, December 1994

//=====================================================================
//=====================================================================
// The following classes are declared in this header:
//
//
// CBaseMediaFilter            Basic IMediaFilter support (abstract class)
// CBaseFilter                 Support for IBaseFilter (incl. IMediaFilter)
// CEnumPins                   Enumerate input and output pins
// CEnumMediaTypes             Enumerate the preferred pin formats
// CBasePin                    Abstract base class for IPin interface
//    CBaseOutputPin           Adds data provider member functions
//    CBaseInputPin            Implements IMemInputPin interface
// CMediaSample                Basic transport unit for IMemInputPin
// CBaseAllocator              General list guff for most allocators
//    CMemAllocator            Implements memory buffer allocation
//
//=====================================================================
//=====================================================================

#include <streams.h>

//=====================================================================
// Helpers
//=====================================================================
STDAPI CreateMemoryAllocator(IMemAllocator **ppAllocator)
{
    return CoCreateInstance(CLSID_MemoryAllocator,
                            0,
                            CLSCTX_INPROC_SERVER,
                            IID_IMemAllocator,
                            (void **)ppAllocator);
}

//  Put this one here rather than in ctlutil.cpp to avoid linking
//  anything brought in by ctlutil.cpp
STDAPI CreatePosPassThru(
    LPUNKNOWN pAgg,
    BOOL bRenderer,
    IPin *pPin,
    IUnknown **ppPassThru
)
{
    *ppPassThru = NULL;
    IUnknown *pUnkSeek;
    HRESULT hr = CoCreateInstance(CLSID_SeekingPassThru,
                                  pAgg,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IUnknown,
                                  (void **)&pUnkSeek
                                 );
    if (FAILED(hr)) {
        return hr;
    }

    ISeekingPassThru *pPassThru;
    hr = pUnkSeek->QueryInterface(IID_ISeekingPassThru, (void**)&pPassThru);
    if (FAILED(hr)) {
        pUnkSeek->Release();
        return hr;
    }
    hr = pPassThru->Init(bRenderer, pPin);
    pPassThru->Release();
    if (FAILED(hr)) {
        pUnkSeek->Release();
        return hr;
    }
    *ppPassThru = pUnkSeek;
    return S_OK;
}

#define CONNECT_TRACE_LEVEL 3

//=====================================================================
//=====================================================================
// Implements CBaseMediaFilter
//=====================================================================
//=====================================================================


/* Constructor */

CBaseMediaFilter::CBaseMediaFilter(const TCHAR	*pName,
				   LPUNKNOWN	pUnk,
				   CCritSec	*pLock,
				   REFCLSID	clsid) :
    CUnknown(pName, pUnk),
    m_pLock(pLock),
    m_clsid(clsid),
    m_State(State_Stopped),
    m_pClock(NULL)
{
}


/* Destructor */

CBaseMediaFilter::~CBaseMediaFilter()
{
    // must be stopped, but can't call Stop here since
    // our critsec has been destroyed.

    /* Release any clock we were using */

    if (m_pClock) {
	m_pClock->Release();
	m_pClock = NULL;
    }
}


/* Override this to say what interfaces we support and where */

STDMETHODIMP
CBaseMediaFilter::NonDelegatingQueryInterface(
    REFIID riid,
    void ** ppv)
{
    if (riid == IID_IMediaFilter) {
	    return GetInterface((IMediaFilter *) this, ppv);
    } else if (riid == IID_IPersist) {
	    return GetInterface((IPersist *) this, ppv);
    } else {
	    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}

/* Return the filter's clsid */
STDMETHODIMP
CBaseMediaFilter::GetClassID(CLSID *pClsID)
{
    CheckPointer(pClsID,E_POINTER);
    ValidateReadWritePtr(pClsID,sizeof(CLSID));
    *pClsID = m_clsid;
    return NOERROR;
}

/* Override this if your state changes are not done synchronously */

STDMETHODIMP
CBaseMediaFilter::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    UNREFERENCED_PARAMETER(dwMSecs);
    CheckPointer(State,E_POINTER);
    ValidateReadWritePtr(State,sizeof(FILTER_STATE));

    *State = m_State;
    return S_OK;
}


/* Set the clock we will use for synchronisation */

STDMETHODIMP
CBaseMediaFilter::SetSyncSource(IReferenceClock *pClock)
{
    CAutoLock cObjectLock(m_pLock);

    // Ensure the new one does not go away - even if the same as the old
    if (pClock) {
	pClock->AddRef();
    }

    // if we have a clock, release it
    if (m_pClock) {
	m_pClock->Release();
    }

    // Set the new reference clock (might be NULL)
    // Should we query it to ensure it is a clock?  Consider for a debug build.
    m_pClock = pClock;

    return NOERROR;
}

/* Return the clock we are using for synchronisation */
STDMETHODIMP
CBaseMediaFilter::GetSyncSource(IReferenceClock **pClock)
{
    CheckPointer(pClock,E_POINTER);
    ValidateReadWritePtr(pClock,sizeof(IReferenceClock *));
    CAutoLock cObjectLock(m_pLock);

    if (m_pClock) {
	// returning an interface... addref it...
	m_pClock->AddRef();
    }
    *pClock = (IReferenceClock*)m_pClock;
    return NOERROR;
}


/* Put the filter into a stopped state */

STDMETHODIMP
CBaseMediaFilter::Stop()
{
    CAutoLock cObjectLock(m_pLock);

    m_State = State_Stopped;
    return S_OK;
}


/* Put the filter into a paused state */

STDMETHODIMP
CBaseMediaFilter::Pause()
{
    CAutoLock cObjectLock(m_pLock);

    m_State = State_Paused;
    return S_OK;
}


// Put the filter into a running state.

// The time parameter is the offset to be added to the samples'
// stream time to get the reference time at which they should be presented.
//
// you can either add these two and compare it against the reference clock,
// or you can call CBaseMediaFilter::StreamTime and compare that against
// the sample timestamp.

STDMETHODIMP
CBaseMediaFilter::Run(REFERENCE_TIME tStart)
{
    CAutoLock cObjectLock(m_pLock);

    // remember the stream time offset
    m_tStart = tStart;

    if (m_State == State_Stopped){
	HRESULT hr = Pause();

	if (FAILED(hr)) {
	    return hr;
	}
    }
    m_State = State_Running;
    return S_OK;
}


//
// return the current stream time - samples with start timestamps of this
// time or before should be rendered by now
HRESULT
CBaseMediaFilter::StreamTime(CRefTime& rtStream)
{
    // Caller must lock for synchronization
    // We can't grab the filter lock because we want to be able to call
    // this from worker threads without deadlocking

    if (m_pClock == NULL) {
	return VFW_E_NO_CLOCK;
    }

    // get the current reference time
    HRESULT hr = m_pClock->GetTime((REFERENCE_TIME*)&rtStream);
    if (FAILED(hr)) {
	return hr;
    }

    // subtract the stream offset to get stream time
    rtStream -= m_tStart;

    return S_OK;
}


//=====================================================================
//=====================================================================
// Implements CBaseFilter
//=====================================================================
//=====================================================================


/* Override this to say what interfaces we support and where */

STDMETHODIMP CBaseFilter::NonDelegatingQueryInterface(REFIID riid,
                                                      void **ppv)
{
    /* Do we have this interface */

    if (riid == IID_IBaseFilter) {
	return GetInterface((IBaseFilter *) this, ppv);
    } else if (riid == IID_IMediaFilter) {
	return GetInterface((IMediaFilter *) this, ppv);
    } else if (riid == IID_IPersist) {
	return GetInterface((IPersist *) this, ppv);
    } else if (riid == IID_IAMovieSetup) {
	return GetInterface((IAMovieSetup *) this, ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}

#ifdef DEBUG
STDMETHODIMP_(ULONG) CBaseFilter::NonDelegatingRelease()
{
    if (m_cRef == 1) {
        KASSERT(m_pGraph == NULL);
    }
    return CUnknown::NonDelegatingRelease();
}
#endif


/* Constructor */

CBaseFilter::CBaseFilter(const TCHAR	*pName,
			 LPUNKNOWN	pUnk,
			 CCritSec	*pLock,
			 REFCLSID	clsid) :
    CUnknown( pName, pUnk ),
    m_pLock(pLock),
    m_clsid(clsid),
    m_State(State_Stopped),
    m_pClock(NULL),
    m_pGraph(NULL),
    m_pSink(NULL),
    m_pName(NULL),
    m_PinVersion(1)
{
    ASSERT(pLock != NULL);
}

/* Passes in a redundant HRESULT argument */

CBaseFilter::CBaseFilter(TCHAR     *pName,
                         LPUNKNOWN  pUnk,
                         CCritSec  *pLock,
                         REFCLSID   clsid,
                         HRESULT   *phr) :
    CUnknown( pName, pUnk ),
    m_pLock(pLock),
    m_clsid(clsid),
    m_State(State_Stopped),
    m_pClock(NULL),
    m_pGraph(NULL),
    m_pSink(NULL),
    m_pName(NULL),
    m_PinVersion(1)
{
    ASSERT(pLock != NULL);
    UNREFERENCED_PARAMETER(phr);
}


/* Destructor */

CBaseFilter::~CBaseFilter()
{
// NOTE we do NOT hold references on the filtergraph for m_pGraph or m_pSink
// When we did we had the circular reference problem.  Nothing would go away.

    if (m_pName)
	delete[] m_pName;

    // must be stopped, but can't call Stop here since
    // our critsec has been destroyed.

    /* Release any clock we were using */
    if (m_pClock) {
	m_pClock->Release();
	m_pClock = NULL;
    }
}

/* Return the filter's clsid */
STDMETHODIMP
CBaseFilter::GetClassID(CLSID *pClsID)
{
    CheckPointer(pClsID,E_POINTER);
    ValidateReadWritePtr(pClsID,sizeof(CLSID));
    *pClsID = m_clsid;
    return NOERROR;
}

/* Override this if your state changes are not done synchronously */
STDMETHODIMP
CBaseFilter::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    UNREFERENCED_PARAMETER(dwMSecs);
    CheckPointer(State,E_POINTER);
    ValidateReadWritePtr(State,sizeof(FILTER_STATE));

    *State = m_State;
    return S_OK;
}


/* Set the clock we will use for synchronisation */

STDMETHODIMP
CBaseFilter::SetSyncSource(IReferenceClock *pClock)
{
    CAutoLock cObjectLock(m_pLock);

    // Ensure the new one does not go away - even if the same as the old
    if (pClock) {
	pClock->AddRef();
    }

    // if we have a clock, release it
    if (m_pClock) {
	m_pClock->Release();
    }

    // Set the new reference clock (might be NULL)
    // Should we query it to ensure it is a clock?  Consider for a debug build.
    m_pClock = pClock;

    return NOERROR;
}

/* Return the clock we are using for synchronisation */
STDMETHODIMP
CBaseFilter::GetSyncSource(IReferenceClock **pClock)
{
    CheckPointer(pClock,E_POINTER);
    ValidateReadWritePtr(pClock,sizeof(IReferenceClock *));
    CAutoLock cObjectLock(m_pLock);

    if (m_pClock) {
	// returning an interface... addref it...
	m_pClock->AddRef();
    }
    *pClock = (IReferenceClock*)m_pClock;
    return NOERROR;
}



// override CBaseMediaFilter Stop method, to deactivate any pins this
// filter has.
STDMETHODIMP
CBaseFilter::Stop()
{
    CAutoLock cObjectLock(m_pLock);
    HRESULT hr = NOERROR;

    // notify all pins of the state change
    if (m_State != State_Stopped) {
	int cPins = GetPinCount();
	for (int c = 0; c < cPins; c++) {

	    CBasePin *pPin = GetPin(c);

            // Disconnected pins are not activated - this saves pins worrying
            // about this state themselves. We ignore the return code to make
            // sure everyone is inactivated regardless. The base input pin
            // class can return an error if it has no allocator but Stop can
            // be used to resync the graph state after something has gone bad

            if (pPin->IsConnected()) {
                HRESULT hrTmp = pPin->Inactive();
                if (FAILED(hrTmp) && SUCCEEDED(hr)) {
                    hr = hrTmp;
                }
            }
	}
    }
    m_State = State_Stopped;
    return hr;
}


// override CBaseMediaFilter Pause method to activate any pins
// this filter has (also called from Run)

STDMETHODIMP
CBaseFilter::Pause()
{
    CAutoLock cObjectLock(m_pLock);

    // notify all pins of the change to active state
    if (m_State == State_Stopped) {
	int cPins = GetPinCount();
	for (int c = 0; c < cPins; c++) {

	    CBasePin *pPin = GetPin(c);

            // Disconnected pins are not activated - this saves pins
            // worrying about this state themselves

            if (pPin->IsConnected()) {
	        HRESULT hr = pPin->Active();
	        if (FAILED(hr)) {
		    return hr;
	        }
            }
	}
    }
    m_State = State_Paused;
    return S_OK;
}

// Put the filter into a running state.

// The time parameter is the offset to be added to the samples'
// stream time to get the reference time at which they should be presented.
//
// you can either add these two and compare it against the reference clock,
// or you can call CBaseFilter::StreamTime and compare that against
// the sample timestamp.

STDMETHODIMP
CBaseFilter::Run(REFERENCE_TIME tStart)
{
    CAutoLock cObjectLock(m_pLock);

    // remember the stream time offset
    m_tStart = tStart;

    if (m_State == State_Stopped){
	HRESULT hr = Pause();

	if (FAILED(hr)) {
	    return hr;
	}
    }
    // notify all pins of the change to active state
    if (m_State != State_Running) {
	int cPins = GetPinCount();
	for (int c = 0; c < cPins; c++) {

	    CBasePin *pPin = GetPin(c);

            // Disconnected pins are not activated - this saves pins
            // worrying about this state themselves

            if (pPin->IsConnected()) {
	        HRESULT hr = pPin->Run(tStart);
	        if (FAILED(hr)) {
		    return hr;
	        }
            }
	}
    }
    m_State = State_Running;
    return S_OK;
}

//
// return the current stream time - samples with start timestamps of this
// time or before should be rendered by now
HRESULT
CBaseFilter::StreamTime(CRefTime& rtStream)
{
    // Caller must lock for synchronization
    // We can't grab the filter lock because we want to be able to call
    // this from worker threads without deadlocking

    if (m_pClock == NULL) {
	return VFW_E_NO_CLOCK;
    }

    // get the current reference time
    HRESULT hr = m_pClock->GetTime((REFERENCE_TIME*)&rtStream);
    if (FAILED(hr)) {
	return hr;
    }

    // subtract the stream offset to get stream time
    rtStream -= m_tStart;

    return S_OK;
}


/* Create an enumerator for the pins attached to this filter */

STDMETHODIMP
CBaseFilter::EnumPins(IEnumPins **ppEnum)
{
    CheckPointer(ppEnum,E_POINTER);
    ValidateReadWritePtr(ppEnum,sizeof(IEnumPins *));

    /* Create a new ref counted enumerator */

    *ppEnum = new CEnumPins(this,
	                    NULL);

    return *ppEnum == NULL ? E_OUTOFMEMORY : NOERROR;
}


// default behaviour of FindPin is to assume pins are named
// by their pin names
STDMETHODIMP
CBaseFilter::FindPin(
    LPCWSTR Id,
    IPin ** ppPin
)
{
    CheckPointer(ppPin,E_POINTER);
    ValidateReadWritePtr(ppPin,sizeof(IPin *));

    //  We're going to search the pin list so maintain integrity
    CAutoLock lck(m_pLock);
    int iCount = GetPinCount();
    for (int i = 0; i < iCount; i++) {
        CBasePin *pPin = GetPin(i);
        ASSERT(pPin != NULL);

        if (0 == lstrcmpW(pPin->Name(), Id)) {
            //  Found one that matches
            //
            //  AddRef() and return it
            *ppPin = pPin;
            pPin->AddRef();
            return S_OK;
        }
    }
    *ppPin = NULL;
    return VFW_E_NOT_FOUND;
}

/* Return information about this filter */

STDMETHODIMP
CBaseFilter::QueryFilterInfo(FILTER_INFO * pInfo)
{
    CheckPointer(pInfo,E_POINTER);
    ValidateReadWritePtr(pInfo,sizeof(FILTER_INFO));

    if (m_pName) {
    	lstrcpynW(pInfo->achName, m_pName, sizeof(pInfo->achName)/sizeof(WCHAR));
    } else {
	pInfo->achName[0] = L'\0';
    }
    pInfo->pGraph = m_pGraph;
    if (m_pGraph)
	m_pGraph->AddRef();
    return NOERROR;
}


/* Provide the filter with a filter graph */

STDMETHODIMP
CBaseFilter::JoinFilterGraph(
    IFilterGraph * pGraph,
    LPCWSTR pName)
{
    CAutoLock cObjectLock(m_pLock);

    // NOTE: we no longer hold references on the graph (m_pGraph, m_pSink)

    m_pGraph = pGraph;
    if (m_pGraph) {
	HRESULT hr = m_pGraph->QueryInterface(IID_IMediaEventSink,
					(void**) &m_pSink);
	if (FAILED(hr)) {
	    ASSERT(m_pSink == NULL);
	}
        else m_pSink->Release();        // we do NOT keep a reference on it.
    } else {
        // if graph pointer is null, then we should
        // also release the IMediaEventSink on the same object - we don't
        // refcount it, so just set it to null
        m_pSink = NULL;
    }


    if (m_pName) {
        delete[] m_pName;
	m_pName = NULL;
    }

    if (pName) {
	DWORD nameLen = lstrlenW(pName)+1;
	m_pName = new WCHAR[nameLen];
	if (m_pName) {
	    CopyMemory(m_pName, pName, nameLen*sizeof(WCHAR));
	} else {
	    // !!! error here?
	}
    }
    return NOERROR;
}


// return a Vendor information string. Optional - may return E_NOTIMPL.
// memory returned should be freed using CoTaskMemFree
// default implementation returns E_NOTIMPL
STDMETHODIMP
CBaseFilter::QueryVendorInfo(
    LPWSTR* pVendorInfo)
{
    UNREFERENCED_PARAMETER(pVendorInfo);
    return E_NOTIMPL;
}


// send an event notification to the filter graph if we know about it.
// returns S_OK if delivered, S_FALSE if the filter graph does not sink
// events, or an error otherwise.
HRESULT
CBaseFilter::NotifyEvent(
    long EventCode,
    LONG_PTR EventParam1,
    LONG_PTR EventParam2)
{
    // Snapshot so we don't have to lock up
    IMediaEventSink *pSink = m_pSink;
    if (pSink) {
	return pSink->Notify(EventCode, EventParam1, EventParam2);
    } else {
	return E_NOTIMPL;
    }
}

// Request reconnect
// pPin is the pin to reconnect
// pmt is the type to reconnect with - can be NULL
// Calls ReconnectEx on the filter graph
HRESULT
CBaseFilter::ReconnectPin(
    IPin *pPin,
    AM_MEDIA_TYPE const *pmt
)
{
    IFilterGraph2 *pGraph2;
    if (m_pGraph != NULL) {
        HRESULT hr = m_pGraph->QueryInterface(IID_IFilterGraph2, (void **)&pGraph2);
        if (SUCCEEDED(hr)) {
            hr = pGraph2->ReconnectEx(pPin, pmt);
            pGraph2->Release();
            return hr;
        } else {
            return m_pGraph->Reconnect(pPin);
        }
    } else {
        return E_NOINTERFACE;
    }
}



/* This is the same idea as the media type version does for type enumeration
   on pins but for the list of pins available. So if the list of pins you
   provide changes dynamically then either override this virtual function
   to provide the version number, or more simply call IncrementPinVersion */

LONG CBaseFilter::GetPinVersion()
{
    return m_PinVersion;
}


/* Increment the current pin version cookie */

void CBaseFilter::IncrementPinVersion()
{
    InterlockedIncrement(&m_PinVersion);
}

/* register filter */

STDMETHODIMP CBaseFilter::Register()
{
    // get setup data, if it exists
    //
    LPAMOVIESETUP_FILTER psetupdata = GetSetupData();

    // check we've got data
    //
    if( NULL == psetupdata ) return S_FALSE;

    // init is ref counted so call just in case
    // we're being called cold.
    //
    HRESULT hr = CoInitialize( (LPVOID)NULL );
    ASSERT( SUCCEEDED(hr) );

    // get hold of IFilterMapper
    //
    IFilterMapper *pIFM;
    hr = CoCreateInstance( CLSID_FilterMapper
                             , NULL
                             , CLSCTX_INPROC_SERVER
                             , IID_IFilterMapper
                             , (void **)&pIFM       );
    if( SUCCEEDED(hr) )
    {
        hr = AMovieSetupRegisterFilter( psetupdata, pIFM, TRUE );
        pIFM->Release();
    }

    // and clear up
    //
    CoFreeUnusedLibraries();
    CoUninitialize();

    return NOERROR;
}


/* unregister filter */

STDMETHODIMP CBaseFilter::Unregister()
{
    // get setup data, if it exists
    //
    LPAMOVIESETUP_FILTER psetupdata = GetSetupData();

    // check we've got data
    //
    if( NULL == psetupdata ) return S_FALSE;

    // OLE init is ref counted so call
    // just in case we're being called cold.
    //
    HRESULT hr = CoInitialize( (LPVOID)NULL );
    ASSERT( SUCCEEDED(hr) );

    // get hold of IFilterMapper
    //
    IFilterMapper *pIFM;
    hr = CoCreateInstance( CLSID_FilterMapper
                             , NULL
                             , CLSCTX_INPROC_SERVER
                             , IID_IFilterMapper
                             , (void **)&pIFM       );
    if( SUCCEEDED(hr) )
    {
        hr = AMovieSetupRegisterFilter( psetupdata, pIFM, FALSE );

        // release interface
        //
        pIFM->Release();
    }

    // clear up
    //
    CoFreeUnusedLibraries();
    CoUninitialize();

    // handle one acceptable "error" - that
    // of filter not being registered!
    // (couldn't find a suitable #define'd
    // name for the error!)
    //
    if( 0x80070002 == hr)
      return NOERROR;
    else
      return hr;
}


//=====================================================================
//=====================================================================
// Implements CEnumPins
//=====================================================================
//=====================================================================


/* NOTE The implementation of this class calls the CUnknown constructor
   with a NULL unknown pointer. This has the effect of making us a self
   contained class, ie any QueryInterface, AddRef or Release calls will be
   routed to the class's NonDelegatingUnknown methods. You will typically
   find that the classes that do this then override one or more of these
   virtual functions to provide more specialised behaviour. A good example
   of this is where a class wants to keep the QueryInterface internal but
   still wants it's lifetime controlled by the external object */

CEnumPins::CEnumPins(CBaseFilter *pFilter,
		     CEnumPins *pEnumPins) :
    m_Position(0),
    m_PinCount(0),
    m_pFilter(pFilter),
    m_cRef(1),               // Already ref counted
    m_PinCache(NAME("Pin Cache"))
{

#ifdef DEBUG
    m_dwCookie = DbgRegisterObjectCreation(TEXT("CEnumPins"));
#endif

    /* We must be owned by a filter derived from CBaseFilter */

    ASSERT(pFilter != NULL);

    /* Hold a reference count on our filter */
    m_pFilter->AddRef();

    /* Are we creating a new enumerator */

    if (pEnumPins == NULL) {
	m_Version = m_pFilter->GetPinVersion();
	m_PinCount = m_pFilter->GetPinCount();
    } else {
        ASSERT(m_Position <= m_PinCount);
        m_Position = pEnumPins->m_Position;
        m_PinCount = pEnumPins->m_PinCount;
        m_Version = pEnumPins->m_Version;
	m_PinCache.AddTail(&(pEnumPins->m_PinCache));
    }
}


/* Destructor releases the reference count on our filter NOTE since we hold
   a reference count on the filter who created us we know it is safe to
   release it, no access can be made to it afterwards though as we have just
   caused the last reference count to go and the object to be deleted */

CEnumPins::~CEnumPins()
{
    m_pFilter->Release();

#ifdef DEBUG
    DbgRegisterObjectDestruction(m_dwCookie);
#endif
}


/* Override this to say what interfaces we support where */

STDMETHODIMP
CEnumPins::QueryInterface(REFIID riid,void **ppv)
{
    CheckPointer(ppv, E_POINTER);

    /* Do we have this interface */

    if (riid == IID_IEnumPins || riid == IID_IUnknown) {
	return GetInterface((IEnumPins *) this, ppv);
    } else {
	return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
CEnumPins::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CEnumPins::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if (cRef == 0) {
        delete this;
    }
    return cRef;
}

/* One of an enumerator's basic member functions allows us to create a cloned
   interface that initially has the same state. Since we are taking a snapshot
   of an object (current position and all) we must lock access at the start */

STDMETHODIMP
CEnumPins::Clone(IEnumPins **ppEnum)
{
    CheckPointer(ppEnum,E_POINTER);
    ValidateReadWritePtr(ppEnum,sizeof(IEnumPins *));
    HRESULT hr = NOERROR;

    /* Check we are still in sync with the filter */
    if (AreWeOutOfSync() == TRUE) {
        *ppEnum = NULL;
        hr =  VFW_E_ENUM_OUT_OF_SYNC;
    } else {

        *ppEnum = new CEnumPins(m_pFilter,
    	                        this);
        if (*ppEnum == NULL) {
    	    hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}


/* Return the next pin after the current position */

STDMETHODIMP
CEnumPins::Next(ULONG cPins,        // place this many pins...
		IPin **ppPins,      // ...in this array
		ULONG *pcFetched)   // actual count passed returned here
{
    CheckPointer(ppPins,E_POINTER);
    ValidateReadWritePtr(ppPins,cPins * sizeof(IPin *));

    ASSERT(ppPins);

    if (pcFetched!=NULL) {
        ValidateWritePtr(pcFetched, sizeof(ULONG));
        *pcFetched = 0;           // default unless we succeed
    }
    // now check that the parameter is valid
    else if (cPins>1) {	  // pcFetched == NULL
        return E_INVALIDARG;
    }
    ULONG cFetched = 0;           // increment as we get each one.

    /* Check we are still in sync with the filter */
    if (AreWeOutOfSync() == TRUE) {
	// If we are out of sync, we should refresh the enumerator.
	// This will reset the position and update the other members, but
	// will not clear cache of pins we have already returned.
	Refresh();
    }

    /* Calculate the number of available pins */

    int cRealPins = min(m_PinCount - m_Position, (int) cPins);
    if (cRealPins == 0) {
	return S_FALSE;
    }

    /* Return each pin interface NOTE GetPin returns CBasePin * not addrefed
       so we must QI for the IPin (which increments its reference count)
       If while we are retrieving a pin from the filter an error occurs we
       assume that our internal state is stale with respect to the filter
       (for example someone has deleted a pin) so we
       return VFW_E_ENUM_OUT_OF_SYNC                            */

    while (cRealPins && (m_PinCount - m_Position)) {

	/* Get the next pin object from the filter */

	CBasePin *pPin = m_pFilter->GetPin(m_Position++);
	if (pPin == NULL) {
            // If this happend, and it's not the first time through, then we've got a problem,
            // since we should really go back and release the iPins, which we have previously
            // AddRef'ed.
            ASSERT( cFetched==0 );
            return VFW_E_ENUM_OUT_OF_SYNC;
	}

	/* We only want to return this pin, if it is not in our cache */
	if (0 == m_PinCache.Find(pPin))
	{
	    /* From the object get an IPin interface */

	    *ppPins = pPin;
	    pPin->AddRef();

	    cFetched++;
	    ppPins++;

	    m_PinCache.AddTail(pPin);

	    cRealPins--;

	}
    }

    if (pcFetched!=NULL) {
        *pcFetched = cFetched;
    }

    return (cPins==cFetched ? NOERROR : S_FALSE);
}


/* Skip over one or more entries in the enumerator */

STDMETHODIMP
CEnumPins::Skip(ULONG cPins)
{
    /* Check we are still in sync with the filter */
    if (AreWeOutOfSync() == TRUE) {
        return VFW_E_ENUM_OUT_OF_SYNC;
    }

    /* Work out how many pins are left to skip over */
    /* We could position at the end if we are asked to skip too many... */
    /* ..which would match the base implementation for CEnumMediaTypes::Skip */

    ULONG PinsLeft = m_PinCount - m_Position;
    if (cPins > PinsLeft) {
	return S_FALSE;
    }
    m_Position += cPins;
    return NOERROR;
}


/* Set the current position back to the start */
/* Reset has 4 simple steps:
 *
 * Set position to head of list
 * Sync enumerator with object being enumerated
 * Clear the cache of pins already returned
 * return S_OK
 */

STDMETHODIMP
CEnumPins::Reset()
{
    m_Version = m_pFilter->GetPinVersion();
    m_PinCount = m_pFilter->GetPinCount();

    m_Position = 0;

    // Clear the cache
    m_PinCache.RemoveAll();

    return S_OK;
}


/* Set the current position back to the start */
/* Refresh has 3 simple steps:
 *
 * Set position to head of list
 * Sync enumerator with object being enumerated
 * return S_OK
 */

STDMETHODIMP
CEnumPins::Refresh()
{
    m_Version = m_pFilter->GetPinVersion();
    m_PinCount = m_pFilter->GetPinCount();

    m_Position = 0;
    return S_OK;
}


//=====================================================================
//=====================================================================
// Implements CEnumMediaTypes
//=====================================================================
//=====================================================================


/* NOTE The implementation of this class calls the CUnknown constructor
   with a NULL unknown pointer. This has the effect of making us a self
   contained class, ie any QueryInterface, AddRef or Release calls will be
   routed to the class's NonDelegatingUnknown methods. You will typically
   find that the classes that do this then override one or more of these
   virtual functions to provide more specialised behaviour. A good example
   of this is where a class wants to keep the QueryInterface internal but
   still wants it's lifetime controlled by the external object */

CEnumMediaTypes::CEnumMediaTypes(CBasePin *pPin,
				 CEnumMediaTypes *pEnumMediaTypes) :
    m_Position(0),
    m_pPin(pPin),
    m_cRef(1)
{

#ifdef DEBUG
    m_dwCookie = DbgRegisterObjectCreation(TEXT("CEnumMediaTypes"));
#endif

    /* We must be owned by a pin derived from CBasePin */

    ASSERT(pPin != NULL);

    /* Hold a reference count on our pin */
    m_pPin->AddRef();

    /* Are we creating a new enumerator */

    if (pEnumMediaTypes == NULL) {
	m_Version = m_pPin->GetMediaTypeVersion();
	return;
    }

    m_Position = pEnumMediaTypes->m_Position;
    m_Version = pEnumMediaTypes->m_Version;
}


/* Destructor releases the reference count on our base pin. NOTE since we hold
   a reference count on the pin who created us we know it is safe to release
   it, no access can be made to it afterwards though as we might have just
   caused the last reference count to go and the object to be deleted */

CEnumMediaTypes::~CEnumMediaTypes()
{
#ifdef DEBUG
    DbgRegisterObjectDestruction(m_dwCookie);
#endif
    m_pPin->Release();
}


/* Override this to say what interfaces we support where */

STDMETHODIMP
CEnumMediaTypes::QueryInterface(REFIID riid,void **ppv)
{
    CheckPointer(ppv, E_POINTER);

    /* Do we have this interface */

    if (riid == IID_IEnumMediaTypes || riid == IID_IUnknown) {
	return GetInterface((IEnumMediaTypes *) this, ppv);
    } else {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
CEnumMediaTypes::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CEnumMediaTypes::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if (cRef == 0) {
        delete this;
    }
    return cRef;
}

/* One of an enumerator's basic member functions allows us to create a cloned
   interface that initially has the same state. Since we are taking a snapshot
   of an object (current position and all) we must lock access at the start */

STDMETHODIMP
CEnumMediaTypes::Clone(IEnumMediaTypes **ppEnum)
{
    CheckPointer(ppEnum,E_POINTER);
    ValidateReadWritePtr(ppEnum,sizeof(IEnumMediaTypes *));
    HRESULT hr = NOERROR;

    /* Check we are still in sync with the pin */
    if (AreWeOutOfSync() == TRUE) {
        *ppEnum = NULL;
        hr = VFW_E_ENUM_OUT_OF_SYNC;
    } else {

        *ppEnum = new CEnumMediaTypes(m_pPin,
    	                              this);

        if (*ppEnum == NULL) {
    	    hr =  E_OUTOFMEMORY;
        }
    }
    return hr;
}


/* Enumerate the next pin(s) after the current position. The client using this
   interface passes in a pointer to an array of pointers each of which will
   be filled in with a pointer to a fully initialised media type format
   Return NOERROR if it all works,
          S_FALSE if fewer than cMediaTypes were enumerated.
          VFW_E_ENUM_OUT_OF_SYNC if the enumerator has been broken by
                                 state changes in the filter
   The actual count always correctly reflects the number of types in the array.
*/

STDMETHODIMP
CEnumMediaTypes::Next(ULONG cMediaTypes,          // place this many types...
		      AM_MEDIA_TYPE **ppMediaTypes,   // ...in this array
		      ULONG *pcFetched)           // actual count passed
{
    CheckPointer(ppMediaTypes,E_POINTER);
    ValidateReadWritePtr(ppMediaTypes,cMediaTypes * sizeof(AM_MEDIA_TYPE *));
    /* Check we are still in sync with the pin */
    if (AreWeOutOfSync() == TRUE) {
        return VFW_E_ENUM_OUT_OF_SYNC;
    }

    if (pcFetched!=NULL) {
        ValidateWritePtr(pcFetched, sizeof(ULONG));
        *pcFetched = 0;           // default unless we succeed
    }
    // now check that the parameter is valid
    else if (cMediaTypes>1) {	  // pcFetched == NULL
        return E_INVALIDARG;
    }
    ULONG cFetched = 0;           // increment as we get each one.

    /* Return each media type by asking the filter for them in turn - If we
       have an error code retured to us while we are retrieving a media type
       we assume that our internal state is stale with respect to the filter
       (for example the window size changing) so we return
       VFW_E_ENUM_OUT_OF_SYNC */

    while (cMediaTypes) {

    	CMediaType cmt;

	HRESULT hr = m_pPin->GetMediaType(m_Position++, &cmt);
        if (S_OK != hr) {
            break;
        }

    	/* We now have a CMediaType object that contains the next media type
    	   but when we assign it to the array position we CANNOT just assign
    	   the AM_MEDIA_TYPE structure because as soon as the object goes out of
    	   scope it will delete the memory we have just copied. The function
    	   we use is CreateMediaType which allocates a task memory block */

        /*  Transfer across the format block manually to save an allocate
            and free on the format block and generally go faster */

    	*ppMediaTypes = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));
    	if (*ppMediaTypes == NULL) {
            break;
    	}

        /*  Do a regular copy */
        **ppMediaTypes = (AM_MEDIA_TYPE)cmt;

        /*  Make sure the destructor doesn't free these */
        cmt.pbFormat = NULL;
        cmt.cbFormat = NULL;
        cmt.pUnk     = NULL;


    	ppMediaTypes++;
    	cFetched++;
    	cMediaTypes--;
    }

    if (pcFetched!=NULL) {
        *pcFetched = cFetched;
    }

    return ( cMediaTypes==0 ? NOERROR : S_FALSE );
}


/* Skip over one or more entries in the enumerator */

STDMETHODIMP
CEnumMediaTypes::Skip(ULONG cMediaTypes)
{
    /* Check we are still in sync with the pin */
    if (AreWeOutOfSync() == TRUE) {
        return VFW_E_ENUM_OUT_OF_SYNC;
    }

    m_Position += cMediaTypes;

    /*  See if we're over the end */
    CMediaType cmt;
    return S_OK == m_pPin->GetMediaType(m_Position - 1, &cmt) ? S_OK : S_FALSE;
}


/* Set the current position back to the start */
/* Reset has 3 simple steps:
 *
 * set position to head of list
 * sync enumerator with object being enumerated
 * return S_OK
 */

STDMETHODIMP
CEnumMediaTypes::Reset()
{
    m_Position = 0;

    // Bring the enumerator back into step with the current state.  This
    // may be a noop but ensures that the enumerator will be valid on the
    // next call.
    m_Version = m_pPin->GetMediaTypeVersion();
    return NOERROR;
}


//=====================================================================
//=====================================================================
// Implements CBasePin
//=====================================================================
//=====================================================================


/* NOTE The implementation of this class calls the CUnknown constructor with
   a NULL outer unknown pointer. This has the effect of making us a self
   contained class, ie any QueryInterface, AddRef or Release calls will be
   routed to the class's NonDelegatingUnknown methods. You will typically
   find that the classes that do this then override one or more of these
   virtual functions to provide more specialised behaviour. A good example
   of this is where a class wants to keep the QueryInterface internal but
   still wants its lifetime controlled by the external object */

/* Constructor */

CBasePin::CBasePin(TCHAR *pObjectName,
		   CBaseFilter *pFilter,
		   CCritSec *pLock,
		   HRESULT *phr,
		   LPCWSTR pName,
		   PIN_DIRECTION dir) :
    CUnknown( pObjectName, NULL ),
    m_pFilter(pFilter),
    m_pLock(pLock),
    m_pName(NULL),
    m_Connected(NULL),
    m_dir(dir),
    m_bRunTimeError(FALSE),
    m_pQSink(NULL),
    m_TypeVersion(1),
    m_tStart(),
    m_tStop(MAX_TIME),
    m_dRate(1.0)
{
    /*  WARNING - pFilter is often not a properly constituted object at
        this state (in particular QueryInterface may not work) - this
        is because its owner is often its containing object and we
        have been called from the containing object's constructor so
        the filter's owner has not yet had its CUnknown constructor
        called
    */
    ASSERT(pFilter != NULL);
    ASSERT(pLock != NULL);

    if (pName) {
	DWORD nameLen = lstrlenW(pName)+1;
	m_pName = new WCHAR[nameLen];
	if (m_pName) {
	    CopyMemory(m_pName, pName, nameLen*sizeof(WCHAR));
	}
    }

#ifdef DEBUG
    m_cRef = 0;
#endif
}


/* Destructor since a connected pin holds a reference count on us there is
   no way that we can be deleted unless we are not currently connected */

CBasePin::~CBasePin()
{
    //  We don't call disconnect because if the filter is going away
    //  all the pins must have a reference count of zero so they must
    //  have been disconnected anyway - (but check the assumption)
    ASSERT(m_Connected == FALSE);

    if (m_pName)
	delete[] m_pName;

    // check the internal reference count is consistent
    ASSERT(m_cRef == 0);
}


/* Override this to say what interfaces we support and where */

STDMETHODIMP
CBasePin::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    /* Do we have this interface */

    if (riid == IID_IPin) {
	return GetInterface((IPin *) this, ppv);
    } else if (riid == IID_IQualityControl) {
        return GetInterface((IQualityControl *) this, ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


/* Override to increment the owning filter's reference count */

STDMETHODIMP_(ULONG)
CBasePin::NonDelegatingAddRef()
{
    ASSERT(InterlockedIncrement(&m_cRef) > 0);
    return m_pFilter->AddRef();
}


/* Override to decrement the owning filter's reference count */

STDMETHODIMP_(ULONG)
CBasePin::NonDelegatingRelease()
{
    ASSERT(InterlockedDecrement(&m_cRef) >= 0);
    return m_pFilter->Release();
}


/* Displays pin connection information */

#ifdef DEBUG
void
CBasePin::DisplayPinInfo(IPin *pReceivePin)
{

    if (DbgCheckModuleLevel(LOG_TRACE, CONNECT_TRACE_LEVEL)) {
	PIN_INFO ConnectPinInfo;
	PIN_INFO ReceivePinInfo;

	if (FAILED(QueryPinInfo(&ConnectPinInfo))) {
	    lstrcpyW(ConnectPinInfo.achName, L"Bad Pin");
	} else {
	    QueryPinInfoReleaseFilter(ConnectPinInfo);
	}

	if (FAILED(pReceivePin->QueryPinInfo(&ReceivePinInfo))) {
	    lstrcpyW(ReceivePinInfo.achName, L"Bad Pin");
	} else {
	    QueryPinInfoReleaseFilter(ReceivePinInfo);
	}

	DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("Trying to connect Pins :")));
	DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("    <%ls>"), ConnectPinInfo.achName));
	DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("    <%ls>"), ReceivePinInfo.achName));
    }
}
#endif


/* Displays general information on the pin media type */

#ifdef DEBUG
void CBasePin::DisplayTypeInfo(IPin *pPin, const CMediaType *pmt)
{
    UNREFERENCED_PARAMETER(pPin);
    if (DbgCheckModuleLevel(LOG_TRACE, CONNECT_TRACE_LEVEL)) {
	DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("Trying media type:")));
	DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("    major type:  %s"),
	       GuidNames[*pmt->Type()]));
	DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("    sub type  :  %s"),
	       GuidNames[*pmt->Subtype()]));
    }
}
#endif

/* Asked to connect to a pin. A pin is always attached to an owning filter
   object so we always delegate our locking to that object. We first of all
   retrieve a media type enumerator for the input pin and see if we accept
   any of the formats that it would ideally like, failing that we retrieve
   our enumerator and see if it will accept any of our preferred types */

STDMETHODIMP
CBasePin::Connect(
    IPin * pReceivePin,
    const AM_MEDIA_TYPE *pmt   // optional media type
)
{
    CheckPointer(pReceivePin,E_POINTER);
    ValidateReadPtr(pReceivePin,sizeof(IPin));
    CAutoLock cObjectLock(m_pLock);
    DisplayPinInfo(pReceivePin);

    /* See if we are already connected */

    if (m_Connected) {
	DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("Already connected")));
	return VFW_E_ALREADY_CONNECTED;
    }

    /* See if the filter is active */
    if (!IsStopped()) {
        return VFW_E_NOT_STOPPED;
    }


    // Find a mutually agreeable media type -
    // Pass in the template media type. If this is partially specified,
    // each of the enumerated media types will need to be checked against
    // it. If it is non-null and fully specified, we will just try to connect
    // with this.

    const CMediaType * ptype = (CMediaType*)pmt;
    HRESULT hr = AgreeMediaType(pReceivePin, ptype);
    if (FAILED(hr)) {
	DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("Failed to agree type")));
	BreakConnect();
	return hr;
    }

    DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("Connection succeeded")));
    return NOERROR;
}

// given a specific media type, attempt a connection (includes
// checking that the type is acceptable to this pin)
HRESULT
CBasePin::AttemptConnection(
    IPin* pReceivePin,      // connect to this pin
    const CMediaType* pmt   // using this type
)
{
    // Check that the connection is valid  -- need to do this for every
    // connect attempt since BreakConnect will undo it.
    HRESULT hr = CheckConnect(pReceivePin);
    if (FAILED(hr)) {
	DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("CheckConnect failed")));
	BreakConnect();
	return hr;
    }

    DisplayTypeInfo(pReceivePin, pmt);

    /* Check we will accept this media type */

    hr = CheckMediaType(pmt);
    if (hr == NOERROR) {

        /*  Make ourselves look connected otherwise ReceiveConnection
            may not be able to complete the connection
        */
        m_Connected = pReceivePin;
        m_Connected->AddRef();
        SetMediaType(pmt);

        /* See if the other pin will accept this type */

        hr = pReceivePin->ReceiveConnection((IPin *)this, pmt);
        if (SUCCEEDED(hr)) {
            /* Complete the connection */

            hr = CompleteConnect(pReceivePin);
            if (SUCCEEDED(hr)) {
                return hr;
            } else {
                DbgLog((LOG_TRACE,
                        CONNECT_TRACE_LEVEL,
                        TEXT("Failed to complete connection")));
                pReceivePin->Disconnect();
            }
        }
    } else {
	// we cannot use this media type

	// return a specific media type error if there is one
	// or map a general failure code to something more helpful
	// (in particular S_FALSE gets changed to an error code)
	if (SUCCEEDED(hr) ||
	    (hr == E_FAIL) ||
	    (hr == E_INVALIDARG)) {
		hr = VFW_E_TYPE_NOT_ACCEPTED;
	}
    }

    // BreakConnect and release any connection here in case CheckMediaType
    // failed, or if we set anything up during a call back during
    // ReceiveConnection.
    BreakConnect();

    /*  If failed then undo our state */
    if (m_Connected) {
        m_Connected->Release();
        m_Connected = NULL;
    }

    return hr;
}

/* Given an enumerator we cycle through all the media types it proposes and
   firstly suggest them to our derived pin class and if that succeeds try
   them with the pin in a ReceiveConnection call. This means that if our pin
   proposes a media type we still check in here that we can support it. This
   is deliberate so that in simple cases the enumerator can hold all of the
   media types even if some of them are not really currently available */

HRESULT CBasePin::TryMediaTypes(
    IPin *pReceivePin,
    const CMediaType *pmt,
    IEnumMediaTypes *pEnum)
{
    /* Reset the current enumerator position */

    HRESULT hr = pEnum->Reset();
    if (FAILED(hr)) {
	return hr;
    }

    CMediaType *pMediaType = NULL;
    ULONG ulMediaCount = 0;

    // attempt to remember a specific error code if there is one
    HRESULT hrFailure = S_OK;

    for (;;) {

	/* Retrieve the next media type NOTE each time round the loop the
	   enumerator interface will allocate another AM_MEDIA_TYPE structure
	   If we are successful then we copy it into our output object, if
	   not then we must delete the memory allocated before returning */

	hr = pEnum->Next(1, (AM_MEDIA_TYPE**)&pMediaType,&ulMediaCount);
	if (hr != S_OK) {
	    if (S_OK == hrFailure) {
		hrFailure = VFW_E_NO_ACCEPTABLE_TYPES;
	    }
	    return hrFailure;
	}


	ASSERT(ulMediaCount == 1);
	ASSERT(pMediaType);

        // check that this matches the partial type (if any)

        if ((pmt == NULL) ||
            pMediaType->MatchesPartial(pmt)) {

            hr = AttemptConnection(pReceivePin, pMediaType);

	    // attempt to remember a specific error code
	    if (FAILED(hr) &&
		SUCCEEDED(hrFailure) &&
		(hr != E_FAIL) &&
		(hr != E_INVALIDARG) &&
		(hr != VFW_E_TYPE_NOT_ACCEPTED)) {
		    hrFailure = hr;
	    }
        } else {
            hr = VFW_E_NO_ACCEPTABLE_TYPES;
        }

        DeleteMediaType(pMediaType);

        if (S_OK == hr) {
            return hr;
        }
    }
}


/* This is called to make the connection, including the taask of finding
   a media type for the pin connection. pmt is the proposed media type
   from the Connect call: if this is fully specified, we will try that.
   Otherwise we enumerate and try all the input pin's types first and
   if that fails we then enumerate and try all our preferred media types.
   For each media type we check it against pmt (if non-null and partially
   specified) as well as checking that both pins will accept it.
 */

HRESULT CBasePin::AgreeMediaType(
    IPin *pReceivePin,
    const CMediaType *pmt)
{
    ASSERT(pReceivePin);
    IEnumMediaTypes *pEnumMediaTypes = NULL;

    // if the media type is fully specified then use that
    if ( (pmt != NULL) && (!pmt->IsPartiallySpecified())) {

        // if this media type fails, then we must fail the connection
        // since if pmt is nonnull we are only allowed to connect
        // using a type that matches it.

        return AttemptConnection(pReceivePin, pmt);
    }


    /* Try the other pin's enumerator */

    HRESULT hrFailure = VFW_E_NO_ACCEPTABLE_TYPES;

    HRESULT hr = pReceivePin->EnumMediaTypes(&pEnumMediaTypes);
    if (SUCCEEDED(hr)) {
	ASSERT(pEnumMediaTypes);
	hr = TryMediaTypes(pReceivePin,pmt,pEnumMediaTypes);
	pEnumMediaTypes->Release();
	if (SUCCEEDED(hr)) {
	    return NOERROR;
	} else {
	    // try to remember specific error codes if there are any
	    if ((hr != E_FAIL) &&
		(hr != E_INVALIDARG) &&
		(hr != VFW_E_TYPE_NOT_ACCEPTED)) {
		    hrFailure = hr;
	    }
	}
    }

    /* Having failed with that try our enumerator */

    hr = EnumMediaTypes(&pEnumMediaTypes);
    if (SUCCEEDED(hr)) {
	ASSERT(pEnumMediaTypes);
	hr = TryMediaTypes(pReceivePin,pmt,pEnumMediaTypes);
	pEnumMediaTypes->Release();
	if (SUCCEEDED(hr)) {
	    return NOERROR;
	} else {
	    // try to remember specific error codes if there are any
	    if ((hr != E_FAIL) &&
		(hr != E_INVALIDARG) &&
		(hr != VFW_E_TYPE_NOT_ACCEPTED)) {
		    hrFailure = hr;
	    }
	}
    }
    return hrFailure;
}


/* Called when we want to complete a connection to another filter. Failing
   this will also fail the connection and disconnect the other pin as well */

HRESULT
CBasePin::CompleteConnect(IPin *pReceivePin)
{
    UNREFERENCED_PARAMETER(pReceivePin);
    return NOERROR;
}


/* This is called to set the format for a pin connection - CheckMediaType
   will have been called to check the connection format and if it didn't
   return an error code then this (virtual) function will be invoked */

HRESULT
CBasePin::SetMediaType(const CMediaType *pmt)
{
    m_mt = *pmt;
    return NOERROR;
}


/* This is called during Connect() to provide a virtual method that can do
   any specific check needed for connection such as QueryInterface. This
   base class method just checks that the pin directions don't match */

HRESULT
CBasePin::CheckConnect(IPin * pPin)
{
    /* Check that pin directions DONT match */

    PIN_DIRECTION pd;
    pPin->QueryDirection(&pd);

    ASSERT((pd == PINDIR_OUTPUT) || (pd == PINDIR_INPUT));
    ASSERT((m_dir == PINDIR_OUTPUT) || (m_dir == PINDIR_INPUT));

    // we should allow for non-input and non-output connections?
    if (pd == m_dir) {
	return VFW_E_INVALID_DIRECTION;
    }
    return NOERROR;
}


/* This is called when we realise we can't make a connection to the pin and
   must undo anything we did in CheckConnect - override to release QIs done */

HRESULT
CBasePin::BreakConnect()
{
    return NOERROR;
}


/* Called normally by an output pin on an input pin to try and establish a
   connection.
*/

STDMETHODIMP
CBasePin::ReceiveConnection(
    IPin * pConnector,      // this is the pin who we will connect to
    const AM_MEDIA_TYPE *pmt    // this is the media type we will exchange
)
{
    CheckPointer(pConnector,E_POINTER);
    CheckPointer(pmt,E_POINTER);
    ValidateReadPtr(pConnector,sizeof(IPin));
    ValidateReadPtr(pmt,sizeof(AM_MEDIA_TYPE));
    CAutoLock cObjectLock(m_pLock);

    /* Are we already connected */
    if (m_Connected) {
	return VFW_E_ALREADY_CONNECTED;
    }

    /* See if the filter is active */
    if (!IsStopped()) {
        return VFW_E_NOT_STOPPED;
    }

    HRESULT hr = CheckConnect(pConnector);
    if (FAILED(hr)) {
	BreakConnect();
	return hr;
    }

    /* Ask derived class if this media type is ok */

    CMediaType * pcmt = (CMediaType*) pmt;
    hr = CheckMediaType(pcmt);
    if (hr != NOERROR) {
	// no -we don't support this media type
	BreakConnect();

	// return a specific media type error if there is one
	// or map a general failure code to something more helpful
	// (in particular S_FALSE gets changed to an error code)
	if (SUCCEEDED(hr) ||
	    (hr == E_FAIL) ||
	    (hr == E_INVALIDARG)) {
		hr = VFW_E_TYPE_NOT_ACCEPTED;
	}
	return hr;
    }

    /* Complete the connection */

    m_Connected = pConnector;
    m_Connected->AddRef();
    SetMediaType(pcmt);

    hr = CompleteConnect(pConnector);
    if (FAILED(hr)) {
        DbgLog((LOG_TRACE, CONNECT_TRACE_LEVEL, TEXT("Failed to complete connection")));
        m_Connected->Release();
        m_Connected = NULL;
        BreakConnect();
        return hr;
    }
    return NOERROR;
}


/* Called when we want to terminate a pin connection */

STDMETHODIMP
CBasePin::Disconnect()
{
    CAutoLock cObjectLock(m_pLock);

    /* See if the filter is active */
    if (!IsStopped()) {
        return VFW_E_NOT_STOPPED;
    }		

    if (m_Connected) {
	BreakConnect();
	m_Connected->Release();
	m_Connected = NULL;
	return S_OK;
    } else {
	// no connection - not an error
	return S_FALSE;
    }
}


/* Return an AddRef()'d pointer to the connected pin if there is one */
STDMETHODIMP
CBasePin::ConnectedTo(
    IPin **ppPin
)
{
    CheckPointer(ppPin,E_POINTER);
    ValidateReadWritePtr(ppPin,sizeof(IPin *));
    //
    //  It's pointless to lock here.
    //  The caller should ensure integrity.
    //

    IPin *pPin = m_Connected;
    *ppPin = pPin;
    if (pPin != NULL) {
        pPin->AddRef();
        return S_OK;
    } else {
        ASSERT(*ppPin == NULL);
        return VFW_E_NOT_CONNECTED;
    }
}

/* Return the media type of the connection */
STDMETHODIMP
CBasePin::ConnectionMediaType(
    AM_MEDIA_TYPE *pmt
)
{
    CheckPointer(pmt,E_POINTER);
    ValidateReadWritePtr(pmt,sizeof(AM_MEDIA_TYPE));
    CAutoLock cObjectLock(m_pLock);

    /*  Copy constructor of m_mt allocates the memory */
    if (IsConnected()) {
        CopyMediaType( pmt, &m_mt );
        return S_OK;
    } else {
        ((CMediaType *)pmt)->InitMediaType();
        return VFW_E_NOT_CONNECTED;
    }
}

/* Return information about the filter we are connect to */

STDMETHODIMP
CBasePin::QueryPinInfo(
    PIN_INFO * pInfo
)
{
    CheckPointer(pInfo,E_POINTER);
    ValidateReadWritePtr(pInfo,sizeof(PIN_INFO));

    pInfo->pFilter = m_pFilter;
    if (m_pFilter) {
	m_pFilter->AddRef();
    }

    if (m_pName) {
	lstrcpyW(pInfo->achName, m_pName);
    } else {
	pInfo->achName[0] = L'\0';
    }

    pInfo->dir = m_dir;

    return NOERROR;
}

STDMETHODIMP
CBasePin::QueryDirection(
    PIN_DIRECTION * pPinDir
)
{
    CheckPointer(pPinDir,E_POINTER);
    ValidateReadWritePtr(pPinDir,sizeof(PIN_DIRECTION));

    *pPinDir = m_dir;
    return NOERROR;
}

// Default QueryId to return the pin's name
STDMETHODIMP
CBasePin::QueryId(
    LPWSTR * Id
)
{
    //  We're not going away because someone's got a pointer to us
    //  so there's no need to lock

    return AMGetWideString(Name(), Id);
}

/* Does this pin support this media type WARNING this interface function does
   not lock the main object as it is meant to be asynchronous by nature - if
   the media types you support depend on some internal state that is updated
   dynamically then you will need to implement locking in a derived class */

STDMETHODIMP
CBasePin::QueryAccept(
    const AM_MEDIA_TYPE *pmt
)
{
    CheckPointer(pmt,E_POINTER);
    ValidateReadPtr(pmt,sizeof(AM_MEDIA_TYPE));

    /* The CheckMediaType method is valid to return error codes if the media
       type is horrible, an example might be E_INVALIDARG. What we do here
       is map all the error codes into either S_OK or S_FALSE regardless */

    HRESULT hr = CheckMediaType((CMediaType*)pmt);
    if (FAILED(hr)) {
        return S_FALSE;
    }
    // note that the only defined success codes should be S_OK and S_FALSE...
    return hr;
}


/* This can be called to return an enumerator for the pin's list of preferred
   media types. An input pin is not obliged to have any preferred formats
   although it can do. For example, the window renderer has a preferred type
   which describes a video image that matches the current window size. All
   output pins should expose at least one preferred format otherwise it is
   possible that neither pin has any types and so no connection is possible */

STDMETHODIMP
CBasePin::EnumMediaTypes(
    IEnumMediaTypes **ppEnum
)
{
    CheckPointer(ppEnum,E_POINTER);
    ValidateReadWritePtr(ppEnum,sizeof(IEnumMediaTypes *));

    /* Create a new ref counted enumerator */

    *ppEnum = new CEnumMediaTypes(this,
	                          NULL);

    if (*ppEnum == NULL) {
	return E_OUTOFMEMORY;
    }

    return NOERROR;
}



/* This is a virtual function that returns a media type corresponding with
   place iPosition in the list. This base class simply returns an error as
   we support no media types by default but derived classes should override */

HRESULT CBasePin::GetMediaType(int iPosition, CMediaType *pMediaType)
{
    UNREFERENCED_PARAMETER(iPosition);
    UNREFERENCED_PARAMETER(pMediaType);
    return E_UNEXPECTED;
}


/* This is a virtual function that returns the current media type version.
   The base class initialises the media type enumerators with the value 1
   By default we always returns that same value. A Derived class may change
   the list of media types available and after doing so it should increment
   the version either in a method derived from this, or more simply by just
   incrementing the m_TypeVersion base pin variable. The type enumerators
   call this when they want to see if their enumerations are out of date */

LONG CBasePin::GetMediaTypeVersion()
{
    return m_TypeVersion;
}


/* Increment the cookie representing the current media type version */

void CBasePin::IncrementTypeVersion()
{
    InterlockedIncrement(&m_TypeVersion);
}


/* Called by IMediaFilter implementation when the state changes from Stopped
   to either paused or running and in derived classes could do things like
   commit memory and grab hardware resource (the default is to do nothing) */

HRESULT
CBasePin::Active(void)
{
    return NOERROR;
}

/* Called by IMediaFilter implementation when the state changes from
   to either paused to running and in derived classes could do things like
   commit memory and grab hardware resource (the default is to do nothing) */

HRESULT
CBasePin::Run(REFERENCE_TIME tStart)
{
    UNREFERENCED_PARAMETER(tStart);
    return NOERROR;
}


/* Also called by the IMediaFilter implementation when the state changes to
   Stopped at which point you should decommit allocators and free hardware
   resources you grabbed in the Active call (default is also to do nothing) */

HRESULT
CBasePin::Inactive(void)
{
    m_bRunTimeError = FALSE;
    return NOERROR;
}


// Called when no more data will arrive
STDMETHODIMP
CBasePin::EndOfStream(void)
{
    return S_FALSE;
}


STDMETHODIMP
CBasePin::SetSink(IQualityControl * piqc)
{
    CAutoLock cObjectLock(m_pLock);
    if (piqc) ValidateReadPtr(piqc,sizeof(IQualityControl));
    m_pQSink = piqc;
    return NOERROR;
} // SetSink


STDMETHODIMP
CBasePin::Notify(IBaseFilter * pSender, Quality q)
{
    UNREFERENCED_PARAMETER(q);
    UNREFERENCED_PARAMETER(pSender);
    DbgBreak("IQualityControl::Notify not over-ridden from CBasePin.  (IGNORE is OK)");
    return E_NOTIMPL;
} //Notify


// NewSegment notifies of the start/stop/rate applying to the data
// about to be received. Default implementation records data and
// returns S_OK.
// Override this to pass downstream.
STDMETHODIMP
CBasePin::NewSegment(
                REFERENCE_TIME tStart,
                REFERENCE_TIME tStop,
                double dRate)
{
    m_tStart = tStart;
    m_tStop = tStop;
    m_dRate = dRate;

    return S_OK;
}


//=====================================================================
//=====================================================================
// Implements CBaseOutputPin
//=====================================================================
//=====================================================================


CBaseOutputPin::CBaseOutputPin(TCHAR *pObjectName,
			       CBaseFilter *pFilter,
			       CCritSec *pLock,
			       HRESULT *phr,
			       LPCWSTR pName) :
    CBasePin(pObjectName, pFilter, pLock, phr, pName, PINDIR_OUTPUT),
    m_pAllocator(NULL),
    m_pInputPin(NULL)
{
    ASSERT(pFilter);
}


/* Since an input pin connected to us holds a reference count on us we will
   never be deleted unless all connections have already been terminated */

#if 0
CBaseOutputPin::~CBaseOutputPin()
{
}
#endif

/*   This is called after a media type has been proposed

     Try to complete the connection by agreeing the allocator
*/
HRESULT
CBaseOutputPin::CompleteConnect(IPin *pReceivePin)
{
    UNREFERENCED_PARAMETER(pReceivePin);
    return DecideAllocator(m_pInputPin, &m_pAllocator);
}


/* This method is called when the output pin is about to try and connect to
   an input pin. It is at this point that you should try and grab any extra
   interfaces that you need, in this case IMemInputPin. Because this is
   only called if we are not currently connected we do NOT need to call
   BreakConnect. This also makes it easier to derive classes from us as
   BreakConnect is only called when we actually have to break a connection
   (or a partly made connection) and not when we are checking a connection */

/* Overriden from CBasePin */

HRESULT
CBaseOutputPin::CheckConnect(IPin * pPin)
{
    HRESULT hr = CBasePin::CheckConnect(pPin);
    if (FAILED(hr)) {
	return hr;
    }

    // get an input pin and an allocator interface
    hr = pPin->QueryInterface(IID_IMemInputPin, (void **) &m_pInputPin);
    if (FAILED(hr)) {
	return hr;
    }
    return NOERROR;
}


/* Overriden from CBasePin */

HRESULT
CBaseOutputPin::BreakConnect()
{
    /* Release any allocator we hold */

    if (m_pAllocator) {
	m_pAllocator->Release();
	m_pAllocator = NULL;
    }

    /* Release any input pin interface we hold */

    if (m_pInputPin) {
	m_pInputPin->Release();
	m_pInputPin = NULL;
    }
    return NOERROR;
}


/* This is called when the input pin didn't give us a valid allocator */

HRESULT
CBaseOutputPin::InitAllocator(IMemAllocator **ppAlloc)
{
#if 0
    HRESULT hr = NOERROR;
    *ppAlloc = NULL;
    CMemAllocator *pMemObject = NULL;

    /* Create a default memory allocator */

    pMemObject = new CMemAllocator(NAME("Base memory allocator"),NULL, &hr);
    if (pMemObject == NULL) {
	return E_OUTOFMEMORY;
    }

    if (FAILED(hr)) {
	delete pMemObject;
	return hr;
    }

    /* Get a reference counted IID_IMemAllocator interface */

    EXECUTE_ASSERT(SUCCEEDED(pMemObject->QueryInterface(IID_IMemAllocator,(void **)ppAlloc)));

    ASSERT(*ppAlloc != NULL);
    return NOERROR;
#else
    return CreateMemoryAllocator(ppAlloc);
#endif
}


/* Decide on an allocator, override this if you want to use your own allocator
   Override DecideBufferSize to call SetProperties. If the input pin fails
   the GetAllocator call then this will construct a CMemAllocator and call
   DecideBufferSize on that, and if that fails then we are completely hosed.
   If the you succeed the DecideBufferSize call, we will notify the input
   pin of the selected allocator. NOTE this is called during Connect() which
   therefore looks after grabbing and locking the object's critical section */

// We query the input pin for its requested properties and pass this to
// DecideBufferSize to allow it to fulfill requests that it is happy
// with (eg most people don't care about alignment and are thus happy to
// use the downstream pin's alignment request).

HRESULT
CBaseOutputPin::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    HRESULT hr = NOERROR;
    *ppAlloc = NULL;

    // get downstream prop request
    // the derived class may modify this in DecideBufferSize, but
    // we assume that he will consistently modify it the same way,
    // so we only get it once
    ALLOCATOR_PROPERTIES prop;
    ZeroMemory(&prop, sizeof(prop));

    // whatever he returns, we assume prop is either all zeros
    // or he has filled it out.
    pPin->GetAllocatorRequirements(&prop);

    // if he doesn't care about alignment, then set it to 1
    if (prop.cbAlign == 0) {
        prop.cbAlign = 1;
    }

    /* Try the allocator provided by the input pin */

    hr = pPin->GetAllocator(ppAlloc);
    if (SUCCEEDED(hr)) {

	hr = DecideBufferSize(*ppAlloc, &prop);
	if (SUCCEEDED(hr)) {
	    hr = pPin->NotifyAllocator(*ppAlloc, FALSE);
	    if (SUCCEEDED(hr)) {
		return NOERROR;
	    }
	}
    }

    /* If the GetAllocator failed we may not have an interface */

    if (*ppAlloc) {
	(*ppAlloc)->Release();
	*ppAlloc = NULL;
    }

    /* Try the output pin's allocator by the same method */

    hr = InitAllocator(ppAlloc);
    if (SUCCEEDED(hr)) {

        // note - the properties passed here are in the same
        // structure as above and may have been modified by
        // the previous call to DecideBufferSize
	hr = DecideBufferSize(*ppAlloc, &prop);
	if (SUCCEEDED(hr)) {
	    hr = pPin->NotifyAllocator(*ppAlloc, FALSE);
	    if (SUCCEEDED(hr)) {
		return NOERROR;
	    }
	}
    }

    /* Likewise we may not have an interface to release */

    if (*ppAlloc) {
	(*ppAlloc)->Release();
	*ppAlloc = NULL;
    }
    return hr;
}


/* This returns an empty sample buffer from the allocator WARNING the same
   dangers and restrictions apply here as described below for Deliver() */

HRESULT
CBaseOutputPin::GetDeliveryBuffer(IMediaSample ** ppSample,
                                  REFERENCE_TIME * pStartTime,
                                  REFERENCE_TIME * pEndTime,
                                  DWORD dwFlags)
{
    if (m_pAllocator != NULL) {
        return m_pAllocator->GetBuffer(ppSample,pStartTime,pEndTime,dwFlags);
    } else {
        return E_NOINTERFACE;
    }
}


/* Deliver a filled-in sample to the connected input pin. NOTE the object must
   have locked itself before calling us otherwise we may get halfway through
   executing this method only to find the filter graph has got in and
   disconnected us from the input pin. If the filter has no worker threads
   then the lock is best applied on Receive(), otherwise it should be done
   when the worker thread is ready to deliver. There is a wee snag to worker
   threads that this shows up. The worker thread must lock the object when
   it is ready to deliver a sample, but it may have to wait until a state
   change has completed, but that may never complete because the state change
   is waiting for the worker thread to complete. The way to handle this is for
   the state change code to grab the critical section, then set an abort event
   for the worker thread, then release the critical section and wait for the
   worker thread to see the event we set and then signal that it has finished
   (with another event). At which point the state change code can complete */

// note (if you've still got any breath left after reading that) that you
// need to release the sample yourself after this call. if the connected
// input pin needs to hold onto the sample beyond the call, it will addref
// the sample itself.

// of course you must release this one and call GetDeliveryBuffer for the
// next. You cannot reuse it directly.

HRESULT
CBaseOutputPin::Deliver(IMediaSample * pSample)
{
    if (m_pInputPin == NULL) {
	return VFW_E_NOT_CONNECTED;
    }
    return m_pInputPin->Receive(pSample);
}


// called from elsewhere in our filter to pass EOS downstream to
// our connected input pin
HRESULT
CBaseOutputPin::DeliverEndOfStream(void)
{
    // remember this is on IPin not IMemInputPin
    if (m_Connected == NULL) {
        return VFW_E_NOT_CONNECTED;
    }
    return m_Connected->EndOfStream();
}


/* Commit the allocator's memory, this is called through IMediaFilter
   which is responsible for locking the object before calling us */

HRESULT
CBaseOutputPin::Active(void)
{
    if (m_pAllocator == NULL) {
	return VFW_E_NO_ALLOCATOR;
    }
    return m_pAllocator->Commit();
}


/* Free up or unprepare allocator's memory, this is called through
   IMediaFilter which is responsible for locking the object first */

HRESULT
CBaseOutputPin::Inactive(void)
{
    m_bRunTimeError = FALSE;
    if (m_pAllocator == NULL) {
	return VFW_E_NO_ALLOCATOR;
    }
    return m_pAllocator->Decommit();
}

// we have a default handling of EndOfStream which is to return
// an error, since this should be called on input pins only
STDMETHODIMP
CBaseOutputPin::EndOfStream(void)
{
    return E_UNEXPECTED;
}


// BeginFlush should be called on input pins only
STDMETHODIMP
CBaseOutputPin::BeginFlush(void)
{
    return E_UNEXPECTED;
}

// EndFlush should be called on input pins only
STDMETHODIMP
CBaseOutputPin::EndFlush(void)
{
    return E_UNEXPECTED;
}

// call BeginFlush on the connected input pin
HRESULT
CBaseOutputPin::DeliverBeginFlush(void)
{
    // remember this is on IPin not IMemInputPin
    if (m_Connected == NULL) {
        return VFW_E_NOT_CONNECTED;
    }
    return m_Connected->BeginFlush();
}

// call EndFlush on the connected input pin
HRESULT
CBaseOutputPin::DeliverEndFlush(void)
{
    // remember this is on IPin not IMemInputPin
    if (m_Connected == NULL) {
        return VFW_E_NOT_CONNECTED;
    }
    return m_Connected->EndFlush();
}
// deliver NewSegment to connected pin
HRESULT
CBaseOutputPin::DeliverNewSegment(
    REFERENCE_TIME tStart,
    REFERENCE_TIME tStop,
    double dRate)
{
    if (m_Connected == NULL) {
        return VFW_E_NOT_CONNECTED;
    }
    return m_Connected->NewSegment(tStart, tStop, dRate);
}


//=====================================================================
//=====================================================================
// Implements CBaseInputPin
//=====================================================================
//=====================================================================


/* Constructor creates a default allocator object */

CBaseInputPin::CBaseInputPin(TCHAR *pObjectName,
			     CBaseFilter *pFilter,
			     CCritSec *pLock,
			     HRESULT *phr,
			     LPCWSTR pPinName) :
    CBasePin(pObjectName, pFilter, pLock, phr, pPinName, PINDIR_INPUT),
    m_pAllocator(NULL),
    m_bReadOnly(FALSE),
    m_bFlushing(FALSE)
{
    ZeroMemory(&m_SampleProps, sizeof(m_SampleProps));
}

/* Destructor releases it's reference count on the default allocator */

CBaseInputPin::~CBaseInputPin()
{
    if (m_pAllocator != NULL) {
	m_pAllocator->Release();
	m_pAllocator = NULL;
    }
}


// override this to publicise our interfaces
STDMETHODIMP
CBaseInputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    /* Do we know about this interface */

    if (riid == IID_IMemInputPin) {
	return GetInterface((IMemInputPin *) this, ppv);
    } else {
	return CBasePin::NonDelegatingQueryInterface(riid, ppv);
    }
}


/* Return the allocator interface that this input pin would like the output
   pin to use. NOTE subsequent calls to GetAllocator should all return an
   interface onto the SAME object so we create one object at the start

   Note:
       The allocator is Release()'d on disconnect and replaced on
       NotifyAllocator().

   Override this to provide your own allocator.
*/

STDMETHODIMP
CBaseInputPin::GetAllocator(
    IMemAllocator **ppAllocator)
{
    CheckPointer(ppAllocator,E_POINTER);
    ValidateReadWritePtr(ppAllocator,sizeof(IMemAllocator *));
    CAutoLock cObjectLock(m_pLock);

    if (m_pAllocator == NULL) {
#if 0
	HRESULT hr = S_OK;

	/* Create the new allocator object */

	CMemAllocator *pMemObject = new CMemAllocator(NAME("Default memory allocator"),
						      NULL, &hr);
	if (pMemObject == NULL) {
	    return E_OUTOFMEMORY;
	}

	if (FAILED(hr)) {
	    ASSERT(pMemObject);
	    delete pMemObject;
	    return hr;
	}

        m_pAllocator = pMemObject;

        /*  We AddRef() our own allocator */
        m_pAllocator->AddRef();
#else
        HRESULT hr = CreateMemoryAllocator(&m_pAllocator);
        if (FAILED(hr)) {
            return hr;
        }
#endif
    }
    ASSERT(m_pAllocator != NULL);
    *ppAllocator = m_pAllocator;
    m_pAllocator->AddRef();
    return NOERROR;
}


/* Tell the input pin which allocator the output pin is actually going to use
   Override this if you care - NOTE the locking we do both here and also in
   GetAllocator is unnecessary but derived classes that do something useful
   will undoubtedly have to lock the object so this might help remind people */

STDMETHODIMP
CBaseInputPin::NotifyAllocator(
    IMemAllocator * pAllocator,
    BOOL bReadOnly)
{
    CheckPointer(pAllocator,E_POINTER);
    ValidateReadPtr(pAllocator,sizeof(IMemAllocator));
    CAutoLock cObjectLock(m_pLock);

    IMemAllocator *pOldAllocator = m_pAllocator;
    pAllocator->AddRef();
    m_pAllocator = pAllocator;

    if (pOldAllocator != NULL) {
	pOldAllocator->Release();
    }

    // the readonly flag indicates whether samples from this allocator should
    // be regarded as readonly - if true, then inplace transforms will not be
    // allowed.
    m_bReadOnly = (BYTE)bReadOnly;
    return NOERROR;
}


/*  Disconnect */

STDMETHODIMP CBaseInputPin::Disconnect()
{
    CAutoLock cObjectLock(m_pLock);

    /*  Call base class first because it calls Inactive() for us */
    HRESULT hr = CBasePin::Disconnect();

    if (S_OK == hr) {
        /* We don't need our allocator any more */
        if (m_pAllocator) {
            m_pAllocator->Release();
            m_pAllocator = NULL;
        }
    }
    return hr;
}


/* Do something with this media sample - this base class checks to see if the
   format has changed with this media sample and if so checks that the filter
   will accept it, generating a run time error if not. Once we have raised a
   run time error we set a flag so that no more samples will be accepted

   It is important that any filter should override this method and implement
   synchronization so that samples are not processed when the pin is
   disconnected etc
*/

STDMETHODIMP
CBaseInputPin::Receive(IMediaSample *pSample)
{
    CheckPointer(pSample,E_POINTER);
    ValidateReadPtr(pSample,sizeof(IMediaSample));
    AM_MEDIA_TYPE *pmt = NULL;
    ASSERT(pSample);

    HRESULT hr = CheckStreaming();
    if (S_OK != hr) {
        return hr;
    }

    /* Check for IMediaSample2 */
    IMediaSample2 *pSample2;
    if (SUCCEEDED(pSample->QueryInterface(IID_IMediaSample2, (void **)&pSample2))) {
        hr = pSample2->GetProperties(sizeof(m_SampleProps), (PBYTE)&m_SampleProps);
        pSample2->Release();
        if (FAILED(hr)) {
            return hr;
        }
    } else {
        /*  Get the properties the hard way */
        m_SampleProps.cbData = sizeof(m_SampleProps);
        m_SampleProps.dwTypeSpecificFlags = 0;
        m_SampleProps.dwStreamId = AM_STREAM_MEDIA;
        m_SampleProps.dwSampleFlags = 0;
        if (S_OK == pSample->IsDiscontinuity()) {
            m_SampleProps.dwSampleFlags |= AM_SAMPLE_DATADISCONTINUITY;
        }
        if (S_OK == pSample->IsPreroll()) {
            m_SampleProps.dwSampleFlags |= AM_SAMPLE_PREROLL;
        }
        if (S_OK == pSample->IsSyncPoint()) {
            m_SampleProps.dwSampleFlags |= AM_SAMPLE_SPLICEPOINT;
        }
        if (SUCCEEDED(pSample->GetTime(&m_SampleProps.tStart,
                                       &m_SampleProps.tStop))) {
            m_SampleProps.dwSampleFlags |= AM_SAMPLE_TIMEVALID |
                                           AM_SAMPLE_STOPVALID;
        }
        if (S_OK == pSample->GetMediaType(&m_SampleProps.pMediaType)) {
            m_SampleProps.dwSampleFlags |= AM_SAMPLE_TYPECHANGED;
        }
        pSample->GetPointer(&m_SampleProps.pbBuffer);
        m_SampleProps.lActual = pSample->GetActualDataLength();
        m_SampleProps.cbBuffer = pSample->GetSize();
    }

    /* Has the format changed in this sample */

    if (!(m_SampleProps.dwSampleFlags & AM_SAMPLE_TYPECHANGED)) {
	return NOERROR;
    }

    /* Check the derived class accepts this format */
    /* This shouldn't fail as the source must call QueryAccept first */

    hr = CheckMediaType((CMediaType *)m_SampleProps.pMediaType);

    if (hr == NOERROR) {
        return NOERROR;
    }

    /* Raise a runtime error if we fail the media type */

    m_bRunTimeError = TRUE;
    EndOfStream();
    m_pFilter->NotifyEvent(EC_ERRORABORT,VFW_E_TYPE_NOT_ACCEPTED,0);
    return VFW_E_INVALIDMEDIATYPE;
}


/*  Receive multiple samples */
STDMETHODIMP
CBaseInputPin::ReceiveMultiple (
    IMediaSample **pSamples,
    long nSamples,
    long *nSamplesProcessed)
{
    CheckPointer(pSamples,E_POINTER);
    ValidateReadPtr(pSamples,nSamples * sizeof(IMediaSample *));

    HRESULT hr = S_OK;
    *nSamplesProcessed = 0;
    while (nSamples-- > 0) {
         hr = Receive(pSamples[*nSamplesProcessed]);

         /*  S_FALSE means don't send any more */
         if (hr != S_OK) {
             break;
         }
         (*nSamplesProcessed)++;
    }
    return hr;
}

/*  See if Receive() might block */
STDMETHODIMP
CBaseInputPin::ReceiveCanBlock()
{
    /*  Ask all the output pins if they block
        If there are no output pin assume we do block
    */
    int cPins = m_pFilter->GetPinCount();
    int cOutputPins = 0;
    for (int c = 0; c < cPins; c++) {
        CBasePin *pPin = m_pFilter->GetPin(c);
        PIN_DIRECTION pd;
        HRESULT hr = pPin->QueryDirection(&pd);
        if (FAILED(hr)) {
            return hr;
        }

        if (pd == PINDIR_OUTPUT) {
            IPin *pConnected;
            hr = pPin->ConnectedTo(&pConnected);
            if (SUCCEEDED(hr)) {
                ASSERT(pConnected != NULL);
                cOutputPins++;
                IMemInputPin *pInputPin;
                hr = pConnected->QueryInterface(
                                              IID_IMemInputPin,
                                              (void **)&pInputPin);
                pConnected->Release();
                if (SUCCEEDED(hr)) {
                    hr = pInputPin->ReceiveCanBlock();
                    pInputPin->Release();
                    if (hr != S_FALSE) {
                        return S_OK;
                    }
                } else {
                    /*  There's a transport we don't understand here */
                    return S_OK;
                }
            }
        }
    }
    return cOutputPins == 0 ? S_OK : S_FALSE;
}

// Default handling for BeginFlush - call at the beginning
// of your implementation (makes sure that all Receive calls
// fail). After calling this, you need to free any queued data
// and then call downstream.
STDMETHODIMP
CBaseInputPin::BeginFlush(void)
{
    //  BeginFlush is NOT synchronized with streaming but is part of
    //  a control action - hence we synchronize with the filter
    CAutoLock lck(m_pLock);

    // if we are already in mid-flush, this is probably a mistake
    // though not harmful - try to pick it up for now so I can think about it
    ASSERT(!m_bFlushing);

    // first thing to do is ensure that no further Receive calls succeed
    m_bFlushing = TRUE;

    // now discard any data and call downstream - must do that
    // in derived classes
    return S_OK;
}

// default handling for EndFlush - call at end of your implementation
// - before calling this, ensure that there is no queued data and no thread
// pushing any more without a further receive, then call downstream,
// then call this method to clear the m_bFlushing flag and re-enable
// receives
STDMETHODIMP
CBaseInputPin::EndFlush(void)
{
    //  Endlush is NOT synchronized with streaming but is part of
    //  a control action - hence we synchronize with the filter
    CAutoLock lck(m_pLock);

    // almost certainly a mistake if we are not in mid-flush
    ASSERT(m_bFlushing);

    // before calling, sync with pushing thread and ensure
    // no more data is going downstream, then call EndFlush on
    // downstream pins.

    // now re-enable Receives
    m_bFlushing = FALSE;

    return S_OK;
}


STDMETHODIMP
CBaseInputPin::Notify(IBaseFilter * pSender, Quality q)
{
    UNREFERENCED_PARAMETER(q);
    CheckPointer(pSender,E_POINTER);
    ValidateReadPtr(pSender,sizeof(IBaseFilter));
    DbgBreak("IQuality::Notify called on an input pin");
    return NOERROR;
} // Notify

/* Free up or unprepare allocator's memory, this is called through
   IMediaFilter which is responsible for locking the object first */

HRESULT
CBaseInputPin::Inactive(void)
{
    m_bRunTimeError = FALSE;
    if (m_pAllocator == NULL) {
	return VFW_E_NO_ALLOCATOR;
    }

    m_bFlushing = FALSE;

    return m_pAllocator->Decommit();
}

// what requirements do we have of the allocator - override if you want
// to support other people's allocators but need a specific alignment
// or prefix.
STDMETHODIMP
CBaseInputPin::GetAllocatorRequirements(ALLOCATOR_PROPERTIES*pProps)
{
    UNREFERENCED_PARAMETER(pProps);
    return E_NOTIMPL;
}

//  Check if it's OK to process data
//
HRESULT
CBaseInputPin::CheckStreaming()
{
    //  Shouldn't be able to get any data if we're not connected!
    ASSERT(IsConnected());

    //  Don't process stuff in Stopped state
    if (IsStopped()) {
        return VFW_E_WRONG_STATE;
    }
    if (m_bFlushing) {
        return S_FALSE;
    }
    if (m_bRunTimeError) {
	return VFW_E_RUNTIME_ERROR;
    }
    return S_OK;
}

// Pass on the Quality notification q to
// a. Our QualityControl sink (if we have one) or else
// b. to our upstream filter
// and if that doesn't work, throw it away with a bad return code
HRESULT
CBaseInputPin::PassNotify(Quality& q)
{
    // We pass the message on, which means that we find the quality sink
    // for our input pin and send it there

    DbgLog((LOG_TRACE,3,TEXT("Passing Quality notification through transform")));
    if (m_pQSink!=NULL) {
        return m_pQSink->Notify(m_pFilter, q);
    } else {
        // no sink set, so pass it upstream
        HRESULT hr;
        IQualityControl * pIQC;

        hr = VFW_E_NOT_FOUND;                   // default
        if (m_Connected) {
            m_Connected->QueryInterface(IID_IQualityControl, (void**)&pIQC);

            if (pIQC!=NULL) {
                hr = pIQC->Notify(m_pFilter, q);
                pIQC->Release();
            }
        }
        return hr;
    }

} // PassNotify

//=====================================================================
//=====================================================================
// Memory allocation class, implements CMediaSample
//=====================================================================
//=====================================================================


/* NOTE The implementation of this class calls the CUnknown constructor with
   a NULL outer unknown pointer. This has the effect of making us a self
   contained class, ie any QueryInterface, AddRef or Release calls will be
   routed to the class's NonDelegatingUnknown methods. You will typically
   find that the classes that do this then override one or more of these
   virtual functions to provide more specialised behaviour. A good example
   of this is where a class wants to keep the QueryInterface internal but
   still wants it's lifetime controlled by the external object */

/* The last two parameters have default values of NULL and zero */

CMediaSample::CMediaSample(TCHAR *pName,
			   CBaseAllocator *pAllocator,
			   HRESULT *phr,
			   LPBYTE pBuffer,
			   LONG length) :
    m_pBuffer(pBuffer),             // Initialise the buffer
    m_cbBuffer(length),             // And it's length
    m_lActual(length),              // By default, actual = length
    m_pMediaType(NULL),             // No media type change
    m_dwFlags(0),                   // Nothing set
    m_cRef(0),                      // 0 ref count
    m_dwTypeSpecificFlags(0),       // Type specific flags
    m_dwStreamId(AM_STREAM_MEDIA),  // Stream id
    m_pAllocator(pAllocator)        // Allocator
{
    /* We must have an owner and it must also be derived from class
       CBaseAllocator BUT we do not hold a reference count on it */

    ASSERT(pAllocator);
}


/* Destructor deletes the media type memory */

CMediaSample::~CMediaSample()
{
    if (m_pMediaType) {
	DeleteMediaType(m_pMediaType);
    }
}

/* Override this to publicise our interfaces */

STDMETHODIMP
CMediaSample::QueryInterface(REFIID riid, void **ppv)
{
    if (riid == IID_IMediaSample ||
        riid == IID_IMediaSample2 ||
        riid == IID_IUnknown) {
	return GetInterface((IMediaSample *) this, ppv);
    } else {
	return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
CMediaSample::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// --  CMediaSample lifetimes --
//
// On final release of this sample buffer it is not deleted but
// returned to the freelist of the owning memory allocator
//
// The allocator may be waiting for the last buffer to be placed on the free
// list in order to decommit all the memory, so the ReleaseBuffer() call may
// result in this sample being deleted. We also need to hold a refcount on
// the allocator to stop that going away until we have finished with this.
// However, we cannot release the allocator before the ReleaseBuffer, as the
// release may cause us to be deleted. Similarly we can't do it afterwards.
//
// Thus we must leave it to the allocator to hold an addref on our behalf.
// When he issues us in GetBuffer, he addref's himself. When ReleaseBuffer
// is called, he releases himself, possibly causing us and him to be deleted.


STDMETHODIMP_(ULONG)
CMediaSample::Release()
{
    /* Decrement our own private reference count */
    LONG lRef;
    if (m_cRef == 1) {
        lRef = 0;
        m_cRef = 0;
    } else {
        lRef = InterlockedDecrement(&m_cRef);
    }
    ASSERT(lRef >= 0);

    DbgLog((LOG_MEMORY,3,TEXT("    Unknown %X ref-- = %d"),
	    this, m_cRef));

    /* Did we release our final reference count */
    if (lRef == 0) {
        /* Free all resources */
        if (m_dwFlags & Sample_TypeChanged) {
            SetMediaType(NULL);
        }
        ASSERT(m_pMediaType == NULL);
        m_dwFlags = 0;
        m_dwTypeSpecificFlags = 0;
        m_dwStreamId = AM_STREAM_MEDIA;

        /* This may cause us to be deleted */
        // Our refcount is reliably 0 thus no-one will mess with us
        m_pAllocator->ReleaseBuffer(this);
    }
    return (ULONG)lRef;
}


// set the buffer pointer and length. Used by allocators that
// want variable sized pointers or pointers into already-read data.
// This is only available through a CMediaSample* not an IMediaSample*
// and so cannot be changed by clients.
HRESULT
CMediaSample::SetPointer(BYTE * ptr, LONG cBytes)
{
    m_pBuffer = ptr;            // new buffer area (could be null)
    m_cbBuffer = cBytes;        // length of buffer
    m_lActual = cBytes;         // length of data in buffer (assume full)

    return S_OK;
}


// get me a read/write pointer to this buffer's memory. I will actually
// want to use sizeUsed bytes.
STDMETHODIMP
CMediaSample::GetPointer(BYTE ** ppBuffer)
{
    ValidateReadWritePtr(ppBuffer,sizeof(BYTE *));

    // creator must have set pointer either during
    // constructor or by SetPointer
    ASSERT(m_pBuffer);

    *ppBuffer = m_pBuffer;
    return NOERROR;
}


// return the size in bytes of this buffer
STDMETHODIMP_(LONG)
CMediaSample::GetSize(void)
{
    return m_cbBuffer;
}


// get the stream time at which this sample should start and finish.
STDMETHODIMP
CMediaSample::GetTime(
    REFERENCE_TIME * pTimeStart,     // put time here
    REFERENCE_TIME * pTimeEnd
)
{
    ValidateReadWritePtr(pTimeStart,sizeof(REFERENCE_TIME));
    ValidateReadWritePtr(pTimeEnd,sizeof(REFERENCE_TIME));

    if (!(m_dwFlags & Sample_StopValid)) {
        if (!(m_dwFlags & Sample_TimeValid)) {
            return VFW_E_SAMPLE_TIME_NOT_SET;
        } else {
            *pTimeStart = m_Start;

            //  Make sure old stuff works
            *pTimeEnd = m_Start + 1;
            return VFW_S_NO_STOP_TIME;
        }
    }

    *pTimeStart = m_Start;
    *pTimeEnd = m_End;
    return NOERROR;
}


// Set the stream time at which this sample should start and finish.
// NULL pointers means the time is reset
STDMETHODIMP
CMediaSample::SetTime(
    REFERENCE_TIME * pTimeStart,
    REFERENCE_TIME * pTimeEnd
)
{
    if (pTimeStart == NULL) {
        ASSERT(pTimeEnd == NULL);
        m_dwFlags &= ~(Sample_TimeValid | Sample_StopValid);
    } else {
        if (pTimeEnd == NULL) {
            m_Start = *pTimeStart;
            m_dwFlags |= Sample_TimeValid;
            m_dwFlags &= ~Sample_StopValid;
        } else {
            ValidateReadPtr(pTimeStart,sizeof(REFERENCE_TIME));
            ValidateReadPtr(pTimeEnd,sizeof(REFERENCE_TIME));
            ASSERT(*pTimeEnd >= *pTimeStart);

            m_Start = *pTimeStart;
            m_End = *pTimeEnd;
            m_dwFlags |= Sample_TimeValid | Sample_StopValid;
        }
    }
    return NOERROR;
}


// get the media times (eg bytes) for this sample
STDMETHODIMP
CMediaSample::GetMediaTime(
    LONGLONG * pTimeStart,
    LONGLONG * pTimeEnd
)
{
    ValidateReadWritePtr(pTimeStart,sizeof(LONGLONG));
    ValidateReadWritePtr(pTimeEnd,sizeof(LONGLONG));

    if (!(m_dwFlags & Sample_MediaTimeValid)) {
        return VFW_E_MEDIA_TIME_NOT_SET;
    }

    *pTimeStart = m_MediaStart;
    *pTimeEnd = (m_MediaStart + m_MediaEnd);
    return NOERROR;
}


// Set the media times for this sample
STDMETHODIMP
CMediaSample::SetMediaTime(
    LONGLONG * pTimeStart,
    LONGLONG * pTimeEnd
)
{
    if (pTimeStart == NULL) {
        ASSERT(pTimeEnd == NULL);
        m_dwFlags &= ~Sample_MediaTimeValid;
    } else {
        ValidateReadPtr(pTimeStart,sizeof(LONGLONG));
        ValidateReadPtr(pTimeEnd,sizeof(LONGLONG));
	ASSERT(*pTimeEnd >= *pTimeStart);

        m_MediaStart = *pTimeStart;
        m_MediaEnd = (LONG)(*pTimeEnd - *pTimeStart);
        m_dwFlags |= Sample_MediaTimeValid;
    }
    return NOERROR;
}


STDMETHODIMP
CMediaSample::IsSyncPoint(void)
{
    if (m_dwFlags & Sample_SyncPoint) {
	return S_OK;
    } else {
	return S_FALSE;
    }
}


STDMETHODIMP
CMediaSample::SetSyncPoint(BOOL bIsSyncPoint)
{
    if (bIsSyncPoint) {
        m_dwFlags |= Sample_SyncPoint;
    } else {
        m_dwFlags &= ~Sample_SyncPoint;
    }
    return NOERROR;
}

// returns S_OK if there is a discontinuity in the data (this same is
// not a continuation of the previous stream of data
// - there has been a seek).
STDMETHODIMP
CMediaSample::IsDiscontinuity(void)
{
    if (m_dwFlags & Sample_Discontinuity) {
	return S_OK;
    } else {
	return S_FALSE;
    }
}

// set the discontinuity property - TRUE if this sample is not a
// continuation, but a new sample after a seek.
STDMETHODIMP
CMediaSample::SetDiscontinuity(BOOL bDiscont)
{
    // should be TRUE or FALSE
    if (bDiscont) {
        m_dwFlags |= Sample_Discontinuity;
    } else {
        m_dwFlags &= ~Sample_Discontinuity;
    }
    return S_OK;
}

STDMETHODIMP
CMediaSample::IsPreroll(void)
{
    if (m_dwFlags & Sample_Preroll) {
	return S_OK;
    } else {
	return S_FALSE;
    }
}


STDMETHODIMP
CMediaSample::SetPreroll(BOOL bIsPreroll)
{
    if (bIsPreroll) {
        m_dwFlags |= Sample_Preroll;
    } else {
        m_dwFlags &= ~Sample_Preroll;
    }
    return NOERROR;
}

STDMETHODIMP_(LONG)
CMediaSample::GetActualDataLength(void)
{
    return m_lActual;
}


STDMETHODIMP
CMediaSample::SetActualDataLength(LONG lActual)
{
    if (lActual > m_cbBuffer) {
        ASSERT(lActual <= GetSize());
	return VFW_E_BUFFER_OVERFLOW;
    }
    m_lActual = lActual;
    return NOERROR;
}


/* These allow for limited format changes in band */

STDMETHODIMP
CMediaSample::GetMediaType(AM_MEDIA_TYPE **ppMediaType)
{
    ValidateReadWritePtr(ppMediaType,sizeof(AM_MEDIA_TYPE *));
    ASSERT(ppMediaType);

    /* Do we have a new media type for them */

    if (!(m_dwFlags & Sample_TypeChanged)) {
	ASSERT(m_pMediaType == NULL);
	*ppMediaType = NULL;
	return S_FALSE;
    }

    ASSERT(m_pMediaType);

    /* Create a copy of our media type */

    *ppMediaType = CreateMediaType(m_pMediaType);
    if (*ppMediaType == NULL) {
	return E_OUTOFMEMORY;
    }
    return NOERROR;
}


/* Mark this sample as having a different format type */

STDMETHODIMP
CMediaSample::SetMediaType(AM_MEDIA_TYPE *pMediaType)
{
    /* Delete the current media type */

    if (m_pMediaType) {
	DeleteMediaType(m_pMediaType);
	m_pMediaType = NULL;
    }

    /* Mechanism for resetting the format type */

    if (pMediaType == NULL) {
        m_dwFlags &= ~Sample_TypeChanged;
	return NOERROR;
    }

    ASSERT(pMediaType);
    ValidateReadPtr(pMediaType,sizeof(AM_MEDIA_TYPE));

    /* Take a copy of the media type */

    m_pMediaType = CreateMediaType(pMediaType);
    if (m_pMediaType == NULL) {
        m_dwFlags &= ~Sample_TypeChanged;
	return E_OUTOFMEMORY;
    }

    m_dwFlags |= Sample_TypeChanged;
    return NOERROR;
}

// Set and get properties (IMediaSample2)
STDMETHODIMP CMediaSample::GetProperties(
    DWORD cbProperties,
    BYTE * pbProperties
)
{
    if (0 != cbProperties) {
        CheckPointer(pbProperties, E_POINTER);
        //  Return generic stuff up to the length
        AM_SAMPLE2_PROPERTIES Props;
        Props.cbData     = min(cbProperties, sizeof(Props));
        Props.dwSampleFlags = m_dwFlags & ~Sample_MediaTimeValid;
        Props.dwTypeSpecificFlags = m_dwTypeSpecificFlags;
        Props.pbBuffer   = m_pBuffer;
        Props.cbBuffer   = m_cbBuffer;
        Props.lActual    = m_lActual;
        Props.tStart     = m_Start;
        Props.tStop      = m_End;
        Props.dwStreamId = m_dwStreamId;
        if (m_dwFlags & AM_SAMPLE_TYPECHANGED) {
            Props.pMediaType = m_pMediaType;
        } else {
            Props.pMediaType = NULL;
        }
        CopyMemory(pbProperties, &Props, Props.cbData);
    }
    return S_OK;
}

#define CONTAINS_FIELD(type, field, offset) \
    ((FIELD_OFFSET(type, field) + sizeof(((type *)0)->field)) <= offset)

HRESULT CMediaSample::SetProperties(
    DWORD cbProperties,
    const BYTE * pbProperties
)
{

    /*  Generic properties */
    AM_MEDIA_TYPE *pMediaType = NULL;

    if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, cbData, cbProperties)) {
        CheckPointer(pbProperties, E_POINTER);
        AM_SAMPLE2_PROPERTIES *pProps =
            (AM_SAMPLE2_PROPERTIES *)pbProperties;

        /*  Don't use more data than is actually there */
        if (pProps->cbData < cbProperties) {
            cbProperties = pProps->cbData;
        }
        /*  We only handle IMediaSample2 */
        if (cbProperties > sizeof(*pProps) ||
            pProps->cbData > sizeof(*pProps)) {
            return E_INVALIDARG;
        }
        /*  Do checks first, the assignments (for backout) */
        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, dwSampleFlags, cbProperties)) {
            /*  Check the flags */
            if (pProps->dwSampleFlags &
                    (~Sample_ValidFlags | Sample_MediaTimeValid)) {
                return E_INVALIDARG;
            }
            /*  Check a flag isn't being set for a property
                not being provided
            */
            if ((pProps->dwSampleFlags & AM_SAMPLE_TIMEVALID) &&
                 !(m_dwFlags & AM_SAMPLE_TIMEVALID) &&
                 !CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, tStop, cbProperties)) {
                 return E_INVALIDARG;
            }
        }
        /*  NB - can't SET the pointer or size */
        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, pbBuffer, cbProperties)) {

            /*  Check pbBuffer */
            if (pProps->pbBuffer != 0 && pProps->pbBuffer != m_pBuffer) {
                return E_INVALIDARG;
            }
        }
        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, cbBuffer, cbProperties)) {

            /*  Check cbBuffer */
            if (pProps->cbBuffer != 0 && pProps->cbBuffer != m_cbBuffer) {
                return E_INVALIDARG;
            }
        }
        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, cbBuffer, cbProperties) &&
            CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, lActual, cbProperties)) {

            /*  Check lActual */
            if (pProps->cbBuffer < pProps->lActual) {
                return E_INVALIDARG;
            }
        }

        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, pMediaType, cbProperties)) {

            /*  Check pMediaType */
            if (pProps->dwSampleFlags & AM_SAMPLE_TYPECHANGED) {
                CheckPointer(pProps->pMediaType, E_POINTER);
                pMediaType = CreateMediaType(pProps->pMediaType);
                if (pMediaType == NULL) {
                    return E_OUTOFMEMORY;
                }
            }
        }

        /*  Now do the assignments */
        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, dwStreamId, cbProperties)) {
            m_dwStreamId = pProps->dwStreamId;
        }
        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, dwSampleFlags, cbProperties)) {
            /*  Set the flags */
            m_dwFlags = pProps->dwSampleFlags |
                                (m_dwFlags & Sample_MediaTimeValid);
            m_dwTypeSpecificFlags = pProps->dwTypeSpecificFlags;
        } else {
            if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, dwTypeSpecificFlags, cbProperties)) {
                m_dwTypeSpecificFlags = pProps->dwTypeSpecificFlags;
            }
        }

        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, lActual, cbProperties)) {
            /*  Set lActual */
            m_lActual = pProps->lActual;
        }

        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, tStop, cbProperties)) {

            /*  Set the times */
            m_End   = pProps->tStop;
        }
        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, tStart, cbProperties)) {

            /*  Set the times */
            m_Start = pProps->tStart;
        }

        if (CONTAINS_FIELD(AM_SAMPLE2_PROPERTIES, pMediaType, cbProperties)) {
            /*  Set pMediaType */
            if (pProps->dwSampleFlags & AM_SAMPLE_TYPECHANGED) {
                if (m_pMediaType != NULL) {
                    DeleteMediaType(m_pMediaType);
                }
                m_pMediaType = pMediaType;
            }
        }
    }

    return S_OK;
}

//=====================================================================
//=====================================================================
// Implements CBaseAllocator
//=====================================================================
//=====================================================================


/* Constructor overrides the default settings for the free list to request
   that it be alertable (ie the list can be cast to a handle which can be
   passed to WaitForSingleObject). Both of the allocator lists also ask for
   object locking, the all list matches the object default settings but I
   have included them here just so it is obvious what kind of list it is */

CBaseAllocator::CBaseAllocator(TCHAR *pName,
			       LPUNKNOWN pUnk,
			       HRESULT *phr,
                               BOOL bEvent) :
    CUnknown(pName, pUnk),
    m_lAllocated(0),
    m_bChanged(FALSE),
    m_bCommitted(FALSE),
    m_bDecommitInProgress(FALSE),
    m_lSize(0),
    m_lCount(0),
    m_lAlignment(0),
    m_lPrefix(0),
    m_hSem(NULL),
    m_lWaiting(0)
{
    if (bEvent) {
        m_hSem = CreateSemaphore(NULL, 0, 0x7FFFFFFF, NULL);
        if (m_hSem == NULL) {
            *phr = E_OUTOFMEMORY;
            return;
        }
    }
}


/* Destructor */

CBaseAllocator::~CBaseAllocator()
{
    // we can't call Decommit here since that would mean a call to a
    // pure virtual in destructor.
    // We must assume that the derived class has gone into decommit state in
    // its destructor.
    ASSERT(!m_bCommitted);
    if (m_hSem != NULL) {
        EXECUTE_ASSERT(CloseHandle(m_hSem));
    }
}


/* Override this to publicise our interfaces */

STDMETHODIMP
CBaseAllocator::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    /* Do we know about this interface */

    if (riid == IID_IMemAllocator) {
        return GetInterface((IMemAllocator *) this, ppv);
    } else {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


/* This sets the size and count of the required samples. The memory isn't
   actually allocated until Commit() is called, if memory has already been
   allocated then assuming no samples are outstanding the user may call us
   to change the buffering, the memory will be released in Commit() */

STDMETHODIMP
CBaseAllocator::SetProperties(
                ALLOCATOR_PROPERTIES* pRequest,
                ALLOCATOR_PROPERTIES* pActual)
{
    CheckPointer(pRequest, E_POINTER);
    CheckPointer(pActual, E_POINTER);
    ValidateReadWritePtr(pActual, sizeof(ALLOCATOR_PROPERTIES));
    CAutoLock cObjectLock(this);

    ZeroMemory(pActual, sizeof(ALLOCATOR_PROPERTIES));

    ASSERT(pRequest->cbBuffer > 0);

    /*  Check the alignment requested */
    if (pRequest->cbAlign != 1) {
	DbgLog((LOG_ERROR, 2, TEXT("Alignment requested was 0x%x, not 1"),
	       pRequest->cbAlign));
	return VFW_E_BADALIGN;
    }

    /* Can't do this if already committed, there is an argument that says we
       should not reject the SetProperties call if there are buffers still
       active. However this is called by the source filter, which is the same
       person who is holding the samples. Therefore it is not unreasonable
       for them to free all their samples before changing the requirements */

    if (m_bCommitted) {
	return VFW_E_ALREADY_COMMITTED;
    }

    /* Must be no outstanding buffers */

    if (m_lAllocated != m_lFree.GetCount()) {
	return VFW_E_BUFFERS_OUTSTANDING;
    }

    /* There isn't any real need to check the parameters as they
       will just be rejected when the user finally calls Commit */

    pActual->cbBuffer = m_lSize = pRequest->cbBuffer;
    pActual->cBuffers = m_lCount = pRequest->cBuffers;
    pActual->cbAlign = m_lAlignment = pRequest->cbAlign;
    pActual->cbPrefix = m_lPrefix = pRequest->cbPrefix;

    m_bChanged = TRUE;
    return NOERROR;
}

STDMETHODIMP
CBaseAllocator::GetProperties(
    ALLOCATOR_PROPERTIES * pActual)
{
    CheckPointer(pActual,E_POINTER);
    ValidateReadWritePtr(pActual,sizeof(ALLOCATOR_PROPERTIES));

    CAutoLock cObjectLock(this);
    pActual->cbBuffer = m_lSize;
    pActual->cBuffers = m_lCount;
    pActual->cbAlign = m_lAlignment;
    pActual->cbPrefix = m_lPrefix;
    return NOERROR;
}

// get container for a sample. Blocking, synchronous call to get the
// next free buffer (as represented by an IMediaSample interface).
// on return, the time etc properties will be invalid, but the buffer
// pointer and size will be correct.

HRESULT CBaseAllocator::GetBuffer(IMediaSample **ppBuffer,
                                  REFERENCE_TIME *pStartTime,
                                  REFERENCE_TIME *pEndTime,
                                  DWORD dwFlags
                                  )
{
    UNREFERENCED_PARAMETER(pStartTime);
    UNREFERENCED_PARAMETER(pEndTime);
    UNREFERENCED_PARAMETER(dwFlags);
    CMediaSample *pSample;

    *ppBuffer = NULL;
    for (;;)
    {
        {  // scope for lock
            CAutoLock cObjectLock(this);

            /* Check we are committed */
            if (!m_bCommitted) {
                return VFW_E_NOT_COMMITTED;
            }
            pSample = (CMediaSample *) m_lFree.RemoveHead();
            if (pSample == NULL) {
                SetWaiting();
            }
        }

        /* If we didn't get a sample then wait for the list to signal */

        if (pSample) {
            break;
        }
        if (dwFlags & AM_GBF_NOWAIT) {
            return VFW_E_TIMEOUT;
        }
        ASSERT(m_hSem != NULL);
        WaitForSingleObject(m_hSem, INFINITE);
    }

    /* Addref the buffer up to one. On release
       back to zero instead of being deleted, it will requeue itself by
       calling the ReleaseBuffer member function. NOTE the owner of a
       media sample must always be derived from CBaseAllocator */


    ASSERT(pSample->m_cRef == 0);
    pSample->m_cRef = 1;
    *ppBuffer = pSample;

    return NOERROR;
}


/* Final release of a CMediaSample will call this */

STDMETHODIMP
CBaseAllocator::ReleaseBuffer(IMediaSample * pSample)
{
    CheckPointer(pSample,E_POINTER);
    ValidateReadPtr(pSample,sizeof(IMediaSample));
    BOOL bRelease = FALSE;
    {
        CAutoLock cal(this);

        /* Put back on the free list */

        m_lFree.Add((CMediaSample *)pSample);
        if (m_lWaiting != 0) {
            NotifySample();
        }

        // if there is a pending Decommit, then we need to complete it by
        // calling Free() when the last buffer is placed on the free list

    	LONG l1 = m_lFree.GetCount();
    	if (m_bDecommitInProgress && (l1 == m_lAllocated)) {
    	    Free();
    	    m_bDecommitInProgress = FALSE;
            bRelease = TRUE;
    	}
    }

    /* For each buffer there is one AddRef, made in GetBuffer and released
       here. This may cause the allocator and all samples to be deleted */

    if (bRelease) {
        Release();
    }
    return NOERROR;
}

void
CBaseAllocator::NotifySample()
{
    if (m_lWaiting != 0) {
        ASSERT(m_hSem != NULL);
        ReleaseSemaphore(m_hSem, m_lWaiting, 0);
        m_lWaiting = 0;
    }
}

STDMETHODIMP
CBaseAllocator::Commit()
{
    /* Check we are not decommitted */
    CAutoLock cObjectLock(this);

    // cannot need to alloc or re-alloc if we are committed
    if (m_bCommitted) {
        return NOERROR;
    }

    /* Allow GetBuffer calls */

    m_bCommitted = TRUE;

    // is there a pending decommit ? if so, just cancel it
    if (m_bDecommitInProgress) {
        m_bDecommitInProgress = FALSE;

        // don't call Alloc at this point. He cannot allow SetProperties
        // between Decommit and the last free, so the buffer size cannot have
        // changed. And because some of the buffers are not free yet, he
        // cannot re-alloc anyway.
        return NOERROR;
    }

    DbgLog((LOG_MEMORY, 1, TEXT("Allocating: %ldx%ld"), m_lCount, m_lSize));

    // actually need to allocate the samples
    HRESULT hr = Alloc();
    if (FAILED(hr)) {
        m_bCommitted = FALSE;
        return hr;
    }
    AddRef();
    return NOERROR;
}


STDMETHODIMP
CBaseAllocator::Decommit()
{
    BOOL bRelease = FALSE;
    {
        /* Check we are not already decommitted */
        CAutoLock cObjectLock(this);
        if (m_bCommitted == FALSE) {
            if (m_bDecommitInProgress == FALSE) {
                return NOERROR;
            }
        }

        /* No more GetBuffer calls will succeed */
        m_bCommitted = FALSE;

        // are any buffers outstanding?
        if (m_lFree.GetCount() < m_lAllocated) {
            // please complete the decommit when last buffer is freed
            m_bDecommitInProgress = TRUE;
        } else {
            m_bDecommitInProgress = FALSE;

            // need to complete the decommit here as there are no
            // outstanding buffers

            Free();
            bRelease = TRUE;
        }

        // Tell anyone waiting that they can go now so we can
        // reject their call
        NotifySample();
    }

    if (bRelease) {
        Release();
    }
    return NOERROR;
}


/* Base definition of allocation which checks we are ok to go ahead and do
   the full allocation. We return S_FALSE if the requirements are the same */

HRESULT
CBaseAllocator::Alloc(void)
{
    /* Error if he hasn't set the size yet */
    if (m_lCount <= 0 || m_lSize <= 0 || m_lAlignment <= 0) {
	return VFW_E_SIZENOTSET;
    }

    /* should never get here while buffers outstanding */
    ASSERT(m_lFree.GetCount() == m_lAllocated);

    /* If the requirements haven't changed then don't reallocate */
    if (m_bChanged == FALSE) {
	return S_FALSE;
    }

    return NOERROR;
}

/*  Implement CBaseAllocator::CSampleList::Remove(pSample)
    Removes pSample from the list
*/
void
CBaseAllocator::CSampleList::Remove(CMediaSample * pSample)
{
    CMediaSample **pSearch;
    for (pSearch = &m_List;
         *pSearch != NULL;
         pSearch = &(CBaseAllocator::NextSample(*pSearch))) {
       if (*pSearch == pSample) {
           *pSearch = CBaseAllocator::NextSample(pSample);
           CBaseAllocator::NextSample(pSample) = NULL;
           m_nOnList--;
           return;
       }
    }
    DbgBreak("Couldn't find sample in list");
}

//=====================================================================
//=====================================================================
// Implements CMemAllocator
//=====================================================================
//=====================================================================


/* This goes in the factory template table to create new instances */
CUnknown *CMemAllocator::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    CUnknown *pUnkRet = new CMemAllocator(NAME("CMemAllocator"), pUnk, phr);
    return pUnkRet;
}

CMemAllocator::CMemAllocator(
    TCHAR *pName,
    LPUNKNOWN pUnk,
    HRESULT *phr)
    : CBaseAllocator(pName, pUnk, phr),
    m_pBuffer(NULL)
{
}

/* This sets the size and count of the required samples. The memory isn't
   actually allocated until Commit() is called, if memory has already been
   allocated then assuming no samples are outstanding the user may call us
   to change the buffering, the memory will be released in Commit() */
STDMETHODIMP
CMemAllocator::SetProperties(
                ALLOCATOR_PROPERTIES* pRequest,
                ALLOCATOR_PROPERTIES* pActual)
{
    CheckPointer(pActual,E_POINTER);
    ValidateReadWritePtr(pActual,sizeof(ALLOCATOR_PROPERTIES));
    CAutoLock cObjectLock(this);

    ZeroMemory(pActual, sizeof(ALLOCATOR_PROPERTIES));

    ASSERT(pRequest->cbBuffer > 0);

    SYSTEM_INFO SysInfo;
    GetSystemInfo(&SysInfo);

    /*  Check the alignment request is a power of 2 */
    if ((-pRequest->cbAlign & pRequest->cbAlign) != pRequest->cbAlign) {
	DbgLog((LOG_ERROR, 1, TEXT("Alignment requested 0x%x not a power of 2!"),
	       pRequest->cbAlign));
    }
    /*  Check the alignment requested */
    if (pRequest->cbAlign == 0 ||
	(SysInfo.dwAllocationGranularity & (pRequest->cbAlign - 1)) != 0) {
	DbgLog((LOG_ERROR, 1, TEXT("Invalid alignment 0x%x requested - granularity = 0x%x"),
	       pRequest->cbAlign, SysInfo.dwAllocationGranularity));
	return VFW_E_BADALIGN;
    }

    /* Can't do this if already committed, there is an argument that says we
       should not reject the SetProperties call if there are buffers still
       active. However this is called by the source filter, which is the same
       person who is holding the samples. Therefore it is not unreasonable
       for them to free all their samples before changing the requirements */

    if (m_bCommitted == TRUE) {
	return VFW_E_ALREADY_COMMITTED;
    }

    /* Must be no outstanding buffers */

    if (m_lFree.GetCount() < m_lAllocated) {
	return VFW_E_BUFFERS_OUTSTANDING;
    }

    /* There isn't any real need to check the parameters as they
       will just be rejected when the user finally calls Commit */

    // round length up to alignment - remember that prefix is included in
    // the alignment
    LONG lSize = pRequest->cbBuffer + pRequest->cbPrefix;
    LONG lRemainder = lSize % pRequest->cbAlign;
    if (lRemainder != 0) {
	lSize = lSize - lRemainder + pRequest->cbAlign;
    }
    pActual->cbBuffer = m_lSize = (lSize - pRequest->cbPrefix);

    pActual->cBuffers = m_lCount = pRequest->cBuffers;
    pActual->cbAlign = m_lAlignment = pRequest->cbAlign;
    pActual->cbPrefix = m_lPrefix = pRequest->cbPrefix;

    m_bChanged = TRUE;
    return NOERROR;
}

// override this to allocate our resources when Commit is called.
//
// note that our resources may be already allocated when this is called,
// since we don't free them on Decommit. We will only be called when in
// decommit state with all buffers free.
//
// object locked by caller
HRESULT
CMemAllocator::Alloc(void)
{
    CAutoLock lck(this);

    /* Check he has called SetProperties */
    HRESULT hr = CBaseAllocator::Alloc();
    if (FAILED(hr)) {
	return hr;
    }

    /* If the requirements haven't changed then don't reallocate */
    if (hr == S_FALSE) {
	ASSERT(m_pBuffer);
	return NOERROR;
    }
    ASSERT(hr == S_OK); // we use this fact in the loop below

    /* Free the old resources */
    if (m_pBuffer) {
	ReallyFree();
    }

    /* Compute the aligned size */
    LONG lAlignedSize = m_lSize + m_lPrefix;
    if (m_lAlignment > 1) {
        LONG lRemainder = lAlignedSize % m_lAlignment;
        if (lRemainder != 0) {
            lAlignedSize += (m_lAlignment - lRemainder);
        }
    }

    /* Create the contiguous memory block for the samples
       making sure it's properly aligned (64K should be enough!)
    */
    ASSERT(lAlignedSize % m_lAlignment == 0);

    m_pBuffer = (PBYTE)VirtualAlloc(NULL,
				    m_lCount * lAlignedSize,
				    MEM_COMMIT,
				    PAGE_READWRITE);

    if (m_pBuffer == NULL) {
	return E_OUTOFMEMORY;
    }

    LPBYTE pNext = m_pBuffer;
    CMediaSample *pSample;

    ASSERT(m_lAllocated == 0);

    // Create the new samples - we have allocated m_lSize bytes for each sample
    // plus m_lPrefix bytes per sample as a prefix. We set the pointer to
    // the memory after the prefix - so that GetPointer() will return a pointer
    // to m_lSize bytes.
    for (; m_lAllocated < m_lCount; m_lAllocated++, pNext += lAlignedSize) {


	pSample = new CMediaSample(
                        NAME("Default memory media sample"),
			this,
                        &hr,
                        pNext + m_lPrefix,      // GetPointer() value
                        m_lSize);               // not including prefix

        ASSERT(SUCCEEDED(hr));
	if (pSample == NULL) {
	    return E_OUTOFMEMORY;
	}

	// This CANNOT fail
	m_lFree.Add(pSample);
    }

    m_bChanged = FALSE;
    return NOERROR;
}


// override this to free up any resources we have allocated.
// called from the base class on Decommit when all buffers have been
// returned to the free list.
//
// caller has already locked the object.

// in our case, we keep the memory until we are deleted, so
// we do nothing here. The memory is deleted in the destructor by
// calling ReallyFree()
void
CMemAllocator::Free(void)
{
    return;
}


// called from the destructor (and from Alloc if changing size/count) to
// actually free up the memory
void
CMemAllocator::ReallyFree(void)
{
    /* Should never be deleting this unless all buffers are freed */

    ASSERT(m_lAllocated == m_lFree.GetCount());

    /* Free up all the CMediaSamples */

    CMediaSample *pSample;
    for (;;) {
        pSample = m_lFree.RemoveHead();
        if (pSample != NULL) {
            delete pSample;
        } else {
            break;
        }
    }

    m_lAllocated = 0;

    // free the block of buffer memory
    if (m_pBuffer) {
	EXECUTE_ASSERT(VirtualFree(m_pBuffer, 0, MEM_RELEASE));
	m_pBuffer = NULL;
    }
}


/* Destructor frees our memory resources */

CMemAllocator::~CMemAllocator()
{
    Decommit();
    ReallyFree();
}

// ------------------------------------------------------------------------
// filter registration through IFilterMapper. used if IFilterMapper is
// not found (Quartz 1.0 install)

STDAPI
AMovieSetupRegisterFilter( const AMOVIESETUP_FILTER * const psetupdata
                         , IFilterMapper *                  pIFM
                         , BOOL                             bRegister  )
{
  DbgLog((LOG_TRACE, 3, TEXT("= AMovieSetupRegisterFilter")));

  // check we've got data
  //
  if( NULL == psetupdata ) return S_FALSE;


  // unregister filter
  // (as pins are subkeys of filter's CLSID key
  // they do not need to be removed separately).
  //
  DbgLog((LOG_TRACE, 3, TEXT("= = unregister filter")));
  HRESULT hr = pIFM->UnregisterFilter( *(psetupdata->clsID) );


  if( bRegister )
  {
    // register filter
    //
    DbgLog((LOG_TRACE, 3, TEXT("= = register filter")));
    hr = pIFM->RegisterFilter( *(psetupdata->clsID)
                             , psetupdata->strName
                             , psetupdata->dwMerit    );
    if( SUCCEEDED(hr) )
    {
      // all its pins
      //
      DbgLog((LOG_TRACE, 3, TEXT("= = register filter pins")));
      for( UINT m1=0; m1 < psetupdata->nPins; m1++ )
      {
        hr = pIFM->RegisterPin( *(psetupdata->clsID)
                              , psetupdata->lpPin[m1].strName
                              , psetupdata->lpPin[m1].bRendered
                              , psetupdata->lpPin[m1].bOutput
                              , psetupdata->lpPin[m1].bZero
                              , psetupdata->lpPin[m1].bMany
                              , *(psetupdata->lpPin[m1].clsConnectsToFilter)
                              , psetupdata->lpPin[m1].strConnectsToPin );

        if( SUCCEEDED(hr) )
        {
          // and each pin's media types
          //
          DbgLog((LOG_TRACE, 3, TEXT("= = register filter pin types")));
          for( UINT m2=0; m2 < psetupdata->lpPin[m1].nMediaTypes; m2++ )
          {
            hr = pIFM->RegisterPinType( *(psetupdata->clsID)
                                      , psetupdata->lpPin[m1].strName
                                      , *(psetupdata->lpPin[m1].lpMediaType[m2].clsMajorType)
                                      , *(psetupdata->lpPin[m1].lpMediaType[m2].clsMinorType) );
            if( FAILED(hr) ) break;
          }
          if( FAILED(hr) ) break;
        }
        if( FAILED(hr) ) break;
      }
    }
  }

  // handle one acceptable "error" - that
  // of filter not being registered!
  // (couldn't find a suitable #define'd
  // name for the error!)
  //
  if( 0x80070002 == hr)
    return NOERROR;
  else
    return hr;
}


//  Remove warnings about unreferenced inline functions
#pragma warning(disable:4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\combase.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Base class hierachy for creating COM objects, December 1994

/*

a. Derive your COM object from CUnknown

b. Make a static CreateInstance function that takes an LPUNKNOWN, an HRESULT *
   and a TCHAR *. The LPUNKNOWN defines the object to delegate IUnknown calls
   to. The HRESULT * allows error codes to be passed around constructors and
   the TCHAR * is a descriptive name that can be printed on the debugger.

   It is important that constructors only change the HRESULT * if they have
   to set an ERROR code, if it was successful then leave it alone or you may
   overwrite an error code from an object previously created.

   When you call a constructor the descriptive name should be in static store
   as we do not copy the string. To stop large amounts of memory being used
   in retail builds by all these static strings use the NAME macro,

   CMyFilter = new CImplFilter(NAME("My filter"),pUnknown,phr);
   if (FAILED(hr)) {
       return hr;
   }

   In retail builds NAME(_x_) compiles to NULL, the base CBaseObject class
   knows not to do anything with objects that don't have a name.

c. Have a constructor for your object that passes the LPUNKNOWN, HRESULT * and
   TCHAR * to the CUnknown constructor. You can set the HRESULT if you have an
   error, or just simply pass it through to the constructor.

   The object creation will fail in the class factory if the HRESULT indicates
   an error (ie FAILED(HRESULT) == TRUE)

d. Create a FactoryTemplate with your object's class id and CreateInstance
   function.

Then (for each interface) either

Multiple inheritance

1. Also derive it from ISomeInterface
2. Include DECLARE_IUNKNOWN in your class definition to declare
   implementations of QueryInterface, AddRef and Release that
   call the outer unknown
3. Override NonDelegatingQueryInterface to expose ISomeInterface by
   code something like

     if (riid == IID_ISomeInterface) {
         return GetInterface((ISomeInterface *) this, ppv);
     } else {
         return CUnknown::NonDelegatingQueryInterface(riid, ppv);
     }

4. Declare and implement the member functions of ISomeInterface.

or: Nested interfaces

1. Declare a class derived from CUnknown
2. Include DECLARE_IUNKNOWN in your class definition
3. Override NonDelegatingQueryInterface to expose ISomeInterface by
   code something like

     if (riid == IID_ISomeInterface) {
         return GetInterface((ISomeInterface *) this, ppv);
     } else {
         return CUnknown::NonDelegatingQueryInterface(riid, ppv);
     }

4. Implement the member functions of ISomeInterface. Use GetOwner() to
   access the COM object class.

And in your COM object class:

5. Make the nested class a friend of the COM object class, and declare
   an instance of the nested class as a member of the COM object class.

   NOTE that because you must always pass the outer unknown and an hResult
   to the CUnknown constructor you cannot use a default constructor, in
   other words you will have to make the member variable a pointer to the
   class and make a NEW call in your constructor to actually create it.

6. override the NonDelegatingQueryInterface with code like this:

     if (riid == IID_ISomeInterface) {
         return m_pImplFilter->
            NonDelegatingQueryInterface(IID_ISomeInterface, ppv);
     } else {
         return CUnknown::NonDelegatingQueryInterface(riid, ppv);
     }

You can have mixed classes which support some interfaces via multiple
inheritance and some via nested classes

*/

#ifndef __COMBASE__
#define __COMBASE__

// Filter Setup data structures no defined in axextend.idl

typedef REGPINTYPES
AMOVIESETUP_MEDIATYPE, * PAMOVIESETUP_MEDIATYPE, * FAR LPAMOVIESETUP_MEDIATYPE;

typedef REGFILTERPINS
AMOVIESETUP_PIN, * PAMOVIESETUP_PIN, * FAR LPAMOVIESETUP_PIN;

typedef struct _AMOVIESETUP_FILTER
{
  const CLSID * clsID;
  const WCHAR * strName;
  DWORD      dwMerit;
  UINT       nPins;
  const AMOVIESETUP_PIN * lpPin;
}
AMOVIESETUP_FILTER, * PAMOVIESETUP_FILTER, * FAR LPAMOVIESETUP_FILTER;

/* The DLLENTRY module initialises the module handle on loading */

extern HINSTANCE g_hInst;

/* On DLL load remember which platform we are running on */

extern DWORD g_amPlatform;
extern OSVERSIONINFO g_osInfo;     // Filled in by GetVersionEx

/* Version of IUnknown that is renamed to allow a class to support both
   non delegating and delegating IUnknowns in the same COM object */

#ifndef INONDELEGATINGUNKNOWN_DEFINED
DECLARE_INTERFACE(INonDelegatingUnknown)
{
    STDMETHOD(NonDelegatingQueryInterface) (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG, NonDelegatingAddRef)(THIS) PURE;
    STDMETHOD_(ULONG, NonDelegatingRelease)(THIS) PURE;
};
#define INONDELEGATINGUNKNOWN_DEFINED
#endif

typedef INonDelegatingUnknown *PNDUNKNOWN;


/* This is the base object class that supports active object counting. As
   part of the debug facilities we trace every time a C++ object is created
   or destroyed. The name of the object has to be passed up through the class
   derivation list during construction as you cannot call virtual functions
   in the constructor. The downside of all this is that every single object
   constructor has to take an object name parameter that describes it */

class CBaseObject
{

private:

    // Disable the copy constructor and assignment by default so you will get
    //   compiler errors instead of unexpected behaviour if you pass objects
    //   by value or assign objects.
    CBaseObject(const CBaseObject& objectSrc);          // no implementation
    void operator=(const CBaseObject& objectSrc);       // no implementation

private:
    static LONG m_cObjects;     /* Total number of objects active */

protected:
#ifdef DEBUG
    DWORD m_dwCookie;           /* Cookie identifying this object */
#endif


public:

    /* These increment and decrement the number of active objects */

    CBaseObject(const TCHAR *pName);
    ~CBaseObject();

    /* Call this to find if there are any CUnknown derived objects active */

    static LONG ObjectsActive() {
        return m_cObjects;
    };
};


/* An object that supports one or more COM interfaces will be based on
   this class. It supports counting of total objects for DLLCanUnloadNow
   support, and an implementation of the core non delegating IUnknown */

class AM_NOVTABLE CUnknown : public INonDelegatingUnknown,
                 public CBaseObject
{
private:
    const LPUNKNOWN m_pUnknown; /* Owner of this object */

protected:                      /* So we can override NonDelegatingRelease() */
    volatile LONG m_cRef;       /* Number of reference counts */

public:

    CUnknown(const TCHAR *pName, LPUNKNOWN pUnk);
    virtual ~CUnknown() {};

    // This is redundant, just use the other constructor
    //   as we never touch the HRESULT in this anyway
    CUnknown(TCHAR *pName, LPUNKNOWN pUnk,HRESULT *phr);

    /* Return the owner of this object */

    LPUNKNOWN GetOwner() const {
        return m_pUnknown;
    };

    /* Called from the class factory to create a new instance, it is
       pure virtual so it must be overriden in your derived class */

    /* static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *) */

    /* Non delegating unknown implementation */

    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();
};

/* Return an interface pointer to a requesting client
   performing a thread safe AddRef as necessary */

STDAPI GetInterface(LPUNKNOWN pUnk, void **ppv);

/* A function that can create a new COM object */

typedef CUnknown *(CALLBACK *LPFNNewCOMObject)(LPUNKNOWN pUnkOuter, HRESULT *phr);

/*  A function (can be NULL) which is called from the DLL entrypoint
    routine for each factory template:

    bLoading - TRUE on DLL load, FALSE on DLL unload
    rclsid   - the m_ClsID of the entry
*/
typedef void (CALLBACK *LPFNInitRoutine)(BOOL bLoading, const CLSID *rclsid);

/* Create one of these per object class in an array so that
   the default class factory code can create new instances */

class CFactoryTemplate {

public:

    const WCHAR *              m_Name;
    const CLSID *              m_ClsID;
    LPFNNewCOMObject           m_lpfnNew;
    LPFNInitRoutine            m_lpfnInit;
    const AMOVIESETUP_FILTER * m_pAMovieSetup_Filter;

    BOOL IsClassID(REFCLSID rclsid) const {
        return (IsEqualCLSID(*m_ClsID,rclsid));
    };

    CUnknown *CreateInstance(LPUNKNOWN pUnk, HRESULT *phr) const {
        CheckPointer(phr,NULL);
        return m_lpfnNew(pUnk, phr);
    };
};


/* You must override the (pure virtual) NonDelegatingQueryInterface to return
   interface pointers (using GetInterface) to the interfaces your derived
   class supports (the default implementation only supports IUnknown) */

#define DECLARE_IUNKNOWN                                        \
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv) {      \
        return GetOwner()->QueryInterface(riid,ppv);            \
    };                                                          \
    STDMETHODIMP_(ULONG) AddRef() {                             \
        return GetOwner()->AddRef();                            \
    };                                                          \
    STDMETHODIMP_(ULONG) Release() {                            \
        return GetOwner()->Release();                           \
    };



HINSTANCE	LoadOLEAut32();


#endif /* __COMBASE__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\combase.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Base class hierachy for creating COM objects, December 1994

#include <streams.h>
#pragma warning( disable : 4514 )   // Disable warnings re unused inline functions


/* Define the static member variable */

LONG CBaseObject::m_cObjects = 0;


/* Constructor */

CBaseObject::CBaseObject(const TCHAR *pName)
{
    /* Increment the number of active objects */
    InterlockedIncrement(&m_cObjects);

#ifdef DEBUG
    m_dwCookie = DbgRegisterObjectCreation(pName);
#endif
}


HINSTANCE	hlibOLEAut32;

/* Destructor */

CBaseObject::~CBaseObject()
{
    /* Decrement the number of objects active */
    if (InterlockedDecrement(&m_cObjects) == 0) {
	if (hlibOLEAut32) {
	    FreeLibrary(hlibOLEAut32);

	    hlibOLEAut32 = 0;
	}
    };

    
#ifdef DEBUG
    DbgRegisterObjectDestruction(m_dwCookie);
#endif
}

static const TCHAR szOle32Aut[]   = TEXT("OleAut32.dll");

HINSTANCE LoadOLEAut32()
{
    if (hlibOLEAut32 == 0) {

	hlibOLEAut32 = LoadLibrary(szOle32Aut);
    }

    return hlibOLEAut32;
}


/* Constructor */

// We know we use "this" in the initialization list, we also know we don't modify *phr.
#pragma warning( disable : 4355 4100 )
CUnknown::CUnknown(const TCHAR *pName, LPUNKNOWN pUnk)
: CBaseObject(pName)
/* Start the object with a reference count of zero - when the      */
/* object is queried for it's first interface this may be          */
/* incremented depending on whether or not this object is          */
/* currently being aggregated upon                                 */
, m_cRef(0)
/* Set our pointer to our IUnknown interface.                      */
/* If we have an outer, use its, otherwise use ours.               */
/* This pointer effectivly points to the owner of                  */
/* this object and can be accessed by the GetOwner() method.       */
, m_pUnknown( pUnk != 0 ? pUnk : reinterpret_cast<LPUNKNOWN>( static_cast<PNDUNKNOWN>(this) ) )
 /* Why the double cast?  Well, the inner cast is a type-safe cast */
 /* to pointer to a type from which we inherit.  The second is     */
 /* type-unsafe but works because INonDelegatingUnknown "behaves   */
 /* like" IUnknown. (Only the names on the methods change.)        */
{
    // Everything we need to do has been done in the initializer list
}

// This does the same as above except it has a useless HRESULT argument
// use the previous constructor, this is just left for compatibility...
CUnknown::CUnknown(TCHAR *pName, LPUNKNOWN pUnk,HRESULT *phr) :
    CBaseObject(pName),
    m_cRef(0),
    m_pUnknown( pUnk != 0 ? pUnk : reinterpret_cast<LPUNKNOWN>( static_cast<PNDUNKNOWN>(this) ) )
{
}
#pragma warning( default : 4355 4100 )


/* QueryInterface */

STDMETHODIMP CUnknown::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    CheckPointer(ppv,E_POINTER);
    ValidateReadWritePtr(ppv,sizeof(PVOID));

    /* We know only about IUnknown */

    if (riid == IID_IUnknown) {
        GetInterface((LPUNKNOWN) (PNDUNKNOWN) this, ppv);
        return NOERROR;
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

/* We have to ensure that we DON'T use a max macro, since these will typically   */
/* lead to one of the parameters being evaluated twice.  Since we are worried    */
/* about concurrency, we can't afford to access the m_cRef twice since we can't  */
/* afford to run the risk that its value having changed between accesses.        */
#ifdef max
    #undef max
#endif

template<class T> inline static T max( const T & a, const T & b )
{
    return a > b ? a : b;
}

/* AddRef */

STDMETHODIMP_(ULONG) CUnknown::NonDelegatingAddRef()
{
    LONG lRef = InterlockedIncrement( &m_cRef );
    ASSERT(lRef > 0);
    DbgLog((LOG_MEMORY,3,TEXT("    Obj %d ref++ = %d"),
           m_dwCookie, m_cRef));
    return max(ULONG(m_cRef), 1ul);
}


/* Release */

STDMETHODIMP_(ULONG) CUnknown::NonDelegatingRelease()
{
    /* If the reference count drops to zero delete ourselves */

    LONG lRef = InterlockedDecrement( &m_cRef );
    ASSERT(lRef >= 0);

    DbgLog((LOG_MEMORY,3,TEXT("    Object %d ref-- = %d"),
	    m_dwCookie, m_cRef));
    if (lRef == 0) {

        // COM rules say we must protect against re-entrancy.
        // If we are an aggregator and we hold our own interfaces
        // on the aggregatee, the QI for these interfaces will
        // addref ourselves. So after doing the QI we must release
        // a ref count on ourselves. Then, before releasing the
        // private interface, we must addref ourselves. When we do
        // this from the destructor here it will result in the ref
        // count going to 1 and then back to 0 causing us to
        // re-enter the destructor. Hence we add an extra refcount here
        // once we know we will delete the object.
        // for an example aggregator see filgraph\distrib.cpp.

        m_cRef++;

        delete this;
        return ULONG(0);
    } else {
        return max(ULONG(m_cRef), 1ul);
    }
}


/* Return an interface pointer to a requesting client
   performing a thread safe AddRef as necessary */

STDAPI GetInterface(LPUNKNOWN pUnk, void **ppv)
{
    CheckPointer(ppv, E_POINTER);
    *ppv = pUnk;
    pUnk->AddRef();
    return NOERROR;
}


/* Compares two interfaces and returns TRUE if they are on the same object */

BOOL WINAPI IsEqualObject(IUnknown *pFirst, IUnknown *pSecond)
{
    /*  Different objects can't have the same interface pointer for
        any interface
    */
    if (pFirst == pSecond) {
        return TRUE;
    }
    /*  OK - do it the hard way - check if they have the same
        IUnknown pointers - a single object can only have one of these
    */
    LPUNKNOWN pUnknown1;     // Retrieve the IUnknown interface
    LPUNKNOWN pUnknown2;     // Retrieve the other IUnknown interface
    HRESULT hr;              // General OLE return code

    ASSERT(pFirst);
    ASSERT(pSecond);

    /* See if the IUnknown pointers match */

    hr = pFirst->QueryInterface(IID_IUnknown,(void **) &pUnknown1);
    ASSERT(SUCCEEDED(hr));
    ASSERT(pUnknown1);

    hr = pSecond->QueryInterface(IID_IUnknown,(void **) &pUnknown2);
    ASSERT(SUCCEEDED(hr));
    ASSERT(pUnknown2);

    /* Release the extra interfaces we hold */

    pUnknown1->Release();
    pUnknown2->Release();
    return (pUnknown1 == pUnknown2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\ctlutil.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Base classes implementing IDispatch parsing for the basic control dual
// interfaces. Derive from these and implement just the custom method and
// property methods. We also implement CPosPassThru that can be used by
// renderers and transforms to pass by IMediaPosition and IMediaSeeking


#include <streams.h>
#include <limits.h>
#include "seekpt.h"

// 'bool' non standard reserved word
#pragma warning(disable:4237)


// --- CBaseDispatch implementation ----------
CBaseDispatch::~CBaseDispatch()
{
    if (m_pti) {
	m_pti->Release();
    }
}


// return 1 if we support GetTypeInfo

STDMETHODIMP
CBaseDispatch::GetTypeInfoCount(UINT * pctinfo)
{
    CheckPointer(pctinfo,E_POINTER);
    ValidateReadWritePtr(pctinfo,sizeof(UINT *));
    *pctinfo = 1;
    return S_OK;
}


typedef HRESULT (STDAPICALLTYPE *LPLOADTYPELIB)(
			    const OLECHAR FAR *szFile,
			    ITypeLib FAR* FAR* pptlib);

typedef HRESULT (STDAPICALLTYPE *LPLOADREGTYPELIB)(REFGUID rguid,
			    WORD wVerMajor,
			    WORD wVerMinor,
			    LCID lcid,
			    ITypeLib FAR* FAR* pptlib);

// attempt to find our type library

STDMETHODIMP
CBaseDispatch::GetTypeInfo(
  REFIID riid,
  UINT itinfo,
  LCID lcid,
  ITypeInfo ** pptinfo)
{
    CheckPointer(pptinfo,E_POINTER);
    ValidateReadWritePtr(pptinfo,sizeof(ITypeInfo *));
    HRESULT hr;

    *pptinfo = NULL;

    // we only support one type element
    if (0 != itinfo) {
	return TYPE_E_ELEMENTNOTFOUND;
    }

    if (NULL == pptinfo) {
	return E_POINTER;
    }

    // always look for neutral
    if (NULL == m_pti) {

	LPLOADTYPELIB	    lpfnLoadTypeLib;
	LPLOADREGTYPELIB    lpfnLoadRegTypeLib;
	ITypeLib	    *ptlib;
	HINSTANCE	    hInst;

	static const char  szTypeLib[]	  = "LoadTypeLib";
	static const char  szRegTypeLib[] = "LoadRegTypeLib";
	static const WCHAR szControl[]	  = L"control.tlb";

	//
	// Try to get the Ole32Aut.dll module handle.
	//

	hInst = LoadOLEAut32();
	if (hInst == NULL) {
	    DWORD dwError = GetLastError();
	    return HRESULT_FROM_WIN32(dwError);
	}
	lpfnLoadRegTypeLib = (LPLOADREGTYPELIB)GetProcAddress(hInst,
							      szRegTypeLib);
	if (lpfnLoadRegTypeLib == NULL) {
	    DWORD dwError = GetLastError();
	    return HRESULT_FROM_WIN32(dwError);
	}

	hr = (*lpfnLoadRegTypeLib)(LIBID_QuartzTypeLib, 1, 0, // version 1.0
				   lcid, &ptlib);

	if (FAILED(hr)) {

	    // attempt to load directly - this will fill the
	    // registry in if it finds it

	    lpfnLoadTypeLib = (LPLOADTYPELIB)GetProcAddress(hInst, szTypeLib);
	    if (lpfnLoadTypeLib == NULL) {
		DWORD dwError = GetLastError();
		return HRESULT_FROM_WIN32(dwError);
	    }

	    hr = (*lpfnLoadTypeLib)(szControl, &ptlib);
	    if (FAILED(hr)) {
		return hr;
	    }
	}

	hr = ptlib->GetTypeInfoOfGuid(
		    riid,
		    &m_pti);

	ptlib->Release();

	if (FAILED(hr)) {
	    return hr;
	}
    }

    *pptinfo = m_pti;
    m_pti->AddRef();
    return S_OK;
}


STDMETHODIMP
CBaseDispatch::GetIDsOfNames(
  REFIID riid,
  OLECHAR  ** rgszNames,
  UINT cNames,
  LCID lcid,
  DISPID * rgdispid)
{
    // although the IDispatch riid is dead, we use this to pass from
    // the interface implementation class to us the iid we are talking about.

    ITypeInfo * pti;
    HRESULT hr = GetTypeInfo(riid, 0, lcid, &pti);

    if (SUCCEEDED(hr)) {
	hr = pti->GetIDsOfNames(rgszNames, cNames, rgdispid);

	pti->Release();
    }
    return hr;
}


// --- CMediaControl implementation ---------

CMediaControl::CMediaControl(const TCHAR * name,LPUNKNOWN pUnk) :
    CUnknown(name, pUnk)
{
}

// expose our interfaces IMediaControl and IUnknown

STDMETHODIMP
CMediaControl::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    ValidateReadWritePtr(ppv,sizeof(PVOID));
    if (riid == IID_IMediaControl) {
	return GetInterface( (IMediaControl *) this, ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


// return 1 if we support GetTypeInfo

STDMETHODIMP
CMediaControl::GetTypeInfoCount(UINT * pctinfo)
{
    return m_basedisp.GetTypeInfoCount(pctinfo);
}


// attempt to find our type library

STDMETHODIMP
CMediaControl::GetTypeInfo(
  UINT itinfo,
  LCID lcid,
  ITypeInfo ** pptinfo)
{
    return m_basedisp.GetTypeInfo(
		IID_IMediaControl,
		itinfo,
		lcid,
		pptinfo);
}


STDMETHODIMP
CMediaControl::GetIDsOfNames(
  REFIID riid,
  OLECHAR  ** rgszNames,
  UINT cNames,
  LCID lcid,
  DISPID * rgdispid)
{
    return m_basedisp.GetIDsOfNames(
			IID_IMediaControl,
			rgszNames,
			cNames,
			lcid,
			rgdispid);
}


STDMETHODIMP
CMediaControl::Invoke(
  DISPID dispidMember,
  REFIID riid,
  LCID lcid,
  WORD wFlags,
  DISPPARAMS * pdispparams,
  VARIANT * pvarResult,
  EXCEPINFO * pexcepinfo,
  UINT * puArgErr)
{
    // this parameter is a dead leftover from an earlier interface
    if (IID_NULL != riid) {
	return DISP_E_UNKNOWNINTERFACE;
    }

    ITypeInfo * pti;
    HRESULT hr = GetTypeInfo(0, lcid, &pti);

    if (FAILED(hr)) {
	return hr;
    }

    hr = pti->Invoke(
	    (IMediaControl *)this,
	    dispidMember,
	    wFlags,
	    pdispparams,
	    pvarResult,
	    pexcepinfo,
	    puArgErr);

    pti->Release();
    return hr;
}


// --- CMediaEvent implementation ----------


CMediaEvent::CMediaEvent(const TCHAR * name,LPUNKNOWN pUnk) :
    CUnknown(name, pUnk)
{
}


// expose our interfaces IMediaEvent and IUnknown

STDMETHODIMP
CMediaEvent::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    ValidateReadWritePtr(ppv,sizeof(PVOID));
    if (riid == IID_IMediaEvent || riid == IID_IMediaEventEx) {
	return GetInterface( (IMediaEventEx *) this, ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


// return 1 if we support GetTypeInfo

STDMETHODIMP
CMediaEvent::GetTypeInfoCount(UINT * pctinfo)
{
    return m_basedisp.GetTypeInfoCount(pctinfo);
}


// attempt to find our type library

STDMETHODIMP
CMediaEvent::GetTypeInfo(
  UINT itinfo,
  LCID lcid,
  ITypeInfo ** pptinfo)
{
    return m_basedisp.GetTypeInfo(
		IID_IMediaEvent,
		itinfo,
		lcid,
		pptinfo);
}


STDMETHODIMP
CMediaEvent::GetIDsOfNames(
  REFIID riid,
  OLECHAR  ** rgszNames,
  UINT cNames,
  LCID lcid,
  DISPID * rgdispid)
{
    return m_basedisp.GetIDsOfNames(
			IID_IMediaEvent,
			rgszNames,
			cNames,
			lcid,
			rgdispid);
}


STDMETHODIMP
CMediaEvent::Invoke(
  DISPID dispidMember,
  REFIID riid,
  LCID lcid,
  WORD wFlags,
  DISPPARAMS * pdispparams,
  VARIANT * pvarResult,
  EXCEPINFO * pexcepinfo,
  UINT * puArgErr)
{
    // this parameter is a dead leftover from an earlier interface
    if (IID_NULL != riid) {
	return DISP_E_UNKNOWNINTERFACE;
    }

    ITypeInfo * pti;
    HRESULT hr = GetTypeInfo(0, lcid, &pti);

    if (FAILED(hr)) {
	return hr;
    }

    hr = pti->Invoke(
	    (IMediaEvent *)this,
	    dispidMember,
	    wFlags,
	    pdispparams,
	    pvarResult,
	    pexcepinfo,
	    puArgErr);

    pti->Release();
    return hr;
}


// --- CMediaPosition implementation ----------


CMediaPosition::CMediaPosition(const TCHAR * name,LPUNKNOWN pUnk) :
    CUnknown(name, pUnk)
{
}

CMediaPosition::CMediaPosition(const TCHAR * name,
                               LPUNKNOWN pUnk,
                               HRESULT * phr) :
    CUnknown(name, pUnk)
{
    UNREFERENCED_PARAMETER(phr);
}


// expose our interfaces IMediaPosition and IUnknown

STDMETHODIMP
CMediaPosition::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    ValidateReadWritePtr(ppv,sizeof(PVOID));
    if (riid == IID_IMediaPosition) {
	return GetInterface( (IMediaPosition *) this, ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


// return 1 if we support GetTypeInfo

STDMETHODIMP
CMediaPosition::GetTypeInfoCount(UINT * pctinfo)
{
    return m_basedisp.GetTypeInfoCount(pctinfo);
}


// attempt to find our type library

STDMETHODIMP
CMediaPosition::GetTypeInfo(
  UINT itinfo,
  LCID lcid,
  ITypeInfo ** pptinfo)
{
    return m_basedisp.GetTypeInfo(
		IID_IMediaPosition,
		itinfo,
		lcid,
		pptinfo);
}


STDMETHODIMP
CMediaPosition::GetIDsOfNames(
  REFIID riid,
  OLECHAR  ** rgszNames,
  UINT cNames,
  LCID lcid,
  DISPID * rgdispid)
{
    return m_basedisp.GetIDsOfNames(
			IID_IMediaPosition,
			rgszNames,
			cNames,
			lcid,
			rgdispid);
}


STDMETHODIMP
CMediaPosition::Invoke(
  DISPID dispidMember,
  REFIID riid,
  LCID lcid,
  WORD wFlags,
  DISPPARAMS * pdispparams,
  VARIANT * pvarResult,
  EXCEPINFO * pexcepinfo,
  UINT * puArgErr)
{
    // this parameter is a dead leftover from an earlier interface
    if (IID_NULL != riid) {
	return DISP_E_UNKNOWNINTERFACE;
    }

    ITypeInfo * pti;
    HRESULT hr = GetTypeInfo(0, lcid, &pti);

    if (FAILED(hr)) {
	return hr;
    }

    hr = pti->Invoke(
	    (IMediaPosition *)this,
	    dispidMember,
	    wFlags,
	    pdispparams,
	    pvarResult,
	    pexcepinfo,
	    puArgErr);

    pti->Release();
    return hr;
}


// --- IMediaPosition and IMediaSeeking pass through class ----------


CPosPassThru::CPosPassThru(const TCHAR *pName,
			   LPUNKNOWN pUnk,
			   HRESULT *phr,
			   IPin *pPin) :
    CMediaPosition(pName,pUnk),
    m_pPin(pPin)
{
    if (pPin == NULL) {
	*phr = E_POINTER;
	return;
    }
}


// Expose our IMediaSeeking and IMediaPosition interfaces

STDMETHODIMP
CPosPassThru::NonDelegatingQueryInterface(REFIID riid,void **ppv)
{
    CheckPointer(ppv,E_POINTER);
    *ppv = NULL;

    if (riid == IID_IMediaSeeking) {
	return GetInterface( static_cast<IMediaSeeking *>(this), ppv);
    }
    return CMediaPosition::NonDelegatingQueryInterface(riid,ppv);
}


// Return the IMediaPosition interface from our peer

HRESULT
CPosPassThru::GetPeer(IMediaPosition ** ppMP)
{
    *ppMP = NULL;

    IPin *pConnected;
    HRESULT hr = m_pPin->ConnectedTo(&pConnected);
    if (FAILED(hr)) {
	return E_NOTIMPL;
    }
    IMediaPosition * pMP;
    hr = pConnected->QueryInterface(IID_IMediaPosition, (void **) &pMP);
    pConnected->Release();
    if (FAILED(hr)) {
	return E_NOTIMPL;
    }

    *ppMP = pMP;
    return S_OK;
}


// Return the IMediaSeeking interface from our peer

HRESULT
CPosPassThru::GetPeerSeeking(IMediaSeeking ** ppMS)
{
    *ppMS = NULL;

    IPin *pConnected;
    HRESULT hr = m_pPin->ConnectedTo(&pConnected);
    if (FAILED(hr)) {
	return E_NOTIMPL;
    }
    IMediaSeeking * pMS;
    hr = pConnected->QueryInterface(IID_IMediaSeeking, (void **) &pMS);
    pConnected->Release();
    if (FAILED(hr)) {
	return E_NOTIMPL;
    }

    *ppMS = pMS;
    return S_OK;
}


// --- IMediaSeeking methods ----------


STDMETHODIMP
CPosPassThru::GetCapabilities(DWORD * pCaps)
{
    IMediaSeeking* pMS;
    HRESULT hr = GetPeerSeeking(&pMS);
    if (FAILED(hr)) {
	return hr;
    }

    hr = pMS->GetCapabilities(pCaps);
    pMS->Release();
    return hr;
}

STDMETHODIMP
CPosPassThru::CheckCapabilities(DWORD * pCaps)
{
    IMediaSeeking* pMS;
    HRESULT hr = GetPeerSeeking(&pMS);
    if (FAILED(hr)) {
	return hr;
    }

    hr = pMS->CheckCapabilities(pCaps);
    pMS->Release();
    return hr;
}

STDMETHODIMP
CPosPassThru::IsFormatSupported(const GUID * pFormat)
{
    IMediaSeeking* pMS;
    HRESULT hr = GetPeerSeeking(&pMS);
    if (FAILED(hr)) {
	return hr;
    }

    hr = pMS->IsFormatSupported(pFormat);
    pMS->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::QueryPreferredFormat(GUID *pFormat)
{
    IMediaSeeking* pMS;
    HRESULT hr = GetPeerSeeking(&pMS);
    if (FAILED(hr)) {
	return hr;
    }

    hr = pMS->QueryPreferredFormat(pFormat);
    pMS->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::SetTimeFormat(const GUID * pFormat)
{
    IMediaSeeking* pMS;
    HRESULT hr = GetPeerSeeking(&pMS);
    if (FAILED(hr)) {
	return hr;
    }

    hr = pMS->SetTimeFormat(pFormat);
    pMS->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::GetTimeFormat(GUID *pFormat)
{
    IMediaSeeking* pMS;
    HRESULT hr = GetPeerSeeking(&pMS);
    if (FAILED(hr)) {
	return hr;
    }

    hr = pMS->GetTimeFormat(pFormat);
    pMS->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::IsUsingTimeFormat(const GUID * pFormat)
{
    IMediaSeeking* pMS;
    HRESULT hr = GetPeerSeeking(&pMS);
    if (FAILED(hr)) {
	return hr;
    }

    hr = pMS->IsUsingTimeFormat(pFormat);
    pMS->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::ConvertTimeFormat(LONGLONG * pTarget, const GUID * pTargetFormat,
				LONGLONG    Source, const GUID * pSourceFormat )
{
    IMediaSeeking* pMS;
    HRESULT hr = GetPeerSeeking(&pMS);
    if (FAILED(hr)) {
	return hr;
    }

    hr = pMS->ConvertTimeFormat(pTarget, pTargetFormat, Source, pSourceFormat );
    pMS->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags
			  , LONGLONG * pStop, DWORD StopFlags )
{
    IMediaSeeking* pMS;
    HRESULT hr = GetPeerSeeking(&pMS);
    if (FAILED(hr)) {
	return hr;
    }

    hr = pMS->SetPositions(pCurrent, CurrentFlags, pStop, StopFlags );
    pMS->Release();
    return hr;
}

STDMETHODIMP
CPosPassThru::GetPositions(LONGLONG *pCurrent, LONGLONG * pStop)
{
    IMediaSeeking* pMS;
    HRESULT hr = GetPeerSeeking(&pMS);
    if (FAILED(hr)) {
	return hr;
    }

    hr = pMS->GetPositions(pCurrent,pStop);
    pMS->Release();
    return hr;
}

HRESULT
CPosPassThru::GetSeekingLongLong
( HRESULT (__stdcall IMediaSeeking::*pMethod)( LONGLONG * )
, LONGLONG * pll
)
{
    IMediaSeeking* pMS;
    HRESULT hr = GetPeerSeeking(&pMS);
    if (SUCCEEDED(hr))
    {
	hr = (pMS->*pMethod)(pll);
	pMS->Release();
    }
    return hr;
}

// If we don't have a current position then ask upstream

STDMETHODIMP
CPosPassThru::GetCurrentPosition(LONGLONG *pCurrent)
{
    // Can we report the current position
    HRESULT hr = GetMediaTime(pCurrent,NULL);
    if (SUCCEEDED(hr)) hr = NOERROR;
    else hr = GetSeekingLongLong( &IMediaSeeking::GetCurrentPosition, pCurrent );
    return hr;
}


STDMETHODIMP
CPosPassThru::GetStopPosition(LONGLONG *pStop)
{
    return GetSeekingLongLong( &IMediaSeeking::GetStopPosition, pStop );;
}

STDMETHODIMP
CPosPassThru::GetDuration(LONGLONG *pDuration)
{
    return GetSeekingLongLong( &IMediaSeeking::GetDuration, pDuration );;
}


STDMETHODIMP
CPosPassThru::GetPreroll(LONGLONG *pllPreroll)
{
    return GetSeekingLongLong( &IMediaSeeking::GetPreroll, pllPreroll );;
}


STDMETHODIMP
CPosPassThru::GetAvailable( LONGLONG *pEarliest, LONGLONG *pLatest )
{
    IMediaSeeking* pMS;
    HRESULT hr = GetPeerSeeking(&pMS);
    if (FAILED(hr)) {
	return hr;
    }

    hr = pMS->GetAvailable( pEarliest, pLatest );
    pMS->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::GetRate(double * pdRate)
{
    IMediaSeeking* pMS;
    HRESULT hr = GetPeerSeeking(&pMS);
    if (FAILED(hr)) {
	return hr;
    }
    hr = pMS->GetRate(pdRate);
    pMS->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::SetRate(double dRate)
{
    if (0.0 == dRate) {
		return E_INVALIDARG;
    }

    IMediaSeeking* pMS;
    HRESULT hr = GetPeerSeeking(&pMS);
    if (FAILED(hr)) {
	return hr;
    }
    hr = pMS->SetRate(dRate);
    pMS->Release();
    return hr;
}




// --- IMediaPosition methods ----------


STDMETHODIMP
CPosPassThru::get_Duration(REFTIME * plength)
{
    IMediaPosition* pMP;
    HRESULT hr = GetPeer(&pMP);
    if (FAILED(hr)) {
	return hr;
    }

    hr = pMP->get_Duration(plength);
    pMP->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::get_CurrentPosition(REFTIME * pllTime)
{
    IMediaPosition* pMP;
    HRESULT hr = GetPeer(&pMP);
    if (FAILED(hr)) {
	return hr;
    }
    hr = pMP->get_CurrentPosition(pllTime);
    pMP->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::put_CurrentPosition(REFTIME llTime)
{
    IMediaPosition* pMP;
    HRESULT hr = GetPeer(&pMP);
    if (FAILED(hr)) {
	return hr;
    }
    hr = pMP->put_CurrentPosition(llTime);
    pMP->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::get_StopTime(REFTIME * pllTime)
{
    IMediaPosition* pMP;
    HRESULT hr = GetPeer(&pMP);
    if (FAILED(hr)) {
	return hr;
    }
    hr = pMP->get_StopTime(pllTime);
    pMP->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::put_StopTime(REFTIME llTime)
{
    IMediaPosition* pMP;
    HRESULT hr = GetPeer(&pMP);
    if (FAILED(hr)) {
	return hr;
    }
    hr = pMP->put_StopTime(llTime);
    pMP->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::get_PrerollTime(REFTIME * pllTime)
{
    IMediaPosition* pMP;
    HRESULT hr = GetPeer(&pMP);
    if (FAILED(hr)) {
	return hr;
    }
    hr = pMP->get_PrerollTime(pllTime);
    pMP->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::put_PrerollTime(REFTIME llTime)
{
    IMediaPosition* pMP;
    HRESULT hr = GetPeer(&pMP);
    if (FAILED(hr)) {
	return hr;
    }
    hr = pMP->put_PrerollTime(llTime);
    pMP->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::get_Rate(double * pdRate)
{
    IMediaPosition* pMP;
    HRESULT hr = GetPeer(&pMP);
    if (FAILED(hr)) {
	return hr;
    }
    hr = pMP->get_Rate(pdRate);
    pMP->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::put_Rate(double dRate)
{
    if (0.0 == dRate) {
		return E_INVALIDARG;
    }

    IMediaPosition* pMP;
    HRESULT hr = GetPeer(&pMP);
    if (FAILED(hr)) {
	return hr;
    }
    hr = pMP->put_Rate(dRate);
    pMP->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::CanSeekForward(LONG *pCanSeekForward)
{
    IMediaPosition* pMP;
    HRESULT hr = GetPeer(&pMP);
    if (FAILED(hr)) {
	return hr;
    }
    hr = pMP->CanSeekForward(pCanSeekForward);
    pMP->Release();
    return hr;
}


STDMETHODIMP
CPosPassThru::CanSeekBackward(LONG *pCanSeekBackward)
{
    IMediaPosition* pMP;
    HRESULT hr = GetPeer(&pMP);
    if (FAILED(hr)) {
	return hr;
    }
    hr = pMP->CanSeekBackward(pCanSeekBackward);
    pMP->Release();
    return hr;
}


// --- Implements the CRendererPosPassThru class ----------


// Media times (eg current frame, field, sample etc) are passed through the
// filtergraph in media samples. When a renderer gets a sample with media
// times in it, it will call one of the RegisterMediaTime methods we expose
// (one takes an IMediaSample, the other takes the media times direct). We
// store the media times internally and return them in GetCurrentPosition.

CRendererPosPassThru::CRendererPosPassThru(const TCHAR *pName,
					   LPUNKNOWN pUnk,
					   HRESULT *phr,
					   IPin *pPin) :
    CPosPassThru(pName,pUnk,phr,pPin),
    m_StartMedia(0),
    m_EndMedia(0),
    m_bReset(TRUE)
{
}


// Sets the media times the object should report

HRESULT
CRendererPosPassThru::RegisterMediaTime(IMediaSample *pMediaSample)
{
    ASSERT(pMediaSample);
    LONGLONG StartMedia;
    LONGLONG EndMedia;

    CAutoLock cAutoLock(&m_PositionLock);

    // Get the media times from the sample

    HRESULT hr = pMediaSample->GetTime(&StartMedia,&EndMedia);
    if (FAILED(hr))
    {
	ASSERT(hr == VFW_E_SAMPLE_TIME_NOT_SET);
	return hr;
    }

    m_StartMedia = StartMedia;
    m_EndMedia = EndMedia;
    m_bReset = FALSE;
    return NOERROR;
}


// Sets the media times the object should report

HRESULT
CRendererPosPassThru::RegisterMediaTime(LONGLONG StartTime,LONGLONG EndTime)
{
    CAutoLock cAutoLock(&m_PositionLock);
    m_StartMedia = StartTime;
    m_EndMedia = EndTime;
    m_bReset = FALSE;
    return NOERROR;
}


// Return the current media times registered in the object

HRESULT
CRendererPosPassThru::GetMediaTime(LONGLONG *pStartTime,LONGLONG *pEndTime)
{
    ASSERT(pStartTime);

    CAutoLock cAutoLock(&m_PositionLock);
    if (m_bReset == TRUE) {
	return E_FAIL;
    }

    // We don't have to return the end time

    HRESULT hr = ConvertTimeFormat( pStartTime, 0, m_StartMedia, &TIME_FORMAT_MEDIA_TIME );
    if (pEndTime && SUCCEEDED(hr)) {
	hr = ConvertTimeFormat( pEndTime, 0, m_EndMedia, &TIME_FORMAT_MEDIA_TIME );
    }
    return hr;
}


// Resets the media times we hold

HRESULT
CRendererPosPassThru::ResetMediaTime()
{
    CAutoLock cAutoLock(&m_PositionLock);
    m_StartMedia = 0;
    m_EndMedia = 0;
    m_bReset = TRUE;
    return NOERROR;
}

// Intended to be called by the owing filter during EOS processing so
// that the media times can be adjusted to the stop time.  This ensures
// that the GetCurrentPosition will actully get to the stop position.
HRESULT
CRendererPosPassThru::EOS()
{
    HRESULT hr;

    if ( m_bReset == TRUE ) hr = E_FAIL;
    else
    {
	LONGLONG llStop;
	if SUCCEEDED(hr=GetStopPosition(&llStop))
	{
	    CAutoLock cAutoLock(&m_PositionLock);
	    m_StartMedia =
	    m_EndMedia	 = llStop;
	}
    }
    return hr;
}

// -- CSourceSeeking implementation ------------

CSourceSeeking::CSourceSeeking(
    const TCHAR * pName,
    LPUNKNOWN pUnk,
    HRESULT* phr,
    CCritSec * pLock) :
        CUnknown(pName, pUnk),
        m_pLock(pLock),
        m_rtStart((long)0)
{
    m_rtStop = _I64_MAX / 2;
    m_rtDuration = m_rtStop;
    m_dRateSeeking = 1.0;

    m_dwSeekingCaps = AM_SEEKING_CanSeekForwards
        | AM_SEEKING_CanSeekBackwards
        | AM_SEEKING_CanSeekAbsolute
        | AM_SEEKING_CanGetStopPos
        | AM_SEEKING_CanGetDuration;
}

HRESULT CSourceSeeking::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if(riid == IID_IMediaSeeking) {
        CheckPointer(ppv, E_POINTER);
        return GetInterface(static_cast<IMediaSeeking *>(this), ppv);
    }
    else {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}
    

HRESULT CSourceSeeking::IsFormatSupported(const GUID * pFormat)
{
    CheckPointer(pFormat, E_POINTER);
    // only seeking in time (REFERENCE_TIME units) is supported
    return *pFormat == TIME_FORMAT_MEDIA_TIME ? S_OK : S_FALSE;
}

HRESULT CSourceSeeking::QueryPreferredFormat(GUID *pFormat)
{
    CheckPointer(pFormat, E_POINTER);
    *pFormat = TIME_FORMAT_MEDIA_TIME;
    return S_OK;
}

HRESULT CSourceSeeking::SetTimeFormat(const GUID * pFormat)
{
    CheckPointer(pFormat, E_POINTER);

    // nothing to set; just check that it's TIME_FORMAT_TIME
    return *pFormat == TIME_FORMAT_MEDIA_TIME ? S_OK : E_INVALIDARG;
}

HRESULT CSourceSeeking::IsUsingTimeFormat(const GUID * pFormat)
{
    CheckPointer(pFormat, E_POINTER);
    return *pFormat == TIME_FORMAT_MEDIA_TIME ? S_OK : S_FALSE;
}

HRESULT CSourceSeeking::GetTimeFormat(GUID *pFormat)
{
    CheckPointer(pFormat, E_POINTER);
    *pFormat = TIME_FORMAT_MEDIA_TIME;
    return S_OK;
}

HRESULT CSourceSeeking::GetDuration(LONGLONG *pDuration)
{
    CheckPointer(pDuration, E_POINTER);
    CAutoLock lock(m_pLock);
    *pDuration = m_rtDuration;
    return S_OK;
}

HRESULT CSourceSeeking::GetStopPosition(LONGLONG *pStop)
{
    CheckPointer(pStop, E_POINTER);
    CAutoLock lock(m_pLock);
    *pStop = m_rtStop;
    return S_OK;
}

HRESULT CSourceSeeking::GetCurrentPosition(LONGLONG *pCurrent)
{
    // GetCurrentPosition is typically supported only in renderers and
    // not in source filters.
    return E_NOTIMPL;
}

HRESULT CSourceSeeking::GetCapabilities( DWORD * pCapabilities )
{
    CheckPointer(pCapabilities, E_POINTER);
    *pCapabilities = m_dwSeekingCaps;
    return S_OK;
}

HRESULT CSourceSeeking::CheckCapabilities( DWORD * pCapabilities )
{
    CheckPointer(pCapabilities, E_POINTER);

    // make sure all requested capabilities are in our mask
    return (~m_dwSeekingCaps & *pCapabilities) ? S_FALSE : S_OK;
}

HRESULT CSourceSeeking::ConvertTimeFormat( LONGLONG * pTarget, const GUID * pTargetFormat,
                           LONGLONG    Source, const GUID * pSourceFormat )
{
    CheckPointer(pTarget, E_POINTER);
    // format guids can be null to indicate current format

    // since we only support TIME_FORMAT_MEDIA_TIME, we don't really
    // offer any conversions.
    if(pTargetFormat == 0 || *pTargetFormat == TIME_FORMAT_MEDIA_TIME)
    {
        if(pSourceFormat == 0 || *pSourceFormat == TIME_FORMAT_MEDIA_TIME)
        {
            *pTarget = Source;
            return S_OK;
        }
    }
    
    return E_INVALIDARG;
}


HRESULT CSourceSeeking::SetPositions( LONGLONG * pCurrent,  DWORD CurrentFlags
                      , LONGLONG * pStop,  DWORD StopFlags )
{
    DWORD StopPosBits = StopFlags & AM_SEEKING_PositioningBitsMask;
    DWORD StartPosBits = CurrentFlags & AM_SEEKING_PositioningBitsMask;

    if(StopFlags) {
        CheckPointer(pStop, E_POINTER);

        // accept only relative, incremental, or absolute positioning
        if(StopPosBits != StopFlags) {
            return E_INVALIDARG;
        }
    }

    if(CurrentFlags) {
        CheckPointer(pCurrent, E_POINTER);
        if(StartPosBits != AM_SEEKING_AbsolutePositioning &&
           StartPosBits != AM_SEEKING_RelativePositioning) {
            return E_INVALIDARG;
        }
    }


    // scope for autolock
    {
        CAutoLock lock(m_pLock);

        // set start position
        if(StartPosBits == AM_SEEKING_AbsolutePositioning)
        {
            m_rtStart = *pCurrent;
        }
        else if(StartPosBits == AM_SEEKING_RelativePositioning)
        {
            m_rtStart += *pCurrent;
        }

        // set stop position
        if(StopPosBits == AM_SEEKING_AbsolutePositioning)
        {
            m_rtStop = *pStop;
        }
        else if(StopPosBits == AM_SEEKING_IncrementalPositioning)
        {
            m_rtStop = m_rtStart + *pStop;
        }
        else if(StopPosBits == AM_SEEKING_RelativePositioning)
        {
            m_rtStop = m_rtStop + *pStop;
        }
    }


    HRESULT hr = S_OK;
    if(SUCCEEDED(hr) && StopPosBits) {
        hr = ChangeStop();
    }
    if(StartPosBits) {
        hr = ChangeStart();
    }

    return hr;
}


HRESULT CSourceSeeking::GetPositions( LONGLONG * pCurrent, LONGLONG * pStop )
{
    if(pCurrent) {
        *pCurrent = m_rtStart;
    }
    if(pStop) {
        *pStop = m_rtStop;
    }
    
    return S_OK;;
}


HRESULT CSourceSeeking::GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest )
{
    if(pEarliest) {
        *pEarliest = 0;
    }
    if(pLatest) {
        CAutoLock lock(m_pLock);
        *pLatest = m_rtDuration;
    }
    return S_OK;
}

HRESULT CSourceSeeking::SetRate( double dRate)
{
    {
        CAutoLock lock(m_pLock);
        m_dRateSeeking = dRate;
    }
    return ChangeRate();
}

HRESULT CSourceSeeking::GetRate( double * pdRate)
{
    CheckPointer(pdRate, E_POINTER);
    CAutoLock lock(m_pLock);
    *pdRate = m_dRateSeeking;
    return S_OK;
}

HRESULT CSourceSeeking::GetPreroll(LONGLONG *pPreroll) 
{
    CheckPointer(pPreroll, E_POINTER);
    *pPreroll = 0;
    return S_OK;
}





// --- CSourcePosition implementation ----------


CSourcePosition::CSourcePosition(const TCHAR * pName,
				 LPUNKNOWN pUnk,
				 HRESULT* phr,
				 CCritSec * pLock) :
    CMediaPosition(pName, pUnk),
    m_pLock(pLock),
    m_Start(CRefTime((LONGLONG)0))
{
    m_Stop = _I64_MAX;
    m_Rate = 1.0;
}


STDMETHODIMP
CSourcePosition::get_Duration(REFTIME * plength)
{
    CheckPointer(plength,E_POINTER);
    ValidateReadWritePtr(plength,sizeof(REFTIME));
    CAutoLock lock(m_pLock);

    *plength = m_Duration;
    return S_OK;
}


STDMETHODIMP
CSourcePosition::put_CurrentPosition(REFTIME llTime)
{
    m_pLock->Lock();
    m_Start = llTime;
    m_pLock->Unlock();

    return ChangeStart();
}


STDMETHODIMP
CSourcePosition::get_StopTime(REFTIME * pllTime)
{
    CheckPointer(pllTime,E_POINTER);
    ValidateReadWritePtr(pllTime,sizeof(REFTIME));
    CAutoLock lock(m_pLock);

    *pllTime = m_Stop;
    return S_OK;
}


STDMETHODIMP
CSourcePosition::put_StopTime(REFTIME llTime)
{
    m_pLock->Lock();
    m_Stop = llTime;
    m_pLock->Unlock();

    return ChangeStop();
}


STDMETHODIMP
CSourcePosition::get_PrerollTime(REFTIME * pllTime)
{
    CheckPointer(pllTime,E_POINTER);
    ValidateReadWritePtr(pllTime,sizeof(REFTIME));
    return E_NOTIMPL;
}


STDMETHODIMP
CSourcePosition::put_PrerollTime(REFTIME llTime)
{
    return E_NOTIMPL;
}


STDMETHODIMP
CSourcePosition::get_Rate(double * pdRate)
{
    CheckPointer(pdRate,E_POINTER);
    ValidateReadWritePtr(pdRate,sizeof(double));
    CAutoLock lock(m_pLock);

    *pdRate = m_Rate;
    return S_OK;
}


STDMETHODIMP
CSourcePosition::put_Rate(double dRate)
{
    m_pLock->Lock();
    m_Rate = dRate;
    m_pLock->Unlock();

    return ChangeRate();
}


// By default we can seek forwards

STDMETHODIMP
CSourcePosition::CanSeekForward(LONG *pCanSeekForward)
{
    CheckPointer(pCanSeekForward,E_POINTER);
    *pCanSeekForward = OATRUE;
    return S_OK;
}


// By default we can seek backwards

STDMETHODIMP
CSourcePosition::CanSeekBackward(LONG *pCanSeekBackward)
{
    CheckPointer(pCanSeekBackward,E_POINTER);
    *pCanSeekBackward = OATRUE;
    return S_OK;
}


// --- Implementation of CBasicAudio class ----------


CBasicAudio::CBasicAudio(const TCHAR * pName,LPUNKNOWN punk) :
    CUnknown(pName, punk)
{
}

// overriden to publicise our interfaces

STDMETHODIMP
CBasicAudio::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    ValidateReadWritePtr(ppv,sizeof(PVOID));
    if (riid == IID_IBasicAudio) {
	return GetInterface( (IBasicAudio *) this, ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


STDMETHODIMP
CBasicAudio::GetTypeInfoCount(UINT * pctinfo)
{
    return m_basedisp.GetTypeInfoCount(pctinfo);
}


STDMETHODIMP
CBasicAudio::GetTypeInfo(
  UINT itinfo,
  LCID lcid,
  ITypeInfo ** pptinfo)
{
    return m_basedisp.GetTypeInfo(
		IID_IBasicAudio,
		itinfo,
		lcid,
		pptinfo);
}


STDMETHODIMP
CBasicAudio::GetIDsOfNames(
  REFIID riid,
  OLECHAR  ** rgszNames,
  UINT cNames,
  LCID lcid,
  DISPID * rgdispid)
{
    return m_basedisp.GetIDsOfNames(
			IID_IBasicAudio,
			rgszNames,
			cNames,
			lcid,
			rgdispid);
}


STDMETHODIMP
CBasicAudio::Invoke(
  DISPID dispidMember,
  REFIID riid,
  LCID lcid,
  WORD wFlags,
  DISPPARAMS * pdispparams,
  VARIANT * pvarResult,
  EXCEPINFO * pexcepinfo,
  UINT * puArgErr)
{
    // this parameter is a dead leftover from an earlier interface
    if (IID_NULL != riid) {
	return DISP_E_UNKNOWNINTERFACE;
    }

    ITypeInfo * pti;
    HRESULT hr = GetTypeInfo(0, lcid, &pti);

    if (FAILED(hr)) {
	return hr;
    }

    hr = pti->Invoke(
	    (IBasicAudio *)this,
	    dispidMember,
	    wFlags,
	    pdispparams,
	    pvarResult,
	    pexcepinfo,
	    puArgErr);

    pti->Release();
    return hr;
}


// --- IVideoWindow implementation ----------

CBaseVideoWindow::CBaseVideoWindow(const TCHAR * pName,LPUNKNOWN punk) :
    CUnknown(pName, punk)
{
}


// overriden to publicise our interfaces

STDMETHODIMP
CBaseVideoWindow::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    ValidateReadWritePtr(ppv,sizeof(PVOID));
    if (riid == IID_IVideoWindow) {
	return GetInterface( (IVideoWindow *) this, ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


STDMETHODIMP
CBaseVideoWindow::GetTypeInfoCount(UINT * pctinfo)
{
    return m_basedisp.GetTypeInfoCount(pctinfo);
}


STDMETHODIMP
CBaseVideoWindow::GetTypeInfo(
  UINT itinfo,
  LCID lcid,
  ITypeInfo ** pptinfo)
{
    return m_basedisp.GetTypeInfo(
		IID_IVideoWindow,
		itinfo,
		lcid,
		pptinfo);
}


STDMETHODIMP
CBaseVideoWindow::GetIDsOfNames(
  REFIID riid,
  OLECHAR  ** rgszNames,
  UINT cNames,
  LCID lcid,
  DISPID * rgdispid)
{
    return m_basedisp.GetIDsOfNames(
			IID_IVideoWindow,
			rgszNames,
			cNames,
			lcid,
			rgdispid);
}


STDMETHODIMP
CBaseVideoWindow::Invoke(
  DISPID dispidMember,
  REFIID riid,
  LCID lcid,
  WORD wFlags,
  DISPPARAMS * pdispparams,
  VARIANT * pvarResult,
  EXCEPINFO * pexcepinfo,
  UINT * puArgErr)
{
    // this parameter is a dead leftover from an earlier interface
    if (IID_NULL != riid) {
	return DISP_E_UNKNOWNINTERFACE;
    }

    ITypeInfo * pti;
    HRESULT hr = GetTypeInfo(0, lcid, &pti);

    if (FAILED(hr)) {
	return hr;
    }

    hr = pti->Invoke(
	    (IVideoWindow *)this,
	    dispidMember,
	    wFlags,
	    pdispparams,
	    pvarResult,
	    pexcepinfo,
	    puArgErr);

    pti->Release();
    return hr;
}


// --- IBasicVideo implementation ----------


CBaseBasicVideo::CBaseBasicVideo(const TCHAR * pName,LPUNKNOWN punk) :
    CUnknown(pName, punk)
{
}


// overriden to publicise our interfaces

STDMETHODIMP
CBaseBasicVideo::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    ValidateReadWritePtr(ppv,sizeof(PVOID));
    if (riid == IID_IBasicVideo || riid == IID_IBasicVideo2) {
	return GetInterface( static_cast<IBasicVideo2 *>(this), ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


STDMETHODIMP
CBaseBasicVideo::GetTypeInfoCount(UINT * pctinfo)
{
    return m_basedisp.GetTypeInfoCount(pctinfo);
}


STDMETHODIMP
CBaseBasicVideo::GetTypeInfo(
  UINT itinfo,
  LCID lcid,
  ITypeInfo ** pptinfo)
{
    return m_basedisp.GetTypeInfo(
		IID_IBasicVideo,
		itinfo,
		lcid,
		pptinfo);
}


STDMETHODIMP
CBaseBasicVideo::GetIDsOfNames(
  REFIID riid,
  OLECHAR  ** rgszNames,
  UINT cNames,
  LCID lcid,
  DISPID * rgdispid)
{
    return m_basedisp.GetIDsOfNames(
			IID_IBasicVideo,
			rgszNames,
			cNames,
			lcid,
			rgdispid);
}


STDMETHODIMP
CBaseBasicVideo::Invoke(
  DISPID dispidMember,
  REFIID riid,
  LCID lcid,
  WORD wFlags,
  DISPPARAMS * pdispparams,
  VARIANT * pvarResult,
  EXCEPINFO * pexcepinfo,
  UINT * puArgErr)
{
    // this parameter is a dead leftover from an earlier interface
    if (IID_NULL != riid) {
	return DISP_E_UNKNOWNINTERFACE;
    }

    ITypeInfo * pti;
    HRESULT hr = GetTypeInfo(0, lcid, &pti);

    if (FAILED(hr)) {
	return hr;
    }

    hr = pti->Invoke(
	    (IBasicVideo *)this,
	    dispidMember,
	    wFlags,
	    pdispparams,
	    pvarResult,
	    pexcepinfo,
	    puArgErr);

    pti->Release();
    return hr;
}


// --- Implementation of Deferred Commands ----------


CDispParams::CDispParams(UINT nArgs, VARIANT* pArgs)
{
   cNamedArgs = 0;
   rgdispidNamedArgs = NULL;
   cArgs = nArgs;

    if (cArgs) {
	rgvarg = new VARIANT[cArgs];

	for (UINT i = 0; i < cArgs; i++) {

	    VARIANT * pDest = &rgvarg[i];
	    VARIANT * pSrc = &pArgs[i];

	    pDest->vt = pSrc->vt;
	    switch(pDest->vt) {

	    case VT_I4:
		pDest->lVal = pSrc->lVal;
		break;

	    case VT_UI1:
		pDest->bVal = pSrc->bVal;
		break;

	    case VT_I2:
		pDest->iVal = pSrc->iVal;
		break;

	    case VT_R4:
		pDest->fltVal = pSrc->fltVal;
		break;

	    case VT_R8:
		pDest->dblVal = pSrc->dblVal;
		break;

	    case VT_BOOL:
		pDest->boolVal = pSrc->boolVal;
		break;

	    case VT_ERROR:
		pDest->scode = pSrc->scode;
		break;

	    case VT_CY:
		pDest->cyVal = pSrc->cyVal;
		break;

	    case VT_DATE:
		pDest->date = pSrc->date;
		break;

	    case VT_BSTR:
		if (pSrc->bstrVal == NULL) {
		    pDest->bstrVal = NULL;
		} else {

		    // a BSTR is a WORD followed by a UNICODE string.
		    // the pointer points just after the WORD

		    WORD len = * (WORD*) (pSrc->bstrVal - (sizeof(WORD) / sizeof(OLECHAR)));
		    OLECHAR* pch = new OLECHAR[len + (sizeof(WORD)/sizeof(OLECHAR))];
		    WORD *pui = (WORD*)pch;
		    *pui = len;
		    pDest->bstrVal = pch + (sizeof(WORD)/sizeof(OLECHAR));
		    CopyMemory(pDest->bstrVal, pSrc->bstrVal, len*sizeof(OLECHAR));
		}
		pDest->bstrVal = pSrc->bstrVal;
		break;

	    case VT_UNKNOWN:
		pDest->punkVal = pSrc->punkVal;
		pDest->punkVal->AddRef();
		break;

	    case VT_DISPATCH:
		pDest->pdispVal = pSrc->pdispVal;
		pDest->pdispVal->AddRef();
		break;

	    default:
		// a type we haven't got round to adding yet!
		ASSERT(0);
		break;
	    }
	}

    } else {
	rgvarg = NULL;
    }

}


CDispParams::~CDispParams()
{
    for (UINT i = 0; i < cArgs; i++) {
	switch(rgvarg[i].vt) {
	case VT_BSTR:
	    if (rgvarg[i].bstrVal != NULL) {
		OLECHAR * pch = rgvarg[i].bstrVal - (sizeof(WORD)/sizeof(OLECHAR));
		delete pch;
	    }
	    break;

	case VT_UNKNOWN:
	    rgvarg[i].punkVal->Release();
	    break;

	case VT_DISPATCH:
	    rgvarg[i].pdispVal->Release();
	    break;
	}
    }
    delete[] rgvarg;
}


// lifetime is controlled by refcounts (see defer.h)

CDeferredCommand::CDeferredCommand(
    CCmdQueue * pQ,
    LPUNKNOWN	pUnk,
    HRESULT *	phr,
    LPUNKNOWN	pUnkExecutor,
    REFTIME	time,
    GUID*	iid,
    long	dispidMethod,
    short	wFlags,
    long	nArgs,
    VARIANT*	pDispParams,
    VARIANT*	pvarResult,
    short*	puArgErr,
    BOOL	bStream
    ) :
	CUnknown(NAME("DeferredCommand"), pUnk),
	m_pQueue(pQ),
	m_pUnk(pUnkExecutor),
	m_iid(iid),
	m_dispidMethod(dispidMethod),
	m_wFlags(wFlags),
	m_DispParams(nArgs, pDispParams),
	m_pvarResult(pvarResult),
	m_bStream(bStream),
	m_hrResult(E_ABORT)

{
    // convert REFTIME to REFERENCE_TIME
    COARefTime convertor(time);
    m_time = convertor;

    // no check of time validity - it's ok to queue a command that's
    // already late

    // check iid is supportable on pUnk by QueryInterface for it
    IUnknown * pInterface;
    HRESULT hr = m_pUnk->QueryInterface(GetIID(), (void**) &pInterface);
    if (FAILED(hr)) {
	*phr = hr;
	return;
    }
    pInterface->Release();


    // !!! check dispidMethod and param/return types using typelib
    ITypeInfo *pti;
    hr = m_Dispatch.GetTypeInfo(*iid, 0, 0, &pti);
    if (FAILED(hr)) {
	*phr = hr;
	return;
    }
    // !!! some sort of ITypeInfo validity check here
    pti->Release();


    // Fix up the dispid for put and get
    if (wFlags == DISPATCH_PROPERTYPUT) {
        m_DispParams.cNamedArgs = 1;
        m_DispId = DISPID_PROPERTYPUT;
        m_DispParams.rgdispidNamedArgs = &m_DispId;
    }

    // all checks ok - add to queue
    hr = pQ->Insert(this);
    if (FAILED(hr)) {
	*phr = hr;
    }
}


// refcounts are held by caller of InvokeAt... and by list. So if
// we get here, we can't be on the list

#if 0
CDeferredCommand::~CDeferredCommand()
{
    // this assert is invalid since if the queue is deleted while we are
    // still on the queue, we will have been removed by the queue and this
    // m_pQueue will not have been modified.
    // ASSERT(m_pQueue == NULL);

    // we don't hold a ref count on pUnk, which is the object that should
    // execute the command.
    // This is because there would otherwise be a circular refcount problem
    // since pUnk probably owns the CmdQueue object that has a refcount
    // on us.
    // The lifetime of pUnk is guaranteed by it being part of, or lifetime
    // controlled by, our parent object. As long as we are on the list, pUnk
    // must be valid. Once we are off the list, we do not use pUnk.

}
#endif


// overriden to publicise our interfaces

STDMETHODIMP
CDeferredCommand::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    ValidateReadWritePtr(ppv,sizeof(PVOID));
    if (riid == IID_IDeferredCommand) {
	return GetInterface( (IDeferredCommand *) this, ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


// remove from q. this will reduce the refcount by one (since the q
// holds a count) but can't make us go away since he must have a
// refcount in order to call this method.

STDMETHODIMP
CDeferredCommand::Cancel()
{
    if (m_pQueue == NULL) {
	return VFW_E_ALREADY_CANCELLED;
    }

    HRESULT hr = m_pQueue->Remove(this);
    if (FAILED(hr)) {
	return hr;
    }

    m_pQueue = NULL;
    return S_OK;
}


STDMETHODIMP
CDeferredCommand::Confidence(LONG* pConfidence)
{
    return E_NOTIMPL;
}


STDMETHODIMP
CDeferredCommand::GetHResult(HRESULT * phrResult)
{
    CheckPointer(phrResult,E_POINTER);
    ValidateReadWritePtr(phrResult,sizeof(HRESULT));

    if (m_pQueue != NULL) {
	return E_ABORT;
    }
    *phrResult = m_hrResult;
    return S_OK;
}


// set the time to be a new time (checking that it is valid) and
// then requeue

STDMETHODIMP
CDeferredCommand::Postpone(REFTIME newtime)
{

    // check that this time is not past
    // convert REFTIME to REFERENCE_TIME
    COARefTime convertor(newtime);

    // check that the time has not passed
    if (m_pQueue->CheckTime(convertor, IsStreamTime())) {
	return VFW_E_TIME_ALREADY_PASSED;
    }

    // extract from list
    HRESULT hr = m_pQueue->Remove(this);
    if (FAILED(hr)) {
	return hr;
    }

    // change time
    m_time = convertor;

    // requeue
    hr = m_pQueue->Insert(this);

    return hr;
}


HRESULT
CDeferredCommand::Invoke()
{
    // check that we are still outstanding
    if (m_pQueue == NULL) {
	return VFW_E_ALREADY_CANCELLED;
    }

    // get the type info
    ITypeInfo* pti;
    HRESULT hr = m_Dispatch.GetTypeInfo(GetIID(), 0, 0, &pti);
    if (FAILED(hr)) {
	return hr;
    }

    // qi for the expected interface and then invoke it. Note that we have to
    // treat the returned interface as IUnknown since we don't know its type.
    IUnknown* pInterface;

    hr = m_pUnk->QueryInterface(GetIID(), (void**) &pInterface);
    if (FAILED(hr)) {
	pti->Release();
	return hr;
    }

    EXCEPINFO expinfo;
    UINT uArgErr;
    m_hrResult = pti->Invoke(
	pInterface,
	GetMethod(),
	GetFlags(),
	GetParams(),
	GetResult(),
	&expinfo,
	&uArgErr);

    // release the interface we QI'd for
    pInterface->Release();
    pti->Release();


    // remove from list whether or not successful
    // or we loop indefinitely
    hr = m_pQueue->Remove(this);
    m_pQueue = NULL;
    return hr;
}



// --- CCmdQueue methods ----------


CCmdQueue::CCmdQueue() :
    m_listPresentation(NAME("Presentation time command list")),
    m_listStream(NAME("Stream time command list")),
    m_evDue(TRUE),    // manual reset
    m_dwAdvise(0),
    m_pClock(NULL),
    m_bRunning(FALSE)
{
}


CCmdQueue::~CCmdQueue()
{
    // empty all our lists

    // we hold a refcount on each, so traverse and Release each
    // entry then RemoveAll to empty the list
    POSITION pos = m_listPresentation.GetHeadPosition();

    while(pos) {
	CDeferredCommand* pCmd = m_listPresentation.GetNext(pos);
	pCmd->Release();
    }
    m_listPresentation.RemoveAll();

    pos = m_listStream.GetHeadPosition();

    while(pos) {
	CDeferredCommand* pCmd = m_listStream.GetNext(pos);
	pCmd->Release();
    }
    m_listStream.RemoveAll();

    if (m_pClock) {
	if (m_dwAdvise) {
	    m_pClock->Unadvise(m_dwAdvise);
	    m_dwAdvise = 0;
	}
	m_pClock->Release();
    }
}


// returns a new CDeferredCommand object that will be initialised with
// the parameters and will be added to the queue during construction.
// returns S_OK if successfully created otherwise an error and
// no object has been queued.

HRESULT
CCmdQueue::New(
    CDeferredCommand **ppCmd,
    LPUNKNOWN	pUnk,		// this object will execute command
    REFTIME	time,
    GUID*	iid,
    long	dispidMethod,
    short	wFlags,
    long	cArgs,
    VARIANT*	pDispParams,
    VARIANT*	pvarResult,
    short*	puArgErr,
    BOOL	bStream
)
{
    CAutoLock lock(&m_Lock);

    HRESULT hr = S_OK;
    *ppCmd = NULL;

    CDeferredCommand* pCmd;
    pCmd = new CDeferredCommand(
		    this,
		    NULL,	    // not aggregated
		    &hr,
		    pUnk,	    // this guy will execute
		    time,
		    iid,
		    dispidMethod,
		    wFlags,
		    cArgs,
		    pDispParams,
		    pvarResult,
		    puArgErr,
		    bStream);

    if (pCmd == NULL) {
	hr = E_OUTOFMEMORY;
    } else {
	*ppCmd = pCmd;
    }
    return hr;
}


HRESULT
CCmdQueue::Insert(CDeferredCommand* pCmd)
{
    CAutoLock lock(&m_Lock);

    // addref the item
    pCmd->AddRef();

    CGenericList<CDeferredCommand> * pList;
    if (pCmd->IsStreamTime()) {
	pList = &m_listStream;
    } else {
	pList = &m_listPresentation;
    }
    POSITION pos = pList->GetHeadPosition();

    // seek past all items that are before us
    while (pos &&
	(pList->Get(pos)->GetTime() <= pCmd->GetTime())) {

	pList->GetNext(pos);
    }

    // now at end of list or in front of items that come later
    if (!pos) {
	pList->AddTail(pCmd);
    } else {
	pList->AddBefore(pos, pCmd);
    }

    SetTimeAdvise();
    return S_OK;
}


HRESULT
CCmdQueue::Remove(CDeferredCommand* pCmd)
{
    CAutoLock lock(&m_Lock);
    HRESULT hr = S_OK;

    CGenericList<CDeferredCommand> * pList;
    if (pCmd->IsStreamTime()) {
	pList = &m_listStream;
    } else {
	pList = &m_listPresentation;
    }
    POSITION pos = pList->GetHeadPosition();

    // traverse the list
    while (pos && (pList->Get(pos) != pCmd)) {
	pList->GetNext(pos);
    }

    // did we drop off the end?
    if (!pos) {
	hr = VFW_E_NOT_FOUND;
    } else {

	// found it - now take off list
	pList->Remove(pos);

	// Insert did an AddRef, so release it
	pCmd->Release();

	// check that timer request is still for earliest time
	SetTimeAdvise();
    }
    return hr;
}


// set the clock used for timing

HRESULT
CCmdQueue::SetSyncSource(IReferenceClock* pClock)
{
    CAutoLock lock(&m_Lock);

    // addref the new clock first in case they are the same
    if (pClock) {
	pClock->AddRef();
    }

    // kill any advise on the old clock
    if (m_pClock) {
	if (m_dwAdvise) {
	    m_pClock->Unadvise(m_dwAdvise);
	    m_dwAdvise = 0;
	}
	m_pClock->Release();
    }
    m_pClock = pClock;

    // set up a new advise
    SetTimeAdvise();
    return S_OK;
}


// set up a timer event with the reference clock

void
CCmdQueue::SetTimeAdvise(void)
{
    // make sure we have a clock to use
    if (!m_pClock) {
	return;
    }

    // reset the event whenever we are requesting a new signal
    m_evDue.Reset();

    // time 0 is earliest
    CRefTime current;

    // find the earliest presentation time
    if (m_listPresentation.GetCount() > 0) {

	POSITION pos = m_listPresentation.GetHeadPosition();
	current = m_listPresentation.Get(pos)->GetTime();
    }

    // if we're running, check the stream times too
    if (m_bRunning) {

	CRefTime t;

	if (m_listStream.GetCount() > 0) {

	    POSITION pos = m_listStream.GetHeadPosition();
	    t = m_listStream.Get(pos)->GetTime();

	    // add on stream time offset to get presentation time
	    t += m_StreamTimeOffset;

	    // is this earlier?
	    if ((current == TimeZero) || (t < current)) {
		current = t;
	    }
	}
    }

    // need to change?
    if ((current > TimeZero) && (current != m_tCurrentAdvise)) {
	if (m_dwAdvise) {
	    m_pClock->Unadvise(m_dwAdvise);
	    // reset the event whenever we are requesting a new signal
	    m_evDue.Reset();
	}

	// ask for time advice - the first two params are either
	// stream time offset and stream time or
	// presentation time and 0. we always use the latter
	HRESULT hr = m_pClock->AdviseTime(
		    (REFERENCE_TIME)current,
		    TimeZero,
		    (HEVENT) HANDLE(m_evDue),
		    &m_dwAdvise);

	ASSERT(SUCCEEDED(hr));
	m_tCurrentAdvise = current;
    }
}


// switch to run mode. Streamtime to Presentation time mapping known.

HRESULT
CCmdQueue::Run(REFERENCE_TIME tStreamTimeOffset)
{
    CAutoLock lock(&m_Lock);

    m_StreamTimeOffset = tStreamTimeOffset;
    m_bRunning = TRUE;

    // ensure advise is accurate
    SetTimeAdvise();
    return S_OK;
}


// switch to Stopped or Paused mode. Time mapping not known.

HRESULT
CCmdQueue::EndRun()
{
    CAutoLock lock(&m_Lock);

    m_bRunning = FALSE;

    // check timer setting - stream times
    SetTimeAdvise();
    return S_OK;
}


// return a pointer to the next due command. Blocks for msTimeout
// milliseconds until there is a due command.
// Stream-time commands will only become due between Run and Endrun calls.
// The command remains queued until invoked or cancelled.
// Returns E_ABORT if timeout occurs, otherwise S_OK (or other error).
//
// returns an AddRef'd object

HRESULT
CCmdQueue::GetDueCommand(CDeferredCommand ** ppCmd, long msTimeout)
{
    // loop until we timeout or find a due command
    for (;;) {

	{
	    CAutoLock lock(&m_Lock);


	    // find the earliest command
	    CDeferredCommand * pCmd = NULL;

	    // check the presentation time and the
	    // stream time list to find the earliest

	    if (m_listPresentation.GetCount() > 0) {
		POSITION pos = m_listPresentation.GetHeadPosition();
		pCmd = m_listPresentation.Get(pos);
	    }

	    if (m_bRunning && (m_listStream.GetCount() > 0)) {
		POSITION pos = m_listStream.GetHeadPosition();
		CDeferredCommand* pStrm = m_listStream.Get(pos);

		CRefTime t = pStrm->GetTime() + m_StreamTimeOffset;
		if (!pCmd || (t < pCmd->GetTime())) {
		    pCmd = pStrm;
		}
	    }

	    //	if we have found one, is it due?
	    if (pCmd) {
		if (CheckTime(pCmd->GetTime(), pCmd->IsStreamTime())) {

		    // yes it's due - addref it
		    pCmd->AddRef();
		    *ppCmd = pCmd;
		    return S_OK;
		}
	    }
	}

	// block until the advise is signalled
	if (WaitForSingleObject(m_evDue, msTimeout) != WAIT_OBJECT_0) {
	    return E_ABORT;
	}
    }
}


// return a pointer to a command that will be due for a given time.
// Pass in a stream time here. The stream time offset will be passed
// in via the Run method.
// Commands remain queued until invoked or cancelled.
// This method will not block. It will report E_ABORT if there are no
// commands due yet.
//
// returns an AddRef'd object

HRESULT
CCmdQueue::GetCommandDueFor(REFERENCE_TIME rtStream, CDeferredCommand**ppCmd)
{
    CAutoLock lock(&m_Lock);

    CRefTime tStream(rtStream);

    // find the earliest stream and presentation time commands
    CDeferredCommand* pStream = NULL;
    if (m_listStream.GetCount() > 0) {
	POSITION pos = m_listStream.GetHeadPosition();
	pStream = m_listStream.Get(pos);
    }
    CDeferredCommand* pPresent = NULL;
    if (m_listPresentation.GetCount() > 0) {
	POSITION pos = m_listPresentation.GetHeadPosition();
	pPresent = m_listPresentation.Get(pos);
    }

    // is there a presentation time that has passed already
    if (pPresent && CheckTime(pPresent->GetTime(), FALSE)) {
	pPresent->AddRef();
	*ppCmd = pPresent;
	return S_OK;
    }

    // is there a stream time command due before this stream time
    if (pStream && (pStream->GetTime() <= tStream)) {
	pPresent->AddRef();
	*ppCmd = pStream;
	return S_OK;
    }

    // if we are running, we can map presentation times to
    // stream time. In this case, is there a presentation time command
    // that will be due before this stream time is presented?
    if (m_bRunning && pPresent) {

	// this stream time will appear at...
	tStream += m_StreamTimeOffset;

	// due before that?
	if (pPresent->GetTime() <= tStream) {
	    *ppCmd = pPresent;
	    return S_OK;
	}
    }

    // no commands due yet
    return VFW_E_NOT_FOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\ctlutil.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Base classes implementing IDispatch parsing for the basic control dual
// interfaces. Derive from these and implement just the custom method and
// property methods. We also implement CPosPassThru that can be used by
// renderers and transforms to pass by IMediaPosition and IMediaSeeking

#ifndef __CTLUTIL__
#define __CTLUTIL__

// OLE Automation has different ideas of TRUE and FALSE

#define OATRUE (-1)
#define OAFALSE (0)


// It's possible that we could replace this class with CreateStdDispatch

class CBaseDispatch
{
    ITypeInfo * m_pti;

public:

    CBaseDispatch() : m_pti(NULL) {}
    ~CBaseDispatch();

    /* IDispatch methods */
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);

    STDMETHODIMP GetTypeInfo(
      REFIID riid,
      UINT itinfo,
      LCID lcid,
      ITypeInfo ** pptinfo);

    STDMETHODIMP GetIDsOfNames(
      REFIID riid,
      OLECHAR  ** rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID * rgdispid);
};


class AM_NOVTABLE CMediaControl :
    public IMediaControl,
    public CUnknown
{
    CBaseDispatch m_basedisp;

public:

    CMediaControl(const TCHAR *, LPUNKNOWN);

    DECLARE_IUNKNOWN

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    /* IDispatch methods */
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);

    STDMETHODIMP GetTypeInfo(
      UINT itinfo,
      LCID lcid,
      ITypeInfo ** pptinfo);

    STDMETHODIMP GetIDsOfNames(
      REFIID riid,
      OLECHAR  ** rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID * rgdispid);

    STDMETHODIMP Invoke(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS * pdispparams,
      VARIANT * pvarResult,
      EXCEPINFO * pexcepinfo,
      UINT * puArgErr);
};


class AM_NOVTABLE CMediaEvent :
    public IMediaEventEx,
    public CUnknown
{
    CBaseDispatch m_basedisp;

public:

    CMediaEvent(const TCHAR *, LPUNKNOWN);

    DECLARE_IUNKNOWN

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    /* IDispatch methods */
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);

    STDMETHODIMP GetTypeInfo(
      UINT itinfo,
      LCID lcid,
      ITypeInfo ** pptinfo);

    STDMETHODIMP GetIDsOfNames(
      REFIID riid,
      OLECHAR  ** rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID * rgdispid);

    STDMETHODIMP Invoke(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS * pdispparams,
      VARIANT * pvarResult,
      EXCEPINFO * pexcepinfo,
      UINT * puArgErr);
};


class AM_NOVTABLE CMediaPosition :
    public IMediaPosition,
    public CUnknown
{
    CBaseDispatch m_basedisp;


public:

    CMediaPosition(const TCHAR *, LPUNKNOWN);
    CMediaPosition(const TCHAR *, LPUNKNOWN, HRESULT *phr);

    DECLARE_IUNKNOWN

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    /* IDispatch methods */
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);

    STDMETHODIMP GetTypeInfo(
      UINT itinfo,
      LCID lcid,
      ITypeInfo ** pptinfo);

    STDMETHODIMP GetIDsOfNames(
      REFIID riid,
      OLECHAR  ** rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID * rgdispid);

    STDMETHODIMP Invoke(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS * pdispparams,
      VARIANT * pvarResult,
      EXCEPINFO * pexcepinfo,
      UINT * puArgErr);

};


// OA-compatibility means that we must use double as the RefTime value,
// and REFERENCE_TIME (essentially a LONGLONG) within filters.
// this class converts between the two

class COARefTime : public CRefTime {
public:

    COARefTime() {
    };

    COARefTime(CRefTime t)
        : CRefTime(t)
    {
    };

    COARefTime(REFERENCE_TIME t)
        : CRefTime(t)
    {
    };

    COARefTime(double d) {
        m_time = (LONGLONG) (d * 10000000);
    };

    operator double() {
        return double(m_time) / 10000000;
    };

    operator REFERENCE_TIME() {
        return m_time;
    };

    COARefTime& operator=(const double& rd)  {
        m_time = (LONGLONG) (rd * 10000000);
        return *this;
    }

    COARefTime& operator=(const REFERENCE_TIME& rt)  {
        m_time = rt;
        return *this;
    }

    inline BOOL operator==(const COARefTime& rt)
    {
        return m_time == rt.m_time;
    };

    inline BOOL operator!=(const COARefTime& rt)
    {
        return m_time != rt.m_time;
    };

    inline BOOL operator < (const COARefTime& rt)
    {
        return m_time < rt.m_time;
    };

    inline BOOL operator > (const COARefTime& rt)
    {
        return m_time > rt.m_time;
    };

    inline BOOL operator >= (const COARefTime& rt)
    {
        return m_time >= rt.m_time;
    };

    inline BOOL operator <= (const COARefTime& rt)
    {
        return m_time <= rt.m_time;
    };

    inline COARefTime operator+(const COARefTime& rt)
    {
        return COARefTime(m_time + rt.m_time);
    };

    inline COARefTime operator-(const COARefTime& rt)
    {
        return COARefTime(m_time - rt.m_time);
    };

    inline COARefTime operator*(LONG l)
    {
        return COARefTime(m_time * l);
    };

    inline COARefTime operator/(LONG l)
    {
        return COARefTime(m_time / l);
    };

private:
    //  Prevent bugs from constructing from LONG (which gets
    //  converted to double and then multiplied by 10000000
    COARefTime(LONG);
    operator=(LONG);
};


// A utility class that handles IMediaPosition and IMediaSeeking on behalf
// of single-input pin renderers, or transform filters.
//
// Renderers will expose this from the filter; transform filters will
// expose it from the output pin and not the renderer.
//
// Create one of these, giving it your IPin* for your input pin, and delegate
// all IMediaPosition methods to it. It will query the input pin for
// IMediaPosition and respond appropriately.
//
// Call ForceRefresh if the pin connection changes.
//
// This class no longer caches the upstream IMediaPosition or IMediaSeeking
// it acquires it on each method call. This means ForceRefresh is not needed.
// The method is kept for source compatibility and to minimise the changes
// if we need to put it back later for performance reasons.

class CPosPassThru : public IMediaSeeking, public CMediaPosition
{
    IPin *m_pPin;

    HRESULT GetPeer(IMediaPosition **ppMP);
    HRESULT GetPeerSeeking(IMediaSeeking **ppMS);

public:

    CPosPassThru(const TCHAR *, LPUNKNOWN, HRESULT*, IPin *);
    DECLARE_IUNKNOWN

    HRESULT ForceRefresh() {
        return S_OK;
    };

    // override to return an accurate current position
    virtual HRESULT GetMediaTime(LONGLONG *pStartTime,LONGLONG *pEndTime) {
        return E_FAIL;
    }

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    // IMediaSeeking methods
    STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
    STDMETHODIMP CheckCapabilities( DWORD * pCapabilities );
    STDMETHODIMP SetTimeFormat(const GUID * pFormat);
    STDMETHODIMP GetTimeFormat(GUID *pFormat);
    STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);
    STDMETHODIMP IsFormatSupported( const GUID * pFormat);
    STDMETHODIMP QueryPreferredFormat( GUID *pFormat);
    STDMETHODIMP ConvertTimeFormat(LONGLONG * pTarget, const GUID * pTargetFormat,
                                   LONGLONG    Source, const GUID * pSourceFormat );
    STDMETHODIMP SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags
                             , LONGLONG * pStop, DWORD StopFlags );

    STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );
    STDMETHODIMP GetCurrentPosition( LONGLONG * pCurrent );
    STDMETHODIMP GetStopPosition( LONGLONG * pStop );
    STDMETHODIMP SetRate( double dRate);
    STDMETHODIMP GetRate( double * pdRate);
    STDMETHODIMP GetDuration( LONGLONG *pDuration);
    STDMETHODIMP GetAvailable( LONGLONG *pEarliest, LONGLONG *pLatest );
    STDMETHODIMP GetPreroll( LONGLONG *pllPreroll );

    // IMediaPosition properties
    STDMETHODIMP get_Duration(REFTIME * plength);
    STDMETHODIMP put_CurrentPosition(REFTIME llTime);
    STDMETHODIMP get_StopTime(REFTIME * pllTime);
    STDMETHODIMP put_StopTime(REFTIME llTime);
    STDMETHODIMP get_PrerollTime(REFTIME * pllTime);
    STDMETHODIMP put_PrerollTime(REFTIME llTime);
    STDMETHODIMP get_Rate(double * pdRate);
    STDMETHODIMP put_Rate(double dRate);
    STDMETHODIMP get_CurrentPosition(REFTIME * pllTime);
    STDMETHODIMP CanSeekForward(LONG *pCanSeekForward);
    STDMETHODIMP CanSeekBackward(LONG *pCanSeekBackward);

private:
    HRESULT GetSeekingLongLong( HRESULT (__stdcall IMediaSeeking::*pMethod)( LONGLONG * ),
                                LONGLONG * pll );
};


// Adds the ability to return a current position

class CRendererPosPassThru : public CPosPassThru
{
    CCritSec m_PositionLock;    // Locks access to our position
    LONGLONG m_StartMedia;      // Start media time last seen
    LONGLONG m_EndMedia;        // And likewise the end media
    BOOL m_bReset;              // Have media times been set

public:

    // Used to help with passing media times through graph

    CRendererPosPassThru(const TCHAR *, LPUNKNOWN, HRESULT*, IPin *);
    HRESULT RegisterMediaTime(IMediaSample *pMediaSample);
    HRESULT RegisterMediaTime(LONGLONG StartTime,LONGLONG EndTime);
    HRESULT GetMediaTime(LONGLONG *pStartTime,LONGLONG *pEndTime);
    HRESULT ResetMediaTime();
    HRESULT EOS();
};

STDAPI CreatePosPassThru(
    LPUNKNOWN pAgg,
    BOOL bRenderer,
    IPin *pPin,
    IUnknown **ppPassThru
);

// A class that handles the IDispatch part of IBasicAudio and leaves the
// properties and methods themselves pure virtual.

class AM_NOVTABLE CBasicAudio : public IBasicAudio, public CUnknown
{
    CBaseDispatch m_basedisp;

public:

    CBasicAudio(const TCHAR *, LPUNKNOWN);

    DECLARE_IUNKNOWN

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    /* IDispatch methods */
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);

    STDMETHODIMP GetTypeInfo(
      UINT itinfo,
      LCID lcid,
      ITypeInfo ** pptinfo);

    STDMETHODIMP GetIDsOfNames(
      REFIID riid,
      OLECHAR  ** rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID * rgdispid);

    STDMETHODIMP Invoke(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS * pdispparams,
      VARIANT * pvarResult,
      EXCEPINFO * pexcepinfo,
      UINT * puArgErr);
};


// A class that handles the IDispatch part of IBasicVideo and leaves the
// properties and methods themselves pure virtual.

class AM_NOVTABLE CBaseBasicVideo : public IBasicVideo2, public CUnknown
{
    CBaseDispatch m_basedisp;

public:

    CBaseBasicVideo(const TCHAR *, LPUNKNOWN);

    DECLARE_IUNKNOWN

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    /* IDispatch methods */
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);

    STDMETHODIMP GetTypeInfo(
      UINT itinfo,
      LCID lcid,
      ITypeInfo ** pptinfo);

    STDMETHODIMP GetIDsOfNames(
      REFIID riid,
      OLECHAR  ** rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID * rgdispid);

    STDMETHODIMP Invoke(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS * pdispparams,
      VARIANT * pvarResult,
      EXCEPINFO * pexcepinfo,
      UINT * puArgErr);

    STDMETHODIMP GetPreferredAspectRatio(
      long *plAspectX,
      long *plAspectY)
    {
        return E_NOTIMPL;
    }
};


// A class that handles the IDispatch part of IVideoWindow and leaves the
// properties and methods themselves pure virtual.

class AM_NOVTABLE CBaseVideoWindow : public IVideoWindow, public CUnknown
{
    CBaseDispatch m_basedisp;

public:

    CBaseVideoWindow(const TCHAR *, LPUNKNOWN);

    DECLARE_IUNKNOWN

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    /* IDispatch methods */
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);

    STDMETHODIMP GetTypeInfo(
      UINT itinfo,
      LCID lcid,
      ITypeInfo ** pptinfo);

    STDMETHODIMP GetIDsOfNames(
      REFIID riid,
      OLECHAR  ** rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID * rgdispid);

    STDMETHODIMP Invoke(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS * pdispparams,
      VARIANT * pvarResult,
      EXCEPINFO * pexcepinfo,
      UINT * puArgErr);
};


// abstract class to help source filters with their implementation
// of IMediaPosition. Derive from this and set the duration (and stop
// position). Also override NotifyChange to do something when the properties
// change.

class AM_NOVTABLE CSourcePosition : public CMediaPosition
{

public:
    CSourcePosition(const TCHAR *, LPUNKNOWN, HRESULT*, CCritSec *);

    // IMediaPosition methods
    STDMETHODIMP get_Duration(REFTIME * plength);
    STDMETHODIMP put_CurrentPosition(REFTIME llTime);
    STDMETHODIMP get_StopTime(REFTIME * pllTime);
    STDMETHODIMP put_StopTime(REFTIME llTime);
    STDMETHODIMP get_PrerollTime(REFTIME * pllTime);
    STDMETHODIMP put_PrerollTime(REFTIME llTime);
    STDMETHODIMP get_Rate(double * pdRate);
    STDMETHODIMP put_Rate(double dRate);
    STDMETHODIMP CanSeekForward(LONG *pCanSeekForward);
    STDMETHODIMP CanSeekBackward(LONG *pCanSeekBackward);

    // override if you can return the data you are actually working on
    STDMETHODIMP get_CurrentPosition(REFTIME * pllTime) {
        return E_NOTIMPL;
    };

protected:

    // we call this to notify changes. Override to handle them
    virtual HRESULT ChangeStart() PURE;
    virtual HRESULT ChangeStop() PURE;
    virtual HRESULT ChangeRate() PURE;

    COARefTime m_Duration;
    COARefTime m_Start;
    COARefTime m_Stop;
    double m_Rate;

    CCritSec * m_pLock;
};

class AM_NOVTABLE CSourceSeeking :
    public IMediaSeeking,
    public CUnknown
{

public:

    DECLARE_IUNKNOWN;
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
    
    // IMediaSeeking methods

    STDMETHODIMP IsFormatSupported(const GUID * pFormat);
    STDMETHODIMP QueryPreferredFormat(GUID *pFormat);
    STDMETHODIMP SetTimeFormat(const GUID * pFormat);
    STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);
    STDMETHODIMP GetTimeFormat(GUID *pFormat);
    STDMETHODIMP GetDuration(LONGLONG *pDuration);
    STDMETHODIMP GetStopPosition(LONGLONG *pStop);
    STDMETHODIMP GetCurrentPosition(LONGLONG *pCurrent);
    STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
    STDMETHODIMP CheckCapabilities( DWORD * pCapabilities );
    STDMETHODIMP ConvertTimeFormat( LONGLONG * pTarget, const GUID * pTargetFormat,
                                    LONGLONG    Source, const GUID * pSourceFormat );

    STDMETHODIMP SetPositions( LONGLONG * pCurrent,  DWORD CurrentFlags
			     , LONGLONG * pStop,  DWORD StopFlags );

    STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );

    STDMETHODIMP GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest );
    STDMETHODIMP SetRate( double dRate);
    STDMETHODIMP GetRate( double * pdRate);
    STDMETHODIMP GetPreroll(LONGLONG *pPreroll);

    
protected:

    // ctor
    CSourceSeeking(const TCHAR *, LPUNKNOWN, HRESULT*, CCritSec *);
    
    // we call this to notify changes. Override to handle them
    virtual HRESULT ChangeStart() PURE;
    virtual HRESULT ChangeStop() PURE;
    virtual HRESULT ChangeRate() PURE;

    CRefTime m_rtDuration;      // length of stream
    CRefTime m_rtStart;         // source will start here
    CRefTime m_rtStop;          // source will stop here
    double m_dRateSeeking;

    // seeking capabilities 
    DWORD m_dwSeekingCaps;

    CCritSec * m_pLock;
};


// Base classes supporting Deferred commands.

// Deferred commands are queued by calls to methods on the IQueueCommand
// interface, exposed by the filtergraph and by some filters. A successful
// call to one of these methods will return an IDeferredCommand interface
// representing the queued command.
//
// A CDeferredCommand object represents a single deferred command, and exposes
// the IDeferredCommand interface as well as other methods permitting time
// checks and actual execution. It contains a reference to the CCommandQueue
// object on which it is queued.
//
// CCommandQueue is a base class providing a queue of CDeferredCommand
// objects, and methods to add, remove, check status and invoke the queued
// commands. A CCommandQueue object would be part of an object that
// implemented IQueueCommand.

class CCmdQueue;

// take a copy of the params and store them. Release any allocated
// memory in destructor

class CDispParams : public DISPPARAMS
{
public:
    CDispParams(UINT nArgs, VARIANT* pArgs);
    ~CDispParams();
};


// CDeferredCommand lifetime is controlled by refcounts. Caller of
// InvokeAt.. gets a refcounted interface pointer, and the CCmdQueue
// object also holds a refcount on us. Calling Cancel or Invoke takes
// us off the CCmdQueue and thus reduces the refcount by 1. Once taken
// off the queue we cannot be put back on the queue.

class CDeferredCommand
    : public CUnknown,
      public IDeferredCommand
{
public:

    CDeferredCommand(
        CCmdQueue * pQ,
        LPUNKNOWN   pUnk,               // aggregation outer unk
        HRESULT *   phr,
        LPUNKNOWN   pUnkExecutor,       // object that will execute this cmd
        REFTIME     time,
        GUID*       iid,
        long        dispidMethod,
        short       wFlags,
        long        cArgs,
        VARIANT*    pDispParams,
        VARIANT*    pvarResult,
        short*      puArgErr,
        BOOL        bStream
        );

    DECLARE_IUNKNOWN

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    // IDeferredCommand methods
    STDMETHODIMP Cancel();
    STDMETHODIMP Confidence(
                    LONG* pConfidence);
    STDMETHODIMP Postpone(
                    REFTIME newtime);
    STDMETHODIMP GetHResult(
                    HRESULT* phrResult);

    // other public methods

    HRESULT Invoke();

    // access methods

    // returns TRUE if streamtime, FALSE if presentation time
    BOOL IsStreamTime() {
       return m_bStream;
    };

    CRefTime GetTime() {
        return m_time;
    };

    REFIID GetIID() {
        return *m_iid;
    };

    long GetMethod() {
        return m_dispidMethod;
    };

    short GetFlags() {
        return m_wFlags;
    };

    DISPPARAMS* GetParams() {
        return &m_DispParams;
    };

    VARIANT* GetResult() {
        return m_pvarResult;
    };

protected:

    CCmdQueue* m_pQueue;

    // pUnk for the interface that we will execute the command on
    LPUNKNOWN   m_pUnk;

    // stored command data
    REFERENCE_TIME     m_time;
    GUID*       m_iid;
    long        m_dispidMethod;
    short       m_wFlags;
    VARIANT*    m_pvarResult;
    BOOL        m_bStream;
    CDispParams m_DispParams;
    DISPID      m_DispId;         //  For get and put

    // we use this for ITypeInfo access
    CBaseDispatch   m_Dispatch;

    // save retval here
    HRESULT     m_hrResult;
};


// a list of CDeferredCommand objects. this is a base class providing
// the basics of access to the list. If you want to use CDeferredCommand
// objects then your queue needs to be derived from this class.

class AM_NOVTABLE CCmdQueue
{
public:
    CCmdQueue();
    virtual ~CCmdQueue();

    // returns a new CDeferredCommand object that will be initialised with
    // the parameters and will be added to the queue during construction.
    // returns S_OK if successfully created otherwise an error and
    // no object has been queued.
    virtual HRESULT  New(
        CDeferredCommand **ppCmd,
        LPUNKNOWN   pUnk,
        REFTIME     time,
        GUID*       iid,
        long        dispidMethod,
        short       wFlags,
        long        cArgs,
        VARIANT*    pDispParams,
        VARIANT*    pvarResult,
        short*      puArgErr,
        BOOL        bStream
    );

    // called by the CDeferredCommand object to add and remove itself
    // from the queue
    virtual HRESULT Insert(CDeferredCommand* pCmd);
    virtual HRESULT Remove(CDeferredCommand* pCmd);

    // Command-Due Checking
    //
    // There are two schemes of synchronisation: coarse and accurate. In
    // coarse mode, you wait till the time arrives and then execute the cmd.
    // In accurate mode, you wait until you are processing the sample that
    // will appear at the time, and then execute the command. It's up to the
    // filter which one it will implement. The filtergraph will always
    // implement coarse mode for commands queued at the filtergraph.
    //
    // If you want coarse sync, you probably want to wait until there is a
    // command due, and then execute it. You can do this by calling
    // GetDueCommand. If you have several things to wait for, get the
    // event handle from GetDueHandle() and when this is signalled then call
    // GetDueCommand. Stream time will only advance between calls to Run and
    // EndRun. Note that to avoid an extra thread there is no guarantee that
    // if the handle is set there will be a command ready. Each time the
    // event is signalled, call GetDueCommand (probably with a 0 timeout);
    // This may return E_ABORT.
    //
    // If you want accurate sync, you must call GetCommandDueFor, passing
    // as a parameter the stream time of the samples you are about to process.
    // This will return:
    //   -- a stream-time command due at or before that stream time
    //   -- a presentation-time command due at or before the
    //      time that stream time will be presented (only between Run
    //      and EndRun calls, since outside of this, the mapping from
    //      stream time to presentation time is not known.
    //   -- any presentation-time command due now.
    // This means that if you want accurate synchronisation on samples that
    // might be processed during Paused mode, you need to use
    // stream-time commands.
    //
    // In all cases, commands remain queued until Invoked or Cancelled. The
    // setting and resetting of the event handle is managed entirely by this
    // queue object.

    // set the clock used for timing
    virtual HRESULT SetSyncSource(IReferenceClock*);

    // switch to run mode. Streamtime to Presentation time mapping known.
    virtual HRESULT Run(REFERENCE_TIME tStreamTimeOffset);

    // switch to Stopped or Paused mode. Time mapping not known.
    virtual HRESULT EndRun();

    // return a pointer to the next due command. Blocks for msTimeout
    // milliseconds until there is a due command.
    // Stream-time commands will only become due between Run and Endrun calls.
    // The command remains queued until invoked or cancelled.
    // Returns E_ABORT if timeout occurs, otherwise S_OK (or other error).
    // Returns an AddRef-ed object
    virtual HRESULT GetDueCommand(CDeferredCommand ** ppCmd, long msTimeout);

    // return the event handle that will be signalled whenever
    // there are deferred commands due for execution (when GetDueCommand
    // will not block).
    HANDLE GetDueHandle() {
        return HANDLE(m_evDue);
    };

    // return a pointer to a command that will be due for a given time.
    // Pass in a stream time here. The stream time offset will be passed
    // in via the Run method.
    // Commands remain queued until invoked or cancelled.
    // This method will not block. It will report VFW_E_NOT_FOUND if there
    // are no commands due yet.
    // Returns an AddRef-ed object
    virtual HRESULT GetCommandDueFor(REFERENCE_TIME tStream, CDeferredCommand**ppCmd);

    // check if a given time is due (TRUE if it is due yet)
    BOOL CheckTime(CRefTime time, BOOL bStream) {

        // if no clock, nothing is due!
        if (!m_pClock) {
            return FALSE;
        }

        // stream time
        if (bStream) {

            // not valid if not running
            if (!m_bRunning) {
                return FALSE;
            }
            // add on known stream time offset to get presentation time
            time += m_StreamTimeOffset;
        }

        CRefTime Now;
        m_pClock->GetTime((REFERENCE_TIME*)&Now);
        return (time <= Now);
    };

protected:

    // protect access to lists etc
    CCritSec m_Lock;

    // commands queued in presentation time are stored here
    CGenericList<CDeferredCommand> m_listPresentation;

    // commands queued in stream time are stored here
    CGenericList<CDeferredCommand> m_listStream;

    // set when any commands are due
    CAMEvent m_evDue;

    // creates an advise for the earliest time required, if any
    void SetTimeAdvise(void);

    // advise id from reference clock (0 if no outstanding advise)
    DWORD_PTR m_dwAdvise;

    // advise time is for this presentation time
    CRefTime m_tCurrentAdvise;

    // the reference clock we are using (addrefed)
    IReferenceClock* m_pClock;

    // true when running
    BOOL m_bRunning;

    // contains stream time offset when m_bRunning is true
    CRefTime m_StreamTimeOffset;
};

#endif // __CTLUTIL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\dllsetup.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>

//---------------------------------------------------------------------------
// defines

#define MAX_KEY_LEN  260


//---------------------------------------------------------------------------
// externally defined functions/variable

extern int g_cTemplates;
extern CFactoryTemplate g_Templates[];

//---------------------------------------------------------------------------
//
// EliminateSubKey
//
// Try to enumerate all keys under this one.
// if we find anything, delete it completely.
// Otherwise just delete it.
//
// note - this was pinched/duplicated from
// Filgraph\Mapper.cpp - so should it be in
// a lib somewhere?
//
//---------------------------------------------------------------------------

STDAPI
EliminateSubKey( HKEY hkey, LPTSTR strSubKey )
{
  HKEY hk;
  if (0 == lstrlen(strSubKey) ) {
      // defensive approach
      return E_FAIL;
  }

  LONG lreturn = RegOpenKeyEx( hkey
                             , strSubKey
                             , 0
                             , MAXIMUM_ALLOWED
                             , &hk );

  ASSERT(    lreturn == ERROR_SUCCESS
          || lreturn == ERROR_FILE_NOT_FOUND
          || lreturn == ERROR_INVALID_HANDLE );

  if( ERROR_SUCCESS == lreturn )
  {
    // Keep on enumerating the first (zero-th)
    // key and deleting that

    for( ; ; )
    {
      TCHAR Buffer[MAX_KEY_LEN];
      DWORD dw = MAX_KEY_LEN;
      FILETIME ft;

      lreturn = RegEnumKeyEx( hk
                            , 0
                            , Buffer
                            , &dw
                            , NULL
                            , NULL
                            , NULL
                            , &ft);

      ASSERT(    lreturn == ERROR_SUCCESS
              || lreturn == ERROR_NO_MORE_ITEMS );

      if( ERROR_SUCCESS == lreturn )
      {
        EliminateSubKey(hk, Buffer);
      }
      else
      {
        break;
      }
    }

    RegCloseKey(hk);
    RegDeleteKey(hkey, strSubKey);
  }

  return NOERROR;
}


//---------------------------------------------------------------------------
//
// AMovieSetupRegisterServer()
//
// registers specfied file "szFileName" as server for
// CLSID "clsServer".  A description is also required.
// The ThreadingModel and ServerType are optional, as
// they default to InprocServer32 (i.e. dll) and Both.
//
//---------------------------------------------------------------------------

STDAPI
AMovieSetupRegisterServer( CLSID   clsServer
                         , LPCWSTR szDescription
                         , LPCWSTR szFileName
                         , LPCWSTR szThreadingModel = L"Both"
                         , LPCWSTR szServerType     = L"InprocServer32" )
{
  // temp buffer
  //
  TCHAR achTemp[MAX_PATH];

  // convert CLSID uuid to string and write
  // out subkey as string - CLSID\{}
  //
  OLECHAR szCLSID[CHARS_IN_GUID];
  HRESULT hr = StringFromGUID2( clsServer
                              , szCLSID
                              , CHARS_IN_GUID );
  ASSERT( SUCCEEDED(hr) );

  // create key
  //
  HKEY hkey;
  wsprintf( achTemp, TEXT("CLSID\\%ls"), szCLSID );
  LONG lreturn = RegCreateKey( HKEY_CLASSES_ROOT
                             , (LPCTSTR)achTemp
                             , &hkey              );
  if( ERROR_SUCCESS != lreturn )
  {
    return HRESULT_FROM_WIN32(lreturn);
  }

  // set description string
  //

  wsprintf( achTemp, TEXT("%ls"), szDescription );
  lreturn = RegSetValue( hkey
                       , (LPCTSTR)NULL
                       , REG_SZ
                       , achTemp
                       , sizeof(achTemp) );
  if( ERROR_SUCCESS != lreturn )
  {
    RegCloseKey( hkey );
    return HRESULT_FROM_WIN32(lreturn);
  }

  // create CLSID\\{"CLSID"}\\"ServerType" key,
  // using key to CLSID\\{"CLSID"} passed back by
  // last call to RegCreateKey().
  //
  HKEY hsubkey;

  wsprintf( achTemp, TEXT("%ls"), szServerType );
  lreturn = RegCreateKey( hkey
                        , achTemp
                        , &hsubkey     );
  if( ERROR_SUCCESS != lreturn )
  {
    RegCloseKey( hkey );
    return HRESULT_FROM_WIN32(lreturn);
  }

  // set Server string
  //
  wsprintf( achTemp, TEXT("%ls"), szFileName );
  lreturn = RegSetValue( hsubkey
                       , (LPCTSTR)NULL
                       , REG_SZ
                       , (LPCTSTR)achTemp
                       , sizeof(TCHAR) * (lstrlen(achTemp)+1) );
  if( ERROR_SUCCESS != lreturn )
  {
    RegCloseKey( hkey );
    RegCloseKey( hsubkey );
    return HRESULT_FROM_WIN32(lreturn);
  }

  wsprintf( achTemp, TEXT("%ls"), szThreadingModel );
  lreturn = RegSetValueEx( hsubkey
                         , TEXT("ThreadingModel")
                         , 0L
                         , REG_SZ
                         , (CONST BYTE *)achTemp
                         , sizeof(TCHAR) * (lstrlen(achTemp)+1) );

  // close hkeys
  //
  RegCloseKey( hkey );
  RegCloseKey( hsubkey );

  // and return
  //
  return HRESULT_FROM_WIN32(lreturn);

}


//---------------------------------------------------------------------------
//
// AMovieSetupUnregisterServer()
//
// default ActiveMovie dll setup function
// - to use must be called from an exported
//   function named DllRegisterServer()
//
//---------------------------------------------------------------------------

STDAPI
AMovieSetupUnregisterServer( CLSID clsServer )
{
  // convert CLSID uuid to string and write
  // out subkey CLSID\{}
  //
  OLECHAR szCLSID[CHARS_IN_GUID];
  HRESULT hr = StringFromGUID2( clsServer
                              , szCLSID
                              , CHARS_IN_GUID );
  ASSERT( SUCCEEDED(hr) );

  TCHAR achBuffer[MAX_KEY_LEN];
  wsprintf( achBuffer, TEXT("CLSID\\%ls"), szCLSID );

  // delete subkey
  //

  hr = EliminateSubKey( HKEY_CLASSES_ROOT, achBuffer );
  ASSERT( SUCCEEDED(hr) );

  // return
  //
  return NOERROR;
}


//---------------------------------------------------------------------------
//
// AMovieSetupRegisterFilter through IFilterMapper2
//
//---------------------------------------------------------------------------

STDAPI
AMovieSetupRegisterFilter2( const AMOVIESETUP_FILTER * const psetupdata
                          , IFilterMapper2 *                 pIFM2
                          , BOOL                             bRegister  )
{
  DbgLog((LOG_TRACE, 3, TEXT("= AMovieSetupRegisterFilter")));

  // check we've got data
  //
  if( NULL == psetupdata ) return S_FALSE;


  // unregister filter
  // (as pins are subkeys of filter's CLSID key
  // they do not need to be removed separately).
  //
  DbgLog((LOG_TRACE, 3, TEXT("= = unregister filter")));
  HRESULT hr = pIFM2->UnregisterFilter(
      0,                        // default category
      0,                        // default instance name
      *psetupdata->clsID );


  if( bRegister )
  {
    REGFILTER2 rf2;
    rf2.dwVersion = 1;
    rf2.dwMerit = psetupdata->dwMerit;
    rf2.cPins = psetupdata->nPins;
    rf2.rgPins = psetupdata->lpPin;
    
    // register filter
    //
    DbgLog((LOG_TRACE, 3, TEXT("= = register filter")));
    hr = pIFM2->RegisterFilter(*psetupdata->clsID
                             , psetupdata->strName
                             , 0 // moniker
                             , 0 // category
                             , NULL // instance
                             , &rf2);
  }

  // handle one acceptable "error" - that
  // of filter not being registered!
  // (couldn't find a suitable #define'd
  // name for the error!)
  //
  if( 0x80070002 == hr)
    return NOERROR;
  else
    return hr;
}


//---------------------------------------------------------------------------
//
// RegisterAllServers()
//
//---------------------------------------------------------------------------

STDAPI
RegisterAllServers( LPCWSTR szFileName, BOOL bRegister )
{
  HRESULT hr = NOERROR;

  for( int i = 0; i < g_cTemplates; i++ )
  {
    // get i'th template
    //
    const CFactoryTemplate *pT = &g_Templates[i];

    DbgLog((LOG_TRACE, 2, TEXT("- - register %ls"),
           (LPCWSTR)pT->m_Name ));

    // register CLSID and InprocServer32
    //
    if( bRegister )
    {
      hr = AMovieSetupRegisterServer( *(pT->m_ClsID)
                                    , (LPCWSTR)pT->m_Name
                                    , szFileName );
    }
    else
    {
      hr = AMovieSetupUnregisterServer( *(pT->m_ClsID) );
    }

    // check final error for this pass
    // and break loop if we failed
    //
    if( FAILED(hr) )
      break;
  }

  return hr;
}


//---------------------------------------------------------------------------
//
// AMovieDllRegisterServer2()
//
// default ActiveMovie dll setup function
// - to use must be called from an exported
//   function named DllRegisterServer()
//
// this function is table driven using the
// static members of the CFactoryTemplate
// class defined in the dll.
//
// it registers the Dll as the InprocServer32
// and then calls the IAMovieSetup.Register
// method.
//
//---------------------------------------------------------------------------

STDAPI
AMovieDllRegisterServer2( BOOL bRegister )
{
  HRESULT hr = NOERROR;

  DbgLog((LOG_TRACE, 2, TEXT("AMovieDllRegisterServer2()")));

  // get file name (where g_hInst is the
  // instance handle of the filter dll)
  //
  WCHAR achFileName[MAX_PATH];

  // WIN95 doesn't support GetModuleFileNameW
  //
  {
    char achTemp[MAX_PATH];

    DbgLog((LOG_TRACE, 2, TEXT("- get module file name")));

    // g_hInst handle is set in our dll entry point. Make sure
    // DllEntryPoint in dllentry.cpp is called
    ASSERT(g_hInst != 0);

    if( 0 == GetModuleFileNameA( g_hInst
                              , achTemp
                              , sizeof(achTemp) ) )
    {
      // we've failed!
      DWORD dwerr = GetLastError();
      return HRESULT_FROM_WIN32(dwerr);
    }

    MultiByteToWideChar( CP_ACP
                       , 0L
                       , achTemp
                       , lstrlenA(achTemp) + 1
                       , achFileName
                       , sizeof(achFileName) / sizeof(achFileName[0]));
  }

  //
  // first registering, register all OLE servers
  //
  if( bRegister )
  {
    DbgLog((LOG_TRACE, 2, TEXT("- register OLE Servers")));
    hr = RegisterAllServers( achFileName, TRUE );
  }

  //
  // next, register/unregister all filters
  //

  if( SUCCEEDED(hr) )
  {
    // init is ref counted so call just in case
    // we're being called cold.
    //
    DbgLog((LOG_TRACE, 2, TEXT("- CoInitialize")));
    hr = CoInitialize( (LPVOID)NULL );
    ASSERT( SUCCEEDED(hr) );

    // get hold of IFilterMapper2
    //
    DbgLog((LOG_TRACE, 2, TEXT("- obtain IFilterMapper2")));
    IFilterMapper2 *pIFM2 = 0;
    IFilterMapper *pIFM = 0;
    hr = CoCreateInstance( CLSID_FilterMapper2
                         , NULL
                         , CLSCTX_INPROC_SERVER
                         , IID_IFilterMapper2
                         , (void **)&pIFM2       );
    if(FAILED(hr))
    {
        DbgLog((LOG_TRACE, 2, TEXT("- trying IFilterMapper instead")));

        hr = CoCreateInstance(
            CLSID_FilterMapper,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IFilterMapper,
            (void **)&pIFM);
    }
    if( SUCCEEDED(hr) )
    {
      // scan through array of CFactoryTemplates
      // registering servers and filters.
      //
      DbgLog((LOG_TRACE, 2, TEXT("- register Filters")));
      for( int i = 0; i < g_cTemplates; i++ )
      {
        // get i'th template
        //
        const CFactoryTemplate *pT = &g_Templates[i];

        if( NULL != pT->m_pAMovieSetup_Filter )
        {
          DbgLog((LOG_TRACE, 2, TEXT("- - register %ls"), (LPCWSTR)pT->m_Name ));

          if(pIFM2)
          {
              hr = AMovieSetupRegisterFilter2( pT->m_pAMovieSetup_Filter, pIFM2, bRegister );
          }
          else
          {
              hr = AMovieSetupRegisterFilter( pT->m_pAMovieSetup_Filter, pIFM, bRegister );
          }
        }

        // check final error for this pass
        // and break loop if we failed
        //
        if( FAILED(hr) )
          break;
      }

      // release interface
      //
      if(pIFM2)
          pIFM2->Release();
      else
          pIFM->Release();

    }

    // and clear up
    //
    CoFreeUnusedLibraries();
    CoUninitialize();
  }

  //
  // if unregistering, unregister all OLE servers
  //
  if( SUCCEEDED(hr) && !bRegister )
  {
    DbgLog((LOG_TRACE, 2, TEXT("- register OLE Servers")));
    hr = RegisterAllServers( achFileName, FALSE );
  }

  DbgLog((LOG_TRACE, 2, TEXT("- return %0x"), hr));
  return hr;
}


//---------------------------------------------------------------------------
//
// AMovieDllRegisterServer()
//
// default ActiveMovie dll setup function
// - to use must be called from an exported
//   function named DllRegisterServer()
//
// this function is table driven using the
// static members of the CFactoryTemplate
// class defined in the dll.
//
// it registers the Dll as the InprocServer32
// and then calls the IAMovieSetup.Register
// method.
//
//---------------------------------------------------------------------------


STDAPI
AMovieDllRegisterServer( void )
{
  HRESULT hr = NOERROR;

  // get file name (where g_hInst is the
  // instance handle of the filter dll)
  //
  WCHAR achFileName[MAX_PATH];

  {
    // WIN95 doesn't support GetModuleFileNameW
    //
    char achTemp[MAX_PATH];

    if( 0 == GetModuleFileNameA( g_hInst
                              , achTemp
                              , sizeof(achTemp) ) )
    {
      // we've failed!
      DWORD dwerr = GetLastError();
      return HRESULT_FROM_WIN32(dwerr);
    }

    MultiByteToWideChar( CP_ACP
                       , 0L
                       , achTemp
                       , lstrlenA(achTemp) + 1
                       , achFileName
                       , sizeof(achFileName)/sizeof(achFileName[0]) );
  }

  // scan through array of CFactoryTemplates
  // registering servers and filters.
  //
  for( int i = 0; i < g_cTemplates; i++ )
  {
    // get i'th template
    //
    const CFactoryTemplate *pT = &g_Templates[i];

    // register CLSID and InprocServer32
    //
    hr = AMovieSetupRegisterServer( *(pT->m_ClsID)
                                  , (LPCWSTR)pT->m_Name
                                  , achFileName );

    // instantiate all servers and get hold of
    // IAMovieSetup, if implemented, and call
    // IAMovieSetup.Register() method
    //
    if( SUCCEEDED(hr) && (NULL != pT->m_lpfnNew) )
    {
      // instantiate object
      //
      PAMOVIESETUP psetup;
      hr = CoCreateInstance( *(pT->m_ClsID)
                           , 0
                           , CLSCTX_INPROC_SERVER
                           , IID_IAMovieSetup
                           , reinterpret_cast<void**>(&psetup) );
      if( SUCCEEDED(hr) )
      {
        hr = psetup->Unregister();
        if( SUCCEEDED(hr) )
          hr = psetup->Register();
        psetup->Release();
      }
      else
      {
        if(    (E_NOINTERFACE      == hr )
            || (VFW_E_NEED_OWNER == hr ) )
          hr = NOERROR;
      }
    }

    // check final error for this pass
    // and break loop if we failed
    //
    if( FAILED(hr) )
      break;

  } // end-for

  return hr;
}


//---------------------------------------------------------------------------
//
// AMovieDllUnregisterServer()
//
// default ActiveMovie dll uninstall function
// - to use must be called from an exported
//   function named DllRegisterServer()
//
// this function is table driven using the
// static members of the CFactoryTemplate
// class defined in the dll.
//
// it calls the IAMovieSetup.Unregister
// method and then unregisters the Dll
// as the InprocServer32
//
//---------------------------------------------------------------------------

STDAPI
AMovieDllUnregisterServer()
{
  // initialize return code
  //
  HRESULT hr = NOERROR;

  // scan through CFactory template and unregister
  // all OLE servers and filters.
  //
  for( int i = g_cTemplates; i--; )
  {
    // get i'th template
    //
    const CFactoryTemplate *pT = &g_Templates[i];

    // check method exists
    //
    if( NULL != pT->m_lpfnNew )
    {
      // instantiate object
      //
      PAMOVIESETUP psetup;
      hr = CoCreateInstance( *(pT->m_ClsID)
                           , 0
                           , CLSCTX_INPROC_SERVER
                           , IID_IAMovieSetup
                           , reinterpret_cast<void**>(&psetup) );
      if( SUCCEEDED(hr) )
      {
        hr = psetup->Unregister();
        psetup->Release();
      }
      else
      {
        if(    (E_NOINTERFACE      == hr )
            || (VFW_E_NEED_OWNER == hr ) )
           hr = NOERROR;
      }
    }

    // unregister CLSID and InprocServer32
    //
    if( SUCCEEDED(hr) )
    {
      hr = AMovieSetupUnregisterServer( *(pT->m_ClsID) );
    }

    // check final error for this pass
    // and break loop if we failed
    //
    if( FAILED(hr) )
      break;
  }

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\evcode.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

//
// list of standard Quartz event codes and the expected params
//

// Event codes are broken into two groups
//   -- system event codes
//   -- extension event codes
// All system event codes are below EC_USER

#define EC_SYSTEMBASE                       0x00
#define EC_USER                             0x8000


// System-defined event codes
// ==========================
//
// There are three types of system-defined event codes:
//
// 1.  Those which are always passed through to the application
//     (To be collected by calls to GetEvent or within WaitForCompletion.)
//     (e.g. EC_ERRORABORT, EC_USERABORT.)
//
// 2.  Those which are pure internal and will never be passed to
//     the application.  (e.g. EC_SHUTDOWN)
//
// 3.  Those which have default handling.  Default handing implies that
//     the event is not passed to the application.  However, default
//     handling may be canceled by calling
//     IMediaEvent::CancelDefaultHandling.  If the default handling is
//     cancelled in this way, then the message will be delivered to the
//     application and the application must action it appropriately.
//     Default handling can be restored by calling RestoreDefaultHandling.
//
// We will refer to these events as application, internal and defaulted
// events respectively.
//
// System-defined events may have interface pointers, BSTR's, etc passed
// as parameters.  It is therefore essential that, for any message
// retrieved using GetEvent, a matching call to FreeEventParams is made
// to ensure that relevant interfaces are released and storage freed.
// Failure to call FreeEventParams will result in memory leaks, if not
// worse.
//
// Filters sending these messages to the filter graph should not AddRef()
// any interfaces that they may pass as parameters.  The filter graph
// manager will AddRef them if required.  E.g. if the event is to be queued
// for the application or queued to a worker thread.

// Each event listed below is immediately followed by a parameter list
// detailing the types of the parameters associated with the message,
// and an indication of whether the message is an application, internal
// or defaulted message.  This is then followed by a short description.
// The use of "void" in the parameter list implies that the parameter is not
// used.  Such parameters should be zero.



#define EC_COMPLETE                         0x01
// ( HRESULT, void ) : defaulted (special)
// Signals the completed playback of a stream within the graph.  This message
// is sent by renderers when they receive end-of-stream.  The default handling
// of this message results in a _SINGLE_ EC_COMPLETE being sent to the
// application when ALL of the individual renderers have signaled EC_COMPLETE
// to the filter graph.  If the default handing is canceled, the application
// will see all of the individual EC_COMPLETEs.


#define EC_USERABORT                        0x02
// ( void, void ) : application
// In some sense, the user has requested that playback be terminated.
// This message is typically sent by renderers that render into a
// window if the user closes the window into which it was rendering.
// It is up to the application to decide if playback should actually
// be stopped.


#define EC_ERRORABORT                       0x03
// ( HRESULT, void ) : application
// Operation aborted because of error


#define EC_TIME                             0x04
// ( DWORD, DWORD ) : application
// The requested reference time occurred.  (This event is currently not used).
// lParam1 is low dword of ref time, lParam2 is high dword of reftime.


#define EC_REPAINT                          0x05
// ( IPin * (could be NULL), void ) : defaulted
// A repaint is required - lParam1 contains the (IPin *) that needs the data
// to be sent again. Default handling is: if the output pin which the IPin is
// attached  to supports the IMediaEventSink interface then it will be called
// with the EC_REPAINT first.  If that fails then normal repaint processing is
// done by the filter graph.


// Stream error notifications
#define EC_STREAM_ERROR_STOPPED             0x06
#define EC_STREAM_ERROR_STILLPLAYING        0x07
// ( HRESULT, DWORD ) : application
// lParam 1 is major code, lParam2 is minor code, either may be zero.


#define EC_ERROR_STILLPLAYING               0x08
// ( HRESULT, void ) : application
// The filter graph manager may issue Run's to the graph asynchronously.
// If such a Run fails, EC_ERROR_STILLPLAYING is issued to notify the
// application of the failure.  The state of the underlying filters
// at such a time will be indeterminate - they will all have been asked
// to run, but some are almost certainly not.


#define EC_PALETTE_CHANGED                  0x09
// ( void, void ) : application
// notify application that the video palette has changed


#define EC_VIDEO_SIZE_CHANGED               0x0A
// ( DWORD, void ) : application
// Sent by video renderers.
// Notifies the application that the native video size has changed.
// LOWORD of the DWORD is the new width, HIWORD is the new height.


#define EC_QUALITY_CHANGE                   0x0B
// ( void, void ) : application
// Notify application that playback degradation has occurred


#define EC_SHUTTING_DOWN                    0x0C
// ( void, void ) : internal
// This message is sent by the filter graph manager to any plug-in
// distributors which support IMediaEventSink to notify them that
// the filter graph is starting to shutdown.


#define EC_CLOCK_CHANGED                    0x0D
// ( void, void ) : application
// Notify application that the clock has changed.
// (i.e. SetSyncSource has been called on the filter graph and has been
// distributed successfully to the filters in the graph.)


#define EC_OPENING_FILE	                    0x10
#define EC_BUFFERING_DATA                   0x11
// ( BOOL, void ) : application
// lParam1 == 1   --> starting to open file or buffer data
// lParam1 == 0   --> not opening or buffering any more
// (This event does not appear to be used by ActiveMovie.)


#define EC_FULLSCREEN_LOST                  0x12
// ( void, IBaseFilter * ) : application
// Sent by full screen renderers when switched away from full screen.
// IBaseFilter may be NULL.


#define EC_ACTIVATE                         0x13
// ( BOOL, IBaseFilter * ) : internal
// Sent by video renderers when they lose or gain activation.
// lParam1 is set to 1 if gained or 0 if lost
// lParam2 is the IBaseFilter* for the filter that is sending the message
// Used for sound follows focus and full-screen switching


#define EC_NEED_RESTART                     0x14
// ( void, void ) : defaulted
// Sent by renderers when they regain a resource (e.g. audio renderer).
// Causes a restart by Pause/put_Current/Run (if running).


#define EC_WINDOW_DESTROYED                 0x15
// ( IBaseFilter *, void ) : internal
// Sent by video renderers when the window has been destroyed. Handled
// by the filter graph / distributor telling the resource manager.
// lParam1 is the IBaseFilter* of the filter whose window is being destroyed


#define EC_DISPLAY_CHANGED                  0x16
// ( IPin *, void ) : internal
// Sent by renderers when they detect a display change. the filter graph
// will arrange for the graph to be stopped and the pin send in lParam1
// to be reconnected. by being reconnected it allows a renderer to reset
// and connect with a more appropriate format for the new display mode
// lParam1 contains an (IPin *) that should be reconnected by the graph


#define EC_STARVATION                       0x17
// ( void, void ) : defaulted
// Sent by a filter when it detects starvation. Default handling (only when
// running) is for the graph to be paused until all filters enter the
// paused state and then run. Normally this would be sent by a parser or source
// filter when too little data is arriving.


#define EC_OLE_EVENT			    0x18
// ( BSTR, BSTR ) : application
// Sent by a filter to pass a text string to the application.
// Conventionally, the first string is a type, and the second a parameter.


#define EC_NOTIFY_WINDOW                    0x19
// ( HWND, void ) : internal
// Pass the window handle around during pin connection.

#define EC_STREAM_CONTROL_STOPPED	    0x1A
// ( IPin * pSender, DWORD dwCookie )
// Notification that an earlier call to IAMStreamControl::StopAt
// has now take effect.  Calls to the method can be marked
// with a cookie which is passed back in the second parameter,
// allowing applications to easily tie together request
// and completion notifications.
//
// NB: IPin will point to the pin that actioned the Stop.  This
// may not be the pin that the StopAt was sent to.

#define EC_STREAM_CONTROL_STARTED	    0x1B
// ( IPin * pSender, DWORD dwCookie )
// Notification that an earlier call to IAMStreamControl::StartAt
// has now take effect.  Calls to the method can be marked
// with a cookie which is passed back in the second parameter,
// allowing applications to easily tie together request
// and completion notifications.
//
// NB: IPin will point to the pin that actioned the Start.  This
// may not be the pin that the StartAt was sent to.

#define EC_END_OF_SEGMENT                   0x1C
//
// ( const REFERENCE_TIME *pStreamTimeAtEndOfSegment, DWORD dwSegmentNumber )
//
// pStreamTimeAtEndOfSegment
//     pointer to the accumulated stream clock
//     time since the start of the segment - this is directly computable
//     as the sum of the previous and current segment durations (Stop - Start)
//     and the rate applied to each segment
//     The source add this time to the time within each segment to get
//     a total elapsed time
//
// dwSegmentNumber
//     Segment number - starts at 0
//
// Notifies that a segment end has been reached when the
// AM_SEEKING_Segment flags was set for IMediaSeeking::SetPositions
// Passes in an IMediaSeeking interface to allow the next segment
// to be defined by the application

#define EC_SEGMENT_STARTED                  0x1D
//
// ( const REFERENCE_TIME *pStreamTimeAtStartOfSegment, DWORD dwSegmentNumber)
//
// pStreamTimeAtStartOfSegment
//     pointer to the accumulated stream clock
//     time since the start of the segment - this is directly computable
//     as the sum of the previous segment durations (Stop - Start)
//     and the rate applied to each segment
//
// dwSegmentNumber
//     Segment number - starts at 0
//
// Notifies that a new segment has been started.
// This is sent synchronously by any entity that will issue
// EC_END_OF_SEGMENT when a new segment is started
// (See IMediaSeeking::SetPositions - AM_SEEKING_Segment flag)
// It is used to compute how many EC_END_OF_SEGMENT notifications
// to expect at the end of a segment and as a consitency check

#define EC_LENGTH_CHANGED                  0x1E
// (void, void)
// sent to indicate that the length of the "file" has changed
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\dllentry.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

//
// classes used to support dll entrypoints for COM objects.
//
#include <streams.h>

#ifdef DEBUG
#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE
#endif // _UNICODE
#endif // UNICODE

#include <tchar.h>
#endif // DEBUG

extern CFactoryTemplate g_Templates[];
extern int g_cTemplates;

HINSTANCE g_hInst;
DWORD	  g_amPlatform;		// VER_PLATFORM_WIN32_WINDOWS etc... (from GetVersionEx)
OSVERSIONINFO g_osInfo;

//
// an instance of this is created by the DLLGetClassObject entrypoint
// it uses the CFactoryTemplate object it is given to support the
// IClassFactory interface

class CClassFactory : public IClassFactory, public CBaseObject
{

private:
    const CFactoryTemplate *const m_pTemplate;

    ULONG m_cRef;

    static int m_cLocked;
public:
    CClassFactory(const CFactoryTemplate *);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG)AddRef();
    STDMETHODIMP_(ULONG)Release();

    // IClassFactory
    STDMETHODIMP CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, void **pv);
    STDMETHODIMP LockServer(BOOL fLock);

    // allow DLLGetClassObject to know about global server lock status
    static BOOL IsLocked() {
        return (m_cLocked > 0);
    };
};

// process-wide dll locked state
int CClassFactory::m_cLocked = 0;

CClassFactory::CClassFactory(const CFactoryTemplate *pTemplate)
: CBaseObject(NAME("Class Factory"))
, m_cRef(0)
, m_pTemplate(pTemplate)
{
}


STDMETHODIMP
CClassFactory::QueryInterface(REFIID riid,void **ppv)
{
    CheckPointer(ppv,E_POINTER)
    ValidateReadWritePtr(ppv,sizeof(PVOID));
    *ppv = NULL;

    // any interface on this object is the object pointer.
    if ((riid == IID_IUnknown) || (riid == IID_IClassFactory)) {
        *ppv = (LPVOID) this;
	// AddRef returned interface pointer
        ((LPUNKNOWN) *ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG)
CClassFactory::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CClassFactory::Release()
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    } else {
        return m_cRef;
    }
}

STDMETHODIMP
CClassFactory::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    void **pv)
{
    CheckPointer(pv,E_POINTER)
    ValidateReadWritePtr(pv,sizeof(void *));

    /* Enforce the normal OLE rules regarding interfaces and delegation */

    if (pUnkOuter != NULL) {
        if (IsEqualIID(riid,IID_IUnknown) == FALSE) {
            return ResultFromScode(E_NOINTERFACE);
        }
    }

    /* Create the new object through the derived class's create function */

    HRESULT hr = NOERROR;
    CUnknown *pObj = m_pTemplate->CreateInstance(pUnkOuter, &hr);

    if (pObj == NULL) {
	if (SUCCEEDED(hr)) {
	    hr = E_OUTOFMEMORY;
	}
	return hr;
    }

    /* Delete the object if we got a construction error */

    if (FAILED(hr)) {
        delete pObj;
        return hr;
    }

    /* Get a reference counted interface on the object */

    /* We wrap the non-delegating QI with NDAddRef & NDRelease. */
    /* This protects any outer object from being prematurely    */
    /* released by an inner object that may have to be created  */
    /* in order to supply the requested interface.              */
    pObj->NonDelegatingAddRef();
    hr = pObj->NonDelegatingQueryInterface(riid, pv);
    pObj->NonDelegatingRelease();
    /* Note that if NonDelegatingQueryInterface fails, it will  */
    /* not increment the ref count, so the NonDelegatingRelease */
    /* will drop the ref back to zero and the object will "self-*/
    /* destruct".  Hence we don't need additional tidy-up code  */
    /* to cope with NonDelegatingQueryInterface failing.        */

    if (SUCCEEDED(hr)) {
        ASSERT(*pv);
    }

    return hr;
}

STDMETHODIMP
CClassFactory::LockServer(BOOL fLock)
{
    if (fLock) {
        m_cLocked++;
    } else {
        m_cLocked--;
    }
    return NOERROR;
}


// --- COM entrypoints -----------------------------------------

//called by COM to get the class factory object for a given class
STDAPI
DllGetClassObject(
    REFCLSID rClsID,
    REFIID riid,
    void **pv)
{
    if (!(riid == IID_IUnknown) && !(riid == IID_IClassFactory)) {
            return E_NOINTERFACE;
    }

    // traverse the array of templates looking for one with this
    // class id
    for (int i = 0; i < g_cTemplates; i++) {
        const CFactoryTemplate * pT = &g_Templates[i];
        if (pT->IsClassID(rClsID)) {

            // found a template - make a class factory based on this
            // template

            *pv = (LPVOID) (LPUNKNOWN) new CClassFactory(pT);
            if (*pv == NULL) {
                return E_OUTOFMEMORY;
            }
            ((LPUNKNOWN)*pv)->AddRef();
            return NOERROR;
        }
    }
    return CLASS_E_CLASSNOTAVAILABLE;
}

//
//  Call any initialization routines
//
void
DllInitClasses(BOOL bLoading)
{
    int i;

    // traverse the array of templates calling the init routine
    // if they have one
    for (i = 0; i < g_cTemplates; i++) {
        const CFactoryTemplate * pT = &g_Templates[i];
        if (pT->m_lpfnInit != NULL) {
            (*pT->m_lpfnInit)(bLoading, pT->m_ClsID);
        }
    }

}

// called by COM to determine if this dll can be unloaded
// return ok unless there are outstanding objects or a lock requested
// by IClassFactory::LockServer
//
// CClassFactory has a static function that can tell us about the locks,
// and CCOMObject has a static function that can tell us about the active
// object count
STDAPI
DllCanUnloadNow()
{
    DbgLog((LOG_MEMORY,2,TEXT("DLLCanUnloadNow called - IsLocked = %d, Active objects = %d"),
        CClassFactory::IsLocked(),
        CBaseObject::ObjectsActive()));

    if (CClassFactory::IsLocked() || CBaseObject::ObjectsActive()) {
	return S_FALSE;
    } else {
        return S_OK;
    }
}


// --- standard WIN32 entrypoints --------------------------------------


extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE, ULONG, LPVOID);

BOOL WINAPI
DllEntryPoint(HINSTANCE hInstance, ULONG ulReason, LPVOID pv)
{
#ifdef DEBUG
    extern bool g_fDbgInDllEntryPoint;
    g_fDbgInDllEntryPoint = true;
#endif

    switch (ulReason)
    {

    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hInstance);
        DbgInitialise(hInstance);
	{
	    // The platform identifier is used to work out whether
	    // full unicode support is available or not.  Hence the
	    // default will be the lowest common denominator - i.e. N/A
            g_amPlatform = VER_PLATFORM_WIN32_WINDOWS; // win95 assumed in case GetVersionEx fails

            g_osInfo.dwOSVersionInfoSize = sizeof(g_osInfo);
            if (GetVersionEx(&g_osInfo)) {
        	g_amPlatform = g_osInfo.dwPlatformId;
	    } else {
		DbgLog((LOG_ERROR, 1, TEXT("Failed to get the OS platform, assuming Win95")));
	    }
	}
        g_hInst = hInstance;
        DllInitClasses(TRUE);
        break;

    case DLL_PROCESS_DETACH:
        DllInitClasses(FALSE);

#ifdef DEBUG
        if (CBaseObject::ObjectsActive()) {
            DbgSetModuleLevel(LOG_MEMORY, 2);
            TCHAR szInfo[512];
            extern TCHAR m_ModuleName[];     // Cut down module name

            TCHAR FullName[_MAX_PATH];      // Load the full path and module name
            TCHAR *pName;                   // Searches from the end for a backslash

            GetModuleFileName(NULL,FullName,_MAX_PATH);
            pName = _tcsrchr(FullName,'\\');
            if (pName == NULL) {
                pName = FullName;
            } else {
                pName++;
            }

	    DWORD cch = wsprintf(szInfo, TEXT("Executable: %s  Pid %x  Tid %x. "),
			    pName, GetCurrentProcessId(), GetCurrentThreadId());

            wsprintf(szInfo+cch, TEXT("Module %s, %d objects left active!"),
                     m_ModuleName, CBaseObject::ObjectsActive());
            DbgAssert(szInfo, TEXT(__FILE__),__LINE__);

	    // If running remotely wait for the Assert to be acknowledged
	    // before dumping out the object register
            DbgDumpObjectRegister();
        }
        DbgTerminate();
#endif
        break;
    }

#ifdef DEBUG
    g_fDbgInDllEntryPoint = false;
#endif
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\dllsetup.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// To be self registering, OLE servers must
// export functions named DllRegisterServer
// and DllUnregisterServer.  To allow use of
// custom and default implementations the
// defaults are named AMovieDllRegisterServer
// and AMovieDllUnregisterServer.
//
// To the use the default implementation you
// must provide stub functions.
//
// i.e. STDAPI DllRegisterServer()
//      {
//        return AMovieDllRegisterServer();
//      }
//
//      STDAPI DllUnregisterServer()
//      {
//        return AMovieDllUnregisterServer();
//      }
//
//
// AMovieDllRegisterServer   calls IAMovieSetup.Register(), and
// AMovieDllUnregisterServer calls IAMovieSetup.Unregister().

STDAPI AMovieDllRegisterServer2( BOOL );
STDAPI AMovieDllRegisterServer();
STDAPI AMovieDllUnregisterServer();

// helper functions
STDAPI EliminateSubKey( HKEY, LPTSTR );


STDAPI
AMovieSetupRegisterFilter2( const AMOVIESETUP_FILTER * const psetupdata
                          , IFilterMapper2 *                 pIFM2
                          , BOOL                             bRegister  );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\fourcc.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// FOURCCMap
//
// provides a mapping between old-style multimedia format DWORDs
// and new-style GUIDs.
//
// A range of 4 billion GUIDs has been allocated to ensure that this
// mapping can be done straightforwardly one-to-one in both directions.
//
// January 95


#ifndef __FOURCC__
#define __FOURCC__


// Multimedia format types are marked with DWORDs built from four 8-bit
// chars and known as FOURCCs. New multimedia AM_MEDIA_TYPE definitions include
// a subtype GUID. In order to simplify the mapping, GUIDs in the range:
//    XXXXXXXX-0000-0010-8000-00AA00389B71
// are reserved for FOURCCs.

class FOURCCMap : public GUID
{

public:
    FOURCCMap();
    FOURCCMap(DWORD Fourcc);
    FOURCCMap(const GUID *);


    DWORD GetFOURCC(void);
    void SetFOURCC(DWORD fourcc);
    void SetFOURCC(const GUID *);

private:
    void InitGUID();
};

#define GUID_Data2      0
#define GUID_Data3     0x10
#define GUID_Data4_1   0xaa000080
#define GUID_Data4_2   0x719b3800

inline void
FOURCCMap::InitGUID() {
    Data2 = GUID_Data2;
    Data3 = GUID_Data3;
    ((DWORD *)Data4)[0] = GUID_Data4_1;
    ((DWORD *)Data4)[1] = GUID_Data4_2;
}

inline
FOURCCMap::FOURCCMap() {
    InitGUID();
    SetFOURCC( DWORD(0));
}

inline
FOURCCMap::FOURCCMap(DWORD fourcc)
{
    InitGUID();
    SetFOURCC(fourcc);
}

inline
FOURCCMap::FOURCCMap(const GUID * pGuid)
{
    InitGUID();
    SetFOURCC(pGuid);
}

inline void
FOURCCMap::SetFOURCC(const GUID * pGuid)
{
    FOURCCMap * p = (FOURCCMap*) pGuid;
    SetFOURCC(p->GetFOURCC());
}

inline void
FOURCCMap::SetFOURCC(DWORD fourcc)
{
    Data1 = fourcc;
}

inline DWORD
FOURCCMap::GetFOURCC(void)
{
    return Data1;
}

#endif /* __FOURCC__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\measure.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

/*
   The idea is to pepper the source code with interesting measurements and
   have the last few thousand of these recorded in a circular buffer that
   can be post-processed to give interesting numbers.

   WHAT THE LOG LOOKS LIKE:

  Time (sec)   Type        Delta  Incident_Name
    0.055,41  NOTE      -.       Incident Nine  - Another note
    0.055,42  NOTE      0.000,01 Incident Nine  - Another note
    0.055,44  NOTE      0.000,02 Incident Nine  - Another note
    0.055,45  STOP      -.       Incident Eight - Also random
    0.055,47  START     -.       Incident Seven - Random
    0.055,49  NOTE      0.000,05 Incident Nine  - Another note
    ------- <etc.  there is a lot of this> ----------------
    0.125,60  STOP      0.000,03 Msr_Stop
    0.125,62  START     -.       Msr_Start
    0.125,63  START     -.       Incident Two   - Start/Stop
    0.125,65  STOP      0.000,03 Msr_Start
    0.125,66  START     -.       Msr_Stop
    0.125,68  STOP      0.000,05 Incident Two   - Start/Stop
    0.125,70  STOP      0.000,04 Msr_Stop
    0.125,72  START     -.       Msr_Start
    0.125,73  START     -.       Incident Two   - Start/Stop
    0.125,75  STOP      0.000,03 Msr_Start
    0.125,77  START     -.       Msr_Stop
    0.125,78  STOP      0.000,05 Incident Two   - Start/Stop
    0.125,80  STOP      0.000,03 Msr_Stop
    0.125,81  NOTE      -.       Incident Three - single Note
    0.125,83  START     -.       Incident Four  - Start, no stop
    0.125,85  START     -.       Incident Five  - Single Start/Stop
    0.125,87  STOP      0.000,02 Incident Five  - Single Start/Stop

Number      Average       StdDev     Smallest      Largest Incident_Name
    10     0.000,58     0.000,10     0.000,55     0.000,85 Incident One   - Note
    50     0.000,05     0.000,00     0.000,05     0.000,05 Incident Two   - Start/Stop
     1     -.           -.           -.           -.       Incident Three - single Note
     0     -.           -.           -.           -.       Incident Four  - Start, no stop
     1     0.000,02     -.           0.000,02     0.000,02 Incident Five  - Single Start/Stop
     0     -.           -.           -.           -.       Incident Six   - zero occurrences
   100     0.000,25     0.000,12     0.000,02     0.000,62 Incident Seven - Random
   100     0.000,79     0.000,48     0.000,02     0.001,92 Incident Eight - Also random
  5895     0.000,01     0.000,01     0.000,01     0.000,56 Incident Nine  - Another note
    10     0.000,03     0.000,00     0.000,03     0.000,04 Msr_Note
    50     0.000,03     0.000,00     0.000,03     0.000,04 Msr_Start
    50     0.000,04     0.000,03     0.000,03     0.000,31 Msr_Stop

  WHAT IT MEANS:
    The log shows what happened and when.  Each line shows the time at which
    something happened (see WHAT YOU CODE below) what it was that happened
    and (if approporate) the time since the corresponding previous event
    (that's the delta column).

    The statistics show how many times each event occurred, what the average
    delta time was, also the standard deviation, largest and smalles delta.

   WHAT YOU CODE:

   Before anything else executes: - register your ids

    int id1     = Msr_Register("Incident One   - Note");
    int id2     = Msr_Register("Incident Two   - Start/Stop");
    int id3     = Msr_Register("Incident Three - single Note");
    etc.

   At interesting moments:

       // To measure a repetitive event - e.g. end of bitblt to screen
       Msr_Note(Id9);             // e.g. "video frame hiting the screen NOW!"

           or

       // To measure an elapsed time e.g. time taken to decode an MPEG B-frame
       Msr_Start(Id2);            // e.g. "Starting to decode MPEG B-frame"
         . . .
       MsrStop(Id2);              //      "Finished MPEG decode"

   At the end:

       HANDLE hFile;
       hFile = CreateFile("Perf.log", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
       Msr_Dump(hFile);           // This writes the log out to the file
       CloseHandle(hFile);

           or

       Msr_Dump(NULL);            // This writes it to DbgLog((LOG_TRACE,0, ... ));
                                  // but if you are writing it out to the debugger
                                  // then the times are probably all garbage because
                                  // the debugger can make things run awfully slow.

    A given id should be used either for start / stop or Note calls.  If Notes
    are mixed in with Starts and Stops their statistics will be gibberish.

    If you code the calls in upper case i.e. MSR_START(idMunge); then you get
    macros which will turn into nothing unless PERF is defined.

    You can reset the statistical counts for a given id by calling Reset(Id).
    They are reset by default at the start.
    It logs Reset as a special incident, so you can see it in the log.

    The log is a circular buffer in storage (to try to minimise disk I/O).
    It overwrites the oldest entries once full.  The statistics include ALL
    incidents since the last Reset, whether still visible in the log or not.
*/

#ifndef __MEASURE__
#define __MEASURE__

#ifdef PERF
#define MSR_INIT() Msr_Init()
#define MSR_TERMINATE() Msr_Terminate()
#define MSR_REGISTER(a) Msr_Register(a)
#define MSR_RESET(a) Msr_Reset(a)
#define MSR_CONTROL(a) Msr_Control(a)
#define MSR_START(a) Msr_Start(a)
#define MSR_STOP(a) Msr_Stop(a)
#define MSR_NOTE(a) Msr_Note(a)
#define MSR_INTEGER(a,b) Msr_Integer(a,b)
#define MSR_DUMP(a) Msr_Dump(a)
#define MSR_DUMPSTATS(a) Msr_DumpStats(a)
#else
#define MSR_INIT() ((void)0)
#define MSR_TERMINATE() ((void)0)
#define MSR_REGISTER(a) 0
#define MSR_RESET(a) ((void)0)
#define MSR_CONTROL(a) ((void)0)
#define MSR_START(a) ((void)0)
#define MSR_STOP(a) ((void)0)
#define MSR_NOTE(a) ((void)0)
#define MSR_INTEGER(a,b) ((void)0)
#define MSR_DUMP(a) ((void)0)
#define MSR_DUMPSTATS(a) ((void)0)
#endif

#ifdef __cplusplus
extern "C" {
#endif

// This must be called first - (called by the DllEntry)

void WINAPI Msr_Init(void);


// Call this last to clean up (or just let it fall off the end - who cares?)

void WINAPI Msr_Terminate(void);


// Call this to get an Id for an "incident" that you can pass to Start, Stop or Note
// everything that's logged is called an "incident".

int  WINAPI Msr_Register(LPTSTR Incident);


// Reset the statistical counts for an incident

void WINAPI Msr_Reset(int Id);


// Reset all the counts for all incidents
#define MSR_RESET_ALL 0
#define MSR_PAUSE 1
#define MSR_RUN 2

void WINAPI Msr_Control(int iAction);


// log the start of an operation

void WINAPI Msr_Start(int Id);


// log the end of an operation

void WINAPI Msr_Stop(int Id);


// log a one-off or repetitive operation

void WINAPI Msr_Note(int Id);


// log an integer (on which we can see statistics later)
void WINAPI Msr_Integer(int Id, int n);


// print out all the vaialable log (it may have wrapped) and then the statistics.
// When the log wraps you lose log but the statistics are still complete.
// hFIle==NULL => use DbgLog
// otherwise hFile must have come from CreateFile or OpenFile.

void WINAPI Msr_Dump(HANDLE hFile);


// just dump the statistics - never mind the log

void WINAPI Msr_DumpStats(HANDLE hFile);

// Type definitions in case you want to declare a pointer to the dump functions
// (makes it a trifle easier to do dynamic linking
// i.e. LoadModule, GetProcAddress and call that)

// Typedefs so can declare MSR_DUMPPROC *MsrDumpStats; or whatever
typedef void WINAPI MSR_DUMPPROC(HANDLE hFile);
typedef void WINAPI MSR_CONTROLPROC(int iAction);


#ifdef __cplusplus
}
#endif

#endif // __MEASURE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\msgthrd.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// support for a worker thread class to which you can asynchronously post
// messages


// Message class - really just a structure.
//
class CMsg {
public:
    UINT uMsg;
    DWORD dwFlags;
    LPVOID lpParam;
    CAMEvent *pEvent;

    CMsg(UINT u, DWORD dw, LPVOID lp, CAMEvent *pEvnt)
        : uMsg(u), dwFlags(dw), lpParam(lp), pEvent(pEvnt) {}

    CMsg()
        : uMsg(0), dwFlags(0L), lpParam(NULL), pEvent(NULL) {}
};

// This is the actual thread class.  It exports all the usual thread control
// functions.  The created thread is different from a normal WIN32 thread in
// that it is prompted to perform particaular tasks by responding to messages
// posted to its message queue.
//
class AM_NOVTABLE CMsgThread {
private:
    static DWORD WINAPI DefaultThreadProc(LPVOID lpParam);
    DWORD               m_ThreadId;
    HANDLE              m_hThread;

protected:

    // if you want to override GetThreadMsg to block on other things
    // as well as this queue, you need access to this
    CGenericList<CMsg>        m_ThreadQueue;
    CCritSec                  m_Lock;
    HANDLE                    m_hSem;
    LONG                      m_lWaiting;

public:
    CMsgThread()
        : m_ThreadId(0),
        m_hThread(NULL),
        m_lWaiting(0),
        m_hSem(NULL),
        // make a list with a cache of 5 items
        m_ThreadQueue(NAME("MsgThread list"), 5)
        {
        }

    ~CMsgThread();
    // override this if you want to block on other things as well
    // as the message loop
    void virtual GetThreadMsg(CMsg *msg);

    // override this if you want to do something on thread startup
    virtual void OnThreadInit() {
    };

    BOOL CreateThread();

    BOOL WaitForThreadExit(LPDWORD lpdwExitCode) {
        if (m_hThread != NULL) {
            WaitForSingleObject(m_hThread, INFINITE);
            return GetExitCodeThread(m_hThread, lpdwExitCode);
        }
        return FALSE;
    }

    DWORD ResumeThread() {
        return ::ResumeThread(m_hThread);
    }

    DWORD SuspendThread() {
        return ::SuspendThread(m_hThread);
    }

    int GetThreadPriority() {
        return ::GetThreadPriority(m_hThread);
    }

    BOOL SetThreadPriority(int nPriority) {
        return ::SetThreadPriority(m_hThread, nPriority);
    }

    HANDLE GetThreadHandle() {
        return m_hThread;
    }

    DWORD GetThreadId() {
        return m_ThreadId;
    }


    void PutThreadMsg(UINT uMsg, DWORD dwMsgFlags,
                      LPVOID lpMsgParam, CAMEvent *pEvent = NULL) {
        CAutoLock lck(&m_Lock);
        CMsg* pMsg = new CMsg(uMsg, dwMsgFlags, lpMsgParam, pEvent);
        m_ThreadQueue.AddTail(pMsg);
        if (m_lWaiting != 0) {
            ReleaseSemaphore(m_hSem, m_lWaiting, 0);
            m_lWaiting = 0;
        }
    }

    // This is the function prototype of the function that the client
    // supplies.  It is always called on the created thread, never on
    // the creator thread.
    //
    virtual LRESULT ThreadMessageProc(
        UINT uMsg, DWORD dwFlags, LPVOID lpParam, CAMEvent *pEvent) = 0;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\mtype.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Class that holds and manages media type information, December 1994

// helper class that derived pin objects can use to compare media
// types etc. Has same data members as the struct AM_MEDIA_TYPE defined
// in the streams IDL file, but also has (non-virtual) functions

#include <streams.h>

CMediaType::~CMediaType(){
    FreeMediaType(*this);
}


CMediaType::CMediaType()
{
    InitMediaType();
}


CMediaType::CMediaType(const GUID * type)
{
    InitMediaType();
    majortype = *type;
}


// copy constructor does a deep copy of the format block

CMediaType::CMediaType(const AM_MEDIA_TYPE& rt)
{
    CopyMediaType(this, &rt);
}

CMediaType::CMediaType(const CMediaType& rt)
{
    CopyMediaType(this, &rt);
}

// this class inherits publicly from AM_MEDIA_TYPE so the compiler could generate
// the following assignment operator itself, however it could introduce some
// memory conflicts and leaks in the process because the structure contains
// a dynamically allocated block (pbFormat) which it will not copy correctly

CMediaType&
CMediaType::operator=(const AM_MEDIA_TYPE& rt)
{
    if (&rt != this) {
        FreeMediaType(*this);
        CopyMediaType(this, &rt);
    }
    return *this;
}


CMediaType&
CMediaType::operator=(const CMediaType& rt)
{
    *this = (AM_MEDIA_TYPE &) rt;
    return *this;
}

BOOL
CMediaType::operator == (const CMediaType& rt) const
{
    // I don't believe we need to check sample size or
    // temporal compression flags, since I think these must
    // be represented in the type, subtype and format somehow. They
    // are pulled out as separate flags so that people who don't understand
    // the particular format representation can still see them, but
    // they should duplicate information in the format block.

    return ((IsEqualGUID(majortype,rt.majortype) == TRUE) &&
        (IsEqualGUID(subtype,rt.subtype) == TRUE) &&
        (IsEqualGUID(formattype,rt.formattype) == TRUE) &&
        (cbFormat == rt.cbFormat) &&
        ( (cbFormat == 0) ||
          (memcmp(pbFormat, rt.pbFormat, cbFormat) == 0)));
}


BOOL
CMediaType::operator != (const CMediaType& rt) const
{
    /* Check to see if they are equal */

    if (*this == rt) {
        return FALSE;
    }
    return TRUE;
}


BOOL
CMediaType::IsValid() const
{
    return (!IsEqualGUID(majortype,GUID_NULL));
}


void
CMediaType::SetType(const GUID* ptype)
{
    majortype = *ptype;
}


void
CMediaType::SetSubtype(const GUID* ptype)
{
    subtype = *ptype;
}


ULONG
CMediaType::GetSampleSize() const {
    if (IsFixedSize()) {
        return lSampleSize;
    } else {
        return 0;
    }
}


void
CMediaType::SetSampleSize(ULONG sz) {
    if (sz == 0) {
        SetVariableSize();
    } else {
        bFixedSizeSamples = TRUE;
        lSampleSize = sz;
    }
}


void
CMediaType::SetVariableSize() {
    bFixedSizeSamples = FALSE;
}


void
CMediaType::SetTemporalCompression(BOOL bCompressed) {
    bTemporalCompression = bCompressed;
}

BOOL
CMediaType::SetFormat(BYTE * pformat, ULONG cb)
{
    if (NULL == AllocFormatBuffer(cb))
	return(FALSE);

    ASSERT(pbFormat);
    memcpy(pbFormat, pformat, cb);
    return(TRUE);
}


// set the type of the media type format block, this type defines what you
// will actually find in the format pointer. For example FORMAT_VideoInfo or
// FORMAT_WaveFormatEx. In the future this may be an interface pointer to a
// property set. Before sending out media types this should be filled in.

void
CMediaType::SetFormatType(const GUID *pformattype)
{
    formattype = *pformattype;
}


// reset the format buffer

void CMediaType::ResetFormatBuffer()
{
    if (cbFormat) {
        CoTaskMemFree((PVOID)pbFormat);
    }
    cbFormat = 0;
    pbFormat = NULL;
}


// allocate length bytes for the format and return a read/write pointer
// If we cannot allocate the new block of memory we return NULL leaving
// the original block of memory untouched (as does ReallocFormatBuffer)

BYTE*
CMediaType::AllocFormatBuffer(ULONG length)
{
    ASSERT(length);

    // do the types have the same buffer size

    if (cbFormat == length) {
        return pbFormat;
    }

    // allocate the new format buffer

    BYTE *pNewFormat = (PBYTE)CoTaskMemAlloc(length);
    if (pNewFormat == NULL) {
        if (length <= cbFormat) return pbFormat; //reuse the old block anyway.
        return NULL;
    }

    // delete the old format

    if (cbFormat != 0) {
        ASSERT(pbFormat);
        CoTaskMemFree((PVOID)pbFormat);
    }

    cbFormat = length;
    pbFormat = pNewFormat;
    return pbFormat;
}


// reallocate length bytes for the format and return a read/write pointer
// to it. We keep as much information as we can given the new buffer size
// if this fails the original format buffer is left untouched. The caller
// is responsible for ensuring the size of memory required is non zero

BYTE*
CMediaType::ReallocFormatBuffer(ULONG length)
{
    ASSERT(length);

    // do the types have the same buffer size

    if (cbFormat == length) {
        return pbFormat;
    }

    // allocate the new format buffer

    BYTE *pNewFormat = (PBYTE)CoTaskMemAlloc(length);
    if (pNewFormat == NULL) {
        if (length <= cbFormat) return pbFormat; //reuse the old block anyway.
        return NULL;
    }

    // copy any previous format (or part of if new is smaller)
    // delete the old format and replace with the new one

    if (cbFormat != 0) {
        ASSERT(pbFormat);
        memcpy(pNewFormat,pbFormat,min(length,cbFormat));
        CoTaskMemFree((PVOID)pbFormat);
    }

    cbFormat = length;
    pbFormat = pNewFormat;
    return pNewFormat;
}

// initialise a media type structure

void CMediaType::InitMediaType()
{
    ZeroMemory((PVOID)this, sizeof(*this));
    lSampleSize = 1;
    bFixedSizeSamples = TRUE;
}


// a partially specified media type can be passed to IPin::Connect
// as a constraint on the media type used in the connection.
// the type, subtype or format type can be null.
BOOL
CMediaType::IsPartiallySpecified(void) const
{
    if ((majortype == GUID_NULL) ||
        (formattype == GUID_NULL)) {
            return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
CMediaType::MatchesPartial(const CMediaType* ppartial) const
{
    if ((ppartial->majortype != GUID_NULL) &&
        (majortype != ppartial->majortype)) {
            return FALSE;
    }
    if ((ppartial->subtype != GUID_NULL) &&
        (subtype != ppartial->subtype)) {
            return FALSE;
    }

    if (ppartial->formattype != GUID_NULL) {
        // if the format block is specified then it must match exactly
        if (formattype != ppartial->formattype) {
            return FALSE;
        }
        if (cbFormat != ppartial->cbFormat) {
            return FALSE;
        }
        if ((cbFormat != 0) &&
            (memcmp(pbFormat, ppartial->pbFormat, cbFormat) != 0)) {
                return FALSE;
        }
    }

    return TRUE;

}



// general purpose function to delete a heap allocated AM_MEDIA_TYPE structure
// which is useful when calling IEnumMediaTypes::Next as the interface
// implementation allocates the structures which you must later delete
// the format block may also be a pointer to an interface to release

void WINAPI DeleteMediaType(AM_MEDIA_TYPE *pmt)
{
    // allow NULL pointers for coding simplicity

    if (pmt == NULL) {
        return;
    }

    FreeMediaType(*pmt);
    CoTaskMemFree((PVOID)pmt);
}


// this also comes in useful when using the IEnumMediaTypes interface so
// that you can copy a media type, you can do nearly the same by creating
// a CMediaType object but as soon as it goes out of scope the destructor
// will delete the memory it allocated (this takes a copy of the memory)

AM_MEDIA_TYPE * WINAPI CreateMediaType(AM_MEDIA_TYPE const *pSrc)
{
    ASSERT(pSrc);

    // Allocate a block of memory for the media type

    AM_MEDIA_TYPE *pMediaType =
        (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));

    if (pMediaType == NULL) {
        return NULL;
    }
    // Copy the variable length format block

    CopyMediaType(pMediaType,pSrc);

    return pMediaType;
}


//  Copy 1 media type to another

void WINAPI CopyMediaType(AM_MEDIA_TYPE *pmtTarget, const AM_MEDIA_TYPE *pmtSource)
{
    //  We'll leak if we copy onto one that already exists - there's one
    //  case we can check like that - copying to itself.
    ASSERT(pmtSource != pmtTarget);
    *pmtTarget = *pmtSource;
    if (pmtSource->cbFormat != 0) {
        ASSERT(pmtSource->pbFormat != NULL);
        pmtTarget->pbFormat = (PBYTE)CoTaskMemAlloc(pmtSource->cbFormat);
        if (pmtTarget->pbFormat == NULL) {
            pmtTarget->cbFormat = 0;
        } else {
            CopyMemory((PVOID)pmtTarget->pbFormat, (PVOID)pmtSource->pbFormat,
                       pmtTarget->cbFormat);
        }
    }
    if (pmtTarget->pUnk != NULL) {
        pmtTarget->pUnk->AddRef();
    }
}

//  Free an existing media type (ie free resources it holds)

void WINAPI FreeMediaType(AM_MEDIA_TYPE& mt)
{
    if (mt.cbFormat != 0) {
        CoTaskMemFree((PVOID)mt.pbFormat);

        // Strictly unnecessary but tidier
        mt.cbFormat = 0;
        mt.pbFormat = NULL;
    }
    if (mt.pUnk != NULL) {
        mt.pUnk->Release();
        mt.pUnk = NULL;
    }
}

//  Initialize a media type from a WAVEFORMATEX

STDAPI CreateAudioMediaType(
    const WAVEFORMATEX *pwfx,
    AM_MEDIA_TYPE *pmt,
    BOOL bSetFormat
)
{
    pmt->majortype            = MEDIATYPE_Audio;
    pmt->subtype              = FOURCCMap(pwfx->wFormatTag);
    pmt->formattype           = FORMAT_WaveFormatEx;
    pmt->bFixedSizeSamples    = TRUE;
    pmt->bTemporalCompression = FALSE;
    pmt->lSampleSize          = pwfx->nBlockAlign;
    pmt->pUnk                 = NULL;
    if (bSetFormat) {
        if (pwfx->wFormatTag == WAVE_FORMAT_PCM) {
            pmt->cbFormat         = sizeof(WAVEFORMATEX);
        } else {
            pmt->cbFormat         = sizeof(WAVEFORMATEX) + pwfx->cbSize;
        }
        pmt->pbFormat             = (PBYTE)CoTaskMemAlloc(pmt->cbFormat);
        if (pmt->pbFormat == NULL) {
            return E_OUTOFMEMORY;
        }
        if (pwfx->wFormatTag == WAVE_FORMAT_PCM) {
            CopyMemory(pmt->pbFormat, pwfx, sizeof(PCMWAVEFORMAT));
            ((WAVEFORMATEX *)pmt->pbFormat)->cbSize = 0;
        } else {
            CopyMemory(pmt->pbFormat, pwfx, pmt->cbFormat);
        }
    }
    return S_OK;
}

// eliminate very many spurious warnings from MS compiler
#pragma warning(disable:4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\refclock.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//  REFCLOCK.H
//  Implements IReferenceClock Interface

#ifndef __BASEREFCLOCK__
#define __BASEREFCLOCK__

#include <Schedule.h>

const UINT RESOLUTION = 1;                      /* High resolution timer */
const INT ADVISE_CACHE = 4;                     /* Default cache size */
const LONGLONG MAX_TIME = 0x7FFFFFFFFFFFFFFF;   /* Maximum LONGLONG value */

inline LONGLONG WINAPI ConvertToMilliseconds(const REFERENCE_TIME& RT)
{
    /* This converts an arbitrary value representing a reference time
       into a MILLISECONDS value for use in subsequent system calls */

    return (RT / (UNITS / MILLISECONDS));
}

/* This class hierarchy will support an IReferenceClock interface so
   that an audio card (or other externally driven clock) can update the
   system wide clock that everyone uses.

   The interface will be pretty thin with probably just one update method
   This interface has not yet been defined.
 */

/* This abstract base class implements the IReferenceClock
 * interface.  Classes that actually provide clock signals (from
 * whatever source) have to be derived from this class.
 *
 * The abstract class provides implementations for:
 * 	CUnknown support
 *      locking support (CCritSec)
 *	client advise code (creates a thread)
 *
 * Question: what can we do about quality?  Change the timer
 * resolution to lower the system load?  Up the priority of the
 * timer thread to force more responsive signals?
 *
 * During class construction we create a worker thread that is destroyed during
 * destuction.  This thread executes a series of WaitForSingleObject calls,
 * waking up when a command is given to the thread or the next wake up point
 * is reached.  The wakeup points are determined by clients making Advise
 * calls.
 *
 * Each advise call defines a point in time when they wish to be notified.  A
 * periodic advise is a series of these such events.  We maintain a list of
 * advise links and calculate when the nearest event notification is due for.
 * We then call WaitForSingleObject with a timeout equal to this time.  The
 * handle we wait on is used by the class to signal that something has changed
 * and that we must reschedule the next event.  This typically happens when
 * someone comes in and asks for an advise link while we are waiting for an
 * event to timeout.
 *
 * While we are modifying the list of advise requests we
 * are protected from interference through a critical section.  Clients are NOT
 * advised through callbacks.  One shot clients have an event set, while
 * periodic clients have a semaphore released for each event notification.  A
 * semaphore allows a client to be kept up to date with the number of events
 * actually triggered and be assured that they can't miss multiple events being
 * set.
 *
 * Keeping track of advises is taken care of by the CAMSchedule class.
 */

class CBaseReferenceClock
: public CUnknown, public IReferenceClock, public CCritSec
{
protected:
    virtual ~CBaseReferenceClock();     // Don't let me be created on the stack!
public:
    CBaseReferenceClock(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr, CAMSchedule * pSched = 0 );

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void ** ppv);

    DECLARE_IUNKNOWN

    /* IReferenceClock methods */
    // Derived classes must implement GetPrivateTime().  All our GetTime
    // does is call GetPrivateTime and then check so that time does not
    // go backwards.  A return code of S_FALSE implies that the internal
    // clock has gone backwards and GetTime time has halted until internal
    // time has caught up. (Don't know if this will be much use to folk,
    // but it seems odd not to use the return code for something useful.)
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    // When this is called, it sets m_rtLastGotTime to the time it returns.

    /* Provide standard mechanisms for scheduling events */

    /* Ask for an async notification that a time has elapsed */
    STDMETHODIMP AdviseTime(
        REFERENCE_TIME baseTime,        // base reference time
        REFERENCE_TIME streamTime,      // stream offset time
        HEVENT hEvent,                  // advise via this event
        DWORD_PTR *pdwAdviseCookie          // where your cookie goes
    );

    /* Ask for an asynchronous periodic notification that a time has elapsed */
    STDMETHODIMP AdvisePeriodic(
        REFERENCE_TIME StartTime,       // starting at this time
        REFERENCE_TIME PeriodTime,      // time between notifications
        HSEMAPHORE hSemaphore,          // advise via a semaphore
        DWORD_PTR *pdwAdviseCookie          // where your cookie goes
    );

    /* Cancel a request for notification(s) - if the notification was
     * a one shot timer then this function doesn't need to be called
     * as the advise is automatically cancelled, however it does no
     * harm to explicitly cancel a one-shot advise.  It is REQUIRED that
     * clients call Unadvise to clear a Periodic advise setting.
     */

    STDMETHODIMP Unadvise(DWORD_PTR dwAdviseCookie);

    /* Methods for the benefit of derived classes or outer objects */

    // GetPrivateTime() is the REAL clock.  GetTime is just a cover for
    // it.  Derived classes will probably override this method but not
    // GetTime() itself.
    // The important point about GetPrivateTime() is it's allowed to go
    // backwards.  Our GetTime() will keep returning the LastGotTime
    // until GetPrivateTime() catches up.
    virtual REFERENCE_TIME GetPrivateTime();

    /* Provide a method for correcting drift */
    STDMETHODIMP SetTimeDelta( const REFERENCE_TIME& TimeDelta );

    CAMSchedule * GetSchedule() const { return m_pSchedule; }

private:
    REFERENCE_TIME m_rtPrivateTime;     // Current best estimate of time
    DWORD          m_dwPrevSystemTime;  // Last vaule we got from timeGetTime
    REFERENCE_TIME m_rtLastGotTime;     // Last time returned by GetTime
    REFERENCE_TIME m_rtNextAdvise;      // Time of next advise
    UINT           m_TimerResolution;

#ifdef PERF
    int m_idGetSystemTime;
#endif

// Thread stuff
public:
    void TriggerThread()                	// Wakes thread up.  Need to do this if
    {						// time to next advise needs reevaluating.
	EXECUTE_ASSERT(SetEvent(m_pSchedule->GetEvent()));
    }


private:
    BOOL           m_bAbort;            // Flag used for thread shutdown
    HANDLE         m_hThread;           // Thread handle

    HRESULT AdviseThread();             // Method in which the advise thread runs
    static DWORD __stdcall AdviseThreadFunction(LPVOID); // Function used to get there

protected:
    CAMSchedule * const m_pSchedule;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\ksuuids.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// contains the GUIDs for the MediaType type, subtype fields and format types 
// for DVD/MPEG2 media types.


//
// --- MPEG 2 definitions ---
//

// e06d8020-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIATYPE_MPEG2_PES,
0xe06d8020, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea)


#if 0
DEFINE_GUID(MEDIATYPE_CONTROL,
0xe06d8021, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
#endif // #if 0


// e06d8026-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_VIDEO,
0xe06d8026, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea)

// use MPEG2VIDEOINFO (defined below) with FORMAT_MPEG2_VIDEO
// e06d80e3-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_MPEG2_VIDEO,
0xe06d80e3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea)

// F72A76A0-EB0A-11d0-ACE4-0000C0CC16BA       (FORMAT_VideoInfo2)
OUR_GUID_ENTRY(FORMAT_VIDEOINFO2,
0xf72a76A0L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba)

// MPEG2 Other subtypes
// e06d8022-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_PROGRAM,
0xe06d8022, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8023-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_TRANSPORT,
0xe06d8023, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d802b-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_AUDIO,
0xe06d802b, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d802c-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DOLBY_AC3,
0xe06d802c, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d802d-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_SUBPICTURE,
0xe06d802d, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8032-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_LPCM_AUDIO,
0xe06d8032, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// DVD-related mediatypes
// ED0B916A-044D-11d1-AA78-00C04FC31D60
OUR_GUID_ENTRY(MEDIATYPE_DVD_ENCRYPTED_PACK,
0xed0b916a, 0x044d, 0x11d1, 0xaa, 0x78, 0x00, 0xc0, 0x04f, 0xc3, 0x1d, 0x60)

// e06d802e-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIATYPE_DVD_NAVIGATION,
0xe06d802e, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d802f-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_NAVIGATION_PCI,                             
0xe06d802f, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8030-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_NAVIGATION_DSI,
0xe06d8030, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8031-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_NAVIGATION_PROVIDER,
0xe06d8031, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

//
// DVD - MPEG2/AC3-related Formats
//
// e06d80e3-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_MPEG2Video,
0xe06d80e3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d80e4-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_DolbyAC3,
0xe06d80e4, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d80e5-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_MPEG2Audio,
0xe06d80e5, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d80e6-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_DVD_LPCMAudio,
0xe06d80e6, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)


//
// KS Property Set Id (to communicate with the WDM Proxy filter) -- from
// ksmedia.h of WDM DDK.
//

// BFABE720-6E1F-11D0-BCF2-444553540000
OUR_GUID_ENTRY(AM_KSPROPSETID_AC3,
0xBFABE720, 0x6E1F, 0x11D0, 0xBC, 0xF2, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00)

// ac390460-43af-11d0-bd6a-003505c103a9
OUR_GUID_ENTRY(AM_KSPROPSETID_DvdSubPic,
0xac390460, 0x43af, 0x11d0, 0xbd, 0x6a, 0x00, 0x35, 0x05, 0xc1, 0x03, 0xa9)

// 0E8A0A40L-6AEF-11D0-9ED0-00A024CA19B3
OUR_GUID_ENTRY(AM_KSPROPSETID_CopyProt,
0x0E8A0A40, 0x6AEF, 0x11D0, 0x9E, 0xD0, 0x00, 0xA0, 0x24, 0xCA, 0x19, 0xB3)

// A503C5C0-1D1D-11d1-AD80-444553540000
OUR_GUID_ENTRY(AM_KSPROPSETID_TSRateChange, 
0xa503c5c0, 0x1d1d, 0x11d1, 0xad, 0x80, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0)


//
// KS categories from ks.h and ksmedia.h
//
//

// 65E8773D-8F56-11D0-A3B9-00A0C9223196
OUR_GUID_ENTRY(AM_KSCATEGORY_CAPTURE,
0x65E8773DL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 65E8773E-8F56-11D0-A3B9-00A0C9223196
OUR_GUID_ENTRY(AM_KSCATEGORY_RENDER,
0x65E8773EL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 1E84C900-7E70-11D0-A5D6-28DB04C10000
OUR_GUID_ENTRY(AM_KSCATEGORY_DATACOMPRESSOR,
0x1E84C900L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00)

// 6994AD04-93EF-11D0-A3CC-00A0C9223196
OUR_GUID_ENTRY(AM_KSCATEGORY_AUDIO,
0x6994AD04L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 6994AD05-93EF-11D0-A3CC-00A0C9223196
OUR_GUID_ENTRY(AM_KSCATEGORY_VIDEO,
0x6994AD05L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// a799a800-a46d-11d0-a18c-00a02401dcd4
OUR_GUID_ENTRY(AM_KSCATEGORY_TVTUNER,
0xa799a800L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4)

// a799a801-a46d-11d0-a18c-00a02401dcd4
OUR_GUID_ENTRY(AM_KSCATEGORY_CROSSBAR,
0xa799a801L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4)               

// a799a802-a46d-11d0-a18c-00a02401dcd4
OUR_GUID_ENTRY(AM_KSCATEGORY_TVAUDIO,
0xa799a802L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4)


//
// guids needed to support IKsPin interface
//

// d3abc7e0l-9a61-11d0-a40d00a0c9223196
OUR_GUID_ENTRY(IID_IKsInterfaceHandler,
0xD3ABC7E0L, 0x9A61, 0x11D0, 0xA4, 0x0D, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 5ffbaa02l-49a3-11d0-9f3600aa00a216a1
OUR_GUID_ENTRY(IID_IKsDataTypeHandler,
0x5FFBAA02L, 0x49A3, 0x11D0, 0x9F, 0x36, 0x00, 0xAA, 0x00, 0xA2, 0x16, 0xA1)

// b61178d1-a2d9-11cf-9e53-00aa00a216a1
OUR_GUID_ENTRY(IID_IKsPin,
0xb61178d1L, 0xa2d9, 0x11cf, 0x9e, 0x53, 0x00, 0xaa, 0x00, 0xa2, 0x16, 0xa1)

// 1A8766A0-62CE-11CF-A5D6-28DB04C10000
OUR_GUID_ENTRY(AM_INTERFACESETID_Standard,
0x1A8766A0L, 0x62CE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\mtype.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Class that holds and manages media type information, December 1994

#ifndef __MTYPE__
#define __MTYPE__

/* Helper class that derived pin objects can use to compare media
   types etc. Has same data members as the struct AM_MEDIA_TYPE defined
   in the streams IDL file, but also has (non-virtual) functions */

class CMediaType : public _AMMediaType {

public:

    ~CMediaType();
    CMediaType();
    CMediaType(const GUID * majortype);
    CMediaType(const AM_MEDIA_TYPE&);
    CMediaType(const CMediaType&);

    CMediaType& operator=(const CMediaType&);
    CMediaType& operator=(const AM_MEDIA_TYPE&);

    BOOL operator == (const CMediaType&) const;
    BOOL operator != (const CMediaType&) const;

    BOOL IsValid() const;

    const GUID *Type() const { return &majortype;} ;
    void SetType(const GUID *);
    const GUID *Subtype() const { return &subtype;} ;
    void SetSubtype(const GUID *);

    BOOL IsFixedSize() const {return bFixedSizeSamples; };
    BOOL IsTemporalCompressed() const {return bTemporalCompression; };
    ULONG GetSampleSize() const;

    void SetSampleSize(ULONG sz);
    void SetVariableSize();
    void SetTemporalCompression(BOOL bCompressed);

    // read/write pointer to format - can't change length without
    // calling SetFormat, AllocFormatBuffer or ReallocFormatBuffer

    BYTE*   Format() const {return pbFormat; };
    ULONG   FormatLength() const { return cbFormat; };

    void SetFormatType(const GUID *);
    const GUID *FormatType() const {return &formattype; };
    BOOL SetFormat(BYTE *pFormat, ULONG length);
    void ResetFormatBuffer();
    BYTE* AllocFormatBuffer(ULONG length);
    BYTE* ReallocFormatBuffer(ULONG length);

    void InitMediaType();

    BOOL MatchesPartial(const CMediaType* ppartial) const;
    BOOL IsPartiallySpecified(void) const;
};


/* General purpose functions to copy and delete a task allocated AM_MEDIA_TYPE
   structure which is useful when using the IEnumMediaFormats interface as
   the implementation allocates the structures which you must later delete */

void WINAPI DeleteMediaType(AM_MEDIA_TYPE *pmt);
AM_MEDIA_TYPE * WINAPI CreateMediaType(AM_MEDIA_TYPE const *pSrc);
void WINAPI CopyMediaType(AM_MEDIA_TYPE *pmtTarget, const AM_MEDIA_TYPE *pmtSource);
void WINAPI FreeMediaType(AM_MEDIA_TYPE& mt);

//  Initialize a media type from a WAVEFORMATEX

STDAPI CreateAudioMediaType(
    const WAVEFORMATEX *pwfx,
    AM_MEDIA_TYPE *pmt,
    BOOL bSetFormat);

#endif /* __MTYPE__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\reftime.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

//
// CRefTime
//
// Manage reference times.
// Shares same data layout as REFERENCE_TIME, but adds some (nonvirtual)
// functions providing simple comparison, conversion and arithmetic.
//
// A reference time (at the moment) is a unit of seconds represented in
// 100ns units as is used in the Win32 FILETIME structure. BUT the time
// a REFERENCE_TIME represents is NOT the time elapsed since 1/1/1601 it
// will either be stream time or reference time depending upon context
//
// This class provides simple arithmetic operations on reference times
//
// keep non-virtual otherwise the data layout will not be the same as
// REFERENCE_TIME


// -----
// note that you are safe to cast a CRefTime* to a REFERENCE_TIME*, but
// you will need to do so explicitly
// -----


#ifndef __REFTIME__
#define __REFTIME__


const LONGLONG MILLISECONDS = (1000);            // 10 ^ 3
const LONGLONG NANOSECONDS = (1000000000);       // 10 ^ 9
const LONGLONG UNITS = (NANOSECONDS / 100);      // 10 ^ 7

/*  Unfortunately an inline function here generates a call to __allmul
    - even for constants!
*/
#define MILLISECONDS_TO_100NS_UNITS(lMs) \
    Int32x32To64((lMs), (UNITS / MILLISECONDS))

class CRefTime
{
public:

    // *MUST* be the only data member so that this class is exactly
    // equivalent to a REFERENCE_TIME.
    // Also, must be *no virtual functions*

    REFERENCE_TIME m_time;

    inline CRefTime()
    {
        // default to 0 time
        m_time = 0;
    };

    inline CRefTime(LONG msecs)
    {
        m_time = MILLISECONDS_TO_100NS_UNITS(msecs);
    };

    inline CRefTime(REFERENCE_TIME rt)
    {
        m_time = rt;
    };

    inline operator REFERENCE_TIME() const
    {
        return m_time;
    };

    inline CRefTime& operator=(const CRefTime& rt)
    {
        m_time = rt.m_time;
        return *this;
    };

    inline CRefTime& operator=(const LONGLONG ll)
    {
        m_time = ll;
        return *this;
    };

    inline CRefTime& operator+=(const CRefTime& rt)
    {
        return (*this = *this + rt);
    };

    inline CRefTime& operator-=(const CRefTime& rt)
    {
        return (*this = *this - rt);
    };

    inline LONG Millisecs(void)
    {
        return (LONG)(m_time / (UNITS / MILLISECONDS));
    };

    inline LONGLONG GetUnits(void)
    {
        return m_time;
    };
};

const LONGLONG TimeZero = 0;

#endif /* __REFTIME__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\renbase.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>        // ActiveMovie base class definitions
#include <mmsystem.h>       // Needed for definition of timeGetTime
#include <limits.h>         // Standard data type limit definitions
#include <measure.h>        // Used for time critical log functions

#pragma warning(disable:4355)

//  Helper function for clamping time differences
int inline TimeDiff(REFERENCE_TIME rt)
{
    if (rt < - (50 * UNITS)) {
        return -(50 * UNITS);
    } else
    if (rt > 50 * UNITS) {
        return 50 * UNITS;
    } else return (int)rt;
}

// Implements the CBaseRenderer class

CBaseRenderer::CBaseRenderer(REFCLSID RenderClass, // CLSID for this renderer
			     TCHAR *pName,         // Debug ONLY description
			     LPUNKNOWN pUnk,       // Aggregated owner object
			     HRESULT *phr) :       // General OLE return code

    CBaseFilter(pName,pUnk,&m_InterfaceLock,RenderClass),
    m_evComplete(TRUE),
    m_bAbort(FALSE),
    m_pPosition(NULL),
    m_ThreadSignal(TRUE),
    m_bStreaming(FALSE),
    m_bEOS(FALSE),
    m_bEOSDelivered(FALSE),
    m_pMediaSample(NULL),
    m_dwAdvise(0),
    m_pQSink(NULL),
    m_pInputPin(NULL),
    m_bRepaintStatus(TRUE),
    m_SignalTime(0),
    m_bInReceive(FALSE),
    m_EndOfStreamTimer(0)
{
    Ready();
#ifdef PERF
    m_idBaseStamp = MSR_REGISTER("BaseRenderer: sample time stamp");
    m_idBaseRenderTime = MSR_REGISTER("BaseRenderer: draw time (msec)");
    m_idBaseAccuracy = MSR_REGISTER("BaseRenderer: Accuracy (msec)");
#endif
}


// Delete the dynamically allocated IMediaPosition and IMediaSeeking helper
// object. The object is created when somebody queries us. These are standard
// control interfaces for seeking and setting start/stop positions and rates.
// We will probably also have made an input pin based on CRendererInputPin
// that has to be deleted, it's created when an enumerator calls our GetPin

CBaseRenderer::~CBaseRenderer()
{
    ASSERT(m_bStreaming == FALSE);
    ASSERT(m_EndOfStreamTimer == 0);
    StopStreaming();
    ClearPendingSample();

    // Delete any IMediaPosition implementation

    if (m_pPosition) {
	delete m_pPosition;
	m_pPosition = NULL;
    }

    // Delete any input pin created

    if (m_pInputPin) {
	delete m_pInputPin;
	m_pInputPin = NULL;
    }

    // Release any Quality sink

    ASSERT(m_pQSink == NULL);
}


// This returns the IMediaPosition and IMediaSeeking interfaces

HRESULT CBaseRenderer::GetMediaPositionInterface(REFIID riid,void **ppv)
{
    CAutoLock cRendererLock(&m_InterfaceLock);
    if (m_pPosition) {
	return m_pPosition->NonDelegatingQueryInterface(riid,ppv);
    }

    HRESULT hr = NOERROR;

    // Create implementation of this dynamically since sometimes we may
    // never try and do a seek. The helper object implements a position
    // control interface (IMediaPosition) which in fact simply takes the
    // calls normally from the filter graph and passes them upstream

    m_pPosition = new CRendererPosPassThru(NAME("Renderer CPosPassThru"),
					   CBaseFilter::GetOwner(),
					   (HRESULT *) &hr,
					   GetPin(0));
    if (m_pPosition == NULL) {
	return E_OUTOFMEMORY;
    }

    if (FAILED(hr)) {
	delete m_pPosition;
	m_pPosition = NULL;
	return E_NOINTERFACE;
    }
    return GetMediaPositionInterface(riid,ppv);
}


// Overriden to say what interfaces we support and where

STDMETHODIMP CBaseRenderer::NonDelegatingQueryInterface(REFIID riid,void **ppv)
{
    // Do we have this interface

    if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking) {
	return GetMediaPositionInterface(riid,ppv);
    } else {
	return CBaseFilter::NonDelegatingQueryInterface(riid,ppv);
    }
}


// This is called whenever we change states, we have a manual reset event that
// is signalled whenever we don't won't the source filter thread to wait in us
// (such as in a stopped state) and likewise is not signalled whenever it can
// wait (during paused and running) this function sets or resets the thread
// event. The event is used to stop source filter threads waiting in Receive

HRESULT CBaseRenderer::SourceThreadCanWait(BOOL bCanWait)
{
    if (bCanWait == TRUE) {
	m_ThreadSignal.Reset();
    } else {
	m_ThreadSignal.Set();
    }
    return NOERROR;
}


#ifdef DEBUG
// Dump the current renderer state to the debug terminal. The hardest part of
// the renderer is the window where we unlock everything to wait for a clock
// to signal it is time to draw or for the application to cancel everything
// by stopping the filter. If we get things wrong we can leave the thread in
// WaitForRenderTime with no way for it to ever get out and we will deadlock

void CBaseRenderer::DisplayRendererState()
{
    DbgLog((LOG_TIMING, 1, TEXT("\nTimed out in WaitForRenderTime")));

    // No way should this be signalled at this point

    BOOL bSignalled = m_ThreadSignal.Check();
    DbgLog((LOG_TIMING, 1, TEXT("Signal sanity check %d"),bSignalled));

    // Now output the current renderer state variables

    DbgLog((LOG_TIMING, 1, TEXT("Filter state %d"),m_State));

    DbgLog((LOG_TIMING, 1, TEXT("Abort flag %d"),m_bAbort));

    DbgLog((LOG_TIMING, 1, TEXT("Streaming flag %d"),m_bStreaming));

    DbgLog((LOG_TIMING, 1, TEXT("Clock advise link %d"),m_dwAdvise));

    DbgLog((LOG_TIMING, 1, TEXT("Current media sample %x"),m_pMediaSample));

    DbgLog((LOG_TIMING, 1, TEXT("EOS signalled %d"),m_bEOS));

    DbgLog((LOG_TIMING, 1, TEXT("EOS delivered %d"),m_bEOSDelivered));

    DbgLog((LOG_TIMING, 1, TEXT("Repaint status %d"),m_bRepaintStatus));


    // Output the delayed end of stream timer information

    DbgLog((LOG_TIMING, 1, TEXT("End of stream timer %x"),m_EndOfStreamTimer));

    DbgLog((LOG_TIMING, 1, TEXT("Deliver time %s"),CDisp((LONGLONG)m_SignalTime)));


    // Should never timeout during a flushing state

    BOOL bFlushing = m_pInputPin->IsFlushing();
    DbgLog((LOG_TIMING, 1, TEXT("Flushing sanity check %d"),bFlushing));

    // Display the time we were told to start at
    DbgLog((LOG_TIMING, 1, TEXT("Last run time %s"),CDisp((LONGLONG)m_tStart.m_time)));

    // Have we got a reference clock
    if (m_pClock == NULL) return;

    // Get the current time from the wall clock

    CRefTime CurrentTime,StartTime,EndTime;
    m_pClock->GetTime((REFERENCE_TIME*) &CurrentTime);
    CRefTime Offset = CurrentTime - m_tStart;

    // Display the current time from the clock

    DbgLog((LOG_TIMING, 1, TEXT("Clock time %s"),CDisp((LONGLONG)CurrentTime.m_time)));

    DbgLog((LOG_TIMING, 1, TEXT("Time difference %dms"),Offset.Millisecs()));


    // Do we have a sample ready to render
    if (m_pMediaSample == NULL) return;

    m_pMediaSample->GetTime((REFERENCE_TIME*)&StartTime, (REFERENCE_TIME*)&EndTime);
    DbgLog((LOG_TIMING, 1, TEXT("Next sample stream times (Start %d End %d ms)"),
	   StartTime.Millisecs(),EndTime.Millisecs()));

    // Calculate how long it is until it is due for rendering
    CRefTime Wait = (m_tStart + StartTime) - CurrentTime;
    DbgLog((LOG_TIMING, 1, TEXT("Wait required %d ms"),Wait.Millisecs()));
}
#endif


// Wait until the clock sets the timer event or we're otherwise signalled. We
// set an arbitrary timeout for this wait and if it fires then we display the
// current renderer state on the debugger. It will often fire if the filter's
// left paused in an application however it may also fire during stress tests
// if the synchronisation with application seeks and state changes is faulty

#define RENDER_TIMEOUT 10000

HRESULT CBaseRenderer::WaitForRenderTime()
{
    HANDLE WaitObjects[] = { m_ThreadSignal, m_RenderEvent };
    DWORD Result = WAIT_TIMEOUT;

    // Wait for either the time to arrive or for us to be stopped

    OnWaitStart();
    while (Result == WAIT_TIMEOUT) {
	Result = WaitForMultipleObjects(2,WaitObjects,FALSE,RENDER_TIMEOUT);

#ifdef DEBUG
	if (Result == WAIT_TIMEOUT) DisplayRendererState();
#endif

    }
    OnWaitEnd();

    // We may have been awoken without the timer firing

    if (Result == WAIT_OBJECT_0) {
	return VFW_E_STATE_CHANGED;
    }

    SignalTimerFired();
    return NOERROR;
}


// Poll waiting for Receive to complete.  This really matters when
// Receive may set the palette and cause window messages
// The problem is that if we don't really wait for a renderer to
// stop processing we can deadlock waiting for a transform which
// is calling the renderer's Receive() method because the transform's
// Stop method doesn't know to process window messages to unblock
// the renderer's Receive processing
void CBaseRenderer::WaitForReceiveToComplete()
{
    for (;;) {
	if (!m_bInReceive) {
	    break;
	}

	MSG msg;
	//  Receive all interthread snedmessages
	PeekMessage(&msg, NULL, WM_NULL, WM_NULL, PM_NOREMOVE);

	Sleep(1);
    }

    // If the wakebit for QS_POSTMESSAGE is set, the PeekMessage call
    // above just cleared the changebit which will cause some messaging
    // calls to block (waitMessage, MsgWaitFor...) now.
    // Post a dummy message to set the QS_POSTMESSAGE bit again
    if (HIWORD(GetQueueStatus(QS_POSTMESSAGE)) & QS_POSTMESSAGE) {
	//  Send dummy message
	PostThreadMessage(GetCurrentThreadId(), WM_NULL, 0, 0);
    }
}

// A filter can have four discrete states, namely Stopped, Running, Paused,
// Intermediate. We are in an intermediate state if we are currently trying
// to pause but haven't yet got the first sample (or if we have been flushed
// in paused state and therefore still have to wait for a sample to arrive)

// This class contains an event called m_evComplete which is signalled when
// the current state is completed and is not signalled when we are waiting to
// complete the last state transition. As mentioned above the only time we
// use this at the moment is when we wait for a media sample in paused state
// If while we are waiting we receive an end of stream notification from the
// source filter then we know no data is imminent so we can reset the event
// This means that when we transition to paused the source filter must call
// end of stream on us or send us an image otherwise we'll hang indefinately


// Simple internal way of getting the real state

FILTER_STATE CBaseRenderer::GetRealState() {
    return m_State;
}


// The renderer doesn't complete the full transition to paused states until
// it has got one media sample to render. If you ask it for its state while
// it's waiting it will return the state along with VFW_S_STATE_INTERMEDIATE

STDMETHODIMP CBaseRenderer::GetState(DWORD dwMSecs,FILTER_STATE *State)
{
    CheckPointer(State,E_POINTER);

    if (WaitDispatchingMessages(m_evComplete, dwMSecs) == WAIT_TIMEOUT) {
	*State = m_State;
	return VFW_S_STATE_INTERMEDIATE;
    }
    *State = m_State;
    return NOERROR;
}


// If we're pausing and we have no samples we don't complete the transition
// to State_Paused and we return S_FALSE. However if the m_bAbort flag has
// been set then all samples are rejected so there is no point waiting for
// one. If we do have a sample then return NOERROR. We will only ever return
// VFW_S_STATE_INTERMEDIATE from GetState after being paused with no sample
// (calling GetState after either being stopped or Run will NOT return this)

HRESULT CBaseRenderer::CompleteStateChange(FILTER_STATE OldState)
{
    // Allow us to be paused when disconnected

    if (m_pInputPin->IsConnected() == FALSE) {
	Ready();
	return S_OK;
    }

    // Have we run off the end of stream

    if (IsEndOfStream() == TRUE) {
	Ready();
	return S_OK;
    }

    // Make sure we get fresh data after being stopped

    if (HaveCurrentSample() == TRUE) {
	if (OldState != State_Stopped) {
	    Ready();
	    return S_OK;
	}
    }
    NotReady();
    return S_FALSE;
}


// When we stop the filter the things we do are:-

//      Decommit the allocator being used in the connection
//      Release the source filter if it's waiting in Receive
//      Cancel any advise link we set up with the clock
//      Any end of stream signalled is now obsolete so reset
//      Allow us to be stopped when we are not connected

STDMETHODIMP CBaseRenderer::Stop()
{
    CAutoLock cRendererLock(&m_InterfaceLock);

    // Make sure there really is a state change

    if (m_State == State_Stopped) {
	return NOERROR;
    }

    // Is our input pin connected

    if (m_pInputPin->IsConnected() == FALSE) {
	NOTE("Input pin is not connected");
	m_State = State_Stopped;
	return NOERROR;
    }

    CBaseFilter::Stop();

    // If we are going into a stopped state then we must decommit whatever
    // allocator we are using it so that any source filter waiting in the
    // GetBuffer can be released and unlock themselves for a state change

    if (m_pInputPin->Allocator()) {
	m_pInputPin->Allocator()->Decommit();
    }

    // Cancel any scheduled rendering

    SetRepaintStatus(TRUE);
    StopStreaming();
    SourceThreadCanWait(FALSE);
    ResetEndOfStream();
    CancelNotification();

    // There should be no outstanding clock advise
    ASSERT(CancelNotification() == S_FALSE);
    ASSERT(WAIT_TIMEOUT == WaitForSingleObject((HANDLE)m_RenderEvent,0));
    ASSERT(m_EndOfStreamTimer == 0);

    Ready();
    WaitForReceiveToComplete();
    m_bAbort = FALSE;
    return NOERROR;
}


// When we pause the filter the things we do are:-

//      Commit the allocator being used in the connection
//      Allow a source filter thread to wait in Receive
//      Cancel any clock advise link (we may be running)
//      Possibly complete the state change if we have data
//      Allow us to be paused when we are not connected

STDMETHODIMP CBaseRenderer::Pause()
{
    CAutoLock cRendererLock(&m_InterfaceLock);
    FILTER_STATE OldState = m_State;
    ASSERT(m_pInputPin->IsFlushing() == FALSE);

    // Make sure there really is a state change

    if (m_State == State_Paused) {
	return CompleteStateChange(State_Paused);
    }

    // Has our input pin been connected

    if (m_pInputPin->IsConnected() == FALSE) {
	NOTE("Input pin is not connected");
	m_State = State_Paused;
	return CompleteStateChange(State_Paused);
    }

    // Pause the base filter class

    HRESULT hr = CBaseFilter::Pause();
    if (FAILED(hr)) {
	NOTE("Pause failed");
	return hr;
    }

    // Enable EC_REPAINT events again

    SetRepaintStatus(TRUE);
    StopStreaming();
    SourceThreadCanWait(TRUE);
    CancelNotification();
    ResetEndOfStreamTimer();

    // If we are going into a paused state then we must commit whatever
    // allocator we are using it so that any source filter can call the
    // GetBuffer and expect to get a buffer without returning an error

    if (m_pInputPin->Allocator()) {
	m_pInputPin->Allocator()->Commit();
    }

    // There should be no outstanding advise
    ASSERT(CancelNotification() == S_FALSE);
    ASSERT(WAIT_TIMEOUT == WaitForSingleObject((HANDLE)m_RenderEvent,0));
    ASSERT(m_EndOfStreamTimer == 0);
    ASSERT(m_pInputPin->IsFlushing() == FALSE);

    // When we come out of a stopped state we must clear any image we were
    // holding onto for frame refreshing. Since renderers see state changes
    // first we can reset ourselves ready to accept the source thread data
    // Paused or running after being stopped causes the current position to
    // be reset so we're not interested in passing end of stream signals

    if (OldState == State_Stopped) {
	m_bAbort = FALSE;
	ClearPendingSample();
    }
    return CompleteStateChange(OldState);
}


// When we run the filter the things we do are:-

//      Commit the allocator being used in the connection
//      Allow a source filter thread to wait in Receive
//      Signal the render event just to get us going
//      Start the base class by calling StartStreaming
//      Allow us to be run when we are not connected
//      Signal EC_COMPLETE if we are not connected

STDMETHODIMP CBaseRenderer::Run(REFERENCE_TIME StartTime)
{
    CAutoLock cRendererLock(&m_InterfaceLock);
    FILTER_STATE OldState = m_State;

    // Make sure there really is a state change

    if (m_State == State_Running) {
	return NOERROR;
    }

    // Send EC_COMPLETE if we're not connected

    if (m_pInputPin->IsConnected() == FALSE) {
	NotifyEvent(EC_COMPLETE,S_OK,(LONG_PTR)(IBaseFilter *)this);
	m_State = State_Running;
	return NOERROR;
    }

    Ready();

    // Pause the base filter class

    HRESULT hr = CBaseFilter::Run(StartTime);
    if (FAILED(hr)) {
	NOTE("Run failed");
	return hr;
    }

    // Allow the source thread to wait
    ASSERT(m_pInputPin->IsFlushing() == FALSE);
    SourceThreadCanWait(TRUE);
    SetRepaintStatus(FALSE);

    // There should be no outstanding advise
    ASSERT(CancelNotification() == S_FALSE);
    ASSERT(WAIT_TIMEOUT == WaitForSingleObject((HANDLE)m_RenderEvent,0));
    ASSERT(m_EndOfStreamTimer == 0);
    ASSERT(m_pInputPin->IsFlushing() == FALSE);

    // If we are going into a running state then we must commit whatever
    // allocator we are using it so that any source filter can call the
    // GetBuffer and expect to get a buffer without returning an error

    if (m_pInputPin->Allocator()) {
	m_pInputPin->Allocator()->Commit();
    }

    // When we come out of a stopped state we must clear any image we were
    // holding onto for frame refreshing. Since renderers see state changes
    // first we can reset ourselves ready to accept the source thread data
    // Paused or running after being stopped causes the current position to
    // be reset so we're not interested in passing end of stream signals

    if (OldState == State_Stopped) {
	m_bAbort = FALSE;
	ClearPendingSample();
    }
    return StartStreaming();
}


// Return the number of input pins we support

int CBaseRenderer::GetPinCount()
{
    return 1;
}


// We only support one input pin and it is numbered zero

CBasePin *CBaseRenderer::GetPin(int n)
{
    CAutoLock cRendererLock(&m_InterfaceLock);
    HRESULT hr = NOERROR;
    ASSERT(n == 0);

    // Should only ever be called with zero

    if (n != 0) {
	return NULL;
    }

    // Create the input pin if not already done so

    if (m_pInputPin == NULL) {
	m_pInputPin = new CRendererInputPin(this,&hr,L"In");
    }
    return m_pInputPin;
}


// If "In" then return the IPin for our input pin, otherwise NULL and error

STDMETHODIMP CBaseRenderer::FindPin(LPCWSTR Id, IPin **ppPin)
{
    CheckPointer(ppPin,E_POINTER);

    if (0==lstrcmpW(Id,L"In")) {
	*ppPin = GetPin(0);
	ASSERT(*ppPin);
	(*ppPin)->AddRef();
    } else {
	*ppPin = NULL;
	return VFW_E_NOT_FOUND;
    }
    return NOERROR;
}


// Called when the input pin receives an EndOfStream notification. If we have
// not got a sample, then notify EC_COMPLETE now. If we have samples, then set
// m_bEOS and check for this on completing samples. If we're waiting to pause
// then complete the transition to paused state by setting the state event

HRESULT CBaseRenderer::EndOfStream()
{
    // Ignore these calls if we are stopped

    if (m_State == State_Stopped) {
	return NOERROR;
    }

    // If we have a sample then wait for it to be rendered

    m_bEOS = TRUE;
    if (m_pMediaSample) {
	return NOERROR;
    }

    // If we are waiting for pause then we are now ready since we cannot now
    // carry on waiting for a sample to arrive since we are being told there
    // won't be any. This sets an event that the GetState function picks up

    Ready();

    // Only signal completion now if we are running otherwise queue it until
    // we do run in StartStreaming. This is used when we seek because a seek
    // causes a pause where early notification of completion is misleading

    if (m_bStreaming) {
	SendEndOfStream();
    }
    return NOERROR;
}


// When we are told to flush we should release the source thread

HRESULT CBaseRenderer::BeginFlush()
{
    // If paused then report state intermediate until we get some data

    if (m_State == State_Paused) {
	NotReady();
    }

    SourceThreadCanWait(FALSE);
    CancelNotification();
    ClearPendingSample();
    //  Wait for Receive to complete
    WaitForReceiveToComplete();
    return NOERROR;
}


// After flushing the source thread can wait in Receive again

HRESULT CBaseRenderer::EndFlush()
{
    // Reset the current sample media time
    if (m_pPosition) m_pPosition->ResetMediaTime();

    // There should be no outstanding advise

    ASSERT(CancelNotification() == S_FALSE);
    SourceThreadCanWait(TRUE);
    return NOERROR;
}


// We can now send EC_REPAINTs if so required

HRESULT CBaseRenderer::CompleteConnect(IPin *pReceivePin)
{
    SetRepaintStatus(TRUE);
    m_bAbort = FALSE;
    return NOERROR;
}


// Called when we go paused or running

HRESULT CBaseRenderer::Active()
{
    return NOERROR;
}


// Called when we go into a stopped state

HRESULT CBaseRenderer::Inactive()
{
    if (m_pPosition) {
	m_pPosition->ResetMediaTime();
    }
    //  People who derive from this may want to override this behaviour
    //  to keep hold of the sample in some circumstances
    ClearPendingSample();
    return NOERROR;
}


// Tell derived classes about the media type agreed

HRESULT CBaseRenderer::SetMediaType(const CMediaType *pmt)
{
    return NOERROR;
}


// When we break the input pin connection we should reset the EOS flags. When
// we are asked for either IMediaPosition or IMediaSeeking we will create a
// CPosPassThru object to handles media time pass through. When we're handed
// samples we store (by calling CPosPassThru::RegisterMediaTime) their media
// times so we can then return a real current position of data being rendered

HRESULT CBaseRenderer::BreakConnect()
{
    // Do we have a quality management sink

    if (m_pQSink) {
	m_pQSink->Release();
	m_pQSink = NULL;
    }

    // Check we have a valid connection

    if (m_pInputPin->IsConnected() == FALSE) {
	return S_FALSE;
    }

    // Check we are stopped before disconnecting

    if (m_State != State_Stopped) {
	return VFW_E_NOT_STOPPED;
    }

    SetRepaintStatus(FALSE);
    ResetEndOfStream();
    ClearPendingSample();
    m_bAbort = FALSE;
    return NOERROR;
}


// Retrieves the sample times for this samples (note the sample times are
// passed in by reference not value). We return S_FALSE to say schedule this
// sample according to the times on the sample. We also return S_OK in
// which case the object should simply render the sample data immediately

HRESULT CBaseRenderer::GetSampleTimes(IMediaSample *pMediaSample,
				      REFERENCE_TIME *pStartTime,
				      REFERENCE_TIME *pEndTime)
{
    ASSERT(m_dwAdvise == 0);
    ASSERT(pMediaSample);

    // If the stop time for this sample is before or the same as start time,
    // then just ignore it (release it) and schedule the next one in line
    // Source filters should always fill in the start and end times properly!

    if (SUCCEEDED(pMediaSample->GetTime(pStartTime, pEndTime))) {
	if (*pEndTime < *pStartTime) {
	    return VFW_E_START_TIME_AFTER_END;
	}
    } else {
	// no time set in the sample... draw it now?
	return S_OK;
    }

    // Can't synchronise without a clock so we return S_OK which tells the
    // caller that the sample should be rendered immediately without going
    // through the overhead of setting a timer advise link with the clock

    if (m_pClock == NULL) {
	return S_OK;
    }
    return ShouldDrawSampleNow(pMediaSample,pStartTime,pEndTime);
}


// By default all samples are drawn according to their time stamps so we
// return S_FALSE. Returning S_OK means draw immediately, this is used
// by the derived video renderer class in its quality management.

HRESULT CBaseRenderer::ShouldDrawSampleNow(IMediaSample *pMediaSample,
					   REFERENCE_TIME *ptrStart,
					   REFERENCE_TIME *ptrEnd)
{
    return S_FALSE;
}


// We must always reset the current advise time to zero after a timer fires
// because there are several possible ways which lead us not to do any more
// scheduling such as the pending image being cleared after state changes

void CBaseRenderer::SignalTimerFired()
{
    m_dwAdvise = 0;
}


// Cancel any notification currently scheduled. This is called by the owning
// window object when it is told to stop streaming. If there is no timer link
// outstanding then calling this is benign otherwise we go ahead and cancel
// We must always reset the render event as the quality management code can
// signal immediate rendering by setting the event without setting an advise
// link. If we're subsequently stopped and run the first attempt to setup an
// advise link with the reference clock will find the event still signalled

HRESULT CBaseRenderer::CancelNotification()
{
    ASSERT(m_dwAdvise == 0 || m_pClock);
    DWORD_PTR dwAdvise = m_dwAdvise;

    // Have we a live advise link

    if (m_dwAdvise) {
	m_pClock->Unadvise(m_dwAdvise);
	SignalTimerFired();
	ASSERT(m_dwAdvise == 0);
    }

    // Clear the event and return our status

    m_RenderEvent.Reset();
    return (dwAdvise ? S_OK : S_FALSE);
}


// Responsible for setting up one shot advise links with the clock
// Return FALSE if the sample is to be dropped (not drawn at all)
// Return TRUE if the sample is to be drawn and in this case also
// arrange for m_RenderEvent to be set at the appropriate time

BOOL CBaseRenderer::ScheduleSample(IMediaSample *pMediaSample)
{
    REFERENCE_TIME StartSample, EndSample;

    // Is someone pulling our leg

    if (pMediaSample == NULL) {
	return FALSE;
    }

    // Get the next sample due up for rendering.  If there aren't any ready
    // then GetNextSampleTimes returns an error.  If there is one to be done
    // then it succeeds and yields the sample times. If it is due now then
    // it returns S_OK other if it's to be done when due it returns S_FALSE

    HRESULT hr = GetSampleTimes(pMediaSample, &StartSample, &EndSample);
    if (FAILED(hr)) {
	return FALSE;
    }

    // If we don't have a reference clock then we cannot set up the advise
    // time so we simply set the event indicating an image to render. This
    // will cause us to run flat out without any timing or synchronisation

    if (hr == S_OK) {
	EXECUTE_ASSERT(SetEvent((HANDLE) m_RenderEvent));
	return TRUE;
    }

    ASSERT(m_dwAdvise == 0);
    ASSERT(m_pClock);
    ASSERT(WAIT_TIMEOUT == WaitForSingleObject((HANDLE)m_RenderEvent,0));

    // We do have a valid reference clock interface so we can ask it to
    // set an event when the image comes due for rendering. We pass in
    // the reference time we were told to start at and also the current
    // stream time which is the offset from the start reference time

    hr = m_pClock->AdviseTime(
	    (REFERENCE_TIME) m_tStart,          // Start run time
	    StartSample,                        // Stream time
	    (HEVENT)(HANDLE) m_RenderEvent,     // Render notification
	    &m_dwAdvise);                       // Advise cookie

    if (SUCCEEDED(hr)) {
	return TRUE;
    }

    // We could not schedule the next sample for rendering despite the fact
    // we have a valid sample here. This is a fair indication that either
    // the system clock is wrong or the time stamp for the sample is duff

    ASSERT(m_dwAdvise == 0);
    return FALSE;
}


// This is called when a sample comes due for rendering. We pass the sample
// on to the derived class. After rendering we will initialise the timer for
// the next sample, NOTE signal that the last one fired first, if we don't
// do this it thinks there is still one outstanding that hasn't completed

HRESULT CBaseRenderer::Render(IMediaSample *pMediaSample)
{
    // If the media sample is NULL then we will have been notified by the
    // clock that another sample is ready but in the mean time someone has
    // stopped us streaming which causes the next sample to be released

    if (pMediaSample == NULL) {
	return S_FALSE;
    }

    // If we have stopped streaming then don't render any more samples, the
    // thread that got in and locked us and then reset this flag does not
    // clear the pending sample as we can use it to refresh any output device

    if (m_bStreaming == FALSE) {
	return S_FALSE;
    }

    // Time how long the rendering takes

    OnRenderStart(pMediaSample);
    DoRenderSample(pMediaSample);
    OnRenderEnd(pMediaSample);

    return NOERROR;
}


// Checks if there is a sample waiting at the renderer

BOOL CBaseRenderer::HaveCurrentSample()
{
    CAutoLock cRendererLock(&m_RendererLock);
    return (m_pMediaSample == NULL ? FALSE : TRUE);
}


// Returns the current sample waiting at the video renderer. We AddRef the
// sample before returning so that should it come due for rendering the
// person who called this method will hold the remaining reference count
// that will stop the sample being added back onto the allocator free list

IMediaSample *CBaseRenderer::GetCurrentSample()
{
    CAutoLock cRendererLock(&m_RendererLock);
    if (m_pMediaSample) {
	m_pMediaSample->AddRef();
    }
    return m_pMediaSample;
}


// Called when the source delivers us a sample. We go through a few checks to
// make sure the sample can be rendered. If we are running (streaming) then we
// have the sample scheduled with the reference clock, if we are not streaming
// then we have received an sample in paused mode so we can complete any state
// transition. On leaving this function everything will be unlocked so an app
// thread may get in and change our state to stopped (for example) in which
// case it will also signal the thread event so that our wait call is stopped

HRESULT CBaseRenderer::PrepareReceive(IMediaSample *pMediaSample)
{
    CAutoLock cRendererLock(&m_InterfaceLock);
    m_bInReceive = TRUE;

    // Check our flushing and filter state

    HRESULT hr = m_pInputPin->CBaseInputPin::Receive(pMediaSample);

    if (hr != NOERROR) {
	m_bInReceive = FALSE;
	return E_FAIL;
    }

    // Has the type changed on a media sample. We do all rendering
    // synchronously on the source thread, which has a side effect
    // that only one buffer is ever outstanding. Therefore when we
    // have Receive called we can go ahead and change the format
    // Since the format change can cause a SendMessage we just don't
    // lock
    if (m_pInputPin->SampleProps()->pMediaType) {
	m_pInputPin->SetMediaType(
	    (CMediaType *)m_pInputPin->SampleProps()->pMediaType);
    }


    CAutoLock cSampleLock(&m_RendererLock);

    ASSERT(IsActive() == TRUE);
    ASSERT(m_pInputPin->IsFlushing() == FALSE);
    ASSERT(m_pInputPin->IsConnected() == TRUE);
    ASSERT(m_pMediaSample == NULL);

    // Return an error if we already have a sample waiting for rendering
    // source pins must serialise the Receive calls - we also check that
    // no data is being sent after the source signalled an end of stream

    if (m_pMediaSample || m_bEOS || m_bAbort) {
	Ready();
	m_bInReceive = FALSE;
	return E_UNEXPECTED;
    }

    // Store the media times from this sample
    if (m_pPosition) m_pPosition->RegisterMediaTime(pMediaSample);

    // Schedule the next sample if we are streaming

    if ((m_bStreaming == TRUE) && (ScheduleSample(pMediaSample) == FALSE)) {
	ASSERT(WAIT_TIMEOUT == WaitForSingleObject((HANDLE)m_RenderEvent,0));
	ASSERT(CancelNotification() == S_FALSE);
	m_bInReceive = FALSE;
	return VFW_E_SAMPLE_REJECTED;
    }

    // Store the sample end time for EC_COMPLETE handling
    m_SignalTime = m_pInputPin->SampleProps()->tStop;

    // BEWARE we sometimes keep the sample even after returning the thread to
    // the source filter such as when we go into a stopped state (we keep it
    // to refresh the device with) so we must AddRef it to keep it safely. If
    // we start flushing the source thread is released and any sample waiting
    // will be released otherwise GetBuffer may never return (see BeginFlush)

    m_pMediaSample = pMediaSample;
    m_pMediaSample->AddRef();

    if (m_bStreaming == FALSE) {
	SetRepaintStatus(TRUE);
    }
    return NOERROR;
}


// Called by the source filter when we have a sample to render. Under normal
// circumstances we set an advise link with the clock, wait for the time to
// arrive and then render the data using the PURE virtual DoRenderSample that
// the derived class will have overriden. After rendering the sample we may
// also signal EOS if it was the last one sent before EndOfStream was called

HRESULT CBaseRenderer::Receive(IMediaSample *pSample)
{
    ASSERT(pSample);

    // It may return VFW_E_SAMPLE_REJECTED code to say don't bother

    HRESULT hr = PrepareReceive(pSample);
    ASSERT(m_bInReceive == SUCCEEDED(hr));
    if (FAILED(hr)) {
	if (hr == VFW_E_SAMPLE_REJECTED) {
	    return NOERROR;
	}
	return hr;
    }

    // We realize the palette in "PrepareRender()" so we have to give away the
    // filter lock here.
    if (m_State == State_Paused) {
	PrepareRender();
	// no need to use InterlockedExchange
	m_bInReceive = FALSE;
	{
	    // We must hold both these locks
	    CAutoLock cRendererLock(&m_InterfaceLock);
	    if (m_State == State_Stopped)
		return NOERROR;
	    m_bInReceive = TRUE;
	    CAutoLock cSampleLock(&m_RendererLock);
	    OnReceiveFirstSample(pSample);
	}
	Ready();
    }
    // Having set an advise link with the clock we sit and wait. We may be
    // awoken by the clock firing or by a state change. The rendering call
    // will lock the critical section and check we can still render the data

    hr = WaitForRenderTime();
    if (FAILED(hr)) {
	m_bInReceive = FALSE;
	return NOERROR;
    }

    PrepareRender();

    //  Set this here and poll it until we work out the locking correctly
    //  It can't be right that the streaming stuff grabs the interface
    //  lock - after all we want to be able to wait for this stuff
    //  to complete
    m_bInReceive = FALSE;

    // We must hold both these locks
    CAutoLock cRendererLock(&m_InterfaceLock);

    // since we gave away the filter wide lock, the sate of the filter could
    // have chnaged to Stopped
    if (m_State == State_Stopped)
	return NOERROR;

    CAutoLock cSampleLock(&m_RendererLock);

    // Deal with this sample

    Render(m_pMediaSample);
    ClearPendingSample();
    SendEndOfStream();
    CancelNotification();
    return NOERROR;
}


// This is called when we stop or are inactivated to clear the pending sample
// We release the media sample interface so that they can be allocated to the
// source filter again, unless of course we are changing state to inactive in
// which case GetBuffer will return an error. We must also reset the current
// media sample to NULL so that we know we do not currently have an image

HRESULT CBaseRenderer::ClearPendingSample()
{
    CAutoLock cRendererLock(&m_RendererLock);
    if (m_pMediaSample) {
	m_pMediaSample->Release();
	m_pMediaSample = NULL;
    }
    return NOERROR;
}


// Used to signal end of stream according to the sample end time

void CALLBACK EndOfStreamTimer(UINT uID,        // Timer identifier
			       UINT uMsg,       // Not currently used
			       DWORD_PTR dwUser,// User information
			       DWORD_PTR dw1,   // Windows reserved
			       DWORD_PTR dw2)   // is also reserved
{
    CBaseRenderer *pRenderer = (CBaseRenderer *) dwUser;
    NOTE1("EndOfStreamTimer called (%d)",uID);
    pRenderer->TimerCallback();
}

//  Do the timer callback work
void CBaseRenderer::TimerCallback()
{
    //  Lock for synchronization (but don't hold this lock when calling
    //  timeKillEvent)
    CAutoLock cRendererLock(&m_RendererLock);

    // See if we should signal end of stream now

    if (m_EndOfStreamTimer) {
	m_EndOfStreamTimer = 0;
	SendEndOfStream();
    }
}


// If we are at the end of the stream signal the filter graph but do not set
// the state flag back to FALSE. Once we drop off the end of the stream we
// leave the flag set (until a subsequent ResetEndOfStream). Each sample we
// get delivered will update m_SignalTime to be the last sample's end time.
// We must wait this long before signalling end of stream to the filtergraph

#define TIMEOUT_DELIVERYWAIT 50
#define TIMEOUT_RESOLUTION 10

HRESULT CBaseRenderer::SendEndOfStream()
{
    ASSERT(CritCheckIn(&m_RendererLock));
    if (m_bEOS == FALSE || m_bEOSDelivered || m_EndOfStreamTimer) {
	return NOERROR;
    }

    // If there is no clock then signal immediately
    if (m_pClock == NULL) {
	return NotifyEndOfStream();
    }

    // How long into the future is the delivery time

    REFERENCE_TIME Signal = m_tStart + m_SignalTime;
    REFERENCE_TIME CurrentTime;
    m_pClock->GetTime(&CurrentTime);
    LONG Delay = LONG((Signal - CurrentTime) / 10000);

    // Dump the timing information to the debugger

    NOTE1("Delay until end of stream delivery %d",Delay);
    NOTE1("Current %s",(LPCTSTR)CDisp((LONGLONG)CurrentTime));
    NOTE1("Signal %s",(LPCTSTR)CDisp((LONGLONG)Signal));

    // Wait for the delivery time to arrive

    if (Delay < TIMEOUT_DELIVERYWAIT) {
	return NotifyEndOfStream();
    }

    // Signal a timer callback on another worker thread

    m_EndOfStreamTimer = timeSetEvent((UINT) Delay,       // Period of timer
				      TIMEOUT_RESOLUTION, // Timer resolution
				      EndOfStreamTimer,   // Callback function
				      DWORD_PTR(this),    // Used information
				      TIME_ONESHOT);      // Type of callback
    if (m_EndOfStreamTimer == 0) {
	return NotifyEndOfStream();
    }
    return NOERROR;
}


// Signals EC_COMPLETE to the filtergraph manager

HRESULT CBaseRenderer::NotifyEndOfStream()
{
    CAutoLock cRendererLock(&m_RendererLock);
    ASSERT(m_bEOS == TRUE);
    ASSERT(m_bEOSDelivered == FALSE);
    ASSERT(m_EndOfStreamTimer == 0);

    // Has the filter changed state

    if (m_bStreaming == FALSE) {
	ASSERT(m_EndOfStreamTimer == 0);
	return NOERROR;
    }

    // Reset the end of stream timer
    m_EndOfStreamTimer = 0;

    // If we've been using the IMediaPosition interface, set it's start
    // and end media "times" to the stop position by hand.  This ensures
    // that we actually get to the end, even if the MPEG guestimate has
    // been bad or if the quality management dropped the last few frames

    if (m_pPosition) m_pPosition->EOS();
    m_bEOSDelivered = TRUE;
    NOTE("Sending EC_COMPLETE...");
    return NotifyEvent(EC_COMPLETE,S_OK,(LONG_PTR)(IBaseFilter *)this);
}


// Reset the end of stream flag, this is typically called when we transfer to
// stopped states since that resets the current position back to the start so
// we will receive more samples or another EndOfStream if there aren't any. We
// keep two separate flags one to say we have run off the end of the stream
// (this is the m_bEOS flag) and another to say we have delivered EC_COMPLETE
// to the filter graph. We need the latter otherwise we can end up sending an
// EC_COMPLETE every time the source changes state and calls our EndOfStream

HRESULT CBaseRenderer::ResetEndOfStream()
{
    ResetEndOfStreamTimer();
    CAutoLock cRendererLock(&m_RendererLock);

    m_bEOS = FALSE;
    m_bEOSDelivered = FALSE;
    m_SignalTime = 0;

    return NOERROR;
}


// Kills any outstanding end of stream timer

void CBaseRenderer::ResetEndOfStreamTimer()
{
    ASSERT(CritCheckOut(&m_RendererLock));
    if (m_EndOfStreamTimer) {
	timeKillEvent(m_EndOfStreamTimer);
	m_EndOfStreamTimer = 0;
    }
}


// This is called when we start running so that we can schedule any pending
// image we have with the clock and display any timing information. If we
// don't have any sample but we have queued an EOS flag then we send it. If
// we do have a sample then we wait until that has been rendered before we
// signal the filter graph otherwise we may change state before it's done

HRESULT CBaseRenderer::StartStreaming()
{
    CAutoLock cRendererLock(&m_RendererLock);
    if (m_bStreaming == TRUE) {
	return NOERROR;
    }

    // Reset the streaming times ready for running

    m_bStreaming = TRUE;
    timeBeginPeriod(1);
    OnStartStreaming();

    // There should be no outstanding advise
    ASSERT(WAIT_TIMEOUT == WaitForSingleObject((HANDLE)m_RenderEvent,0));
    ASSERT(CancelNotification() == S_FALSE);

    // If we have an EOS and no data then deliver it now

    if (m_pMediaSample == NULL) {
	return SendEndOfStream();
    }

    // Have the data rendered

    ASSERT(m_pMediaSample);
    if (!ScheduleSample(m_pMediaSample))
	m_RenderEvent.Set();
    
    return NOERROR;
}


// This is called when we stop streaming so that we can set our internal flag
// indicating we are not now to schedule any more samples arriving. The state
// change methods in the filter implementation take care of cancelling any
// clock advise link we have set up and clearing any pending sample we have

HRESULT CBaseRenderer::StopStreaming()
{
    CAutoLock cRendererLock(&m_RendererLock);
    m_bEOSDelivered = FALSE;

    if (m_bStreaming == TRUE) {
	m_bStreaming = FALSE;
	OnStopStreaming();
	timeEndPeriod(1);
    }
    return NOERROR;
}


// We have a boolean flag that is reset when we have signalled EC_REPAINT to
// the filter graph. We set this when we receive an image so that should any
// conditions arise again we can send another one. By having a flag we ensure
// we don't flood the filter graph with redundant calls. We do not set the
// event when we receive an EndOfStream call since there is no point in us
// sending further EC_REPAINTs. In particular the AutoShowWindow method and
// the DirectDraw object use this method to control the window repainting

void CBaseRenderer::SetRepaintStatus(BOOL bRepaint)
{
    CAutoLock cSampleLock(&m_RendererLock);
    m_bRepaintStatus = bRepaint;
}


// Pass the window handle to the upstream filter

void CBaseRenderer::SendNotifyWindow(IPin *pPin,HWND hwnd)
{
    IMediaEventSink *pSink;

    // Does the pin support IMediaEventSink
    HRESULT hr = pPin->QueryInterface(IID_IMediaEventSink,(void **)&pSink);
    if (SUCCEEDED(hr)) {
	pSink->Notify(EC_NOTIFY_WINDOW,LONG_PTR(hwnd),0);
	pSink->Release();
    }
    NotifyEvent(EC_NOTIFY_WINDOW,LONG_PTR(hwnd),0);
}


// Signal an EC_REPAINT to the filter graph. This can be used to have data
// sent to us. For example when a video window is first displayed it may
// not have an image to display, at which point it signals EC_REPAINT. The
// filtergraph will either pause the graph if stopped or if already paused
// it will call put_CurrentPosition of the current position. Setting the
// current position to itself has the stream flushed and the image resent

#define RLOG(_x_) DbgLog((LOG_TRACE,1,TEXT(_x_)));

void CBaseRenderer::SendRepaint()
{
    CAutoLock cSampleLock(&m_RendererLock);
    ASSERT(m_pInputPin);

    // We should not send repaint notifications when...
    //    - An end of stream has been notified
    //    - Our input pin is being flushed
    //    - The input pin is not connected
    //    - We have aborted a video playback
    //    - There is a repaint already sent

    if (m_bAbort == FALSE) {
	if (m_pInputPin->IsConnected() == TRUE) {
	    if (m_pInputPin->IsFlushing() == FALSE) {
		if (IsEndOfStream() == FALSE) {
		    if (m_bRepaintStatus == TRUE) {
			IPin *pPin = (IPin *) m_pInputPin;
			NotifyEvent(EC_REPAINT,(LONG_PTR) pPin,0);
			SetRepaintStatus(FALSE);
			RLOG("Sending repaint");
		    }
		}
	    }
	}
    }
}


// When a video window detects a display change (WM_DISPLAYCHANGE message) it
// can send an EC_DISPLAY_CHANGED event code along with the renderer pin. The
// filtergraph will stop everyone and reconnect our input pin. As we're then
// reconnected we can accept the media type that matches the new display mode
// since we may no longer be able to draw the current image type efficiently

BOOL CBaseRenderer::OnDisplayChange()
{
    // Ignore if we are not connected yet

    CAutoLock cSampleLock(&m_RendererLock);
    if (m_pInputPin->IsConnected() == FALSE) {
	return FALSE;
    }

    RLOG("Notification of EC_DISPLAY_CHANGE");

    // Pass our input pin as parameter on the event

    IPin *pPin = (IPin *) m_pInputPin;
    m_pInputPin->AddRef();
    NotifyEvent(EC_DISPLAY_CHANGED,(LONG_PTR) pPin,0);
    SetAbortSignal(TRUE);
    ClearPendingSample();
    m_pInputPin->Release();

    return TRUE;
}


// Called just before we start drawing.
// Store the current time in m_trRenderStart to allow the rendering time to be
// logged.  Log the time stamp of the sample and how late it is (neg is early)

void CBaseRenderer::OnRenderStart(IMediaSample *pMediaSample)
{
#ifdef PERF
    REFERENCE_TIME trStart, trEnd;
    pMediaSample->GetTime(&trStart, &trEnd);

    MSR_INTEGER(m_idBaseStamp, (int)trStart);     // dump low order 32 bits

    m_pClock->GetTime(&m_trRenderStart);
    MSR_INTEGER(0, (int)m_trRenderStart);
    REFERENCE_TIME trStream;
    trStream = m_trRenderStart-m_tStart;     // convert reftime to stream time
    MSR_INTEGER(0,(int)trStream);

    const int trLate = (int)(trStream - trStart);
    MSR_INTEGER(m_idBaseAccuracy, trLate/10000);  // dump in mSec
#endif

} // OnRenderStart


// Called directly after drawing an image.
// calculate the time spent drawing and log it.

void CBaseRenderer::OnRenderEnd(IMediaSample *pMediaSample)
{
#ifdef PERF
    REFERENCE_TIME trNow;
    m_pClock->GetTime(&trNow);
    MSR_INTEGER(0,(int)trNow);
    int t = (int)((trNow - m_trRenderStart)/10000);   // convert UNITS->msec
    MSR_INTEGER(m_idBaseRenderTime, t);
#endif
} // OnRenderEnd




// Constructor must be passed the base renderer object

CRendererInputPin::CRendererInputPin(CBaseRenderer *pRenderer,
				     HRESULT *phr,
				     LPCWSTR pPinName) :
    CBaseInputPin(NAME("Renderer pin"),
		  pRenderer,
		  &pRenderer->m_InterfaceLock,
		  (HRESULT *) phr,
		  pPinName)
{
    m_pRenderer = pRenderer;
    ASSERT(m_pRenderer);
}


// Signals end of data stream on the input pin

STDMETHODIMP CRendererInputPin::EndOfStream()
{
    CAutoLock cRendererLock(&m_pRenderer->m_InterfaceLock);
    CAutoLock cSampleLock(&m_pRenderer->m_RendererLock);

    // Make sure we're streaming ok

    HRESULT hr = CheckStreaming();
    if (hr != NOERROR) {
	return hr;
    }

    // Pass it onto the renderer

    hr = m_pRenderer->EndOfStream();
    if (SUCCEEDED(hr)) {
	hr = CBaseInputPin::EndOfStream();
    }
    return hr;
}


// Signals start of flushing on the input pin - we do the final reset end of
// stream with the renderer lock unlocked but with the interface lock locked
// We must do this because we call timeKillEvent, our timer callback method
// has to take the renderer lock to serialise our state. Therefore holding a
// renderer lock when calling timeKillEvent could cause a deadlock condition

STDMETHODIMP CRendererInputPin::BeginFlush()
{
    CAutoLock cRendererLock(&m_pRenderer->m_InterfaceLock);
    {
	CAutoLock cSampleLock(&m_pRenderer->m_RendererLock);
	CBaseInputPin::BeginFlush();
	m_pRenderer->BeginFlush();
    }
    return m_pRenderer->ResetEndOfStream();
}


// Signals end of flushing on the input pin

STDMETHODIMP CRendererInputPin::EndFlush()
{
    CAutoLock cRendererLock(&m_pRenderer->m_InterfaceLock);
    CAutoLock cSampleLock(&m_pRenderer->m_RendererLock);

    HRESULT hr = m_pRenderer->EndFlush();
    if (SUCCEEDED(hr)) {
	hr = CBaseInputPin::EndFlush();
    }
    return hr;
}


// Pass the sample straight through to the renderer object

STDMETHODIMP CRendererInputPin::Receive(IMediaSample *pSample)
{
    return m_pRenderer->Receive(pSample);
}


// Called when the input pin is disconnected

HRESULT CRendererInputPin::BreakConnect()
{
    HRESULT hr = m_pRenderer->BreakConnect();
    if (FAILED(hr)) {
	return hr;
    }
    return CBaseInputPin::BreakConnect();
}


// Called when the input pin is connected

HRESULT CRendererInputPin::CompleteConnect(IPin *pReceivePin)
{
    HRESULT hr = m_pRenderer->CompleteConnect(pReceivePin);
    if (FAILED(hr)) {
	return hr;
    }
    return CBaseInputPin::CompleteConnect(pReceivePin);
}


// Give the pin id of our one and only pin

STDMETHODIMP CRendererInputPin::QueryId(LPWSTR *Id)
{
    CheckPointer(Id,E_POINTER);

    *Id = (LPWSTR)CoTaskMemAlloc(8);
    if (*Id == NULL) {
       return E_OUTOFMEMORY;
    }
    lstrcpyW(*Id, L"In");
    return NOERROR;
}


// Will the filter accept this media type

HRESULT CRendererInputPin::CheckMediaType(const CMediaType *pmt)
{
    return m_pRenderer->CheckMediaType(pmt);
}


// Called when we go paused or running

HRESULT CRendererInputPin::Active()
{
    return m_pRenderer->Active();
}


// Called when we go into a stopped state

HRESULT CRendererInputPin::Inactive()
{
    return m_pRenderer->Inactive();
}


// Tell derived classes about the media type agreed

HRESULT CRendererInputPin::SetMediaType(const CMediaType *pmt)
{
    HRESULT hr = CBaseInputPin::SetMediaType(pmt);
    if (FAILED(hr)) {
	return hr;
    }
    return m_pRenderer->SetMediaType(pmt);
}


// We do not keep an event object to use when setting up a timer link with
// the clock but are given a pointer to one by the owning object through the
// SetNotificationObject method - this must be initialised before starting
// We can override the default quality management process to have it always
// draw late frames, this is currently done by having the following registry
// key (actually an INI key) called DrawLateFrames set to 1 (default is 0)

const TCHAR AMQUALITY[] = TEXT("ActiveMovie");
const TCHAR DRAWLATEFRAMES[] = TEXT("DrawLateFrames");

CBaseVideoRenderer::CBaseVideoRenderer(
      REFCLSID RenderClass, // CLSID for this renderer
      TCHAR *pName,         // Debug ONLY description
      LPUNKNOWN pUnk,       // Aggregated owner object
      HRESULT *phr) :       // General OLE return code

    CBaseRenderer(RenderClass,pName,pUnk,phr),
    m_cFramesDropped(0),
    m_cFramesDrawn(0),
    m_bSupplierHandlingQuality(FALSE)
{
    ResetStreamingTimes();

#ifdef PERF
    m_idTimeStamp       = MSR_REGISTER("Frame time stamp");
    m_idEarliness       = MSR_REGISTER("Earliness fudge");
    m_idTarget          = MSR_REGISTER("Target (mSec)");
    m_idSchLateTime     = MSR_REGISTER("mSec late when scheduled");
    m_idDecision        = MSR_REGISTER("Scheduler decision code");
    m_idQualityRate     = MSR_REGISTER("Quality rate sent");
    m_idQualityTime     = MSR_REGISTER("Quality time sent");
    m_idWaitReal        = MSR_REGISTER("Render wait");
    // m_idWait            = MSR_REGISTER("wait time recorded (msec)");
    m_idFrameAccuracy   = MSR_REGISTER("Frame accuracy (msecs)");
    m_bDrawLateFrames = GetProfileInt(AMQUALITY, DRAWLATEFRAMES, FALSE);
    //m_idSendQuality      = MSR_REGISTER("Processing Quality message");

    m_idRenderAvg       = MSR_REGISTER("Render draw time Avg");
    m_idFrameAvg        = MSR_REGISTER("FrameAvg");
    m_idWaitAvg         = MSR_REGISTER("WaitAvg");
    m_idDuration        = MSR_REGISTER("Duration");
    m_idThrottle        = MSR_REGISTER("Audio-video throttle wait");
    // m_idDebug           = MSR_REGISTER("Debug stuff");
#endif // PERF
} // Constructor


// Destructor is just a placeholder

CBaseVideoRenderer::~CBaseVideoRenderer()
{
    ASSERT(m_dwAdvise == 0);
}


// The timing functions in this class are called by the window object and by
// the renderer's allocator.
// The windows object calls timing functions as it receives media sample
// images for drawing using GDI.
// The allocator calls timing functions when it starts passing DCI/DirectDraw
// surfaces which are not rendered in the same way; The decompressor writes
// directly to the surface with no separate rendering, so those code paths
// call direct into us.  Since we only ever hand out DCI/DirectDraw surfaces
// when we have allocated one and only one image we know there cannot be any
// conflict between the two.
//
// We use timeGetTime to return the timing counts we use (since it's relative
// performance we are interested in rather than absolute compared to a clock)
// The window object sets the accuracy of the system clock (normally 1ms) by
// calling timeBeginPeriod/timeEndPeriod when it changes streaming states


// Reset all times controlling streaming.
// Set them so that
// 1. Frames will not initially be dropped
// 2. The first frame will definitely be drawn (achieved by saying that there
//    has not ben a frame drawn for a long time).

HRESULT CBaseVideoRenderer::ResetStreamingTimes()
{
    m_trLastDraw = -1000;     // set up as first frame since ages (1 sec) ago
    m_tStreamingStart = timeGetTime();
    m_trRenderAvg = 0;
    m_trFrameAvg = -1;        // -1000 fps == "unset"
    m_trDuration = 0;         // 0 - strange value
    m_trRenderLast = 0;
    m_trWaitAvg = 0;
    m_tRenderStart = 0;
    m_cFramesDrawn = 0;
    m_cFramesDropped = 0;
    m_iTotAcc = 0;
    m_iSumSqAcc = 0;
    m_iSumSqFrameTime = 0;
    m_trFrame = 0;          // hygeine - not really needed
    m_trLate = 0;           // hygeine - not really needed
    m_iSumFrameTime = 0;
    m_nNormal = 0;
    m_trEarliness = 0;
    m_trTarget = -300000;  // 30mSec early
    m_trThrottle = 0;
    m_trRememberStampForPerf = 0;

#ifdef PERF
    m_trRememberFrameForPerf = 0;
#endif

    return NOERROR;
} // ResetStreamingTimes


// Reset all times controlling streaming. Note that we're now streaming. We
// don't need to set the rendering event to have the source filter released
// as it is done during the Run processing. When we are run we immediately
// release the source filter thread and draw any image waiting (that image
// may already have been drawn once as a poster frame while we were paused)

HRESULT CBaseVideoRenderer::OnStartStreaming()
{
    ResetStreamingTimes();
    return NOERROR;
} // OnStartStreaming


// Called at end of streaming.  Fixes times for property page report

HRESULT CBaseVideoRenderer::OnStopStreaming()
{
    m_tStreamingStart = timeGetTime()-m_tStreamingStart;
    return NOERROR;
} // OnStopStreaming


// Called when we start waiting for a rendering event.
// Used to update times spent waiting and not waiting.

void CBaseVideoRenderer::OnWaitStart()
{
    MSR_START(m_idWaitReal);
} // OnWaitStart


// Called when we are awoken from the wait in the window OR by our allocator
// when it is hanging around until the next sample is due for rendering on a
// DCI/DirectDraw surface. We add the wait time into our rolling average.
// We grab the interface lock so that we're serialised with the application
// thread going through the run code - which in due course ends up calling
// ResetStreaming times - possibly as we run through this section of code

void CBaseVideoRenderer::OnWaitEnd()
{
#ifdef PERF
    MSR_STOP(m_idWaitReal);
    // for a perf build we want to know just exactly how late we REALLY are.
    // even if this means that we have to look at the clock again.

    REFERENCE_TIME trRealStream;     // the real time now expressed as stream time.
#if 0
    m_pClock->GetTime(&trRealStream); // Calling clock here causes W95 deadlock!
#else
    // We will be discarding overflows like mad here!
    // This is wrong really because timeGetTime() can wrap but it's
    // only for PERF
    REFERENCE_TIME tr = timeGetTime()*10000;
    trRealStream = tr + m_llTimeOffset;
#endif
    trRealStream -= m_tStart;     // convert to stream time (this is a reftime)

    if (m_trRememberStampForPerf==0) {
	// This is probably the poster frame at the start, and it is not scheduled
	// in the usual way at all.  Just count it.  The rememberstamp gets set
	// in ShouldDrawSampleNow, so this does bogus frame recording until we
	// actually start playing.
	PreparePerformanceData(0, 0);
    } else {
	int trLate = (int)(trRealStream - m_trRememberStampForPerf);
	int trFrame = (int)(tr - m_trRememberFrameForPerf);
	PreparePerformanceData(trLate, trFrame);
    }
    m_trRememberFrameForPerf = tr;
#endif //PERF
} // OnWaitEnd


// Put data on one side that describes the lateness of the current frame.
// We don't yet know whether it will actually be drawn.  In direct draw mode,
// this decision is up to the filter upstream, and it could change its mind.
// The rules say that if it did draw it must call Receive().  One way or
// another we eventually get into either OnRenderStart or OnDirectRender and
// these both call RecordFrameLateness to update the statistics.

void CBaseVideoRenderer::PreparePerformanceData(int trLate, int trFrame)
{
    m_trLate = trLate;
    m_trFrame = trFrame;
} // PreparePerformanceData


// update the statistics:
// m_iTotAcc, m_iSumSqAcc, m_iSumSqFrameTime, m_iSumFrameTime, m_cFramesDrawn
// Note that because the properties page reports using these variables,
// 1. We need to be inside a critical section
// 2. They must all be updated together.  Updating the sums here and the count
// elsewhere can result in imaginary jitter (i.e. attempts to find square roots
// of negative numbers) in the property page code.

void CBaseVideoRenderer::RecordFrameLateness(int trLate, int trFrame)
{
    // Record how timely we are.
    int tLate = trLate/10000;

    // Best estimate of moment of appearing on the screen is average of
    // start and end draw times.  Here we have only the end time.  This may
    // tend to show us as spuriously late by up to 1/2 frame rate achieved.
    // Decoder probably monitors draw time.  We don't bother.
    MSR_INTEGER( m_idFrameAccuracy, tLate );

    // This is a hack - we can get frames that are ridiculously late
    // especially (at start-up) and they sod up the statistics.
    // So ignore things that are more than 1 sec off.
    if (tLate>1000 || tLate<-1000) {
	if (m_cFramesDrawn<=1) {
	    tLate = 0;
	} else if (tLate>0) {
	    tLate = 1000;
	} else {
	    tLate = -1000;
	}
    }
    // The very first frame often has a bogus time, so I'm just
    // not going to count it into the statistics.   ???
    if (m_cFramesDrawn>1) {
	m_iTotAcc += tLate;
	m_iSumSqAcc += (tLate*tLate);
    }

    // calculate inter-frame time.  Doesn't make sense for first frame
    // second frame suffers from bogus first frame stamp.
    if (m_cFramesDrawn>2) {
	int tFrame = trFrame/10000;    // convert to mSec else it overflows
		// This is a hack.  It can overflow anyway (a pause can cause
		// a very long inter-frame time) and it overflows at 2**31/10**7
		// or about 215 seconds i.e. 3min 35sec
	if (tFrame>1000||tFrame<0) tFrame = 1000;
	m_iSumSqFrameTime += tFrame*tFrame;
	ASSERT(m_iSumSqFrameTime>=0);
	m_iSumFrameTime += tFrame;
    }
    ++m_cFramesDrawn;

} // RecordFrameLateness


void CBaseVideoRenderer::ThrottleWait()
{
    if (m_trThrottle>0) {
	int iThrottle = m_trThrottle/10000;    // convert to mSec
	MSR_INTEGER( m_idThrottle, iThrottle);
        DbgLog((LOG_TRACE, 0, TEXT("Throttle %d ms"), iThrottle));
	Sleep(iThrottle);
    } else {
        Sleep(0);
    }
} // ThrottleWait


// Whenever a frame is rendered it goes though either OnRenderStart
// or OnDirectRender.  Data that are generated during ShouldDrawSample
// are added to the statistics by calling RecordFrameLateness from both
// these two places.

// Called in place of OnRenderStart..OnRenderEnd
// When a DirectDraw image is drawn
void CBaseVideoRenderer::OnDirectRender(IMediaSample *pMediaSample)
{
    int time = 0;
    m_trRenderAvg = 0;
    m_trRenderLast = 5000000;  // If we mode switch, we do NOT want this
			       // to inhibit the new average getting going!
			       // so we set it to half a second
    // MSR_INTEGER(m_idRenderAvg, m_trRenderAvg/10000);
    RecordFrameLateness(m_trLate, m_trFrame);
    ThrottleWait();
} // OnDirectRender


// Called just before we start drawing.  All we do is to get the current clock
// time (from the system) and return.  We have to store the start render time
// in a member variable because it isn't used until we complete the drawing
// The rest is just performance logging.

void CBaseVideoRenderer::OnRenderStart(IMediaSample *pMediaSample)
{
    RecordFrameLateness(m_trLate, m_trFrame);
    m_tRenderStart = timeGetTime();
} // OnRenderStart


// Called directly after drawing an image.  We calculate the time spent in the
// drawing code and if this doesn't appear to have any odd looking spikes in
// it then we add it to the current average draw time.  Measurement spikes may
// occur if the drawing thread is interrupted and switched to somewhere else.

void CBaseVideoRenderer::OnRenderEnd(IMediaSample *pMediaSample)
{
    // The renderer time can vary erratically if we are interrupted so we do
    // some smoothing to help get more sensible figures out but even that is
    // not enough as figures can go 9,10,9,9,83,9 and we must disregard 83

    int tr = (timeGetTime() - m_tRenderStart)*10000;   // convert mSec->UNITS
    if (tr < m_trRenderAvg*2 || tr < 2 * m_trRenderLast) {
	// DO_MOVING_AVG(m_trRenderAvg, tr);
	m_trRenderAvg = (tr + (AVGPERIOD-1)*m_trRenderAvg)/AVGPERIOD;
    }
    m_trRenderLast = tr;
    ThrottleWait();
} // OnRenderEnd


STDMETHODIMP CBaseVideoRenderer::SetSink( IQualityControl * piqc)
{

    m_pQSink = piqc;

    return NOERROR;
} // SetSink


STDMETHODIMP CBaseVideoRenderer::Notify( IBaseFilter * pSelf, Quality q)
{
    // NOTE:  We are NOT getting any locks here.  We could be called
    // asynchronously and possibly even on a time critical thread of
    // someone else's - so we do the minumum.  We only set one state
    // variable (an integer) and if that happens to be in the middle
    // of another thread reading it they will just get either the new
    // or the old value.  Locking would achieve no more than this.

    // It might be nice to check that we are being called from m_pGraph, but
    // it turns out to be a millisecond or so per throw!

    // This is heuristics, these numbers are aimed at being "what works"
    // rather than anything based on some theory.
    // We use a hyperbola because it's easy to calculate and it includes
    // a panic button asymptote (which we push off just to the left)
    // The throttling fits the following table (roughly)
    // Proportion   Throttle (msec)
    //     >=1000         0
    //        900         3
    //        800         7
    //        700        11
    //        600        17
    //        500        25
    //        400        35
    //        300        50
    //        200        72
    //        125       100
    //        100       112
    //         50       146
    //          0       200

    // (some evidence that we could go for a sharper kink - e.g. no throttling
    // until below the 750 mark - might give fractionally more frames on a
    // P60-ish machine).  The easy way to get these coefficients is to use
    // Renbase.xls follow the instructions therein using excel solver.

    if (q.Proportion>=1000) { m_trThrottle = 0; }
    else {
	// The DWORD is to make quite sure I get unsigned arithmetic
	// as the constant is between 2**31 and 2**32
	m_trThrottle = -330000 + (388880000/(q.Proportion+167));
    }
    return NOERROR;
} // Notify


// Send a message to indicate what our supplier should do about quality.
// Theory:
// What a supplier wants to know is "is the frame I'm working on NOW
// going to be late?".
// F1 is the frame at the supplier (as above)
// Tf1 is the due time for F1
// T1 is the time at that point (NOW!)
// Tr1 is the time that f1 WILL actually be rendered
// L1 is the latency of the graph for frame F1 = Tr1-T1
// D1 (for delay) is how late F1 will be beyond its due time i.e.
// D1 = (Tr1-Tf1) which is what the supplier really wants to know.
// Unfortunately Tr1 is in the future and is unknown, so is L1
//
// We could estimate L1 by its value for a previous frame,
// L0 = Tr0-T0 and work off
// D1' = ((T1+L0)-Tf1) = (T1 + (Tr0-T0) -Tf1)
// Rearranging terms:
// D1' = (T1-T0) + (Tr0-Tf1)
//       adding (Tf0-Tf0) and rearranging again:
//     = (T1-T0) + (Tr0-Tf0) + (Tf0-Tf1)
//     = (T1-T0) - (Tf1-Tf0) + (Tr0-Tf0)
// But (Tr0-Tf0) is just D0 - how late frame zero was, and this is the
// Late field in the quality message that we send.
// The other two terms just state what correction should be applied before
// using the lateness of F0 to predict the lateness of F1.
// (T1-T0) says how much time has actually passed (we have lost this much)
// (Tf1-Tf0) says how much time should have passed if we were keeping pace
// (we have gained this much).
//
// Suppliers should therefore work off:
//    Quality.Late + (T1-T0)  - (Tf1-Tf0)
// and see if this is "acceptably late" or even early (i.e. negative).
// They get T1 and T0 by polling the clock, they get Tf1 and Tf0 from
// the time stamps in the frames.  They get Quality.Late from us.
//

HRESULT CBaseVideoRenderer::SendQuality(REFERENCE_TIME trLate,
					REFERENCE_TIME trRealStream)
{
    Quality q;
    HRESULT hr;

    // If we are the main user of time, then report this as Flood/Dry.
    // If our suppliers are, then report it as Famine/Glut.
    //
    // We need to take action, but avoid hunting.  Hunting is caused by
    // 1. Taking too much action too soon and overshooting
    // 2. Taking too long to react (so averaging can CAUSE hunting).
    //
    // The reason why we use trLate as well as Wait is to reduce hunting;
    // if the wait time is coming down and about to go into the red, we do
    // NOT want to rely on some average which is only telling is that it used
    // to be OK once.

    q.TimeStamp = (REFERENCE_TIME)trRealStream;

    if (m_trFrameAvg<0) {
	q.Type = Famine;      // guess
    }
    // Is the greater part of the time taken bltting or something else
    else if (m_trFrameAvg > 2*m_trRenderAvg) {
	q.Type = Famine;                        // mainly other
    } else {
	q.Type = Flood;                         // mainly bltting
    }

    q.Proportion = 1000;               // default

    if (m_trFrameAvg<0) {
	// leave it alone - we don't know enough
    }
    else if ( trLate> 0 ) {
	// try to catch up over the next second
	// We could be Really, REALLY late, but rendering all the frames
	// anyway, just because it's so cheap.

	q.Proportion = 1000 - (int)((trLate)/(UNITS/1000));
	if (q.Proportion<500) {
	   q.Proportion = 500;      // don't go daft. (could've been negative!)
	} else {
	}

    } else if (  m_trWaitAvg>20000
	      && trLate<-20000
	      ){
	// Go cautiously faster - aim at 2mSec wait.
	if (m_trWaitAvg>=m_trFrameAvg) {
	    // This can happen because of some fudges.
	    // The waitAvg is how long we originally planned to wait
	    // The frameAvg is more honest.
	    // It means that we are spending a LOT of time waiting
	    q.Proportion = 2000;    // double.
	} else {
	    if (m_trFrameAvg+20000 > m_trWaitAvg) {
		q.Proportion
		    = 1000 * (m_trFrameAvg / (m_trFrameAvg + 20000 - m_trWaitAvg));
	    } else {
		// We're apparently spending more than the whole frame time waiting.
		// Assume that the averages are slightly out of kilter, but that we
		// are indeed doing a lot of waiting.  (This leg probably never
		// happens, but the code avoids any potential divide by zero).
		q.Proportion = 2000;
	    }
	}

	if (q.Proportion>2000) {
	    q.Proportion = 2000;    // don't go crazy.
	}
    }

    // Tell the supplier how late frames are when they get rendered
    // That's how late we are now.
    // If we are in directdraw mode then the guy upstream can see the drawing
    // times and we'll just report on the start time.  He can figure out any
    // offset to apply.  If we are in DIB Section mode then we will apply an
    // extra offset which is half of our drawing time.  This is usually small
    // but can sometimes be the dominant effect.  For this we will use the
    // average drawing time rather than the last frame.  If the last frame took
    // a long time to draw and made us late, that's already in the lateness
    // figure.  We should not add it in again unless we expect the next frame
    // to be the same.  We don't, we expect the average to be a better shot.
    // In direct draw mode the RenderAvg will be zero.

    q.Late = trLate + m_trRenderAvg/2;

    // log what we're doing
    MSR_INTEGER(m_idQualityRate, q.Proportion);
    MSR_INTEGER( m_idQualityTime, (int)q.Late / 10000 );

    // A specific sink interface may be set through IPin

    if (m_pQSink==NULL) {
	// Get our input pin's peer.  We send quality management messages
	// to any nominated receiver of these things (set in the IPin
	// interface), or else to our source filter.

	IQualityControl *pQC = NULL;
	IPin *pOutputPin = m_pInputPin->GetConnected();
	ASSERT(pOutputPin != NULL);

	// And get an AddRef'd quality control interface

	hr = pOutputPin->QueryInterface(IID_IQualityControl,(void**) &pQC);
	if (SUCCEEDED(hr)) {
	    m_pQSink = pQC;
	}
    }
    if (m_pQSink) {
	return m_pQSink->Notify(this,q);
    }

    return S_FALSE;

} // SendQuality


// We are called with a valid IMediaSample image to decide whether this is to
// be drawn or not.  There must be a reference clock in operation.
// Return S_OK if it is to be drawn Now (as soon as possible)
// Return S_FALSE if it is to be drawn when it's due
// Return an error if we want to drop it
// m_nNormal=-1 indicates that we dropped the previous frame and so this
// one should be drawn early.  Respect it and update it.
// Use current stream time plus a number of heuristics (detailed below)
// to make the decision

HRESULT CBaseVideoRenderer::ShouldDrawSampleNow(IMediaSample *pMediaSample,
						REFERENCE_TIME *ptrStart,
						REFERENCE_TIME *ptrEnd)
{

    // Don't call us unless there's a clock interface to synchronise with
    ASSERT(m_pClock);

    MSR_INTEGER(m_idTimeStamp, (int)((*ptrStart)>>32));   // high order 32 bits
    MSR_INTEGER(m_idTimeStamp, (int)(*ptrStart));         // low order 32 bits

    // We lose a bit of time depending on the monitor type waiting for the next
    // screen refresh.  On average this might be about 8mSec - so it will be
    // later than we think when the picture appears.  To compensate a bit
    // we bias the media samples by -8mSec i.e. 80000 UNITs.
    // We don't ever make a stream time negative (call it paranoia)
    if (*ptrStart>=80000) {
	*ptrStart -= 80000;
	*ptrEnd -= 80000;       // bias stop to to retain valid frame duration
    }

    // Cache the time stamp now.  We will want to compare what we did with what
    // we started with (after making the monitor allowance).
    m_trRememberStampForPerf = *ptrStart;

    // Get reference times (current and late)
    REFERENCE_TIME trRealStream;     // the real time now expressed as stream time.
    m_pClock->GetTime(&trRealStream);
#ifdef PERF
    // While the reference clock is expensive:
    // Remember the offset from timeGetTime and use that.
    // This overflows all over the place, but when we subtract to get
    // differences the overflows all cancel out.
    m_llTimeOffset = trRealStream-timeGetTime()*10000;
#endif
    trRealStream -= m_tStart;     // convert to stream time (this is a reftime)

    // We have to wory about two versions of "lateness".  The truth, which we
    // try to work out here and the one measured against m_trTarget which
    // includes long term feedback.  We report statistics against the truth
    // but for operational decisions we work to the target.
    // We use TimeDiff to make sure we get an integer because we
    // may actually be late (or more likely early if there is a big time
    // gap) by a very long time.
    const int trTrueLate = TimeDiff(trRealStream - *ptrStart);
    const int trLate = trTrueLate;

    MSR_INTEGER(m_idSchLateTime, trTrueLate/10000);

    // Send quality control messages upstream, measured against target
    HRESULT hr = SendQuality(trLate, trRealStream);
    // Note: the filter upstream is allowed to this FAIL meaning "you do it".
    m_bSupplierHandlingQuality = (hr==S_OK);

    // Decision time!  Do we drop, draw when ready or draw immediately?

    const int trDuration = (int)(*ptrEnd - *ptrStart);
    {
	// We need to see if the frame rate of the file has just changed.
	// This would make comparing our previous frame rate with the current
	// frame rate odd.  Hang on a moment though.  I've seen files
	// where the frames vary between 33 and 34 mSec so as to average
	// 30fps.  A minor variation like that won't hurt us.
	int t = m_trDuration/32;
	if (  trDuration > m_trDuration+t
	   || trDuration < m_trDuration-t
	   ) {
	    // There's a major variation.  Reset the average frame rate to
	    // exactly the current rate to disable decision 9002 for this frame,
	    // and remember the new rate.
	    m_trFrameAvg = trDuration;
	    m_trDuration = trDuration;
	}
    }

    MSR_INTEGER(m_idEarliness, m_trEarliness/10000);
    MSR_INTEGER(m_idRenderAvg, m_trRenderAvg/10000);
    MSR_INTEGER(m_idFrameAvg, m_trFrameAvg/10000);
    MSR_INTEGER(m_idWaitAvg, m_trWaitAvg/10000);
    MSR_INTEGER(m_idDuration, trDuration/10000);

#ifdef PERF
    if (S_OK==pMediaSample->IsDiscontinuity()) {
	MSR_INTEGER(m_idDecision, 9000);
    }
#endif

    // Control the graceful slide back from slow to fast machine mode.
    // After a frame drop accept an early frame and set the earliness to here
    // If this frame is already later than the earliness then slide it to here
    // otherwise do the standard slide (reduce by about 12% per frame).
    // Note: earliness is normally NEGATIVE
    BOOL bJustDroppedFrame
	= (  m_bSupplierHandlingQuality
	  //  Can't use the pin sample properties because we might
	  //  not be in Receive when we call this
	  && (S_OK == pMediaSample->IsDiscontinuity())          // he just dropped one
	  )
       || (m_nNormal==-1);                          // we just dropped one


    // Set m_trEarliness (slide back from slow to fast machine mode)
    if (trLate>0) {
	m_trEarliness = 0;   // we are no longer in fast machine mode at all!
    } else if (  (trLate>=m_trEarliness) || bJustDroppedFrame) {
	m_trEarliness = trLate;  // Things have slipped of their own accord
    } else {
	m_trEarliness = m_trEarliness - m_trEarliness/8;  // graceful slide
    }

    // prepare the new wait average - but don't pollute the old one until
    // we have finished with it.
    int trWaitAvg;
    {
	// We never mix in a negative wait.  This causes us to believe in fast machines
	// slightly more.
	int trL = trLate<0 ? -trLate : 0;
	trWaitAvg = (trL + m_trWaitAvg*(AVGPERIOD-1))/AVGPERIOD;
    }


    int trFrame;
    {
	REFERENCE_TIME tr = trRealStream - m_trLastDraw; // Cd be large - 4 min pause!
	if (tr>10000000) {
	    tr = 10000000;   // 1 second - arbitrarily.
	}
	trFrame = int(tr);
    }

    // We will DRAW this frame IF...
    if (
	  // ...the time we are spending drawing is a small fraction of the total
	  // observed inter-frame time so that dropping it won't help much.
	  (3*m_trRenderAvg <= m_trFrameAvg)

	 // ...or our supplier is NOT handling things and the next frame would
	 // be less timely than this one or our supplier CLAIMS to be handling
	 // things, and is now less than a full FOUR frames late.
       || ( m_bSupplierHandlingQuality
	  ? (trLate <= trDuration*4)
	  : (trLate+trLate < trDuration)
	  )

	  // ...or we are on average waiting for over eight milliseconds then
	  // this may be just a glitch.  Draw it and we'll hope to catch up.
       || (m_trWaitAvg > 80000)

	  // ...or we haven't drawn an image for over a second.  We will update
	  // the display, which stops the video looking hung.
	  // Do this regardless of how late this media sample is.
       || ((trRealStream - m_trLastDraw) > UNITS)

    ) {
	HRESULT Result;

	// We are going to play this frame.  We may want to play it early.
	// We will play it early if we think we are in slow machine mode.
	// If we think we are NOT in slow machine mode, we will still play
	// it early by m_trEarliness as this controls the graceful slide back.
	// and in addition we aim at being m_trTarget late rather than "on time".

	BOOL bPlayASAP = FALSE;

	// we will play it AT ONCE (slow machine mode) if...

	    // ...we are playing catch-up
	if ( bJustDroppedFrame) {
	    bPlayASAP = TRUE;
	    MSR_INTEGER(m_idDecision, 9001);
	}

	    // ...or if we are running below the true frame rate
	    // exact comparisons are glitchy, for these measurements,
	    // so add an extra 5% or so
	else if (  (m_trFrameAvg > trDuration + trDuration/16)

		   // It's possible to get into a state where we are losing ground, but
		   // are a very long way ahead.  To avoid this or recover from it
		   // we refuse to play early by more than 10 frames.
		&& (trLate > - trDuration*10)
		){
	    bPlayASAP = TRUE;
	    MSR_INTEGER(m_idDecision, 9002);
	}
#if 0
	    // ...or if we have been late and are less than one frame early
	else if (  (trLate + trDuration > 0)
		&& (m_trWaitAvg<=20000)
		) {
	    bPlayASAP = TRUE;
	    MSR_INTEGER(m_idDecision, 9003);
	}
#endif
	// We will NOT play it at once if we are grossly early.  On very slow frame
	// rate movies - e.g. clock.avi - it is not a good idea to leap ahead just
	// because we got starved (for instance by the net) and dropped one frame
	// some time or other.  If we are more than 900mSec early, then wait.
	if (trLate<-9000000) {
	    bPlayASAP = FALSE;
	}

	if (bPlayASAP) {

	    m_nNormal = 0;
	    MSR_INTEGER(m_idDecision, 0);
	    // When we are here, we are in slow-machine mode.  trLate may well
	    // oscillate between negative and positive when the supplier is
	    // dropping frames to keep sync.  We should not let that mislead
	    // us into thinking that we have as much as zero spare time!
	    // We just update with a zero wait.
	    m_trWaitAvg = (m_trWaitAvg*(AVGPERIOD-1))/AVGPERIOD;

	    // Assume that we draw it immediately.  Update inter-frame stats
	    m_trFrameAvg = (trFrame + m_trFrameAvg*(AVGPERIOD-1))/AVGPERIOD;
#ifndef PERF
	    // if this is NOT a perf build, then report what we know so far
	    // without looking at the clock any more.  This assumes that we
	    // actually wait for exactly the time we hope to.  it also reports
	    // how close we get to the hacked up time stamps that we now have
	    // rather than the ones we originally started with.  It will
	    // therefore be a little optimistic.  However it's fast.
	    PreparePerformanceData(trTrueLate, trFrame);
#endif
	    m_trLastDraw = trRealStream;
	    if (m_trEarliness > trLate) {
		m_trEarliness = trLate;  // if we are actually early, this is neg
	    }
	    Result = S_OK;                   // Draw it now

	} else {
	    ++m_nNormal;
	    // Set the average frame rate to EXACTLY the ideal rate.
	    // If we are exiting slow-machine mode then we will have caught up
	    // and be running ahead, so as we slide back to exact timing we will
	    // have a longer than usual gap at this point.  If we record this
	    // real gap then we'll think that we're running slow and go back
	    // into slow-machine mode and vever get it straight.
	    m_trFrameAvg = trDuration;
	    MSR_INTEGER(m_idDecision, 1);

	    // Play it early by m_trEarliness and by m_trTarget

	    {
		int trE = m_trEarliness;
                if (trE < -m_trFrameAvg) {
                    trE = -m_trFrameAvg;
                }
		*ptrStart += trE;           // N.B. earliness is negative
	    }

	    int Delay = -trTrueLate;
	    Result = Delay<=0 ? S_OK : S_FALSE;     // OK = draw now, FALSE = wait

	    m_trWaitAvg = trWaitAvg;

	    // Predict when it will actually be drawn and update frame stats

	    if (Result==S_FALSE) {   // We are going to wait
		trFrame = TimeDiff(*ptrStart-m_trLastDraw);
		m_trLastDraw = *ptrStart;
	    } else {
		// trFrame is already = trRealStream-m_trLastDraw;
		m_trLastDraw = trRealStream;
	    }
#ifndef PERF
	    int iAccuracy;
	    if (Delay>0) {
		// Report lateness based on when we intend to play it
		iAccuracy = TimeDiff(*ptrStart-m_trRememberStampForPerf);
	    } else {
		// Report lateness based on playing it *now*.
		iAccuracy = trTrueLate;     // trRealStream-RememberStampForPerf;
	    }
	    PreparePerformanceData(iAccuracy, trFrame);
#endif
	}
	return Result;
    }

    // We are going to drop this frame!
    // Of course in DirectDraw mode the guy upstream may draw it anyway.

    // This will probably give a large negative wack to the wait avg.
    m_trWaitAvg = trWaitAvg;

#ifdef PERF
    // Respect registry setting - debug only!
    if (m_bDrawLateFrames) {
       return S_OK;                        // draw it when it's ready
    }                                      // even though it's late.
#endif

    // We are going to drop this frame so draw the next one early
    // n.b. if the supplier is doing direct draw then he may draw it anyway
    // but he's doing something funny to arrive here in that case.

    MSR_INTEGER(m_idDecision, 2);
    m_nNormal = -1;
    return E_FAIL;                         // drop it

} // ShouldDrawSampleNow


// NOTE we're called by both the window thread and the source filter thread
// so we have to be protected by a critical section (locked before called)
// Also, when the window thread gets signalled to render an image, it always
// does so regardless of how late it is. All the degradation is done when we
// are scheduling the next sample to be drawn. Hence when we start an advise
// link to draw a sample, that sample's time will always become the last one
// drawn - unless of course we stop streaming in which case we cancel links

BOOL CBaseVideoRenderer::ScheduleSample(IMediaSample *pMediaSample)
{
    // We override ShouldDrawSampleNow to add quality management

    BOOL bDrawImage = CBaseRenderer::ScheduleSample(pMediaSample);
    if (bDrawImage == FALSE) {
	++m_cFramesDropped;
	return FALSE;
    }

    // m_cFramesDrawn must NOT be updated here.  It has to be updated
    // in RecordFrameLateness at the same time as the other statistics.
    return TRUE;
}


// Implementation of IQualProp interface needed to support the property page
// This is how the property page gets the data out of the scheduler. We are
// passed into the constructor the owning object in the COM sense, this will
// either be the video renderer or an external IUnknown if we're aggregated.
// We initialise our CUnknown base class with this interface pointer. Then
// all we have to do is to override NonDelegatingQueryInterface to expose
// our IQualProp interface. The AddRef and Release are handled automatically
// by the base class and will be passed on to the appropriate outer object

STDMETHODIMP CBaseVideoRenderer::get_FramesDroppedInRenderer(int *pcFramesDropped)
{
    CheckPointer(pcFramesDropped,E_POINTER);
    CAutoLock cVideoLock(&m_InterfaceLock);
    *pcFramesDropped = m_cFramesDropped;
    return NOERROR;
} // get_FramesDroppedInRenderer


// Set *pcFramesDrawn to the number of frames drawn since
// streaming started.

STDMETHODIMP CBaseVideoRenderer::get_FramesDrawn( int *pcFramesDrawn)
{
    CheckPointer(pcFramesDrawn,E_POINTER);
    CAutoLock cVideoLock(&m_InterfaceLock);
    *pcFramesDrawn = m_cFramesDrawn;
    return NOERROR;
} // get_FramesDrawn


// Set iAvgFrameRate to the frames per hundred secs since
// streaming started.  0 otherwise.

STDMETHODIMP CBaseVideoRenderer::get_AvgFrameRate( int *piAvgFrameRate)
{
    CheckPointer(piAvgFrameRate,E_POINTER);
    CAutoLock cVideoLock(&m_InterfaceLock);

    int t;
    if (m_bStreaming) {
	t = timeGetTime()-m_tStreamingStart;
    } else {
	t = m_tStreamingStart;
    }

    if (t<=0) {
	*piAvgFrameRate = 0;
	ASSERT(m_cFramesDrawn == 0);
    } else {
	// i is frames per hundred seconds
	*piAvgFrameRate = MulDiv(100000, m_cFramesDrawn, t);
    }
    return NOERROR;
} // get_AvgFrameRate


// Set *piAvg to the average sync offset since streaming started
// in mSec.  The sync offset is the time in mSec between when the frame
// should have been drawn and when the frame was actually drawn.

STDMETHODIMP CBaseVideoRenderer::get_AvgSyncOffset( int *piAvg)
{
    CheckPointer(piAvg,E_POINTER);
    CAutoLock cVideoLock(&m_InterfaceLock);

    if (NULL==m_pClock) {
	*piAvg = 0;
	return NOERROR;
    }

    // Note that we didn't gather the stats on the first frame
    // so we use m_cFramesDrawn-1 here
    if (m_cFramesDrawn<=1) {
	*piAvg = 0;
    } else {
	*piAvg = (int)(m_iTotAcc / (m_cFramesDrawn-1));
    }
    return NOERROR;
} // get_AvgSyncOffset


// To avoid dragging in the maths library - a cheap
// approximate integer square root.
// We do this by getting a starting guess which is between 1
// and 2 times too large, followed by THREE iterations of
// Newton Raphson.  (That will give accuracy to the nearest mSec
// for the range in question - roughly 0..1000)
//
// It would be faster to use a linear interpolation and ONE NR, but
// who cares.  If anyone does - the best linear interpolation is
// to approximates sqrt(x) by
// y = x * (sqrt(2)-1) + 1 - 1/sqrt(2) + 1/(8*(sqrt(2)-1))
// 0r y = x*0.41421 + 0.59467
// This minimises the maximal error in the range in question.
// (error is about +0.008883 and then one NR will give error .0000something
// (Of course these are integers, so you can't just multiply by 0.41421
// you'd have to do some sort of MulDiv).
// Anyone wanna check my maths?  (This is only for a property display!)

int isqrt(int x)
{
    int s = 1;
    // Make s an initial guess for sqrt(x)
    if (x > 0x40000000) {
       s = 0x8000;     // prevent any conceivable closed loop
    } else {
	while (s*s<x) {    // loop cannot possible go more than 31 times
	    s = 2*s;       // normally it goes about 6 times
	}
	// Three NR iterations.
	if (x==0) {
	   s= 0; // Wouldn't it be tragic to divide by zero whenever our
		 // accuracy was perfect!
	} else {
	    s = (s*s+x)/(2*s);
	    if (s>=0) s = (s*s+x)/(2*s);
	    if (s>=0) s = (s*s+x)/(2*s);
	}
    }
    return s;
}

//
//  Do estimates for standard deviations for per-frame
//  statistics
//
HRESULT CBaseVideoRenderer::GetStdDev(
    int nSamples,
    int *piResult,
    LONGLONG llSumSq,
    LONGLONG iTot
)
{
    CheckPointer(piResult,E_POINTER);
    CAutoLock cVideoLock(&m_InterfaceLock);

    if (NULL==m_pClock) {
	*piResult = 0;
	return NOERROR;
    }

    // If S is the Sum of the Squares of observations and
    //    T the Total (i.e. sum) of the observations and there were
    //    N observations, then an estimate of the standard deviation is
    //      sqrt( (S - T**2/N) / (N-1) )

    if (nSamples<=1) {
	*piResult = 0;
    } else {
	LONGLONG x;
	// First frames have bogus stamps, so we get no stats for them
	// So we need 2 frames to get 1 datum, so N is cFramesDrawn-1

	// so we use m_cFramesDrawn-1 here
	x = llSumSq - llMulDiv(iTot, iTot, nSamples, 0);
	x = x / (nSamples-1);
	ASSERT(x>=0);
	*piResult = isqrt((LONG)x);
    }
    return NOERROR;
}

// Set *piDev to the standard deviation in mSec of the sync offset
// of each frame since streaming started.

STDMETHODIMP CBaseVideoRenderer::get_DevSyncOffset( int *piDev)
{
    // First frames have bogus stamps, so we get no stats for them
    // So we need 2 frames to get 1 datum, so N is cFramesDrawn-1
    return GetStdDev(m_cFramesDrawn - 1,
		     piDev,
		     m_iSumSqAcc,
		     m_iTotAcc);
} // get_DevSyncOffset


// Set *piJitter to the standard deviation in mSec of the inter-frame time
// of frames since streaming started.

STDMETHODIMP CBaseVideoRenderer::get_Jitter( int *piJitter)
{
    // First frames have bogus stamps, so we get no stats for them
    // So second frame gives bogus inter-frame time
    // So we need 3 frames to get 1 datum, so N is cFramesDrawn-2
    return GetStdDev(m_cFramesDrawn - 2,
		     piJitter,
		     m_iSumSqFrameTime,
		     m_iSumFrameTime);
} // get_Jitter


// Overidden to return our IQualProp interface

STDMETHODIMP
CBaseVideoRenderer::NonDelegatingQueryInterface(REFIID riid,VOID **ppv)
{
    // We return IQualProp and delegate everything else

    if (riid == IID_IQualProp) {
	return GetInterface( (IQualProp *)this, ppv);
    } else if (riid == IID_IQualityControl) {
	return GetInterface( (IQualityControl *)this, ppv);
    }
    return CBaseRenderer::NonDelegatingQueryInterface(riid,ppv);
}


// Override JoinFilterGraph so that, just before leaving
// the graph we can send an EC_WINDOW_DESTROYED event

STDMETHODIMP
CBaseVideoRenderer::JoinFilterGraph(IFilterGraph *pGraph,LPCWSTR pName)
{
    // Since we send EC_ACTIVATE, we also need to ensure
    // we send EC_WINDOW_DESTROYED or the resource manager may be
    // holding us as a focus object
    if (!pGraph && m_pGraph) {

	// We were in a graph and now we're not
	// Do this properly in case we are aggregated
	IBaseFilter* pFilter;
	QueryInterface(IID_IBaseFilter,(void **) &pFilter);
	NotifyEvent(EC_WINDOW_DESTROYED, (LPARAM) pFilter, 0);
	pFilter->Release();
    }
    return CBaseFilter::JoinFilterGraph(pGraph, pName);
}


// This removes a large number of level 4 warnings from the
// Microsoft compiler which in this case are not very useful
#pragma warning(disable: 4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\seekpt.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
#ifndef __seekpt_h__
#define __seekpt_h__


class CSeekingPassThru : public ISeekingPassThru, public CUnknown
{
public:
    static CUnknown *CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);
    CSeekingPassThru(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr);
    ~CSeekingPassThru();

    DECLARE_IUNKNOWN;
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    STDMETHODIMP Init(BOOL bSupportRendering, IPin *pPin);

private:
    CPosPassThru              *m_pPosPassThru;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\schedule.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//  SCHEDULE.H

#ifndef __CAMSchedule__
#define __CAMSchedule__

class CAMSchedule : private CBaseObject
{
public:
    virtual ~CAMSchedule();
    // ev is the event we should fire if the advise time needs re-evaluating
    CAMSchedule( HANDLE ev );

    DWORD GetAdviseCount();
    REFERENCE_TIME GetNextAdviseTime();

    // We need a method for derived classes to add advise packets, we return the cookie
    DWORD_PTR AddAdvisePacket( const REFERENCE_TIME & time1, const REFERENCE_TIME & time2, HANDLE h, BOOL periodic );
    // And a way to cancel
    HRESULT Unadvise(DWORD_PTR dwAdviseCookie);

    // Tell us the time please, and we'll dispatch the expired events.  We return the time of the next event.
    // NB: The time returned will be "useless" if you start adding extra Advises.  But that's the problem of
    // whoever is using this helper class (typically a clock).
    REFERENCE_TIME Advise( const REFERENCE_TIME & rtTime );

    // Get the event handle which will be set if advise time requires re-evaluation.
    HANDLE GetEvent() const { return m_ev; }

private:
    // We define the nodes that will be used in our singly linked list
    // of advise packets.  The list is ordered by time, with the
    // elements that will expire first at the front.
    class CAdvisePacket
    {
    public:
        CAdvisePacket()
        {}

        CAdvisePacket * m_next;
        DWORD_PTR       m_dwAdviseCookie;
        REFERENCE_TIME  m_rtEventTime;      // Time at which event should be set
        REFERENCE_TIME  m_rtPeriod;         // Periodic time
        HANDLE          m_hNotify;          // Handle to event or semephore
        BOOL            m_bPeriodic;        // TRUE => Periodic event

        CAdvisePacket( CAdvisePacket * next, LONGLONG time ) : m_next(next), m_rtEventTime(time)
        {}

        void InsertAfter( CAdvisePacket * p )
        {
            p->m_next = m_next;
            m_next    = p;
        }

        int IsZ() const // That is, is it the node that represents the end of the list
        { return m_next == 0; }

        CAdvisePacket * RemoveNext()
        {
            CAdvisePacket *const next = m_next;
            CAdvisePacket *const new_next = next->m_next;
            m_next = new_next;
            return next;
        }

        void DeleteNext()
        {
            delete RemoveNext();
        }

        CAdvisePacket * Next() const
        {
            CAdvisePacket * result = m_next;
            if (result->IsZ()) result = 0;
            return result;
        }

        DWORD_PTR Cookie() const
        { return m_dwAdviseCookie; }
    };

    // Structure is:
    // head -> elmt1 -> elmt2 -> z -> null
    // So an empty list is:       head -> z -> null
    // Having head & z as links makes insertaion,
    // deletion and shunting much easier.
    CAdvisePacket   head, z;            // z is both a tail and a sentry

    volatile DWORD_PTR  m_dwNextCookie;     // Strictly increasing
    volatile DWORD  m_dwAdviseCount;    // Number of elements on list

    CCritSec        m_Serialize;

    // AddAdvisePacket: adds the packet, returns the cookie (0 if failed)
    DWORD_PTR AddAdvisePacket( CAdvisePacket * pPacket );
    // Event that we should set if the packed added above will be the next to fire.
    const HANDLE m_ev;

    // A Shunt is where we have changed the first element in the
    // list and want it re-evaluating (i.e. repositioned) in
    // the list.
    void ShuntHead();

    // Rather than delete advise packets, we cache them for future use
    CAdvisePacket * m_pAdviseCache;
    DWORD           m_dwCacheCount;
    enum { dwCacheMax = 5 };             // Don't bother caching more than five

    void Delete( CAdvisePacket * pLink );// This "Delete" will cache the Link

// Attributes and methods for debugging
public:
#ifdef DEBUG
    void DumpLinkedList();
#else
    void DumpLinkedList() {}
#endif

};

#endif // __CAMSchedule__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\renbase.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Generic ActiveX base renderer class, December 1995

#ifndef __RENBASE__
#define __RENBASE__

// Forward class declarations

class CBaseRenderer;
class CBaseVideoRenderer;
class CRendererInputPin;

// This is our input pin class that channels calls to the renderer

class CRendererInputPin : public CBaseInputPin
{
protected:

    CBaseRenderer *m_pRenderer;

public:

    CRendererInputPin(CBaseRenderer *pRenderer,
                      HRESULT *phr,
                      LPCWSTR Name);

    // Overriden from the base pin classes

    HRESULT BreakConnect();
    HRESULT CompleteConnect(IPin *pReceivePin);
    HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT Active();
    HRESULT Inactive();

    // Add rendering behaviour to interface functions

    STDMETHODIMP QueryId(LPWSTR *Id);
    STDMETHODIMP EndOfStream();
    STDMETHODIMP BeginFlush();
    STDMETHODIMP EndFlush();
    STDMETHODIMP Receive(IMediaSample *pMediaSample);

    // Helper
    IMemAllocator inline *Allocator() const
    {
        return m_pAllocator;
    }
};

// Main renderer class that handles synchronisation and state changes

class CBaseRenderer : public CBaseFilter
{
protected:

    friend class CRendererInputPin;

    friend void CALLBACK EndOfStreamTimer(UINT uID,      // Timer identifier
                                          UINT uMsg,     // Not currently used
                                          DWORD_PTR dwUser,  // User information
                                          DWORD_PTR dw1,     // Windows reserved
                                          DWORD_PTR dw2);    // Is also reserved

    CRendererPosPassThru *m_pPosition;  // Media seeking pass by object
    CAMEvent m_RenderEvent;             // Used to signal timer events
    CAMEvent m_ThreadSignal;            // Signalled to release worker thread
    CAMEvent m_evComplete;              // Signalled when state complete
    BOOL m_bAbort;                      // Stop us from rendering more data
    BOOL m_bStreaming;                  // Are we currently streaming
    DWORD_PTR m_dwAdvise;                   // Timer advise cookie
    IMediaSample *m_pMediaSample;       // Current image media sample
    BOOL m_bEOS;                        // Any more samples in the stream
    BOOL m_bEOSDelivered;               // Have we delivered an EC_COMPLETE
    CRendererInputPin *m_pInputPin;     // Our renderer input pin object
    CCritSec m_InterfaceLock;           // Critical section for interfaces
    CCritSec m_RendererLock;            // Controls access to internals
    IQualityControl * m_pQSink;         // QualityControl sink
    BOOL m_bRepaintStatus;              // Can we signal an EC_REPAINT
    //  Avoid some deadlocks by tracking filter during stop
    volatile BOOL  m_bInReceive;        // Inside Receive between PrepareReceive
                                        // And actually processing the sample
    REFERENCE_TIME m_SignalTime;        // Time when we signal EC_COMPLETE
    UINT m_EndOfStreamTimer;            // Used to signal end of stream

public:

    CBaseRenderer(REFCLSID RenderClass, // CLSID for this renderer
                  TCHAR *pName,         // Debug ONLY description
                  LPUNKNOWN pUnk,       // Aggregated owner object
                  HRESULT *phr);        // General OLE return code

    ~CBaseRenderer();

    // Overriden to say what interfaces we support and where

    virtual HRESULT GetMediaPositionInterface(REFIID riid,void **ppv);
    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);

    virtual HRESULT SourceThreadCanWait(BOOL bCanWait);

#ifdef DEBUG
    // Debug only dump of the renderer state
    void DisplayRendererState();
#endif
    virtual HRESULT WaitForRenderTime();
    virtual HRESULT CompleteStateChange(FILTER_STATE OldState);

    // Return internal information about this filter

    BOOL IsEndOfStream() { return m_bEOS; };
    BOOL IsEndOfStreamDelivered() { return m_bEOSDelivered; };
    BOOL IsStreaming() { return m_bStreaming; };
    void SetAbortSignal(BOOL bAbort) { m_bAbort = bAbort; };
    virtual void OnReceiveFirstSample(IMediaSample *pMediaSample) { };
    CAMEvent *GetRenderEvent() { return &m_RenderEvent; };

    // Permit access to the transition state

    void Ready() { m_evComplete.Set(); };
    void NotReady() { m_evComplete.Reset(); };
    BOOL CheckReady() { return m_evComplete.Check(); };

    virtual int GetPinCount();
    virtual CBasePin *GetPin(int n);
    FILTER_STATE GetRealState();
    void SendRepaint();
    void SendNotifyWindow(IPin *pPin,HWND hwnd);
    BOOL OnDisplayChange();
    void SetRepaintStatus(BOOL bRepaint);

    // Override the filter and pin interface functions

    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME StartTime);
    STDMETHODIMP GetState(DWORD dwMSecs,FILTER_STATE *State);
    STDMETHODIMP FindPin(LPCWSTR Id, IPin **ppPin);

    // These are available for a quality management implementation

    virtual void OnRenderStart(IMediaSample *pMediaSample);
    virtual void OnRenderEnd(IMediaSample *pMediaSample);
    virtual HRESULT OnStartStreaming() { return NOERROR; };
    virtual HRESULT OnStopStreaming() { return NOERROR; };
    virtual void OnWaitStart() { };
    virtual void OnWaitEnd() { };
    virtual void PrepareRender() { };

#ifdef PERF
    REFERENCE_TIME m_trRenderStart; // Just before we started drawing
                                    // Set in OnRenderStart, Used in OnRenderEnd
    int m_idBaseStamp;              // MSR_id for frame time stamp
    int m_idBaseRenderTime;         // MSR_id for true wait time
    int m_idBaseAccuracy;           // MSR_id for time frame is late (int)
#endif

    // Quality management implementation for scheduling rendering

    virtual BOOL ScheduleSample(IMediaSample *pMediaSample);
    virtual HRESULT GetSampleTimes(IMediaSample *pMediaSample,
                                   REFERENCE_TIME *pStartTime,
                                   REFERENCE_TIME *pEndTime);

    virtual HRESULT ShouldDrawSampleNow(IMediaSample *pMediaSample,
                                        REFERENCE_TIME *ptrStart,
                                        REFERENCE_TIME *ptrEnd);

    // Lots of end of stream complexities

    void TimerCallback();
    void ResetEndOfStreamTimer();
    HRESULT NotifyEndOfStream();
    virtual HRESULT SendEndOfStream();
    virtual HRESULT ResetEndOfStream();
    virtual HRESULT EndOfStream();

    // Rendering is based around the clock

    void SignalTimerFired();
    virtual HRESULT CancelNotification();
    virtual HRESULT ClearPendingSample();

    // Called when the filter changes state

    virtual HRESULT Active();
    virtual HRESULT Inactive();
    virtual HRESULT StartStreaming();
    virtual HRESULT StopStreaming();
    virtual HRESULT BeginFlush();
    virtual HRESULT EndFlush();

    // Deal with connections and type changes

    virtual HRESULT BreakConnect();
    virtual HRESULT SetMediaType(const CMediaType *pmt);
    virtual HRESULT CompleteConnect(IPin *pReceivePin);

    // These look after the handling of data samples

    virtual HRESULT PrepareReceive(IMediaSample *pMediaSample);
    virtual HRESULT Receive(IMediaSample *pMediaSample);
    virtual BOOL HaveCurrentSample();
    virtual IMediaSample *GetCurrentSample();
    virtual HRESULT Render(IMediaSample *pMediaSample);

    // Derived classes MUST override these
    virtual HRESULT DoRenderSample(IMediaSample *pMediaSample) PURE;
    virtual HRESULT CheckMediaType(const CMediaType *) PURE;

    // Helper
    void WaitForReceiveToComplete();
};


// CBaseVideoRenderer is a renderer class (see its ancestor class) and
// it handles scheduling of media samples so that they are drawn at the
// correct time by the reference clock.  It implements a degradation
// strategy.  Possible degradation modes are:
//    Drop frames here (only useful if the drawing takes significant time)
//    Signal supplier (upstream) to drop some frame(s) - i.e. one-off skip.
//    Signal supplier to change the frame rate - i.e. ongoing skipping.
//    Or any combination of the above.
// In order to determine what's useful to try we need to know what's going
// on.  This is done by timing various operations (including the supplier).
// This timing is done by using timeGetTime as it is accurate enough and
// usually cheaper than calling the reference clock.  It also tells the
// truth if there is an audio break and the reference clock stops.
// We provide a number of public entry points (named OnXxxStart, OnXxxEnd)
// which the rest of the renderer calls at significant moments.  These do
// the timing.

// the number of frames that the sliding averages are averaged over.
// the rule is (1024*NewObservation + (AVGPERIOD-1) * PreviousAverage)/AVGPERIOD
#define AVGPERIOD 4
#define DO_MOVING_AVG(avg,obs) (avg = (1024*obs + (AVGPERIOD-1)*avg)/AVGPERIOD)
// Spot the bug in this macro - I can't. but it doesn't work!

class CBaseVideoRenderer : public CBaseRenderer,    // Base renderer class
                           public IQualProp,        // Property page guff
                           public IQualityControl   // Allow throttling
{
protected:

    // Hungarian:
    //     tFoo is the time Foo in mSec (beware m_tStart from filter.h)
    //     trBar is the time Bar by the reference clock

    //******************************************************************
    // State variables to control synchronisation
    //******************************************************************

    // Control of sending Quality messages.  We need to know whether
    // we are in trouble (e.g. frames being dropped) and where the time
    // is being spent.

    // When we drop a frame we play the next one early.
    // The frame after that is likely to wait before drawing and counting this
    // wait as spare time is unfair, so we count it as a zero wait.
    // We therefore need to know whether we are playing frames early or not.

    int m_nNormal;                  // The number of consecutive frames
                                    // drawn at their normal time (not early)
                                    // -1 means we just dropped a frame.

#ifdef PERF
    BOOL m_bDrawLateFrames;         // Don't drop any frames (debug and I'm
                                    // not keen on people using it!)
#endif

    BOOL m_bSupplierHandlingQuality;// The response to Quality messages says
                                    // our supplier is handling things.
                                    // We will allow things to go extra late
                                    // before dropping frames.  We will play
                                    // very early after he has dropped one.

    // Control of scheduling, frame dropping etc.
    // We need to know where the time is being spent so as to tell whether
    // we should be taking action here, signalling supplier or what.
    // The variables are initialised to a mode of NOT dropping frames.
    // They will tell the truth after a few frames.
    // We typically record a start time for an event, later we get the time
    // again and subtract to get the elapsed time, and we average this over
    // a few frames.  The average is used to tell what mode we are in.

    // Although these are reference times (64 bit) they are all DIFFERENCES
    // between times which are small.  An int will go up to 214 secs before
    // overflow.  Avoiding 64 bit multiplications and divisions seems
    // worth while.



    // Audio-video throttling.  If the user has turned up audio quality
    // very high (in principle it could be any other stream, not just audio)
    // then we can receive cries for help via the graph manager.  In this case
    // we put in a wait for some time after rendering each frame.
    int m_trThrottle;

    // The time taken to render (i.e. BitBlt) frames controls which component
    // needs to degrade.  If the blt is expensive, the renderer degrades.
    // If the blt is cheap it's done anyway and the supplier degrades.
    int m_trRenderAvg;              // Time frames are taking to blt
    int m_trRenderLast;             // Time for last frame blt
    int m_tRenderStart;             // Just before we started drawing (mSec)
                                    // derived from timeGetTime.

    // When frames are dropped we will play the next frame as early as we can.
    // If it was a false alarm and the machine is fast we slide gently back to
    // normal timing.  To do this, we record the offset showing just how early
    // we really are.  This will normally be negative meaning early or zero.
    int m_trEarliness;

    // Target provides slow long-term feedback to try to reduce the
    // average sync offset to zero.  Whenever a frame is actually rendered
    // early we add a msec or two, whenever late we take off a few.
    // We add or take off 1/32 of the error time.
    // Eventually we should be hovering around zero.  For a really bad case
    // where we were (say) 300mSec off, it might take 100 odd frames to
    // settle down.  The rate of change of this is intended to be slower
    // than any other mechanism in Quartz, thereby avoiding hunting.
    int m_trTarget;

    // The proportion of time spent waiting for the right moment to blt
    // controls whether we bother to drop a frame or whether we reckon that
    // we're doing well enough that we can stand a one-frame glitch.
    int m_trWaitAvg;                // Average of last few wait times
                                    // (actually we just average how early
                                    // we were).  Negative here means LATE.

    // The average inter-frame time.
    // This is used to calculate the proportion of the time used by the
    // three operations (supplying us, waiting, rendering)
    int m_trFrameAvg;               // Average inter-frame time
    int m_trDuration;               // duration of last frame.

#ifdef PERF
    // Performance logging identifiers
    int m_idTimeStamp;              // MSR_id for frame time stamp
    int m_idEarliness;              // MSR_id for earliness fudge
    int m_idTarget;                 // MSR_id for Target fudge
    int m_idWaitReal;               // MSR_id for true wait time
    int m_idWait;                   // MSR_id for wait time recorded
    int m_idFrameAccuracy;          // MSR_id for time frame is late (int)
    int m_idRenderAvg;              // MSR_id for Render time recorded (int)
    int m_idSchLateTime;            // MSR_id for lateness at scheduler
    int m_idQualityRate;            // MSR_id for Quality rate requested
    int m_idQualityTime;            // MSR_id for Quality time requested
    int m_idDecision;               // MSR_id for decision code
    int m_idDuration;               // MSR_id for duration of a frame
    int m_idThrottle;               // MSR_id for audio-video throttling
    //int m_idDebug;                  // MSR_id for trace style debugging
    //int m_idSendQuality;          // MSR_id for timing the notifications per se
#endif // PERF
    REFERENCE_TIME m_trRememberStampForPerf;  // original time stamp of frame
                                              // with no earliness fudges etc.
#ifdef PERF
    REFERENCE_TIME m_trRememberFrameForPerf;  // time when previous frame rendered

    // debug...
    int m_idFrameAvg;
    int m_idWaitAvg;
#endif

    // PROPERTY PAGE
    // This has edit fields that show the user what's happening
    // These member variables hold these counts.

    int m_cFramesDropped;           // cumulative frames dropped IN THE RENDERER
    int m_cFramesDrawn;             // Frames since streaming started seen BY THE
                                    // RENDERER (some may be dropped upstream)

    // Next two support average sync offset and standard deviation of sync offset.
    LONGLONG m_iTotAcc;                  // Sum of accuracies in mSec
    LONGLONG m_iSumSqAcc;           // Sum of squares of (accuracies in mSec)

    // Next two allow jitter calculation.  Jitter is std deviation of frame time.
    REFERENCE_TIME m_trLastDraw;    // Time of prev frame (for inter-frame times)
    LONGLONG m_iSumSqFrameTime;     // Sum of squares of (inter-frame time in mSec)
    LONGLONG m_iSumFrameTime;            // Sum of inter-frame times in mSec

    // To get performance statistics on frame rate, jitter etc, we need
    // to record the lateness and inter-frame time.  What we actually need are the
    // data above (sum, sum of squares and number of entries for each) but the data
    // is generated just ahead of time and only later do we discover whether the
    // frame was actually drawn or not.  So we have to hang on to the data
    int m_trLate;                   // hold onto frame lateness
    int m_trFrame;                  // hold onto inter-frame time

    int m_tStreamingStart;          // if streaming then time streaming started
                                    // else time of last streaming session
                                    // used for property page statistics
#ifdef PERF
    LONGLONG m_llTimeOffset;        // timeGetTime()*10000+m_llTimeOffset==ref time
#endif

public:


    CBaseVideoRenderer(REFCLSID RenderClass, // CLSID for this renderer
                       TCHAR *pName,         // Debug ONLY description
                       LPUNKNOWN pUnk,       // Aggregated owner object
                       HRESULT *phr);        // General OLE return code

    ~CBaseVideoRenderer();

    // IQualityControl methods - Notify allows audio-video throttling

    STDMETHODIMP SetSink( IQualityControl * piqc);
    STDMETHODIMP Notify( IBaseFilter * pSelf, Quality q);

    // These provide a full video quality management implementation

    void OnRenderStart(IMediaSample *pMediaSample);
    void OnRenderEnd(IMediaSample *pMediaSample);
    void OnWaitStart();
    void OnWaitEnd();
    HRESULT OnStartStreaming();
    HRESULT OnStopStreaming();
    void ThrottleWait();

    // Handle the statistics gathering for our quality management

    void PreparePerformanceData(int trLate, int trFrame);
    virtual void RecordFrameLateness(int trLate, int trFrame);
    virtual void OnDirectRender(IMediaSample *pMediaSample);
    virtual HRESULT ResetStreamingTimes();
    BOOL ScheduleSample(IMediaSample *pMediaSample);
    HRESULT ShouldDrawSampleNow(IMediaSample *pMediaSample,
                                REFERENCE_TIME *ptrStart,
                                REFERENCE_TIME *ptrEnd);

    virtual HRESULT SendQuality(REFERENCE_TIME trLate, REFERENCE_TIME trRealStream);
    STDMETHODIMP JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName);

    //
    //  Do estimates for standard deviations for per-frame
    //  statistics
    //
    //  *piResult = (llSumSq - iTot * iTot / m_cFramesDrawn - 1) /
    //                            (m_cFramesDrawn - 2)
    //  or 0 if m_cFramesDrawn <= 3
    //
    HRESULT GetStdDev(
        int nSamples,
        int *piResult,
        LONGLONG llSumSq,
        LONGLONG iTot
    );
public:

    // IQualProp property page support

    STDMETHODIMP get_FramesDroppedInRenderer(int *cFramesDropped);
    STDMETHODIMP get_FramesDrawn(int *pcFramesDrawn);
    STDMETHODIMP get_AvgFrameRate(int *piAvgFrameRate);
    STDMETHODIMP get_Jitter(int *piJitter);
    STDMETHODIMP get_AvgSyncOffset(int *piAvg);
    STDMETHODIMP get_DevSyncOffset(int *piDev);

    // Implement an IUnknown interface and expose IQualProp

    DECLARE_IUNKNOWN
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,VOID **ppv);
};

#endif // __RENBASE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\streams.h ===
// a smaller version of streams.h from the quartz tree.

#ifndef _STREAMS_
#define _STREAMS_

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif
#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

// #defines from sdk/classes/base/streams.h
#define AM_NOVTABLE __declspec(novtable) 
#define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))

#include <strmif.h>
#include <control.h>
#include <uuids.h>
#include <vfwmsgs.h>

#include "wxdebug.h"
#include "combase.h"
#include "dllsetup.h"
#include "reftime.h"
#include "amvideo.h"
#include "wxutil.h"
#include "wxlist.h"
#include "msgthrd.h"
#include "mtype.h"
#include "schedule.h"
#include "refclock.h"
#include "amfilter.h"
#include "evcode.h"
#include "fourcc.h"
#include "ctlutil.h"
#include "renbase.h"

#endif // _STREAMS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\wxdebug.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// ActiveX system debugging facilities

#define _WINDLL

#include <streams.h>
#include <stdarg.h>
#include <stdio.h>

#ifdef DEBUG
#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE
#endif // _UNICODE
#endif // UNICODE
#endif // DEBUG

#include <tchar.h>

#ifdef DEBUG

const INT iDEBUGINFO = 512;                 // Used to format strings
const INT iMAXLEVELS = 5;                   // Maximum debug categories

HINSTANCE m_hInst;                          // Module instance handle
TCHAR m_ModuleName[iDEBUGINFO];             // Cut down module name
DWORD m_Levels[iMAXLEVELS];                 // Debug level per category
CRITICAL_SECTION m_CSDebug;                 // Controls access to list
DWORD m_dwNextCookie;                       // Next active object ID
ObjectDesc *pListHead = NULL;               // First active object
DWORD m_dwObjectCount;                      // Active object count
BOOL m_bInit = FALSE;                       // Have we been initialised
HANDLE m_hOutput = INVALID_HANDLE_VALUE;    // Optional output written here
DWORD dwWaitTimeout = INFINITE;             // Default timeout value
DWORD dwTimeOffset;			    // Time of first DbgLog call
bool g_fUseKASSERT = false;                 // don't create messagebox
bool g_fDbgInDllEntryPoint = false;

const TCHAR *pBaseKey = TEXT("SOFTWARE\\Debug");
const TCHAR *pGlobalKey = TEXT("GLOBAL");
static TCHAR *pUnknownName = TEXT("UNKNOWN");

/* For every module and executable we store a debugging level for each of
   the five categories (eg LOG_ERROR and LOG_TIMING). This makes it easy
   to isolate and debug individual modules without seeing everybody elses
   spurious debug output. The keys are stored in the registry under the
   HKEY_LOCAL_MACHINE\SOFTWARE\Debug\<Module Name>\<KeyName> key values
   NOTE these must be in the same order as their enumeration definition */

TCHAR *pKeyNames[] = {
    TEXT("TIMING"),      // Timing and performance measurements
    TEXT("TRACE"),       // General step point call tracing
    TEXT("MEMORY"),      // Memory and object allocation/destruction
    TEXT("LOCKING"),     // Locking/unlocking of critical sections
    TEXT("ERROR")        // Debug error notification
    };

TCHAR *TimeoutName = TEXT("TIMEOUT");

/* This sets the instance handle that the debug library uses to find
   the module's file name from the Win32 GetModuleFileName function */

void WINAPI DbgInitialise(HINSTANCE hInst)
{
    InitializeCriticalSection(&m_CSDebug);
    m_bInit = TRUE;

    m_hInst = hInst;
    DbgInitModuleName();
    if (GetProfileInt(m_ModuleName, TEXT("BreakOnLoad"), 0))
       DebugBreak();
    DbgInitModuleSettings();
    DbgInitGlobalSettings();
    dwTimeOffset = timeGetTime();
}


/* This is called to clear up any resources the debug library uses - at the
   moment we delete our critical section and the object list. The values we
   retrieve from the registry are all done during initialisation but we don't
   go looking for update notifications while we are running, if the values
   are changed then the application has to be restarted to pick them up */

void WINAPI DbgTerminate()
{
    if (m_hOutput != INVALID_HANDLE_VALUE) {
       EXECUTE_ASSERT(CloseHandle(m_hOutput));
       m_hOutput = INVALID_HANDLE_VALUE;
    }
    DeleteCriticalSection(&m_CSDebug);
    m_bInit = FALSE;
}


/* This is called by DbgInitLogLevels to read the debug settings
   for each logging category for this module from the registry */

void WINAPI DbgInitKeyLevels(HKEY hKey)
{
    LONG lReturn;               // Create key return value
    LONG lKeyPos;               // Current key category
    DWORD dwKeySize;            // Size of the key value
    DWORD dwKeyType;            // Receives it's type
    DWORD dwKeyValue;           // This fields value

    /* Try and read a value for each key position in turn */
    for (lKeyPos = 0;lKeyPos < iMAXLEVELS;lKeyPos++) {

        dwKeySize = sizeof(DWORD);
        lReturn = RegQueryValueEx(
            hKey,                       // Handle to an open key
            pKeyNames[lKeyPos],         // Subkey name derivation
            NULL,                       // Reserved field
            &dwKeyType,                 // Returns the field type
            (LPBYTE) &dwKeyValue,       // Returns the field's value
            &dwKeySize );               // Number of bytes transferred

        /* If either the key was not available or it was not a DWORD value
           then we ensure only the high priority debug logging is output
           but we try and update the field to a zero filled DWORD value */

        if (lReturn != ERROR_SUCCESS || dwKeyType != REG_DWORD)  {

            dwKeyValue = 0;
            lReturn = RegSetValueEx(
                hKey,                   // Handle of an open key
                pKeyNames[lKeyPos],     // Address of subkey name
                (DWORD) 0,              // Reserved field
                REG_DWORD,              // Type of the key field
                (PBYTE) &dwKeyValue,    // Value for the field
                sizeof(DWORD));         // Size of the field buffer

            if (lReturn != ERROR_SUCCESS) {
                DbgLog((LOG_ERROR,0,TEXT("Could not create subkey %s"),pKeyNames[lKeyPos]));
                dwKeyValue = 0;
            }
        }
        m_Levels[lKeyPos] = max(dwKeyValue,m_Levels[lKeyPos]);
    }

    /*  Read the timeout value for catching hangs */
    dwKeySize = sizeof(DWORD);
    lReturn = RegQueryValueEx(
        hKey,                       // Handle to an open key
        TimeoutName,                // Subkey name derivation
        NULL,                       // Reserved field
        &dwKeyType,                 // Returns the field type
        (LPBYTE) &dwWaitTimeout,    // Returns the field's value
        &dwKeySize );               // Number of bytes transferred

    /* If either the key was not available or it was not a DWORD value
       then we ensure only the high priority debug logging is output
       but we try and update the field to a zero filled DWORD value */

    if (lReturn != ERROR_SUCCESS || dwKeyType != REG_DWORD)  {

        dwWaitTimeout = INFINITE;
        lReturn = RegSetValueEx(
            hKey,                   // Handle of an open key
            TimeoutName,            // Address of subkey name
            (DWORD) 0,              // Reserved field
            REG_DWORD,              // Type of the key field
            (PBYTE) &dwWaitTimeout, // Value for the field
            sizeof(DWORD));         // Size of the field buffer

        if (lReturn != ERROR_SUCCESS) {
            DbgLog((LOG_ERROR,0,TEXT("Could not create subkey %s"),pKeyNames[lKeyPos]));
            dwWaitTimeout = INFINITE;
        }
    }
}

void WINAPI DbgOutString(LPCTSTR psz)
{
    if (m_hOutput != INVALID_HANDLE_VALUE) {
        UINT  cb = lstrlen(psz);
        DWORD dw;
        WriteFile (m_hOutput, psz, cb, &dw, NULL);
    } else {
        OutputDebugString (psz);
    }
}

/* Called by DbgInitGlobalSettings to setup alternate logging destinations
 */

void WINAPI DbgInitLogTo (
    HKEY hKey)
{
    LONG  lReturn;
    DWORD dwKeyType;
    DWORD dwKeySize;
    TCHAR szFile[MAX_PATH] = {0};
    static const TCHAR cszKey[] = TEXT("LogToFile");

    dwKeySize = MAX_PATH;
    lReturn = RegQueryValueEx(
        hKey,                       // Handle to an open key
        cszKey,                     // Subkey name derivation
        NULL,                       // Reserved field
        &dwKeyType,                 // Returns the field type
        (LPBYTE) szFile,            // Returns the field's value
        &dwKeySize);                // Number of bytes transferred

    // create an empty key if it does not already exist
    //
    if (lReturn != ERROR_SUCCESS || dwKeyType != REG_SZ)
       {
       dwKeySize = 1;
       lReturn = RegSetValueEx(
            hKey,                   // Handle of an open key
            cszKey,                 // Address of subkey name
            (DWORD) 0,              // Reserved field
            REG_SZ,                 // Type of the key field
            (PBYTE)szFile,          // Value for the field
            dwKeySize);            // Size of the field buffer
       }

    // if an output-to was specified.  try to open it.
    //
    if (m_hOutput != INVALID_HANDLE_VALUE) {
       EXECUTE_ASSERT(CloseHandle (m_hOutput));
       m_hOutput = INVALID_HANDLE_VALUE;
    }
    if (szFile[0] != 0)
       {
       if (!lstrcmpi(szFile, TEXT("Console"))) {
          m_hOutput = GetStdHandle (STD_OUTPUT_HANDLE);
          if (m_hOutput == INVALID_HANDLE_VALUE) {
             AllocConsole ();
             m_hOutput = GetStdHandle (STD_OUTPUT_HANDLE);
          }
          SetConsoleTitle (TEXT("ActiveX Debug Output"));
       } else if (szFile[0] &&
                lstrcmpi(szFile, TEXT("Debug")) &&
                lstrcmpi(szFile, TEXT("Debugger")) &&
                lstrcmpi(szFile, TEXT("Deb")))
          {
          m_hOutput = CreateFile(szFile, GENERIC_WRITE,
                                 FILE_SHARE_READ,
                                 NULL, OPEN_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL);
          if (INVALID_HANDLE_VALUE != m_hOutput)
              {
              static const TCHAR cszBar[] = TEXT("\r\n\r\n=====DbgInitialize()=====\r\n\r\n");
              SetFilePointer (m_hOutput, 0, NULL, FILE_END);
              DbgOutString (cszBar);
              }
          }
       }
}



/* This is called by DbgInitLogLevels to read the global debug settings for
   each logging category for this module from the registry. Normally each
   module has it's own values set for it's different debug categories but
   setting the global SOFTWARE\Debug\Global applies them to ALL modules */

void WINAPI DbgInitGlobalSettings()
{
    LONG lReturn;               // Create key return value
    TCHAR szInfo[iDEBUGINFO];   // Constructs key names
    HKEY hGlobalKey;            // Global override key

    /* Construct the global base key name */
    wsprintf(szInfo,TEXT("%s\\%s"),pBaseKey,pGlobalKey);

    /* Create or open the key for this module */
    lReturn = RegCreateKeyEx(HKEY_LOCAL_MACHINE,   // Handle of an open key
                             szInfo,               // Address of subkey name
                             (DWORD) 0,            // Reserved value
                             NULL,                 // Address of class name
                             (DWORD) 0,            // Special options flags
                             KEY_ALL_ACCESS,       // Desired security access
                             NULL,                 // Key security descriptor
                             &hGlobalKey,          // Opened handle buffer
                             NULL);                // What really happened

    if (lReturn != ERROR_SUCCESS) {
        DbgLog((LOG_ERROR,0,TEXT("Could not access GLOBAL module key")));
        return;
    }

    DbgInitKeyLevels(hGlobalKey);
    RegCloseKey(hGlobalKey);
}


/* This sets the debugging log levels for the different categories. We start
   by opening (or creating if not already available) the SOFTWARE\Debug key
   that all these settings live under. We then look at the global values
   set under SOFTWARE\Debug\Global which apply on top of the individual
   module settings. We then load the individual module registry settings */

void WINAPI DbgInitModuleSettings()
{
    LONG lReturn;               // Create key return value
    TCHAR szInfo[iDEBUGINFO];   // Constructs key names
    HKEY hModuleKey;            // Module key handle

    /* Construct the base key name */
    wsprintf(szInfo,TEXT("%s\\%s"),pBaseKey,m_ModuleName);

    /* Create or open the key for this module */
    lReturn = RegCreateKeyEx(HKEY_LOCAL_MACHINE,   // Handle of an open key
                             szInfo,               // Address of subkey name
                             (DWORD) 0,            // Reserved value
                             NULL,                 // Address of class name
                             (DWORD) 0,            // Special options flags
                             KEY_ALL_ACCESS,       // Desired security access
                             NULL,                 // Key security descriptor
                             &hModuleKey,          // Opened handle buffer
                             NULL);                // What really happened

    if (lReturn != ERROR_SUCCESS) {
        DbgLog((LOG_ERROR,0,TEXT("Could not access module key")));
        return;
    }

    DbgInitLogTo(hModuleKey);
    DbgInitKeyLevels(hModuleKey);
    RegCloseKey(hModuleKey);
}


/* Initialise the module file name */

void WINAPI DbgInitModuleName()
{
    TCHAR FullName[iDEBUGINFO];     // Load the full path and module name
    TCHAR *pName;                   // Searches from the end for a backslash

    GetModuleFileName(m_hInst,FullName,iDEBUGINFO);
    pName = _tcsrchr(FullName,'\\');
    if (pName == NULL) {
        pName = FullName;
    } else {
        pName++;
    }
    lstrcpy(m_ModuleName,pName);
}

struct MsgBoxMsg
{
    HWND hwnd;
    TCHAR *szTitle;
    TCHAR *szMessage;
    DWORD dwFlags;
    INT iResult;
};

//
// create a thread to call MessageBox(). calling MessageBox() on
// random threads at bad times can confuse the host (eg IE).
//
DWORD WINAPI MsgBoxThread(
  LPVOID lpParameter   // thread data
  )
{
    MsgBoxMsg *pmsg = (MsgBoxMsg *)lpParameter;
    pmsg->iResult = MessageBox(
        pmsg->hwnd,
        pmsg->szTitle,
        pmsg->szMessage,
        pmsg->dwFlags);
    
    return 0;
}

INT MessageBoxOtherThread(
    HWND hwnd,
    TCHAR *szTitle,
    TCHAR *szMessage,
    DWORD dwFlags)
{
    if(g_fDbgInDllEntryPoint)
    {
        // can't wait on another thread because we have the loader
        // lock held in the dll entry point.
        return MessageBox(hwnd, szTitle, szMessage, dwFlags);
    }
    else
    {
        MsgBoxMsg msg = {hwnd, szTitle, szMessage, dwFlags, 0};
        DWORD dwid;
        HANDLE hThread = CreateThread(
            0,                      // security
            0,                      // stack size
            MsgBoxThread,
            (void *)&msg,           // arg
            0,                      // flags
            &dwid);
        if(hThread)
        {
            WaitForSingleObject(hThread, INFINITE);
            CloseHandle(hThread);
            return msg.iResult;
        }

        // break into debugger on failure.
        return IDCANCEL;
    }
}


/* Displays a message box if the condition evaluated to FALSE */

void WINAPI DbgAssert(const TCHAR *pCondition,const TCHAR *pFileName,INT iLine)
{
    if(g_fUseKASSERT)
    {
        DbgKernelAssert(pCondition, pFileName, iLine);
    }
    else
    {

        TCHAR szInfo[iDEBUGINFO];

        wsprintf(szInfo, TEXT("%s \nAt line %d of %s\nContinue? (Cancel to debug)"),
                 pCondition, iLine, pFileName);

        INT MsgId = MessageBoxOtherThread(NULL,szInfo,TEXT("ASSERT Failed"),
                                          MB_SYSTEMMODAL |
                                          MB_ICONHAND |
                                          MB_YESNOCANCEL |
                                          MB_SETFOREGROUND);
        switch (MsgId)
        {
          case IDNO:              /* Kill the application */

              FatalAppExit(FALSE, TEXT("Application terminated"));
              break;

          case IDCANCEL:          /* Break into the debugger */

              DebugBreak();
              break;

          case IDYES:             /* Ignore assertion continue execution */
              break;
        }
    }
}

/* Displays a message box at a break point */

void WINAPI DbgBreakPoint(const TCHAR *pCondition,const TCHAR *pFileName,INT iLine)
{
    if(g_fUseKASSERT)
    {
        DbgKernelAssert(pCondition, pFileName, iLine);
    }
    else
    {
        TCHAR szInfo[iDEBUGINFO];

        wsprintf(szInfo, TEXT("%s \nAt line %d of %s\nContinue? (Cancel to debug)"),
                 pCondition, iLine, pFileName);

        INT MsgId = MessageBoxOtherThread(NULL,szInfo,TEXT("Hard coded break point"),
                                          MB_SYSTEMMODAL |
                                          MB_ICONHAND |
                                          MB_YESNOCANCEL |
                                          MB_SETFOREGROUND);
        switch (MsgId)
        {
          case IDNO:              /* Kill the application */

              FatalAppExit(FALSE, TEXT("Application terminated"));
              break;

          case IDCANCEL:          /* Break into the debugger */

              DebugBreak();
              break;

          case IDYES:             /* Ignore break point continue execution */
              break;
        }
    }
}


/* When we initialised the library we stored in the m_Levels array the current
   debug output level for this module for each of the five categories. When
   some debug logging is sent to us it can be sent with a combination of the
   categories (if it is applicable to many for example) in which case we map
   the type's categories into their current debug levels and see if any of
   them can be accepted. The function looks at each bit position in turn from
   the input type field and then compares it's debug level with the modules.

   A level of 0 means that output is always sent to the debugger.  This is
   due to producing output if the input level is <= m_Levels.
*/


BOOL WINAPI DbgCheckModuleLevel(DWORD Type,DWORD Level)
{
    DWORD Mask = 0x01;

    // If no valid bits are set return FALSE
    if ((Type & ((1<<iMAXLEVELS)-1))) {

	// speed up unconditional output.
	if (0==Level)
	    return(TRUE);
	
        for (LONG lKeyPos = 0;lKeyPos < iMAXLEVELS;lKeyPos++) {
            if (Type & Mask) {
                if (Level <= m_Levels[lKeyPos]) {
                    return TRUE;
                }
            }
            Mask <<= 1;
        }
    }
    return FALSE;
}


/* Set debug levels to a given value */

void WINAPI DbgSetModuleLevel(DWORD Type, DWORD Level)
{
    DWORD Mask = 0x01;

    for (LONG lKeyPos = 0;lKeyPos < iMAXLEVELS;lKeyPos++) {
        if (Type & Mask) {
            m_Levels[lKeyPos] = Level;
        }
        Mask <<= 1;
    }
}

/* Print a formatted string to the debugger prefixed with this module's name
   Because the COMBASE classes are linked statically every module loaded will
   have their own copy of this code. It therefore helps if the module name is
   included on the output so that the offending code can be easily found */

void WINAPI DbgLogInfo(DWORD Type,DWORD Level,const TCHAR *pFormat,...)
{
    /* Check the current level for this type combination */

    BOOL bAccept = DbgCheckModuleLevel(Type,Level);
    if (bAccept == FALSE) {
        return;
    }

    TCHAR szInfo[2000];

    /* Format the variable length parameter list */

    va_list va;
    va_start(va, pFormat);

    lstrcpy(szInfo,m_ModuleName);
    wsprintf(szInfo + lstrlen(szInfo),
             TEXT("(tid %x) %8d : "),
             GetCurrentThreadId(), timeGetTime() - dwTimeOffset);

    wvsprintf(szInfo + lstrlen(szInfo), pFormat, va);
    lstrcat(szInfo, TEXT("\r\n"));
    DbgOutString(szInfo);

    va_end(va);
}


/* If we are executing as a pure kernel filter we cannot display message
   boxes to the user, this provides an alternative which puts the error
   condition on the debugger output with a suitable eye catching message */

void WINAPI DbgKernelAssert(const TCHAR *pCondition,const TCHAR *pFileName,INT iLine)
{
    DbgLog((LOG_ERROR,0,TEXT("Assertion FAILED (%s) at line %d in file %s"),
           pCondition, iLine, pFileName));
    DebugBreak();
}



/* Each time we create an object derived from CBaseObject the constructor will
   call us to register the creation of the new object. We are passed a string
   description which we store away. We return a cookie that the constructor
   uses to identify the object when it is destroyed later on. We update the
   total number of active objects in the DLL mainly for debugging purposes */

DWORD WINAPI DbgRegisterObjectCreation(const TCHAR *pObjectName)
{
    /* If this fires you have a mixed DEBUG/RETAIL build */

    ASSERT(pObjectName);

    /* Create a place holder for this object description */

    ObjectDesc *pObject = new ObjectDesc;
    ASSERT(pObject);

    /* It is valid to pass a NULL object name */
    if (pObject == NULL) {
        return FALSE;
    }

    /* Check we have been initialised - we may not be initialised when we are
       being pulled in from an executable which has globally defined objects
       as they are created by the C++ run time before WinMain is called */

    if (m_bInit == FALSE) {
        DbgInitialise(GetModuleHandle(NULL));
    }

    /* Grab the list critical section */
    EnterCriticalSection(&m_CSDebug);

    /* If no name then default to UNKNOWN */
    if (pObjectName == NULL) {
        pObjectName = pUnknownName;
    }

    /* Put the new description at the head of the list */

    pObject->m_pName = pObjectName;
    pObject->m_dwCookie = ++m_dwNextCookie;
    pObject->m_pNext = pListHead;

    pListHead = pObject;
    m_dwObjectCount++;

    DWORD ObjectCookie = pObject->m_dwCookie;
    ASSERT(ObjectCookie);

    DbgLog((LOG_MEMORY,2,TEXT("Object created   %d (%s) %d Active"),
            pObject->m_dwCookie, pObjectName, m_dwObjectCount));

    LeaveCriticalSection(&m_CSDebug);
    return ObjectCookie;
}


/* This is called by the CBaseObject destructor when an object is about to be
   destroyed, we are passed the cookie we returned during construction that
   identifies this object. We scan the object list for a matching cookie and
   remove the object if successful. We also update the active object count */

BOOL WINAPI DbgRegisterObjectDestruction(DWORD dwCookie)
{
    /* Grab the list critical section */
    EnterCriticalSection(&m_CSDebug);

    ObjectDesc *pObject = pListHead;
    ObjectDesc *pPrevious = NULL;

    /* Scan the object list looking for a cookie match */

    while (pObject) {
        if (pObject->m_dwCookie == dwCookie) {
            break;
        }
        pPrevious = pObject;
        pObject = pObject->m_pNext;
    }

    if (pObject == NULL) {
        DbgBreak("Apparently destroying a bogus object");
        LeaveCriticalSection(&m_CSDebug);
        return FALSE;
    }

    /* Is the object at the head of the list */

    if (pPrevious == NULL) {
        pListHead = pObject->m_pNext;
    } else {
        pPrevious->m_pNext = pObject->m_pNext;
    }

    /* Delete the object and update the housekeeping information */

    m_dwObjectCount--;
    DbgLog((LOG_MEMORY,2,TEXT("Object destroyed %d (%s) %d Active"),
            pObject->m_dwCookie, pObject->m_pName, m_dwObjectCount));

    delete pObject;
    LeaveCriticalSection(&m_CSDebug);
    return TRUE;
}


/* This runs through the active object list displaying their details */

void WINAPI DbgDumpObjectRegister()
{
    TCHAR szInfo[iDEBUGINFO];

    /* Grab the list critical section */

    EnterCriticalSection(&m_CSDebug);
    ObjectDesc *pObject = pListHead;

    /* Scan the object list displaying the name and cookie */

    DbgLog((LOG_MEMORY,2,TEXT("")));
    DbgLog((LOG_MEMORY,2,TEXT("   ID             Object Description")));
    DbgLog((LOG_MEMORY,2,TEXT("")));

    while (pObject) {
        wsprintf(szInfo,TEXT("%5d (%8x) %30s"),pObject->m_dwCookie, &pObject, pObject->m_pName);
        DbgLog((LOG_MEMORY,2,szInfo));
        pObject = pObject->m_pNext;
    }

    wsprintf(szInfo,TEXT("Total object count %5d"),m_dwObjectCount);
    DbgLog((LOG_MEMORY,2,TEXT("")));
    DbgLog((LOG_MEMORY,1,szInfo));
    LeaveCriticalSection(&m_CSDebug);
}

/*  Debug infinite wait stuff */
DWORD WINAPI DbgWaitForSingleObject(HANDLE h)
{
    DWORD dwWaitResult;
    do {
        dwWaitResult = WaitForSingleObject(h, dwWaitTimeout);
        ASSERT(dwWaitResult == WAIT_OBJECT_0);
    } while (dwWaitResult == WAIT_TIMEOUT);
    return dwWaitResult;
}
DWORD WINAPI DbgWaitForMultipleObjects(DWORD nCount,
                                CONST HANDLE *lpHandles,
                                BOOL bWaitAll)
{
    DWORD dwWaitResult;
    do {
        dwWaitResult = WaitForMultipleObjects(nCount,
                                              lpHandles,
                                              bWaitAll,
                                              dwWaitTimeout);
        ASSERT((DWORD)(dwWaitResult - WAIT_OBJECT_0) < MAXIMUM_WAIT_OBJECTS);
    } while (dwWaitResult == WAIT_TIMEOUT);
    return dwWaitResult;
}

void WINAPI DbgSetWaitTimeout(DWORD dwTimeout)
{
    dwWaitTimeout = dwTimeout;
}

#endif /* DEBUG */

#ifdef _OBJBASE_H_

    /*  Stuff for printing out our GUID names */

    GUID_STRING_ENTRY g_GuidNames[] = {
    #define OUR_GUID_ENTRY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    { TEXT(#name), { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } } },
        #include <uuids.h>
    };

    CGuidNameList GuidNames;
    int g_cGuidNames = sizeof(g_GuidNames) / sizeof(g_GuidNames[0]);

    TCHAR *CGuidNameList::operator [] (const GUID &guid)
    {
        for (int i = 0; i < g_cGuidNames; i++) {
            if (g_GuidNames[i].guid == guid) {
                return g_GuidNames[i].szName;
            }
        }
        if (guid == GUID_NULL) {
            return TEXT("GUID_NULL");
        }

	// !!! add something to print FOURCC guids?
	
	// shouldn't this print the hex CLSID?
        return TEXT("Unknown GUID Name");
    }

#endif /* _OBJBASE_H_ */

/*  CDisp class - display our data types */

// clashes with REFERENCE_TIME
CDisp::CDisp(LONGLONG ll, int Format)
{
    // note: this could be combined with CDisp(LONGLONG) by
    // introducing a default format of CDISP_REFTIME
    LARGE_INTEGER li;
    li.QuadPart = ll;
    switch (Format) {
	case CDISP_DEC:
	{
	    TCHAR  temp[20];
	    int pos=20;
	    temp[--pos] = 0;
	    int digit;
	    // always output at least one digit
	    do {
		// Get the rightmost digit - we only need the low word
	        digit = li.LowPart % 10;
		li.QuadPart /= 10;
		temp[--pos] = (TCHAR) digit+L'0';
	    } while (li.QuadPart);
	    wsprintf(m_String, TEXT("%s"), temp+pos);
	    break;
	}
	case CDISP_HEX:
	default:
	    wsprintf(m_String, TEXT("0x%X%8.8X"), li.HighPart, li.LowPart);
    }
};

CDisp::CDisp(REFCLSID clsid)
{
    WCHAR strClass[CHARS_IN_GUID+1];
    StringFromGUID2(clsid, strClass, sizeof(strClass) / sizeof(strClass[0]));
    ASSERT(sizeof(m_String)/sizeof(m_String[0]) >= CHARS_IN_GUID+1);
    wsprintf(m_String, TEXT("%ls"), strClass);
};

#ifdef __STREAMS__
/*  Display stuff */
CDisp::CDisp(CRefTime llTime)
{
    LPTSTR lpsz = m_String;
    LONGLONG llDiv;
    if (llTime < 0) {
        llTime = -llTime;
        lpsz += wsprintf(lpsz, TEXT("-"));
    }
    llDiv = (LONGLONG)24 * 3600 * 10000000;
    if (llTime >= llDiv) {
        lpsz += wsprintf(lpsz, TEXT("%d days "), (LONG)(llTime / llDiv));
        llTime = llTime % llDiv;
    }
    llDiv = (LONGLONG)3600 * 10000000;
    if (llTime >= llDiv) {
        lpsz += wsprintf(lpsz, TEXT("%d hrs "), (LONG)(llTime / llDiv));
        llTime = llTime % llDiv;
    }
    llDiv = (LONGLONG)60 * 10000000;
    if (llTime >= llDiv) {
        lpsz += wsprintf(lpsz, TEXT("%d mins "), (LONG)(llTime / llDiv));
        llTime = llTime % llDiv;
    }
    wsprintf(lpsz, TEXT("%d.%3.3d sec"),
             (LONG)llTime / 10000000,
             (LONG)((llTime % 10000000) / 10000));
};

#endif // __STREAMS__


/*  Display pin */
CDisp::CDisp(IPin *pPin)
{
    PIN_INFO pi;
    TCHAR str[MAX_PIN_NAME];
    if (pPin) {
       pPin->QueryPinInfo(&pi);
       QueryPinInfoReleaseFilter(pi);
      #ifndef UNICODE
       WideCharToMultiByte(GetACP(), 0, pi.achName, lstrlenW(pi.achName) + 1,
                           str, MAX_PIN_NAME, NULL, NULL);
      #else
       lstrcpy(str, pi.achName);
      #endif
    } else {
       lstrcpy(str, TEXT("NULL IPin"));
    }

    m_pString = (PTCHAR) new TCHAR[lstrlen(str)+64];
    if (!m_pString) {
	return;
    }

    CLSID clsid;
    pi.pFilter->GetClassID(&clsid);
    wsprintf(m_pString, TEXT("%s(%s)"), GuidNames[clsid], str);
}

CDisp::~CDisp()
{
}

CDispBasic::~CDispBasic()
{
    if (m_pString != m_String) {
	delete [] m_pString;
    }
}

CDisp::CDisp(double d)
{
#ifdef DEBUG
    _stprintf(m_String, TEXT("%.16g"), d);
#else
    wsprintf(m_String, TEXT("%d.%03d"), (int) d, (int) ((d - (int) d) * 1000));
#endif
}


/* If built for debug this will display the media type details. We convert the
   major and subtypes into strings and also ask the base classes for a string
   description of the subtype, so MEDIASUBTYPE_RGB565 becomes RGB 565 16 bit
   We also display the fields in the BITMAPINFOHEADER structure, this should
   succeed as we do not accept input types unless the format is big enough */

#ifdef DEBUG
void WINAPI DisplayType(LPSTR label, const AM_MEDIA_TYPE *pmtIn)
{

    /* Dump the GUID types and a short description */

    DbgLog((LOG_TRACE,5,TEXT("")));
    DbgLog((LOG_TRACE,2,TEXT("%hs  M type %s  S type %s"), label,
	    GuidNames[pmtIn->majortype],
	    GuidNames[pmtIn->subtype]));
    DbgLog((LOG_TRACE,5,TEXT("Subtype description %s"),GetSubtypeName(&pmtIn->subtype)));

    /* Dump the generic media types */

    if (pmtIn->bTemporalCompression) {
	DbgLog((LOG_TRACE,5,TEXT("Temporally compressed")));
    } else {
	DbgLog((LOG_TRACE,5,TEXT("Not temporally compressed")));
    }

    if (pmtIn->bFixedSizeSamples) {
	DbgLog((LOG_TRACE,5,TEXT("Sample size %d"),pmtIn->lSampleSize));
    } else {
	DbgLog((LOG_TRACE,5,TEXT("Variable size samples")));
    }

    if (pmtIn->formattype == FORMAT_VideoInfo) {
	/* Dump the contents of the BITMAPINFOHEADER structure */
	BITMAPINFOHEADER *pbmi = HEADER(pmtIn->pbFormat);
	VIDEOINFOHEADER *pVideoInfo = (VIDEOINFOHEADER *)pmtIn->pbFormat;

	DbgLog((LOG_TRACE,5,TEXT("Source rectangle (Left %d Top %d Right %d Bottom %d)"),
	       pVideoInfo->rcSource.left,
	       pVideoInfo->rcSource.top,
	       pVideoInfo->rcSource.right,
	       pVideoInfo->rcSource.bottom));

	DbgLog((LOG_TRACE,5,TEXT("Target rectangle (Left %d Top %d Right %d Bottom %d)"),
	       pVideoInfo->rcTarget.left,
	       pVideoInfo->rcTarget.top,
	       pVideoInfo->rcTarget.right,
	       pVideoInfo->rcTarget.bottom));

	DbgLog((LOG_TRACE,5,TEXT("Size of BITMAPINFO structure %d"),pbmi->biSize));
	if (pbmi->biCompression < 256) {
	    DbgLog((LOG_TRACE,2,TEXT("%dx%dx%d bit  (%d)"),
		    pbmi->biWidth, pbmi->biHeight,
		    pbmi->biBitCount, pbmi->biCompression));
	} else {
	    DbgLog((LOG_TRACE,2,TEXT("%dx%dx%d bit '%4.4hs'"),
		    pbmi->biWidth, pbmi->biHeight,
		    pbmi->biBitCount, &pbmi->biCompression));
	}

	DbgLog((LOG_TRACE,2,TEXT("Image size %d"),pbmi->biSizeImage));
	DbgLog((LOG_TRACE,5,TEXT("Planes %d"),pbmi->biPlanes));
	DbgLog((LOG_TRACE,5,TEXT("X Pels per metre %d"),pbmi->biXPelsPerMeter));
	DbgLog((LOG_TRACE,5,TEXT("Y Pels per metre %d"),pbmi->biYPelsPerMeter));
	DbgLog((LOG_TRACE,5,TEXT("Colours used %d"),pbmi->biClrUsed));

    } else if (pmtIn->majortype == MEDIATYPE_Audio) {
	DbgLog((LOG_TRACE,2,TEXT("     Format type %s"),
	    GuidNames[pmtIn->formattype]));
	DbgLog((LOG_TRACE,2,TEXT("     Subtype %s"),
	    GuidNames[pmtIn->subtype]));

	if ((pmtIn->subtype != MEDIASUBTYPE_MPEG1Packet)
	  && (pmtIn->cbFormat >= sizeof(PCMWAVEFORMAT)))
	{
	    /* Dump the contents of the WAVEFORMATEX type-specific format structure */

	    WAVEFORMATEX *pwfx = (WAVEFORMATEX *) pmtIn->pbFormat;
            DbgLog((LOG_TRACE,2,TEXT("wFormatTag %u"), pwfx->wFormatTag));
            DbgLog((LOG_TRACE,2,TEXT("nChannels %u"), pwfx->nChannels));
            DbgLog((LOG_TRACE,2,TEXT("nSamplesPerSec %lu"), pwfx->nSamplesPerSec));
            DbgLog((LOG_TRACE,2,TEXT("nAvgBytesPerSec %lu"), pwfx->nAvgBytesPerSec));
            DbgLog((LOG_TRACE,2,TEXT("nBlockAlign %u"), pwfx->nBlockAlign));
            DbgLog((LOG_TRACE,2,TEXT("wBitsPerSample %u"), pwfx->wBitsPerSample));

            /* PCM uses a WAVEFORMAT and does not have the extra size field */

            if (pmtIn->cbFormat >= sizeof(WAVEFORMATEX)) {
                DbgLog((LOG_TRACE,2,TEXT("cbSize %u"), pwfx->cbSize));
            }
	} else {
	}

    } else {
	DbgLog((LOG_TRACE,2,TEXT("     Format type %s"),
	    GuidNames[pmtIn->formattype]));
	// !!!! should add code to dump wave format, others
    }
}


void WINAPI DumpGraph(IFilterGraph *pGraph, DWORD dwLevel)
{
    IEnumFilters *pFilters;

    DbgLog((LOG_TRACE,dwLevel,TEXT("DumpGraph [%x]"), pGraph));

    if (FAILED(pGraph->EnumFilters(&pFilters))) {
	DbgLog((LOG_TRACE,dwLevel,TEXT("EnumFilters failed!")));
    }

    IBaseFilter *pFilter;
    ULONG	n;
    while (pFilters->Next(1, &pFilter, &n) == S_OK) {
	FILTER_INFO	info;

	if (FAILED(pFilter->QueryFilterInfo(&info))) {
	    DbgLog((LOG_TRACE,dwLevel,TEXT("    Filter [%x]  -- failed QueryFilterInfo"), pFilter));
	} else {
	    QueryFilterInfoReleaseGraph(info);

	    // !!! should QueryVendorInfo here!
	
	    DbgLog((LOG_TRACE,dwLevel,TEXT("    Filter [%x]  '%ls'"), pFilter, info.achName));

	    IEnumPins *pins;

	    if (FAILED(pFilter->EnumPins(&pins))) {
		DbgLog((LOG_TRACE,dwLevel,TEXT("EnumPins failed!")));
	    } else {

		IPin *pPin;
		while (pins->Next(1, &pPin, &n) == S_OK) {
		    PIN_INFO	info;

		    if (FAILED(pPin->QueryPinInfo(&info))) {
			DbgLog((LOG_TRACE,dwLevel,TEXT("          Pin [%x]  -- failed QueryPinInfo"), pPin));
		    } else {
			QueryPinInfoReleaseFilter(info);

			IPin *pPinConnected = NULL;

			HRESULT hr = pPin->ConnectedTo(&pPinConnected);

			if (pPinConnected) {
			    DbgLog((LOG_TRACE,dwLevel,TEXT("          Pin [%x]  '%ls' [%sput]")
							   TEXT("  Connected to pin [%x]"),
				    pPin, info.achName,
				    info.dir == PINDIR_INPUT ? TEXT("In") : TEXT("Out"),
				    pPinConnected));

			    pPinConnected->Release();

			    // perhaps we should really dump the type both ways as a sanity
			    // check?
			    if (info.dir == PINDIR_OUTPUT) {
				AM_MEDIA_TYPE mt;

				hr = pPin->ConnectionMediaType(&mt);

				if (SUCCEEDED(hr)) {
				    DisplayType("Connection type", &mt);

				    FreeMediaType(mt);
				}
			    }
			} else {
			    DbgLog((LOG_TRACE,dwLevel,
				    TEXT("          Pin [%x]  '%ls' [%sput]"),
				    pPin, info.achName,
				    info.dir == PINDIR_INPUT ? TEXT("In") : TEXT("Out")));

			}
		    }

		    pPin->Release();

		}

		pins->Release();
	    }

	}
	
	pFilter->Release();
    }

    pFilters->Release();

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\uuids.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// contains the GUIDs for the MediaType type, subtype fields and format types
// for standard media types, and also class ids for well-known components.


//
//  We want to use this list for generating strings for debugging too
//  so we redefine OUR_GUID_ENTRY depending on what we want to do
//
//  It is imperative that all entries in this file are declared using
//  OUR_GUID_ENTRY as that macro might have been defined in advance of
//  including this file.  See wxdebug.cpp in sdk\classes\base.
//

#ifndef OUR_GUID_ENTRY
	#define OUR_GUID_ENTRY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
	DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8);
#endif


// -- to allow consistent labeling of Media types and subtypes --

#define MEDIATYPE_NULL       GUID_NULL
#define MEDIASUBTYPE_NULL    GUID_NULL

// -- Use this subtype if you don't have a use for a subtype for your type
// e436eb8e-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_None
OUR_GUID_ENTRY(MEDIASUBTYPE_None,
0xe436eb8e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)


// -- major types ---


// 73646976-0000-0010-8000-00AA00389B71  'vids' == MEDIATYPE_Video
OUR_GUID_ENTRY(MEDIATYPE_Video,
0x73646976, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 73647561-0000-0010-8000-00AA00389B71  'auds' == MEDIATYPE_Audio
OUR_GUID_ENTRY(MEDIATYPE_Audio,
0x73647561, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 73747874-0000-0010-8000-00AA00389B71  'txts' == MEDIATYPE_Text
OUR_GUID_ENTRY(MEDIATYPE_Text,
0x73747874, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 7364696D-0000-0010-8000-00AA00389B71  'mids' == MEDIATYPE_Midi
OUR_GUID_ENTRY(MEDIATYPE_Midi,
0x7364696D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// e436eb83-524f-11ce-9f53-0020af0ba770            MEDIATYPE_Stream
OUR_GUID_ENTRY(MEDIATYPE_Stream,
0xe436eb83, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 73(s)76(v)61(a)69(i)-0000-0010-8000-00AA00389B71  'iavs' == MEDIATYPE_Interleaved
OUR_GUID_ENTRY(MEDIATYPE_Interleaved,
0x73766169, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 656c6966-0000-0010-8000-00AA00389B71  'file' == MEDIATYPE_File
OUR_GUID_ENTRY(MEDIATYPE_File,
0x656c6966, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 73636d64-0000-0010-8000-00AA00389B71  'scmd' == MEDIATYPE_ScriptCommand
OUR_GUID_ENTRY(MEDIATYPE_ScriptCommand,
0x73636d64, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 670AEA80-3A82-11d0-B79B-00AA003767A7            MEDIATYPE_AUXLine21Data
OUR_GUID_ENTRY(MEDIATYPE_AUXLine21Data,
0x670aea80, 0x3a82, 0x11d0, 0xb7, 0x9b, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// 0482DEE3-7817-11cf-8a03-00aa006ecb65
OUR_GUID_ENTRY(MEDIATYPE_Timecode,
0x482dee3, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 74726c6d-0000-0010-8000-00AA00389B71  'lmrt' == MEDIATYPE_LMRT
OUR_GUID_ENTRY(MEDIATYPE_LMRT,
0x74726c6d, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 74726c6d-0000-0010-8000-00AA00389B71  'urls' == MEDIATYPE_URL_STREAM
OUR_GUID_ENTRY(MEDIATYPE_URL_STREAM,
0x736c7275, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// -- sub types ---


// 39555659-0000-0010-8000-00AA00389B71  'YVU9' == MEDIASUBTYPE_YVU9
OUR_GUID_ENTRY(MEDIASUBTYPE_YVU9,
0x39555659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31313459-0000-0010-8000-00AA00389B71  'Y411' == MEDIASUBTYPE_Y411
OUR_GUID_ENTRY(MEDIASUBTYPE_Y411,
0x31313459, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 50313459-0000-0010-8000-00AA00389B71  'Y41P' == MEDIASUBTYPE_Y41P
OUR_GUID_ENTRY(MEDIASUBTYPE_Y41P,
0x50313459, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 32595559-0000-0010-8000-00AA00389B71  'YUY2' == MEDIASUBTYPE_YUY2
OUR_GUID_ENTRY(MEDIASUBTYPE_YUY2,
0x32595559, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 55595659-0000-0010-8000-00AA00389B71  'YVYU' == MEDIASUBTYPE_YVYU
OUR_GUID_ENTRY(MEDIASUBTYPE_YVYU,
0x55595659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 59565955-0000-0010-8000-00AA00389B71  'UYVY' ==  MEDIASUBTYPE_UYVY
OUR_GUID_ENTRY(MEDIASUBTYPE_UYVY,
0x59565955, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31313259-0000-0010-8000-00AA00389B71  'Y211' ==  MEDIASUBTYPE_Y211
OUR_GUID_ENTRY(MEDIASUBTYPE_Y211,
0x31313259, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31313259-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_YV12
OUR_GUID_ENTRY(MEDIASUBTYPE_YV12,
0x32315659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 524a4c43-0000-0010-8000-00AA00389B71  'CLJR' ==  MEDIASUBTYPE_CLJR
OUR_GUID_ENTRY(MEDIASUBTYPE_CLJR,
0x524a4c43, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 39304649-0000-0010-8000-00AA00389B71  'IF09' ==  MEDIASUBTYPE_IF09
OUR_GUID_ENTRY(MEDIASUBTYPE_IF09,
0x39304649, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 414c5043-0000-0010-8000-00AA00389B71  'CPLA' ==  MEDIASUBTYPE_CPLA
OUR_GUID_ENTRY(MEDIASUBTYPE_CPLA,
0x414c5043, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 47504A4D-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_MJPG
OUR_GUID_ENTRY(MEDIASUBTYPE_MJPG,
0x47504A4D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 4A4D5654-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_TVMJ
OUR_GUID_ENTRY(MEDIASUBTYPE_TVMJ,
0x4A4D5654, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 454B4157-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_WAKE
OUR_GUID_ENTRY(MEDIASUBTYPE_WAKE,
0x454B4157, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 43434643-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_CFCC
OUR_GUID_ENTRY(MEDIASUBTYPE_CFCC,
0x43434643, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 47504A49-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_IJPG
OUR_GUID_ENTRY(MEDIASUBTYPE_IJPG,
0x47504A49, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6D756C50-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_Plum
OUR_GUID_ENTRY(MEDIASUBTYPE_Plum,
0x6D756C50, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// FAST DV-Master
// 53435644-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_DVCS
OUR_GUID_ENTRY(MEDIASUBTYPE_DVCS,
0x53435644, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// FAST DV-Master
// 44535644-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_DVSD
OUR_GUID_ENTRY(MEDIASUBTYPE_DVSD,
0x44535644, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// MIROVideo DV
// 4656444D-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_MDVF
OUR_GUID_ENTRY(MEDIASUBTYPE_MDVF,
0x4656444D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// e436eb78-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB1
// e436eb78-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB1
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB1,
0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb79-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB4
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB4,
0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7a-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB8
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB8,
0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7b-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB565
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB565,
0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7c-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB555
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB555,
0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7d-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB24
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB24,
0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7e-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB32
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB32,
0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7f-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_Overlay
OUR_GUID_ENTRY(MEDIASUBTYPE_Overlay,
0xe436eb7f, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb80-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEGPacket
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Packet,
0xe436eb80, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb81-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1Payload
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Payload,
0xe436eb81, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 00000050-0000-0010-8000-00AA00389B71		MEDIASUBTYPE_MPEG1AudioPayload
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1AudioPayload,
0x00000050, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71)

// e436eb82-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1SystemStream
OUR_GUID_ENTRY(MEDIATYPE_MPEG1SystemStream,
0xe436eb82, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// the next consecutive number is assigned to MEDIATYPE_Stream and appears higher up
// e436eb84-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1System
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1System,
0xe436eb84, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb85-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1VideoCD
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1VideoCD,
0xe436eb85, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb86-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1Video
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Video,
0xe436eb86, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb87-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1Audio
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Audio,
0xe436eb87, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb88-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_Avi
OUR_GUID_ENTRY(MEDIASUBTYPE_Avi,
0xe436eb88, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {3DB80F90-9412-11d1-ADED-0000F8754B99}          MEDIASUBTYPE_Asf
OUR_GUID_ENTRY(MEDIASUBTYPE_Asf,
0x3db80f90, 0x9412, 0x11d1, 0xad, 0xed, 0x0, 0x0, 0xf8, 0x75, 0x4b, 0x99)

// e436eb89-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_QTMovie
OUR_GUID_ENTRY(MEDIASUBTYPE_QTMovie,
0xe436eb89, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 617a7072-0000-0010-8000-00AA00389B71         MEDIASUBTYPE_Rpza
OUR_GUID_ENTRY(MEDIASUBTYPE_QTRpza,
0x617a7072, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 20636d73-0000-0010-8000-00AA00389B71         MEDIASUBTYPE_Smc
OUR_GUID_ENTRY(MEDIASUBTYPE_QTSmc,
0x20636d73, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 20656c72-0000-0010-8000-00AA00389B71        MEDIASUBTYPE_Rle
OUR_GUID_ENTRY(MEDIASUBTYPE_QTRle,
0x20656c72, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6765706a-0000-0010-8000-00AA00389B71        MEDIASUBTYPE_Jpeg
OUR_GUID_ENTRY(MEDIASUBTYPE_QTJpeg,
0x6765706a, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// e436eb8a-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_PCMAudio_Obsolete
OUR_GUID_ENTRY(MEDIASUBTYPE_PCMAudio_Obsolete,
0xe436eb8a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 00000001-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_PCM
OUR_GUID_ENTRY(MEDIASUBTYPE_PCM,
0x00000001, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71)

// e436eb8b-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_WAVE
OUR_GUID_ENTRY(MEDIASUBTYPE_WAVE,
0xe436eb8b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb8c-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_AU
OUR_GUID_ENTRY(MEDIASUBTYPE_AU,
0xe436eb8c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb8d-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_AIFF
OUR_GUID_ENTRY(MEDIASUBTYPE_AIFF,
0xe436eb8d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 64(d)73(s)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvsd' == MEDIASUBTYPE_dvsd
OUR_GUID_ENTRY(MEDIASUBTYPE_dvsd,
0x64737664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 64(d)68(h)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvhd' == MEDIASUBTYPE_dvhd
OUR_GUID_ENTRY(MEDIASUBTYPE_dvhd,
0x64687664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6c(l)73(s)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvsl' == MEDIASUBTYPE_dvsl
OUR_GUID_ENTRY(MEDIASUBTYPE_dvsl,
0x6c737664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)
									
// 6E8D4A22-310C-11d0-B79A-00AA003767A7         MEDIASUBTYPE_Line21_BytePair
OUR_GUID_ENTRY(MEDIASUBTYPE_Line21_BytePair,
0x6e8d4a22, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// 6E8D4A23-310C-11d0-B79A-00AA003767A7         MEDIASUBTYPE_Line21_GOPPacket
OUR_GUID_ENTRY(MEDIASUBTYPE_Line21_GOPPacket,
0x6e8d4a23, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// 6E8D4A24-310C-11d0-B79A-00AA003767A7         MEDIASUBTYPE_Line21_VBIRawData
OUR_GUID_ENTRY(MEDIASUBTYPE_Line21_VBIRawData,
0x6e8d4a24, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// DirectShow DSS definitions

// A0AF4F81-E163-11d0-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_DssVideo,
0xa0af4f81, 0xe163, 0x11d0, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// A0AF4F82-E163-11d0-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_DssAudio,
0xa0af4f82, 0xe163, 0x11d0, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// 5A9B6A40-1A22-11D1-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_VPVideo,
0x5a9b6a40, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// 5A9B6A41-1A22-11D1-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_VPVBI,
0x5a9b6a41, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// --- class IDs ---


OUR_GUID_ENTRY(IID_IAMCutListElement,
0xCDE29520,0x3418,0x11CF,0xA5,0xB0,0x00,0x20,0xAF,0x05,0x3D,0x8F)

OUR_GUID_ENTRY(IID_IAMFileCutListElement,
0xF0947070,0x276C,0x11d0,0x83,0x16,0x00,0x20,0xAF,0x11,0xC0,0x10)

OUR_GUID_ENTRY(IID_IAMVideoCutListElement,
0xCDE29522,0x3418,0x11CF,0xA5,0xB0,0x00,0x20,0xAF,0x05,0x3D,0x8F)

OUR_GUID_ENTRY(IID_IAMAudioCutListElement,
0xCDE29524,0x3418,0x11CF,0xA5,0xB0,0x00,0x20,0xAF,0x05,0x3D,0x8F)

// the cutlist source filter
OUR_GUID_ENTRY(CLSID_CutListSource, 
0xa5ea8d20, 0x253d, 0x11d1, 0xb3, 0xf1, 0x00, 0xaa, 0x00, 0x37, 0x61, 0xc5)

OUR_GUID_ENTRY(IID_IStandardCutList,
0xa5ea8d29, 0x253d, 0x11d1, 0xb3, 0xf1, 0x00, 0xaa, 0x00, 0x37, 0x61, 0xc5)

OUR_GUID_ENTRY(IID_IFileClip,
0xa5ea8d2a, 0x253d, 0x11d1, 0xb3, 0xf1, 0x00, 0xaa, 0x00, 0x37, 0x61, 0xc5)

OUR_GUID_ENTRY(IID_ICutListGraphBuilder,
0xa5ea8d2c, 0x253d, 0x11d1, 0xb3, 0xf1, 0x00, 0xaa, 0x00, 0x37, 0x61, 0xc5)

OUR_GUID_ENTRY(CLSID_CutListGraphBuilder, 
0xa5ea8d2f, 0x253d, 0x11d1, 0xb3, 0xf1, 0x00, 0xaa, 0x00, 0x37, 0x61, 0xc5)

OUR_GUID_ENTRY(CLSID_SimpleCutList, 
0xa5ea8d30, 0x253d, 0x11d1, 0xb3, 0xf1, 0x00, 0xaa, 0x00, 0x37, 0x61, 0xc5)

OUR_GUID_ENTRY(CLSID_VideoFileClip, 
0xa5ea8d31, 0x253d, 0x11d1, 0xb3, 0xf1, 0x00, 0xaa, 0x00, 0x37, 0x61, 0xc5)

OUR_GUID_ENTRY(CLSID_AudioFileClip, 
0xa5ea8d32, 0x253d, 0x11d1, 0xb3, 0xf1, 0x00, 0xaa, 0x00, 0x37, 0x61, 0xc5)

OUR_GUID_ENTRY(CLSID_CutListCacheMemory, 
0xa5ea8d33, 0x253d, 0x11d1, 0xb3, 0xf1, 0x00, 0xaa, 0x00, 0x37, 0x61, 0xc5)

// end cut list stuff


// BF87B6E0-8C27-11d0-B3F0-00AA003761C5     Capture graph building
OUR_GUID_ENTRY(CLSID_CaptureGraphBuilder,
0xBF87B6E0, 0x8C27, 0x11d0, 0xB3, 0xF0, 0x0, 0xAA, 0x00, 0x37, 0x61, 0xC5)

// e436ebb0-524f-11ce-9f53-0020af0ba770            Prototype filtergraph
OUR_GUID_ENTRY(CLSID_ProtoFilterGraph,
0xe436ebb0, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb1-524f-11ce-9f53-0020af0ba770            Reference clock
OUR_GUID_ENTRY(CLSID_SystemClock,
0xe436ebb1, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb2-524f-11ce-9f53-0020af0ba770           Filter Mapper
OUR_GUID_ENTRY(CLSID_FilterMapper,
0xe436ebb2, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb3-524f-11ce-9f53-0020af0ba770           Filter Graph
OUR_GUID_ENTRY(CLSID_FilterGraph,
0xe436ebb3, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb8-524f-11ce-9f53-0020af0ba770           Filter Graph no thread
OUR_GUID_ENTRY(CLSID_FilterGraphNoThread,
0xe436ebb8, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e4bbd160-4269-11ce-838d-00aa0055595a           MPEG System stream
OUR_GUID_ENTRY(CLSID_MPEG1Doc,
0xe4bbd160, 0x4269, 0x11ce, 0x83, 0x8d, 0x0, 0xaa, 0x0, 0x55, 0x59, 0x5a)

// 701722e0-8ae3-11ce-a85c-00aa002feab5           MPEG file reader
OUR_GUID_ENTRY(CLSID_FileSource,
0x701722e0, 0x8ae3, 0x11ce, 0xa8, 0x5c, 0x00, 0xaa, 0x00, 0x2f, 0xea, 0xb5)

// 26C25940-4CA9-11ce-A828-00AA002FEAB5           Takes MPEG1 packets as input
OUR_GUID_ENTRY(CLSID_MPEG1PacketPlayer,
0x26c25940, 0x4ca9, 0x11ce, 0xa8, 0x28, 0x0, 0xaa, 0x0, 0x2f, 0xea, 0xb5)

// 336475d0-942a-11ce-a870-00aa002feab5           MPEG splitter
OUR_GUID_ENTRY(CLSID_MPEG1Splitter,
0x336475d0, 0x942a, 0x11ce, 0xa8, 0x70, 0x00, 0xaa, 0x00, 0x2f, 0xea, 0xb5)

// feb50740-7bef-11ce-9bd9-0000e202599c           MPEG video decoder
OUR_GUID_ENTRY(CLSID_CMpegVideoCodec,
0xfeb50740, 0x7bef, 0x11ce, 0x9b, 0xd9, 0x0, 0x0, 0xe2, 0x2, 0x59, 0x9c)

// 4a2286e0-7bef-11ce-9bd9-0000e202599c           MPEG audio decoder
OUR_GUID_ENTRY(CLSID_CMpegAudioCodec,
0x4a2286e0, 0x7bef, 0x11ce, 0x9b, 0xd9, 0x0, 0x0, 0xe2, 0x2, 0x59, 0x9c)

// e30629d3-27e5-11ce-875d-00608cb78066           Text renderer
OUR_GUID_ENTRY(CLSID_TextRender,
0xe30629d3, 0x27e5, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)



// {F8388A40-D5BB-11d0-BE5A-0080C706568E}
OUR_GUID_ENTRY(CLSID_InfTee,
0xf8388a40, 0xd5bb, 0x11d0, 0xbe, 0x5a, 0x0, 0x80, 0xc7, 0x6, 0x56, 0x8e)

// 1b544c20-fd0b-11ce-8c63-00aa0044b51e           Avi Stream Splitter
OUR_GUID_ENTRY(CLSID_AviSplitter,
0x1b544c20, 0xfd0b, 0x11ce, 0x8c, 0x63, 0x0, 0xaa, 0x00, 0x44, 0xb5, 0x1e)

// 1b544c21-fd0b-11ce-8c63-00aa0044b51e           Avi File Reader
OUR_GUID_ENTRY(CLSID_AviReader,
0x1b544c21, 0xfd0b, 0x11ce, 0x8c, 0x63, 0x0, 0xaa, 0x00, 0x44, 0xb5, 0x1e)

// 1b544c22-fd0b-11ce-8c63-00aa0044b51e           Vfw 2.0 Capture Driver
OUR_GUID_ENTRY(CLSID_VfwCapture,
0x1b544c22, 0xfd0b, 0x11ce, 0x8c, 0x63, 0x0, 0xaa, 0x00, 0x44, 0xb5, 0x1e)

OUR_GUID_ENTRY(CLSID_CaptureProperties,
0x1B544c22, 0xFD0B, 0x11ce, 0x8C, 0x63, 0x00, 0xAA, 0x00, 0x44, 0xB5, 0x1F)

//e436ebb4-524f-11ce-9f53-0020af0ba770            Control Distributor
OUR_GUID_ENTRY(CLSID_FGControl,
0xe436ebb4, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 44584800-F8EE-11ce-B2D4-00DD01101B85           .MOV reader (old)
OUR_GUID_ENTRY(CLSID_MOVReader,
0x44584800, 0xf8ee, 0x11ce, 0xb2, 0xd4, 0x00, 0xdd, 0x1, 0x10, 0x1b, 0x85)

// D51BD5A0-7548-11cf-A520-0080C77EF58A		  QT Splitter
OUR_GUID_ENTRY(CLSID_QuickTimeParser,
0xd51bd5a0, 0x7548, 0x11cf, 0xa5, 0x20, 0x0, 0x80, 0xc7, 0x7e, 0xf5, 0x8a)

// FDFE9681-74A3-11d0-AFA7-00AA00B67A42		  QT Decoder
OUR_GUID_ENTRY(CLSID_QTDec, 
0xfdfe9681, 0x74a3, 0x11d0, 0xaf, 0xa7, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// D3588AB0-0781-11ce-B03A-0020AF0BA770           AVIFile-based reader
OUR_GUID_ENTRY(CLSID_AVIDoc,
0xd3588ab0, 0x0781, 0x11ce, 0xb0, 0x3a, 0x00, 0x20, 0xaf, 0xb, 0xa7, 0x70)

// D3588AB1-0781-11ce-B03A-0020AF0BA770           AVIFile-based writer
OUR_GUID_ENTRY(CLSID_AVIDocWriter,
0xd3588ab1, 0x0781, 0x11ce, 0xb0, 0x3a, 0x00, 0x20, 0xaf, 0xb, 0xa7, 0x70)

// 70e102b0-5556-11ce-97c0-00aa0055595a           Video renderer
OUR_GUID_ENTRY(CLSID_VideoRenderer,
0x70e102b0, 0x5556, 0x11ce, 0x97, 0xc0, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 1643e180-90f5-11ce-97d5-00aa0055595a           Colour space convertor
OUR_GUID_ENTRY(CLSID_Colour,
0x1643e180, 0x90f5, 0x11ce, 0x97, 0xd5, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 1da08500-9edc-11cf-bc10-00aa00ac74f6           VGA 16 color ditherer
OUR_GUID_ENTRY(CLSID_Dither,
0x1da08500, 0x9edc, 0x11cf, 0xbc, 0x10, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6)

// 07167665-5011-11cf-BF33-00AA0055595A           Modex video renderer
OUR_GUID_ENTRY(CLSID_ModexRenderer,
0x7167665, 0x5011, 0x11cf, 0xbf, 0x33, 0x0, 0xaa, 0x0, 0x55, 0x59, 0x5a)

// e30629d1-27e5-11ce-875d-00608cb78066           Waveout audio renderer
OUR_GUID_ENTRY(CLSID_AudioRender,
0xe30629d1, 0x27e5, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)

// 05589faf-c356-11ce-bf01-00aa0055595a           Audio Renderer Property Page
OUR_GUID_ENTRY(CLSID_AudioProperties,
0x05589faf, 0xc356, 0x11ce, 0xbf, 0x01, 0x0, 0xaa, 0x0, 0x55, 0x59, 0x5a)

// 79376820-07D0-11cf-A24D-0020AFD79767           DSound audio renderer
OUR_GUID_ENTRY(CLSID_DSoundRender,
0x79376820, 0x07D0, 0x11CF, 0xA2, 0x4D, 0x0, 0x20, 0xAF, 0xD7, 0x97, 0x67)

// e30629d2-27e5-11ce-875d-00608cb78066           Wavein audio recorder
OUR_GUID_ENTRY(CLSID_AudioRecord,
0xe30629d2, 0x27e5, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)

// {CF49D4E0-1115-11ce-B03A-0020AF0BA770}         AVI Decoder
OUR_GUID_ENTRY(CLSID_AVIDec,
0xcf49d4e0, 0x1115, 0x11ce, 0xb0, 0x3a, 0x0, 0x20, 0xaf, 0xb, 0xa7, 0x70)

// {A888DF60-1E90-11cf-AC98-00AA004C0FA9}	  AVI ICDraw* wrapper
OUR_GUID_ENTRY(CLSID_AVIDraw,
0xa888df60, 0x1e90, 0x11cf, 0xac, 0x98, 0x0, 0xaa, 0x0, 0x4c, 0xf, 0xa9)

// 6a08cf80-0e18-11cf-a24d-0020afd79767       ACM Wrapper
OUR_GUID_ENTRY(CLSID_ACMWrapper,
0x6a08cf80, 0x0e18, 0x11cf, 0xa2, 0x4d, 0x0, 0x20, 0xaf, 0xd7, 0x97, 0x67)

// {e436ebb5-524f-11ce-9f53-0020af0ba770}    Async File Reader
OUR_GUID_ENTRY(CLSID_AsyncReader,
0xe436ebb5, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {e436ebb6-524f-11ce-9f53-0020af0ba770}    Async URL Reader
OUR_GUID_ENTRY(CLSID_URLReader,
0xe436ebb6, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {e436ebb7-524f-11ce-9f53-0020af0ba770}    IPersistMoniker PID
OUR_GUID_ENTRY(CLSID_PersistMonikerPID,
0xe436ebb7, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {5f2759c0-7685-11cf-8b23-00805f6cef60}    IAMovie plug-in distributor
OUR_GUID_ENTRY(CLSID_AMovie,
0x5f2759c0, 0x7685, 0x11cf, 0x8b, 0x23, 0x00, 0x80, 0x5f, 0x6c, 0xef, 0x60)

// {D76E2820-1563-11cf-AC98-00AA004C0FA9}
OUR_GUID_ENTRY(CLSID_AVICo,
0xd76e2820, 0x1563, 0x11cf, 0xac, 0x98, 0x0, 0xaa, 0x0, 0x4c, 0xf, 0xa9)

// {8596E5F0-0DA5-11d0-BD21-00A0C911CE86}
OUR_GUID_ENTRY(CLSID_FileWriter,
0x8596e5f0, 0xda5, 0x11d0, 0xbd, 0x21, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// {E2510970-F137-11CE-8B67-00AA00A3F1A6}     AVI mux filter
OUR_GUID_ENTRY(CLSID_AviDest,
0xe2510970, 0xf137, 0x11ce, 0x8b, 0x67, 0x0, 0xaa, 0x0, 0xa3, 0xf1, 0xa6)

// {F560AE42-6CDD-11d1-ADE2-0000F8754B99}     ASF mux filter
OUR_GUID_ENTRY(CLSID_AsfMux,
0xf560ae42, 0x6cdd, 0x11d1, 0xad, 0xe2, 0x0, 0x0, 0xf8, 0x75, 0x4b, 0x99)

// {C647B5C0-157C-11d0-BD23-00A0C911CE86}
OUR_GUID_ENTRY(CLSID_AviMuxProptyPage,
0xc647b5c0, 0x157c, 0x11d0, 0xbd, 0x23, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// {0A9AE910-85C0-11d0-BD42-00A0C911CE86}
OUR_GUID_ENTRY(CLSID_AviMuxProptyPage1,
0xa9ae910, 0x85c0, 0x11d0, 0xbd, 0x42, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// {07b65360-c445-11ce-afde-00aa006c14f4}
OUR_GUID_ENTRY(CLSID_AVIMIDIRender,
0x07b65360, 0xc445, 0x11ce, 0xaf, 0xde, 0x00, 0xaa, 0x00, 0x6c, 0x14, 0xf4)


// {B1B77C00-C3E4-11cf-AF79-00AA00B67A42}               DV video decoder
OUR_GUID_ENTRY(CLSID_DVVideoCodec,
0xb1b77c00, 0xc3e4, 0x11cf, 0xaf, 0x79, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {13AA3650-BB6F-11d0-AFB9-00AA00B67A42}               DV video encoder
OUR_GUID_ENTRY(CLSID_DVVideoEnc,
0x13aa3650, 0xbb6f, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {4EB31670-9FC6-11cf-AF6E-00AA00B67A42}               DV splitter
OUR_GUID_ENTRY(CLSID_DVSplitter,
0x4eb31670, 0x9fc6, 0x11cf, 0xaf, 0x6e, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {129D7E40-C10D-11d0-AFB9-00AA00B67A42}               DV muxer
OUR_GUID_ENTRY(CLSID_DVMux,
0x129d7e40, 0xc10d, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {060AF76C-68DD-11d0-8FC1-00C04FD9189D}
OUR_GUID_ENTRY(CLSID_SeekingPassThru,
0x60af76c, 0x68dd, 0x11d0, 0x8f, 0xc1, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d)

// 6E8D4A20-310C-11d0-B79A-00AA003767A7                 Line21 (CC) Decoder
OUR_GUID_ENTRY(CLSID_Line21Decoder,
0x6e8d4a20, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// {CD8743A1-3736-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(CLSID_OverlayMixer, 
0xcd8743a1, 0x3736, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {814B9800-1C88-11d1-BAD9-00609744111A}
OUR_GUID_ENTRY(CLSID_VBISurfaces, 
0x814b9800, 0x1c88, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// pnp objects and categories
// 62BE5D10-60EB-11d0-BD3B-00A0C911CE86                 ICreateDevEnum
OUR_GUID_ENTRY(CLSID_SystemDeviceEnum,
0x62BE5D10,0x60EB,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 4315D437-5B8C-11d0-BD3B-00A0C911CE86
OUR_GUID_ENTRY(CLSID_CDeviceMoniker,
0x4315D437,0x5B8C,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 860BB310-5D01-11d0-BD3B-00A0C911CE86                 Video capture category
OUR_GUID_ENTRY(CLSID_VideoInputDeviceCategory,
0x860BB310,0x5D01,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)
OUR_GUID_ENTRY(CLSID_CVidCapClassManager,
0x860BB310,0x5D01,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 083863F1-70DE-11d0-BD40-00A0C911CE86                 Filter category
OUR_GUID_ENTRY(CLSID_LegacyAmFilterCategory,
0x083863F1,0x70DE,0x11d0,0xBD,0x40,0x00,0xA0,0xC9,0x11,0xCE,0x86)
OUR_GUID_ENTRY(CLSID_CQzFilterClassManager,
0x083863F1,0x70DE,0x11d0,0xBD,0x40,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 33D9A760-90C8-11d0-BD43-00A0C911CE86
OUR_GUID_ENTRY(CLSID_VideoCompressorCategory,
0x33d9a760, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CIcmCoClassManager,
0x33d9a760, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 33D9A761-90C8-11d0-BD43-00A0C911CE86
OUR_GUID_ENTRY(CLSID_AudioCompressorCategory,
0x33d9a761, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CAcmCoClassManager,
0x33d9a761, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 33D9A762-90C8-11d0-BD43-00A0C911CE86                 Audio source cateogry
OUR_GUID_ENTRY(CLSID_AudioInputDeviceCategory,
0x33d9a762, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CWaveinClassManager,
0x33d9a762, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// E0F158E1-CB04-11d0-BD4E-00A0C911CE86                 Audio renderer category
OUR_GUID_ENTRY(CLSID_AudioRendererCategory,
0xe0f158e1, 0xcb04, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CWaveOutClassManager,
0xe0f158e1, 0xcb04, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 4EFE2452-168A-11d1-BC76-00C04FB9453B			Midi renderer category
OUR_GUID_ENTRY(CLSID_MidiRendererCategory,
0x4EfE2452, 0x168A, 0x11d1, 0xBC, 0x76, 0x0, 0xc0, 0x4F, 0xB9, 0x45, 0x3B)
OUR_GUID_ENTRY(CLSID_CMidiOutClassManager,
0x4EfE2452, 0x168A, 0x11d1, 0xBC, 0x76, 0x0, 0xc0, 0x4F, 0xB9, 0x45, 0x3B)

// DA4E3DA0-D07D-11d0-BD50-00A0C911CE86
OUR_GUID_ENTRY(CLSID_ActiveMovieCategories,
0xda4e3da0, 0xd07d, 0x11d0, 0xbd, 0x50, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 2721AE20-7E70-11D0-A5D6-28DB04C10000
OUR_GUID_ENTRY(CLSID_DVDHWDecodersCategory,
0x2721AE20, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00)

// CDA42200-BD88-11d0-BD4E-00A0C911CE86
OUR_GUID_ENTRY(CLSID_FilterMapper2,
0xcda42200, 0xbd88, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)


// 1e651cc0-b199-11d0-8212-00c04fc32c45
OUR_GUID_ENTRY(CLSID_MemoryAllocator,
0x1e651cc0, 0xb199, 0x11d0, 0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45)

// CDBD8D00-C193-11d0-BD4E-00A0C911CE86
OUR_GUID_ENTRY(CLSID_MediaPropertyBag,
0xcdbd8d00, 0xc193, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
			
// FCC152B7-F372-11d0-8E00-00C04FD7C08B
OUR_GUID_ENTRY(CLSID_DvdGraphBuilder,
0xFCC152B7, 0xF372, 0x11d0, 0x8E, 0x00, 0x00, 0xC0, 0x4F, 0xD7, 0xC0, 0x8B)

// 9B8C4620-2C1A-11d0-8493-00A02438AD48
OUR_GUID_ENTRY(CLSID_DVDNavigator,
0x9b8c4620, 0x2c1a, 0x11d0, 0x84, 0x93, 0x0, 0xa0, 0x24, 0x38, 0xad, 0x48)

// CC58E280-8AA1-11d1-B3F1-00AA003761C5
OUR_GUID_ENTRY(CLSID_SmartTee,
0xcc58e280, 0x8aa1, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)


// -- format types ---

// 0F6417D6-C318-11D0-A43F-00A0C9223196	       FORMAT_None
OUR_GUID_ENTRY(FORMAT_None,
0x0F6417D6, 0xc318, 0x11d0, 0xa4, 0x3f, 0x00, 0xa0, 0xc9, 0x22, 0x31, 0x96)

// 05589f80-c356-11ce-bf01-00aa0055595a        FORMAT_VideoInfo
OUR_GUID_ENTRY(FORMAT_VideoInfo,
0x05589f80, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// F72A76A0-EB0A-11d0-ACE4-0000C0CC16BA        FORMAT_VideoInfo2
OUR_GUID_ENTRY(FORMAT_VideoInfo2,
0xf72a76A0, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// 05589f81-c356-11ce-bf01-00aa0055595a        FORMAT_WaveFormatEx
OUR_GUID_ENTRY(FORMAT_WaveFormatEx,
0x05589f81, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 05589f82-c356-11ce-bf01-00aa0055595a        FORMAT_MPEGVideo
OUR_GUID_ENTRY(FORMAT_MPEGVideo,
0x05589f82, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 05589f83-c356-11ce-bf01-00aa0055595a        FORMAT_MPEGStreams
OUR_GUID_ENTRY(FORMAT_MPEGStreams,
0x05589f83, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 05589f84-c356-11ce-bf01-00aa0055595a        FORMAT_DvInfo, DVINFO
OUR_GUID_ENTRY(FORMAT_DvInfo,
0x05589f84, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)


// -- Video related GUIDs ---


// 944d4c00-dd52-11ce-bf0e-00aa0055595a
OUR_GUID_ENTRY(CLSID_DirectDrawProperties,
0x944d4c00, 0xdd52, 0x11ce, 0xbf, 0x0e, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 59ce6880-acf8-11cf-b56e-0080c7c4b68a
OUR_GUID_ENTRY(CLSID_PerformanceProperties,
0x59ce6880, 0xacf8, 0x11cf, 0xb5, 0x6e, 0x00, 0x80, 0xc7, 0xc4, 0xb6, 0x8a)

// 418afb70-f8b8-11ce-aac6-0020af0b99a3
OUR_GUID_ENTRY(CLSID_QualityProperties,
0x418afb70, 0xf8b8, 0x11ce, 0xaa, 0xc6, 0x00, 0x20, 0xaf, 0x0b, 0x99, 0xa3)

// 61ded640-e912-11ce-a099-00aa00479a58
OUR_GUID_ENTRY(IID_IBaseVideoMixer,
0x61ded640, 0xe912, 0x11ce, 0xa0, 0x99, 0x00, 0xaa, 0x00, 0x47, 0x9a, 0x58)

// 36d39eb0-dd75-11ce-bf0e-00aa0055595a
OUR_GUID_ENTRY(IID_IDirectDrawVideo,
0x36d39eb0, 0xdd75, 0x11ce, 0xbf, 0x0e, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// bd0ecb0-f8e2-11ce-aac6-0020af0b99a3
OUR_GUID_ENTRY(IID_IQualProp,
0x1bd0ecb0, 0xf8e2, 0x11ce, 0xaa, 0xc6, 0x00, 0x20, 0xaf, 0x0b, 0x99, 0xa3)

// {CE292861-FC88-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(CLSID_VPObject, 
0xce292861, 0xfc88, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {CE292862-FC88-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPObject, 
0xce292862, 0xfc88, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {25DF12C1-3DE0-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPControl, 
0x25df12c1, 0x3de0, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {814B9801-1C88-11d1-BAD9-00609744111A}
OUR_GUID_ENTRY(CLSID_VPVBIObject, 
0x814b9801, 0x1c88, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {814B9802-1C88-11d1-BAD9-00609744111A}
OUR_GUID_ENTRY(IID_IVPVBIObject, 
0x814b9802, 0x1c88, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {BC29A660-30E3-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPConfig,
0xbc29a660, 0x30e3, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {C76794A1-D6C5-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPNotify,
0xc76794a1, 0xd6c5, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {EBF47183-8764-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPNotify2,
0xebf47183, 0x8764, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)


// {EC529B00-1A1F-11D1-BAD9-00609744111A}
OUR_GUID_ENTRY(IID_IVPVBIConfig,
0xec529b00, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {EC529B01-1A1F-11D1-BAD9-00609744111A}
OUR_GUID_ENTRY(IID_IVPVBINotify,
0xec529b01, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {593CDDE1-0759-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IMixerPinConfig, 
0x593cdde1, 0x759, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {EBF47182-8764-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IMixerPinConfig2,
0xebf47182, 0x8764, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)


// This is a real pain in the neck. The OLE GUIDs are separated out into a
// different file from the main header files. The header files can then be
// included multiple times and are protected with the following statements,
//
//      #ifndef __SOMETHING_DEFINED__
//      #define __SOMETHING_DEFINED__
//          all the header contents
//      #endif // __SOMETHING_DEFINED__
//
// When the actual GUIDs are to be defined (using initguid) the GUID header
// file can then be included to really define them just once. Unfortunately
// DirectDraw has the GUIDs defined in the main header file. So if the base
// classes bring in ddraw.h to get at the DirectDraw structures and so on
// nobody would then be able to really include ddraw.h to allocate the GUID
// memory structures because of the aforementioned header file protection
// Therefore the DirectDraw GUIDs are defined and allocated for real here

#ifndef __DDRAW_INCLUDED__
OUR_GUID_ENTRY(CLSID_DirectDraw,	    0xD7B70EE0,0x4340,0x11CF,0xB0,0x63,0x00,0x20,0xAF,0xC2,0xCD,0x35)
OUR_GUID_ENTRY(CLSID_DirectDrawClipper,	    0x593817A0,0x7DB3,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xb9,0x33,0x56)
OUR_GUID_ENTRY(IID_IDirectDraw,		    0x6C14DB80,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDraw2,	    0xB3A6F3E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56)
OUR_GUID_ENTRY(IID_IDirectDrawSurface,	    0x6C14DB81,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawSurface2,	    0x57805885,0x6eec,0x11cf,0x94,0x41,0xa8,0x23,0x03,0xc1,0x0e,0x27)
OUR_GUID_ENTRY(IID_IDirectDrawSurface3,	    0xDA044E00,0x69B2,0x11D0,0xA1,0xD5,0x00,0xAA,0x00,0xB8,0xDF,0xBB)
OUR_GUID_ENTRY(IID_IDirectDrawPalette,	    0x6C14DB84,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawClipper,	    0x6C14DB85,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawColorControl, 0x4B9F0EE0,0x0D7E,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8)
#endif

#ifndef __DVP_INCLUDED__
OUR_GUID_ENTRY(IID_IDDVideoPortContainer,    0x6C142760,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
#endif

#ifndef __DDKM_INCLUDED__
OUR_GUID_ENTRY(IID_IDirectDrawKernel,        0x8D56C120,0x6A08,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8)
OUR_GUID_ENTRY(IID_IDirectDrawSurfaceKernel, 0x60755DA0,0x6A40,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8)
#endif

// 0618aa30-6bc4-11cf-bf36-00aa0055595a
OUR_GUID_ENTRY(CLSID_ModexProperties,
0x0618aa30, 0x6bc4, 0x11cf, 0xbf, 0x36, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// dd1d7110-7836-11cf-bf47-00aa0055595a
OUR_GUID_ENTRY(IID_IFullScreenVideo,
0xdd1d7110, 0x7836, 0x11cf, 0xbf, 0x47, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 53479470-f1dd-11cf-bc42-00aa00ac74f6
OUR_GUID_ENTRY(IID_IFullScreenVideoEx,
0x53479470, 0xf1dd, 0x11cf, 0xbc, 0x42, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6)

// {101193C0-0BFE-11d0-AF91-00AA00B67A42}           DV decoder property
OUR_GUID_ENTRY(CLSID_DVDecPropertiesPage,       
0x101193c0, 0xbfe, 0x11d0, 0xaf, 0x91, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {4150F050-BB6F-11d0-AFB9-00AA00B67A42}           DV encoder property
OUR_GUID_ENTRY(CLSID_DVEncPropertiesPage,
0x4150f050, 0xbb6f, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {4DB880E0-C10D-11d0-AFB9-00AA00B67A42}           DV Muxer property
OUR_GUID_ENTRY(CLSID_DVMuxPropertyPage,
0x4db880e0, 0xc10d, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)


// -- Direct Sound Audio related GUID ---

// 546F4260-D53E-11cf-B3F0-00AA003761C5
OUR_GUID_ENTRY(IID_IAMDirectSound,
0x546f4260, 0xd53e, 0x11cf, 0xb3, 0xf0, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// -- MPEG audio decoder properties

// {b45dd570-3c77-11d1-abe1-00a0c905f375}
OUR_GUID_ENTRY(IID_IMpegAudioDecoder,
0xb45dd570, 0x3c77, 0x11d1, 0xab, 0xe1, 0x00, 0xa0, 0xc9, 0x05, 0xf3, 0x75)

// --- Line21 Decoder interface GUID ---

// 6E8D4A21-310C-11d0-B79A-00AA003767A7            IID_IAMLine21Decoder
OUR_GUID_ENTRY(IID_IAMLine21Decoder,
0x6e8d4a21, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// -- Analog video related GUIDs ---


// -- format types ---
// 0482DDE0-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(FORMAT_AnalogVideo,
0x482dde0, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)


// -- major type, Analog Video

// 0482DDE1-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIATYPE_AnalogVideo,
0x482dde1, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)


// -- Analog Video subtypes, NTSC

// 0482DDE2-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_NTSC_M,
0x482dde2, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// -- Analog Video subtypes, PAL

// 0482DDE5-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_B,
0x482dde5, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE6-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_D,
0x482dde6, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE7-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_G,
0x482dde7, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE8-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_H,
0x482dde8, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE9-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_I,
0x482dde9, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDEA-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_M,
0x482ddea, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDEB-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_N,
0x482ddeb, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// -- Analog Video subtypes, SECAM

// 0482DDF0-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_B,
0x482ddf0, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF1-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_D,
0x482ddf1, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF2-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_G,
0x482ddf2, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF3-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_H,
0x482ddf3, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF4-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_K,
0x482ddf4, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF5-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_K1,
0x482ddf5, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF6-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_L,
0x482ddf6, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)


// --  External audio related GUIDs ---

// -- major types, Analog Audio

// 0482DEE1-7817-11cf-8a03-00aa006ecb65
OUR_GUID_ENTRY(MEDIATYPE_AnalogAudio,
0x482dee1, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

//
// DirectShow's include file based on ksmedia.h from WDM DDK
//
#include "ksuuids.h"


// -- Well known time format GUIDs ---


// 00000000-0000-0000-0000-000000000000
OUR_GUID_ENTRY(TIME_FORMAT_NONE,
0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

// 7b785570-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_FRAME,
0x7b785570, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)

// 7b785571-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_BYTE,
0x7b785571, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)

// 7b785572-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_SAMPLE,
0x7b785572, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)

// 7b785573-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_FIELD,
0x7b785573, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)


// 7b785574-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_MEDIA_TIME,
0x7b785574, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)


// for IKsPropertySet

// 9B00F101-1567-11d1-B3F1-00AA003761C5
OUR_GUID_ENTRY(AMPROPSETID_Pin,
0x9b00f101, 0x1567, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// fb6c4281-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_CAPTURE,
0xfb6c4281, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4282-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_PREVIEW,
0xfb6c4282, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4283-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_ANALOGVIDEOIN,
0xfb6c4283, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4284-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_VBI,
0xfb6c4284, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4285-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_VIDEOPORT,
0xfb6c4285, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4286-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_NABTS,
0xfb6c4286, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4287-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_EDS,
0xfb6c4287, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4288-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_TELETEXT,
0xfb6c4288, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4289-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_CC,
0xfb6c4289, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c428a-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_STILL,
0xfb6c428a, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c428b-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_TIMECODE,
0xfb6c428b, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c428c-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_VIDEOPORT_VBI,
0xfb6c428c, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)


// the following special GUIDS are used by ICaptureGraphBuilder::FindInterface

// {AC798BE0-98E3-11d1-B3F1-00AA003761C5}
OUR_GUID_ENTRY(LOOK_UPSTREAM_ONLY,
0xac798be0, 0x98e3, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// {AC798BE1-98E3-11d1-B3F1-00AA003761C5}
OUR_GUID_ENTRY(LOOK_DOWNSTREAM_ONLY,
0xac798be1, 0x98e3, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// -------------------------------------------------------------------------
// KSProxy GUIDS
// -------------------------------------------------------------------------

// {266EEE41-6C63-11cf-8A03-00AA006ECB65}
OUR_GUID_ENTRY(CLSID_TVTunerFilterPropertyPage, 
0x266eee41, 0x6c63, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// {71F96461-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_CrossbarFilterPropertyPage,
0x71f96461, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96463-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_TVAudioFilterPropertyPage,
0x71f96463, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96464-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_VideoProcAmpPropertyPage,
0x71f96464, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96465-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_CameraControlPropertyPage,
0x71f96465, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)
                                  
// {71F96466-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_AnalogVideoDecoderPropertyPage,
0x71f96466, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)
                                  
// {71F96467-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_VideoStreamConfigPropertyPage,
0x71f96467, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)
                                  
#undef OUR_GUID_ENTRY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\wxdebug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Debugging facilities, January 1995

#ifndef __WXDEBUG__
#define __WXDEBUG__

// This library provides fairly straight forward debugging functionality, this
// is split into two main sections. The first is assertion handling, there are
// three types of assertions provided here. The most commonly used one is the
// ASSERT(condition) macro which will pop up a message box including the file
// and line number if the condition evaluates to FALSE. Then there is the
// EXECUTE_ASSERT macro which is the same as ASSERT except the condition will
// still be executed in NON debug builds. The final type of assertion is the
// KASSERT macro which is more suitable for pure (perhaps kernel) filters as
// the condition is printed onto the debugger rather than in a message box.
//
// The other part of the debug module facilties is general purpose logging.
// This is accessed by calling DbgLog(). The function takes a type and level
// field which define the type of informational string you are presenting and
// it's relative importance. The type field can be a combination (one or more)
// of LOG_TIMING, LOG_TRACE, LOG_MEMORY, LOG_LOCKING and LOG_ERROR. The level
// is a DWORD value where zero defines highest important. Use of zero as the
// debug logging level is to be encouraged ONLY for major errors or events as
// they will ALWAYS be displayed on the debugger. Other debug output has it's
// level matched against the current debug output level stored in the registry
// for this module and if less than the current setting it will be displayed.
//
// Each module or executable has it's own debug output level for each of the
// five types. These are read in when the DbgInitialise function is called
// for DLLs linking to STRMBASE.LIB this is done automatically when the DLL
// is loaded, executables must call it explicitely with the module instance
// handle given to them through the WINMAIN entry point. An executable must
// also call DbgTerminate when they have finished to clean up the resources
// the debug library uses, once again this is done automatically for DLLs

// These are the five different categories of logging information

enum {  LOG_TIMING = 0x01,    // Timing and performance measurements
        LOG_TRACE = 0x02,     // General step point call tracing
        LOG_MEMORY =  0x04,   // Memory and object allocation/destruction
        LOG_LOCKING = 0x08,   // Locking/unlocking of critical sections
        LOG_ERROR = 0x10 };   // Debug error notification

enum {  CDISP_HEX = 0x01,
        CDISP_DEC = 0x02};

// For each object created derived from CBaseObject (in debug builds) we
// create a descriptor that holds it's name (statically allocated memory)
// and a cookie we assign it. We keep a list of all the active objects
// we have registered so that we can dump a list of remaining objects

typedef struct tag_ObjectDesc {
    const TCHAR *m_pName;
    DWORD m_dwCookie;
    tag_ObjectDesc *m_pNext;
} ObjectDesc;

#define DLLIMPORT __declspec(dllimport)
#define DLLEXPORT __declspec(dllexport)

#ifdef DEBUG

    #define NAME(x) TEXT(x)

    // These are used internally by the debug library (PRIVATE)

    void WINAPI DbgInitKeyLevels(HKEY hKey);
    void WINAPI DbgInitGlobalSettings();
    void WINAPI DbgInitModuleSettings();
    void WINAPI DbgInitModuleName();
    DWORD WINAPI DbgRegisterObjectCreation(const TCHAR *pObjectName);
    BOOL WINAPI DbgRegisterObjectDestruction(DWORD dwCookie);

    // These are the PUBLIC entry points

    BOOL WINAPI DbgCheckModuleLevel(DWORD Type,DWORD Level);
    void WINAPI DbgSetModuleLevel(DWORD Type,DWORD Level);

    // Initialise the library with the module handle

    void WINAPI DbgInitialise(HINSTANCE hInst);
    void WINAPI DbgTerminate();

    void WINAPI DbgDumpObjectRegister();

    // Display error and logging to the user

    void WINAPI DbgAssert(const TCHAR *pCondition,const TCHAR *pFileName,INT iLine);
    void WINAPI DbgBreakPoint(const TCHAR *pCondition,const TCHAR *pFileName,INT iLine);
    void WINAPI DbgKernelAssert(const TCHAR *pCondition,const TCHAR *pFileName,INT iLine);
    void WINAPI DbgLogInfo(DWORD Type,DWORD Level,const TCHAR *pFormat,...);
    void WINAPI DbgOutString(LPCTSTR psz);

    //  Debug infinite wait stuff
    DWORD WINAPI DbgWaitForSingleObject(HANDLE h);
    DWORD WINAPI DbgWaitForMultipleObjects(DWORD nCount,
                                    CONST HANDLE *lpHandles,
                                    BOOL bWaitAll);
    void WINAPI DbgSetWaitTimeout(DWORD dwTimeout);

#ifdef __strmif_h__
    // Display a media type: Terse at level 2, verbose at level 5
    void WINAPI DisplayType(LPSTR label, const AM_MEDIA_TYPE *pmtIn);

    // Dump lots of information about a filter graph
    void WINAPI DumpGraph(IFilterGraph *pGraph, DWORD dwLevel);
#endif

    #define KASSERT(_x_) if (!(_x_))         \
        DbgKernelAssert(TEXT(#_x_),TEXT(__FILE__),__LINE__)

    //  Break on the debugger without putting up a message box
    //  message goes to debugger instead

    #define KDbgBreak(_x_)                   \
        DbgKernelAssert(TEXT(#_x_),TEXT(__FILE__),__LINE__)

    // We chose a common name for our ASSERT macro, MFC also uses this name
    // So long as the implementation evaluates the condition and handles it
    // then we will be ok. Rather than override the behaviour expected we
    // will leave whatever first defines ASSERT as the handler (i.e. MFC)
    #ifndef ASSERT
        #define ASSERT(_x_) if (!(_x_))         \
            DbgAssert(TEXT(#_x_),TEXT(__FILE__),__LINE__)
    #endif

    //  Put up a message box informing the user of a halt
    //  condition in the program

    #define DbgBreak(_x_)                   \
        DbgBreakPoint(TEXT(#_x_),TEXT(__FILE__),__LINE__)

    #define EXECUTE_ASSERT(_x_) ASSERT(_x_)
    #define DbgLog(_x_) DbgLogInfo _x_

    // MFC style trace macros

    #define NOTE(_x_)             DbgLog((LOG_TRACE,5,TEXT(_x_)))
    #define NOTE1(_x_,a)          DbgLog((LOG_TRACE,5,TEXT(_x_),a))
    #define NOTE2(_x_,a,b)        DbgLog((LOG_TRACE,5,TEXT(_x_),a,b))
    #define NOTE3(_x_,a,b,c)      DbgLog((LOG_TRACE,5,TEXT(_x_),a,b,c))
    #define NOTE4(_x_,a,b,c,d)    DbgLog((LOG_TRACE,5,TEXT(_x_),a,b,c,d))
    #define NOTE5(_x_,a,b,c,d,e)  DbgLog((LOG_TRACE,5,TEXT(_x_),a,b,c,d,e))

#else

    // Retail builds make public debug functions inert  - WARNING the source
    // files do not define or build any of the entry points in debug builds
    // (public entry points compile to nothing) so if you go trying to call
    // any of the private entry points in your source they won't compile

    #define NAME(_x_) NULL

    #define DbgInitialise(hInst)
    #define DbgTerminate()
    #define DbgLog(_x_) 0
    #define DbgOutString(psz)

    #define DbgRegisterObjectCreation(pObjectName)
    #define DbgRegisterObjectDestruction(dwCookie)
    #define DbgDumpObjectRegister()

    #define DbgCheckModuleLevel(Type,Level)
    #define DbgSetModuleLevel(Type,Level)

    #define DbgWaitForSingleObject(h)  WaitForSingleObject(h, INFINITE)
    #define DbgWaitForMultipleObjects(nCount, lpHandles, bWaitAll)     \
               WaitForMultipleObjects(nCount, lpHandles, bWaitAll, INFINITE)
    #define DbgSetWaitTimeout(dwTimeout)

    #define KDbgBreak(_x_)
    #define DbgBreak(_x_)

    #define KASSERT(_x_) ((void)0)
    #ifndef ASSERT
	#define ASSERT(_x_) ((void)0)
    #endif
    #define EXECUTE_ASSERT(_x_) ((void)(_x_))

    // MFC style trace macros

    #define NOTE(_x_) ((void)0)
    #define NOTE1(_x_,a) ((void)0)
    #define NOTE2(_x_,a,b) ((void)0)
    #define NOTE3(_x_,a,b,c) ((void)0)
    #define NOTE4(_x_,a,b,c,d) ((void)0)
    #define NOTE5(_x_,a,b,c,d,e) ((void)0)

    #define DisplayType(label, pmtIn) ((void)0)
    #define DumpGraph(pGraph, label) ((void)0)
#endif


// Checks a pointer which should be non NULL - can be used as follows.

#define CheckPointer(p,ret) {if((p)==NULL) return (ret);}

//   HRESULT Foo(VOID *pBar)
//   {
//       CheckPointer(pBar,E_INVALIDARG)
//   }
//
//   Or if the function returns a boolean
//
//   BOOL Foo(VOID *pBar)
//   {
//       CheckPointer(pBar,FALSE)
//   }

// These validate pointers when symbol VFWROBUST is defined
// This will normally be defined in debug not retail builds

#ifdef DEBUG
    #define VFWROBUST
#endif

#ifdef VFWROBUST

    #define ValidateReadPtr(p,cb) \
        {if(IsBadReadPtr((PVOID)p,cb) == TRUE) \
            DbgBreak("Invalid read pointer");}

    #define ValidateWritePtr(p,cb) \
        {if(IsBadWritePtr((PVOID)p,cb) == TRUE) \
            DbgBreak("Invalid write pointer");}

    #define ValidateReadWritePtr(p,cb) \
        {ValidateReadPtr(p,cb) ValidateWritePtr(p,cb)}

    #define ValidateStringPtr(p) \
        {if(IsBadStringPtr((LPCTSTR)p,INFINITE) == TRUE) \
            DbgBreak("Invalid string pointer");}

    #define ValidateStringPtrA(p) \
        {if(IsBadStringPtrA((LPCSTR)p,INFINITE) == TRUE) \
            DbgBreak("Invalid ANSII string pointer");}

    #define ValidateStringPtrW(p) \
        {if(IsBadStringPtrW((LPCWSTR)p,INFINITE) == TRUE) \
            DbgBreak("Invalid UNICODE string pointer");}

#else
    #define ValidateReadPtr(p,cb) 0
    #define ValidateWritePtr(p,cb) 0
    #define ValidateReadWritePtr(p,cb) 0
    #define ValidateStringPtr(p) 0
    #define ValidateStringPtrA(p) 0
    #define ValidateStringPtrW(p) 0
#endif


#ifdef _OBJBASE_H_

    //  Outputting GUID names.  If you want to include the name
    //  associated with a GUID (eg CLSID_...) then
    //
    //      GuidNames[yourGUID]
    //
    //  Returns the name defined in uuids.h as a string

    typedef struct {
        TCHAR   *szName;
        GUID    guid;
    } GUID_STRING_ENTRY;

    class CGuidNameList {
    public:
        TCHAR *operator [] (const GUID& guid);
    };

    extern CGuidNameList GuidNames;

#endif

#ifndef REMIND
    //  REMIND macro - generates warning as reminder to complete coding
    //  (eg) usage:
    //
    //  #pragma message (REMIND("Add automation support"))


    #define QUOTE(x) #x
    #define QQUOTE(y) QUOTE(y)
    #define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) ") :  " str
#endif

//  Hack to display objects in a useful format
//
//  eg If you want to display a LONGLONG ll in a debug string do (eg)
//
//  DbgLog((LOG_TRACE, n, TEXT("Value is %s"), (LPCTSTR)CDisp(ll, CDISP_HEX)));


class CDispBasic
{
public:
    CDispBasic() { m_pString = m_String; };
    ~CDispBasic();
protected:
    PTCHAR m_pString;  // normally points to m_String... unless too much data
    TCHAR m_String[50];
};
class CDisp : public CDispBasic
{
public:
    CDisp(LONGLONG ll, int Format = CDISP_HEX); // Display a LONGLONG in CDISP_HEX or CDISP_DEC form
    CDisp(REFCLSID clsid);      // Display a GUID
    CDisp(double d);            // Display a floating point number
#ifdef __strmif_h__
#ifdef __STREAMS__
    CDisp(CRefTime t);          // Display a Reference Time
#endif
    CDisp(IPin *pPin);          // Display a pin as {filter clsid}(pin name)
#endif // __strmif_h__
    ~CDisp();

    //  Implement cast to (LPCTSTR) as parameter to logger
    operator LPCTSTR()
    {
        return (LPCTSTR)m_pString;
    };
};

#endif // __WXDEBUG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\wxutil.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

//
// helper classes for building multimedia filters
//

#include <streams.h>

//
//  Declare function from largeint.h we need so that PPC can build
//

//
// Enlarged integer divide - 64-bits / 32-bits > 32-bits
//

#ifndef _X86_

#define LLtoU64(x) (*(unsigned __int64*)(void*)(&(x)))

__inline
ULONG
WINAPI
EnlargedUnsignedDivide (
    IN ULARGE_INTEGER Dividend,
    IN ULONG Divisor,
    IN PULONG Remainder
    )
{
        // return remainder if necessary
        if (Remainder != NULL)
                *Remainder = (ULONG)(LLtoU64(Dividend) % Divisor);
        return (ULONG)(LLtoU64(Dividend) / Divisor);
}

#else
__inline
ULONG
WINAPI
EnlargedUnsignedDivide (
    IN ULARGE_INTEGER Dividend,
    IN ULONG Divisor,
    IN PULONG Remainder
    )
{
    ULONG ulResult;
    _asm {
        mov eax,Dividend.LowPart
        mov edx,Dividend.HighPart
        mov ecx,Remainder
        div Divisor
        or  ecx,ecx
        jz  short label
        mov [ecx],edx
label:
        mov ulResult,eax
    }
    return ulResult;
}
#endif

// --- CAMEvent -----------------------
CAMEvent::CAMEvent(BOOL fManualReset)
{
    m_hEvent = CreateEvent(NULL, fManualReset, FALSE, NULL);
    ASSERT(m_hEvent);
}

CAMEvent::~CAMEvent()
{
    if (m_hEvent) {
	EXECUTE_ASSERT(CloseHandle(m_hEvent));
    }
}


// --- CAMMsgEvent -----------------------
// One routine.  The rest is handled in CAMEvent

BOOL CAMMsgEvent::WaitMsg(DWORD dwTimeout)
{
    // wait for the event to be signalled, or for the
    // timeout (in MS) to expire.  allow SENT messages
    // to be processed while we wait
    DWORD dwWait;
    DWORD dwStartTime;

    // set the waiting period.
    DWORD dwWaitTime = dwTimeout;

    // the timeout will eventually run down as we iterate
    // processing messages.  grab the start time so that
    // we can calculate elapsed times.
    if (dwWaitTime != INFINITE) {
        dwStartTime = timeGetTime();
    }

    do {
        dwWait = MsgWaitForMultipleObjects(1,&m_hEvent,FALSE, dwWaitTime, QS_SENDMESSAGE);
        if (dwWait == WAIT_OBJECT_0 + 1) {
	    MSG Message;
            PeekMessage(&Message,NULL,0,0,PM_NOREMOVE);

	    // If we have an explicit length of time to wait calculate
	    // the next wake up point - which might be now.
	    // If dwTimeout is INFINITE, it stays INFINITE
	    if (dwWaitTime != INFINITE) {

		DWORD dwElapsed = timeGetTime()-dwStartTime;

		dwWaitTime =
		    (dwElapsed >= dwTimeout)
			? 0  // wake up with WAIT_TIMEOUT
			: dwTimeout-dwElapsed;
	    }
        }
    } while (dwWait == WAIT_OBJECT_0 + 1);

    // return TRUE if we woke on the event handle,
    //        FALSE if we timed out.
    return (dwWait == WAIT_OBJECT_0);
}

// --- CAMThread ----------------------


CAMThread::CAMThread()
    : m_EventSend(TRUE)     // must be manual-reset for CheckRequest()
{
    m_hThread = NULL;
}

CAMThread::~CAMThread() {
    Close();
}


// when the thread starts, it calls this function. We unwrap the 'this'
//pointer and call ThreadProc.
DWORD WINAPI
CAMThread::InitialThreadProc(LPVOID pv)
{
    CAMThread * pThread = (CAMThread *) pv;

    return pThread->ThreadProc();
}

BOOL
CAMThread::Create()
{
    DWORD threadid;

    CAutoLock lock(&m_AccessLock);

    if (ThreadExists()) {
	return FALSE;
    }

    m_hThread = CreateThread(
		    NULL,
		    0,
		    CAMThread::InitialThreadProc,
		    this,
		    0,
		    &threadid);

    if (!m_hThread) {
	return FALSE;
    }

    return TRUE;
}

DWORD
CAMThread::CallWorker(DWORD dwParam)
{
    // lock access to the worker thread for scope of this object
    CAutoLock lock(&m_AccessLock);

    if (!ThreadExists()) {
	return (DWORD) E_FAIL;
    }

    // set the parameter
    m_dwParam = dwParam;

    // signal the worker thread
    m_EventSend.Set();

    // wait for the completion to be signalled
    m_EventComplete.Wait();

    // done - this is the thread's return value
    return m_dwReturnVal;
}

// Wait for a request from the client
DWORD
CAMThread::GetRequest()
{
    m_EventSend.Wait();
    return m_dwParam;
}

// is there a request?
BOOL
CAMThread::CheckRequest(DWORD * pParam)
{
    if (!m_EventSend.Check()) {
	return FALSE;
    } else {
	if (pParam) {
	    *pParam = m_dwParam;
	}
	return TRUE;
    }
}

// reply to the request
void
CAMThread::Reply(DWORD dw)
{
    m_dwReturnVal = dw;

    // The request is now complete so CheckRequest should fail from
    // now on
    //
    // This event should be reset BEFORE we signal the client or
    // the client may Set it before we reset it and we'll then
    // reset it (!)

    m_EventSend.Reset();

    // Tell the client we're finished

    m_EventComplete.Set();
}

HRESULT CAMThread::CoInitializeHelper()
{
    // call CoInitializeEx and tell OLE not to create a window (this
    // thread probably won't dispatch messages and will hang on
    // broadcast msgs o/w).
    //
    // If CoInitEx is not available, threads that don't call CoCreate
    // aren't affected. Threads that do will have to handle the
    // failure. Perhaps we should fall back to CoInitialize and risk
    // hanging?
    //

    // older versions of ole32.dll don't have CoInitializeEx

    HRESULT hr = E_FAIL;
    HINSTANCE hOle = GetModuleHandle(TEXT("ole32.dll"));
    if(hOle)
    {
        typedef HRESULT (STDAPICALLTYPE *PCoInitializeEx)(
            LPVOID pvReserved, DWORD dwCoInit);
        PCoInitializeEx pCoInitializeEx =
            (PCoInitializeEx)(GetProcAddress(hOle, "CoInitializeEx"));
        if(pCoInitializeEx)
        {
            hr = (*pCoInitializeEx)(0, COINIT_DISABLE_OLE1DDE );
        }
    }
    else
    {
        // caller must load ole32.dll
        DbgBreak("couldn't locate ole32.dll");
    }

    return hr;
}


// destructor for CMsgThread  - cleans up any messages left in the
// queue when the thread exited
CMsgThread::~CMsgThread()
{
    if (m_hThread != NULL) {
        WaitForSingleObject(m_hThread, INFINITE);
        EXECUTE_ASSERT(CloseHandle(m_hThread));
    }

    POSITION pos = m_ThreadQueue.GetHeadPosition();
    while (pos) {
        CMsg * pMsg = m_ThreadQueue.GetNext(pos);
        delete pMsg;
    }
    m_ThreadQueue.RemoveAll();

    if (m_hSem != NULL) {
        EXECUTE_ASSERT(CloseHandle(m_hSem));
    }
}

BOOL
CMsgThread::CreateThread(
    )
{
    m_hSem = CreateSemaphore(NULL, 0, 0x7FFFFFFF, NULL);
    if (m_hSem == NULL) {
        return FALSE;
    }

    m_hThread = ::CreateThread(NULL, 0, DefaultThreadProc,
			       (LPVOID)this, 0, &m_ThreadId);
    return m_hThread != NULL;
}


// This is the threads message pump.  Here we get and dispatch messages to
// clients thread proc until the client refuses to process a message.
// The client returns a non-zero value to stop the message pump, this
// value becomes the threads exit code.

DWORD WINAPI
CMsgThread::DefaultThreadProc(
    LPVOID lpParam
    )
{
    CMsgThread *lpThis = (CMsgThread *)lpParam;
    CMsg msg;
    LRESULT lResult;

    // !!!
    CoInitialize(NULL);

    // allow a derived class to handle thread startup
    lpThis->OnThreadInit();

    do {
	lpThis->GetThreadMsg(&msg);
	lResult = lpThis->ThreadMessageProc(msg.uMsg,msg.dwFlags,
					    msg.lpParam, msg.pEvent);
    } while (lResult == 0L);

    // !!!
    CoUninitialize();

    return (DWORD)lResult;
}


// Block until the next message is placed on the list m_ThreadQueue.
// copies the message to the message pointed to by *pmsg
void
CMsgThread::GetThreadMsg(CMsg *msg)
{
    CMsg * pmsg = NULL;

    // keep trying until a message appears
    while (TRUE) {
        {
            CAutoLock lck(&m_Lock);
            pmsg = m_ThreadQueue.RemoveHead();
            if (pmsg == NULL) {
                m_lWaiting++;
            } else {
                break;
            }
        }
        // the semaphore will be signalled when it is non-empty
        WaitForSingleObject(m_hSem, INFINITE);
    }
    // copy fields to caller's CMsg
    *msg = *pmsg;

    // this CMsg was allocated by the 'new' in PutThreadMsg
    delete pmsg;

}


#ifndef UNICODE
// NOTE: as we need to use the same binaries on Win95 as on NT this code should
// be compiled WITHOUT unicode being defined.  Otherwise we will not pick up
// these internal routines and the binary will not run on Win95.

// Windows 95 doesn't implement this, so we provide an implementation.
LPWSTR
WINAPI
lstrcpyWInternal(
    LPWSTR lpString1,
    LPCWSTR lpString2
    )
{
    LPWSTR  lpReturn = lpString1;
    while (*lpString1++ = *lpString2++);

    return lpReturn;
}

// Windows 95 doesn't implement this, so we provide an implementation.
LPWSTR
WINAPI
lstrcpynWInternal(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int     iMaxLength
    )
{
    ASSERT(iMaxLength);
    LPWSTR  lpReturn = lpString1;
    if (iMaxLength) {
        while (--iMaxLength && (*lpString1++ = *lpString2++));

        // If we ran out of room (which will be the case if
        // iMaxLength is now 0) we still need to terminate the
        // string.
        if (!iMaxLength) *lpString1 = L'\0';
    }
    return lpReturn;
}

int
WINAPI
lstrcmpWInternal(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    do {
	WCHAR c1 = *lpString1;
	WCHAR c2 = *lpString2;
	if (c1 != c2)
	    return (int) c1 - (int) c2;
    } while (*lpString1++ && *lpString2++);
    return 0;
}


int
WINAPI
lstrcmpiWInternal(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    do {
	WCHAR c1 = *lpString1;
	WCHAR c2 = *lpString2;
	if (c1 >= L'A' && c1 <= L'Z')
	    c1 -= (WCHAR) (L'A' - L'a');
	if (c2 >= L'A' && c2 <= L'Z')
	    c2 -= (WCHAR) (L'A' - L'a');
	
	if (c1 != c2)
	    return (int) c1 - (int) c2;
    } while (*lpString1++ && *lpString2++);

    return 0;
}


int
WINAPI
lstrlenWInternal(
    LPCWSTR lpString
    )
{
    int i = -1;
    while (*(lpString+(++i)))
        ;
    return i;
}

#endif // NOT UNICODE


#ifndef UNICODE
int WINAPIV wsprintfWInternal(LPWSTR wszOut, LPCWSTR pszFmt, ...)
{
    char fmt[256]; // !!!
    char ach[256]; // !!!
    int i;

    va_list va;
    va_start(va, pszFmt);
    WideCharToMultiByte(GetACP(), 0, pszFmt, -1, fmt, 256, NULL, NULL);
    i = wvsprintf(ach, fmt, va);
    va_end(va);

    MultiByteToWideChar(CP_ACP, 0, ach, -1, wszOut, i+1);

    return i;
}
#endif

// Helper function - convert int to WSTR
void WINAPI IntToWstr(int i, LPWSTR wstr)
{
#ifdef UNICODE
    wsprintf(wstr, L"%d", i);
#else
    TCHAR temp[32];
    wsprintf(temp, "%d", i);
    MultiByteToWideChar(CP_ACP, 0, temp, -1, wstr, 32);
#endif
} // IntToWstr


#if 0
void * memchrInternal(const void *pv, int c, size_t sz)
{
    BYTE *pb = (BYTE *) pv;
    while (sz--) {
	if (*pb == c)
	    return (void *) pb;
	pb++;
    }
    return NULL;
}
#endif


#define MEMORY_ALIGNMENT        4
#define MEMORY_ALIGNMENT_LOG2   2
#define MEMORY_ALIGNMENT_MASK   MEMORY_ALIGNMENT - 1

void * __stdcall memmoveInternal(void * dst, const void * src, size_t count)
{
    void * ret = dst;

#ifdef _X86_
    if (dst <= src || (char *)dst >= ((char *)src + count)) {

        /*
         * Non-Overlapping Buffers
         * copy from lower addresses to higher addresses
         */
        _asm {
            mov     esi,src
            mov     edi,dst
            mov     ecx,count
            cld
            mov     edx,ecx
            and     edx,MEMORY_ALIGNMENT_MASK
            shr     ecx,MEMORY_ALIGNMENT_LOG2
            rep     movsd
            or      ecx,edx
            jz      memmove_done
            rep     movsb
memmove_done:
        }
    }
    else {

        /*
         * Overlapping Buffers
         * copy from higher addresses to lower addresses
         */
        _asm {
            mov     esi,src
            mov     edi,dst
            mov     ecx,count
            std
            add     esi,ecx
            add     edi,ecx
            dec     esi
            dec     edi
            rep     movsb
            cld
        }
    }
#else
    MoveMemory(dst, src, count);
#endif

    return ret;
}

/*  Arithmetic functions to help with time format conversions
*/

/*   Compute (a * b + d) / c */
LONGLONG WINAPI llMulDiv(LONGLONG a, LONGLONG b, LONGLONG c, LONGLONG d)
{
    /*  Compute the absolute values to avoid signed arithmetic problems */
    ULARGE_INTEGER ua, ub;
    DWORDLONG uc;

    ua.QuadPart = (DWORDLONG)(a >= 0 ? a : -a);
    ub.QuadPart = (DWORDLONG)(b >= 0 ? b : -b);
    uc          = (DWORDLONG)(c >= 0 ? c : -c);
    BOOL bSign = (a < 0) ^ (b < 0);

    /*  Do long multiplication */
    ULARGE_INTEGER p[2];
    p[0].QuadPart  = UInt32x32To64(ua.LowPart, ub.LowPart);

    /*  This next computation cannot overflow into p[1].HighPart because
        the max number we can compute here is:

                 (2 ** 32 - 1) * (2 ** 32 - 1) +  // ua.LowPart * ub.LowPart
    (2 ** 32) *  (2 ** 31) * (2 ** 32 - 1) * 2    // x.LowPart * y.HighPart * 2

    == 2 ** 96 - 2 ** 64 + (2 ** 64 - 2 ** 33 + 1)
    == 2 ** 96 - 2 ** 33 + 1
    < 2 ** 96
    */

    ULARGE_INTEGER x;
    x.QuadPart     = UInt32x32To64(ua.LowPart, ub.HighPart) +
                     UInt32x32To64(ua.HighPart, ub.LowPart) +
                     p[0].HighPart;
    p[0].HighPart  = x.LowPart;
    p[1].QuadPart  = UInt32x32To64(ua.HighPart, ub.HighPart) + x.HighPart;

    if (d != 0) {
        ULARGE_INTEGER ud[2];
        if (bSign) {
            ud[0].QuadPart = (DWORDLONG)(-d);
            if (d > 0) {
                /*  -d < 0 */
                ud[1].QuadPart = (DWORDLONG)(LONGLONG)-1;
            } else {
                ud[1].QuadPart = (DWORDLONG)0;
            }
        } else {
            ud[0].QuadPart = (DWORDLONG)d;
            if (d < 0) {
                ud[1].QuadPart = (DWORDLONG)(LONGLONG)-1;
            } else {
                ud[1].QuadPart = (DWORDLONG)0;
            }
        }
        /*  Now do extended addition */
        ULARGE_INTEGER uliTotal;

        /*  Add ls DWORDs */
        uliTotal.QuadPart  = (DWORDLONG)ud[0].LowPart + p[0].LowPart;
        p[0].LowPart       = uliTotal.LowPart;

        /*  Propagate carry */
        uliTotal.LowPart   = uliTotal.HighPart;
        uliTotal.HighPart  = 0;

        /*  Add 2nd most ls DWORDs */
        uliTotal.QuadPart += (DWORDLONG)ud[0].HighPart + p[0].HighPart;
        p[0].HighPart      = uliTotal.LowPart;

        /*  Propagate carry */
        uliTotal.LowPart   = uliTotal.HighPart;
        uliTotal.HighPart  = 0;

        /*  Add MS DWORDLONGs - no carry expected */
        p[1].QuadPart     += ud[1].QuadPart + uliTotal.QuadPart;

        /*  Now see if we got a sign change from the addition */
        if ((LONG)p[1].HighPart < 0) {
            bSign = !bSign;

            /*  Negate the current value (ugh!) */
            p[0].QuadPart  = ~p[0].QuadPart;
            p[1].QuadPart  = ~p[1].QuadPart;
            p[0].QuadPart += 1;
            p[1].QuadPart += (p[0].QuadPart == 0);
        }
    }

    /*  Now for the division */
    if (c < 0) {
        bSign = !bSign;
    }


    /*  This will catch c == 0 and overflow */
    if (uc <= p[1].QuadPart) {
        return bSign ? (LONGLONG)0x8000000000000000 :
                       (LONGLONG)0x7FFFFFFFFFFFFFFF;
    }

    DWORDLONG ullResult;

    /*  Do the division */
    /*  If the dividend is a DWORD_LONG use the compiler */
    if (p[1].QuadPart == 0) {
        ullResult = p[0].QuadPart / uc;
        return bSign ? -(LONGLONG)ullResult : (LONGLONG)ullResult;
    }

    /*  If the divisor is a DWORD then its simpler */
    ULARGE_INTEGER ulic;
    ulic.QuadPart = uc;
    if (ulic.HighPart == 0) {
        ULARGE_INTEGER uliDividend;
        ULARGE_INTEGER uliResult;
        DWORD dwDivisor = (DWORD)uc;
        // ASSERT(p[1].HighPart == 0 && p[1].LowPart < dwDivisor);
        uliDividend.HighPart = p[1].LowPart;
        uliDividend.LowPart = p[0].HighPart;
#ifndef USE_LARGEINT
        uliResult.HighPart = (DWORD)(uliDividend.QuadPart / dwDivisor);
        p[0].HighPart = (DWORD)(uliDividend.QuadPart % dwDivisor);
        uliResult.LowPart = 0;
        uliResult.QuadPart = p[0].QuadPart / dwDivisor + uliResult.QuadPart;
#else
        /*  NOTE - this routine will take exceptions if
            the result does not fit in a DWORD
        */
        if (uliDividend.QuadPart >= (DWORDLONG)dwDivisor) {
            uliResult.HighPart = EnlargedUnsignedDivide(
                                     uliDividend,
                                     dwDivisor,
                                     &p[0].HighPart);
        } else {
            uliResult.HighPart = 0;
        }
        uliResult.LowPart = EnlargedUnsignedDivide(
                                 p[0],
                                 dwDivisor,
                                 NULL);
#endif
        return bSign ? -(LONGLONG)uliResult.QuadPart :
                        (LONGLONG)uliResult.QuadPart;
    }


    ullResult = 0;

    /*  OK - do long division */
    for (int i = 0; i < 64; i++) {
        ullResult <<= 1;

        /*  Shift 128 bit p left 1 */
        p[1].QuadPart <<= 1;
        if ((p[0].HighPart & 0x80000000) != 0) {
            p[1].LowPart++;
        }
        p[0].QuadPart <<= 1;

        /*  Compare */
        if (uc <= p[1].QuadPart) {
            p[1].QuadPart -= uc;
            ullResult += 1;
        }
    }

    return bSign ? - (LONGLONG)ullResult : (LONGLONG)ullResult;
}


LONGLONG WINAPI Int64x32Div32(LONGLONG a, LONG b, LONG c, LONG d)
{
    ULARGE_INTEGER ua;
    DWORD ub;
    DWORD uc;

    /*  Compute the absolute values to avoid signed arithmetic problems */
    ua.QuadPart = (DWORDLONG)(a >= 0 ? a : -a);
    ub = (DWORD)(b >= 0 ? b : -b);
    uc = (DWORD)(c >= 0 ? c : -c);
    BOOL bSign = (a < 0) ^ (b < 0);

    /*  Do long multiplication */
    ULARGE_INTEGER p0;
    DWORD p1;
    p0.QuadPart  = UInt32x32To64(ua.LowPart, ub);

    if (ua.HighPart != 0) {
        ULARGE_INTEGER x;
        x.QuadPart     = UInt32x32To64(ua.HighPart, ub) + p0.HighPart;
        p0.HighPart  = x.LowPart;
        p1   = x.HighPart;
    } else {
        p1 = 0;
    }

    if (d != 0) {
        ULARGE_INTEGER ud0;
        DWORD ud1;

        if (bSign) {
            //
            //  Cast d to LONGLONG first otherwise -0x80000000 sign extends
            //  incorrectly
            //
            ud0.QuadPart = (DWORDLONG)(-(LONGLONG)d);
            if (d > 0) {
                /*  -d < 0 */
                ud1 = (DWORD)-1;
            } else {
                ud1 = (DWORD)0;
            }
        } else {
            ud0.QuadPart = (DWORDLONG)d;
            if (d < 0) {
                ud1 = (DWORD)-1;
            } else {
                ud1 = (DWORD)0;
            }
        }
        /*  Now do extended addition */
        ULARGE_INTEGER uliTotal;

        /*  Add ls DWORDs */
        uliTotal.QuadPart  = (DWORDLONG)ud0.LowPart + p0.LowPart;
        p0.LowPart       = uliTotal.LowPart;

        /*  Propagate carry */
        uliTotal.LowPart   = uliTotal.HighPart;
        uliTotal.HighPart  = 0;

        /*  Add 2nd most ls DWORDs */
        uliTotal.QuadPart += (DWORDLONG)ud0.HighPart + p0.HighPart;
        p0.HighPart      = uliTotal.LowPart;

        /*  Add MS DWORDLONGs - no carry expected */
        p1 += ud1 + uliTotal.HighPart;

        /*  Now see if we got a sign change from the addition */
        if ((LONG)p1 < 0) {
            bSign = !bSign;

            /*  Negate the current value (ugh!) */
            p0.QuadPart  = ~p0.QuadPart;
            p1 = ~p1;
            p0.QuadPart += 1;
            p1 += (p0.QuadPart == 0);
        }
    }

    /*  Now for the division */
    if (c < 0) {
        bSign = !bSign;
    }


    /*  This will catch c == 0 and overflow */
    if (uc <= p1) {
        return bSign ? (LONGLONG)0x8000000000000000 :
                       (LONGLONG)0x7FFFFFFFFFFFFFFF;
    }

    /*  Do the division */

    /*  If the divisor is a DWORD then its simpler */
    ULARGE_INTEGER uliDividend;
    ULARGE_INTEGER uliResult;
    DWORD dwDivisor = uc;
    uliDividend.HighPart = p1;
    uliDividend.LowPart = p0.HighPart;
    /*  NOTE - this routine will take exceptions if
        the result does not fit in a DWORD
    */
    if (uliDividend.QuadPart >= (DWORDLONG)dwDivisor) {
        uliResult.HighPart = EnlargedUnsignedDivide(
                                 uliDividend,
                                 dwDivisor,
                                 &p0.HighPart);
    } else {
        uliResult.HighPart = 0;
    }
    uliResult.LowPart = EnlargedUnsignedDivide(
                             p0,
                             dwDivisor,
                             NULL);
    return bSign ? -(LONGLONG)uliResult.QuadPart :
                    (LONGLONG)uliResult.QuadPart;
}

#ifdef DEBUG
/******************************Public*Routine******************************\
* Debug CCritSec helpers
*
* We provide debug versions of the Constructor, destructor, Lock and Unlock
* routines.  The debug code tracks who owns each critical section by
* maintaining a depth count.
*
* History:
*
\**************************************************************************/

CCritSec::CCritSec()
{
    InitializeCriticalSection(&m_CritSec);
    m_currentOwner = m_lockCount = 0;
    m_fTrace = FALSE;
}

CCritSec::~CCritSec()
{
    DeleteCriticalSection(&m_CritSec);
}

void CCritSec::Lock()
{
    UINT tracelevel=3;
    DWORD us = GetCurrentThreadId();
    DWORD currentOwner = m_currentOwner;
    if (currentOwner && (currentOwner != us)) {
        // already owned, but not by us
        if (m_fTrace) {
            DbgLog((LOG_LOCKING, 2, TEXT("Thread %d about to wait for lock %x owned by %d"),
                GetCurrentThreadId(), &m_CritSec, currentOwner));
            tracelevel=2;
	    // if we saw the message about waiting for the critical
	    // section we ensure we see the message when we get the
	    // critical section
        }
    }
    EnterCriticalSection(&m_CritSec);
    if (0 == m_lockCount++) {
        // we now own it for the first time.  Set owner information
        m_currentOwner = us;
	//ASSERT(((PRTL_CRITICAL_SECTION)&m_CritSec)->OwningThread == (HANDLE)m_currentOwner);
	// only valid on NT
        if (m_fTrace) {
            DbgLog((LOG_LOCKING, tracelevel, TEXT("Thread %d now owns lock %x"), m_currentOwner, &m_CritSec));
        }
    }
}

void CCritSec::Unlock() {
    if (0 == --m_lockCount) {
        // about to be unowned
        if (m_fTrace) {
            DbgLog((LOG_LOCKING, 3, TEXT("Thread %d releasing lock %x"), m_currentOwner, &m_CritSec));
	    //ASSERT(((PRTL_CRITICAL_SECTION)&m_CritSec)->OwningThread == (HANDLE)m_currentOwner);
	    // only valid on NT
        }
        m_currentOwner = 0;
    }
    LeaveCriticalSection(&m_CritSec);
}

void WINAPI DbgLockTrace(CCritSec * pcCrit, BOOL fTrace)
{
    pcCrit->m_fTrace = fTrace;
}

BOOL WINAPI CritCheckIn(CCritSec * pcCrit)
{
    return (GetCurrentThreadId() == pcCrit->m_currentOwner);
}

BOOL WINAPI CritCheckOut(CCritSec * pcCrit)
{
    return (GetCurrentThreadId() != pcCrit->m_currentOwner);
}
#endif


typedef BSTR (STDAPICALLTYPE *LPSYSALLOCSTRING)(const OLECHAR FAR *);

// Dyna-link to SysAllocString to copy BSTR strings

STDAPI WriteBSTR(BSTR *pstrDest, LPCWSTR szSrc)
{
    LPSYSALLOCSTRING	lpfnSysAllocString;
    HINSTANCE		hInst;
    static const char	szSysAllocString[]	  = "SysAllocString";

    //
    // Try to get the Ole32Aut.dll module handle.
    //

    hInst = LoadOLEAut32();
    if (hInst == NULL) {
	DWORD dwError = GetLastError();
	return HRESULT_FROM_WIN32(dwError);
    }
    lpfnSysAllocString = (LPSYSALLOCSTRING)GetProcAddress(hInst,
							  szSysAllocString);
    if (lpfnSysAllocString == NULL) {
	DWORD dwError = GetLastError();
	return HRESULT_FROM_WIN32(dwError);
    }

    *pstrDest = (*lpfnSysAllocString)(szSrc);

    return S_OK;
}


// Free an OLE BSTR through the task allocator

STDAPI FreeBSTR(BSTR* pstr)
{
    if (*pstr != NULL) {
        // get pointer to string
        DWORD* p = (DWORD*) (*pstr);

        // back up to point at DWORD length
        p--;

        // set pointer to null
        *pstr = NULL;

        // and free this
        CoTaskMemFree(p);

        return S_OK;
    } else {
        return S_FALSE;
    }
}


// Return a wide string - allocating memory for it
// Returns:
//    S_OK          - no error
//    E_POINTER     - ppszReturn == NULL
//    E_OUTOFMEMORY - can't allocate memory for returned string
STDAPI AMGetWideString(LPCWSTR psz, LPWSTR *ppszReturn)
{
    CheckPointer(ppszReturn, E_POINTER);
    ValidateReadWritePtr(ppszReturn, sizeof(LPWSTR));
    DWORD nameLen = sizeof(WCHAR) * (lstrlenW(psz)+1);
    *ppszReturn = (LPWSTR)CoTaskMemAlloc(nameLen);
    if (*ppszReturn == NULL) {
       return E_OUTOFMEMORY;
    }
    CopyMemory(*ppszReturn, psz, nameLen);
    return NOERROR;
}

// Waits for the HANDLE hObject.  While waiting messages sent
// to windows on our thread by SendMessage will be processed.
// Using this function to do waits and mutual exclusion
// avoids some deadlocks in objects with windows.
// Return codes are the same as for WaitForSingleObject
DWORD WINAPI WaitDispatchingMessages(HANDLE hObject, DWORD dwWait, HWND hwnd, UINT uMsg)
{
    BOOL bPeeked = FALSE;
    DWORD dwResult;
    DWORD dwStart;
    DWORD dwThreadPriority;
    if (dwWait != INFINITE && dwWait != 0) {
        dwStart = GetTickCount();
    }
    for (; ; ) {
        DWORD dwTimeOut = dwWait;
        if (dwTimeOut > 10) {
            dwTimeOut = 10;
        }
        dwResult = MsgWaitForMultipleObjects(
                             1,
                             &hObject,
                             FALSE,
                             dwTimeOut,
                             hwnd == NULL ? QS_SENDMESSAGE :
                                            QS_SENDMESSAGE + QS_POSTMESSAGE);
        if (dwResult == WAIT_OBJECT_0 + 1 ||
            dwResult == WAIT_TIMEOUT && dwTimeOut != dwWait) {
            MSG msg;
            if (hwnd != NULL) {
                while (PeekMessage(&msg, hwnd, uMsg, uMsg, PM_REMOVE)) {
                    DispatchMessage(&msg);
                }
            }
            // Do this anyway - the previous peek doesn't flush out the
            // messages
            PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);

            if (dwWait != INFINITE && dwWait != 0) {
                DWORD dwNow = GetTickCount();

                // Working with differences handles wrap-around
                DWORD dwDiff = dwNow - dwStart;
                if (dwDiff > dwWait) {
                    dwWait = 0;
                } else {
                    dwWait -= dwDiff;
                }
                dwStart = dwNow;
            }
            if (!bPeeked) {
                //  Raise our priority to prevent our message queue
                //  building up
                dwThreadPriority = GetThreadPriority(GetCurrentThread());
                if (dwThreadPriority < THREAD_PRIORITY_HIGHEST) {
                    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);
                }
                bPeeked = TRUE;
            }
        } else {
            break;
        }
    }
    if (bPeeked) {
        SetThreadPriority(GetCurrentThread(), dwThreadPriority);
        if (HIWORD(GetQueueStatus(QS_POSTMESSAGE)) & QS_POSTMESSAGE) {
            //  Send dummy message
            PostThreadMessage(GetCurrentThreadId(), WM_NULL, 0, 0);
        }
    }
    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\wxlist.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Non MFC based generic list template class, December 1994

/* A generic list of pointers to objects.
   Objectives: avoid using MFC libraries in ndm kernel mode and
   provide a really useful list type.

   The class is thread safe in that separate threads may add and
   delete items in the list concurrently although the application
   must ensure that constructor and destructor access is suitably
   synchronised.

   The list name must not conflict with MFC classes as an
   application may use both

   The nodes form a doubly linked, NULL terminated chain with an anchor
   block (the list object per se) holding pointers to the first and last
   nodes and a count of the nodes.
   There is a node cache to reduce the allocation and freeing overhead.
   It optionally (determined at construction time) has an Event which is
   set whenever the list becomes non-empty and reset whenever it becomes
   empty.
   It optionally (determined at construction time) has a Critical Section
   which is entered during the important part of each operation.  (About
   all you can do outside it is some parameter checking).

   The node cache is a repository of nodes that are NOT in the list to speed
   up storage allocation.  Each list has its own cache to reduce locking and
   serialising.  The list accesses are serialised anyway for a given list - a
   common cache would mean that we would have to separately serialise access
   of all lists within the cache.  Because the cache only stores nodes that are
   not in the list, releasing the cache does not release any list nodes.  This
   means that list nodes can be copied or rechained from one list to another
   without danger of creating a dangling reference if the original cache goes
   away.

   Questionable design decisions:
   1. Retaining the warts for compatibility
   2. Keeping an element count -i.e. counting whenever we do anything
      instead of only when we want the count.
   3. Making the chain pointers NULL terminated.  If the list object
      itself looks just like a node and the list is kept as a ring then
      it reduces the number of special cases.  All inserts look the same.
*/


#include <streams.h>

/* set cursor to the position of each element of list in turn  */
#define INTERNALTRAVERSELIST(list, cursor)               \
for ( cursor = (list).GetHeadPositionI()           \
    ; cursor!=NULL                               \
    ; cursor = (list).Next(cursor)                \
    )


/* set cursor to the position of each element of list in turn
   in reverse order
*/
#define INTERNALREVERSETRAVERSELIST(list, cursor)        \
for ( cursor = (list).GetTailPositionI()           \
    ; cursor!=NULL                               \
    ; cursor = (list).Prev(cursor)                \
    )

/* Constructor calls a separate initialisation function that
   creates a node cache, optionally creates a lock object
   and optionally creates a signaling object.

   By default we create a locking object, a DEFAULTCACHE sized
   cache but no event object so the list cannot be used in calls
   to WaitForSingleObject
*/
CBaseList::CBaseList(TCHAR *pName,    // Descriptive list name
                     INT iItems) :    // Node cache size
#ifdef DEBUG
    CBaseObject(pName),
#endif
    m_pFirst(NULL),
    m_pLast(NULL),
    m_Count(0),
    m_Cache(iItems)
{
} // constructor

CBaseList::CBaseList(TCHAR *pName) :  // Descriptive list name
#ifdef DEBUG
    CBaseObject(pName),
#endif
    m_pFirst(NULL),
    m_pLast(NULL),
    m_Count(0),
    m_Cache(DEFAULTCACHE)
{
} // constructor


/* The destructor enumerates all the node objects in the list and
   in the cache deleting each in turn. We do not do any processing
   on the objects that the list holds (i.e. points to) so if they
   represent interfaces for example the creator of the list should
   ensure that each of them is released before deleting us
*/
CBaseList::~CBaseList()
{
    /* Delete all our list nodes */

    RemoveAll();

} // destructor

/* Remove all the nodes from the list but don't do anything
   with the objects that each node looks after (this is the
   responsibility of the creator).
   Aa a last act we reset the signalling event
   (if available) to indicate to clients that the list
   does not have any entries in it.
*/
void CBaseList::RemoveAll()
{
    /* Free up all the CNode objects NOTE we don't bother putting the
       deleted nodes into the cache as this method is only really called
       in serious times of change such as when we are being deleted at
       which point the cache will be deleted anway */

    CNode *pn = m_pFirst;
    while (pn) {
        CNode *op = pn;
        pn = pn->Next();
        delete op;
    }

    /* Reset the object count and the list pointers */

    m_Count = 0;
    m_pFirst = m_pLast = NULL;

} // RemoveAll



/* Return a position enumerator for the entire list.
   A position enumerator is a pointer to a node object cast to a
   transparent type so all we do is return the head/tail node
   pointer in the list.
   WARNING because the position is a pointer to a node there is
   an implicit assumption for users a the list class that after
   deleting an object from the list that any other position
   enumerators that you have may be invalid (since the node
   may be gone).
*/
POSITION CBaseList::GetHeadPositionI() const
{
    return (POSITION) m_pFirst;
} // GetHeadPosition



POSITION CBaseList::GetTailPositionI() const
{
    return (POSITION) m_pLast;
} // GetTailPosition



/* Get the number of objects in the list,
   Get the lock before accessing the count.
   Locking may not be entirely necessary but it has the side effect
   of making sure that all operations are complete before we get it.
   So for example if a list is being added to this list then that
   will have completed in full before we continue rather than seeing
   an intermediate albeit valid state
*/
int CBaseList::GetCountI() const
{
    return m_Count;
} // GetCount



/* Return the object at rp, update rp to the next object from
   the list or NULL if you have moved over the last object.
   You may still call this function once we return NULL but
   we will continue to return a NULL position value
*/
void *CBaseList::GetNextI(POSITION& rp) const
{
    /* have we reached the end of the list */

    if (rp == NULL) {
        return NULL;
    }

    /* Lock the object before continuing */

    void *pObject;

    /* Copy the original position then step on */

    CNode *pn = (CNode *) rp;
    ASSERT(pn != NULL);
    rp = (POSITION) pn->Next();

    /* Get the object at the original position from the list */

    pObject = pn->GetData();
    // ASSERT(pObject != NULL);    // NULL pointers in the list are allowed.
    return pObject;
} //GetNext



/* Return the object at p.
   Asking for the object at NULL ASSERTs then returns NULL
   The object is NOT locked.  The list is not being changed
   in any way.  If another thread is busy deleting the object
   then locking would only result in a change from one bad
   behaviour to another.
*/
void *CBaseList::GetI(POSITION p) const
{
    if (p == NULL) {
        return NULL;
    }

    CNode * pn = (CNode *) p;
    void *pObject = pn->GetData();
    // ASSERT(pObject != NULL);    // NULL pointers in the list are allowed.
    return pObject;
} //Get



/* Return the first position in the list which holds the given pointer.
   Return NULL if it's not found.
*/
POSITION CBaseList::FindI( void * pObj) const
{
    POSITION pn;
    INTERNALTRAVERSELIST(*this, pn){
        if (GetI(pn)==pObj) {
            return pn;
        }
    }
    return NULL;
} // Find



/* Remove the first node in the list (deletes the pointer to its object
   from the list, does not free the object itself).
   Return the pointer to its object or NULL if empty
*/
void *CBaseList::RemoveHeadI()
{
    /* All we do is get the head position and ask for that to be deleted.
       We could special case this since some of the code path checking
       in Remove() is redundant as we know there is no previous
       node for example but it seems to gain little over the
       added complexity
    */

    return RemoveI((POSITION)m_pFirst);
} // RemoveHead



/* Remove the last node in the list (deletes the pointer to its object
   from the list, does not free the object itself).
   Return the pointer to its object or NULL if empty
*/
void *CBaseList::RemoveTailI()
{
    /* All we do is get the tail position and ask for that to be deleted.
       We could special case this since some of the code path checking
       in Remove() is redundant as we know there is no previous
       node for example but it seems to gain little over the
       added complexity
    */

    return RemoveI((POSITION)m_pLast);
} // RemoveTail



/* Remove the pointer to the object in this position from the list.
   Deal with all the chain pointers
   Return a pointer to the object removed from the list.
   The node object that is freed as a result
   of this operation is added to the node cache where
   it can be used again.
   Remove(NULL) is a harmless no-op - but probably is a wart.
*/
void *CBaseList::RemoveI(POSITION pos)
{
    /* Lock the critical section before continuing */

    // ASSERT (pos!=NULL);     // Removing NULL is to be harmless!
    if (pos==NULL) return NULL;


    CNode *pCurrent = (CNode *) pos;
    ASSERT(pCurrent != NULL);

    /* Update the previous node */

    CNode *pNode = pCurrent->Prev();
    if (pNode == NULL) {
        m_pFirst = pCurrent->Next();
    } else {
        pNode->SetNext(pCurrent->Next());
    }

    /* Update the following node */

    pNode = pCurrent->Next();
    if (pNode == NULL) {
        m_pLast = pCurrent->Prev();
    } else {
        pNode->SetPrev(pCurrent->Prev());
    }

    /* Get the object this node was looking after */

    void *pObject = pCurrent->GetData();

    // ASSERT(pObject != NULL);    // NULL pointers in the list are allowed.

    /* Try and add the node object to the cache -
       a NULL return code from the cache means we ran out of room.
       The cache size is fixed by a constructor argument when the
       list is created and defaults to DEFAULTCACHE.
       This means that the cache will have room for this many
       node objects. So if you have a list of media samples
       and you know there will never be more than five active at
       any given time of them for example then override the default
       constructor
    */

    m_Cache.AddToCache(pCurrent);

    /* If the list is empty then reset the list event */

    --m_Count;
    ASSERT(m_Count >= 0);
    return pObject;
} // Remove



/* Add this object to the tail end of our list
   Return the new tail position.
*/

POSITION CBaseList::AddTailI(void *pObject)
{
    /* Lock the critical section before continuing */

    CNode *pNode;
    // ASSERT(pObject);   // NULL pointers in the list are allowed.

    /* If there is a node objects in the cache then use
       that otherwise we will have to create a new one */

    pNode = (CNode *) m_Cache.RemoveFromCache();
    if (pNode == NULL) {
        pNode = new CNode;
    }

    /* Check we have a valid object */

    ASSERT(pNode != NULL);
    if (pNode == NULL) {
        return NULL;
    }

    /* Initialise all the CNode object
       just in case it came from the cache
    */

    pNode->SetData(pObject);
    pNode->SetNext(NULL);
    pNode->SetPrev(m_pLast);

    if (m_pLast == NULL) {
        m_pFirst = pNode;
    } else {
        m_pLast->SetNext(pNode);
    }

    /* Set the new last node pointer and also increment the number
       of list entries, the critical section is unlocked when we
       exit the function
    */

    m_pLast = pNode;
    ++m_Count;

    return (POSITION) pNode;
} // AddTail(object)



/* Add this object to the head end of our list
   Return the new head position.
*/
POSITION CBaseList::AddHeadI(void *pObject)
{
    CNode *pNode;
    // ASSERT(pObject);  // NULL pointers in the list are allowed.

    /* If there is a node objects in the cache then use
       that otherwise we will have to create a new one */

    pNode = (CNode *) m_Cache.RemoveFromCache();
    if (pNode == NULL) {
        pNode = new CNode;
    }

    /* Check we have a valid object */

    ASSERT(pNode != NULL);
    if (pNode == NULL) {
        return NULL;
    }

    /* Initialise all the CNode object
       just in case it came from the cache
    */

    pNode->SetData(pObject);

    /* chain it in (set four pointers) */
    pNode->SetPrev(NULL);
    pNode->SetNext(m_pFirst);

    if (m_pFirst == NULL) {
        m_pLast = pNode;
    } else {
        m_pFirst->SetPrev(pNode);
    }
    m_pFirst = pNode;

    ++m_Count;

    return (POSITION) pNode;
} // AddHead(object)



/* Add all the elements in *pList to the tail of this list.
   Return TRUE if it all worked, FALSE if it didn't.
   If it fails some elements may have been added.
*/
BOOL CBaseList::AddTail(CBaseList *pList)
{
    /* lock the object before starting then enumerate
       each entry in the source list and add them one by one to
       our list (while still holding the object lock)
       Lock the other list too.
    */
    POSITION pos = pList->GetHeadPositionI();

    while (pos) {
       if (NULL == AddTailI(pList->GetNextI(pos))) {
           return FALSE;
       }
    }
    return TRUE;
} // AddTail(list)



/* Add all the elements in *pList to the head of this list.
   Return TRUE if it all worked, FALSE if it didn't.
   If it fails some elements may have been added.
*/
BOOL CBaseList::AddHead(CBaseList *pList)
{
    /* lock the object before starting then enumerate
       each entry in the source list and add them one by one to
       our list (while still holding the object lock)
       Lock the other list too.

       To avoid reversing the list, traverse it backwards.
    */

    POSITION pos;

    INTERNALREVERSETRAVERSELIST(*pList, pos) {
        if (NULL== AddHeadI(pList->GetI(pos))){
            return FALSE;
        }
    }
    return TRUE;
} // AddHead(list)



/* Add the object after position p
   p is still valid after the operation.
   AddAfter(NULL,x) adds x to the start - same as AddHead
   Return the position of the new object, NULL if it failed
*/
POSITION  CBaseList::AddAfterI(POSITION pos, void * pObj)
{
    if (pos==NULL)
        return AddHeadI(pObj);

    /* As someone else might be furkling with the list -
       Lock the critical section before continuing
    */
    CNode *pAfter = (CNode *) pos;
    ASSERT(pAfter != NULL);
    if (pAfter==m_pLast)
        return AddTailI(pObj);

    /* set pnode to point to a new node, preferably from the cache */

    CNode *pNode = (CNode *) m_Cache.RemoveFromCache();
    if (pNode == NULL) {
        pNode = new CNode;
    }

    /* Check we have a valid object */

    ASSERT(pNode != NULL);
    if (pNode == NULL) {
        return NULL;
    }

    /* Initialise all the CNode object
       just in case it came from the cache
    */

    pNode->SetData(pObj);

    /* It is to be added to the middle of the list - there is a before
       and after node.  Chain it after pAfter, before pBefore.
    */
    CNode * pBefore = pAfter->Next();
    ASSERT(pBefore != NULL);

    /* chain it in (set four pointers) */
    pNode->SetPrev(pAfter);
    pNode->SetNext(pBefore);
    pBefore->SetPrev(pNode);
    pAfter->SetNext(pNode);

    ++m_Count;

    return (POSITION) pNode;

} // AddAfter(object)



BOOL CBaseList::AddAfter(POSITION p, CBaseList *pList)
{
    POSITION pos;
    INTERNALTRAVERSELIST(*pList, pos) {
        /* p follows along the elements being added */
        p = AddAfterI(p, pList->GetI(pos));
        if (p==NULL) return FALSE;
    }
    return TRUE;
} // AddAfter(list)



/* Mirror images:
   Add the element or list after position p.
   p is still valid after the operation.
   AddBefore(NULL,x) adds x to the end - same as AddTail
*/
POSITION CBaseList::AddBeforeI(POSITION pos, void * pObj)
{
    if (pos==NULL)
        return AddTailI(pObj);

    /* set pnode to point to a new node, preferably from the cache */

    CNode *pBefore = (CNode *) pos;
    ASSERT(pBefore != NULL);
    if (pBefore==m_pFirst)
        return AddHeadI(pObj);

    CNode * pNode = (CNode *) m_Cache.RemoveFromCache();
    if (pNode == NULL) {
        pNode = new CNode;
    }

    /* Check we have a valid object */

    ASSERT(pNode != NULL);
    if (pNode == NULL) {
        return NULL;
    }

    /* Initialise all the CNode object
       just in case it came from the cache
    */

    pNode->SetData(pObj);

    /* It is to be added to the middle of the list - there is a before
       and after node.  Chain it after pAfter, before pBefore.
    */

    CNode * pAfter = pBefore->Prev();
    ASSERT(pAfter != NULL);

    /* chain it in (set four pointers) */
    pNode->SetPrev(pAfter);
    pNode->SetNext(pBefore);
    pBefore->SetPrev(pNode);
    pAfter->SetNext(pNode);

    ++m_Count;

    return (POSITION) pNode;

} // Addbefore(object)



BOOL CBaseList::AddBefore(POSITION p, CBaseList *pList)
{
    POSITION pos;
    INTERNALREVERSETRAVERSELIST(*pList, pos) {
        /* p follows along the elements being added */
        p = AddBeforeI(p, pList->GetI(pos));
        if (p==NULL) return FALSE;
    }
    return TRUE;
} // AddBefore(list)



/* Split *this after position p in *this
   Retain as *this the tail portion of the original *this
   Add the head portion to the tail end of *pList
   Return TRUE if it all worked, FALSE if it didn't.

   e.g.
      foo->MoveToTail(foo->GetHeadPosition(), bar);
          moves one element from the head of foo to the tail of bar
      foo->MoveToTail(NULL, bar);
          is a no-op
      foo->MoveToTail(foo->GetTailPosition, bar);
          concatenates foo onto the end of bar and empties foo.

   A better, except excessively long name might be
       MoveElementsFromHeadThroughPositionToOtherTail
*/
BOOL CBaseList::MoveToTail
        (POSITION pos, CBaseList *pList)
{
    /* Algorithm:
       Note that the elements (including their order) in the concatenation
       of *pList to the head of *this is invariant.
       1. Count elements to be moved
       2. Join *pList onto the head of this to make one long chain
       3. Set first/Last pointers in *this and *pList
       4. Break the chain at the new place
       5. Adjust counts
       6. Set/Reset any events
    */

    if (pos==NULL) return TRUE;  // no-op.  Eliminates special cases later.


    /* Make cMove the number of nodes to move */
    CNode * p = (CNode *)pos;
    int cMove = 0;            // number of nodes to move
    while(p!=NULL) {
       p = p->Prev();
       ++cMove;
    }


    /* Join the two chains together */
    if (pList->m_pLast!=NULL)
        pList->m_pLast->SetNext(m_pFirst);
    if (m_pFirst!=NULL)
        m_pFirst->SetPrev(pList->m_pLast);


    /* set first and last pointers */
    p = (CNode *)pos;

    if (pList->m_pFirst==NULL)
        pList->m_pFirst = m_pFirst;
    m_pFirst = p->Next();
    if (m_pFirst==NULL)
        m_pLast = NULL;
    pList->m_pLast = p;


    /* Break the chain after p to create the new pieces */
    if (m_pFirst!=NULL)
        m_pFirst->SetPrev(NULL);
    p->SetNext(NULL);


    /* Adjust the counts */
    m_Count -= cMove;
    pList->m_Count += cMove;

    return TRUE;

} // MoveToTail



/* Mirror image of MoveToTail:
   Split *this before position p in *this.
   Retain in *this the head portion of the original *this
   Add the tail portion to the start (i.e. head) of *pList
   Return TRUE if it all worked, FALSE if it didn't.

   e.g.
      foo->MoveToHead(foo->GetTailPosition(), bar);
          moves one element from the tail of foo to the head of bar
      foo->MoveToHead(NULL, bar);
          is a no-op
      foo->MoveToHead(foo->GetHeadPosition, bar);
          concatenates foo onto the start of bar and empties foo.
*/
BOOL CBaseList::MoveToHead
        (POSITION pos, CBaseList *pList)
{

    /* See the comments on the algorithm in MoveToTail */

    if (pos==NULL) return TRUE;  // no-op.  Eliminates special cases later.

    /* Make cMove the number of nodes to move */
    CNode * p = (CNode *)pos;
    int cMove = 0;            // number of nodes to move
    while(p!=NULL) {
       p = p->Next();
       ++cMove;
    }


    /* Join the two chains together */
    if (pList->m_pFirst!=NULL)
        pList->m_pFirst->SetPrev(m_pLast);
    if (m_pLast!=NULL)
        m_pLast->SetNext(pList->m_pFirst);


    /* set first and last pointers */
    p = (CNode *)pos;


    if (pList->m_pLast==NULL)
        pList->m_pLast = m_pLast;

    m_pLast = p->Prev();
    if (m_pLast==NULL)
        m_pFirst = NULL;
    pList->m_pFirst = p;


    /* Break the chain after p to create the new pieces */
    if (m_pLast!=NULL)
        m_pLast->SetNext(NULL);
    p->SetPrev(NULL);


    /* Adjust the counts */
    m_Count -= cMove;
    pList->m_Count += cMove;

    return TRUE;

} // MoveToHead



/* Reverse the order of the [pointers to] objects in *this
*/
void CBaseList::Reverse()
{
    /* algorithm:
       The obvious booby trap is that you flip pointers around and lose
       addressability to the node that you are going to process next.
       The easy way to avoid this is do do one chain at a time.

       Run along the forward chain,
       For each node, set the reverse pointer to the one ahead of us.
       The reverse chain is now a copy of the old forward chain, including
       the NULL termination.

       Run along the reverse chain (i.e. old forward chain again)
       For each node set the forward pointer of the node ahead to point back
       to the one we're standing on.
       The first node needs special treatment,
       it's new forward pointer is NULL.
       Finally set the First/Last pointers

    */
    CNode * p;

    // Yes we COULD use a traverse, but it would look funny!
    p = m_pFirst;
    while (p!=NULL) {
        CNode * q;
        q = p->Next();
        p->SetNext(p->Prev());
        p->SetPrev(q);
        p = q;
    }

    p = m_pFirst;
    m_pFirst = m_pLast;
    m_pLast = p;


#if 0     // old version

    if (m_pFirst==NULL) return;          // empty list
    if (m_pFirst->Next()==NULL) return;  // single node list


    /* run along forward chain */
    for ( p = m_pFirst
        ; p!=NULL
        ; p = p->Next()
        ){
        p->SetPrev(p->Next());
    }


    /* special case first element */
    m_pFirst->SetNext(NULL);     // fix the old first element


    /* run along new reverse chain i.e. old forward chain again */
    for ( p = m_pFirst           // start at the old first element
        ; p->Prev()!=NULL        // while there's a node still to be set
        ; p = p->Prev()          // work in the same direction as before
        ){
        p->Prev()->SetNext(p);
    }


    /* fix forward and reverse pointers
       - the triple XOR swap would work but all the casts look hideous */
    p = m_pFirst;
    m_pFirst = m_pLast;
    m_pLast = p;
#endif

} // Reverse
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\synth\onef\isynth.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// isynth.h
//
// A custom interface to allow the user to adjust the frequency

#ifndef __ISYNTH__
#define __ISYNTH__

#ifdef __cplusplus
extern "C" {
#endif


//
// ISynth's GUID
//
// {FFC08882-CDAC-11ce-8A03-00AA006ECB65}
DEFINE_GUID(IID_ISynth,
0xffc08882, 0xcdac, 0x11ce, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65);


//
// ISynth
//
DECLARE_INTERFACE_(ISynth, IUnknown) {

    STDMETHOD(get_Frequency) (THIS_
                int *Frequency          /* [out] */    // the current frequency
             ) PURE;

    STDMETHOD(put_Frequency) (THIS_
                int    Frequency        /* [in] */    // Change to this frequency
             ) PURE;

    STDMETHOD(get_Waveform) (THIS_
                int *Waveform           /* [out] */    // the current Waveform
             ) PURE;

    STDMETHOD(put_Waveform) (THIS_
                int    Waveform         /* [in] */    // Change to this Waveform
             ) PURE;

    STDMETHOD(get_Channels) (THIS_
                int *Channels           /* [out] */    // the current Channels
             ) PURE;

    STDMETHOD(put_Channels) (THIS_
                int    Channels         /* [in] */    // Change to this Channels
             ) PURE;

    STDMETHOD(get_BitsPerSample) (THIS_
                int *BitsPerSample      /* [out] */    // the current BitsPerSample
             ) PURE;

    STDMETHOD(put_BitsPerSample) (THIS_
                int    BitsPerSample    /* [in] */    // Change to this BitsPerSample
             ) PURE;

    STDMETHOD(get_SamplesPerSec) (THIS_
                 int *SamplesPerSec     /* [out] */    // the current SamplesPerSec
             ) PURE;

    STDMETHOD(put_SamplesPerSec) (THIS_
                  int    SamplesPerSec  /* [in] */    // Change to this SamplesPerSec
             ) PURE;

    STDMETHOD(get_Amplitude) (THIS_
                  int *Amplitude        /* [out] */    // the current Amplitude
             ) PURE;

    STDMETHOD(put_Amplitude) (THIS_
                  int    Amplitude      /* [in] */    // Change to this Amplitude
              ) PURE;

    STDMETHOD(get_SweepRange) (THIS_
                  int *SweepStart,      /* [out] */
                  int *SweepEnd         /* [out] */
             ) PURE;

    STDMETHOD(put_SweepRange) (THIS_
                  int    SweepStart,    /* [in] */
                  int    SweepEnd       /* [in] */
             ) PURE;

};


#ifdef __cplusplus
}
#endif

#endif // __ISYNTH__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\wxlist.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Non MFC based generic template list class, December 1994

/* A generic list of pointers to objects.
   No storage management or copying is done on the objects pointed to.
   Objectives: avoid using MFC libraries in ndm kernel mode and
   provide a really useful list type.

   The class is thread safe in that separate threads may add and
   delete items in the list concurrently although the application
   must ensure that constructor and destructor access is suitably
   synchronised. An application can cause deadlock with operations
   which use two lists by simultaneously calling
   list1->Operation(list2) and list2->Operation(list1).  So don't!

   The names must not conflict with MFC classes as an application
   may use both.
   */

#ifndef __WXLIST__
#define __WXLIST__

   /* A POSITION represents (in some fashion that's opaque) a cursor
      on the list that can be set to identify any element.  NULL is
      a valid value and several operations regard NULL as the position
      "one step off the end of the list".  (In an n element list there
      are n+1 places to insert and NULL is that "n+1-th" value).
      The POSITION of an element in the list is only invalidated if
      that element is deleted.  Move operations may mean that what
      was a valid POSITION in one list is now a valid POSITION in
      a different list.

      Some operations which at first sight are illegal are allowed as
      harmless no-ops.  For instance RemoveHead is legal on an empty
      list and it returns NULL.  This allows an atomic way to test if
      there is an element there, and if so, get it.  The two operations
      AddTail and RemoveHead thus implement a MONITOR (See Hoare's paper).

      Single element operations return POSITIONs, non-NULL means it worked.
      whole list operations return a BOOL.  TRUE means it all worked.

      This definition is the same as the POSITION type for MFCs, so we must
      avoid defining it twice.
   */
#ifndef __AFX_H__
struct __POSITION { int unused; };
typedef __POSITION* POSITION;
#endif

const int DEFAULTCACHE = 10;    /* Default node object cache size */

/* A class representing one node in a list.
   Each node knows a pointer to it's adjacent nodes and also a pointer
   to the object that it looks after.
   All of these pointers can be retrieved or set through member functions.
*/
class CBaseList 
#ifdef DEBUG
    : public CBaseObject
#endif
{
    /* Making these classes inherit from CBaseObject does nothing
       functionally but it allows us to check there are no memory
       leaks in debug builds. 
    */

public:

#ifdef DEBUG
    class CNode : public CBaseObject {
#else
    class CNode {
#endif

        CNode *m_pPrev;         /* Previous node in the list */
        CNode *m_pNext;         /* Next node in the list */
        void *m_pObject;      /* Pointer to the object */

    public:

        /* Constructor - initialise the object's pointers */
        CNode()
#ifdef DEBUG
            : CBaseObject(NAME("List node"))
#endif
        {
        };


        /* Return the previous node before this one */
        CNode *Prev() const { return m_pPrev; };


        /* Return the next node after this one */
        CNode *Next() const { return m_pNext; };


        /* Set the previous node before this one */
        void SetPrev(CNode *p) { m_pPrev = p; };


        /* Set the next node after this one */
        void SetNext(CNode *p) { m_pNext = p; };


        /* Get the pointer to the object for this node */
        void *GetData() const { return m_pObject; };


        /* Set the pointer to the object for this node */
        void SetData(void *p) { m_pObject = p; };
    };

    class CNodeCache
    {
    public:
        CNodeCache(INT iCacheSize) : m_iCacheSize(iCacheSize),
                                     m_pHead(NULL),
                                     m_iUsed(0)
                                     {};
        ~CNodeCache() {
            CNode *pNode = m_pHead;
            while (pNode) {
                CNode *pCurrent = pNode;
                pNode = pNode->Next();
                delete pCurrent;
            }
        };
        void AddToCache(CNode *pNode)
        {
            if (m_iUsed < m_iCacheSize) {
                pNode->SetNext(m_pHead);
                m_pHead = pNode;
                m_iUsed++;
            } else {
                delete pNode;
            }
        };
        CNode *RemoveFromCache()
        {
            CNode *pNode = m_pHead;
            if (pNode != NULL) {
                m_pHead = pNode->Next();
                m_iUsed--;
                ASSERT(m_iUsed >= 0);
            } else {
                ASSERT(m_iUsed == 0);
            }
            return pNode;
        };
    private:
        INT m_iCacheSize;
        INT m_iUsed;
        CNode *m_pHead;
    };

protected:

    CNode* m_pFirst;    /* Pointer to first node in the list */
    CNode* m_pLast;     /* Pointer to the last node in the list */
    LONG m_Count;       /* Number of nodes currently in the list */

private:

    CNodeCache m_Cache; /* Cache of unused node pointers */

private:

    /* These override the default copy constructor and assignment
       operator for all list classes. They are in the private class
       declaration section so that anybody trying to pass a list
       object by value will generate a compile time error of
       "cannot access the private member function". If these were
       not here then the compiler will create default constructors
       and assignment operators which when executed first take a
       copy of all member variables and then during destruction
       delete them all. This must not be done for any heap
       allocated data.
    */
    CBaseList(const CBaseList &refList);
    CBaseList &operator=(const CBaseList &refList);

public:

    CBaseList(TCHAR *pName,
              INT iItems);

    CBaseList(TCHAR *pName);

    ~CBaseList();

    /* Remove all the nodes from *this i.e. make the list empty */
    void RemoveAll();


    /* Return a cursor which identifies the first element of *this */
    POSITION GetHeadPositionI() const;


    /* Return a cursor which identifies the last element of *this */
    POSITION GetTailPositionI() const;


    /* Return the number of objects in *this */
    int GetCountI() const;

protected:
    /* Return the pointer to the object at rp,
       Update rp to the next node in *this
       but make it NULL if it was at the end of *this.
       This is a wart retained for backwards compatibility.
       GetPrev is not implemented.
       Use Next, Prev and Get separately.
    */
    void *GetNextI(POSITION& rp) const;


    /* Return a pointer to the object at p
       Asking for the object at NULL will return NULL harmlessly.
    */
    void *GetI(POSITION p) const;

public:
    /* return the next / prev position in *this
       return NULL when going past the end/start.
       Next(NULL) is same as GetHeadPosition()
       Prev(NULL) is same as GetTailPosition()
       An n element list therefore behaves like a n+1 element
       cycle with NULL at the start/end.

       !!WARNING!! - This handling of NULL is DIFFERENT from GetNext.

       Some reasons are:
       1. For a list of n items there are n+1 positions to insert
          These are conveniently encoded as the n POSITIONs and NULL.
       2. If you are keeping a list sorted (fairly common) and you
          search forward for an element to insert before and don't
          find it you finish up with NULL as the element before which
          to insert.  You then want that NULL to be a valid POSITION
          so that you can insert before it and you want that insertion
          point to mean the (n+1)-th one that doesn't have a POSITION.
          (symmetrically if you are working backwards through the list).
       3. It simplifies the algebra which the methods generate.
          e.g. AddBefore(p,x) is identical to AddAfter(Prev(p),x)
          in ALL cases.  All the other arguments probably are reflections
          of the algebraic point.
    */
    POSITION Next(POSITION pos) const
    {
        if (pos == NULL) {
            return (POSITION) m_pFirst;
        }
        CNode *pn = (CNode *) pos;
        return (POSITION) pn->Next();
    } //Next

    // See Next
    POSITION Prev(POSITION pos) const
    {
        if (pos == NULL) {
            return (POSITION) m_pLast;
        }
        CNode *pn = (CNode *) pos;
        return (POSITION) pn->Prev();
    } //Prev


    /* Return the first position in *this which holds the given
       pointer.  Return NULL if the pointer was not not found.
    */
protected:
    POSITION FindI( void * pObj) const;

    // ??? Should there be (or even should there be only)
    // ??? POSITION FindNextAfter(void * pObj, POSITION p)
    // ??? And of course FindPrevBefore too.
    // ??? List.Find(&Obj) then becomes List.FindNextAfter(&Obj, NULL)


    /* Remove the first node in *this (deletes the pointer to its
       object from the list, does not free the object itself).
       Return the pointer to its object.
       If *this was already empty it will harmlessly return NULL.
    */
    void *RemoveHeadI();


    /* Remove the last node in *this (deletes the pointer to its
       object from the list, does not free the object itself).
       Return the pointer to its object.
       If *this was already empty it will harmlessly return NULL.
    */
    void *RemoveTailI();


    /* Remove the node identified by p from the list (deletes the pointer
       to its object from the list, does not free the object itself).
       Asking to Remove the object at NULL will harmlessly return NULL.
       Return the pointer to the object removed.
    */
    void *RemoveI(POSITION p);

    /* Add single object *pObj to become a new last element of the list.
       Return the new tail position, NULL if it fails.
       If you are adding a COM objects, you might want AddRef it first.
       Other existing POSITIONs in *this are still valid
    */
    POSITION AddTailI(void * pObj);
public:


    /* Add all the elements in *pList to the tail of *this.
       This duplicates all the nodes in *pList (i.e. duplicates
       all its pointers to objects).  It does not duplicate the objects.
       If you are adding a list of pointers to a COM object into the list
       it's a good idea to AddRef them all  it when you AddTail it.
       Return TRUE if it all worked, FALSE if it didn't.
       If it fails some elements may have been added.
       Existing POSITIONs in *this are still valid

       If you actually want to MOVE the elements, use MoveToTail instead.
    */
    BOOL AddTail(CBaseList *pList);


    /* Mirror images of AddHead: */

    /* Add single object to become a new first element of the list.
       Return the new head position, NULL if it fails.
       Existing POSITIONs in *this are still valid
    */
protected:
    POSITION AddHeadI(void * pObj);
public:

    /* Add all the elements in *pList to the head of *this.
       Same warnings apply as for AddTail.
       Return TRUE if it all worked, FALSE if it didn't.
       If it fails some of the objects may have been added.

       If you actually want to MOVE the elements, use MoveToHead instead.
    */
    BOOL AddHead(CBaseList *pList);


    /* Add the object *pObj to *this after position p in *this.
       AddAfter(NULL,x) adds x to the start - equivalent to AddHead
       Return the position of the object added, NULL if it failed.
       Existing POSITIONs in *this are undisturbed, including p.
    */
protected:
    POSITION AddAfterI(POSITION p, void * pObj);
public:

    /* Add the list *pList to *this after position p in *this
       AddAfter(NULL,x) adds x to the start - equivalent to AddHead
       Return TRUE if it all worked, FALSE if it didn't.
       If it fails, some of the objects may be added
       Existing POSITIONs in *this are undisturbed, including p.
    */
    BOOL AddAfter(POSITION p, CBaseList *pList);


    /* Mirror images:
       Add the object *pObj to this-List after position p in *this.
       AddBefore(NULL,x) adds x to the end - equivalent to AddTail
       Return the position of the new object, NULL if it fails
       Existing POSITIONs in *this are undisturbed, including p.
    */
    protected:
    POSITION AddBeforeI(POSITION p, void * pObj);
    public:

    /* Add the list *pList to *this before position p in *this
       AddAfter(NULL,x) adds x to the start - equivalent to AddHead
       Return TRUE if it all worked, FALSE if it didn't.
       If it fails, some of the objects may be added
       Existing POSITIONs in *this are undisturbed, including p.
    */
    BOOL AddBefore(POSITION p, CBaseList *pList);


    /* Note that AddAfter(p,x) is equivalent to AddBefore(Next(p),x)
       even in cases where p is NULL or Next(p) is NULL.
       Similarly for mirror images etc.
       This may make it easier to argue about programs.
    */



    /* The following operations do not copy any elements.
       They move existing blocks of elements around by switching pointers.
       They are fairly efficient for long lists as for short lists.
       (Alas, the Count slows things down).

       They split the list into two parts.
       One part remains as the original list, the other part
       is appended to the second list.  There are eight possible
       variations:
       Split the list {after/before} a given element
       keep the {head/tail} portion in the original list
       append the rest to the {head/tail} of the new list.

       Since After is strictly equivalent to Before Next
       we are not in serious need of the Before/After variants.
       That leaves only four.

       If you are processing a list left to right and dumping
       the bits that you have processed into another list as
       you go, the Tail/Tail variant gives the most natural result.
       If you are processing in reverse order, Head/Head is best.

       By using NULL positions and empty lists judiciously either
       of the other two can be built up in two operations.

       The definition of NULL (see Next/Prev etc) means that
       degenerate cases include
          "move all elements to new list"
          "Split a list into two lists"
          "Concatenate two lists"
          (and quite a few no-ops)

       !!WARNING!! The type checking won't buy you much if you get list
       positions muddled up - e.g. use a POSITION that's in a different
       list and see what a mess you get!
    */

    /* Split *this after position p in *this
       Retain as *this the tail portion of the original *this
       Add the head portion to the tail end of *pList
       Return TRUE if it all worked, FALSE if it didn't.

       e.g.
          foo->MoveToTail(foo->GetHeadPosition(), bar);
              moves one element from the head of foo to the tail of bar
          foo->MoveToTail(NULL, bar);
              is a no-op, returns NULL
          foo->MoveToTail(foo->GetTailPosition, bar);
              concatenates foo onto the end of bar and empties foo.

       A better, except excessively long name might be
           MoveElementsFromHeadThroughPositionToOtherTail
    */
    BOOL MoveToTail(POSITION pos, CBaseList *pList);


    /* Mirror image:
       Split *this before position p in *this.
       Retain in *this the head portion of the original *this
       Add the tail portion to the start (i.e. head) of *pList

       e.g.
          foo->MoveToHead(foo->GetTailPosition(), bar);
              moves one element from the tail of foo to the head of bar
          foo->MoveToHead(NULL, bar);
              is a no-op, returns NULL
          foo->MoveToHead(foo->GetHeadPosition, bar);
              concatenates foo onto the start of bar and empties foo.
    */
    BOOL MoveToHead(POSITION pos, CBaseList *pList);


    /* Reverse the order of the [pointers to] objects in *this
    */
    void Reverse();


    /* set cursor to the position of each element of list in turn  */
    #define TRAVERSELIST(list, cursor)               \
    for ( cursor = (list).GetHeadPosition()           \
        ; cursor!=NULL                               \
        ; cursor = (list).Next(cursor)                \
        )


    /* set cursor to the position of each element of list in turn
       in reverse order
    */
    #define REVERSETRAVERSELIST(list, cursor)        \
    for ( cursor = (list).GetTailPosition()           \
        ; cursor!=NULL                               \
        ; cursor = (list).Prev(cursor)                \
        )

}; // end of class declaration

template<class OBJECT> class CGenericList : public CBaseList
{
public:
    CGenericList(TCHAR *pName,
                 INT iItems,
                 BOOL bLock = TRUE,
                 BOOL bAlert = FALSE) :
                     CBaseList(pName, iItems) {
        UNREFERENCED_PARAMETER(bAlert);
        UNREFERENCED_PARAMETER(bLock);
    };
    CGenericList(TCHAR *pName) :
                     CBaseList(pName) {
    };

    POSITION GetHeadPosition() const { return (POSITION)m_pFirst; }
    POSITION GetTailPosition() const { return (POSITION)m_pLast; }
    int GetCount() const { return m_Count; }

    OBJECT *GetNext(POSITION& rp) const { return (OBJECT *) GetNextI(rp); }

    OBJECT *Get(POSITION p) const { return (OBJECT *) GetI(p); }
    OBJECT *GetHead() const  { return Get(GetHeadPosition()); }

    OBJECT *RemoveHead() { return (OBJECT *) RemoveHeadI(); }

    OBJECT *RemoveTail() { return (OBJECT *) RemoveTailI(); }

    OBJECT *Remove(POSITION p) { return (OBJECT *) RemoveI(p); }
    POSITION AddBefore(POSITION p, OBJECT * pObj) { return AddBeforeI(p, pObj); }
    POSITION AddAfter(POSITION p, OBJECT * pObj)  { return AddAfterI(p, pObj); }
    POSITION AddHead(OBJECT * pObj) { return AddHeadI(pObj); }
    POSITION AddTail(OBJECT * pObj)  { return AddTailI(pObj); }
    BOOL AddTail(CGenericList<OBJECT> *pList)
            { return CBaseList::AddTail((CBaseList *) pList); }
    BOOL AddHead(CGenericList<OBJECT> *pList)
            { return CBaseList::AddHead((CBaseList *) pList); }
    BOOL AddAfter(POSITION p, CGenericList<OBJECT> *pList)
            { return CBaseList::AddAfter(p, (CBaseList *) pList); };
    BOOL AddBefore(POSITION p, CGenericList<OBJECT> *pList)
            { return CBaseList::AddBefore(p, (CBaseList *) pList); };
    POSITION Find( OBJECT * pObj) const { return FindI(pObj); }
}; // end of class declaration



/* These define the standard list types */

typedef CGenericList<CBaseObject> CBaseObjectList;
typedef CGenericList<IUnknown> CBaseInterfaceList;

#endif /* __WXLIST__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\strmbase\wxutil.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

//
// helper classes and functions for building multimedia filters
//

#ifndef __WXUTIL__
#define __WXUTIL__

// eliminate spurious "statement has no effect" warnings.
#pragma warning(disable: 4705)

// wrapper for whatever critical section we have
class CCritSec {

    // make copy constructor and assignment operator inaccessible

    CCritSec(const CCritSec &refCritSec);
    CCritSec &operator=(const CCritSec &refCritSec);

    CRITICAL_SECTION m_CritSec;

#ifdef DEBUG
public:
    DWORD   m_currentOwner;
    DWORD   m_lockCount;
    BOOL    m_fTrace;        // Trace this one
public:
    CCritSec();
    ~CCritSec();
    void Lock();
    void Unlock();
#else

public:
    CCritSec() {
	InitializeCriticalSection(&m_CritSec);
    };

    ~CCritSec() {
	DeleteCriticalSection(&m_CritSec);
    };

    void Lock() {
	EnterCriticalSection(&m_CritSec);
    };

    void Unlock() {
	LeaveCriticalSection(&m_CritSec);
    };
#endif
};

//
// To make deadlocks easier to track it is useful to insert in the
// code an assertion that says whether we own a critical section or
// not.  We make the routines that do the checking globals to avoid
// having different numbers of member functions in the debug and
// retail class implementations of CCritSec.  In addition we provide
// a routine that allows usage of specific critical sections to be
// traced.  This is NOT on by default - there are far too many.
//

#ifdef DEBUG
    BOOL WINAPI CritCheckIn(CCritSec * pcCrit);
    BOOL WINAPI CritCheckOut(CCritSec * pcCrit);
    void WINAPI DbgLockTrace(BOOL fTrace);
#else
    #define CritCheckIn(x) TRUE
    #define CritCheckOut(x) TRUE
    #define DbgLockTrace(pc, fT)
#endif


// locks a critical section, and unlocks it automatically
// when the lock goes out of scope
class CAutoLock {

    // make copy constructor and assignment operator inaccessible

    CAutoLock(const CAutoLock &refAutoLock);
    CAutoLock &operator=(const CAutoLock &refAutoLock);

protected:
    CCritSec * m_pLock;

public:
    CAutoLock(CCritSec * plock)
    {
        m_pLock = plock;
        m_pLock->Lock();
    };

    ~CAutoLock() {
        m_pLock->Unlock();
    };
};



// wrapper for event objects
class CAMEvent
{

    // make copy constructor and assignment operator inaccessible

    CAMEvent(const CAMEvent &refEvent);
    CAMEvent &operator=(const CAMEvent &refEvent);

protected:
    HANDLE m_hEvent;
public:
    CAMEvent(BOOL fManualReset = FALSE);
    ~CAMEvent();

    // Cast to HANDLE - we don't support this as an lvalue
    operator HANDLE () const { return m_hEvent; };

    void Set() {EXECUTE_ASSERT(SetEvent(m_hEvent));};
    BOOL Wait(DWORD dwTimeout = INFINITE) {
	return (WaitForSingleObject(m_hEvent, dwTimeout) == WAIT_OBJECT_0);
    };
    void Reset() { ResetEvent(m_hEvent); };
    BOOL Check() { return Wait(0); };
};


// wrapper for event objects that do message processing
// This adds ONE method to the CAMEvent object to allow sent
// messages to be processed while waiting

class CAMMsgEvent : public CAMEvent
{

public:

    // Allow SEND messages to be processed while waiting
    BOOL WaitMsg(DWORD dwTimeout = INFINITE);
};

// old name supported for the time being
#define CTimeoutEvent CAMEvent

// support for a worker thread

// simple thread class supports creation of worker thread, synchronization
// and communication. Can be derived to simplify parameter passing
class AM_NOVTABLE CAMThread {

    // make copy constructor and assignment operator inaccessible

    CAMThread(const CAMThread &refThread);
    CAMThread &operator=(const CAMThread &refThread);

    CAMEvent m_EventSend;
    CAMEvent m_EventComplete;

    DWORD m_dwParam;
    DWORD m_dwReturnVal;

protected:
    HANDLE m_hThread;

    // thread will run this function on startup
    // must be supplied by derived class
    virtual DWORD ThreadProc() = 0;

public:
    CAMThread();
    ~CAMThread();

    CCritSec m_AccessLock;	// locks access by client threads
    CCritSec m_WorkerLock;	// locks access to shared objects

    // thread initially runs this. param is actually 'this'. function
    // just gets this and calls ThreadProc
    static DWORD WINAPI InitialThreadProc(LPVOID pv);

    // start thread running  - error if already running
    BOOL Create();

    // signal the thread, and block for a response
    //
    DWORD CallWorker(DWORD);

    // accessor thread calls this when done with thread (having told thread
    // to exit)
    void Close() {
        HANDLE hThread = (HANDLE)InterlockedExchangePointer(&m_hThread, 0);
        if (hThread) {
            WaitForSingleObject(hThread, INFINITE);
            CloseHandle(hThread);
        }
    };

    // ThreadExists
    // Return TRUE if the thread exists. FALSE otherwise
    BOOL ThreadExists(void) const
    {
        if (m_hThread == 0) {
            return FALSE;
        } else {
            return TRUE;
        }
    }

    // wait for the next request
    DWORD GetRequest();

    // is there a request?
    BOOL CheckRequest(DWORD * pParam);

    // reply to the request
    void Reply(DWORD);

    // If you want to do WaitForMultipleObjects you'll need to include
    // this handle in your wait list or you won't be responsive
    HANDLE GetRequestHandle() const { return m_EventSend; };

    // Find out what the request was
    DWORD GetRequestParam() const { return m_dwParam; };

    // call CoInitializeEx (COINIT_DISABLE_OLE1DDE) if
    // available. S_FALSE means it's not available.
    static HRESULT CoInitializeHelper();
};


// CQueue
//
// Implements a simple Queue ADT.  The queue contains a finite number of
// objects, access to which is controlled by a semaphore.  The semaphore
// is created with an initial count (N).  Each time an object is added
// a call to WaitForSingleObject is made on the semaphore's handle.  When
// this function returns a slot has been reserved in the queue for the new
// object.  If no slots are available the function blocks until one becomes
// available.  Each time an object is removed from the queue ReleaseSemaphore
// is called on the semaphore's handle, thus freeing a slot in the queue.
// If no objects are present in the queue the function blocks until an
// object has been added.

#define DEFAULT_QUEUESIZE   2

template <class T> class CQueue {
private:
    HANDLE          hSemPut;        // Semaphore controlling queue "putting"
    HANDLE          hSemGet;        // Semaphore controlling queue "getting"
    CRITICAL_SECTION CritSect;      // Thread seriallization
    int             nMax;           // Max objects allowed in queue
    int             iNextPut;       // Array index of next "PutMsg"
    int             iNextGet;       // Array index of next "GetMsg"
    T              *QueueObjects;   // Array of objects (ptr's to void)

    void Initialize(int n) {
        iNextPut = iNextGet = 0;
        nMax = n;
        InitializeCriticalSection(&CritSect);
        hSemPut = CreateSemaphore(NULL, n, n, NULL);
        hSemGet = CreateSemaphore(NULL, 0, n, NULL);
        QueueObjects = new T[n];
    }


public:
    CQueue(int n) {
        Initialize(n);
    }

    CQueue() {
        Initialize(DEFAULT_QUEUESIZE);
    }

    ~CQueue() {
        delete [] QueueObjects;
        DeleteCriticalSection(&CritSect);
        CloseHandle(hSemPut);
        CloseHandle(hSemGet);
    }

    T GetQueueObject() {
        int iSlot;
        T Object;
        LONG lPrevious;

        // Wait for someone to put something on our queue, returns straight
        // away is there is already an object on the queue.
        //
        WaitForSingleObject(hSemGet, INFINITE);

        EnterCriticalSection(&CritSect);
        iSlot = iNextGet++ % nMax;
        Object = QueueObjects[iSlot];
        LeaveCriticalSection(&CritSect);

        // Release anyone waiting to put an object onto our queue as there
        // is now space available in the queue.
        //
        ReleaseSemaphore(hSemPut, 1L, &lPrevious);
        return Object;
    }

    void PutQueueObject(T Object) {
        int iSlot;
        LONG lPrevious;

        // Wait for someone to get something from our queue, returns straight
        // away is there is already an empty slot on the queue.
        //
        WaitForSingleObject(hSemPut, INFINITE);

        EnterCriticalSection(&CritSect);
        iSlot = iNextPut++ % nMax;
        QueueObjects[iSlot] = Object;
        LeaveCriticalSection(&CritSect);

        // Release anyone waiting to remove an object from our queue as there
        // is now an object available to be removed.
        //
        ReleaseSemaphore(hSemGet, 1L, &lPrevious);
    }
};

// miscellaneous string conversion functions
// NOTE: as we need to use the same binaries on Win95 as on NT this code should
// be compiled WITHOUT unicode being defined.  Otherwise we will not pick up
// these internal routines and the binary will not run on Win95.

#ifndef UNICODE
#define wsprintfW wsprintfWInternal
int WINAPIV wsprintfWInternal(LPWSTR, LPCWSTR, ...);

#define lstrcpyW lstrcpyWInternal
LPWSTR
WINAPI
lstrcpyWInternal(
    LPWSTR lpString1,
    LPCWSTR lpString2
    );
#define lstrcpynW lstrcpynWInternal
LPWSTR
WINAPI
lstrcpynWInternal(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int     iMaxLength
    );
#define lstrcmpW lstrcmpWInternal
int
WINAPI
lstrcmpWInternal(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );
#define lstrcmpiW lstrcmpiWInternal
int
WINAPI
lstrcmpiWInternal(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );
#define lstrlenW lstrlenWInternal
int
WINAPI
lstrlenWInternal(
    LPCWSTR lpString
    );
#endif

extern "C"
void * __stdcall memmoveInternal(void *, const void *, size_t);

inline void * __cdecl memchrInternal(const void *buf, int chr, size_t cnt)
{
#ifdef _X86_
    void *pRet = NULL;

    _asm {
        cld                 // make sure we get the direction right
        mov     ecx, cnt    // num of bytes to scan
        mov     edi, buf    // pointer byte stream
        mov     eax, chr    // byte to scan for
        repne   scasb       // look for the byte in the byte stream
        jnz     exit_memchr // Z flag set if byte found
        dec     edi         // scasb always increments edi even when it
                            // finds the required byte
        mov     pRet, edi
exit_memchr:
    }
    return pRet;

#else
    while ( cnt && (*(unsigned char *)buf != (unsigned char)chr) ) {
        buf = (unsigned char *)buf + 1;
        cnt--;
    }

    return(cnt ? (void *)buf : NULL);
#endif
}

void WINAPI IntToWstr(int i, LPWSTR wstr);

#define WstrToInt(sz) atoiW(sz)

inline int atoiW(const WCHAR *sz)
{
    int i = 0;

    while (*sz && *sz >= L'0' && *sz <= L'9')
    	i = i*10 + *sz++ - L'0';
    	
    return i;    	
}

inline int WINAPI atoiA(const CHAR *sz)
{
    int i = 0;

    while (*sz && *sz >= '0' && *sz <= '9')
    	i = i*10 + *sz++ - '0';
    	
    return i;    	
}

#ifdef UNICODE
#define atoi    atoiW
#else
#define atoi    atoiA
#endif



// These are available to help managing bitmap VIDEOINFOHEADER media structures

extern const DWORD bits555[3];
extern const DWORD bits565[3];
extern const DWORD bits888[3];

// These help convert between VIDEOINFOHEADER and BITMAPINFO structures

STDAPI_(const GUID) GetTrueColorType(const BITMAPINFOHEADER *pbmiHeader);
STDAPI_(const GUID) GetBitmapSubtype(const BITMAPINFOHEADER *pbmiHeader);
STDAPI_(WORD) GetBitCount(const GUID *pSubtype);
STDAPI_(TCHAR *) GetSubtypeName(const GUID *pSubtype);
STDAPI_(LONG) GetBitmapFormatSize(const BITMAPINFOHEADER *pHeader);
STDAPI_(DWORD) GetBitmapSize(const BITMAPINFOHEADER *pHeader);
STDAPI_(BOOL) ContainsPalette(const VIDEOINFOHEADER *pVideoInfo);
STDAPI_(const RGBQUAD *) GetBitmapPalette(const VIDEOINFOHEADER *pVideoInfo);


// Compares two interfaces and returns TRUE if they are on the same object
BOOL WINAPI IsEqualObject(IUnknown *pFirst, IUnknown *pSecond);

// This is for comparing pins
#define EqualPins(pPin1, pPin2) IsEqualObject(pPin1, pPin2)


// Arithmetic helper functions

// Compute (a * b + rnd) / c
LONGLONG WINAPI llMulDiv(LONGLONG a, LONGLONG b, LONGLONG c, LONGLONG rnd);
LONGLONG WINAPI Int64x32Div32(LONGLONG a, LONG b, LONG c, LONG rnd);


// Avoids us dyna-linking to SysAllocString to copy BSTR strings
STDAPI WriteBSTR(BSTR * pstrDest, LPCWSTR szSrc);
STDAPI FreeBSTR(BSTR* pstr);

// Return a wide string - allocating memory for it
// Returns:
//    S_OK          - no error
//    E_POINTER     - ppszReturn == NULL
//    E_OUTOFMEMORY - can't allocate memory for returned string
STDAPI AMGetWideString(LPCWSTR pszString, LPWSTR *ppszReturn);

// Special wait for objects owning windows
DWORD WINAPI WaitDispatchingMessages(HANDLE hObject, DWORD dwWait, HWND hwnd = NULL, UINT uMsg = 0);
#endif /* __WXUTIL__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\synth\onef\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by synth.rc
//
#define VERSION_RES_MINOR_VER           0
#define VERSION_RES_BUILD               0
#define VER_DEBUG                       0
#define VERSION_RES_MAJOR_VER           1
#define IDD_BALLPROP                    101
#define IDD_SYNTHPROP1                  101
#define IDC_FREQUENCYTEXT               1002
#define IDC_FREQUENCY                   1003
#define IDC_AMPLITUDETEXT               1003
#define IDC_FREQTRACKBAR                1004
#define IDC_FREQUENCYGROUP              1005
#define IDC_WAVEFORMGROUP               1006
#define IDC_WAVESINE                    1007
#define IDC_WAVESQUARE                  1008
#define IDC_WAVESAWTOOTH                1009
#define IDC_WAVESWEEP                   1010
#define IDC_AMPLITUDETRACKBAR           1011
#define IDC_CHANNELS1                   1012
#define IDC_CHANNELS2                   1013
#define IDC_BITSPERSAMPLEGROUP          1014
#define IDC_BITSPERSAMPLE8              1015
#define IDC_BITSPERSAMPLE16             1016
#define IDC_SAMPLINGFREQUENCYGROUP      1017
#define IDC_SAMPLINGFREQ11              1018
#define IDC_SAMPLINGFREQ22              1019
#define IDC_SAMPLINGFREQ44              1020
#define IDC_AMPLITUDEGROUP              1021
#define IDC_SWEEP                       1023
#define IDS_SYNTHPROPNAME               1024
#define VERSION_RES_LANGUAGE            0x409
#define VERSION_RES_CHARSET             1252
#define IDS_STATIC                      -1
#define IDC_CHANNELSGROUP               -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1025
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\urlcache\url.h ===
#ifndef __URL_H__
#define __URL_H__

#include "wininet.h"
#include "urlmon.h"

typedef WCHAR *PWSZ;
typedef DWORD FLAG;

#ifdef _ALPHA_
   typedef const char*  DWORD_ALPHA_CAST;
#else
   typedef DWORD        DWORD_ALPHA_CAST;   
#endif

HRESULT
AddFileToCache(
    IN  PWSZ        pwszFilePath,
    IN  PWSZ        pwszUrl,
    IN  PWSZ        pwszOriginalUrl,
    IN  DWORD       dwFileSize,
    IN  LPFILETIME  pLastModifiedTime,
    IN  DWORD       dwCacheEntryType );

HRESULT
QueryCreateCacheEntry(
    IN  PSZ         pszUrl,
    IN  LPFILETIME  pLastModifiedTime,
    OUT FLAG        *pfCreateCacheEntry );

HRESULT
GetUrlExtension(
    IN  PSZ     pszUrl,
    OUT PSZ     pszExtension );

#endif // __URL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\synth\onef\synthprp.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// synthprop.cpp - Synthesizer Property Page
//

#include <windows.h>
#include <streams.h>
#include <commctrl.h>
#include <memory.h>
#include <olectl.h>

#include "isynth.h"
#include "synth.h"
#include "synthprp.h"
#include "resource.h"


// -------------------------------------------------------------------------
// CSynthProperties
// -------------------------------------------------------------------------

//
// CreateInstance
//

CUnknown * WINAPI CSynthProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CSynthProperties(lpunk, phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
}


//
// Constructor
//
// Creaete a Property page object for the synthesizer

CSynthProperties::CSynthProperties(LPUNKNOWN lpunk, HRESULT *phr)
    : CBasePropertyPage(NAME("Synth Property Page"), lpunk,
        IDD_SYNTHPROP1,IDS_SYNTHPROPNAME)
    , m_pSynth(NULL)
    , m_iSweepStart(DefaultSweepStart)
    , m_iSweepEnd(DefaultSweepEnd)
	, m_fWindowInActive(TRUE)
{
    ASSERT(phr);

    InitCommonControls();
}

//
// OnConnect
//
// Give us the filter to communicate with

HRESULT CSynthProperties::OnConnect(IUnknown *pUnknown)
{
    ASSERT(m_pSynth == NULL);

    // Ask the filter for it's control interface

    HRESULT hr = pUnknown->QueryInterface(IID_ISynth,(void **)&m_pSynth);
    if (FAILED(hr)) {
        return E_NOINTERFACE;
    }

    ASSERT(m_pSynth);

    // Get current filter state
    m_pSynth->get_BitsPerSample(&m_iBitsPerSampleOriginal);
    m_pSynth->get_Waveform(&m_iWaveformOriginal);
    m_pSynth->get_Frequency(&m_iFrequencyOriginal);
    m_pSynth->get_Channels(&m_iChannelsOriginal);
    m_pSynth->get_SamplesPerSec(&m_iSamplesPerSecOriginal);
    m_pSynth->get_Amplitude(&m_iAmplitudeOriginal);

    return NOERROR;
}


//
// OnDisconnect
//
// Release the interface

HRESULT CSynthProperties::OnDisconnect()
{
    // Release the interface

    if (m_pSynth == NULL) {
        return E_UNEXPECTED;
    }

    m_pSynth->put_Waveform(m_iWaveformOriginal);
    m_pSynth->put_Frequency(m_iFrequencyOriginal);
    m_pSynth->put_Amplitude(m_iAmplitudeOriginal);

    m_pSynth->put_Channels(m_iChannelsOriginal);
    m_pSynth->put_BitsPerSample(m_iBitsPerSampleOriginal);
    m_pSynth->put_SamplesPerSec(m_iSamplesPerSecOriginal);

    m_pSynth->Release();
    m_pSynth = NULL;
    return NOERROR;
}


//
// OnActivate
//
// Called on dialog creation

HRESULT CSynthProperties::OnActivate(void)
{
    InitPropertiesDialog(m_hwnd);

   // ASSERT(m_hwndFreqSlider);

	m_fWindowInActive = FALSE;
    return NOERROR;
}

//
// OnDeactivate
//
// Called on dialog destruction

HRESULT
CSynthProperties::OnDeactivate(void)
{
	m_fWindowInActive = TRUE;
    return NOERROR;
}


//
// OnApplyChanges
//
// User pressed the Apply button, remember the current settings

HRESULT CSynthProperties::OnApplyChanges(void)
{
    m_pSynth->get_BitsPerSample(&m_iBitsPerSampleOriginal);
    m_pSynth->get_Waveform(&m_iWaveformOriginal);
    m_pSynth->get_Frequency(&m_iFrequencyOriginal);
    m_pSynth->get_Channels(&m_iChannelsOriginal);
    m_pSynth->get_SamplesPerSec(&m_iSamplesPerSecOriginal);
    m_pSynth->get_Amplitude(&m_iAmplitudeOriginal);

    return NOERROR;
}


//
// OnReceiveMessages
//
// Handles the messages for our property window

BOOL CSynthProperties::OnReceiveMessage( HWND hwnd
                                , UINT uMsg
                                , WPARAM wParam
                                , LPARAM lParam)
{

	if(m_fWindowInActive)
		return FALSE;

    switch (uMsg) {

    case WM_PROPERTYPAGE_ENABLE:
        // Our private message that our owning filter sends us when changing to a Run / Stop / Pause
        // state.  if lParam, then enable the controls which affect the format; if not lParam, then
        // disable the controls that affect the format.

        EnableWindow (GetDlgItem (hwnd, IDC_SAMPLINGFREQ11), (BOOL) lParam);
        EnableWindow (GetDlgItem (hwnd, IDC_SAMPLINGFREQ22), (BOOL) lParam);
        EnableWindow (GetDlgItem (hwnd, IDC_SAMPLINGFREQ44), (BOOL) lParam);

        EnableWindow (GetDlgItem (hwnd, IDC_BITSPERSAMPLE8),  (BOOL) lParam);
        EnableWindow (GetDlgItem (hwnd, IDC_BITSPERSAMPLE16), (BOOL) lParam);

        EnableWindow (GetDlgItem (hwnd, IDC_CHANNELS1), (BOOL) lParam);
        EnableWindow (GetDlgItem (hwnd, IDC_CHANNELS2), (BOOL) lParam);
        break;

    case WM_VSCROLL:
        if ((HWND) lParam == m_hwndFreqSlider)
            OnFreqSliderNotification(LOWORD (wParam), HIWORD (wParam));
        else if ((HWND) lParam == m_hwndAmplitudeSlider)
            OnAmpSliderNotification(LOWORD (wParam), HIWORD (wParam));
        SetDirty();
        return TRUE;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDC_FREQUENCYTEXT:
        {
            int iNotify = HIWORD (wParam);

            if (iNotify == EN_KILLFOCUS) {
                BOOL fOK;

                int iPos = GetDlgItemInt (hwnd, IDC_FREQUENCYTEXT, &fOK, FALSE);
                int iMaxFreq;

                m_pSynth->get_SamplesPerSec(&iMaxFreq);
                iMaxFreq /= 2;

                if (!fOK || (iPos > iMaxFreq || iPos < 0)) {
                    int iCurrentFreq;
                    m_pSynth->get_Frequency(&iCurrentFreq);
                    SetDlgItemInt (hwnd, IDC_FREQUENCYTEXT, iCurrentFreq, FALSE);
                    break;
                }

		   		SendMessage(m_hwndFreqSlider, TBM_SETPOS, TRUE, (LPARAM) iMaxFreq - iPos);
                m_pSynth->put_Frequency(iPos);
                SetDirty();
            }
        }
        break;

        case IDC_AMPLITUDETEXT:
        {
            int iNotify = HIWORD (wParam);

            if (iNotify == EN_KILLFOCUS) {
                BOOL fOK;

                int iPos = GetDlgItemInt (hwnd, IDC_AMPLITUDETEXT, &fOK, FALSE);

                if (!fOK || (iPos > MaxAmplitude || iPos < 0)) {
                    int iCurrentAmplitude;

                    m_pSynth->get_Amplitude(&iCurrentAmplitude);
                    SetDlgItemInt (hwnd, IDC_AMPLITUDETEXT, iCurrentAmplitude, FALSE);
                    break;
                }

			    SendMessage(m_hwndAmplitudeSlider, TBM_SETPOS, TRUE, (LPARAM) MaxAmplitude - iPos);
                m_pSynth->put_Amplitude(iPos);
                SetDirty();
            }
        }
        break;

        case IDC_SAMPLINGFREQ11:
            m_pSynth->put_SamplesPerSec(11025);
            RecalcFreqSlider();
            SetDirty();
            break;
        case IDC_SAMPLINGFREQ22:
            m_pSynth->put_SamplesPerSec(22050);
            RecalcFreqSlider();
            SetDirty();
            break;
        case IDC_SAMPLINGFREQ44:
            m_pSynth->put_SamplesPerSec(44100);
            RecalcFreqSlider();
            SetDirty();
            break;


        case IDC_BITSPERSAMPLE8:
            m_pSynth->put_BitsPerSample(8);
            SetDirty();
            break;
        case IDC_BITSPERSAMPLE16:
            m_pSynth->put_BitsPerSample(16);
            SetDirty();
            break;


        case IDC_CHANNELS1:
            m_pSynth->put_Channels(1);
            SetDirty();
            break;
        case IDC_CHANNELS2:
            m_pSynth->put_Channels(2);
            SetDirty();
            break;
	    

        case IDC_WAVESINE:
            m_pSynth->put_Waveform(WAVE_SINE);
            SetDirty();
            break;
        case IDC_WAVESQUARE:
            m_pSynth->put_Waveform(WAVE_SQUARE);
            SetDirty();
            break;
        case IDC_WAVESAWTOOTH:
            m_pSynth->put_Waveform(WAVE_SAWTOOTH);
            SetDirty();
            break;
        case IDC_WAVESWEEP:
            m_pSynth->put_Waveform(WAVE_SINESWEEP);
            SetDirty();
            break;

        default:
            break;

        }
        return TRUE;

    case WM_DESTROY:
        return TRUE;

    default:
        return FALSE;

    }
    return TRUE;
}


//
// InitPropertiesDialog
//

void
CSynthProperties::InitPropertiesDialog(HWND hwndParent)
{
    m_hwndFreqSlider = GetDlgItem (hwndParent, IDC_FREQTRACKBAR);
    m_hwndFreqText  = GetDlgItem (hwndParent, IDC_FREQUENCYTEXT);
    m_hwndAmplitudeSlider = GetDlgItem (hwndParent, IDC_AMPLITUDETRACKBAR);
    m_hwndAmplitudeText  = GetDlgItem (hwndParent, IDC_AMPLITUDETEXT);

    // Sampling Frequency
    int i;
    switch (m_iSamplesPerSecOriginal) {
    case 11025: i = IDC_SAMPLINGFREQ11; break;
    case 22050: i = IDC_SAMPLINGFREQ22; break;
    case 44100: i = IDC_SAMPLINGFREQ44; break;
    default:
        ASSERT(0);
    }
    CheckRadioButton(hwndParent,
        IDC_SAMPLINGFREQ11,
        IDC_SAMPLINGFREQ44,
        i);

    // BitsPerSample
    CheckRadioButton(hwndParent,
                IDC_BITSPERSAMPLE8,
                IDC_BITSPERSAMPLE16,
                IDC_BITSPERSAMPLE8 + m_iBitsPerSampleOriginal / 8 - 1);

    // Waveform 0 == sine, 1 == square, ...
    CheckRadioButton(hwndParent,
                IDC_WAVESINE,
                IDC_WAVESWEEP,
                IDC_WAVESINE + m_iWaveformOriginal);

    // Channels
    CheckRadioButton(hwndParent,
                IDC_CHANNELS1,
                IDC_CHANNELS2,
                IDC_CHANNELS1 + m_iChannelsOriginal - 1);

    //
    // Frequency trackbar
    //

    RecalcFreqSlider();

    //
    //  Amplitude trackbar
    //

    SendMessage(m_hwndAmplitudeSlider, TBM_SETRANGE, TRUE,
        MAKELONG(MinAmplitude, MaxAmplitude) );

    SendMessage(m_hwndAmplitudeSlider, TBM_SETTIC, 0,
        ((MinAmplitude + MaxAmplitude) / 2));

    SendMessage(m_hwndAmplitudeSlider, TBM_SETPOS, TRUE,
        (LPARAM) (MaxAmplitude - m_iAmplitudeOriginal));

    SetDlgItemInt (hwndParent, IDC_AMPLITUDETEXT,
        m_iAmplitudeOriginal, TRUE);
}


//
// RecalcFreqSlider
//
// Set the range, current settings for the Freq scrollbar

void
CSynthProperties::RecalcFreqSlider(void)
{
    int iPos, iMaxFreq;

    // Limit the frequency to one half the sampling frequency

    m_pSynth->get_SamplesPerSec(&iMaxFreq);
    iMaxFreq /= 2;
    m_pSynth->get_Frequency(&iPos);
    if (iPos > iMaxFreq)
        iPos = iMaxFreq;

    SendMessage(m_hwndFreqSlider, TBM_SETRANGE, TRUE,
        MAKELONG(0, iMaxFreq));

    SendMessage(m_hwndFreqSlider, TBM_SETTIC, 0,
        iMaxFreq / 2);

    SendMessage(m_hwndFreqSlider, TBM_SETPOS, TRUE,
        (LPARAM) (iMaxFreq - iPos));

    SendMessage(m_hwndFreqSlider, TBM_SETPAGESIZE, 0, 10);

    SendMessage(m_hwndFreqSlider, TBM_SETSEL, TRUE,
        MAKELONG (iMaxFreq - m_iSweepEnd, iMaxFreq - m_iSweepStart));

    SetDlgItemInt (m_hwnd, IDC_FREQUENCYTEXT,
        iPos, TRUE);

}

//
// OnFreqSliderNotification
//
// Handle the notification meesages from the slider control

void
CSynthProperties::OnFreqSliderNotification(WPARAM wParam, WORD wPosition)
{
    int MaxFreq;
    int Freq;
    int SliderPos;

    switch (wParam) {

    case TB_ENDTRACK:
    case TB_THUMBTRACK:
    case TB_LINEDOWN:
    case TB_LINEUP: {
        // max frequency of slider is half the sampling frequency
        m_pSynth->get_SamplesPerSec (&MaxFreq);
        MaxFreq /= 2;
        SliderPos = (int) SendMessage(m_hwndFreqSlider, TBM_GETPOS, 0, 0L);
        Freq = MaxFreq - SliderPos;
        m_pSynth->put_Frequency (Freq);

        // Set the end of sweep to the current slider pos
        if (!(GetKeyState (VK_SHIFT) & 0x8000)) {
            m_iSweepEnd = Freq;
        }

        // Set the start of the sweep range if SHIFT key is pressed
        if (GetKeyState (VK_SHIFT) & 0x8000) {
            m_iSweepStart = Freq;
        }
        m_pSynth->put_SweepRange (m_iSweepStart, m_iSweepEnd);

        if (m_iSweepEnd > m_iSweepStart)
            SendMessage(m_hwndFreqSlider, TBM_SETSEL, TRUE,
                MAKELONG (MaxFreq - m_iSweepEnd, MaxFreq - m_iSweepStart));
        else
            SendMessage(m_hwndFreqSlider, TBM_SETSEL, TRUE,
                MAKELONG (MaxFreq - m_iSweepStart, MaxFreq - m_iSweepEnd));

        SetDlgItemInt (m_hwnd, IDC_FREQUENCYTEXT, Freq, TRUE);

    }
    break;

    }
}

//
// OnAmpSliderNotification
//
// Handle the notification meesages from the slider control

void
CSynthProperties::OnAmpSliderNotification(WPARAM wParam, WORD wPosition)
{
    switch (wParam) {

    case TB_ENDTRACK:
    case TB_THUMBTRACK:
    case TB_LINEDOWN:
    case TB_LINEUP: {
        int Level = (int) SendMessage(m_hwndAmplitudeSlider, TBM_GETPOS, 0, 0L);
        m_pSynth->put_Amplitude (MaxAmplitude - Level);
        SetDlgItemInt (m_hwnd, IDC_AMPLITUDETEXT, MaxAmplitude - Level, TRUE);
    }
    break;

    }
}

//
// SetDirty
//
// notifies the property page site of changes

void
CSynthProperties::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\urlcache\url.cpp ===
#include <windows.h>
#include "url.h"
#include <atlbase.h>

#undef _ATL_STATIC_REGISTRY

#include <atlimpl.cpp>
#include <winineti.h>

#define max(a,b)            (((a) > (b)) ? (a) : (b))
#define ASSERT _ASSERTE

///////////////////////////////////////////////////////////////////////////////
HRESULT
AddFileToCache(
    IN  PWSZ        pwszFilePath,
    IN  PWSZ        pwszUrl,
    IN  PWSZ        pwszOriginalUrl,
    IN  DWORD       dwFileSize,
    IN  LPFILETIME  pLastModifiedTime,
    IN  DWORD       dwCacheEntryType )
{
    HRESULT     hr                  = S_OK;
    FLAG        fCreateCacheEntry;
    char        *szOriginalUrl;
    char        szHeader[]          = "HTTP/1.0 200 OK\r\n\r\n";
    char        szExtension         [ INTERNET_MAX_URL_LENGTH + 1 ];
    char        szCacheFilePath     [ MAX_PATH + 1 ];
    char        *szFilePath;
    FILETIME    ZeroFileTime;
    DWORD       dwReserved;

    ASSERT( NULL != pwszFilePath );
    ASSERT( NULL != pwszUrl );

    USES_CONVERSION;
    char *szUrl = W2A(pwszUrl);

    if( NULL != pwszOriginalUrl )
    {
        szOriginalUrl = W2A(pwszOriginalUrl);
    }

    //
    // Check if the URL is already in the cache.
    //

    hr = QueryCreateCacheEntry( szUrl, pLastModifiedTime, &fCreateCacheEntry );
    
    if( hr == S_OK && fCreateCacheEntry )
    {
        //
        // We need to create the cache entry.
        //

        //
        // First, get the filename extension of the URL. We do this so
        // that the URL will show up in the IE cache window with the right icon.
        //

        hr = GetUrlExtension(
                szUrl,
                szExtension );

        if( hr == S_OK )
        {
            //
            // Now, create the cache entry.
            //

            if( !CreateUrlCacheEntryA( 
                    szUrl,
                    dwFileSize,
                    szExtension,
                    szCacheFilePath,
                    0 ) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
            }
            else
            {
                //
                // Copy the file to the cache file path.
                //

                szFilePath = W2A(pwszFilePath);

                if( !CopyFileA(
                        szFilePath,
                        szCacheFilePath,
                        FALSE ) )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                }
            }
        }

        if( hr == S_OK )
        {
            //
            // Commit the cache entry.
            //

            if( NULL != pwszOriginalUrl )
            {
                //
                // The URL was redirected. Pass the original URL in via the
                // dwReserved parameter.
                //
                dwReserved = (DWORD)szOriginalUrl;
            }
            else
            {
                //
                // The URL was not redirected.
                //
                dwReserved = 0;
            }

            ZeroMemory( &ZeroFileTime, sizeof( FILETIME ) );

            if( !CommitUrlCacheEntryA(
                    szUrl,
                    szCacheFilePath,
                    ZeroFileTime,
                    *pLastModifiedTime,
                    dwCacheEntryType,
                    (LPBYTE)szHeader,
                    strlen( szHeader ),
                    NULL,
                    (DWORD_ALPHA_CAST)dwReserved ) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
            }
        }

        if( hr != S_OK )
        {
            //
            // An error occured. Delete the cache entry.
            //
            DeleteUrlCacheEntry( szUrl );
        }
    }

    return( hr );
}

///////////////////////////////////////////////////////////////////////////////
HRESULT
QueryCreateCacheEntry(
    IN  PSZ         pszUrl,
    IN  LPFILETIME  pLastModifiedTime,
    OUT FLAG        *pfCreateCacheEntry )
{
    HRESULT                         hr                      = S_OK;
    FLAG                            fCreateCacheEntry       = FALSE;
    BYTE                            CacheEntryBuffer        [MAX_CACHE_ENTRY_INFO_SIZE];
    LPINTERNET_CACHE_ENTRY_INFOA    pCacheEntryInfo;
    DWORD                           dwCacheEntryInfoSize    = MAX_CACHE_ENTRY_INFO_SIZE;

    ASSERT( NULL != pszUrl );
    ASSERT( NULL != pLastModifiedTime );
    ASSERT( NULL != pfCreateCacheEntry );

    dwCacheEntryInfoSize    = MAX_CACHE_ENTRY_INFO_SIZE;
    pCacheEntryInfo         = (LPINTERNET_CACHE_ENTRY_INFOA)CacheEntryBuffer;
    
    ZeroMemory(pCacheEntryInfo, dwCacheEntryInfoSize);
    pCacheEntryInfo->dwStructSize = dwCacheEntryInfoSize;

    if (!GetUrlCacheEntryInfoA(
            pszUrl,
            pCacheEntryInfo,
            &dwCacheEntryInfoSize ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
    }

    if( hr == S_OK )
    {
        //
        // The URL already exists in the cache. Check if it is older than the source file.
        // Only replace it if it is.
        //

        if( CompareFileTime(
                &pCacheEntryInfo->LastModifiedTime, 
                pLastModifiedTime ) < 0 ) 
        {
            //
            // The last modified time of the currently cached URL is older
            // than the file being received. Delete the entry and re-create it.
            //

            DeleteUrlCacheEntry( pszUrl );

            fCreateCacheEntry = TRUE;
        }
    }
    else if( hr == HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) )
    {
        //
        // The URL does not exist in the cache. We have to create it.
        //

        fCreateCacheEntry = TRUE;

        hr = S_OK;
    }

    *pfCreateCacheEntry = fCreateCacheEntry;

    return( hr );
}

///////////////////////////////////////////////////////////////////////////////
HRESULT
GetUrlExtension(
    IN  PSZ     pszUrl,
    OUT PSZ     pszExtension )
{
    HRESULT         hr                  = S_OK;
    char            szCanonicalUrl      [INTERNET_MAX_URL_LENGTH + 1];
    char            szUrlPath           [INTERNET_MAX_URL_LENGTH + 1];
    DWORD           dwUrlBufferLength   = (INTERNET_MAX_URL_LENGTH + 1);
    PSZ             pszT;
    PSZ             pszT1;
    PSZ             pszT2;
    URL_COMPONENTSA UrlComponents;
    DWORD           dwLen;
    char            ch;

    ASSERT( NULL != pszUrl );
    ASSERT( NULL != pszExtension );

    if( !InternetCanonicalizeUrlA(
            pszUrl,
            szCanonicalUrl,
            &dwUrlBufferLength,
            ICU_NO_ENCODE | ICU_BROWSER_MODE ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
    }
    else
    {
        ZeroMemory( &UrlComponents, sizeof( URL_COMPONENTSA ) );

        UrlComponents.dwStructSize      = sizeof( URL_COMPONENTSA );
        UrlComponents.dwSchemeLength    = 1;
        
        UrlComponents.lpszUrlPath       = szUrlPath;
        UrlComponents.dwUrlPathLength   = INTERNET_MAX_URL_LENGTH + 1;

        if( !InternetCrackUrlA( szCanonicalUrl, 0, 0, &UrlComponents ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }
        else
        {
            ASSERT( NULL != UrlComponents.lpszUrlPath );

            //
            // Now, look for the extension of the file path. 
            // If the URL has a query, then the extension is that of the URL before 
            // the query delimiter (?) -- e.g., the extension of http://foo.asp?default.gif 
            // is "asp," not "gif." If the URL does not have a query, then the extension is
            // that of the URL itself. If the URL itself doesnt have an extension, we pass out
            // "htm" so that the default IE icon will be used. A special case exists for "asp" --
            // "htm" will also be passed out in this case because that is what IE does.
            // 
            //

            pszT1 = strrchr( UrlComponents.lpszUrlPath, '/' );
            pszT2 = strrchr( UrlComponents.lpszUrlPath, '\\' );

            pszT = max( pszT1, pszT2 );

            if( NULL == pszT )
            {
                pszT = UrlComponents.lpszUrlPath;
            }
            else
            {
                pszT++;
            }

            pszT2 = strchr( pszT, '?' );

            if( NULL != pszT2 )
            {
                ch = *pszT2;

                *pszT2 = '\0';
            }

            pszT = strrchr( pszT, '.' );

            if( NULL != pszT2 )
            {
                *pszT2 = ch;
            }

            if( NULL != pszT )
            {
                pszT++;

                dwLen = strlen( pszT );

                ch = *( pszT + dwLen - 1 );

                if( '/' == ch || '\\' == ch )
                {
                    *( pszT + dwLen - 1 ) = '\0';
                }

                //
                // Dont include non-alphanumeric characters.
                //

                pszT1 = pszT;

                while( '\0' != *pszT1 && isalnum( *pszT1 ) )
                {
                    pszT1++;
                }

                if( pszT1 == pszT )
                {
                    strcpy( pszExtension, "htm" );
                }
                else
                {
                    *pszT1 = '\0';

                    if( !_stricmp( pszT, "asp" ) )
                    {
                        strcpy( pszExtension, "htm" );
                    }
                    else
                    {
                        strcpy( pszExtension, pszT );
                    }
                }
            }
            else
            {
                strcpy( pszExtension, "htm" );
            }
        }
    }

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\synth\onef\synth.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// synth.cpp
//
// Audio Signal Generator Source Filter


#include <windows.h>
#include <streams.h>
#include <math.h>

#include <initguid.h>
#if (1100 > _MSC_VER)
#include <olectlid.h>
#else
#include <olectl.h>
#endif

#define RMAX 0x7fff  // 2^15-1 (based on rand's max value)
#define _AUDIOSYNTH_IMPLEMENTATION_

#include "isynth.h"
#include "synth.h"
#include "synthprp.h"

// setup data

const AMOVIESETUP_MEDIATYPE sudOpPinTypes =
{ &MEDIATYPE_Audio      // clsMajorType
, &MEDIASUBTYPE_NULL }; // clsMinorType

const AMOVIESETUP_PIN sudOpPin =
{ L"Output"          // strName
, FALSE              // bRendered
, TRUE               // bOutput
, FALSE              // bZero
, FALSE              // bMany
, &CLSID_NULL        // clsConnectsToFilter
, L"Input"           // strConnectsToPin
, 1                  // nTypes
, &sudOpPinTypes };  // lpTypes

const AMOVIESETUP_FILTER sudSynth =
{ &CLSID_SynthFilter     // clsID
, L"1/f Audio Synthesizer" // strName
, MERIT_UNLIKELY       // dwMerit
, 1                    // nPins
, &sudOpPin };         // lpPin

// -------------------------------------------------------------------------
// g_Templates
// -------------------------------------------------------------------------
// COM global table of objects in this dll

CFactoryTemplate g_Templates[] = {

    { L"1/f Audio Synthesizer"
    , &CLSID_SynthFilter
    , CSynthFilter::CreateInstance
    , NULL
    , &sudSynth }
  ,
    { L"1/f Audio Synthesizer Property Page"
    , &CLSID_SynthPropertyPage
    , CSynthProperties::CreateInstance }

};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// -------------------------------------------------------------------------
// CSynthFilter, the main filter object
// -------------------------------------------------------------------------
//
// CreateInstance
//
// The only allowed way to create Synthesizers

CUnknown * WINAPI CSynthFilter::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) {

    CUnknown *punk = new CSynthFilter(lpunk, phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
}

//
// CSynthFilter::Constructor
//
// initialise a CSynthStream object so that we have a pin.

CSynthFilter::CSynthFilter(LPUNKNOWN lpunk, HRESULT *phr)
    : CSource(NAME("Audio Synthesizer Filter"),lpunk, CLSID_SynthFilter)
    , CPersistStream(lpunk, phr)
{
    CAutoLock l(&m_cStateLock);

    m_paStreams    = (CSourceStream **) new CSynthStream*[1];
    if (m_paStreams == NULL) {
        *phr = E_OUTOFMEMORY;
        return;
    }

    m_paStreams[0] = new CSynthStream(phr, this, L"Audio Synth Stream");
    if (m_paStreams[0] == NULL) {
        *phr = E_OUTOFMEMORY;
        return;
    }

    if (SUCCEEDED(*phr)) {
	ASSERT(m_Synth);
	m_Channels = 1;
	m_SamplesPerSec = 11025;
	m_BitsPerSample = 8;
	m_Synth->put_SynthFormat(m_Channels, m_BitsPerSample, m_SamplesPerSec);
    }
}

//
// CSynthFilter::Destructor
//
CSynthFilter::~CSynthFilter(void) {

    //
    //  Base class will free our pins
    //
}

//
// NonDelegatingQueryInterface
//
// Reveal our property page, persistance, and control interfaces

STDMETHODIMP CSynthFilter::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    CAutoLock l(&m_cStateLock);

    if (riid == IID_ISynth) {
        return GetInterface((ISynth *) this, ppv);
    }
    else if (riid == IID_IPersistStream) {
        return GetInterface((IPersistStream *) this, ppv);
    }
    else if (riid == IID_ISpecifyPropertyPages) {
        return GetInterface((ISpecifyPropertyPages *) this, ppv);
    } else {
        return CSource::NonDelegatingQueryInterface(riid, ppv);
    }
}


//
// GetPages
//
STDMETHODIMP CSynthFilter::GetPages(CAUUID * pPages) {

    CAutoLock l(&m_cStateLock);

    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }
    *(pPages->pElems) = CLSID_SynthPropertyPage;

    return NOERROR;

}

// -------------------------------------------------------------------------
// --- IPersistStream ---
// -------------------------------------------------------------------------

#define WRITEOUT(var)   hr = pStream->Write(&var, sizeof(var), NULL); \
                        if (FAILED(hr)) return hr;

#define READIN(var)     hr = pStream->Read(&var, sizeof(var), NULL); \
                        if (FAILED(hr)) return hr;

STDMETHODIMP CSynthFilter::GetClassID(CLSID *pClsid)
{
    return CBaseFilter::GetClassID(pClsid);
}

int CSynthFilter::SizeMax ()
{
    return sizeof (int) * 8;
}

HRESULT CSynthFilter::WriteToStream(IStream *pStream)
{
    HRESULT hr;
    int i, k;

    get_Frequency (&i);  // don't we wish we'd used a structure, now?
    WRITEOUT(i);
    get_Waveform (&i);
    WRITEOUT(i);
    get_Channels (&i);
    WRITEOUT(i);
    get_BitsPerSample (&i);
    WRITEOUT(i);
    get_SamplesPerSec (&i);
    WRITEOUT(i);
    get_Amplitude (&i);
    WRITEOUT(i);
    get_SweepRange (&i, &k);
    WRITEOUT(i);
    WRITEOUT(k);

    return hr;
}


HRESULT CSynthFilter::ReadFromStream(IStream *pStream)
{
    HRESULT hr;
    int i, k;

    READIN(i);
    put_Frequency(i);
    READIN(i);
    put_Waveform (i);
    READIN(i);
    put_Channels (i);
    READIN(i);
    put_BitsPerSample (i);
    READIN(i);
    put_SamplesPerSec (i);
    READIN(i);
    put_Amplitude (i);
    READIN(i);
    READIN(k);
    put_SweepRange (i, k);

    return hr;
}

// -------------------------------------------------------------------------
// ISynth, the control interface for the synthesizer
// -------------------------------------------------------------------------

//
// get_Frequency
//
STDMETHODIMP CSynthFilter::get_Frequency(int *Frequency) {

    m_Synth->get_Frequency(Frequency);

    DbgLog((LOG_TRACE, 3, TEXT("get_Frequency: %d"), *Frequency));

    return NOERROR;
}


//
// put_Frequency
//
STDMETHODIMP CSynthFilter::put_Frequency(int Frequency) {

    m_Synth->put_Frequency (Frequency);

    DbgLog((LOG_TRACE, 3, TEXT("put_Frequency: %d"), Frequency));

    return NOERROR;
}

//
// get_Waveform
//
STDMETHODIMP CSynthFilter::get_Waveform(int *Waveform) {

    m_Synth->get_Waveform (Waveform);

    DbgLog((LOG_TRACE, 3, TEXT("get_Waveform: %d"), *Waveform));

    return NOERROR;
}


//
// put_Waveform
//
STDMETHODIMP CSynthFilter::put_Waveform(int Waveform) {

    m_Synth->put_Waveform (Waveform);

    DbgLog((LOG_TRACE, 3, TEXT("put_Waveform: %d"), Waveform));

    return NOERROR;
}

//
// get_Channels
//
STDMETHODIMP CSynthFilter::get_Channels(int *Channels) {

    *Channels = m_Channels;

    DbgLog((LOG_TRACE, 3, TEXT("get_Channels: %d"), *Channels));

    return NOERROR;
}

//
// If the format changes, we need to reconnect
//
void CSynthFilter::ReconnectWithNewFormat(void) {

//    CAutoLock l(&m_SynthLock);

    HRESULT hr;
    FILTER_STATE  State;

    CBasePin *pPin = GetPin(0);

    // Get the state and confirm that the graph is stopped
    GetState (0, &State);
    if (State != State_Stopped && pPin->GetConnected()) {
	// let's attempt a dynamic connection
	CMediaType mtNew;

	// !!! better way to get back to a CSynthStream???
	CSynthStream * pStream = (CSynthStream *) pPin;
	pStream->GetMediaType(&mtNew);

	// !!! does this really mean they'll accept a dynamic format change?
	hr = pPin->GetConnected()->QueryAccept(&mtNew);

	DbgLog((LOG_TRACE,2,TEXT("Attempting format change: queryAccept returned %x"), hr));

	if (hr == S_OK) {
	    // actually change what's being pushed
	    m_Synth->put_SynthFormat(m_Channels, m_BitsPerSample, m_SamplesPerSec);
	} else {
	    // !!! couldn't change right now, we should really schedule a reconnect
	    // for the next time the graph is stopped.
	}
	
        return;
    }

    if (!m_pGraph)
        return;

    hr = GetFilterGraph()->Reconnect (pPin);       // Renegotiate the format
    if (FAILED(hr)) {
        DbgLog((LOG_TRACE, 1, TEXT("Reconnect failed, err=%x"), hr));
        return;
    }
}


//
// put_Channels
//
STDMETHODIMP CSynthFilter::put_Channels(int Channels) {

    m_Channels = Channels;

    ReconnectWithNewFormat ();

    DbgLog((LOG_TRACE, 3, TEXT("put_Channels: %d"), Channels));

    return NOERROR;
}

//
// get_BitsPerSample
//
STDMETHODIMP CSynthFilter::get_BitsPerSample(int *BitsPerSample) {

    *BitsPerSample = m_BitsPerSample;

    DbgLog((LOG_TRACE, 3, TEXT("get_BitsPerSample: %d"), *BitsPerSample));

    return NOERROR;
}


//
// put_BitsPerSample
//
STDMETHODIMP CSynthFilter::put_BitsPerSample(int BitsPerSample) {

    m_BitsPerSample = BitsPerSample;

    ReconnectWithNewFormat ();

    DbgLog((LOG_TRACE, 3, TEXT("put_BitsPerSample: %d"), BitsPerSample));

    return NOERROR;
}

//
// get_SamplesPerSec
//
STDMETHODIMP CSynthFilter::get_SamplesPerSec(int *SamplesPerSec) {

    *SamplesPerSec = m_SamplesPerSec;

    DbgLog((LOG_TRACE, 3, TEXT("get_SamplesPerSec: %d"), *SamplesPerSec));

    return NOERROR;
}


//
// put_SamplesPerSec
//
STDMETHODIMP CSynthFilter::put_SamplesPerSec(int SamplesPerSec) {

    m_SamplesPerSec = SamplesPerSec;

    ReconnectWithNewFormat ();

    DbgLog((LOG_TRACE, 3, TEXT("put_SamplesPerSec: %d"), SamplesPerSec));

    return NOERROR;
}

//
// get_Amplitude
//
STDMETHODIMP CSynthFilter::get_Amplitude(int *Amplitude) {

    m_Synth->get_Amplitude (Amplitude);

    DbgLog((LOG_TRACE, 3, TEXT("get_Amplitude: %d"), *Amplitude));

    return NOERROR;
}


//
// put_Amplitude
//
STDMETHODIMP CSynthFilter::put_Amplitude(int Amplitude) {

    m_Synth->put_Amplitude (Amplitude);

    DbgLog((LOG_TRACE, 3, TEXT("put_Amplitude: %d"), Amplitude));

    return NOERROR;
}


//
// get_SweepRange
//
STDMETHODIMP CSynthFilter::get_SweepRange(int *SweepStart, int *SweepEnd) {

    m_Synth->get_SweepRange (SweepStart, SweepEnd);

    DbgLog((LOG_TRACE, 3, TEXT("get_SweepStart: %d %d"), *SweepStart, *SweepEnd));

    return NOERROR;
}


//
// put_SweepRange
//
STDMETHODIMP CSynthFilter::put_SweepRange(int SweepStart, int SweepEnd) {

    m_Synth->put_SweepRange (SweepStart, SweepEnd);

    DbgLog((LOG_TRACE, 3, TEXT("put_SweepRange: %d %d"), SweepStart, SweepEnd));

    return NOERROR;
}


// -------------------------------------------------------------------------
// CSynthStream, the output pin
// -------------------------------------------------------------------------

//
// CSynthStream::Constructor
//

CSynthStream::CSynthStream(HRESULT *phr, CSynthFilter *pParent, LPCWSTR pName)
    : CSourceStream(NAME("Audio Synth output pin"),phr, pParent, pName) {

    CAutoLock l(m_pFilter->pStateLock());

    {
        CAutoLock l(&m_cSharedState);

        m_Synth = new CAudioSynth( );
        pParent->m_Synth = m_Synth;
        if (m_Synth == NULL) {
            *phr = E_OUTOFMEMORY;
            return;
        }
	m_pParent = pParent;
    }
}


//
// CSynthStream::Destructor
//
CSynthStream::~CSynthStream(void) {

    CAutoLock l(&m_cSharedState);

    delete m_Synth;
}


//
// FillBuffer
//
// Stuffs the buffer with data
HRESULT CSynthStream::FillBuffer(IMediaSample *pms) {

    BYTE *pData;
    long lDataLen;
    int nSamplesPerSec;
    int nBitsPerSample;
    int nChannels;
    BOOL fNewFormat = FALSE;

    pms->GetPointer(&pData);
    lDataLen = pms->GetSize();

    CAutoLock lShared(&m_cSharedState);
   // m_Synth->FillAudioBuffer (pData, lDataLen, &fNewFormat);
	m_Synth->CalcOneF (pData, lDataLen);

    if (fNewFormat) {
	CMediaType mtNew;
	GetMediaType(&mtNew);

	pms->SetMediaType(&mtNew);

	DbgLog((LOG_TRACE,2,TEXT("Sending buffer with new media type")));
    }

    CRefTime rtStart  = m_rtSampleTime;  // the current time is the sample's start

    m_Synth->get_SamplesPerSec (&nSamplesPerSec);
    m_Synth->get_BitsPerSample (&nBitsPerSample);
    m_Synth->get_Channels (&nChannels);

    m_rtSampleTime += (UNITS * lDataLen /
            (nSamplesPerSec * nChannels * nBitsPerSample / 8));

    pms->SetTime((REFERENCE_TIME*)&rtStart,
                 (REFERENCE_TIME*)&m_rtSampleTime);

    return NOERROR;
}


//
// Format Support
//

//
// GetMediaType
//
HRESULT CSynthStream::GetMediaType(CMediaType *pmt) {

    CAutoLock l(m_pFilter->pStateLock());

    WAVEFORMATEX *pwf = (WAVEFORMATEX *) pmt->AllocFormatBuffer(sizeof(WAVEFORMATEX));

    pwf->wFormatTag = WAVE_FORMAT_PCM;
    pwf->nChannels = (WORD) m_pParent->m_Channels;
    pwf->nSamplesPerSec = (DWORD) m_pParent->m_SamplesPerSec;
    pwf->wBitsPerSample = (WORD) m_pParent->m_BitsPerSample;
    pwf->nBlockAlign = pwf->wBitsPerSample * pwf->nChannels / 8;
    pwf->nAvgBytesPerSec = (int) ((DWORD) pwf->nBlockAlign *
                           pwf->nSamplesPerSec);
    pwf->cbSize = 0;

    return CreateAudioMediaType(pwf, pmt, FALSE);
}


//
// CheckMediaType
//
// Returns E_INVALIDARG if the mediatype is not acceptable, S_OK if it is
HRESULT CSynthStream::CheckMediaType(const CMediaType *pMediaType) {

    CAutoLock l(m_pFilter->pStateLock());

    //  Check that's Audio and that the format block
    //  has the WAVEFORMATEX structure (indicated by a format type
    //  GUID of FORMAT_WaveFormatEx)

    if ((*pMediaType->Type() != MEDIATYPE_Audio) ||
        (*pMediaType->FormatType() != FORMAT_WaveFormatEx))
        return E_INVALIDARG;

    WAVEFORMATEX * pwfx  = (WAVEFORMATEX *)pMediaType->Format();

    if (pwfx->wFormatTag != WAVE_FORMAT_PCM)
	return E_INVALIDARG;

    // !!! check 8/16, 1/2 channel

    // Check for the subtypes we support

    // Get the format area of the media type

    // !!! if we're going to allow arbitrary media types here, we have to actually
    // look at SetMediaType to see what we've agreed on!

    return S_OK;  // This format is acceptable.
}

//
// DecideBufferSize
//
// This will always be called after the format has been sucessfully
// negotiated. So we have a look at m_mt to see what format we agreed to.
// Then we can ask for buffers of the correct size to contain them.
HRESULT CSynthStream::DecideBufferSize(IMemAllocator *pAlloc,
                                       ALLOCATOR_PROPERTIES *pProperties)
{
    CAutoLock l(m_pFilter->pStateLock());
    ASSERT(pAlloc);
    ASSERT(pProperties);
    HRESULT hr = NOERROR;

    pProperties->cbBuffer = WaveBufferSize;

    int nBitsPerSample;
    int nSamplesPerSec;
    int nChannels;

    m_Synth->get_SamplesPerSec (&nSamplesPerSec);
    m_Synth->get_BitsPerSample (&nBitsPerSample);
    m_Synth->get_Channels (&nChannels);

    pProperties->cBuffers = nChannels * (nSamplesPerSec / pProperties->cbBuffer) * (nBitsPerSample / 8);
    // Get 1/2 second worth of buffers
    pProperties->cBuffers /= 2;
    if (pProperties->cBuffers < 1)
        pProperties->cBuffers = 1 ;

    // Ask the allocator to reserve us the memory

    ALLOCATOR_PROPERTIES Actual;
    hr = pAlloc->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        return hr;
    }

    // Is this allocator unsuitable

    if (Actual.cbBuffer < pProperties->cbBuffer) {
        return E_FAIL;
    }
    return NOERROR;
}


//
// SetMediaType
//
// Overriden from CBasePin.
HRESULT CSynthStream::SetMediaType(const CMediaType *pMediaType) {

    CAutoLock l(m_pFilter->pStateLock());

    HRESULT hr;         // return code from base class calls

    // Pass the call up to my base class
    hr = CSourceStream::SetMediaType(pMediaType);
    if (SUCCEEDED(hr))
        return NOERROR;
    else
        return hr;

}


//
// OnThreadCreate
//
// as we go active reset the stream time to zero
HRESULT CSynthStream::OnThreadCreate(void) {

    CAutoLock lShared(&m_cSharedState);

    m_rtSampleTime = 0;

    return NOERROR;
}

//
// Active
//
// Send a message to the property page telling it to disable
// buttons which change the format when the graph starts running
HRESULT CSynthStream::Active  (void) {
    m_Synth->AllocWaveCache();

    return CSourceStream::Active();
}


//
// Inactive
//
// Send a message to the property page telling it to enable
// buttons which change the format when the graph stops running
HRESULT CSynthStream::Inactive  (void) {
    return CSourceStream::Inactive();
}

// -------------------------------------------------------------------------
// CAudioSynth
// -------------------------------------------------------------------------
// Object that knows nothing about ActiveMovie, but just synthesizes
// waveforms

CAudioSynth::CAudioSynth(
                int Frequency,
                int Waveform,
                int iBitsPerSample,
                int iChannels,
                int iSamplesPerSec,
                int iAmplitude
                )
    : m_bWaveCache(NULL),
      m_wWaveCache(NULL)
{

    ASSERT(Waveform >= WAVE_SINE);
    ASSERT(Waveform <  WAVE_LAST);

    m_iFrequency = Frequency;
    m_iWaveform = Waveform;
    m_iAmplitude = iAmplitude;
    m_iSweepStart = DefaultSweepStart;
    m_iSweepEnd = DefaultSweepEnd;

    // init our WAVEFORMATEX structure
    wfex.wFormatTag = WAVE_FORMAT_PCM;
    wfex.wBitsPerSample = iBitsPerSample;
    wfex.nChannels = iChannels;
    wfex.nSamplesPerSec = iSamplesPerSec;
    wfex.nBlockAlign = wfex.wBitsPerSample * wfex.nChannels / 8;
    wfex.nAvgBytesPerSec = ((DWORD) wfex.nBlockAlign *
                           wfex.nSamplesPerSec);
    wfex.cbSize = 0;
}

CAudioSynth::~CAudioSynth()
{
    if (m_bWaveCache) {
        delete[] m_bWaveCache;
    }

    if (m_wWaveCache) {
        delete[] m_wWaveCache;
    }
}

//
// AllocWaveCache
//
//
void CAudioSynth::AllocWaveCache (void) {
    wfexLast = wfex;

    m_iWaveCacheCycles = m_iFrequency;
    m_iWaveCacheSize = (int) wfex.nSamplesPerSec;

    m_iFrequencyLast = 0;	// force cache contents invalid

    if (m_bWaveCache) {
        delete[] m_bWaveCache;
        m_bWaveCache = NULL;
    }
    if (m_wWaveCache) {
        delete[] m_wWaveCache;
        m_wWaveCache = NULL;
    }

    if (wfex.wBitsPerSample == 8)
        m_bWaveCache = new BYTE [m_iWaveCacheSize];
    else
        m_wWaveCache = new WORD [m_iWaveCacheSize];
}

//
// FillAudioBuffer
//
//
//
//
//
/**********************************************************************
fran: return a random float between min and max (ECM pg 417)
/**********************************************************************/
double 
CAudioSynth::fran(double min, double max)
{
    return((max - min) * ((double)rand()/RMAX) + min);
}

/**********************************************************************
iran: return a random int value between min and max (ECM pg 417)
**********************************************************************/
int 
CAudioSynth::iran(int min, int max)
{
    return((int)fran((double)min, max + 0.9999));
}


void CAudioSynth::CalcOneF (BYTE pBuf[], int len) {

	//define buffer related to wfex.nSamplesPerSec

  int i, n, lastn, length, numSamples, N;
  length = len;
   
  short *buffer;  
  float  halfrange;
  float *r;
  float  R;
	numSamples = 0;
	N = 4;  //default value.  make changeable later.
    r = (float *) malloc (N*sizeof(float));
	numSamples = (int)pow(2.0, (double)N);
    buffer  = (short *)malloc(numSamples*sizeof(short));
    
	// compute length of output sequence
    //for(length= 1, i= 0; i < N; i++)
	//length <<= 1;

	   // normalize halfrange so that sum of all generators always lies in (-1,1)
    halfrange = 1.0/N;

    lastn = length -1; // initialize previous index value

    // generate the sequence
    for(n= 0; n < length; n++) 
       {
       // at each step, check for changing bits and update corresponding random
       //numbers--thier sum is the output

       for(R= i= 0; i<N; i++)
		  {
			if(((1<<i)&n) != ((1<<i)&lastn))
			r[i]= fran(-halfrange, halfrange);
			R+=r[i];
			}
			//printf("%d %f\n", index, R);
		
	   *pBuf++ = (short)(R * 0x7FFF);
       lastn = n;
     }//end for(n)

}

//
// get_Frequency
//
STDMETHODIMP CAudioSynth::get_Frequency(int *Frequency) {

    *Frequency = m_iFrequency;

    DbgLog((LOG_TRACE, 3, TEXT("get_Frequency: %d"), *Frequency));

    return NOERROR;
}


//
// put_Frequency
//
STDMETHODIMP CAudioSynth::put_Frequency(int Frequency) {

    CAutoLock l(&m_SynthLock);

    m_iFrequency = Frequency;

    DbgLog((LOG_TRACE, 3, TEXT("put_Frequency: %d"), Frequency));

    return NOERROR;
}

//
// get_Waveform
//
STDMETHODIMP CAudioSynth::get_Waveform(int *Waveform) {

    *Waveform = m_iWaveform;

    DbgLog((LOG_TRACE, 3, TEXT("get_Waveform: %d"), *Waveform));

    return NOERROR;
}


//
// put_Waveform
//
STDMETHODIMP CAudioSynth::put_Waveform(int Waveform) {

    CAutoLock l(&m_SynthLock);

    m_iWaveform = Waveform;

    DbgLog((LOG_TRACE, 3, TEXT("put_Waveform: %d"), Waveform));

    return NOERROR;
}

//
// get_Channels
//
STDMETHODIMP CAudioSynth::get_Channels(int *Channels) {

    *Channels = wfex.nChannels;

    DbgLog((LOG_TRACE, 3, TEXT("get_Channels: %d"), *Channels));

    return NOERROR;
}


//
// get_BitsPerSample
//
STDMETHODIMP CAudioSynth::get_BitsPerSample(int *BitsPerSample) {

    *BitsPerSample = wfex.wBitsPerSample;

    DbgLog((LOG_TRACE, 3, TEXT("get_BitsPerSample: %d"), *BitsPerSample));

    return NOERROR;
}


//
// get_SamplesPerSec
//
STDMETHODIMP CAudioSynth::get_SamplesPerSec(int *SamplesPerSec) {

    *SamplesPerSec = wfex.nSamplesPerSec;

    DbgLog((LOG_TRACE, 3, TEXT("get_SamplesPerSec: %d"), *SamplesPerSec));

    return NOERROR;
}

//
// put_SynthFormat
//
STDMETHODIMP CAudioSynth::put_SynthFormat(int Channels, int BitsPerSample,
					  int SamplesPerSec) {

    CAutoLock l(&m_SynthLock);

    wfex.nChannels = Channels;

    wfex.wBitsPerSample = BitsPerSample;

    wfex.nSamplesPerSec = SamplesPerSec;

    DbgLog((LOG_TRACE, 1, TEXT("put_SynthFormat: %d-bit %d-channel %dHz"),
	    BitsPerSample, Channels, SamplesPerSec));

    return NOERROR;
}


//
// get_Amplitude
//
STDMETHODIMP CAudioSynth::get_Amplitude(int *Amplitude) {

    *Amplitude =  m_iAmplitude;

    DbgLog((LOG_TRACE, 3, TEXT("get_Amplitude: %d"), *Amplitude));

    return NOERROR;
}


//
// put_Amplitude
//
STDMETHODIMP CAudioSynth::put_Amplitude(int Amplitude) {

    CAutoLock l(&m_SynthLock);

    if (Amplitude > MaxAmplitude || Amplitude < MinAmplitude)
        return E_INVALIDARG;

    m_iAmplitude = Amplitude;

    DbgLog((LOG_TRACE, 3, TEXT("put_Amplitude: %d"), Amplitude));

    return NOERROR;
}


//
// get_SweepRange
//
STDMETHODIMP CAudioSynth::get_SweepRange(int *SweepStart, int *SweepEnd) {

    *SweepStart = m_iSweepStart;
    *SweepEnd = m_iSweepEnd;

    DbgLog((LOG_TRACE, 3, TEXT("get_SweepStart: %d %d"), *SweepStart, *SweepEnd));

    return NOERROR;
}


//
// put_SweepRange
//
STDMETHODIMP CAudioSynth::put_SweepRange(int SweepStart, int SweepEnd) {

    CAutoLock l(&m_SynthLock);

    m_iSweepStart = SweepStart;
    m_iSweepEnd = SweepEnd;

    DbgLog((LOG_TRACE, 3, TEXT("put_SweepRange: %d %d"), SweepStart, SweepEnd));

    return NOERROR;
}

/******************************Public*Routine******************************\
* exported entry points for registration and
* unregistration (in this case they only call
* through to default implmentations).
*
*
*
* History:
*
\**************************************************************************/
STDAPI
DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI
DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}


// call the quartz dll entry point (since filters need initialization)
extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE, ULONG, LPVOID);
BOOL WINAPI DllMain(HINSTANCE hinstDLL,  // handle to DLL module
    DWORD fdwReason,     // reason for calling function
    LPVOID lpvReserved   // reserved
    )
{
    return DllEntryPoint( hinstDLL, fdwReason, lpvReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\urlcache\reftime.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

//
// CRefTime
//
// Manage reference times.
// Shares same data layout as REFERENCE_TIME, but adds some (nonvirtual)
// functions providing simple comparison, conversion and arithmetic.
//
// A reference time (at the moment) is a unit of seconds represented in
// 100ns units as is used in the Win32 FILETIME structure. BUT the time
// a REFERENCE_TIME represents is NOT the time elapsed since 1/1/1601 it
// will either be stream time or reference time depending upon context
//
// This class provides simple arithmetic operations on reference times
//
// keep non-virtual otherwise the data layout will not be the same as
// REFERENCE_TIME


// -----
// note that you are safe to cast a CRefTime* to a REFERENCE_TIME*, but
// you will need to do so explicitly
// -----


#ifndef __REFTIME__
#define __REFTIME__


const LONGLONG MILLISECONDS = (1000);            // 10 ^ 3
const LONGLONG NANOSECONDS = (1000000000);       // 10 ^ 9
const LONGLONG UNITS = (NANOSECONDS / 100);      // 10 ^ 7

/*  Unfortunately an inline function here generates a call to __allmul
    - even for constants!
*/
#define MILLISECONDS_TO_100NS_UNITS(lMs) \
    Int32x32To64((lMs), (UNITS / MILLISECONDS))

class CRefTime
{
public:

    // *MUST* be the only data member so that this class is exactly
    // equivalent to a REFERENCE_TIME.
    // Also, must be *no virtual functions*

    REFERENCE_TIME m_time;

    inline CRefTime()
    {
        // default to 0 time
        m_time = 0;
    };

    inline CRefTime(LONG msecs)
    {
        m_time = MILLISECONDS_TO_100NS_UNITS(msecs);
    };

    inline CRefTime(REFERENCE_TIME rt)
    {
        m_time = rt;
    };

    inline operator REFERENCE_TIME() const
    {
        return m_time;
    };

    inline CRefTime& operator=(const CRefTime& rt)
    {
        m_time = rt.m_time;
        return *this;
    };

    inline CRefTime& operator=(const LONGLONG ll)
    {
        m_time = ll;
        return *this;
    };

    inline CRefTime& operator+=(const CRefTime& rt)
    {
        return (*this = *this + rt);
    };

    inline CRefTime& operator-=(const CRefTime& rt)
    {
        return (*this = *this - rt);
    };

    inline LONG Millisecs(void)
    {
        return (LONG)(m_time / (UNITS / MILLISECONDS));
    };

    inline LONGLONG GetUnits(void)
    {
        return m_time;
    };
};

const LONGLONG TimeZero = 0;

#endif /* __REFTIME__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\synth\onef\synth.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  synth.h
//
//  Audio Signal Generator

#ifndef __AUDIOSYNTH__
#define __AUDIOSYNTH__

// This was generated by Ken on 9/9/98
//CLSID_SynthFilter 
// {3D76319F-482D-11d2-AA53-00C04FC2F60F}
DEFINE_GUID(CLSID_SynthFilter, 
0x3d76319f, 0x482d, 0x11d2, 0xaa, 0x53, 0x0, 0xc0, 0x4f, 0xc2, 0xf6, 0xf);


// This was generated by Ken on 9/9/98
// {5A6D82AF-482E-11d2-AA53-00C04FC2F60F}
DEFINE_GUID(CLSID_SynthPropertyPage,
0x5a6d82af, 0x482e, 0x11d2, 0xaa, 0x53, 0x0, 0xc0, 0x4f, 0xc2, 0xf6, 0xf);


const double TWOPI = 6.283185308;
const int MaxFrequency = 20000;
const int MinFrequency = 0;
const int DefaultFrequency = 440;       // A-440
const int MaxAmplitude = 100;
const int MinAmplitude = 0;
const int DefaultSweepStart = DefaultFrequency;
const int DefaultSweepEnd = 5000;
const int WaveBufferSize = 16*1024;     // Size of each allocated buffer
                                        // Originally used to be 2K, but at
                                        // 44khz/16bit/stereo you would get
                                        // audio breaks with a transform in the
                                        // middle.

enum Waveforms {
    WAVE_SINE = 0,
    WAVE_SQUARE,
    WAVE_SAWTOOTH,
    WAVE_SINESWEEP,
    WAVE_LAST           // Always keep this guy last
};

#define WM_PROPERTYPAGE_ENABLE  (WM_USER + 100)

// below stuff is implementation-only....
#ifdef _AUDIOSYNTH_IMPLEMENTATION_

class CSynthStream;

// -------------------------------------------------------------------------
// CAudioSynth
// -------------------------------------------------------------------------

class CAudioSynth {

public:

    CAudioSynth(
                int Frequency = DefaultFrequency,
                int Waveform = WAVE_SINE,
                int iBitsPerSample = 8,
                int iChannels = 1,
                int iSamplesPerSec = 11025,
                int iAmplitude = 100
                );

    ~CAudioSynth();

    // Load the buffer with the current waveform
    void FillAudioBuffer (BYTE pBuf[], int iSize, BOOL * fNewFormat);
	// My version of loading buffer with current waveform!!
	void CalcOneF          (BYTE pBuf[], int iSize) ;  
    // Set the "current" format and allocate temporary memory
    void AllocWaveCache    (void) ;

    STDMETHODIMP get_Frequency(int *Frequency);
    STDMETHODIMP put_Frequency(int  Frequency);
    STDMETHODIMP get_Waveform(int *Waveform);
    STDMETHODIMP put_Waveform(int  Waveform);
    STDMETHODIMP get_Channels(int *Channels);
    STDMETHODIMP get_BitsPerSample(int *BitsPerSample);
    STDMETHODIMP get_SamplesPerSec(int *SamplesPerSec);
    STDMETHODIMP put_SynthFormat(int Channels, int BitsPerSample, int SamplesPerSec);
    STDMETHODIMP get_Amplitude(int *Amplitude);
    STDMETHODIMP put_Amplitude(int  Amplitude);
    STDMETHODIMP get_SweepRange(int *SweepStart, int *SweepEnd);
    STDMETHODIMP put_SweepRange(int  SweepStart, int  SweepEnd);

private:
    CCritSec m_SynthLock;

    WAVEFORMATEX wfex;          // the current format
    WAVEFORMATEX wfexLast;      // last known waveformat

    int m_iWaveform;            // WAVE_SINE ...
    int m_iFrequency;           // if not using sweep, this is the frequency
    int m_iAmplitude;           // 0 to 100

    int m_iWaveformLast;        // keep track of the last known format
    int m_iFrequencyLast;       // so we can flush the cache if necessary
    int m_iAmplitudeLast;

    int m_iCurrentSample;       // 0 to iSamplesPerSec-1
    BYTE * m_bWaveCache;        // Wave Cache as BYTEs
    WORD * m_wWaveCache;        // Wave Cache as WORDs
    int m_iWaveCacheSize;       // how big is the cache?
    int m_iWaveCacheCycles;     // how many cycles are in the cache
    int m_iWaveCacheIndex;

    int m_iSweepStart;           // start of sweep
    int m_iSweepEnd;             // end of sweep
//    double m_SweepDuration;     // how long the sweep lasts

    void CalcCacheSine     (void) ;
    void CalcCacheSquare   (void) ;
    void CalcCacheSawtooth (void) ;
    void CalcCacheSweep    (void) ;
	//void CalcOneF          (BYTE pBuf[]) ;
	int iran(int min, int max);
	double fran(double min, double max);

};



// -------------------------------------------------------------------------
// CSynthFilter
// -------------------------------------------------------------------------
// CSynthFilter manages filter level stuff

class CSynthFilter :    public ISynth,
                        public CPersistStream,
                        public ISpecifyPropertyPages,
                        public CSource {

public:

    static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);
    ~CSynthFilter();

    DECLARE_IUNKNOWN;

    // override this to reveal our property interface
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // --- ISpecifyPropertyPages ---

    // return our property pages
    STDMETHODIMP GetPages(CAUUID * pPages);

    // --- IPersistStream Interface

    STDMETHODIMP GetClassID(CLSID *pClsid);
    int SizeMax();
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);

    //
    // --- ISynth ---
    //

    STDMETHODIMP get_Frequency(int *Frequency);
    STDMETHODIMP put_Frequency(int Frequency);
    STDMETHODIMP get_Waveform(int *Waveform);
    STDMETHODIMP put_Waveform(int Waveform);
    STDMETHODIMP get_Channels(int *Channels);
    STDMETHODIMP get_BitsPerSample(int *BitsPerSample);
    STDMETHODIMP get_SamplesPerSec(int *SamplesPerSec);
    STDMETHODIMP put_Channels(int Channels);
    STDMETHODIMP put_BitsPerSample(int BitsPersample);
    STDMETHODIMP put_SamplesPerSec(int SamplesPerSec);
    STDMETHODIMP get_Amplitude(int *Amplitude);
    STDMETHODIMP put_Amplitude(int Amplitude);
    STDMETHODIMP get_SweepRange(int *SweepStart, int *SweepEnd);
    STDMETHODIMP put_SweepRange(int  SweepStart, int  SweepEnd);

    CAudioSynth *m_Synth;           // the current synthesizer
    int		m_Channels;
    int		m_BitsPerSample;
    int		m_SamplesPerSec;

private:

    // it is only allowed to to create these objects with CreateInstance
    CSynthFilter(LPUNKNOWN lpunk, HRESULT *phr);

    // When the format changes, reconnect...
    void CSynthFilter::ReconnectWithNewFormat(void);

};


// -------------------------------------------------------------------------
// CSynthStream
// -------------------------------------------------------------------------
// CSynthStream manages the data flow from the output pin.

class CSynthStream : public CSourceStream {

public:

    CSynthStream(HRESULT *phr, CSynthFilter *pParent, LPCWSTR pPinName);
    ~CSynthStream();

    BOOL ReadyToStop(void) {return FALSE;}

    // stuff an audio buffer with the current format
    HRESULT FillBuffer(IMediaSample *pms);

    // ask for buffers of the size appropriate to the agreed media type.
    HRESULT DecideBufferSize(IMemAllocator *pIMemAlloc,
                             ALLOCATOR_PROPERTIES *pProperties);

    // verify we can handle this format
    HRESULT CheckMediaType(const CMediaType *pMediaType);

    // set the agreed media type
    HRESULT SetMediaType(const CMediaType *pMediaType);

    HRESULT GetMediaType(CMediaType *pmt);

    // resets the stream time to zero.
    HRESULT OnThreadCreate(void);

    HRESULT Active   (void);
    HRESULT Inactive (void);

private:

    // Access to this state information should be serialized with the filters
    // critical section (m_pFilter->pStateLock())

    CCritSec    m_cSharedState;     // use this to lock access to m_rtSampleTime and m_Synth
                                    // which are shared with the worker thread.

    CRefTime     m_rtSampleTime;    // The time to be stamped on each sample
    CAudioSynth *m_Synth;           // the current synthesizer

    CSynthFilter *m_pParent;
};



#endif // _AUDIOSYNTH_IMPLEMENTATION_ implementation only....

#endif /* __AUDIOSYNTH__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\synth\onef\synthprp.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  synthprp.h
//
//  CSynthProperties

class CSynthProperties : public CBasePropertyPage {

public:

    CSynthProperties(LPUNKNOWN lpUnk, HRESULT *phr);
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();
    BOOL OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);

private:

    static BOOL CALLBACK DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    void    InitPropertiesDialog(HWND hwndParent);
    void    OnFreqSliderNotification(WPARAM wParam, WORD wPosition);
    void    OnAmpSliderNotification(WPARAM wParam, WORD wPosition);
    void    RecalcFreqSlider(void );
    void    SetDirty(void );

    HWND    m_hwndFreqSlider;           // handle of slider
    HWND    m_hwndFreqText;             // Handle of frequency text window
    HWND    m_hwndAmplitudeSlider;      // handle of slider
    HWND    m_hwndAmplitudeText;        // Handle of amplitude text window

    int     m_iWaveformOriginal;        // WAVE_SINE ...
    int     m_iFrequencyOriginal;       // if not using sweep, this is the frequency
    int     m_iBitsPerSampleOriginal;   // 8 or 16
    int     m_iChannelsOriginal;        // 1 or 2
    int     m_iSamplesPerSecOriginal;   // 8000, 11025, ...
    int     m_iAmplitudeOriginal;       // 0 to 100
    int     m_iSweepStart;              // Sweep range on freq slider
    int     m_iSweepEnd;

	BOOL	m_fWindowInActive;		// TRUE ==> dialog is in the process of being destroyed

    ISynth  *m_pSynth;                  // Interface to the synthsizer
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\include\apelutil.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    Utilities for clients of the AxA engine.

*******************************************************************************/


#ifndef _APELUTIL_H
#define _APELUTIL_H

#include "ocidl.h"

class AXAMsgFilter
{
  public:
    AXAMsgFilter();
    AXAMsgFilter(IDA3View * v, HWND hwnd);
    AXAMsgFilter(IDA3View * v, IOleInPlaceSiteWindowless * site);
    ~AXAMsgFilter();

    bool Filter(double when,
                UINT msg,
                WPARAM wParam,
                LPARAM lParam);

    bool Filter(DWORD dwMsgtime,
                UINT msg,
                WPARAM wParam,
                LPARAM lParam);

    double GetCurTime();
    double ConvertMsgTime(DWORD dwMsgtime);
    
    // Set the AxA view origin relative to its container.  Do this
    // because the AxA engine always interprets mouse position as
    // relative to the AxA view's upper-left-hand corner (which it
    // interprets as (0,0)). The problem is that the window system
    // gives us mouse positions relative to the container.  Setting
    // the view origin here allows our message filter to compensate
    // for this and pass down positions relative to the view to the
    // AxA engine.  If this is not called, this defaults to (0,0).
    void SetViewOrigin(unsigned short left, unsigned short top);

    IDA3View * GetView() { return _view; }
    void SetView(IDA3View * v) { _view = v; }

    HWND GetWindow() { return _hwnd; }
    void SetWindow(HWND hwnd) { _hwnd = hwnd; }

    IOleInPlaceSiteWindowless * GetSite() { return _site; }
    void SetSite(IOleInPlaceSiteWindowless * s) {
        if (_site) _site->Release();
        _site = s;
        if (_site) _site->AddRef();
    }
  protected:
    IDA3View * _view;
    HWND _hwnd;
    IOleInPlaceSiteWindowless * _site;
    BYTE _lastKeyMod;
    DWORD _lastKey;
    double _curtime;
    DWORD _lasttick;
    unsigned short _left;
    unsigned short _top;

    void ReportKeyup(double when, BOOL bReset = TRUE);
};


#endif /* _APELUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\include\axadefs.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _AXADEFS_H
#define _AXADEFS_H

#define AXA_MOUSE_BUTTON_LEFT    0
#define AXA_MOUSE_BUTTON_RIGHT   1
#define AXA_MOUSE_BUTTON_MIDDLE  2

#define AXA_STATE_DOWN       TRUE
#define AXA_STATE_UP         FALSE

#define AXAEMOD_SHIFT_MASK   0x01
#define AXAEMOD_CTRL_MASK    0x02
#define AXAEMOD_ALT_MASK     0x04
#define AXAEMOD_MENU_MASK    0x04
#define AXAEMOD_META_MASK    0x08

#define AXAEMOD_NONE         0x00
#define AXAEMOD_ALL          0xff

//
// Define the special keys
//

// For now these will be greater than any 16 bit value so that
// all chars can be stored in a single DWORD

// Base the numbers off of win32 vk's since it makes it simpler for
// win32 clients to convert the keys

#define VK_TO_AXAKEY(vk)     ((vk) + 0x00010000)
#define AXAKEY_TO_VK(k)      ((k)  - 0x00010000)

#define AXAKEY_PGUP          VK_TO_AXAKEY(VK_PRIOR)
#define AXAKEY_PGDN          VK_TO_AXAKEY(VK_NEXT)
#define AXAKEY_END           VK_TO_AXAKEY(VK_END)
#define AXAKEY_HOME          VK_TO_AXAKEY(VK_HOME)
#define AXAKEY_LEFT          VK_TO_AXAKEY(VK_LEFT)
#define AXAKEY_UP            VK_TO_AXAKEY(VK_UP)
#define AXAKEY_RIGHT         VK_TO_AXAKEY(VK_RIGHT)
#define AXAKEY_DOWN          VK_TO_AXAKEY(VK_DOWN)

#define AXAKEY_INSERT        VK_TO_AXAKEY(VK_INSERT)
#define AXAKEY_DELETE        VK_TO_AXAKEY(VK_DELETE)

#define AXAKEY_NUMPAD0       VK_TO_AXAKEY(VK_NUMPAD0)
#define AXAKEY_NUMPAD1       VK_TO_AXAKEY(VK_NUMPAD1)
#define AXAKEY_NUMPAD2       VK_TO_AXAKEY(VK_NUMPAD2)
#define AXAKEY_NUMPAD3       VK_TO_AXAKEY(VK_NUMPAD3)
#define AXAKEY_NUMPAD4       VK_TO_AXAKEY(VK_NUMPAD4)
#define AXAKEY_NUMPAD5       VK_TO_AXAKEY(VK_NUMPAD5)
#define AXAKEY_NUMPAD6       VK_TO_AXAKEY(VK_NUMPAD6)
#define AXAKEY_NUMPAD7       VK_TO_AXAKEY(VK_NUMPAD7)
#define AXAKEY_NUMPAD8       VK_TO_AXAKEY(VK_NUMPAD8)
#define AXAKEY_NUMPAD9       VK_TO_AXAKEY(VK_NUMPAD9)
#define AXAKEY_MULTIPLY      VK_TO_AXAKEY(VK_MULTIPLY)
#define AXAKEY_ADD           VK_TO_AXAKEY(VK_ADD)
#define AXAKEY_SEPARATOR     VK_TO_AXAKEY(VK_SEPARATOR)
#define AXAKEY_SUBTRACT      VK_TO_AXAKEY(VK_SUBTRACT)
#define AXAKEY_DECIMAL       VK_TO_AXAKEY(VK_DECIMAL)
#define AXAKEY_DIVIDE        VK_TO_AXAKEY(VK_DIVIDE)

#define AXAKEY_F1            VK_TO_AXAKEY(VK_F1)
#define AXAKEY_F2            VK_TO_AXAKEY(VK_F2)
#define AXAKEY_F3            VK_TO_AXAKEY(VK_F3)
#define AXAKEY_F4            VK_TO_AXAKEY(VK_F4)
#define AXAKEY_F5            VK_TO_AXAKEY(VK_F5)
#define AXAKEY_F6            VK_TO_AXAKEY(VK_F6)
#define AXAKEY_F7            VK_TO_AXAKEY(VK_F7)
#define AXAKEY_F8            VK_TO_AXAKEY(VK_F8)
#define AXAKEY_F9            VK_TO_AXAKEY(VK_F9)
#define AXAKEY_F10           VK_TO_AXAKEY(VK_F10)
#define AXAKEY_F11           VK_TO_AXAKEY(VK_F11)
#define AXAKEY_F12           VK_TO_AXAKEY(VK_F12)
#define AXAKEY_F13           VK_TO_AXAKEY(VK_F13)
#define AXAKEY_F14           VK_TO_AXAKEY(VK_F14)
#define AXAKEY_F15           VK_TO_AXAKEY(VK_F15)
#define AXAKEY_F16           VK_TO_AXAKEY(VK_F16)
#define AXAKEY_F17           VK_TO_AXAKEY(VK_F17)
#define AXAKEY_F18           VK_TO_AXAKEY(VK_F18)
#define AXAKEY_F19           VK_TO_AXAKEY(VK_F19)
#define AXAKEY_F20           VK_TO_AXAKEY(VK_F20)
#define AXAKEY_F21           VK_TO_AXAKEY(VK_F21)
#define AXAKEY_F22           VK_TO_AXAKEY(VK_F22)
#define AXAKEY_F23           VK_TO_AXAKEY(VK_F23)
#define AXAKEY_F24           VK_TO_AXAKEY(VK_F24)

inline BOOL AXAIsSpecialVK(UINT_PTR vk) {
    return ((vk >= VK_PRIOR && vk <= VK_DOWN) ||
            (vk >= VK_INSERT && vk <= VK_DELETE) ||
            (vk >= VK_NUMPAD0 && vk <= VK_DIVIDE) ||
            (vk >= VK_F1 && vk <= VK_F24)) ;
}

#endif /* _AXADEFS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\include\avengine.h ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _RBML_H
#define _RBML_H

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif

#include <windows.h>

#define WM_AXA_REDRAW  (WM_USER+0x200)

extern BOOL StartEngine (int argc, char **argv, char **env) ;

#endif /* _RBML_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\include\daatl.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _DAATL_H
#define _DAATL_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define _ATL_NO_DEBUG_CRT 1

#ifdef _DEBUG
#undef _ASSERTE
#endif

#define _ASSERTE(expr) ((void)0)

#define _ATL_STATIC_REGISTRY 1

#ifdef _DEBUG
inline void _cdecl AtlTrace2(LPCTSTR , ...){}
#define ATLTRACE            1 ? (void)0 : AtlTrace2
#endif

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#include <atlbase.h>

// We are overriding these methods so we can hook them and do some
// stuff ourselves.
class DAComModule : public CComModule
{
  public:
    LONG Lock();
    LONG Unlock();

#if DEVELOPER_DEBUG
    void AddComPtr(void *ptr, const _TCHAR * name);
    void RemoveComPtr(void *ptr);

    void DumpObjectList();
#endif
};

//#define _ATL_APARTMENT_THREADED
// THIS MUST BE CALLED _Module - all the ATL header files depend on it
extern DAComModule _Module;

#include <atlcom.h>
#include <atlctl.h>

#if _DEBUG
#include <typeinfo.h>
#endif

// COPIED FROM ATLCOM.H

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
class ModuleReleaser
{
  public:
    ModuleReleaser() {
        _Module.Lock();
    }

    ~ModuleReleaser() {
        _Module.Unlock();
    }
};

template <class Base>
class DAComObject 
    : public ModuleReleaser,
      public Base
{
  public:
    typedef Base _BaseClass;
    DAComObject(void* = NULL)
    {
#if DEVELOPER_DEBUG
#if _DEBUG
        _Module.AddComPtr(this, GetName());
#else
        _Module.AddComPtr(this, NULL);
#endif
#endif
    }
    // Set refcount to 1 to protect destruction
    ~DAComObject()
    {
#if DEVELOPER_DEBUG
        _Module.RemoveComPtr(this);
#endif
        m_dwRef = 1L;
        FinalRelease();
    }
    //If InternalAddRef or InteralRelease is undefined then your class
    //doesn't derive from CComObjectRoot
    STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
    STDMETHOD_(ULONG, Release)()
    {
        ULONG l = InternalRelease();
        if (l == 0)
            delete this;
        return l;
    }
    //if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
    {return _InternalQueryInterface(iid, ppvObject);}
    static HRESULT WINAPI CreateInstance(DAComObject<Base>** pp);
};

template <class Base>
HRESULT WINAPI DAComObject<Base>::CreateInstance(DAComObject<Base>** pp)
{
    _ASSERTE(pp != NULL);
    HRESULT hRes = E_OUTOFMEMORY;
    DAComObject<Base>* p = NULL;
    ATLTRY((p = new DAComObject<Base>()));
    if (p != NULL) {
        p->SetVoid(NULL);
        p->InternalFinalConstructAddRef();
        hRes = p->FinalConstruct();
        p->InternalFinalConstructRelease();
        if (hRes != S_OK) {
            delete p;
            p = NULL;
        }
    }
    *pp = p;
    return hRes;
}

#define DA_DECLARE_NOT_AGGREGATABLE(x) public:\
        typedef CComCreator2< CComCreator< DAComObject< x > >, CComFailCreator<CLASS_E_NOAGGREGATION> > _CreatorClass;
#define DA_DECLARE_AGGREGATABLE(x) public:\
        typedef CComCreator2< CComCreator< DAComObject< x > >, CComCreator< CComAggObject< x > > > _CreatorClass;

// END OF COPIED CODE
// Just to make things more uniform
#define RELEASE(x) if (x) { (x)->Release(); (x) = NULL; }

extern bool bFailedLoad;

#endif /* _DAATL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\include\daerror.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 *
 * Contains all the DirectAnimation error codes
 *
 *******************************************************************************/


#ifndef _DAERROR_H
#define _DAERROR_H

#include <winerror.h>

#define FACILITY_DIRECTANIMATION    FACILITY_ITF
#define DAERR_CODE_BEGIN            0x1000

#define DA_MAKE_HRESULT(i)          MAKE_HRESULT(SEVERITY_ERROR,            \
                                                 FACILITY_DIRECTANIMATION,  \
                                                 (DAERR_CODE_BEGIN + i))


// BEGIN - View specific error codes.
#define DAERR_VIEW_LOCKED               DA_MAKE_HRESULT(10)
#define DAERR_VIEW_TARGET_NOT_SET       DA_MAKE_HRESULT(11)
#define DAERR_VIEW_SURFACE_BUSY         DA_MAKE_HRESULT(12)
// End   - View specific error codes.

    
// BEGIN - DXTransform specific error codes.
#define DAERR_DXTRANSFORM_UNSUPPORTED_OPERATION               DA_MAKE_HRESULT(20)
// End   - DXTransform specific error codes.

    
#endif /* _DAERROR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\include\dalibc.h ===
#pragma once
#ifndef _DALIBC_H
#define _DALIBC_H

/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.
*******************************************************************************/

/*
const double pi    = 3.1415926535897932384626434;

// Point conversions
// 72 pts/ inch * 1/2.54 inch/cm * 100 cm/m
#define POINTS_PER_METER (72.0 * 100.0 / 2.54)
#define METERS_PER_POINT (1.0/POINTS_PER_METER)
*/

extern "C" {
        
    #define StrCmpNA  DAStrCmpNA
    #define StrCmpNIA DAStrCmpNIA
    #define StrRChrA  DAStrRChrA

    LPWSTR StrCpyW(LPWSTR psz1, LPCWSTR psz2);
    LPWSTR StrCpyNW(LPWSTR psz1, LPCWSTR psz2, int cchMax);
    LPWSTR StrCatW(LPWSTR psz1, LPCWSTR psz2);

    BOOL ChrCmpIA(WORD w1, WORD wMatch);
    BOOL ChrCmpIW(WORD w1, WORD wMatch);

    int StrCmpW(LPCWSTR pwsz1, LPCWSTR pwsz2);
    int StrCmpIW(LPCWSTR pwsz1, LPCWSTR pwsz2);
    int StrCmpNA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar);
    int StrCmpNW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar);
    int StrCmpNIA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar);
    int StrCmpNIW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar);

    LPSTR StrRChrA(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch);

    bool DALibStartup(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved);
};



/*****************************************************************************
This object maintains information about the current platform.
*****************************************************************************/

class SysInfo {

  public:

    void Init (void);

    bool IsNT (void);
    bool IsWin9x (void);    // Windows 95 or Windows 98

    // These return the MAJOR / MINOR versions of the OS.

    DWORD OSVersionMajor (void);
    DWORD OSVersionMinor (void);

    // This method queries the version of D3D on the system.

    int VersionD3D (void);

    // This method queries the version of DDraw on the system.  It returns
    // 3 for DDraw 3 or earlier, or N for DDraw N (where N is version 5 or
    // later.

    int VersionDDraw (void);

  private:

    OSVERSIONINFO _osVersion;     // OS Version Information
    int           _versionD3D;    // D3D Version Level
    int           _versionDDraw;  // DDraw Version Level
};

extern SysInfo sysInfo;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\filters\urlcache\urlcache.cpp ===
#include <streams.h>
#include "url.h"

static const GUID CLSID_UrlStreamRenderer = { /* bf0b4b00-8c6c-11d1-ade9-0000f8754b99 */
    0xbf0b4b00,
    0x8c6c,
    0x11d1,
    {0xad, 0xe9, 0x00, 0x00, 0xf8, 0x75, 0x4b, 0x99}
  };



AMOVIESETUP_MEDIATYPE sudURLSPinTypes[] =   {
  &MEDIATYPE_URL_STREAM,        // clsMajorType
  &MEDIATYPE_URL_STREAM };      // clsMinorType

AMOVIESETUP_PIN sudURLSPins[] =
{
  { L"Input"                    // strName
    , TRUE                      // bRendered
    , FALSE                     // bOutput
    , FALSE                     // bZero
    , FALSE                     // bMany
    , &CLSID_NULL               // clsConnectsToFilter
    , 0                         // strConnectsToPin
    , NUMELMS(sudURLSPinTypes)  // nTypes
    , sudURLSPinTypes           // lpTypes
  }
};


const AMOVIESETUP_FILTER sudURLS =
{
  &CLSID_UrlStreamRenderer      // clsID
  , L"URL StreamRenderer"       // strName
  , MERIT_NORMAL                // dwMerit
  , NUMELMS(sudURLSPins)        // nPins
  , sudURLSPins                 // lpPin
};

STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2(TRUE);
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2(FALSE);
}


class CUrlInPin : public CBaseInputPin
{
public:
    CUrlInPin(
        CBaseFilter *pFilter,
        CCritSec *pLock,
        HRESULT *phr
        );

    STDMETHODIMP Receive(IMediaSample *pSample);
    HRESULT CheckMediaType(const CMediaType *) ;
};

CUrlInPin::CUrlInPin(CBaseFilter *pFilter, CCritSec *pLock, HRESULT *phr) :
        CBaseInputPin(NAME("url in pin"), pFilter, pLock, phr, L"In")
{
    if(SUCCEEDED(*phr))
    {
    }
}

HRESULT CUrlInPin::CheckMediaType(const CMediaType *pmt)
{
    if(pmt->majortype == MEDIATYPE_URL_STREAM)
    {
        return S_OK;
    }
    return S_FALSE;
}

HRESULT CUrlInPin::Receive(IMediaSample *ps)
{
    HRESULT hrSignal = S_OK;
    
    HRESULT hr = CBaseInputPin::Receive(ps);
    if(hr == S_OK)
    {
        // determine length of url
        for(LONG ib = 0; ib < m_SampleProps.lActual; ib++)
        {
            if(m_SampleProps.pbBuffer[ib] == 0)
                break;
        }
        if(ib < m_SampleProps.lActual)
        {
            ULONG cbSz = ib + 1; // incl null
            BYTE *pbImage = m_SampleProps.pbBuffer + ib + 1;
            ULONG ibImage = ib + 1; // image starts here
            ULONG cbImage = m_SampleProps.lActual - cbSz;
            
            // don't know the time stamp of the actual ASF/AVI
            // file. so the authoring tool will have to generate a new
            // url each time (hopefully just use a guid).
            FILETIME zft;
            ZeroMemory(&zft, sizeof(&zft));

            FLAG fCreateCacheEntry;
            char *szUrl = (char *)m_SampleProps.pbBuffer;

            hr = QueryCreateCacheEntry(
                szUrl,
                &zft,
                &fCreateCacheEntry);

            if( hr == S_OK && fCreateCacheEntry )
            {
                char szExtension[ INTERNET_MAX_URL_LENGTH + 1 ];
                
                //
                // First, get the filename extension of the URL. We do
                // this so that the URL will show up in the IE cache
                // window with the right icon.
                //
                hr = GetUrlExtension(
                    szUrl,
                    szExtension );
                if(hr == S_OK)
                {
                    char szCacheFilePath [ MAX_PATH + 1 ];

                    BOOL b =  CreateUrlCacheEntryA( 
                        szUrl,
                        cbImage,
                        szExtension,
                        szCacheFilePath,
                        0 );
                    if(b)
                    {
                        HANDLE hFile = CreateFile(
                            szCacheFilePath,
                            GENERIC_WRITE,
                            0,  // share
                            0,  // lpSecurityAttribytes
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            0);
                        if(hFile != INVALID_HANDLE_VALUE)
                        {
                            DWORD cbWritten;
                            
                            b = WriteFile(
                                hFile,
                                pbImage,
                                cbImage,
                                &cbWritten,
                                0); // overlapped

                            EXECUTE_ASSERT(CloseHandle(hFile));
                            
                            if(b)
                            {
                                hFile = INVALID_HANDLE_VALUE;
                                
                                DWORD dwReserved = 0;
                                DWORD dwCacheEntryType = 0; // ???

                                static const char szHeader[] = "HTTP/1.0 200 OK\r\n\r\n";                                
                                b = CommitUrlCacheEntryA(
                                    szUrl, // unique src name
                                    szCacheFilePath, // local copy
                                    zft, // expire time
                                    zft, // last mod time
                                    dwCacheEntryType,
                                    (LPBYTE)szHeader,
                                    strlen( szHeader ),
                                    NULL, // lpszFileExtension, not used
                                    (DWORD_ALPHA_CAST)dwReserved );
                                if(b)
                                {
                                    // success! !!! should we lock the
                                    // file in the cache until the
                                    // graph stops?

                                    
                                }

                                ASSERT(cbWritten == cbImage);
                            } // WriteFile
                        } // CreateFile
                        else
                        {
                            b = FALSE;
                        }

                        if(!b)
                        {
                            // delete on error
                            DeleteUrlCacheEntry( szUrl );
                        }
                        
                    } // CreateUrlCacheEntryA

                    if(!b)
                    {
                        DWORD dw = GetLastError();
                        hr = HRESULT_FROM_WIN32( dw);
                    }                    
                }
            }

            if(FAILED(hr))
            {
                hrSignal = hr;
                hr = S_FALSE;   // stop pushing
            }

        }
        else
        {
            // no null terminator on string
            hrSignal = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            hr = S_FALSE;
        }
        
    } // base class receive

    if(SUCCEEDED(hrSignal))
    {
        return hr;
    }
    else
    {
        m_pFilter->NotifyEvent(EC_STREAM_ERROR_STOPPED, hrSignal, 0);
        return S_FALSE;
    }
}

class CUrlStreamRenderer : public CBaseFilter
{
    CCritSec m_cs;
    CUrlInPin m_inPin;

    int GetPinCount() { return 1; }
    CBasePin *GetPin(int n) { ASSERT(n == 0); return &m_inPin; }
    
    
public:
    CUrlStreamRenderer(LPUNKNOWN punk, HRESULT *phr);
    ~CUrlStreamRenderer() {; }

    static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

};

CFactoryTemplate g_Templates[]= {
  {L"URL StreamRenderer", &CLSID_UrlStreamRenderer, CUrlStreamRenderer::CreateInstance, NULL, &sudURLS},
};
int g_cTemplates = NUMELMS(g_Templates);

CUnknown *CUrlStreamRenderer::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    if(SUCCEEDED(*phr))
        return new CUrlStreamRenderer(lpunk, phr);
    else
        return 0;
}

#pragma warning(disable:4355)

CUrlStreamRenderer::CUrlStreamRenderer(LPUNKNOWN punk, HRESULT *phr) :
        CBaseFilter(NAME("URL Stream Filter"), punk, &m_cs, CLSID_UrlStreamRenderer),
        m_inPin(this, &m_cs, phr)
{
}

extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE, ULONG, LPVOID);


BOOL WINAPI DllMain(  HINSTANCE hinstDLL,  // handle to DLL module
  DWORD fdwReason,     // reason for calling function
  LPVOID lpvReserved   // reserved
)
{
    return DllEntryPoint( hinstDLL, fdwReason, lpvReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\include\dacomutil.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _DACOMUTIL_H
#define _DACOMUTIL_H

#define SET_NULL(x) {if (x) *(x) = NULL;}

#define CHECK_RETURN_NULL(x) {if (!(x)) return E_POINTER;}
#define CHECK_RETURN_SET_NULL(x) {if (!(x)) { return E_POINTER ;} else {*(x) = NULL;}}

template <class T>
class DAComPtr
{
  public:
    typedef T _PtrClass;
    DAComPtr() { p = NULL; }
    DAComPtr(T* lp, bool baddref = true)
    {
        p = lp;
        if (p != NULL && baddref)
            p->AddRef();
    }
    DAComPtr(const DAComPtr<T>& lp, bool baddref = true)
    {
        p = lp.p;

        if (p != NULL && baddref)
            p->AddRef();
    }
    ~DAComPtr() {
        if (p) p->Release();
    }
    void Release() {
        if (p) p->Release();
        p = NULL;
    }
    operator T*() { return (T*)p; }
    T& operator*() { Assert(p != NULL); return *p; }
    //The assert on operator& usually indicates a bug.  If this is really
    //what is needed, however, take the address of the p member explicitly.
    T** operator&() { Assert(p == NULL); return &p; }
    T* operator->() { Assert(p != NULL); return p; }
    T* operator=(T* lp)
    {
        return Assign(lp);
    }
    T* operator=(const DAComPtr<T>& lp)
    {
        return Assign(lp.p);
    }

    bool operator!() const { return (p == NULL); }
    operator bool() const { return (p != NULL); }

    T* p;
  protected:
    T* Assign(T* lp) {
        if (lp != NULL)
            lp->AddRef();

        if (p)
            p->Release();

        p = lp;

        return lp;
    }
};

#endif /* _DACOMUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\include\guids.h ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Appelles guids

--*/

#ifndef __GUIDS_H
#define __GUIDS_H

#endif  // __GUIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\include\dartapi.h ===
/*******************************************************************************
Copyright (c) 1998 Microsoft Corporation.  All rights reserved.
*******************************************************************************/


#ifndef _DARTAPI_H
#define _DARTAPI_H

class CRBvr;
typedef CRBvr * CRBvrPtr;
class CRBoolean;
typedef CRBoolean * CRBooleanPtr;
class CRCamera;
typedef CRCamera * CRCameraPtr;
class CRColor;
typedef CRColor * CRColorPtr;
class CRGeometry;
typedef CRGeometry * CRGeometryPtr;
class CRImage;
typedef CRImage * CRImagePtr;
class CRMatte;
typedef CRMatte * CRMattePtr;
class CRMicrophone;
typedef CRMicrophone * CRMicrophonePtr;
class CRMontage;
typedef CRMontage * CRMontagePtr;
class CRNumber;
typedef CRNumber * CRNumberPtr;
class CRPath2;
typedef CRPath2 * CRPath2Ptr;
class CRPoint2;
typedef CRPoint2 * CRPoint2Ptr;
class CRPoint3;
typedef CRPoint3 * CRPoint3Ptr;
class CRSound;
typedef CRSound * CRSoundPtr;
class CRString;
typedef CRString * CRStringPtr;
class CRTransform2;
typedef CRTransform2 * CRTransform2Ptr;
class CRTransform3;
typedef CRTransform3 * CRTransform3Ptr;
class CRVector2;
typedef CRVector2 * CRVector2Ptr;
class CRVector3;
typedef CRVector3 * CRVector3Ptr;
class CRFontStyle;
typedef CRFontStyle * CRFontStylePtr;
class CRLineStyle;
typedef CRLineStyle * CRLineStylePtr;
class CREndStyle;
typedef CREndStyle * CREndStylePtr;
class CRJoinStyle;
typedef CRJoinStyle * CRJoinStylePtr;
class CRDashStyle;
typedef CRDashStyle * CRDashStylePtr;
class CRBbox2;
typedef CRBbox2 * CRBbox2Ptr;
class CRBbox3;
typedef CRBbox3 * CRBbox3Ptr;
class CRPair;
typedef CRPair * CRPairPtr;
class CREvent;
typedef CREvent * CREventPtr;
class CRArray;
typedef CRArray * CRArrayPtr;
class CRTuple;
typedef CRTuple * CRTuplePtr;
class CRUserData;
typedef CRUserData * CRUserDataPtr;


enum CR_BVR_TYPEID {
    CRINVALID_TYPEID = -1,
    CRUNKNOWN_TYPEID = 0,
    CRBOOLEAN_TYPEID = 1,
    CRCAMERA_TYPEID = 2,
    CRCOLOR_TYPEID = 3,
    CRGEOMETRY_TYPEID = 4,
    CRIMAGE_TYPEID = 5,
    CRMATTE_TYPEID = 6,
    CRMICROPHONE_TYPEID = 7,
    CRMONTAGE_TYPEID = 8,
    CRNUMBER_TYPEID = 9,
    CRPATH2_TYPEID = 10,
    CRPOINT2_TYPEID = 11,
    CRPOINT3_TYPEID = 12,
    CRSOUND_TYPEID = 13,
    CRSTRING_TYPEID = 14,
    CRTRANSFORM2_TYPEID = 15,
    CRTRANSFORM3_TYPEID = 16,
    CRVECTOR2_TYPEID = 17,
    CRVECTOR3_TYPEID = 18,
    CRFONTSTYLE_TYPEID = 19,
    CRLINESTYLE_TYPEID = 20,
    CRENDSTYLE_TYPEID = 21,
    CRJOINSTYLE_TYPEID = 22,
    CRDASHSTYLE_TYPEID = 23,
    CRBBOX2_TYPEID = 24,
    CRBBOX3_TYPEID = 25,
    CRPAIR_TYPEID = 26,
    CREVENT_TYPEID = 27,
    CRARRAY_TYPEID = 28,
    CRTUPLE_TYPEID = 29,
    CRUSERDATA_TYPEID = 30,
};


#ifndef CRSTDAPI

#ifndef _DART_

#define CRSTDAPI            __declspec( dllimport ) HRESULT STDAPICALLTYPE
#define CRSTDAPI_(type)     __declspec( dllimport ) type STDAPICALLTYPE

#define CRSTDAPICB          HRESULT STDAPICALLTYPE
#define CRSTDAPICB_(type)   type STDAPICALLTYPE

#else // _DART_

#define CRSTDAPI            __declspec( dllexport ) HRESULT STDAPICALLTYPE
#define CRSTDAPI_(type)     __declspec( dllexport ) type STDAPICALLTYPE

#define CRSTDAPICB          HRESULT STDAPICALLTYPE
#define CRSTDAPICB_(type)   type STDAPICALLTYPE

#endif // _DART_

#endif

// Base types

class CRBaseCB
{
  public:
    virtual CRSTDAPICB_(ULONG) AddRef() = 0;
    virtual CRSTDAPICB_(ULONG) Release() = 0;
};

typedef CRBaseCB * CRBaseCBPtr;

class CRView;
typedef CRView * CRViewPtr;

class CRViewSite : public CRBaseCB
{
  public:
    virtual CRSTDAPICB_(void) SetStatusText(LPCWSTR StatusText) = 0;
};

typedef CRViewSite * CRViewSitePtr;

// Callbacks

class CRUntilNotifier : public CRBaseCB
{
  public:
    virtual CRSTDAPICB_(CRBvrPtr) Notify(CRBvrPtr eventData,
                                         CRBvrPtr curRunningBvr,
                                         CRViewPtr curView) = 0;
};

typedef CRUntilNotifier * CRUntilNotifierPtr;

class CRBvrHook : public CRBaseCB
{
  public:
    virtual CRSTDAPICB_(CRBvrPtr) Notify(long id,
                                         bool startingPerformance,
                                         double startTime,
                                         double gTime,
                                         double lTime,
                                         CRBvrPtr sampleVal,
                                         CRBvrPtr curRunningBvr) = 0;
};

typedef CRBvrHook * CRBvrHookPtr;

class CRSite : public CRBaseCB
{
  public:
    virtual CRSTDAPICB_(void) SetStatusText(LPCWSTR StatusText) = 0;
    virtual CRSTDAPICB_(void) ReportError(HRESULT hr, LPCWSTR ErrorText) = 0;
    virtual CRSTDAPICB_(void) ReportGC(bool bStarting) = 0;
};

typedef CRSite * CRSitePtr;

class CRImportSite : public CRBaseCB
{
  public:
    virtual CRSTDAPICB_(void) SetStatusText(DWORD importId, LPCWSTR StatusText) = 0;
    virtual CRSTDAPICB_(void) ReportError(DWORD importId, HRESULT hr, LPCWSTR ErrorText) = 0;

    virtual CRSTDAPICB_(void) OnImportStart(DWORD importId) = 0;
    virtual CRSTDAPICB_(void) OnImportStop(DWORD importId) = 0;
    virtual CRSTDAPICB_(void) OnImportCreate(DWORD importId, bool async) = 0;
};

typedef CRImportSite * CRImportSitePtr;

// Results

class CRPickableResult;
typedef CRPickableResult * CRPickableResultPtr;

class CRImportationResult;
typedef CRImportationResult * CRImportationResultPtr;

class CRDXTransformResult;
typedef CRDXTransformResult * CRDXTransformResultPtr;

class TriMeshData;

CRSTDAPI_(CRNumber *) CRPow(CRNumber * a, CRNumber * b);
CRSTDAPI_(CRNumber *) CRAbs(CRNumber * a);
CRSTDAPI_(CRNumber *) CRSqrt(CRNumber * a);
CRSTDAPI_(CRNumber *) CRFloor(CRNumber * a);
CRSTDAPI_(CRNumber *) CRRound(CRNumber * a);
CRSTDAPI_(CRNumber *) CRCeiling(CRNumber * a);
CRSTDAPI_(CRNumber *) CRAsin(CRNumber * a);
CRSTDAPI_(CRNumber *) CRAcos(CRNumber * a);
CRSTDAPI_(CRNumber *) CRAtan(CRNumber * a);
CRSTDAPI_(CRNumber *) CRSin(CRNumber * a);
CRSTDAPI_(CRNumber *) CRCos(CRNumber * a);
CRSTDAPI_(CRNumber *) CRTan(CRNumber * a);
CRSTDAPI_(CRNumber *) CRExp(CRNumber * a);
CRSTDAPI_(CRNumber *) CRLn(CRNumber * a);
CRSTDAPI_(CRNumber *) CRLog10(CRNumber * a);
CRSTDAPI_(CRNumber *) CRToDegrees(CRNumber * a);
CRSTDAPI_(CRNumber *) CRToRadians(CRNumber * a);
CRSTDAPI_(CRNumber *) CRMod(CRNumber * a, CRNumber * b);
CRSTDAPI_(CRNumber *) CRAtan2(CRNumber * a, CRNumber * b);
CRSTDAPI_(CRBvr *) CRFirst(CRPair * p);
CRSTDAPI_(CRBvr *) CRSecond(CRPair * p);
CRSTDAPI_(CRNumber *) CRAdd(CRNumber * a, CRNumber * b);
CRSTDAPI_(CRNumber *) CRSub(CRNumber * a, CRNumber * b);
CRSTDAPI_(CRNumber *) CRMul(CRNumber * a, CRNumber * b);
CRSTDAPI_(CRNumber *) CRDiv(CRNumber * a, CRNumber * b);
CRSTDAPI_(CRBoolean *) CRLT(CRNumber * a, CRNumber * b);
CRSTDAPI_(CRBoolean *) CRLTE(CRNumber * a, CRNumber * b);
CRSTDAPI_(CRBoolean *) CRGT(CRNumber * a, CRNumber * b);
CRSTDAPI_(CRBoolean *) CRGTE(CRNumber * a, CRNumber * b);
CRSTDAPI_(CRBoolean *) CREQ(CRNumber * a, CRNumber * b);
CRSTDAPI_(CRBoolean *) CRNE(CRNumber * a, CRNumber * b);
CRSTDAPI_(CRNumber *) CRNeg(CRNumber * a);
CRSTDAPI_(CRNumber *) CRInterpolate(CRNumber * from, CRNumber * to, CRNumber * duration);
CRSTDAPI_(CRNumber *) CRInterpolate(double from, double to, double duration);
CRSTDAPI_(CRNumber *) CRSlowInSlowOut(CRNumber * from, CRNumber * to, CRNumber * duration, CRNumber * sharpness);
CRSTDAPI_(CRNumber *) CRSlowInSlowOut(double from, double to, double duration, double sharpness);
CRSTDAPI_(CRSound *) CRRenderSound(CRGeometry * geom, CRMicrophone * mic);
CRSTDAPI_(CRGeometry *) CRSoundSource(CRSound * snd);
CRSTDAPI_(CRSound *) CRMix(CRSound * left, CRSound * right);
CRSTDAPI_(CRBoolean *) CRAnd(CRBoolean * a, CRBoolean * b);
CRSTDAPI_(CRBoolean *) CROr(CRBoolean * a, CRBoolean * b);
CRSTDAPI_(CRBoolean *) CRNot(CRBoolean * a);
CRSTDAPI_(CRNumber *) CRIntegral(CRNumber * b);
CRSTDAPI_(CRNumber *) CRDerivative(CRNumber * b);
CRSTDAPI_(CRVector2 *) CRIntegral(CRVector2 * v);
CRSTDAPI_(CRVector3 *) CRIntegral(CRVector3 * v);
CRSTDAPI_(CRVector2 *) CRDerivative(CRVector2 * v);
CRSTDAPI_(CRVector3 *) CRDerivative(CRVector3 * v);
CRSTDAPI_(CRVector2 *) CRDerivative(CRPoint2 * v);
CRSTDAPI_(CRVector3 *) CRDerivative(CRPoint3 * v);
CRSTDAPI_(CRBoolean *) CRKeyState(CRNumber * n);
CRSTDAPI_(CREvent *) CRKeyUp(LONG arg0);
CRSTDAPI_(CREvent *) CRKeyDown(LONG arg0);
CRSTDAPI_(CRNumber *) CRCreateNumber(double num);
CRSTDAPI_(CRString *) CRCreateString(LPWSTR str);
CRSTDAPI_(CRBoolean *) CRCreateBoolean(bool num);
CRSTDAPI_(double) CRExtract(CRNumber * num);
CRSTDAPI_(CRNumber *) CRSeededRandom(double arg0);
CRSTDAPI_(LPWSTR) CRExtract(CRString * str);
CRSTDAPI_(bool) CRExtract(CRBoolean * b);
CRSTDAPI_(CRBvr *) CRNth(CRArray * arr, CRNumber * index);
CRSTDAPI_(CRNumber *) CRLength(CRArray * arr);
CRSTDAPI_(CRBvr *) CRNth(CRTuple * t, long index);
CRSTDAPI_(long) CRLength(CRTuple * t);
CRSTDAPI_(CRPoint2 *) CRMousePosition();
CRSTDAPI_(CRBoolean *) CRLeftButtonState();
CRSTDAPI_(CRBoolean *) CRRightButtonState();
CRSTDAPI_(CRBoolean *) CRTrue();
CRSTDAPI_(CRBoolean *) CRFalse();
CRSTDAPI_(CRNumber *) CRLocalTime();
CRSTDAPI_(CRNumber *) CRGlobalTime();
CRSTDAPI_(CRNumber *) CRPixel();
CRSTDAPI_(CRUserData *) CRCreateUserData(IUnknown * data);
CRSTDAPI_(IUnknown *) CRGetData(CRUserData * data);
CRSTDAPI_(CRBvr *) CRUntilNotify(CRBvr * b0, CREvent * event, CRUntilNotifier * notifier);
CRSTDAPI_(CRBvr *) CRUntil(CRBvr * b0, CREvent * event, CRBvr * b1);
CRSTDAPI_(CRBvr *) CRUntilEx(CRBvr * b0, CREvent * event);
CRSTDAPI_(CRBvr *) CRSequence(CRBvr * s1, CRBvr * s2);
CRSTDAPI_(CRBvr *) CRSequenceArray(long s, CRBvrPtr pBvrs[]);
CRSTDAPI_(CRPickableResult *) CRPickable(CRImage * img);
CRSTDAPI_(CRPickableResult *) CRPickable(CRGeometry * geom);
CRSTDAPI_(CRPickableResult *) CRPickableOccluded(CRImage * img);
CRSTDAPI_(CRPickableResult *) CRPickableOccluded(CRGeometry * geom);
CRSTDAPI_(CRTransform2 *) CRFollowPath(CRPath2 * path, double duration);
CRSTDAPI_(CRTransform2 *) CRFollowPathAngle(CRPath2 * path, double duration);
CRSTDAPI_(CRTransform2 *) CRFollowPathAngleUpright(CRPath2 * path, double duration);
CRSTDAPI_(CRTransform2 *) CRFollowPathEval(CRPath2 * path, CRNumber * eval);
CRSTDAPI_(CRTransform2 *) CRFollowPathAngleEval(CRPath2 * path, CRNumber * eval);
CRSTDAPI_(CRTransform2 *) CRFollowPathAngleUprightEval(CRPath2 * path, CRNumber * eval);
CRSTDAPI_(CRTransform2 *) CRFollowPath(CRPath2 * obsoleted1, CRNumber * obsoleted2);
CRSTDAPI_(CRTransform2 *) CRFollowPathAngle(CRPath2 * obsoleted1, CRNumber * obsoleted2);
CRSTDAPI_(CRTransform2 *) CRFollowPathAngleUpright(CRPath2 * obsoleted1, CRNumber * obsoleted2);
CRSTDAPI_(CRImage *) CRAddPickData(CRImage * img, IUnknown * id, bool ignoresOcclusion);
CRSTDAPI_(CRGeometry *) CRAddPickData(CRGeometry * geo, IUnknown * id, bool ignoresOcclusion);
CRSTDAPI_(long) CRAddElement(CRArray * arr, CRBvr * b, DWORD flag);
CRSTDAPI_(bool) CRRemoveElement(CRArray * arr, long i);
CRSTDAPI_(bool) CRSetElement(CRArray * arr, long i, CRBvr * b, long flag);
CRSTDAPI_(CRBvr *) CRGetElement(CRArray * arr, long i);
CRSTDAPI_(CRString *) CRConcatString(CRString * s1, CRString * s2);
CRSTDAPI_(CRPoint2 *) CRMin(CRBbox2 * box);
CRSTDAPI_(CRPoint2 *) CRMax(CRBbox2 * box);
CRSTDAPI_(CRPoint3 *) CRMin(CRBbox3 * box);
CRSTDAPI_(CRPoint3 *) CRMax(CRBbox3 * box);
CRSTDAPI_(CRCamera *) CRPerspectiveCamera(double focalDist, double nearClip);
CRSTDAPI_(CRCamera *) CRPerspectiveCameraAnim(CRNumber * focalDist, CRNumber * nearClip);
CRSTDAPI_(CRCamera *) CRParallelCamera(double nearClip);
CRSTDAPI_(CRCamera *) CRParallelCameraAnim(CRNumber * nearClip);
CRSTDAPI_(CRCamera *) CRTransform(CRCamera * cam, CRTransform3 * xf);
CRSTDAPI_(CRCamera *) CRDepth(CRCamera * cam, double depth);
CRSTDAPI_(CRCamera *) CRDepth(CRCamera * cam, CRNumber * depth);
CRSTDAPI_(CRCamera *) CRDepthResolution(CRCamera * cam, double resolution);
CRSTDAPI_(CRCamera *) CRDepthResolution(CRCamera * cam, CRNumber * resolution);
CRSTDAPI_(CRPoint2 *) CRProject(CRPoint3 * pt, CRCamera * cam);
CRSTDAPI_(CRColor *) CRColorRgb(CRNumber * red, CRNumber * green, CRNumber * blue);
CRSTDAPI_(CRColor *) CRColorRgb(double red, double green, double blue);
CRSTDAPI_(CRColor *) CRColorRgb255(short red, short green, short blue);
CRSTDAPI_(CRColor *) CRColorHsl(double hue, double saturation, double lum);
CRSTDAPI_(CRColor *) CRColorHsl(CRNumber * hue, CRNumber * saturation, CRNumber * lum);
CRSTDAPI_(CRNumber *) CRGetRed(CRColor * color);
CRSTDAPI_(CRNumber *) CRGetGreen(CRColor * color);
CRSTDAPI_(CRNumber *) CRGetBlue(CRColor * color);
CRSTDAPI_(CRNumber *) CRGetHue(CRColor * color);
CRSTDAPI_(CRNumber *) CRGetSaturation(CRColor * color);
CRSTDAPI_(CRNumber *) CRGetLightness(CRColor * color);
CRSTDAPI_(CRColor *) CRRed();
CRSTDAPI_(CRColor *) CRGreen();
CRSTDAPI_(CRColor *) CRBlue();
CRSTDAPI_(CRColor *) CRCyan();
CRSTDAPI_(CRColor *) CRMagenta();
CRSTDAPI_(CRColor *) CRYellow();
CRSTDAPI_(CRColor *) CRBlack();
CRSTDAPI_(CRColor *) CRWhite();
CRSTDAPI_(CRColor *) CRAqua();
CRSTDAPI_(CRColor *) CRFuchsia();
CRSTDAPI_(CRColor *) CRGray();
CRSTDAPI_(CRColor *) CRLime();
CRSTDAPI_(CRColor *) CRMaroon();
CRSTDAPI_(CRColor *) CRNavy();
CRSTDAPI_(CRColor *) CROlive();
CRSTDAPI_(CRColor *) CRPurple();
CRSTDAPI_(CRColor *) CRSilver();
CRSTDAPI_(CRColor *) CRTeal();
CRSTDAPI_(CREvent *) CRPredicate(CRBoolean * b);
CRSTDAPI_(CREvent *) CRNotEvent(CREvent * event);
CRSTDAPI_(CREvent *) CRAndEvent(CREvent * e1, CREvent * e2);
CRSTDAPI_(CREvent *) CROrEvent(CREvent * e1, CREvent * e2);
CRSTDAPI_(CREvent *) CRThenEvent(CREvent * e1, CREvent * e2);
CRSTDAPI_(CREvent *) CRLeftButtonDown();
CRSTDAPI_(CREvent *) CRLeftButtonUp();
CRSTDAPI_(CREvent *) CRRightButtonDown();
CRSTDAPI_(CREvent *) CRRightButtonUp();
CRSTDAPI_(CREvent *) CRAlways();
CRSTDAPI_(CREvent *) CRNever();
CRSTDAPI_(CREvent *) CRTimer(CRNumber * n);
CRSTDAPI_(CREvent *) CRTimer(double n);
CRSTDAPI_(CREvent *) CRNotify(CREvent * event, CRUntilNotifier * notifier);
CRSTDAPI_(CREvent *) CRSnapshot(CREvent * event, CRBvr * b);
CRSTDAPI_(CREvent *) CRAppTriggeredEvent();
CRSTDAPI_(CREvent *) CRAttachData(CREvent * event, CRBvr * data);
CRSTDAPI_(CRGeometry *) CRUndetectable(CRGeometry * geo);
CRSTDAPI_(CRGeometry *) CREmissiveColor(CRGeometry * geo, CRColor * col);
CRSTDAPI_(CRGeometry *) CRDiffuseColor(CRGeometry * geo, CRColor * col);
CRSTDAPI_(CRGeometry *) CRSpecularColor(CRGeometry * geo, CRColor * col);
CRSTDAPI_(CRGeometry *) CRSpecularExponent(CRGeometry * geo, double power);
CRSTDAPI_(CRGeometry *) CRSpecularExponentAnim(CRGeometry * geo, CRNumber * power);
CRSTDAPI_(CRGeometry *) CRTexture(CRGeometry * geo, CRImage * texture);
CRSTDAPI_(CRGeometry *) CROpacity(CRGeometry * geom, double level);
CRSTDAPI_(CRGeometry *) CROpacity(CRGeometry * geom, CRNumber * level);
CRSTDAPI_(CRGeometry *) CRTransform(CRGeometry * geo, CRTransform3 * xf);
CRSTDAPI_(CRGeometry *) CRShadow(CRGeometry * geoToShadow, CRGeometry * geoContainingLights, CRPoint3 * planePoint, CRVector3 * planeNormal);
CRSTDAPI_(CRGeometry *) CREmptyGeometry();
CRSTDAPI_(CRGeometry *) CRUnionGeometry(CRGeometry * g1, CRGeometry * g2);
CRSTDAPI_(CRGeometry *) CRUnionGeometry(CRArrayPtr imgs);
CRSTDAPI_(CRBbox3 *) CRBoundingBox(CRGeometry * geo);
CRSTDAPI_(CRImage *) CREmptyImage();
CRSTDAPI_(CRImage *) CRDetectableEmptyImage();
CRSTDAPI_(CRImage *) CRRender(CRGeometry * geo, CRCamera * cam);
CRSTDAPI_(CRImage *) CRSolidColorImage(CRColor * col);
CRSTDAPI_(CRImage *) CRGradientPolygon(CRArrayPtr points, CRArrayPtr colors);
CRSTDAPI_(CRImage *) CRRadialGradientPolygon(CRColor * inner, CRColor * outer, CRArrayPtr points, double fallOff);
CRSTDAPI_(CRImage *) CRRadialGradientPolygon(CRColor * inner, CRColor * outer, CRArrayPtr points, CRNumber * fallOff);
CRSTDAPI_(CRImage *) CRGradientSquare(CRColor * lowerLeft, CRColor * upperLeft, CRColor * upperRight, CRColor * lowerRight);
CRSTDAPI_(CRImage *) CRRadialGradientSquare(CRColor * inner, CRColor * outer, double fallOff);
CRSTDAPI_(CRImage *) CRRadialGradientSquare(CRColor * inner, CRColor * outer, CRNumber * fallOff);
CRSTDAPI_(CRImage *) CRRadialGradientRegularPoly(CRColor * inner, CRColor * outer, double numEdges, double fallOff);
CRSTDAPI_(CRImage *) CRRadialGradientRegularPoly(CRColor * inner, CRColor * outer, CRNumber * numEdges, CRNumber * fallOff);
CRSTDAPI_(CRImage *) CRRadialGradientMulticolor(CRArrayPtr offsets, CRArrayPtr colors);
CRSTDAPI_(CRImage *) CRLinearGradientMulticolor(CRArrayPtr offsets, CRArrayPtr colors);
CRSTDAPI_(CRImage *) CRGradientHorizontal(CRColor * start, CRColor * stop, double fallOff);
CRSTDAPI_(CRImage *) CRGradientHorizontal(CRColor * start, CRColor * stop, CRNumber * fallOff);
CRSTDAPI_(CRImage *) CRHatchHorizontal(CRColor * lineClr, double spacing);
CRSTDAPI_(CRImage *) CRHatchHorizontal(CRColor * lineClr, CRNumber * spacing);
CRSTDAPI_(CRImage *) CRHatchVertical(CRColor * lineClr, double spacing);
CRSTDAPI_(CRImage *) CRHatchVertical(CRColor * lineClr, CRNumber * spacing);
CRSTDAPI_(CRImage *) CRHatchForwardDiagonal(CRColor * lineClr, double spacing);
CRSTDAPI_(CRImage *) CRHatchForwardDiagonal(CRColor * lineClr, CRNumber * spacing);
CRSTDAPI_(CRImage *) CRHatchBackwardDiagonal(CRColor * lineClr, double spacing);
CRSTDAPI_(CRImage *) CRHatchBackwardDiagonal(CRColor * lineClr, CRNumber * spacing);
CRSTDAPI_(CRImage *) CRHatchCross(CRColor * lineClr, double spacing);
CRSTDAPI_(CRImage *) CRHatchCross(CRColor * lineClr, CRNumber * spacing);
CRSTDAPI_(CRImage *) CRHatchDiagonalCross(CRColor * lineClr, double spacing);
CRSTDAPI_(CRImage *) CRHatchDiagonalCross(CRColor * lineClr, CRNumber * spacing);
CRSTDAPI_(CRImage *) CROverlay(CRImage * top, CRImage * bottom);
CRSTDAPI_(CRImage *) CROverlay(CRArrayPtr imgs);
CRSTDAPI_(CRBbox2 *) CRBoundingBox(CRImage * image);
CRSTDAPI_(CRImage *) CRCrop(CRImage * image, CRPoint2 * min, CRPoint2 * max);
CRSTDAPI_(CRImage *) CRTransform(CRImage * image, CRTransform2 * xf);
CRSTDAPI_(CRImage *) CROpacity(CRImage * image, CRNumber * opacity);
CRSTDAPI_(CRImage *) CROpacity(CRImage * image, double opacity);
CRSTDAPI_(CRImage *) CRUndetectable(CRImage * image);
CRSTDAPI_(CRImage *) CRTile(CRImage * image);
CRSTDAPI_(CRImage *) CRClip(CRImage * image, CRMatte * m);
CRSTDAPI_(CRImage *) CRMapToUnitSquare(CRImage * image);
CRSTDAPI_(CRImage *) CRClipPolygonImage(CRImage * image, CRArrayPtr points);
CRSTDAPI_(CRImage *) CRRenderResolution(CRImage * img, long width, long height);
CRSTDAPI_(CRImage *) CRImageQuality(CRImage * img, DWORD dwQualityFlags);
CRSTDAPI_(CRImage *) CRColorKey(CRImage * image, CRColor * colorKey);
CRSTDAPI_(CRImage *) CRTransformColorRGB(CRImage * arg0, CRTransform3 * arg1);
CRSTDAPI_(CRGeometry*) CRAmbientLight();
CRSTDAPI_(CRGeometry*) CRDirectionalLight();
CRSTDAPI_(CRGeometry*) CRPointLight();
CRSTDAPI_(CRGeometry*) CRSpotLight(CRNumber * fullcone, CRNumber * cutoff);
CRSTDAPI_(CRGeometry*) CRSpotLight(CRNumber * fullcone, double cutoff);
CRSTDAPI_(CRGeometry*) CRLightColor(CRGeometry * geom, CRColor * color);
CRSTDAPI_(CRGeometry*) CRLightRange(CRGeometry * geom, CRNumber * range);
CRSTDAPI_(CRGeometry*) CRLightRange(CRGeometry * geom, double range);
CRSTDAPI_(CRGeometry*) CRLightAttenuation(CRGeometry * geom, CRNumber * constant, CRNumber * linear, CRNumber * quadratic);
CRSTDAPI_(CRGeometry*) CRLightAttenuation(CRGeometry * geom, double constant, double linear, double quadratic);
CRSTDAPI_(CRGeometry*) CRBlendTextureDiffuse(CRGeometry * geometry, CRBoolean * blended);
CRSTDAPI_(CRGeometry*) CRAmbientColor(CRGeometry * geo, CRColor * color);
CRSTDAPI_(CRGeometry*) CRD3DRMTexture(CRGeometry * geo, IUnknown * rmTex);
CRSTDAPI_(CRGeometry*) CRModelClip(CRGeometry * geo, CRPoint3 * planePt, CRVector3 * planeVec);
CRSTDAPI_(CRGeometry*) CRLighting(CRGeometry * geo, CRBoolean * lighting);
CRSTDAPI_(CRGeometry*) CRTextureImage(CRGeometry * geo, CRImage * texture);
CRSTDAPI_(CRGeometry*) CRBillboard (CRGeometry*, CRVector3*);
CRSTDAPI_(CRGeometry*) CRTriMesh (TriMeshData &tm);
CRSTDAPI_(CRLineStyle *) CRDefaultLineStyle();
CRSTDAPI_(CRLineStyle *) CREmptyLineStyle();
CRSTDAPI_(CRLineStyle *) CREnd(CRLineStyle * lsty, CREndStyle * sty);
CRSTDAPI_(CRLineStyle *) CRJoin(CRLineStyle * lsty, CRJoinStyle * sty);
CRSTDAPI_(CRLineStyle *) CRDash(CRLineStyle * lsty, CRDashStyle * sty);
CRSTDAPI_(CRLineStyle *) CRWidth(CRLineStyle * lsty, CRNumber * sty);
CRSTDAPI_(CRLineStyle *) CRWidth(CRLineStyle * lsty, double sty);
CRSTDAPI_(CRLineStyle *) CRAntiAliasing(CRLineStyle * lsty, double aaStyle);
CRSTDAPI_(CRLineStyle *) CRDetail(CRLineStyle * lsty);
CRSTDAPI_(CRLineStyle *) CRLineColor(CRLineStyle * lsty, CRColor * clr);
CRSTDAPI_(CRJoinStyle *) CRJoinStyleBevel();
CRSTDAPI_(CRJoinStyle *) CRJoinStyleRound();
CRSTDAPI_(CRJoinStyle *) CRJoinStyleMiter();
CRSTDAPI_(CREndStyle *) CREndStyleFlat();
CRSTDAPI_(CREndStyle *) CREndStyleSquare();
CRSTDAPI_(CREndStyle *) CREndStyleRound();
CRSTDAPI_(CRDashStyle *) CRDashStyleSolid();
CRSTDAPI_(CRDashStyle *) CRDashStyleDashed();
CRSTDAPI_(CRLineStyle *) CRDashEx(CRLineStyle * ls, DWORD ds_enum);
CRSTDAPI_(CRLineStyle *) CRMiterLimit(CRLineStyle * ls, double mtrlim);
CRSTDAPI_(CRLineStyle *) CRMiterLimit(CRLineStyle * ls, CRNumber * mtrlim);
CRSTDAPI_(CRLineStyle *) CRJoinEx(CRLineStyle * ls, DWORD js_enum);
CRSTDAPI_(CRLineStyle *) CREndEx(CRLineStyle * ls, DWORD es_enum);
CRSTDAPI_(CRMicrophone *) CRDefaultMicrophone();
CRSTDAPI_(CRMicrophone *) CRTransform(CRMicrophone * mic, CRTransform3 * xf);
CRSTDAPI_(CRMatte *) CROpaqueMatte();
CRSTDAPI_(CRMatte *) CRClearMatte();
CRSTDAPI_(CRMatte *) CRUnionMatte(CRMatte * m1, CRMatte * m2);
CRSTDAPI_(CRMatte *) CRIntersectMatte(CRMatte * m1, CRMatte * m2);
CRSTDAPI_(CRMatte *) CRDifferenceMatte(CRMatte * m1, CRMatte * m2);
CRSTDAPI_(CRMatte *) CRTransform(CRMatte * m, CRTransform2 * xf);
CRSTDAPI_(CRMatte *) CRFillMatte(CRPath2 * p);
CRSTDAPI_(CRMatte *) CRTextMatte(CRString * str, CRFontStyle * fs);
CRSTDAPI_(CRMontage *) CREmptyMontage();
CRSTDAPI_(CRMontage *) CRImageMontage(CRImage * im, double depth);
CRSTDAPI_(CRMontage *) CRImageMontageAnim(CRImage * im, CRNumber * depth);
CRSTDAPI_(CRMontage *) CRUnionMontage(CRMontage * m1, CRMontage * m2);
CRSTDAPI_(CRImage *) CRRender(CRMontage * m);
CRSTDAPI_(CRPath2 *) CRConcat(CRPath2 * p1, CRPath2 * p2);
CRSTDAPI_(CRPath2 *) CRConcat(CRArrayPtr paths);
CRSTDAPI_(CRPath2 *) CRTransform(CRPath2 * p, CRTransform2 * xf);
CRSTDAPI_(CRBbox2 *) CRBoundingBox(CRPath2 * p, CRLineStyle * style);
CRSTDAPI_(CRImage *) CRFill(CRPath2 * p, CRLineStyle * border, CRImage * fill);
CRSTDAPI_(CRImage *) CRDraw(CRPath2 * p, CRLineStyle * border);
CRSTDAPI_(CRPath2 *) CRClose(CRPath2 * p);
CRSTDAPI_(CRPath2 *) CRLine(CRPoint2 * p1, CRPoint2 * p2);
CRSTDAPI_(CRPath2 *) CRRay(CRPoint2 * pt);
CRSTDAPI_(CRPath2 *) CRStringPath(CRString * str, CRFontStyle * fs);
CRSTDAPI_(CRPath2 *) CRStringPath(LPWSTR str, CRFontStyle * fs);
CRSTDAPI_(CRPath2 *) CRPolyline(CRArrayPtr points);
CRSTDAPI_(CRPath2 *) CRPolydrawPath(CRArrayPtr points, CRArrayPtr codes);
CRSTDAPI_(CRPath2 *) CRPolydrawPath(double*, unsigned int, double*, unsigned int);
CRSTDAPI_(CRPath2 *) CRArcRadians(double startAngle, double endAngle, double arcWidth, double arcHeight);
CRSTDAPI_(CRPath2 *) CRArcRadians(CRNumber * startAngle, CRNumber * endAngle, CRNumber * arcWidth, CRNumber * arcHeight);
CRSTDAPI_(CRPath2 *) CRArc(double startAngle, double endAngle, double arcWidth, double arcHeight);
CRSTDAPI_(CRPath2 *) CRPieRadians(double startAngle, double endAngle, double arcWidth, double arcHeight);
CRSTDAPI_(CRPath2 *) CRPieRadians(CRNumber * startAngle, CRNumber * endAngle, CRNumber * arcWidth, CRNumber * arcHeight);
CRSTDAPI_(CRPath2 *) CRPie(double startAngle, double endAngle, double arcWidth, double arcHeight);
CRSTDAPI_(CRPath2 *) CROval(double width, double height);
CRSTDAPI_(CRPath2 *) CROval(CRNumber * width, CRNumber * height);
CRSTDAPI_(CRPath2 *) CRRect(double width, double height);
CRSTDAPI_(CRPath2 *) CRRect(CRNumber * width, CRNumber * height);
CRSTDAPI_(CRPath2 *) CRRoundRect(double width, double height, double cornerArcWidth, double cornerArcHeight);
CRSTDAPI_(CRPath2 *) CRRoundRect(CRNumber * width, CRNumber * height, CRNumber * cornerArcWidth, CRNumber * cornerArcHeight);
CRSTDAPI_(CRPath2 *) CRCubicBSplinePath(CRArrayPtr points, CRArrayPtr knots);
CRSTDAPI_(CRPath2 *) CRTextPath(CRString * obsolete1, CRFontStyle * obsolete2);
CRSTDAPI_(CRSound *) CRSilence();
CRSTDAPI_(CRSound *) CRMix(CRArrayPtr snds);
CRSTDAPI_(CRSound *) CRPhase(CRSound * snd, CRNumber * phaseAmt);
CRSTDAPI_(CRSound *) CRPhase(CRSound * snd, double phaseAmt);
CRSTDAPI_(CRSound *) CRRate(CRSound * snd, CRNumber * pitchShift);
CRSTDAPI_(CRSound *) CRRate(CRSound * snd, double pitchShift);
CRSTDAPI_(CRSound *) CRPan(CRSound * snd, CRNumber * panAmt);
CRSTDAPI_(CRSound *) CRPan(CRSound * snd, double panAmt);
CRSTDAPI_(CRSound *) CRGain(CRSound * snd, CRNumber * gainAmt);
CRSTDAPI_(CRSound *) CRGain(CRSound * snd, double gainAmt);
CRSTDAPI_(CRSound *) CRLoop(CRSound * snd);
CRSTDAPI_(CRSound *) CRSinSynth();
CRSTDAPI_(CRString *) CRToString(CRNumber * num, CRNumber * precision);
CRSTDAPI_(CRString *) CRToString(CRNumber * num, double precision);
CRSTDAPI_(CRFontStyle *) CRDefaultFont();
CRSTDAPI_(CRFontStyle *) CRFont(CRString * str, CRNumber * size, CRColor * col);
CRSTDAPI_(CRFontStyle *) CRFont(LPWSTR str, double size, CRColor * col);
CRSTDAPI_(CRImage *) CRStringImage(CRString * str, CRFontStyle * fs);
CRSTDAPI_(CRImage *) CRStringImage(LPWSTR str, CRFontStyle * fs);
CRSTDAPI_(CRFontStyle *) CRBold(CRFontStyle * fs);
CRSTDAPI_(CRFontStyle *) CRItalic(CRFontStyle * fs);
CRSTDAPI_(CRFontStyle *) CRUnderline(CRFontStyle * fs);
CRSTDAPI_(CRFontStyle *) CRStrikethrough(CRFontStyle * fs);
CRSTDAPI_(CRFontStyle *) CRAntiAliasing(CRFontStyle * fs, double aaStyle);
CRSTDAPI_(CRFontStyle *) CRTextColor(CRFontStyle * fs, CRColor * col);
CRSTDAPI_(CRFontStyle *) CRFamily(CRFontStyle * fs, CRString * face);
CRSTDAPI_(CRFontStyle *) CRFamily(CRFontStyle * fs, LPWSTR face);
CRSTDAPI_(CRFontStyle *) CRSize(CRFontStyle * fs, CRNumber * size);
CRSTDAPI_(CRFontStyle *) CRSize(CRFontStyle * fs, double size);
CRSTDAPI_(CRFontStyle *) CRWeight(CRFontStyle * fs, double weight);
CRSTDAPI_(CRFontStyle *) CRWeight(CRFontStyle * fs, CRNumber * weight);
CRSTDAPI_(CRImage *) CRTextImage(CRString * obsoleted1, CRFontStyle * obsoleted2);
CRSTDAPI_(CRImage *) CRTextImage(LPWSTR obsoleted1, CRFontStyle * obsoleted2);
CRSTDAPI_(CRFontStyle *) CRTransformCharacters(CRFontStyle * style, CRTransform2 * transform);
CRSTDAPI_(CRVector2 *) CRXVector2();
CRSTDAPI_(CRVector2 *) CRYVector2();
CRSTDAPI_(CRVector2 *) CRZeroVector2();
CRSTDAPI_(CRPoint2 *) CROrigin2();
CRSTDAPI_(CRVector2 *) CRCreateVector2(CRNumber * x, CRNumber * y);
CRSTDAPI_(CRVector2 *) CRCreateVector2(double x, double y);
CRSTDAPI_(CRPoint2 *) CRCreatePoint2(CRNumber * x, CRNumber * y);
CRSTDAPI_(CRPoint2 *) CRCreatePoint2(double x, double y);
CRSTDAPI_(CRVector2 *) CRVector2Polar(CRNumber * theta, CRNumber * radius);
CRSTDAPI_(CRVector2 *) CRVector2Polar(double theta, double radius);
CRSTDAPI_(CRPoint2 *) CRPoint2Polar(CRNumber * theta, CRNumber * radius);
CRSTDAPI_(CRPoint2 *) CRPoint2Polar(double theta, double radius);
CRSTDAPI_(CRNumber *) CRLength(CRVector2 * v);
CRSTDAPI_(CRNumber *) CRLengthSquared(CRVector2 * v);
CRSTDAPI_(CRVector2 *) CRNormalize(CRVector2 * v);
CRSTDAPI_(CRNumber *) CRDot(CRVector2 * v, CRVector2 * u);
CRSTDAPI_(CRVector2 *) CRNeg(CRVector2 * v);
CRSTDAPI_(CRVector2 *) CRMul(CRVector2 * v, CRNumber * scalar);
CRSTDAPI_(CRVector2 *) CRMul(CRVector2 * v, double scalar);
CRSTDAPI_(CRVector2 *) CRDiv(CRVector2 * v, CRNumber * scalar);
CRSTDAPI_(CRVector2 *) CRDiv(CRVector2 * v, double scalar);
CRSTDAPI_(CRVector2 *) CRSub(CRVector2 * v1, CRVector2 * v2);
CRSTDAPI_(CRVector2 *) CRAdd(CRVector2 * v1, CRVector2 * v2);
CRSTDAPI_(CRPoint2 *) CRAdd(CRPoint2 * p, CRVector2 * v);
CRSTDAPI_(CRPoint2 *) CRSub(CRPoint2 * p, CRVector2 * v);
CRSTDAPI_(CRVector2 *) CRSub(CRPoint2 * p1, CRPoint2 * p2);
CRSTDAPI_(CRNumber *) CRDistance(CRPoint2 * p, CRPoint2 * q);
CRSTDAPI_(CRNumber *) CRDistanceSquared(CRPoint2 * p, CRPoint2 * q);
CRSTDAPI_(CRNumber *) CRGetX(CRVector2 * v);
CRSTDAPI_(CRNumber *) CRGetY(CRVector2 * v);
CRSTDAPI_(CRNumber *) CRPolarCoordAngle(CRVector2 * v);
CRSTDAPI_(CRNumber *) CRPolarCoordLength(CRVector2 * v);
CRSTDAPI_(CRNumber *) CRGetX(CRPoint2 * v);
CRSTDAPI_(CRNumber *) CRGetY(CRPoint2 * v);
CRSTDAPI_(CRNumber *) CRPolarCoordAngle(CRPoint2 * v);
CRSTDAPI_(CRNumber *) CRPolarCoordLength(CRPoint2 * v);
CRSTDAPI_(CRVector3 *) CRXVector3();
CRSTDAPI_(CRVector3 *) CRYVector3();
CRSTDAPI_(CRVector3 *) CRZVector3();
CRSTDAPI_(CRVector3 *) CRZeroVector3();
CRSTDAPI_(CRPoint3 *) CROrigin3();
CRSTDAPI_(CRVector3 *) CRCreateVector3(CRNumber * x, CRNumber * y, CRNumber * z);
CRSTDAPI_(CRVector3 *) CRCreateVector3(double x, double y, double z);
CRSTDAPI_(CRPoint3 *) CRCreatePoint3(CRNumber * x, CRNumber * y, CRNumber * z);
CRSTDAPI_(CRPoint3 *) CRCreatePoint3(double x, double y, double z);
CRSTDAPI_(CRVector3 *) CRVector3Spherical(CRNumber * xyAngle, CRNumber * yzAngle, CRNumber * radius);
CRSTDAPI_(CRVector3 *) CRVector3Spherical(double xyAngle, double yzAngle, double radius);
CRSTDAPI_(CRPoint3 *) CRPoint3Spherical(CRNumber * zxAngle, CRNumber * xyAngle, CRNumber * radius);
CRSTDAPI_(CRPoint3 *) CRPoint3Spherical(double zxAngle, double xyAngle, double radius);
CRSTDAPI_(CRNumber *) CRLength(CRVector3 * v);
CRSTDAPI_(CRNumber *) CRLengthSquared(CRVector3 * v);
CRSTDAPI_(CRVector3 *) CRNormalize(CRVector3 * v);
CRSTDAPI_(CRNumber *) CRDot(CRVector3 * v, CRVector3 * u);
CRSTDAPI_(CRVector3 *) CRCross(CRVector3 * v, CRVector3 * u);
CRSTDAPI_(CRVector3 *) CRNeg(CRVector3 * v);
CRSTDAPI_(CRVector3 *) CRMul(CRVector3 * v, CRNumber * scalar);
CRSTDAPI_(CRVector3 *) CRMul(CRVector3 * v, double scalar);
CRSTDAPI_(CRVector3 *) CRDiv(CRVector3 * v, CRNumber * scalar);
CRSTDAPI_(CRVector3 *) CRDiv(CRVector3 * v, double scalar);
CRSTDAPI_(CRVector3 *) CRSub(CRVector3 * v1, CRVector3 * v2);
CRSTDAPI_(CRVector3 *) CRAdd(CRVector3 * v1, CRVector3 * v2);
CRSTDAPI_(CRPoint3 *) CRAdd(CRPoint3 * p, CRVector3 * v);
CRSTDAPI_(CRPoint3 *) CRSub(CRPoint3 * p, CRVector3 * v);
CRSTDAPI_(CRVector3 *) CRSub(CRPoint3 * p1, CRPoint3 * p2);
CRSTDAPI_(CRNumber *) CRDistance(CRPoint3 * p, CRPoint3 * q);
CRSTDAPI_(CRNumber *) CRDistanceSquared(CRPoint3 * p, CRPoint3 * q);
CRSTDAPI_(CRNumber *) CRGetX(CRVector3 * v);
CRSTDAPI_(CRNumber *) CRGetY(CRVector3 * v);
CRSTDAPI_(CRNumber *) CRGetZ(CRVector3 * v);
CRSTDAPI_(CRNumber *) CRSphericalCoordXYAngle(CRVector3 * v);
CRSTDAPI_(CRNumber *) CRSphericalCoordYZAngle(CRVector3 * v);
CRSTDAPI_(CRNumber *) CRSphericalCoordLength(CRVector3 * v);
CRSTDAPI_(CRNumber *) CRGetX(CRPoint3 * v);
CRSTDAPI_(CRNumber *) CRGetY(CRPoint3 * v);
CRSTDAPI_(CRNumber *) CRGetZ(CRPoint3 * v);
CRSTDAPI_(CRNumber *) CRSphericalCoordXYAngle(CRPoint3 * v);
CRSTDAPI_(CRNumber *) CRSphericalCoordYZAngle(CRPoint3 * v);
CRSTDAPI_(CRNumber *) CRSphericalCoordLength(CRPoint3 * v);
CRSTDAPI_(CRTransform3 *) CRIdentityTransform3();
CRSTDAPI_(CRTransform3 *) CRTranslate3(CRNumber * tx, CRNumber * ty, CRNumber * tz);
CRSTDAPI_(CRTransform3 *) CRTranslate3(double tx, double ty, double tz);
CRSTDAPI_(CRTransform3 *) CRTranslate3(CRNumber tx, CRNumber ty, CRNumber tz);
CRSTDAPI_(CRTransform3 *) CRTranslate3(CRVector3 * delta);
CRSTDAPI_(CRTransform3 *) CRTranslate3(CRPoint3 * new_origin);
CRSTDAPI_(CRTransform3 *) CRScale3(CRNumber * x, CRNumber * y, CRNumber * z);
CRSTDAPI_(CRTransform3 *) CRScale3(double x, double y, double z);
CRSTDAPI_(CRTransform3 *) CRScale3(CRNumber x, CRNumber y, CRNumber z);
CRSTDAPI_(CRTransform3 *) CRScale3(CRVector3 * scale_vec);
CRSTDAPI_(CRTransform3 *) CRScale3Uniform(CRNumber * uniform_scale);
CRSTDAPI_(CRTransform3 *) CRScale3Uniform(double uniform_scale);
CRSTDAPI_(CRTransform3 *) CRScale3Uniform(CRNumber uniform_scale);
CRSTDAPI_(CRTransform3 *) CRRotate3(CRVector3 * axis, CRNumber * angle);
CRSTDAPI_(CRTransform3 *) CRRotate3(CRVector3 * axis, double angle);
CRSTDAPI_(CRTransform3 *) CRRotate3(CRVector3 * axis, CRNumber angle);
CRSTDAPI_(CRVector3 *) CRTransform(CRVector3 * vec, CRTransform3 * xf);
CRSTDAPI_(CRPoint3 *) CRTransform(CRPoint3 * pt, CRTransform3 * xf);
CRSTDAPI_(CRTransform3 *) CRXShear3(CRNumber * a, CRNumber * b);
CRSTDAPI_(CRTransform3 *) CRXShear3(double a, double b);
CRSTDAPI_(CRTransform3 *) CRXShear3(CRNumber a, CRNumber b);
CRSTDAPI_(CRTransform3 *) CRYShear3(CRNumber * c, CRNumber * d);
CRSTDAPI_(CRTransform3 *) CRYShear3(double c, double d);
CRSTDAPI_(CRTransform3 *) CRYShear3(CRNumber c, CRNumber d);
CRSTDAPI_(CRTransform3 *) CRZShear3(CRNumber * e, CRNumber * f);
CRSTDAPI_(CRTransform3 *) CRZShear3(double e, double f);
CRSTDAPI_(CRTransform3 *) CRZShear3(CRNumber e, CRNumber f);
CRSTDAPI_(CRTransform3 *) CRTransform4x4(CRArrayPtr m);
CRSTDAPI_(CRTransform3 *) CRCompose3(CRTransform3 * a, CRTransform3 * b);
CRSTDAPI_(CRTransform3 *) CRCompose3(CRArrayPtr xfs);
CRSTDAPI_(CRTransform3 *) CRInverse(CRTransform3 * xform);
CRSTDAPI_(CRBoolean *) CRIsSingular(CRTransform3 * xform);
CRSTDAPI_(CRTransform3 *) CRLookAtFrom(CRPoint3 * to, CRPoint3 * from, CRVector3 * up);
CRSTDAPI_(CRTransform2 *) CRIdentityTransform2();
CRSTDAPI_(CRTransform2 *) CRTranslate2(CRNumber * Tx, CRNumber * Ty);
CRSTDAPI_(CRTransform2 *) CRTranslate2(double Tx, double Ty);
CRSTDAPI_(CRTransform2 *) CRTranslate2(CRNumber Tx, CRNumber Ty);
CRSTDAPI_(CRTransform2 *) CRTranslate2(CRVector2 * delta);
CRSTDAPI_(CRTransform2 *) CRTranslate2(CRPoint2 * pos);
CRSTDAPI_(CRTransform2 *) CRScale2(CRNumber * x, CRNumber * y);
CRSTDAPI_(CRTransform2 *) CRScale2(double x, double y);
CRSTDAPI_(CRTransform2 *) CRScale2(CRNumber x, CRNumber y);
CRSTDAPI_(CRTransform2 *) CRScale2(CRVector2 * obsoleteMethod);
CRSTDAPI_(CRTransform2 *) CRScale2(CRVector2 * scale_vec);
CRSTDAPI_(CRTransform2 *) CRScale2Uniform(CRNumber * uniform_scale);
CRSTDAPI_(CRTransform2 *) CRScale2Uniform(double uniform_scale);
CRSTDAPI_(CRTransform2 *) CRScale2Uniform(CRNumber uniform_scale);
CRSTDAPI_(CRTransform2 *) CRRotate2(CRNumber * angle);
CRSTDAPI_(CRTransform2 *) CRRotate2(double angle);
CRSTDAPI_(CRTransform2 *) CRRotate2(CRNumber angle);
CRSTDAPI_(CRTransform2 *) CRRotate2Degrees(double angle);
CRSTDAPI_(CRTransform2 *) CRXShear2(CRNumber * arg0);
CRSTDAPI_(CRTransform2 *) CRXShear2(double arg0);
CRSTDAPI_(CRTransform2 *) CRXShear2(CRNumber arg0);
CRSTDAPI_(CRTransform2 *) CRYShear2(CRNumber * arg0);
CRSTDAPI_(CRTransform2 *) CRYShear2(double arg0);
CRSTDAPI_(CRTransform2 *) CRYShear2(CRNumber arg0);
CRSTDAPI_(CRTransform2 *) CRTransform3x2(CRArrayPtr m);
CRSTDAPI_(CRTransform2 *) CRTransform3x2(double *m, unsigned int n);
CRSTDAPI_(CRTransform2 *) CRCompose2(CRTransform2 * a, CRTransform2 * b);
CRSTDAPI_(CRTransform2 *) CRCompose2(CRArrayPtr xfs);
CRSTDAPI_(CRPoint2 *) CRTransform(CRPoint2 * pt, CRTransform2 * xf);
CRSTDAPI_(CRVector2 *) CRTransform(CRVector2 * vec, CRTransform2 * xf);
CRSTDAPI_(CRTransform2 *) CRInverse(CRTransform2 * theXf);
CRSTDAPI_(CRBoolean *) CRIsSingular(CRTransform2 * theXf);
CRSTDAPI_(CRTransform2 *) CRParallelTransform2(CRTransform3 * xf);
CRSTDAPI_(CRNumber *) CRViewFrameRate();
CRSTDAPI_(CRNumber *) CRViewTimeDelta();
CRSTDAPI_(CRMontage *) CRUnionMontageArray(CRArrayPtr mtgs);
CRSTDAPI_(CRColor *) CREmptyColor();
// Basic functions
CRSTDAPI_(bool)        CRConnect(HINSTANCE hinst);
CRSTDAPI_(bool)        CRDisconnect(HINSTANCE hinst);
CRSTDAPI_(bool)        CRIsConnected(HINSTANCE hinst);

CRSTDAPI_(bool)        CRAddSite(CRSitePtr s);
CRSTDAPI_(bool)        CRRemoveSite(CRSitePtr s);

CRSTDAPI_(HRESULT)     CRGetLastError();
CRSTDAPI_(LPCWSTR)     CRGetLastErrorString();
CRSTDAPI_(void)        CRClearLastError();
CRSTDAPI_(void)        CRSetLastError(HRESULT reason, LPCWSTR msg);

CRSTDAPI_(bool)        CRAcquireGCLock();
CRSTDAPI_(bool)        CRReleaseGCLock();
CRSTDAPI_(bool)        CRDoGC();
CRSTDAPI_(bool)        CRAddRefGC(void *);
CRSTDAPI_(bool)        CRReleaseGC(void *);

CRSTDAPI_(bool)        CRBvrToCOM(CRBvrPtr bvr,
                                  REFIID riid,
                                  void ** ppv);
CRSTDAPI_(CRBvrPtr)    COMToCRBvr(IUnknown * pbvr);

// Behavior functions

#define CRContinueTimeline   0x00000001
#define CRSwitchFinal        0x00000002
#define CRSwitchNextTick     0x00000004
#define CRSwitchAtTime       0x00000008
#define CRSwitchCurrentTick  0x00000010

CRSTDAPI_(CR_BVR_TYPEID) CRGetTypeId(CRBvrPtr);
CRSTDAPI_(CR_BVR_TYPEID) CRGetArrayTypeId(CRBvrPtr);
CRSTDAPI_(bool)          CRInit(CRBvrPtr, CRBvrPtr toBvr);
CRSTDAPI_(CRBvrPtr)      CRImportance(CRBvrPtr, double relativeImportance);
CRSTDAPI_(CRBvrPtr)      CRRunOnce(CRBvrPtr);
CRSTDAPI_(CRBvrPtr)      CRSubstituteTime(CRBvrPtr, CRNumberPtr xform);
CRSTDAPI_(CRBvrPtr)      CRHook(CRBvrPtr, CRBvrHookPtr notifier);
CRSTDAPI_(CRBvrPtr)      CRDuration(CRBvrPtr, double duration);
CRSTDAPI_(CRBvrPtr)      CRDuration(CRBvrPtr, CRNumberPtr duration);
CRSTDAPI_(CRBvrPtr)      CRRepeat(CRBvrPtr, long count);
CRSTDAPI_(CRBvrPtr)      CRRepeatForever(CRBvrPtr);
CRSTDAPI_(CRBvrPtr)      CRBvrApplyPreference(CRBvrPtr bv, BSTR pref, VARIANT val);
CRSTDAPI_(bool)          CRIsReady(CRBvrPtr, bool bBlock);
CRSTDAPI_(CRBvrPtr)      CREndEvent(CRBvrPtr);

CRSTDAPI_(bool)          CRIsImport(CRBvrPtr);
CRSTDAPI                 CRImportStatus(CRBvrPtr);
CRSTDAPI_(bool)          CRImportCancel(CRBvrPtr);
CRSTDAPI_(bool)          CRSetImportPriority(CRBvrPtr, float prio);
CRSTDAPI_(float)         CRGetImportPriority(CRBvrPtr);

CRSTDAPI_(bool)          CRIsModifiableBvr(CRBvrPtr);
CRSTDAPI_(bool)          CRSwitchTo(CRBvrPtr,
                                    CRBvrPtr switchTo,
                                    bool bOverrideFlags,
                                    DWORD dwFlags,
                                    double gTime);
CRSTDAPI_(bool)          CRSwitchToNumber(CRNumberPtr, double numToSwitchTo);
CRSTDAPI_(bool)          CRSwitchToString(CRStringPtr, LPWSTR strToSwitchTo);
CRSTDAPI_(bool)          CRSwitchToBool(CRBooleanPtr, bool b);
CRSTDAPI_(CRBvrPtr)      CRGetModifiableBvr(CRBvrPtr);

// View functions
#define CRAsyncFlag 0x00000001
#define CRINVRECT_MERGE_BOXES (1L << 0)

CRSTDAPI_(CRViewPtr)             CRCreateView();
CRSTDAPI_(void)                  CRDestroyView(CRViewPtr v);

CRSTDAPI_(double)                CRGetSimulationTime(CRViewPtr);
CRSTDAPI_(bool)                  CRTick(CRViewPtr, double simTime, bool * needToRender);
CRSTDAPI_(bool)                  CRRender(CRViewPtr);
CRSTDAPI_(bool)                  CRAddBvrToRun(CRViewPtr, 
                                               CRBvrPtr bvr, 
                                               bool continueTimeline,
                                               long * pId);
CRSTDAPI_(bool)                  CRRemoveRunningBvr(CRViewPtr, long id);
CRSTDAPI_(bool)                  CRStartModel(CRViewPtr,
                                              CRImagePtr pImage,
                                              CRSoundPtr pSound,
                                              double startTime,
                                              DWORD dwFlags,
                                              bool * pbPending);
CRSTDAPI_(bool)                  CRStopModel(CRViewPtr);
CRSTDAPI_(bool)                  CRPauseModel(CRViewPtr);
CRSTDAPI_(bool)                  CRResumeModel(CRViewPtr);
CRSTDAPI_(HWND)                  CRGetWindow(CRViewPtr);
CRSTDAPI_(bool)                  CRSetWindow(CRViewPtr, HWND hwnd);
CRSTDAPI_(IUnknown *)            CRGetDirectDrawSurface(CRViewPtr);
CRSTDAPI_(bool)                  CRSetDirectDrawSurface(CRViewPtr, IUnknown *ddsurf);
CRSTDAPI_(HDC)                   CRGetDC(CRViewPtr);
CRSTDAPI_(bool)                  CRSetDC(CRViewPtr, HDC dc);
CRSTDAPI_(bool)                  CRGetCompositeDirectlyToTarget(CRViewPtr);
CRSTDAPI_(bool)                  CRSetCompositeDirectlyToTarget(CRViewPtr, bool b);
CRSTDAPI_(bool)                  CRSetViewport(CRViewPtr,
                                               long xPos,
                                               long yPos,
                                               long w,
                                               long h);
CRSTDAPI_(bool)                  CRSetClipRect(CRViewPtr,
                                               long xPos,
                                               long yPos,
                                               long w,
                                               long h);
CRSTDAPI_(bool)                  CRRepaint(CRViewPtr,
                                           long xPos,
                                           long yPos,
                                           long w,
                                           long h);
CRSTDAPI_(CRViewSitePtr)         CRGetSite(CRViewPtr);
CRSTDAPI_(bool)                  CRSetSite(CRViewPtr, CRViewSitePtr s);
CRSTDAPI_(IServiceProvider *)    CRGetServiceProvider(CRViewPtr);
CRSTDAPI_(bool)                  CRSetServiceProvider(CRViewPtr,
                                                      IServiceProvider * s);
CRSTDAPI_(bool)                  CROnMouseMove(CRViewPtr,
                                               double when,
                                               long xPos, long yPos,
                                               byte modifiers);
CRSTDAPI_(bool)                  CROnMouseLeave(CRViewPtr,
                                                double when);
CRSTDAPI_(bool)                  CROnMouseButton(CRViewPtr,
                                                 double when,
                                                 long xPos, long yPos,
                                                 byte button,
                                                 bool bPressed,
                                                 byte modifiers);
CRSTDAPI_(bool)                  CROnKey(CRViewPtr,
                                         double when,
                                         long key,
                                         bool bPressed,
                                         byte modifiers);
CRSTDAPI_(bool)                  CROnFocus(CRViewPtr,
                                           bool bHasFocus);
CRSTDAPI_(DWORD)                 CRQueryHitPoint(CRViewPtr,
                                                 DWORD dwAspect,
                                                 LPCRECT prcBounds,
                                                 POINT   ptLoc,
                                                 long lCloseHint);
CRSTDAPI_(long)                  CRQueryHitPointEx(CRViewPtr,
                                                   long s,
                                                   DWORD_PTR *cookies,
                                                   double *points,
                                                   LPCRECT prcBounds,
                                                   POINT   ptLoc);
CRSTDAPI_(long)                  CRGetInvalidatedRects(CRViewPtr,
                                                       DWORD flags,
                                                       long  size,
                                                       RECT *pRects);
CRSTDAPI_(bool)                  CRGetDDD3DRM(CRViewPtr,
                                              IUnknown **directDraw,
                                              IUnknown **d3drm);
CRSTDAPI_(bool)                  CRGetRMDevice(CRViewPtr,
                                               IUnknown **d3drmDevice,
                                               DWORD     *sequenceNumber);
CRSTDAPI_(bool)                  CRPutPreference(CRViewPtr,
                                                 LPWSTR preferenceName,
                                                 VARIANT value);
CRSTDAPI_(bool)                  CRGetPreference(CRViewPtr,
                                                 LPWSTR preferenceName,
                                                 VARIANT * value);
CRSTDAPI_(bool)                  CRPropagate(CRViewPtr);

// Pickable result functions

CRSTDAPI_(CRImagePtr)    CRGetImage(CRPickableResultPtr);
CRSTDAPI_(CRGeometryPtr) CRGetGeometry(CRPickableResultPtr);
CRSTDAPI_(CREventPtr)    CRGetEvent(CRPickableResultPtr);

// Importation result functions

CRSTDAPI_(CRImagePtr)    CRGetImage(CRImportationResultPtr);
CRSTDAPI_(CRSoundPtr)    CRGetSound(CRImportationResultPtr);
CRSTDAPI_(CRGeometryPtr) CRGetGeometry(CRImportationResultPtr);
CRSTDAPI_(CRNumberPtr)   CRGetDuration(CRImportationResultPtr);
CRSTDAPI_(CREventPtr)    CRGetCompletionEvent(CRImportationResultPtr);
CRSTDAPI_(CRNumberPtr)   CRGetProgress(CRImportationResultPtr);
CRSTDAPI_(CRNumberPtr)   CRGetSize(CRImportationResultPtr);

// Transform result functions

CRSTDAPI_(CRBvrPtr)    CRGetOutputBvr(CRDXTransformResultPtr);
CRSTDAPI_(IUnknown *)  CRGetTransform(CRDXTransformResultPtr);
CRSTDAPI_(bool)        CRSetBvrAsProperty(CRDXTransformResultPtr,
                                          LPCWSTR property,
                                          CRBvrPtr bvr);

CRSTDAPI_(CRDXTransformResultPtr) CRApplyDXTransform(IUnknown *theXf,
                                                     long numInputs,
                                                     CRBvrPtr *inputs,
                                                     CRBvrPtr evaluator);

// Import
enum CR_MEDIA_SOURCE {
    CR_SRC_URL = 0,
    CR_SRC_IStream = 1
};

#define CR_IMPORT_ASYNC        0x00000001
#define CR_IMPORT_STREAMED     0x00000002

CRSTDAPI_(CRImportationResultPtr)   CRImportMedia(LPWSTR baseUrl,
                                                  void * mediaSource,
                                                  CR_MEDIA_SOURCE srcType,
                                                  void * params[],
                                                  DWORD flags,
                                                  CRImportSitePtr s);
CRSTDAPI_(DWORD)                     CRImportImage(LPCWSTR baseUrl,
                                                   LPCWSTR relUrl,
                                                   CRImportSitePtr s,
                                                   IBindHost * bh,
                                                   bool useColorKey,
                                                   BYTE ckRed,
                                                   BYTE ckGreen,
                                                   BYTE ckBlue,
                                                   CRImage   *pImageStandIn,
                                                   CRImage  **ppImage,
                                                   CREvent  **ppEvent,
                                                   CRNumber **ppProgress,
                                                   CRNumber **size);
CRSTDAPI_(DWORD)                     CRImportMovie(LPCWSTR baseUrl,
                                                   LPCWSTR relUrl,
                                                   CRImportSitePtr s,
                                                   IBindHost * bh,
                                                   bool        stream,
                                                   CRImage   *pImageStandIn,
                                                   CRSound   *pSoundStandIn,
                                                   CRImage  **ppImage,
                                                   CRSound  **ppSound,
                                                   CRNumber **length,
                                                   CREvent  **ppEvent,
                                                   CRNumber **ppProgress,
                                                   CRNumber **size);
CRSTDAPI_(DWORD)                     CRImportSound(LPCWSTR baseUrl,
                                                   LPCWSTR relUrl,
                                                   CRImportSitePtr s,
                                                   IBindHost * bh,
                                                   bool        stream,
                                                   CRSound   *pSoundStandIn,
                                                   CRSound  **ppSound,
                                                   CRNumber **length,
                                                   CREvent  **ppEvent,
                                                   CRNumber **ppProgress,
                                                   CRNumber **size);

CRSTDAPI_(DWORD)                     CRImportGeometry(LPCWSTR baseUrl,
                                                      LPCWSTR relUrl,
                                                      CRImportSitePtr s,
                                                      IBindHost * bh,
                                                      CRGeometry   *pGeoStandIn,
                                                      CRGeometry  **ppGeometry,
                                                      CREvent  **ppEvent,
                                                      CRNumber **ppProgress,
                                                      CRNumber **size);

CRSTDAPI_(DWORD)                     CRImportGeometryWrapped(LPCWSTR baseUrl,
                                                             LPCWSTR relUrl,
                                                             CRImportSitePtr s,
                                                             IBindHost * bh,
                                                             CRGeometry   *pGeoStandIn,
                                                             CRGeometry  **ppGeometry,
                                                             CREvent  **ppEvent,
                                                             CRNumber **ppProgress,
                                                             CRNumber **size,
                                                             LONG wrapType,
                                                             double originX,
                                                             double originY,
                                                             double originZ,
                                                             double zAxisX,
                                                             double zAxisY,
                                                             double zAxisZ,
                                                             double yAxisX,
                                                             double yAxisY,
                                                             double yAxisZ,
                                                             double texOriginX,
                                                             double texOriginY,
                                                             double texScaleX,
                                                             double texScaleY,
                                                             DWORD flags);

CRSTDAPI_(CRImagePtr)    CRImportDirectDrawSurface (IUnknown *dds,
                                                    CREvent *updateEvent);

CRSTDAPI_(CRGeometryPtr) CRImportDirect3DRMVisual (IUnknown *visual);

CRSTDAPI_(CRGeometryPtr) CRImportDirect3DRMVisualWrapped(IUnknown *visual,
                                                         LONG wrapType,
                                                         double originX,
                                                         double originY,
                                                         double originZ,
                                                         double zAxisX,
                                                         double zAxisY,
                                                         double zAxisZ,
                                                         double yAxisX,
                                                         double yAxisY,
                                                         double yAxisZ,
                                                         double texOriginX,
                                                         double texOriginY,
                                                         double texScaleX,
                                                         double texScaleY,
                                                         DWORD flags);

// Misc
#define CR_ARRAY_CHANGEABLE_FLAG  0x00000001

CRSTDAPI_(LPCWSTR)         CRVersionString();
CRSTDAPI_(bool)            CRTriggerEvent(CREventPtr event, CRBvrPtr t);
CRSTDAPI_(CRBvrPtr)        CRCond(CRBooleanPtr c,
                                  CRBvrPtr i,
                                  CRBvrPtr e);
CRSTDAPI_(CRArrayPtr)      CRCreateArray(long s,
                                         CRBvrPtr pBvrs[],
                                         DWORD dwFlags);
CRSTDAPI_(CRArrayPtr)      CRCreateArray(long s,
                                         double dArr[],
                                         CR_BVR_TYPEID tid);
CRSTDAPI_(CRTuplePtr)      CRCreateTuple(long s, CRBvrPtr pBvrs[]);
CRSTDAPI_(CRArrayPtr)      CRUninitializedArray(CRArrayPtr typeTmp);
CRSTDAPI_(CRTuplePtr)      CRUninitializedTuple(CRTuplePtr typeTmp);
CRSTDAPI_(CRBvrPtr)        CRUninitializedBvr(CR_BVR_TYPEID t);
CRSTDAPI_(CRBvrPtr)        CRSampleAtLocalTime(CRBvrPtr b, double localTime);
CRSTDAPI_(bool)            CRIsConstantBvr(CRBvrPtr b);

// Modifiables
CRSTDAPI_(CRBvrPtr)        CRModifiableBvr(CRBvrPtr orig, DWORD dwFlags);
CRSTDAPI_(CRNumberPtr)     CRModifiableNumber(double initVal);
CRSTDAPI_(CRStringPtr)     CRModifiableString(LPWSTR initVal);
CRSTDAPI_(CRColorPtr)      CRModifiableColor255(BYTE initRed,
                                                BYTE initGreen,
                                                BYTE initBlue);
CRSTDAPI_(CRPoint2Ptr)     CRModifiablePoint2(double x,
                                              double y,
                                              bool bPixelMode);
CRSTDAPI_(CRVector2Ptr)    CRModifiableVector2(double x,
                                               double y,
                                               bool bPixelMode);
CRSTDAPI_(CRPoint3Ptr)     CRModifiablePoint3(double x,
                                              double y,
                                              double z,
                                              bool bPixelMode);
CRSTDAPI_(CRVector3Ptr)    CRModifiableVector3(double x,
                                               double y,
                                               double z,
                                               bool bPixelMode);
CRSTDAPI_(CRTransform2Ptr) CRModifiableTranslate2(double x,
                                                  double y,
                                                  bool bPixelMode);
CRSTDAPI_(CRTransform2Ptr) CRModifiableScale2(double x,
                                              double y);
CRSTDAPI_(CRTransform2Ptr) CRModifiableRotate2(double angle);
CRSTDAPI_(CRTransform3Ptr) CRModifiableTranslate3(double x,
                                                  double y,
                                                  double z,
                                                  bool bPixelMode);
CRSTDAPI_(CRTransform3Ptr) CRModifiableScale3(double x,
                                              double y,
                                              double z);
CRSTDAPI_(CRTransform3Ptr) CRModifiableRotate3(double axisX,
                                               double axisY,
                                               double axisZ,
                                               double angle);
// Splines
CRSTDAPI_(CRBvrPtr)      CRBSpline(int degree,
                                   long numKnots,
                                   CRNumberPtr knots[],
                                   long numPts,
                                   CRBvrPtr ctrlPts[],
                                   long numWts,
                                   CRNumberPtr weights[],
                                   CRNumberPtr evaluator,
                                   CR_BVR_TYPEID tid);

CRSTDAPI_(CRBvrPtr)      CRExtendedAttrib(CRBvr *arg0,
                                          LPWSTR arg1,
                                          VARIANT arg2);

#define CRQUAL_AA_TEXT_ON     (1L << 0)
#define CRQUAL_AA_TEXT_OFF    (1L << 1)
#define CRQUAL_AA_LINES_ON    (1L << 2)
#define CRQUAL_AA_LINES_OFF   (1L << 3)
#define CRQUAL_AA_SOLIDS_ON   (1L << 4)
#define CRQUAL_AA_SOLIDS_OFF  (1L << 5)
#define CRQUAL_AA_CLIP_ON     (1L << 6)
#define CRQUAL_AA_CLIP_OFF    (1L << 7)
#define CRQUAL_MSHTML_COLORS_ON  (1L << 8)
#define CRQUAL_MSHTML_COLORS_OFF  (1L << 9)
#define CRQUAL_QUALITY_TRANSFORMS_ON  (1L << 10)
#define CRQUAL_QUALITY_TRANSFORMS_OFF (1L << 11)

// SAME VALUES AS DANIM.IDL <if you update this: update danim.idl>

typedef enum  {
    ds_Solid      = 0,
    ds_Dashed     = 1,
    ds_Dot        = 2,
    ds_Dashdot    = 3,
    ds_Dashdotdot = 4,
    ds_Null       = 5
} DashStyleEnum;

typedef enum  {
    es_Round  = 0,
    es_Square = 1,
    es_Flat   = 2
} EndStyleEnum;

typedef enum  {
    js_Round = 0,
    js_Bevel = 1,
    js_Miter = 2
} JoinStyleEnum;


#endif /* _DARTAPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\include\dartapipriv.h ===
#ifndef _DARTAPIPRIV_H
#define _DARTAPIPRIV_H


class CRBvr : public BvrImpl{};
class CRBoolean : public CRBvr{};
class CRCamera : public CRBvr{};
class CRColor : public CRBvr{};
class CRGeometry : public CRBvr{};
class CRImage : public CRBvr{};
class CRMatte : public CRBvr{};
class CRMicrophone : public CRBvr{};
class CRMontage : public CRBvr{};
class CRNumber : public CRBvr{};
class CRPath2 : public CRBvr{};
class CRPoint2 : public CRBvr{};
class CRPoint3 : public CRBvr{};
class CRSound : public CRBvr{};
class CRString : public CRBvr{};
class CRTransform2 : public CRBvr{};
class CRTransform3 : public CRBvr{};
class CRVector2 : public CRBvr{};
class CRVector3 : public CRBvr{};
class CRFontStyle : public CRBvr{};
class CRLineStyle : public CRBvr{};
class CREndStyle : public CRBvr{};
class CRJoinStyle : public CRBvr{};
class CRDashStyle : public CRBvr{};
class CRBbox2 : public CRBvr{};
class CRBbox3 : public CRBvr{};
class CRPair : public CRBvr{};
class CREvent : public CRBvr{};
class CRArray : public CRBvr{};
class CRTuple : public CRBvr{};
class CRUserData : public CRBvr{};


#endif /* _DARTAPIPRIV_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\include\verhead.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 *      version.h is created on the fly from verhead.bat and vertail.h,     *
 *      with the current version numbers inserted in between                *
 *                                                                          *
 ****************************************************************************/

#ifndef VER_H
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include <winver.h>
#endif

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\include\dispids.h ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Global dispid file

--*/

#ifndef _DISPIDS_H_
#define _DISPIDS_H_

#define DISPID_AXAVIEWCONTROL_DATAPATH     100
#define DISPID_AXAVIEWCONTROL_EXPRESSION   102
#define DISPID_AXAVIEWCONTROL_BORDER       103
#define DISPID_AXAVIEWCONTROL_FROZEN       105
#define DISPID_AXAVIEWCONTROL_DATA         106
#define DISPID_AXAVIEWCONTROL_VIEWERMENUS  107
#define DISPID_AXAVIEWCONTROL_SHOWSOURCE   108

#define DISPID_ENGINE_SETENGINESITE            200
#define DISPID_ENGINE_SETCONTAINER             201
#define DISPID_ENGINE_SHOWCONTEXTMENU          202
#define DISPID_ENGINE_MAKEBEHAVIORINTERFACE    203
#define DISPID_ENGINE_CREATEMODULE             204
#define DISPID_ENGINE_CREATEVIEW               205

#define DISPID_MODULE_LOADURL          300
#define DISPID_MODULE_LOADSTRING       301
#define DISPID_MODULE_GETTYPESTRING    302
#define DISPID_MODULE_GETCODESTRING    303
#define DISPID_MODULE_ENUMPRIMITIVES   304
#define DISPID_MODULE_ENUMENVIRONMENT  305
#define DISPID_MODULE_DOCUMENTBASE     306
#define DISPID_MODULE_SETMODULESITE    307
#define DISPID_MODULE_STATUSHWND       308
#define DISPID_MODULE_MAKEBEHAVIOR     309

#define DISPID_VIEW_TICK                 401
#define DISPID_VIEW_TICK_USE_SYS_TIME    402
#define DISPID_VIEW_START_MODEL          403
#define DISPID_VIEW_WINDOW               404
#define DISPID_VIEW_NAME                 405
#define DISPID_VIEW_PAINT                406
#define DISPID_VIEW_SETSIZE              407
#define DISPID_VIEW_PALETTECHANGED       408
#define DISPID_VIEW_CONTEXTMENU          409
#define DISPID_VIEW_SETVIEWSITE          410
#define DISPID_VIEW_SETSYSSTARTTIME      411
#define DISPID_VIEW_GETSYSSTARTTIME      412
#define DISPID_VIEW_APPTRIGGER           413
#define DISPID_VIEW_ONMOUSEMOVE          414
#define DISPID_VIEW_ONMOUSEBUTTON        415
#define DISPID_VIEW_ONKEY                416
#define DISPID_VIEW_ONFOCUS              417
#define DISPID_VIEW_START_SCRIPT_MODEL   418
#define DISPID_VIEW_QUERYACTUALGC        419

#define DISPID_BEHAVIOR_GETTYPESTRING   600
#define DISPID_BEHAVIOR_GETCLASSNAME    601
#define DISPID_BEHAVIOR_RUN             602
#define DISPID_BEHAVIOR_SNAPSHOT        603

#define DISPID_UNTILNOTIFIER_NOTIFY     700

#endif  // _DISPIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\javacab\cabcopy.cpp ===
#include <windows.h>

  DWORD dwReturn;
  TCHAR destDir[MAX_PATH];
  TCHAR zCmd[MAX_PATH];
  TCHAR currentDir[MAX_PATH];

  // this is the file to copy
  TCHAR cabFile[] = "dajava.cab";
  #define CAB_FILENAME_LENGTH	10

  int WINAPI WinMain(
		HINSTANCE	hInstance,
		HINSTANCE	hPrevInstance,
		LPSTR		lpCmdLine,
		int			nCmdShow ) 
  { // WinMain //

    DWORD	currDirLength;
	UINT	character,
			destDirLength;
	int		returnValue = -1;

    destDirLength = GetWindowsDirectory(destDir, MAX_PATH);
	
	if( destDirLength == 0 || destDirLength > MAX_PATH) {
		return returnValue;
	}

	currDirLength = GetCurrentDirectory(MAX_PATH, currentDir);

	if( currDirLength == 0 || currDirLength > MAX_PATH) {
		return returnValue;
	}

	//Let's append the filename to the current directory
	// check space for the directory separator and null termination
	if( currDirLength > MAX_PATH + CAB_FILENAME_LENGTH + 2) {
		return returnValue;
	}

	//Add a directory separator
	currentDir[currDirLength] = '\\';
	currDirLength++;

	for( character = 0; character < CAB_FILENAME_LENGTH; character++) {
		currentDir[currDirLength + character] = cabFile[character];
	}

	// NULL terminate the string
	currentDir[currDirLength + CAB_FILENAME_LENGTH] = 0;

	//Now, let's append the filename to the destination directory
	// check space for the directory separator and null termination
	if( destDirLength > MAX_PATH + CAB_FILENAME_LENGTH + 2) {
		return returnValue;
	}

	//Add a directory separator
	destDir[destDirLength] = '\\';
	destDirLength++;

	// Note that we start at one because we already add the backslash
	for( character = 0; character < CAB_FILENAME_LENGTH; character++) {
		destDir[destDirLength + character] = cabFile[character];
	}

	// NULL terminate the string
	destDir[destDirLength + CAB_FILENAME_LENGTH] = 0;

	if( MoveFile(currentDir, destDir) == 0 ) {
		DWORD error = GetLastError();
	} else {
		returnValue = 0;
	}

	return returnValue;

  } // WinMain //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\include\version.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 *      version.h is created on the fly from verhead.bat and vertail.h,     *
 *      with the current version numbers inserted in between                *
 *                                                                          *
 ****************************************************************************/

#ifndef VER_H
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include <winver.h>
#endif

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/

/* 8/11/00 tuanle - change from 6,01,09,0727 to 6,03,01,0146    */
/* for DX8 Beta2                                                */

#define VERSION                     "6.03.01.0146" 
#define VER_FILEVERSION_STR         "6.03.01.0146\0" 
#define VER_FILEVERSION             6,03,01,0146 
#define VER_PRODUCTVERSION_STR      "6.03.01.0146\0" 
#define VER_PRODUCTVERSION          6,03,01,0146 

#define OFFICIAL                    1
#define FINAL                       1

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#if _DEBUG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is privatebuild */
#if DEVELOPER_DEBUG /*OFFICIAL */
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS32
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\include\vertail.h ===
#define OFFICIAL                    1
#define FINAL                       1

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#if _DEBUG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS32
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\jaxa\makecomm.inc ===
!include ../../root.inc
MODULE=jaxa
PCHPATH=$(BLDROOT)\jaxa
PCHFILE=headers

INCLUDEDIRS=$(SRCDIR) $(TOOLSINCLUDE) $(SRCROOT)\include $(SDKDIR) $(BLDDIR)

!include $(ROOT)\src\make\make1.inc

JAVAPRIM=javaprim.bat
PRIMFILE=$(SDKDIR)\cprims.h
MAKE_CLASS_INC=$(BLDDIR)\mkclass.inc
STATICSNAME=Statics
PACKAGEROOT=com.ms.dxmedia
PACKAGEPATHROOT=$(PACKAGEROOT:.=\)
PACKAGEPATH=$(BLDDIR)\$(PACKAGEPATHROOT)
BINPACKAGEPATH=$(BINDIR)\$(PACKAGEPATHROOT)
FILELIST=$(BLDDIR)\files.lst
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\jaxa\makefile.inc ===
BINDIR=$(BLDROOT)\bin
BLDDIR=$(TARGETPATH)\$(TARGET_DIRECTORY)
JAVA15DIR=$(TOOLSDIR)\java15
JCOMGEN  = $(JAVA15DIR)\bin\JCOMGEN
JAVADIR=$(TOOLSDIR)\java20
PACKAGEROOT=com.ms.dxmedia
PACKAGEROOT=com.ms.dxmedia
PACKAGEPATHROOT=com\ms\dxmedia
PACKAGEPATH=$(BLDDIR)\$(PACKAGEPATHROOT)
BINPACKAGEPATH=$(BINDIR)\$(PACKAGEPATHROOT)
_USER_JCOMGENFLAGS=/p $(PACKAGEROOT).rawcom /p:b- /d $(BLDDIR) /xi /e /X:m-
JCOMGENFLAGS= /nologo $(_USER_JCOMGENFLAGS)
JCCLASSPATH= $(JAVADIR)\classes\afc.zip;$(JAVADIR)\classes\classes.zip;$(SRCDIR);$(BLDDIR);$(SDKDIR);$(BINDIR)
ATTRJC   = $(JAVA15DIR)\bin\ATTRJVC
ATTRJCFLAGS= /cp:p $(JCCLASSPATH) $(_USER_ATTRJCFLAGS)

!ifndef NOLINK

JavaStuff: $(BINPACKAGEPATH)\rawcom\IDAView.class jaxasrc

$(BINPACKAGEPATH)\rawcom\IDAView.class: $(BLDDIR)\danim.tlb
    $(JCOMGEN) $(JCOMGENFLAGS) $(BLDDIR)\danim.tlb
    DEL 2>nul: $(PACKAGEPATH)\rawcom\*Default.java
    $(ATTRJC) $(ATTRJCFLAGS) /d $(BLDDIR) $(PACKAGEPATH)\rawcom\*.java
    @-md $(BINPACKAGEPATH)\rawcom
    xcopy >NUL $(PACKAGEPATH)\rawcom\*.class $(BINPACKAGEPATH)\rawcom

jaxasrc:
    set _BLDROOT=$(_BLDROOT)
    set NTMAKEENV_TMP=$(NTMAKEENV)
    set NTMAKEENV=
!if $(FREEBUILD)
    nmake D=0 fresh
!else
    nmake fresh
!endif
    set NTMAKEENV=$(NTMAKEENV_TMP)
    copy $(BINDIR)\dxmedia.zip $(TARGETPATH)\$(TARGET_DIRECTORY)
    copy $(BINDIR)\dajava.cab $(TARGETPATH)\$(TARGET_DIRECTORY)
!else
JavaStuff:
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\behaviors\autoeffect.h ===
#ifndef __AUTOEFFECT_H_
#define __AUTOEFFECT_H_

//*****************************************************************************
//
// Microsoft LiquidMotion
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    AutoEffect.h
//
// Author:	markhal
//
// Created:	11/10/98
//
// Abstract:    Definition of the LM Auto Effect Behavior.
//
//*****************************************************************************

#include <resource.h>
#include <vector>

#include "lmrt.h"
#include "..\chrome\include\basebvr.h"
#include "..\chrome\include\sampler.h"
#include "sparkmaker.h"

using namespace std;

class CSpark
{
public:
	CSpark(	IDABehavior * pBvr = NULL, 
			bool fAlive = true, 
			double dAge = 0.0 );

	CSpark( const CSpark& );

	virtual ~CSpark();

public:
	bool		IsAlive();
	double		Age( double dDeltaTime );
	HRESULT		Kill( IDABehavior * );
	HRESULT		Reincarnate( IDABehavior *, double in_dAge = 0.0 );

protected:
	bool							m_fAlive;
	double							m_dAge;
	CComPtr<IDABehavior>			m_pModifiableBvr;
};

typedef vector<CSpark> VecSparks;

#define NUM_AUTOEFFECT_PROPS 10

//*****************************************************************************

class ATL_NO_VTABLE CAutoEffectBvr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAutoEffectBvr, &CLSID_LMAutoEffectBvr>,
    public IConnectionPointContainerImpl<CAutoEffectBvr>,
    public IPropertyNotifySinkCP<CAutoEffectBvr>,
    public IDispatchImpl<ILMAutoEffectBvr, &IID_ILMAutoEffectBvr, &LIBID_LiquidMotion>,
    public IPersistPropertyBag2,
    public IElementBehavior,
	public ILMSample,
    public CBaseBehavior
	
{
public:
DECLARE_REGISTRY_RESOURCEID(IDR_AUTOEFFECTBVR)

BEGIN_COM_MAP(CAutoEffectBvr)
	COM_INTERFACE_ENTRY(ILMAutoEffectBvr)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPersistPropertyBag2)
	COM_INTERFACE_ENTRY(IElementBehavior)
    COM_INTERFACE_ENTRY(ILMSample)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

// Connection Point to allow IPropertyNotifySink 
BEGIN_CONNECTION_POINT_MAP(CAutoEffectBvr)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

	CAutoEffectBvr();
    ~CAutoEffectBvr();
    HRESULT FinalConstruct();
    // IElementBehavior
    //
	STDMETHOD(Init)(IElementBehaviorSite *pBehaviorSite);
	STDMETHOD(Notify)(LONG event, VARIANT *pVar);
	STDMETHOD(Detach)();

    // ILMSample
    STDMETHOD(Sample) (double dStart, double dGlobalNow, double dLocalNow );

    //
    //ILMAutoEffectBvr
    //
    STDMETHOD(put_animates)( VARIANT newVal );
    STDMETHOD(get_animates)( VARIANT *pVal );
    STDMETHOD(put_type)( VARIANT newVal );
    STDMETHOD(get_type)( VARIANT *pVal );
    STDMETHOD(put_cause)( VARIANT newVal );
    STDMETHOD(get_cause)( VARIANT *pVal );
    STDMETHOD(put_span)( VARIANT newVal );
    STDMETHOD(get_span)( VARIANT *pVal );
    STDMETHOD(put_size)( VARIANT newVal );
    STDMETHOD(get_size)( VARIANT *pVal );
    STDMETHOD(put_rate)( VARIANT newVal );
    STDMETHOD(get_rate)( VARIANT *pVal );
    STDMETHOD(put_gravity)( VARIANT newVal );
    STDMETHOD(get_gravity)( VARIANT *pVal );
    STDMETHOD(put_wind)( VARIANT newVal );
    STDMETHOD(get_wind)( VARIANT *pVal );
    STDMETHOD(put_fillColor)( VARIANT newVal );
    STDMETHOD(get_fillColor)( VARIANT *pVal );
    STDMETHOD(put_strokeColor)( VARIANT newVal );
    STDMETHOD(get_strokeColor)( VARIANT *pVal );
    STDMETHOD(put_opacity)( VARIANT newVal );
    STDMETHOD(get_opacity)( VARIANT *pVal );
	STDMETHOD(buildBehaviorFragments)( IDispatch* pActorDisp );

	STDMETHOD(mouseEvent) (long x,
						   long y,
                           VARIANT_BOOL bMove,
                           VARIANT_BOOL bUp,
                           VARIANT_BOOL bShift, 
                           VARIANT_BOOL bAlt,
                           VARIANT_BOOL bCtrl,
                           long button);
    //IPersistPropertyBag2 methods
    STDMETHOD(GetClassID)(CLSID* pclsid);
	STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void){return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    // Needed by CBaseBehavior
    void * 	GetInstance() { return (ILMAutoEffectBvr *) this ; }
	
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }

protected:
	enum Cause
	{
		CAUSE_TIME,
		CAUSE_MOUSEMOVE,
		CAUSE_DRAGOVER,
		CAUSE_MOUSEDOWN,
		NUM_CAUSES
	};

	static const WCHAR * const RGSZ_CAUSES[ NUM_CAUSES ];
	
	static const WCHAR * const RGSZ_TYPES[ CSparkMaker::NUM_TYPES ];
	
protected:
    virtual HRESULT BuildAnimationAsDABehavior() { return S_OK; }

    virtual VARIANT *VariantFromIndex(ULONG iIndex);

    virtual HRESULT GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropName);
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);

	HRESULT InitInternalProperties();
	HRESULT InitSparks();

	HRESULT AddSpark();
	HRESULT AddSparkAround( long x, long y );
	HRESULT	AddSparkAt( long x, long y );

	HRESULT	CreateSparkBvr( IDAImage ** ppImageBvr, float fX, float fY, float fSize );


private:
	HRESULT AddMouseEventListener( bool bAdd );
	
	HRESULT	AgeSparks( double dDeltaTime );

	HRESULT PossiblyAddSparks( double dLocalTime );
	HRESULT PossiblyAddSpark( double dLocalTime, long x, long y );
	HRESULT	ResetSparks( double dLocalTime );
	bool	ThrottleBirth( double dLocalTime );
	void	ResetThrottle( double dLocalTime );
	
	HRESULT AddBvrToSparkArray( IDAImage * pImageBvr );
		
private:
	CComPtr<IDispatch>	m_pdispActor;

	CSampler			* m_pSampler;
	CSparkMaker			* m_pSparkMaker;
	CComPtr<IDA2Array>	m_pDAArraySparks;
	VecSparks			m_vecSparks;
	SparkOptions		m_sparkOptions;

    static WCHAR                *m_rgPropNames[NUM_AUTOEFFECT_PROPS]; 

    VARIANT m_type;
    VARIANT m_cause;
    VARIANT m_span;
    VARIANT m_size;
    VARIANT m_rate;
    VARIANT m_gravity;
    VARIANT m_wind;
    VARIANT m_fillColor;
    VARIANT m_strokeColor;
	VARIANT m_opacity;

	CSparkMaker::Type	m_eType;
	Cause				m_eCause;
	double				m_dMaxAge;               
	float				m_fScaledSize;           
	double				m_dBirthDelta;           
	float				m_fXVelocity;            
	float				m_fYVelocity;            
	float				m_fOpacity;              
						                         
	double				m_dLocalTime;            
	double				m_dLastBirth; 

	long				m_lCookie;

	HRESULT				RemoveFragment();
	
}; // CAutoEffectBvr

inline CSpark::CSpark( IDABehavior * in_pBvr, bool in_fAlive, double in_dAge )
{
	m_fAlive 			= in_fAlive;
	m_dAge				= in_dAge;
	m_pModifiableBvr	= in_pBvr;
}

inline CSpark::CSpark( const CSpark& in_spark )
{
	m_fAlive			= in_spark.m_fAlive;
	m_dAge				= in_spark.m_dAge;
	m_pModifiableBvr	= in_spark.m_pModifiableBvr;
}

inline CSpark::~CSpark()
{
}

inline bool
CSpark::IsAlive()
{
	return m_fAlive;
}

#endif //__AUTOEFFECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\behaviors\autoeffect.cpp ===
//*****************************************************************************
//
// File:            autoeffect.cpp
// Author:          markhal, elainela
// Date Created:    11/10/98
//
// Abstract: Implementation of the Liquid Motion auto effect behavior as
//           a DHTML behavior.
//
//*****************************************************************************

#include "headers.h"

#include "autoeffect.h"
#include "lmattrib.h"
#include "lmdefaults.h"
#include "..\idl\lmbvrdispid.h"
#include "..\chrome\src\dautil.h"
#include "..\chrome\include\utils.h"

#undef THIS
#define THIS CAutoEffectBvr
#define SUPER CBaseBehavior

#include "..\chrome\src\pbagimp.cpp"

static const	int		RAND_PRECISION		= 1000;

static const	long	MAX_SPARKS			= 40;
static const	double	MIN_MAXAGE			= 0.04;
static const	double	MIN_DELTABIRTH		= 0.005;
static const	double	SPARK_BASESIZE		= 4.0;
static const	long	SPARK_OFFSET		= 10;

const WCHAR * const CAutoEffectBvr::RGSZ_CAUSES[ NUM_CAUSES ] =
{
	L"time",
	L"onmousemove",
	L"ondragover",
	L"onmousedown"
};

const WCHAR * const CAutoEffectBvr::RGSZ_TYPES[ CSparkMaker::NUM_TYPES ] =
{
	L"sparkles",
	L"twirlers",
	L"bubbles",
	L"filledbubbles",
	L"clouds",
	L"smoke"
};

#define VAR_TYPE		0
#define VAR_CAUSE		1
#define VAR_SPAN		2 
#define VAR_SIZE		3 
#define VAR_RATE		4 
#define VAR_GRAVITY		5
#define VAR_WIND		6 
#define VAR_FILLCOLOR	7
#define VAR_STROKECOLOR 8
#define VAR_OPACITY		9

WCHAR * CAutoEffectBvr::m_rgPropNames[] = {
									 BEHAVIOR_PROPERTY_TYPE,
									 BEHAVIOR_PROPERTY_CAUSE,
									 BEHAVIOR_PROPERTY_SPAN,
									 BEHAVIOR_PROPERTY_SIZE,
									 BEHAVIOR_PROPERTY_RATE,
									 BEHAVIOR_PROPERTY_GRAVITY,
									 BEHAVIOR_PROPERTY_WIND,
									 BEHAVIOR_PROPERTY_FILLCOLOR,
									 BEHAVIOR_PROPERTY_STROKECOLOR,
									 BEHAVIOR_PROPERTY_OPACITY
									};

//*****************************************************************************

CAutoEffectBvr::CAutoEffectBvr()
{
	m_pdispActor	= NULL;

	m_lCookie 		= 0;

	m_pSampler		= NULL;
	
	m_pSparkMaker	= NULL;
	m_eType			= CSparkMaker::SPARKLES;
	m_eCause		= CAUSE_TIME;
	
	// REVIEW: These numbers should never actually be used.
	m_dBirthDelta	= 1.0/3.0;
	m_dMaxAge		= 3.0;
	m_fScaledSize	= 5.0f;
	m_fXVelocity	= 0.0f;
	m_fYVelocity	= 0.0f;
	
	m_dLastBirth	= 0;

	VariantInit( &m_type );
	VariantInit( &m_cause );
	VariantInit( &m_span );
	VariantInit( &m_size );
	VariantInit( &m_rate );
	VariantInit( &m_gravity );
	VariantInit( &m_wind );
	VariantInit( &m_fillColor );
	VariantInit( &m_strokeColor );
	VariantInit( &m_opacity );
}

//*****************************************************************************

CAutoEffectBvr::~CAutoEffectBvr()
{
	if( m_pSampler != NULL )
	{
		m_pSampler->Invalidate();
		m_pSampler = NULL;
	}

	delete m_pSparkMaker;
	
	VariantClear( &m_type );
	VariantClear( &m_cause );
	VariantClear( &m_span );
	VariantClear( &m_size );
	VariantClear( &m_rate );
	VariantClear( &m_gravity );
	VariantClear( &m_wind );
	VariantClear( &m_fillColor );
	VariantClear( &m_strokeColor );
	VariantClear( &m_opacity );
}

//*****************************************************************************

HRESULT 
CAutoEffectBvr::FinalConstruct()
{

	HRESULT hr = SUPER::FinalConstruct();
	if (FAILED(hr))
	{
		DPF_ERR("Error in auto effect behavior FinalConstruct initializing base classes");
		return hr;
	}
	return S_OK;
} // FinalConstruct

//*****************************************************************************

VARIANT *
CAutoEffectBvr::VariantFromIndex(ULONG iIndex)
{
	DASSERT(iIndex < NUM_AUTOEFFECT_PROPS);
	switch (iIndex)
	{
	case VAR_TYPE:
		return &m_type;
		break;
	case VAR_CAUSE:
		return &m_cause;
		break;
	case VAR_SPAN:
		return &m_span;
		break;
	case VAR_SIZE:
		return &m_size;
		break;
	case VAR_RATE:
		return &m_rate;
		break;
	case VAR_GRAVITY:
		return &m_gravity;
		break;
	case VAR_WIND:
		return &m_wind;
		break;
	case VAR_FILLCOLOR:
		return &m_fillColor;
		break;
	case VAR_STROKECOLOR:
		return &m_strokeColor;
		break;
	case VAR_OPACITY:
		return &m_opacity;
		break;
	default:
		// We should never get here
		DASSERT(false);
		return NULL;
	}
} // VariantFromIndex

//*****************************************************************************

HRESULT 
CAutoEffectBvr::GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropNames)
{
	*pulProperties = NUM_AUTOEFFECT_PROPS;
	*pppPropNames = m_rgPropNames;
	return S_OK;
} // GetPropertyBagInfo

//*****************************************************************************

STDMETHODIMP 
CAutoEffectBvr::Init(IElementBehaviorSite *pBehaviorSite)
{
	return SUPER::Init(pBehaviorSite);
} // Init

//*****************************************************************************

STDMETHODIMP 
CAutoEffectBvr::Notify(LONG event, VARIANT *pVar)
{
	HRESULT hr = SUPER::Notify(event, pVar);
	CheckHR( hr, "Notify in base class failed", end);

	switch( event )
	{
	case BEHAVIOREVENT_CONTENTREADY:
		DPF_ERR("Got Content Ready");
			
		{
			hr = RequestRebuild( );
			CheckHR( hr, "Request for rebuild failed", end );
			
		}break;
    case BEHAVIOREVENT_DOCUMENTREADY:
		break;
    case BEHAVIOREVENT_APPLYSTYLE:
		DPF_ERR("Got ApplyStyle");
		break;
    case BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE:
		DPF_ERR("Got Document context change");
		break;
	default:
		DPF_ERR("Unknown event");
	}

end:
	
	return hr;

} // Notify

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::Detach()
{
	if ( m_pdispActor )
	{
		AddMouseEventListener( false );
	}

	HRESULT hr = S_OK;

	if( m_pSampler != NULL )
	{
		m_pSampler->Invalidate();
		m_pSampler = NULL;
	}

	hr = RemoveFragment();

	m_pdispActor.Release();
	
	hr = SUPER::Detach();

	CheckHR( hr, "Failed to remove the behavior fragment from this behavior", end );

end:
	return hr;
} // Detach 

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::Sample( double dStart, double dGlobalNow, double dLocalNow )
{
	if ( m_pSparkMaker == NULL ) return S_OK;
	
	HRESULT		hr = S_OK;

	// Never run before, or starting over again?  Reset sparks
	if ( ( m_dLocalTime < 0.0 ) || ( dLocalNow < m_dLocalTime ) )
		ResetSparks( 0.0 );
	else
		AgeSparks( dLocalNow - m_dLocalTime );

	m_dLocalTime = dLocalNow;
	
	if ( m_eCause == CAUSE_TIME )
	{
		PossiblyAddSparks( dLocalNow );
	}
	
	return	hr;

} // Sample

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::buildBehaviorFragments( IDispatch* pActorDisp )
{
	HRESULT hr = S_OK;

	hr = RemoveFragment();
	if( FAILED( hr ) )
	{
		DPF_ERR("failed to remove the behavior fragment" );
		return hr;
	}

	if( m_pSampler != NULL )
	{
		m_pSampler->Invalidate();
		m_pSampler = NULL;
	}

	m_pSampler = new CSampler( this );


	// HACK: This is just so we can test the progress number
	if (V_VT(&m_type) == VT_BSTR && wcsicmp(V_BSTR(&m_type), L"progress") == 0)
	{
		CComPtr<IDANumber> pProgress;
		
		hr = GetTIMEProgressNumber(&pProgress);
		LMRETURNIFFAILED(hr);

		CComPtr<IDAString> pProgressString;

		hr = pProgress->ToString(5, &pProgressString);
		LMRETURNIFFAILED(hr);

		CComPtr<IDAFontStyle> pDefaultFont;

		hr = GetDAStatics()->get_DefaultFont(&pDefaultFont);
		LMRETURNIFFAILED(hr);

		CComPtr<IDAImage> pProgressImage;

		hr = GetDAStatics()->StringImageAnim(pProgressString, pDefaultFont, &pProgressImage);
		LMRETURNIFFAILED(hr);

		IDispatch* pdispThis = NULL;

		hr = GetHTMLElementDispatch( &pdispThis );
		if( FAILED( hr ) )
		{
			DPF_ERR( "failed to get IDispatch from the element" );
			return hr;
		}
		
		hr = AttachBehaviorToActorEx( pActorDisp, 
									  pProgressImage, 
									  L"image", 
									  e_Relative, 
									  e_Image,
									  pdispThis,
									  &m_lCookie);
		ReleaseInterface( pdispThis );
		LMRETURNIFFAILED(hr);

		m_pdispActor = pActorDisp;
		
		return S_OK;
	}

	// HACK: This is just so we can test the timeline number
	if (V_VT(&m_type) == VT_BSTR && wcsicmp(V_BSTR(&m_type), L"timeline") == 0)
	{
		CComPtr<IDANumber> pProgress;
		
		hr = GetTIMETimelineBehavior(&pProgress);
		LMRETURNIFFAILED(hr);

		CComPtr<IDAString> pProgressString;

		hr = pProgress->ToString(5, &pProgressString);
		LMRETURNIFFAILED(hr);

		CComPtr<IDAFontStyle> pDefaultFont;

		hr = GetDAStatics()->get_DefaultFont(&pDefaultFont);
		LMRETURNIFFAILED(hr);

		CComPtr<IDAImage> pProgressImage;

		hr = GetDAStatics()->StringImageAnim(pProgressString, pDefaultFont, &pProgressImage);
		LMRETURNIFFAILED(hr);

		IDispatch* pdispThis = NULL;

		hr = GetHTMLElementDispatch( &pdispThis );
		if( FAILED( hr ) )
		{
			DPF_ERR( "failed to get IDispatch from the element" );
			return hr;
		}
		
		hr = AttachBehaviorToActorEx( pActorDisp, 
									  pProgressImage, 
									  L"image", 
									  e_Relative, 
									  e_Image,
									  pdispThis,
									  &m_lCookie);
		ReleaseInterface( pdispThis );
		LMRETURNIFFAILED(hr);

		m_pdispActor = pActorDisp;
		
		return S_OK;
	}

	// HACK: This is just so we can display the framerate number
	if (V_VT(&m_type) == VT_BSTR && wcsicmp(V_BSTR(&m_type), L"framerate") == 0)
	{
		CComQIPtr<IDA2Statics, &IID_IDA2Statics> pStatics2(GetDAStatics());

		if (pStatics2 == NULL)
			return E_FAIL;

		CComPtr<IDANumber> pFrameRate;

		hr = pStatics2->get_ViewFrameRate(&pFrameRate);
		LMRETURNIFFAILED(hr);
		
		CComPtr<IDAString> pString;

		hr = pFrameRate->ToString(5, &pString);
		LMRETURNIFFAILED(hr);

		CComPtr<IDAFontStyle> pDefaultFont;

		hr = GetDAStatics()->get_DefaultFont(&pDefaultFont);
		LMRETURNIFFAILED(hr);

		CComPtr<IDAImage> pImage;

		hr = GetDAStatics()->StringImageAnim(pString, pDefaultFont, &pImage);
		LMRETURNIFFAILED(hr);

		IDispatch* pdispThis = NULL;

		hr = GetHTMLElementDispatch( &pdispThis );
		if( FAILED( hr ) )
		{
			DPF_ERR( "failed to get IDispatch from the element" );
			return hr;
		}
		
		hr = AttachBehaviorToActorEx( pActorDisp, 
									  pImage, 
									  L"image", 
									  e_Relative, 
									  e_Image,
									  pdispThis,
									  &m_lCookie);
		ReleaseInterface( pdispThis );
		LMRETURNIFFAILED(hr);

		m_pdispActor = pActorDisp;
		
		return S_OK;
	}

	// HACK: This is also a hack to return a solid red image
	if (V_VT(&m_type) == VT_BSTR && wcsicmp(V_BSTR(&m_type), L"red") == 0)
	{
		CComPtr<IDAColor> pColor;
		hr = GetDAStatics()->get_Red(&pColor);
		LMRETURNIFFAILED(hr);

		CComPtr<IDAImage> pImage;
		hr = GetDAStatics()->SolidColorImage(pColor, &pImage);
		LMRETURNIFFAILED(hr);

		IDispatch* pdispThis = NULL;

		hr = GetHTMLElementDispatch( &pdispThis );
		if( FAILED( hr ) )
		{
			DPF_ERR( "failed to get IDispatch from the element" );
			return hr;
		}
		
		hr = AttachBehaviorToActorEx( pActorDisp, 
									  pImage, 
									  L"image", 
									  e_Relative, 
									  e_Image,
									  pdispThis,
									  &m_lCookie);
		ReleaseInterface( pdispThis );
		LMRETURNIFFAILED(hr);

		m_pdispActor = pActorDisp;
		
		return S_OK;
	}

	m_pdispActor = pActorDisp;

	hr = AddMouseEventListener( true );
	LMRETURNIFFAILED(hr);

	
	IDAStatics * pStatics = GetDAStatics();
	if ( pStatics == NULL ) return E_FAIL;

	// Initialize internal representation of properties
	//----------------------------------------------------------------------
	hr = InitInternalProperties();
	LMRETURNIFFAILED(hr);

	// Initialize sparks
	//----------------------------------------------------------------------
	hr = InitSparks();
	LMRETURNIFFAILED(hr);

	CComPtr<IUnknown> pUnkDAArray( m_pDAArraySparks );
	CComPtr<IDAImage> pImageBvr;
	CComVariant		  varDAArray( pUnkDAArray );

	hr = pStatics->OverlayArray( varDAArray, &pImageBvr );
	LMRETURNIFFAILED(hr);
/*
  if (m_fOpacity != 1.0f)
  {
  // We have to add in some opacity
  CComPtr<IDAImage> pOpacityImage;
  hr = pImageBvr->Opacity(m_fOpacity, &pOpacityImage);
  LMRETURNIFFAILED(hr);
		
  pImageBvr = pOpacityImage;
  }
*/
	// We have the resultant behavior; we want to sample it in order
	// to update it
	//----------------------------------------------------------------------
	CComQIPtr<IDABehavior, &IID_IDABehavior> pBvrOrig( pImageBvr );
	CComPtr<IDABehavior> pBvrSampled;

	hr = m_pSampler->Attach( pBvrOrig, &pBvrSampled );
	LMRETURNIFFAILED(hr);

	// Substitute timeline behavior so that Sample() calls us with our local time
	//----------------------------------------------------------------------
	CComPtr<IDANumber> 		pnumTimeline;
	CComPtr<IDABehavior> 	pBvrLocal;
	
	hr = GetTIMETimelineBehavior( &pnumTimeline );
	LMRETURNIFFAILED(hr);

	hr = pBvrSampled->SubstituteTime( pnumTimeline, &pBvrLocal );
	LMRETURNIFFAILED(hr);
	
	CComQIPtr<IDAImage, &IID_IDAImage> pImgBvrLocal( pBvrLocal );
	if ( pImgBvrLocal == NULL )
		return E_FAIL;

	// Attach behavior to the actor
	//----------------------------------------------------------------------

	IDispatch* pdispThis = NULL;

	hr = GetHTMLElementDispatch( &pdispThis );
	if( FAILED( hr ) )
	{
		DPF_ERR( "failed to get IDispatch from the element" );
		return hr;
	}
	
	hr = AttachBehaviorToActorEx( pActorDisp, 
								  pImgBvrLocal, 
								  L"image", 
								  e_ScaledImage, 
								  e_Image,
								  pdispThis,
								  &m_lCookie );

	ReleaseInterface( pdispThis );
	if (FAILED(hr))
	{
		DPF_ERR("Error building animation");
		return SetErrorInfo(hr);
	}

	return S_OK;

} // buildBehaviorFragments

HRESULT
CAutoEffectBvr::InitInternalProperties()
{
	HRESULT	hr;

	// Type -- initialize SparkMaker
	//----------------------------------------------------------------------
	delete m_pSparkMaker, m_pSparkMaker = NULL;

	CComBSTR bstrType = RGSZ_TYPES[ CSparkMaker::SPARKLES ];
	HRESULT hrTmp = CUtils::InsurePropertyVariantAsBSTR( &m_type );
	if ( SUCCEEDED(hrTmp) )
		bstrType = V_BSTR( &m_type );

	for ( int i = 0; i < CSparkMaker::NUM_TYPES; i++ )
	{
		if ( _wcsicmp( bstrType, RGSZ_TYPES[ i] ) == 0 )
		{
			m_eType = (CSparkMaker::Type) i;
			hr = CSparkMaker::CreateSparkMaker( GetDAStatics(),
												m_eType,
												&m_pSparkMaker );
			LMRETURNIFFAILED(hr);
			break;
		}
	}

	if ( m_pSparkMaker == NULL )
		return E_FAIL;
		
	// Cause
	//----------------------------------------------------------------------
	CComBSTR bstrCause = RGSZ_CAUSES[ CAUSE_TIME ];
	hrTmp = CUtils::InsurePropertyVariantAsBSTR( &m_cause );
	if ( SUCCEEDED(hrTmp) )
		bstrCause = V_BSTR( &m_cause );

	for ( i = 0; i < NUM_CAUSES; i++ )
	{
		if ( _wcsicmp( bstrCause, RGSZ_CAUSES[ i] ) == 0 )
		{
			m_eCause = (Cause) i;
			break;
		}
	}
	
	// Lifespan --> Maximum age
	//----------------------------------------------------------------------
	float fSpan = DEFAULT_AUTOEFFECT_SPAN;
	hrTmp = CUtils::InsurePropertyVariantAsFloat( &m_span );
	if ( SUCCEEDED(hrTmp) )
		fSpan = V_R4( &m_span );
	
	fSpan = __max( 0.0, __min( 1.0, fSpan ) );

	// Parabolic scale; make max 15 secs
	m_dMaxAge = fSpan*fSpan*15.0;
	m_dMaxAge = __max( MIN_MAXAGE, m_dMaxAge );
	
	// Size --> m_fScaledSize
	//----------------------------------------------------------------------
	float fSize = DEFAULT_AUTOEFFECT_SIZE;
	hrTmp = CUtils::InsurePropertyVariantAsFloat( &m_size );
	if ( SUCCEEDED(hrTmp) )
		fSize = V_R4( &m_size );

	fSize = __max( 0.0, __min( 1.0, fSize ) );
	
	fSize *= 2;
	m_fScaledSize = (fSize*fSize) * 10.0f;

	// Birthrate --> Birth Delta
	//----------------------------------------------------------------------
	float fRate = DEFAULT_AUTOEFFECT_RATE;
	hrTmp = CUtils::InsurePropertyVariantAsFloat( &m_rate );
	if ( SUCCEEDED(hrTmp) )
		fRate = V_R4( &m_rate );
	
	fRate = __max( 0.0, __min( 1.0, fRate ) );
		
	// 0 becomes high; 1 becomes low
	m_dBirthDelta = 1.0 - fRate;
	//	4*(v^4) -- high curve; max is 4 secs.
	m_dBirthDelta = 4*pow( m_dBirthDelta, 4 ) + MIN_DELTABIRTH;

	// Velocity
	//----------------------------------------------------------------------
	float	fXV = DEFAULT_AUTOEFFECT_WIND;
	float	fYV = DEFAULT_AUTOEFFECT_GRAVITY;

	hrTmp = CUtils::InsurePropertyVariantAsFloat( &m_wind );
	if ( SUCCEEDED(hrTmp) )
		fXV = V_R4( &m_wind );

	fXV = __max( -1.0, __min( 1.0, fXV ) );

	m_fXVelocity = fXV * 20.0;
	
	hrTmp = CUtils::InsurePropertyVariantAsFloat( &m_gravity );
	if ( SUCCEEDED(hrTmp) )
		fYV = V_R4( &m_gravity );

	fYV = __max( -1.0, __min( 1.0, fYV ) );
	
	m_fYVelocity = fYV * -40.0;

	// Opacity
	//----------------------------------------------------------------------
	float fOpacity = DEFAULT_AUTOEFFECT_OPACITY;
	hrTmp = CUtils::InsurePropertyVariantAsFloat( &m_opacity );
	if ( SUCCEEDED(hrTmp) )
		fOpacity = V_R4( &m_opacity );

	fOpacity = __max( 0.0, __min( 1.0, fOpacity ) );

	m_fOpacity = fOpacity;
	
	return hr;
}

//*****************************************************************************

HRESULT
CAutoEffectBvr::InitSparks()
{
	HRESULT	hr = S_OK;
	
	// Cleanup from previous runs
	//----------------------------------------------------------------------
	if ( m_pDAArraySparks != NULL )
	{
		m_pDAArraySparks.Release();
	}

	// Initialize parameters for a run --
	// REVIEW: using same functions as LM 1.0
	//----------------------------------------------------------------------
	m_dLocalTime = -1.0;
	m_dLastBirth = -1.0;
	
	// Color behaviors
	//----------------------------------------------------------------------
	IDAStatics * pStatics = GetDAStatics();
	if ( pStatics == NULL ) return E_FAIL;
	CComQIPtr<IDA2Statics, &IID_IDA2Statics> pStatics2( pStatics );
	
	HRESULT		hrTmp;
	DWORD		color1 = DEFAULT_AUTOEFFECT_FILLCOLOR;
	DWORD		color2 = DEFAULT_AUTOEFFECT_STROKECOLOR;
	float		h1, s1, l1;
	float		h2, s2, l2;
	
	hrTmp = CUtils::InsurePropertyVariantAsBSTR( &m_fillColor );
	if ( SUCCEEDED(hrTmp) )
		color1 = CUtils::GetColorFromVariant( &m_fillColor );
		
	hrTmp = CUtils::InsurePropertyVariantAsBSTR( &m_strokeColor );
	if ( SUCCEEDED(hrTmp) )
		color2 = CUtils::GetColorFromVariant( &m_strokeColor );

	HSL hsl;
	
	CUtils::GetHSLValue( color1, &hsl.hue, &hsl.sat, &hsl.lum );
	m_sparkOptions.hslPrimary = hsl;
	CUtils::GetHSLValue( color2, &hsl.hue, &hsl.sat, &hsl.lum );
	m_sparkOptions.hslSecondary = hsl;

	// Add an image behavior now; otherwise we don't get calls to Sample()
	// later
	//----------------------------------------------------------------------
	CComPtr<IDAImage> pImageEmpty;
	hr = pStatics->get_EmptyImage( &pImageEmpty );
	LMRETURNIFFAILED(hr);
		
	AddBvrToSparkArray( pImageEmpty );					

	return hr;
}

//*****************************************************************************

HRESULT
CAutoEffectBvr::AddSpark()
{
	// Determine position & dimensions of our "canvas"
	CComPtr<IHTMLElement>	pElement;
	long					lWidth, lHeight;
	HRESULT					hr;
	
	hr = GetElementToAnimate( &pElement );
	LMRETURNIFFAILED(hr);

	hr = pElement->get_offsetWidth( &lWidth );
	LMRETURNIFFAILED(hr);
	hr = pElement->get_offsetHeight( &lHeight );
	LMRETURNIFFAILED(hr);

	// Origin is in the middle
	long x = lWidth == 0 ? 0 : ( 2 * (rand() % lWidth) - lWidth ) / 2;
	long y = lHeight == 0 ? 0 : ( 2 * (rand() % lHeight) - lHeight ) / 2;

	return AddSparkAt( x, y );
}

//*****************************************************************************

HRESULT
CAutoEffectBvr::AddSparkAround( long x, long y)
{
	long xOff = (long) ((rand() % (2*SPARK_OFFSET)) - SPARK_OFFSET);
	long yOff = (long) ((rand() % (2*SPARK_OFFSET)) - SPARK_OFFSET);

	return AddSparkAt( x+xOff, y+yOff );
}

//*****************************************************************************

HRESULT
CAutoEffectBvr::AddSparkAt( long x, long y)
{
	HRESULT				hr			= S_OK;

	// See if we can add element to existing array:	 try to reincarnate 
	// dead sparks if they exist.
	//----------------------------------------------------------------------
	bool				bReuseDeadSpark	= false;
	VecSparks::iterator itSpark				= m_vecSparks.begin();

	for ( itSpark = m_vecSparks.begin();
		  itSpark != m_vecSparks.end();
		  itSpark++ )
	
	{
		if ( !itSpark->IsAlive() )
		{
			bReuseDeadSpark = true;
			break;
		}
	}

	// We allow at most MAX_SPARKS in our array
	//----------------------------------------------------------------------
	if ( !bReuseDeadSpark && m_vecSparks.size() == MAX_SPARKS )
		return S_FALSE;
		 
	// Create spark
	//----------------------------------------------------------------------
	CComPtr<IDAImage>	pImageBvr;

	float fSize = SPARK_BASESIZE +
		m_fScaledSize * ( (rand()%RAND_PRECISION)/((float) RAND_PRECISION) );
	
	hr = CreateSparkBvr( &pImageBvr, (float) x, (float) y, fSize );
	LMRETURNIFFAILED(hr);

	// Reuse a dead spark if we have one.  If we have to create a new spark,
	// we need to add a new modifiable behavior to the DAArray.
	//----------------------------------------------------------------------
	if ( bReuseDeadSpark )
		itSpark->Reincarnate( pImageBvr, 0.0 );
	else
		AddBvrToSparkArray( pImageBvr );

	return hr;
}

//*****************************************************************************

HRESULT
CAutoEffectBvr::CreateSparkBvr( IDAImage ** ppImageBvr, float fX, float fY, float fSize )
{
	DASSERT( ppImageBvr != NULL );

	if ( m_pSparkMaker == NULL ) return E_FAIL;
	
	HRESULT					hr	= S_OK;
	VecDATransforms			vecTransforms;
	int						cTransforms = 0;
	
	IDA2Statics * pStatics	= GetDAStatics();
	if ( pStatics == NULL ) return E_FAIL;

	// Get age behavior == local time, which will start at zero when we are
	// born.
	//----------------------------------------------------------------------
	CComPtr<IDANumber>		pnumAge;
	CComPtr<IDANumber>		pnumCurTime;
	CComPtr<IDANumber>		pnumLocalTime;
	CComPtr<IDANumber>		pnumMaxAge;
	CComPtr<IDANumber>		pnumAgeRatio;
	CComPtr<IDANumber>		pnumOne;
	CComPtr<IDABoolean>		pboolGTOne;
	CComPtr<IDABehavior>	pClampedAgeRatio;
	
	hr = pStatics->get_LocalTime( &pnumLocalTime );
	LMRETURNIFFAILED(hr);

	hr = CDAUtils::GetDANumber( pStatics, m_dMaxAge, &pnumMaxAge );
	LMRETURNIFFAILED(hr);

	hr = CDAUtils::GetDANumber( pStatics, m_dLocalTime, &pnumCurTime );
	LMRETURNIFFAILED(hr);

	hr = pStatics->Sub( pnumLocalTime, pnumCurTime, &pnumAge );
	LMRETURNIFFAILED(hr);
	
	hr = pStatics->Div( pnumAge, pnumMaxAge, &pnumAgeRatio);
	LMRETURNIFFAILED(hr);

	hr = CDAUtils::GetDANumber( pStatics, 1.0f, &pnumOne );
	LMRETURNIFFAILED(hr);

	hr = pStatics->GT( pnumAgeRatio, pnumOne, &pboolGTOne );
	LMRETURNIFFAILED(hr);

	//hr = pStatics->Cond( pboolGTOne, pnumOne, pnumAgeRatio, &pClampedAgeRatio );
	hr = SafeCond( pStatics, pboolGTOne, pnumOne, pnumAgeRatio, &pClampedAgeRatio );
	LMRETURNIFFAILED(hr);

	pnumAgeRatio.Release();
	hr = pClampedAgeRatio->QueryInterface( IID_IDANumber, (LPVOID *) &pnumAgeRatio );
	LMRETURNIFFAILED(hr);
	
	// Create basic image
	//----------------------------------------------------------------------
	CComPtr<IDAImage>		pBaseImage;
	
	hr = m_pSparkMaker->GetSparkImageBvr( &m_sparkOptions, pnumAgeRatio, &pBaseImage );
	LMRETURNIFFAILED(hr);
	
	// OPACITY:
	//----------------------------------------------------------------------
	if (m_fOpacity != 1.0f)
	{
		CComPtr<IDAImage> pOpacityImage;
		hr = pBaseImage->Opacity(m_fOpacity, &pOpacityImage);
		LMRETURNIFFAILED(hr);
		
		pBaseImage = pOpacityImage;
	}

	// SCALE: Initial size
	//----------------------------------------------------------------------
	CComPtr<IDATransform2>	pTransScale;

	hr = pStatics->Scale2Uniform( fSize, &pTransScale );
	LMRETURNIFFAILED(hr);

	vecTransforms.push_back( pTransScale );

	// SCALE: Size animation
	//----------------------------------------------------------------------
	hr = m_pSparkMaker->AddScaleTransforms( pnumAgeRatio, vecTransforms );
	LMRETURNIFFAILED(hr);
	
	// ROTATION: Rotation animation
	//----------------------------------------------------------------------
	hr = m_pSparkMaker->AddRotateTransforms( pnumAgeRatio, vecTransforms );
	LMRETURNIFFAILED(hr);

	// TRANSLATION: Translation animation
	//----------------------------------------------------------------------
	hr = m_pSparkMaker->AddTranslateTransforms( pnumAgeRatio, vecTransforms );
	LMRETURNIFFAILED(hr);
	
	// TRANSLATION: Velocity
	//----------------------------------------------------------------------
	CComPtr<IDANumber>		pnumVelX;
	CComPtr<IDANumber>		pnumVelY;
	CComPtr<IDANumber>		pnumVelXMulAge;
	CComPtr<IDANumber>		pnumVelYMulAge;
	CComPtr<IDATransform2>	pTransVelocity;

	hr = CDAUtils::GetDANumber( pStatics, m_fXVelocity, &pnumVelX );
	LMRETURNIFFAILED(hr);

	hr = pStatics->Mul( pnumVelX, pnumAge, &pnumVelXMulAge );
	LMRETURNIFFAILED(hr);

	hr = CDAUtils::GetDANumber( pStatics, m_fYVelocity, &pnumVelY );
	LMRETURNIFFAILED(hr);
	
	hr = pStatics->Mul( pnumVelY, pnumAge, &pnumVelYMulAge );
	LMRETURNIFFAILED(hr);

	hr = CDAUtils::BuildMoveTransform2( pStatics, 
										pnumVelXMulAge, 
										pnumVelYMulAge, 
										&pTransVelocity );
	LMRETURNIFFAILED(hr);

	vecTransforms.push_back( pTransVelocity );

	// TRANSLATION: Position the image according to coordinates
	//----------------------------------------------------------------------
	CComPtr<IDANumber>		pnumX;
	CComPtr<IDANumber>		pnumY;
	CComPtr<IDATransform2>	pTranslate;
	
	hr = CDAUtils::GetDANumber( pStatics, fX, &pnumX );
	LMRETURNIFFAILED(hr);

	hr = CDAUtils::GetDANumber( pStatics, fY, &pnumY );
	LMRETURNIFFAILED(hr);

	hr = pStatics->Translate2Anim( pnumX, pnumY, &pTranslate );
	LMRETURNIFFAILED(hr);

	vecTransforms.push_back( pTranslate );

	// GLOBAL SCALE: scale by meter/pixel conversion factor
	//----------------------------------------------------------------------
	CComPtr<IDANumber>		pnumMetersPerPixel;
	CComPtr<IDATransform2>	pTransScaleGlobal;

	hr = pStatics->get_Pixel( &pnumMetersPerPixel );
	LMRETURNIFFAILED(hr);

	hr = pStatics->Scale2UniformAnim( pnumMetersPerPixel, &pTransScaleGlobal );
	LMRETURNIFFAILED(hr);

	vecTransforms.push_back( pTransScaleGlobal );

	// Now apply all the transforms
	//----------------------------------------------------------------------
	CComPtr<IDATransform2>		pTransFinal;
	VecDATransforms::iterator	itTransform = vecTransforms.begin();

	pTransFinal = *itTransform;
	++itTransform;
	
	while ( itTransform != vecTransforms.end() )
	{
		CComPtr<IDATransform2> pTransTmp;
		
		hr = pStatics->Compose2( *itTransform, pTransFinal, &pTransTmp );
		LMRETURNIFFAILED(hr);

		pTransFinal = pTransTmp;

		++itTransform;
	}

	hr = pBaseImage->Transform( pTransFinal, ppImageBvr );
	LMRETURNIFFAILED(hr);

	return		hr;
}

//**********************************************************************

HRESULT
CAutoEffectBvr::AddMouseEventListener( bool bAdd )
{
	if ( m_pdispActor == NULL ) return E_FAIL;
	
	HRESULT		hr			= S_OK;
	OLECHAR	*	szName;
	DISPID		dispidAddML;
	DISPPARAMS	params;
	VARIANTARG	rgvargs[1];
	int			cArgs = 1;
	VARIANT		varResult;
	EXCEPINFO	excepInfo;
	UINT		iArgErr;

	szName = bAdd ? L"addMouseEventListener" : L"removeMouseEventListener";
	
	rgvargs[0] = CComVariant( GetUnknown() );
	
	params.rgvarg				= rgvargs;
	params.cArgs				= cArgs;
	params.rgdispidNamedArgs	= NULL;
	params.cNamedArgs			= 0;
	
	hr = m_pdispActor->GetIDsOfNames( IID_NULL,
									  &szName,
									  1,
									  LOCALE_SYSTEM_DEFAULT,
									  &dispidAddML );
	LMRETURNIFFAILED(hr);

	hr = m_pdispActor->Invoke( dispidAddML,
							   IID_NULL,
							   LOCALE_SYSTEM_DEFAULT,
							   DISPATCH_METHOD,
							   &params,
							   &varResult,
							   &excepInfo,
							   &iArgErr );
	return hr;
}

//**********************************************************************

HRESULT
CAutoEffectBvr::AgeSparks( double dDeltaTime )
{
	HRESULT hr	= S_OK;

	IDAStatics * pStatics = GetDAStatics();
	if ( pStatics == NULL ) return E_FAIL;

	CComPtr<IDAImage> pImageEmpty;
	hr = pStatics->get_EmptyImage( &pImageEmpty );
	LMRETURNIFFAILED(hr);

	VecSparks::iterator itSpark;

	for ( itSpark = m_vecSparks.begin(); 
		  itSpark != m_vecSparks.end();
		  itSpark++ )
	{
		if ( itSpark->IsAlive() && ( itSpark->Age( dDeltaTime ) > m_dMaxAge ) )
		{
			itSpark->Kill( pImageEmpty );
		}
	}

	return hr;
}

//**********************************************************************

HRESULT
CAutoEffectBvr::PossiblyAddSpark( double dLocalTime, long x, long y )
{
	bool bAdded = false;

	while ( ThrottleBirth( dLocalTime ) && ( AddSparkAround( x, y ) == S_OK ) )
	{
		ResetThrottle( dLocalTime );
		bAdded = true;
	}
	
	return bAdded ? S_OK : S_FALSE;
}		

//**********************************************************************

HRESULT
CAutoEffectBvr::PossiblyAddSparks( double dLocalTime )
{
	bool bAdded = false;

	while ( ThrottleBirth( dLocalTime ) && ( AddSpark() == S_OK ) )
		bAdded = true;

	return bAdded ? S_OK : S_FALSE;
}		

//**********************************************************************

HRESULT
CAutoEffectBvr::ResetSparks( double dLocalTime )
{
	HRESULT hr	= S_OK;

	IDAStatics * pStatics = GetDAStatics();
	if ( pStatics == NULL ) return E_FAIL;

	CComPtr<IDAImage> pImageEmpty;
	hr = pStatics->get_EmptyImage( &pImageEmpty );
	LMRETURNIFFAILED(hr);

	VecSparks::iterator itSpark;

	for ( itSpark = m_vecSparks.begin(); 
		  itSpark != m_vecSparks.end();
		  itSpark++ )
	{
		if ( itSpark->IsAlive() )
		{
			itSpark->Kill( pImageEmpty );
		}
	}

	ResetThrottle( dLocalTime );
	
	return hr;
}

//**********************************************************************

// See if we could have given birth to a spark in the past.
bool
CAutoEffectBvr::ThrottleBirth( double dLocalTime )
{
	double	dDeltaTime = dLocalTime - m_dLastBirth;

	if ( dDeltaTime < 0 )
	{
		m_dLastBirth = dLocalTime;
		return false;
	}

	if ( dDeltaTime > m_dBirthDelta )
	{
		m_dLastBirth += m_dBirthDelta;
		return true;
	}

	return false;
}

//*****************************************************************************

void
CAutoEffectBvr::ResetThrottle( double dLocalTime )
{
	m_dLastBirth = dLocalTime;
}

HRESULT
CAutoEffectBvr::AddBvrToSparkArray( IDAImage * pImageBvr )
{
	HRESULT				hr			= S_OK;

	IDAStatics * pStatics = GetDAStatics();
	if ( pStatics == NULL ) return E_FAIL;
	
	CComQIPtr<IDABehavior, &IID_IDABehavior> pBvrImageBvr( pImageBvr );
	CComPtr<IDABehavior> pBvrModifiable;
	hr = pStatics->ModifiableBehavior( pBvrImageBvr, &pBvrModifiable );
	LMRETURNIFFAILED(hr);

	// DAArray doesn't exist; we must create it.
	//------------------------------------------------------------------
	if ( m_pDAArraySparks == NULL )
	{
		CComQIPtr<IDA2Statics, &IID_IDA2Statics> pStatics2( pStatics );
		CComPtr<IDAArray> pDAArray;

		hr = pStatics2->DAArrayEx2( 1, &pBvrModifiable, DAARRAY_CHANGEABLE, &pDAArray );
		LMRETURNIFFAILED(hr);

		hr = pDAArray->QueryInterface( IID_IDA2Array, (LPVOID *) &m_pDAArraySparks );
		LMRETURNIFFAILED(hr);
	}
	// DAArray already exists; just add new element.
	//------------------------------------------------------------------
	else
	{
		long lIndex;

		hr = m_pDAArraySparks->AddElement( pBvrModifiable, 0, &lIndex );
		LMRETURNIFFAILED(hr);
	}

	m_vecSparks.push_back( CSpark( pBvrModifiable ) );
		
	return hr;
}

//*****************************************************************************
//ILMAutoEffectBvr
//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::put_animates( VARIANT newVal )
{
	return SUPER::SetAnimatesProperty( newVal );
}

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::get_animates( VARIANT *pVal )
{
	return SUPER::GetAnimatesProperty( pVal );
}

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::put_type( VARIANT newVal )
{
    HRESULT hr = VariantCopy( &m_type, &newVal );
    if (FAILED(hr))
    {
        return hr;
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_IAUTOEFFECTBVR_TYPE);
}

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::get_type( VARIANT *pVal )
{
	return VariantCopy( pVal, &m_type );
}

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::put_cause( VARIANT newVal )
{
    HRESULT hr = VariantCopy( &m_cause, &newVal );
    if (FAILED(hr))
    {
        return hr;
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_IAUTOEFFECTBVR_CAUSE);
}

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::get_cause( VARIANT *pVal )
{
	return VariantCopy( pVal, &m_cause );
}

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::put_span( VARIANT newVal )
{
    HRESULT hr = VariantCopy( &m_span, &newVal );
    if (FAILED(hr))
    {
        return hr;
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_IAUTOEFFECTBVR_SPAN);
}

//*****************************************************************************

STDMETHODIMP 
CAutoEffectBvr::get_span( VARIANT *pVal )
{
	return VariantCopy( pVal, &m_span );
}

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::put_size( VARIANT newVal )
{
    HRESULT hr = VariantCopy( &m_size, &newVal );
    if (FAILED(hr))
    {
        return hr;
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_IAUTOEFFECTBVR_SIZE);
}

//*****************************************************************************

STDMETHODIMP 
CAutoEffectBvr::get_size( VARIANT *pVal )
{
	return VariantCopy( pVal, &m_size );
}

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::put_rate( VARIANT newVal )
{
    HRESULT hr = VariantCopy( &m_rate, &newVal );
    if (FAILED(hr))
    {
        return hr;
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_IAUTOEFFECTBVR_RATE);
}

//*****************************************************************************

STDMETHODIMP 
CAutoEffectBvr::get_rate( VARIANT *pVal )
{
	return VariantCopy( pVal, &m_rate );
}

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::put_gravity( VARIANT newVal )
{
    HRESULT hr = VariantCopy( &m_gravity, &newVal );
    if (FAILED(hr))
    {
        return hr;
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_IAUTOEFFECTBVR_GRAVITY);
}

//*****************************************************************************

STDMETHODIMP 
CAutoEffectBvr::get_gravity( VARIANT *pVal )
{
	return VariantCopy( pVal, &m_gravity );
}

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::put_wind( VARIANT newVal )
{
    HRESULT hr = VariantCopy( &m_wind, &newVal );
    if (FAILED(hr))
    {
        return hr;
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_IAUTOEFFECTBVR_WIND);
}

//*****************************************************************************

STDMETHODIMP 
CAutoEffectBvr::get_wind( VARIANT *pVal )
{
	return VariantCopy( pVal, &m_wind );
}

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::put_fillColor( VARIANT newVal )
{
    HRESULT hr = VariantCopy( &m_fillColor, &newVal );
    if (FAILED(hr))
    {
        return hr;
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_IAUTOEFFECTBVR_FILLCOLOR);
}

//*****************************************************************************

STDMETHODIMP 
CAutoEffectBvr::get_fillColor( VARIANT *pVal )
{
	return VariantCopy( pVal, &m_fillColor );
}

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::put_strokeColor( VARIANT newVal )
{
    HRESULT hr = VariantCopy( &m_strokeColor, &newVal );
    if (FAILED(hr))
    {
        return hr;
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_IAUTOEFFECTBVR_STROKECOLOR);
}

//*****************************************************************************

STDMETHODIMP 
CAutoEffectBvr::get_strokeColor( VARIANT *pVal )
{
	return VariantCopy( pVal, &m_strokeColor );
}

//*****************************************************************************

STDMETHODIMP
CAutoEffectBvr::put_opacity( VARIANT newVal )
{
    HRESULT hr = VariantCopy( &m_opacity, &newVal );
    if (FAILED(hr))
    {
        return hr;
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_IAUTOEFFECTBVR_OPACITY);
}

//*****************************************************************************

STDMETHODIMP 
CAutoEffectBvr::get_opacity( VARIANT *pVal )
{
	return VariantCopy( pVal, &m_opacity );
}

//*****************************************************************************

STDMETHODIMP 
CAutoEffectBvr::mouseEvent(long x, 
						   long y, 
						   VARIANT_BOOL bMove,
						   VARIANT_BOOL bUp,
						   VARIANT_BOOL bShift, 
						   VARIANT_BOOL bAlt,
						   VARIANT_BOOL bCtrl,
						   long lButton)
{
	// Determine position & dimensions of our "canvas"
	CComPtr<IHTMLElement>	pElement;
	long					lWidth, lHeight;
	HRESULT					hr;
	
	hr = GetElementToAnimate( &pElement );
	LMRETURNIFFAILED(hr);

	hr = pElement->get_offsetWidth( &lWidth );
	LMRETURNIFFAILED(hr);
	hr = pElement->get_offsetHeight( &lHeight );
	LMRETURNIFFAILED(hr);

	// DA origin is at the center of the element, and Y goes up
	x -= lWidth/2;
	y = (lHeight/2) - y;
	
	// Mouse down
	if ( !bMove && !bUp && ( lButton == MK_LBUTTON ) )
	{
		if ( m_eCause == CAUSE_MOUSEDOWN )
		{
			PossiblyAddSpark( m_dLocalTime, x, y );
		}
	}
	// Mouse is moving
	else if ( bMove && !bUp )
	{
		// Mouse being dragged?
		if ( ( m_eCause == CAUSE_DRAGOVER ) && ( lButton == MK_LBUTTON ) )
		{
			PossiblyAddSpark( m_dLocalTime, x, y );
		}
		// Mouse being moved only?
		else if ( ( m_eCause == CAUSE_MOUSEMOVE ) && ( lButton == 0 ) )
		{
			PossiblyAddSpark( m_dLocalTime, x, y );
		}
	}
	
	return S_OK;
}

//*****************************************************************************

HRESULT
CAutoEffectBvr::RemoveFragment()
{
	HRESULT hr = S_OK;
	
	if( m_pdispActor != NULL && m_lCookie != 0 )
	{
		hr  = RemoveBehaviorFromActor( m_pdispActor, m_lCookie );
		m_lCookie = 0;
		CheckHR( hr, "Failed to remove a fragment from the actor", end );
	}

end:

	return hr;
}

//**********************************************************************

double CSpark::Age( double dDeltaTime )
{
	m_dAge += dDeltaTime;
	return m_dAge;
}

//**********************************************************************

HRESULT CSpark::Kill( IDABehavior * in_pDeadBvr )
{
	if ( !IsAlive() ) return S_FALSE;

	m_fAlive = false;

	return m_pModifiableBvr->SwitchTo( in_pDeadBvr );
}

//**********************************************************************

HRESULT CSpark::Reincarnate( IDABehavior * in_pNewBvr, double in_dAge )
{
	m_fAlive	= true;
	m_dAge		= in_dAge;

	return m_pModifiableBvr->SwitchTo( in_pNewBvr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\behaviors\avoidfollow.cpp ===
//*****************************************************************************
//
// File:            avoidFollow.cpp
// Author:          kurtj
// Date Created:    11/6/98
//
// Abstract: Implementation of the Liquid Motion avoid follow behavior as
//           a DHTML behavior.
//
//
//Change Log:
//11-06-98  kurtj   Created
//11-11-98  kurtj   Fleshed out.
//*****************************************************************************

#include "headers.h" 

#include "avoidfollow.h"
#include "lmattrib.h"
#include "..\chrome\include\utils.h"

#undef THIS
#define THIS CAvoidFollowBvr
#define SUPER CBaseBehavior

#include "..\chrome\src\pbagimp.cpp"


#define DEFAULT_RADIUS 400.0

#define VAR_RADIUS 0
#define VAR_TARGET 1
#define VAR_VELOCITY 2

WCHAR * CAvoidFollowBvr::m_rgPropNames[] = {
                                             BEHAVIOR_PROPERTY_RADIUS,
                                             BEHAVIOR_PROPERTY_TARGET,
                                             BEHAVIOR_PROPERTY_VELOCITY
                                           };


//*****************************************************************************
//CAvoidFollowBvr
//*****************************************************************************



CAvoidFollowBvr::CAvoidFollowBvr(): m_sampler( NULL ),
									m_targetType(targetInvalid),
									m_timeDelta(0.0),
									m_pElement( NULL ),
									m_pAnimatedElement( NULL ),
									m_pAnimatedElement2( NULL ),
									m_pTargetElement2( NULL ),
									m_pWindow3(NULL),
									m_currentX( 0.0 ),
									m_currentY( 0.0 ),
									m_lastSampleTime( 0.0 ),
									m_dRadius( 0.0 ),
									m_dVelocity( 0.0 ),
									m_screenLeft( 0 ),
									m_screenTop( 0 ),
									m_sourceLeft( 0 ),
									m_sourceTop( 0 ),
									m_targetLeft( 0 ),
									m_targetTop( 0 ),
									m_topBvr( NULL ),
									m_leftBvr( NULL ),
									m_pBody2( NULL ),
                                    m_originalX( 0 ),
                                    m_originalY( 0 ),
                                    m_originalLeft( 0 ),
                                    m_originalTop( 0 ),
									m_targetClientLeft( 0 ),
									m_targetClientTop( 0 )
{
    VariantInit( &m_radius );
    VariantInit( &m_target );
    VariantInit( &m_velocity );
    
    m_sampler = new CSampler( SampleOnBvr, reinterpret_cast<void*>(this) );
} // CAvoidFollowBvr

//*****************************************************************************

CAvoidFollowBvr::~CAvoidFollowBvr()
{
    VariantClear( &m_radius );
    VariantClear( &m_target );
    VariantClear( &m_velocity );

	ReleaseInterface( m_leftBvr );
	ReleaseInterface( m_topBvr );

    if( m_sampler != NULL )
	{
        m_sampler->Invalidate();
		m_sampler = NULL;
	}
} // ~CAvoidFollowBvr

//*****************************************************************************

HRESULT 
CAvoidFollowBvr::FinalConstruct()
{

    HRESULT hr = SUPER::FinalConstruct();
    if (FAILED(hr))
    {
        DPF_ERR("Error in move behavior FinalConstruct initializing base classes");
        return hr;
    }
    return S_OK;
} // FinalConstruct

//*****************************************************************************

STDMETHODIMP 
CAvoidFollowBvr::Init(IElementBehaviorSite *pBehaviorSite)
{
	HRESULT hr = SUPER::Init(pBehaviorSite);

	hr = pBehaviorSite->GetElement( &m_pElement );

	return hr;
} // Init

//*****************************************************************************

VARIANT *
CAvoidFollowBvr::VariantFromIndex(ULONG iIndex)
{
    DASSERT(iIndex < NUM_AVOIDFOLLOW_PROPS);
    switch (iIndex)
    {
    case VAR_RADIUS:
        return &m_radius;
        break;
    case VAR_TARGET:
        return &m_target;
        break;
    case VAR_VELOCITY:
        return &m_velocity;
        break;
    default:
        // We should never get here
        DASSERT(false);
        return NULL;
    }
} // VariantFromIndex

//*****************************************************************************

HRESULT 
CAvoidFollowBvr::GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropNames)
{
    *pulProperties = NUM_AVOIDFOLLOW_PROPS;
    *pppPropNames = m_rgPropNames;
    return S_OK;
} // GetPropertyBagInfo

//*****************************************************************************

STDMETHODIMP 
CAvoidFollowBvr::Notify(LONG event, VARIANT *pVar)
{
	return SUPER::Notify(event, pVar);
} // Notify

//*****************************************************************************

STDMETHODIMP
CAvoidFollowBvr::Detach()
{
    if( m_sampler != NULL )
	{
        m_sampler->Invalidate();
		m_sampler = NULL;
	}

	ReleaseDAInterfaces();
	ReleaseTridentInterfaces();

	return SUPER::Detach();
} // Detach 

//*****************************************************************************

void
CAvoidFollowBvr::ReleaseTridentInterfaces()
{
	ReleaseInterface( m_pElement );
	ReleaseInterface( m_pAnimatedElement );
	ReleaseInterface( m_pAnimatedElement2 );
	ReleaseInterface( m_pTargetElement2);
	ReleaseInterface( m_pWindow3 );
	ReleaseInterface( m_pBody2 );
}

//*****************************************************************************

void
CAvoidFollowBvr::ReleaseDAInterfaces()
{
	ReleaseInterface( m_leftBvr );
	ReleaseInterface( m_topBvr );
}

//*****************************************************************************

HRESULT
CAvoidFollowBvr::FindTargetElement()
{
	if( m_pElement == NULL )
		return E_FAIL;
	HRESULT hr = E_FAIL;

	//make sure that the target variant is a bstr and valid.
	hr = CUtils::InsurePropertyVariantAsBSTR( &m_velocity );

	if( FAILED( hr ) )
	{
		DPF_ERR("Could not ensure that the target property was a bstr");
		goto cleanup;
	}

	//get the IDispatch of the document from our element
	IDispatch *pdispDocument;
	hr = m_pElement->get_document( &pdispDocument );

	CheckHR( hr, "Failed to get the IDispatch of the document from the element", cleanup );

	//query the IDispatch returned for IHTMLDocument2
	IHTMLDocument2 *pdoc2Document;
	hr = pdispDocument->QueryInterface( IID_TO_PPV( IHTMLDocument2, &pdoc2Document ) );
	ReleaseInterface( pdispDocument );
	CheckHR( hr, "failed to qi dispatch from get_document for IHTMLDocument2", cleanup );

	//call get_all on the pointer to IHTMLDocument2 getting an IHTMLElementCollection
	IHTMLElementCollection *pelmcolAll;
	hr = pdoc2Document->get_all( &pelmcolAll );
	ReleaseInterface( pdoc2Document );
	CheckHR( hr, "failed to get the all collection from the document", cleanup );
	
	//create a variant which is the index we want if more than one element has the same name (0)
	VARIANT varIndex;
	VariantInit( &varIndex );
	V_VT(&varIndex) = VT_I4;
	V_I4(&varIndex) = 0;

	IDispatch *pdispTarget;

	//call item on the IHTMLElementCollection using our target variant as the name to get
	//  getting back the IDispatch of the element
	hr = pelmcolAll->item( m_target, varIndex, &pdispTarget );
	ReleaseInterface( pelmcolAll );
	VariantClear( &varIndex );
	CheckHR( hr, "failed to get the target from the all collection", cleanup );

	if( pdispTarget == NULL )
	{
		hr = E_FAIL;
		goto cleanup;
	}

	//Query the Element returned for IHTMLElement2 setting m_pTargetElement2
	hr = pdispTarget->QueryInterface( IID_TO_PPV( IHTMLElement2, &m_pTargetElement2 ) );
	ReleaseInterface(pdispTarget);
	CheckHR( hr, "failed to get IHTMLElement2 from the dispatch returned by item", cleanup );

cleanup:

	return hr;
}

//*****************************************************************************

bool
CAvoidFollowBvr::IsTargetPosLegal()
{
	if( m_targetType != targetMouse )
		return true;

	if( m_pBody2 == NULL )
		CacheBody2();

	if( m_pBody2 != NULL )
	{
		HRESULT hr;

		long width = 0;
		long height = 0;

		hr = GetElementClientDimension( m_pBody2, &width, &height );
		CheckHR( hr, "Failed to get the dimension of the body", done );

		return  ( ( m_targetClientLeft >= 0 && m_targetClientLeft <= width ) && 
				  ( m_targetClientTop >=0 && m_targetClientTop <= height ) );

	}
done:
	return false;
}

//*****************************************************************************

bool
CAvoidFollowBvr::IsElementAbsolute( IHTMLElement2 *pElement2 )
{
	HRESULT hr = E_FAIL;

	BSTR position = NULL;

	IHTMLCurrentStyle *pCurrentStyle;
	hr = pElement2->get_currentStyle( &pCurrentStyle );
	CheckHR( hr, "Failed to get the current style from pElement2", cleanup );
	CheckPtr( pCurrentStyle, hr, E_FAIL, "Pointer returned from get_currentStyle was null", cleanup );

	hr = pCurrentStyle->get_position( &position );
	ReleaseInterface( pCurrentStyle );
	CheckHR( hr, "Failed to get the position from the currentStyle", cleanup );

	if( position != NULL && _wcsicmp( position, L"absolute" ) == 0 )
		return true;

	SysFreeString( position );

cleanup:
		return false;
}


//*****************************************************************************


HRESULT
CAvoidFollowBvr::MapToLocal( long *pX, long *pY )
{
    if( pX == NULL || pY == NULL )
        return E_INVALIDARG;

    if( m_pAnimatedElement == NULL )
        return E_FAIL;

    HRESULT hr = E_FAIL;
    
    IHTMLElement *pelemNext = NULL;
    IHTMLElement *pelemCur = NULL;

	long curX = 0;
	long curY = 0;

    hr = m_pAnimatedElement->get_offsetParent( &pelemCur );
    CheckHR( hr, "Failed to get the offset Parent of the animated element", cleanup );

    while( pelemCur != NULL )
    {

		hr = pelemCur->get_offsetLeft( &curX );
		CheckHR( hr, "Could not get the offset left from the current element", cleanup );

		hr = pelemCur->get_offsetTop( &curY );
		CheckHR( hr, "Could not get offsetTop from the current element", cleanup );

		(*pX) -= curX;
		(*pY) -= curY;

        hr = pelemCur->get_offsetParent( &pelemNext );
        CheckHR( hr, "Failed to get the offset parent of the current element", cleanup );

        ReleaseInterface( pelemCur );

        pelemCur = pelemNext;
        pelemNext = NULL;

    }

	//in some cases trident forgets that the body has a position of 2, 2
	(*pX) -=2;
	(*pY) -=2;

cleanup:

    ReleaseInterface( pelemCur );

    return hr;
}

//*****************************************************************************

HRESULT
CAvoidFollowBvr::UpdateSourcePos()
{
	if( m_pAnimatedElement == NULL || m_pAnimatedElement2 == NULL )
		return E_FAIL;

    HRESULT hr = E_FAIL;

    hr = m_pAnimatedElement->get_offsetLeft( &m_sourceLeft );
	CheckHR( hr, "failed to get the offset Left of the target element", cleanup );

    hr = m_pAnimatedElement->get_offsetTop( &m_sourceTop );
	CheckHR( hr, "failed to get the offset Top of the target element", cleanup );

	long width;
	long height;

	//offset for the center of the element;
	hr = GetElementClientDimension( m_pAnimatedElement2, &width, &height );
	CheckHR( hr, "failed to get the element's client dimension", cleanup );

	m_sourceLeft += width/2;
	m_sourceTop +=height/2;


cleanup:
    return hr;
}

//*****************************************************************************

HRESULT
CAvoidFollowBvr::UpdateTargetPos( )
{

	HRESULT hr = E_FAIL;

	//if the target is an element ( not the mouse )
	if( m_targetType == targetElement )
	{
		//get the target element
		if( m_pTargetElement2 == NULL )
		{
			hr = FindTargetElement();
			CheckHR( hr, "failed to find the target element", cleanup );
		}
		//get the position of the target element
		hr = GetElementClientPosition( m_pTargetElement2, &m_targetLeft, &m_targetTop );
		CheckHR( hr, "failed to get the client position of the target element", cleanup );
	} 
	else if( m_targetType == targetMouse ) //else the target is the mouse pointer
	{
		//get the top left offset of the trident window
		hr = UpdateWindowTopLeft();  
		//if we got the top left of the window
		if( SUCCEEDED( hr ) )
		{
			
			//get the mouse position
			POINT mousePos;
			mousePos.x = mousePos.y = 0;
			GetCursorPos( &mousePos ); 
			//translate the mouse position into trident window space
			m_targetLeft = mousePos.x - m_screenLeft;
			m_targetTop = mousePos.y - m_screenTop;
			m_targetClientLeft = m_targetLeft;
			m_targetClientTop = m_targetTop;

		}
	}else //else target is unknown return an error
	{
		hr = E_FAIL;
	}

	hr = MapToLocal( &m_targetLeft, &m_targetTop );
	CheckHR( hr, "failed to map the target Position into local space", cleanup );

cleanup:

	return hr;
}

//*****************************************************************************

HRESULT
CAvoidFollowBvr::CacheWindow3()
{
	HRESULT hr = E_FAIL;

	if( m_pWindow3 != NULL )
		ReleaseInterface( m_pWindow3 );

	if( m_pElement == NULL )
	{
		return E_FAIL;
	}

	IDispatch *pDocumentDispatch;
	hr = m_pElement->get_document( &pDocumentDispatch );
	if( SUCCEEDED( hr ) )
	{
		IHTMLDocument2 *pDocument2;
		hr = pDocumentDispatch->QueryInterface( IID_TO_PPV( IHTMLDocument2, &pDocument2 ) );
		ReleaseInterface( pDocumentDispatch );
		if( SUCCEEDED( hr ) )
		{
			IHTMLWindow2 *pWindow2;
			hr = pDocument2->get_parentWindow( &pWindow2 );
			ReleaseInterface( pDocument2 );
			if( SUCCEEDED( hr ) )
			{
				IHTMLWindow3 *pWindow3;
				hr = pWindow2->QueryInterface( IID_TO_PPV( IHTMLWindow3, &pWindow3 ) );
				ReleaseInterface( pWindow2 );
				if( SUCCEEDED( hr ) )
				{
					m_pWindow3 = pWindow3;
					hr = S_OK;
				}
				else  //QI failed for IHTMLWindow3 on IHTMLWindow2
				{
					DPF_ERR( "AvoidFollow: QI for IHTMLWindow3 on IHTMLWindow2 failed" );
				}
			}
			else //getParentWindow on IHTMLDocument2 failed
			{
				DPF_ERR( "AvoidFollow: getParentWindow on IHTMLDocument2 failed" );
			}
		}
		else  //QI for IHTMLDocument2 on IHTMLDocument failed
		{
			DPF_ERR( "AvoidFollow: QI for IHTMLDocument2 on IHTMLDocument failed" );
		}
	}
	else  //failed to get the document from the animated element
	{
		DPF_ERR( "AvoidFollow: failed to get the document from the animated element" );
	}

	return hr;
}

//*****************************************************************************

HRESULT
CAvoidFollowBvr::CacheBody2()
{
	if( m_pElement == NULL )
		return E_FAIL;

	if( m_pBody2 != NULL )
		ReleaseInterface( m_pBody2 );

	HRESULT hr = E_FAIL;


	IDispatch *pdispDocument;
	hr = m_pElement->get_document( &pdispDocument );
	CheckHR( hr, "failed to get the document from element", cleanup );

	CheckPtr( pdispDocument, hr, E_FAIL, "pointer returned from get_document was null", cleanup );

	IHTMLDocument2 *pdoc2Document;
	hr = pdispDocument->QueryInterface( IID_TO_PPV( IHTMLDocument2, &pdoc2Document ) );
	ReleaseInterface( pdispDocument );
	CheckHR( hr, "Failed to get IHTMLDocument 2 from the document dispatch", cleanup );

	IHTMLElement *pelemBody;
	hr = pdoc2Document->get_body( &pelemBody );
	ReleaseInterface( pdoc2Document );
	CheckHR( hr, "Failed to get the body from the document", cleanup );
	CheckPtr( pelemBody, hr, E_FAIL, "Body returned from get_body was null", cleanup );

	hr = pelemBody->QueryInterface( IID_TO_PPV( IHTMLElement2, &m_pBody2 ) );
	ReleaseInterface( pelemBody );
	CheckHR( hr, "Failed to get IHTMLElement2 from the body element", cleanup );


cleanup:
	return hr;

}

//*****************************************************************************

HRESULT
CAvoidFollowBvr::UpdateWindowTopLeft( )
{
	HRESULT hr = E_FAIL;

	if( m_pWindow3 == NULL )
		CacheWindow3();
	
	if( m_pWindow3 != NULL )
	{
		hr = m_pWindow3->get_screenLeft( &m_screenLeft );
		if( SUCCEEDED( hr ) )
		{
			hr = m_pWindow3->get_screenTop( &m_screenTop );
			if( FAILED( hr ) )//failed to get screen top from IHTMLWindow3
			{
				DPF_ERR( "AvoidFollow: could not get screen top from IHTMLWindow3" );
			}
		}
		else //failed to get left from window3 
		{
			DPF_ERR( "AvoidFollow: could not get screen left from IHTMLWindow3" );
		}
	}
	else  //Could not Cache IHTMLWindow3
	{
		DPF_ERR( "AvoidFollow: Could not Cache IHTMLWindow3" );
		hr = E_FAIL;
	}

	return hr;
}

//*****************************************************************************

HRESULT
CAvoidFollowBvr::GetElementClientPosition( IHTMLElement2 *pElement2, long *pLeft, long* pTop )
{
	if( pElement2 == NULL || pLeft == NULL || pTop == NULL )
		return E_INVALIDARG;

	HRESULT hr = E_FAIL;

	IHTMLRect *prectBBox = NULL;

	hr = pElement2->getBoundingClientRect( &prectBBox );
	CheckHR( hr, "failed to get the bounding client rect of the element", cleanup );
	CheckPtr( prectBBox, hr, E_FAIL, "pointer returned from getBounding ClientRect was NULL", cleanup );

	//get the top and left from the IHTMLRect
	hr = prectBBox->get_left( pLeft );
	CheckHR( hr, "failed to get the left coordiante of the bbox", cleanup );

	hr = prectBBox->get_top( pTop );
	CheckHR( hr, "failed to get the top coordiante of the bbox", cleanup );

cleanup:

	if( FAILED( hr ) )
	{
		(*pLeft) = 0;
		(*pTop) = 0;
	}

	ReleaseInterface( prectBBox );

	return hr;
}

//*****************************************************************************

HRESULT
CAvoidFollowBvr::GetElementClientDimension( IHTMLElement2 *pElement2, long *pWidth, long* pHeight )
{
	if( pElement2 == NULL || pWidth == NULL || pHeight == NULL )
		return E_INVALIDARG;


    HRESULT hr = E_FAIL;


    long left = 0;
    long top = 0;
    long right =0;
    long bottom = 0;

    IHTMLRect *prectBBox = NULL;
	hr = pElement2->getBoundingClientRect( &prectBBox );
	CheckHR( hr, "failed to get the bounding client rect of the element", cleanup );
	CheckPtr( prectBBox, hr, E_FAIL, "pointer returned from getBounding ClientRect was NULL", cleanup );

	//get the top and left from the IHTMLRect

	hr = prectBBox->get_left( &left );
	CheckHR( hr, "failed to get the left of the bbox", cleanup );

	hr = prectBBox->get_top( &top );
	CheckHR( hr, "failed to get the top of the bbox", cleanup );

    hr = prectBBox->get_right( &right );
	CheckHR( hr, "failed to get the right of the bbox", cleanup );

	hr = prectBBox->get_bottom( &bottom );
	CheckHR( hr, "failed to get the bottom of the bbox", cleanup );

    (*pWidth) = right - left;
    (*pHeight) = bottom - top;


cleanup:

	if( FAILED( hr ) )
	{
		(*pWidth) = 0;
		(*pHeight) = 0;
	}

    ReleaseInterface( prectBBox );

	return hr;
}
//*****************************************************************************


HRESULT
CAvoidFollowBvr::SetTargetType()
{
	HRESULT hr = E_FAIL;

	hr = CUtils::InsurePropertyVariantAsBSTR( &m_target );
	if( SUCCEEDED( hr ) )
	{
		if( V_BSTR(&m_target) == NULL  || 
			_wcsicmp( TARGET_MOUSE, V_BSTR(&m_target) ) == 0 )
		{
			m_targetType = targetMouse;
		}
		else
		{
			m_targetType = targetElement;
		}

	}
	else //failed to insure that the target property was a bstr
	{
		m_targetType = targetMouse;
		hr = S_OK;
	}

	return hr;

}

//*****************************************************************************

HRESULT 
CAvoidFollowBvr::BuildAnimationAsDABehavior()
{
	return S_OK;
} // BuildAnimationAsDABehavior


//*****************************************************************************


HRESULT
CAvoidFollowBvr::SampleOnBvr(void *thisPtr,
							 double startTime,
							 double globalNow,
							 double localNow,
							 IDABehavior * sampleVal)
{
	return reinterpret_cast<CAvoidFollowBvr*>(thisPtr)->Sample( startTime, 
															   globalNow, 
															   localNow, 
															   sampleVal );
}


//*****************************************************************************

HRESULT
CAvoidFollowBvr::Sample( double startTime, double globalNow, double localNow, IDABehavior *sampleVal )
{
	HRESULT hr = E_FAIL;

	VARIANT_BOOL on = VARIANT_FALSE;

	IDABoolean *pdaboolSample;
	hr = sampleVal->QueryInterface( IID_TO_PPV( IDABoolean, &pdaboolSample) );
	if( FAILED( hr ) )
		return S_OK;

	hr = pdaboolSample->Extract( &on );
	ReleaseInterface( pdaboolSample );
	if( FAILED ( hr ) )
		return S_OK;

	//if we are not on, there is nothing to do.
	if( on == VARIANT_FALSE)
		return S_OK;

	//if we just turned on set the last sample time.
	if( on != m_lastOn )
		m_lastSampleTime = globalNow;

	m_lastOn = on;

	m_timeDelta = globalNow - m_lastSampleTime;
	m_lastSampleTime = globalNow;

	if( m_timeDelta == 0.0 )
		return S_OK;
	
	if( m_timeDelta < 0 )
		m_timeDelta = -m_timeDelta;

	hr = UpdateTargetPos();
	if( FAILED( hr ) )
		return S_OK;

	if( !IsTargetPosLegal() )
		return S_OK;

	hr = UpdateSourcePos();

	if( FAILED( hr ) )
		return S_OK;
    


    //ensure that the translation that we applied has taken effect
    //TODO: this does not account for transforms applied by other behaviors.
	//  currently this is okay since this is an absolute behavior.
    if( m_originalX + m_currentX != m_sourceLeft ||
        m_originalY + m_currentY != m_sourceTop )
        return S_OK;

	double xToTarget = m_targetLeft-m_sourceLeft;
	double yToTarget = m_targetTop-m_sourceTop;//y is inverted

	double distanceToTarget = sqrt( (xToTarget*xToTarget) + (yToTarget*yToTarget) );
	
	if( distanceToTarget > m_dRadius || distanceToTarget == 0)
		//bail, the target is beyond our sensitive radius
		return S_OK;

	double xMove = xToTarget;
	double yMove = yToTarget;

	double totalMove = m_timeDelta * m_dVelocity;

	//if we are following and we have reached the target in this step
	if( distanceToTarget > totalMove )
	{
		xMove *= totalMove/distanceToTarget;
        yMove *= totalMove/distanceToTarget;
	}


	m_currentX += static_cast<long>( xMove );
	m_currentY += static_cast<long>( yMove );

	hr = m_leftBvr->SwitchToNumber(  m_originalLeft + m_currentX );
	if( FAILED( hr ) )
	{
		DPF_ERR("failed to switch in the left bvr" );
	}
	hr = m_topBvr->SwitchToNumber(  m_originalTop + m_currentY );
	if( FAILED( hr ) )
	{
		DPF_ERR( "failed to switch in the top bvr" );
	}

    return S_OK;
}

//*****************************************************************************
//ILMAvoidFollowBvr
//*****************************************************************************

STDMETHODIMP
CAvoidFollowBvr::put_animates( VARIANT varAnimates )
{
    return SUPER::SetAnimatesProperty( varAnimates );
}

//*****************************************************************************

STDMETHODIMP
CAvoidFollowBvr::get_animates( VARIANT *varAnimates )
{
    return SUPER::GetAnimatesProperty( varAnimates );
}

//*****************************************************************************

STDMETHODIMP
CAvoidFollowBvr::put_radius( VARIANT varRadius )
{
    return VariantCopy( &m_radius, &varRadius );
}

//*****************************************************************************

STDMETHODIMP
CAvoidFollowBvr::get_radius( VARIANT *varRadius )
{
    return VariantCopy( varRadius, &m_radius );
}

//*****************************************************************************

STDMETHODIMP
CAvoidFollowBvr::put_target( VARIANT varTarget )
{
    return VariantCopy( &m_target, &varTarget );
}

//*****************************************************************************

STDMETHODIMP
CAvoidFollowBvr::get_target( VARIANT *varTarget )
{
    return VariantCopy( varTarget, &m_target );
}

//*****************************************************************************

STDMETHODIMP
CAvoidFollowBvr::put_velocity( VARIANT varVelocity )
{
    return VariantCopy( &m_velocity, &varVelocity );
}

//*****************************************************************************

STDMETHODIMP 
CAvoidFollowBvr::get_velocity( VARIANT *varVelocity )
{
    return VariantCopy( varVelocity, &m_velocity );
}

//*****************************************************************************
STDMETHODIMP
CAvoidFollowBvr::buildBehaviorFragments( IDispatch *pActorDisp )
{
	if( pActorDisp == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	m_lastOn = VARIANT_FALSE;		

	IDA2Statics *statics = GetDAStatics();
	IDATransform2 *transform = NULL;

	hr = GetElementToAnimate( &m_pAnimatedElement );
	CheckHR( hr, "Failed to get the animated element", cleanup );

	hr = m_pAnimatedElement->QueryInterface( IID_TO_PPV( IHTMLElement2, &m_pAnimatedElement2 ) );
	CheckHR( hr, "Failed to query the animatedElement for IHTMLElement2", cleanup );

	hr = SetTargetType();
	CheckHR( hr, "Failed to set the target type", cleanup );


	hr = UpdateTargetPos();
	CheckHR( hr, "Failed to update the target Position", cleanup );

    hr = UpdateSourcePos();
    CheckHR( hr, "Failed to update the source position", cleanup );

    m_originalX = m_sourceLeft;
    m_originalY = m_sourceTop;

    if( IsElementAbsolute( m_pAnimatedElement2 ) )
	{
		hr= m_pAnimatedElement->get_offsetLeft( &m_originalLeft );
		CheckHR( hr, "Failed to get the original Left", cleanup );

		hr = m_pAnimatedElement->get_offsetTop( &m_originalTop );
		CheckHR( hr, "Failed to get the original Top", cleanup );
	}
	else
	{
		m_originalLeft = 0;
		m_originalTop = 0;
	}

	hr = CUtils::InsurePropertyVariantAsFloat( &m_radius );
	if( SUCCEEDED( hr ) )
	{
		m_dRadius = static_cast<double>(V_R4(&m_radius));
	}
	else
	{
		m_dRadius = DEFAULT_RADIUS;
	}

	hr = CUtils::InsurePropertyVariantAsFloat( &m_velocity );
	if( SUCCEEDED( hr ) )
	{
		m_dVelocity = - (static_cast<double>(V_R4(&m_velocity)));
	}
	else
	{
		m_dVelocity = 10.0;
	}

	hr = statics->ModifiableNumber( m_originalLeft, &m_leftBvr );
	CheckHR( hr, "Failed to create a modifiable number for the left bvr", cleanup );

	hr = statics->ModifiableNumber( m_originalTop, &m_topBvr );
	CheckHR( hr, "Failed to create a modifiable number for the top bvr", cleanup );

	hr = statics->Translate2Anim( m_leftBvr, m_topBvr, &transform );
	CheckHR( hr, "Failed to create a translate2 behavior for the total translation", cleanup );

	hr = AttachBehaviorToActor( pActorDisp,
							transform, 
							L"Translation",
							e_Absolute,
							e_Translation );

	IDABoolean *onBvr;
	hr = GetTIMEBooleanBehavior( &onBvr );
	CheckHR( hr, "Failed to get the boolean behavior from time", cleanup );

	IDABehavior *hookedBehavior;
	hr = m_sampler->Attach( onBvr, &hookedBehavior );
	ReleaseInterface( onBvr );
	CheckHR( hr, "Failed to attach the sampler to the on behavior", cleanup );

	hr = AddBehaviorToTIME( hookedBehavior );
	ReleaseInterface( hookedBehavior );
	CheckHR( hr, "Failed to add the on behavior to TIME", cleanup );


cleanup:
	ReleaseInterface( transform );

    if( FAILED( hr ) )
    {
        ReleaseDAInterfaces();
        ReleaseTridentInterfaces();
    }

    return hr;
}

//*****************************************************************************
//End ILMAvoidFollowBvr
//*****************************************************************************

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\behaviors\jump.cpp ===
//*****************************************************************************
//
// Microsoft LiquidMotion
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    jump.cpp
//
// Author:	elainela
//
// Created:	11/11/98
//
// Abstract:    Implementation of the LM Jump Behavior.
//
//*****************************************************************************

#include "headers.h" 

#include "..\chrome\src\dautil.h"
#include "..\chrome\include\utils.h"
#include "jump.h"
#include "lmattrib.h"
#include "lmdefaults.h"

#undef THIS
#define THIS CJumpBvr
#define SUPER CBaseBehavior

#include "..\chrome\src\pbagimp.cpp"

static const WCHAR * const	SZ_RANGE_WINDOW		= L"window";
static const WCHAR * const	SZ_RANGE_PAGE		= L"page";

#define VAR_INTERVAL    0
#define VAR_RANGE       1

WCHAR * CJumpBvr::m_rgPropNames[] = {
                                     BEHAVIOR_PROPERTY_INTERVAL,
                                     BEHAVIOR_PROPERTY_RANGE
                                    };


//*****************************************************************************

CJumpBvr::CJumpBvr() :
	m_fOrigX( 0.0f ),
	m_fOrigY( 0.0f ),
	m_eTargetType( TARGET_NONE )
{
	m_pSampler		= new CSampler( this );
	
    VariantInit( &m_varInterval );
    VariantInit( &m_varRange );

	m_fFrequency 		= 0.0f;
	m_dLastUpdateCycle	= -1.0;
	
} // CJumpBvr

//*****************************************************************************

CJumpBvr::~CJumpBvr()
{
    VariantClear( &m_varInterval );
    VariantClear( &m_varRange );

	m_pSampler->Release();

} // ~CJumpBvr

//*****************************************************************************

HRESULT 
CJumpBvr::FinalConstruct()
{

    return SUPER::FinalConstruct();
} // FinalConstruct

//*****************************************************************************

VARIANT *
CJumpBvr::VariantFromIndex(ULONG iIndex)
{
    DASSERT(iIndex < NUM_JUMP_PROPS);
    switch (iIndex)
    {
    case VAR_INTERVAL:
        return &m_varInterval;
        break;
    case VAR_RANGE:
        return &m_varRange;
        break;
    default:
        // We should never get here
        DASSERT(false);
        return NULL;
    }
} // VariantFromIndex

//*****************************************************************************

HRESULT 
CJumpBvr::GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropNames)
{
    *pulProperties = NUM_JUMP_PROPS;
    *pppPropNames = m_rgPropNames;
    return S_OK;
} // GetPropertyBagInfo

//*****************************************************************************

STDMETHODIMP 
CJumpBvr::Init(IElementBehaviorSite *pBehaviorSite)
{
    return SUPER::Init(pBehaviorSite);
} // Init

//*****************************************************************************

STDMETHODIMP 
CJumpBvr::Notify(LONG event, VARIANT *pVar)
{
    return SUPER::Notify(event, pVar);
} // Notify

//*****************************************************************************

STDMETHODIMP
CJumpBvr::Detach()
{
    return SUPER::Detach();
} // Detach 

//*****************************************************************************

STDMETHODIMP
CJumpBvr::Sample( double dStart, double dGlobalNow, double dLocalNow )
{
	double	dCurrentCycle = ::floor( dLocalNow * m_fFrequency );
		
	if ( dCurrentCycle == m_dLastUpdateCycle )
		return S_OK;

	HRESULT	hr = S_OK;
	
	{
		m_dLastUpdateCycle = dCurrentCycle;

		float fMinX, fMaxX, fMinY, fMaxY;
		hr = GetJumpRanges( fMinX, fMaxX, fMinY, fMaxY );
		LMCLEANUPIFFAILED(hr);

		if ( fMinX != m_fBaseX )
		{
			m_fBaseX = fMinX;
			
			hr = m_pBvrModifBaseX->SwitchToNumber( m_fBaseX );
			LMCLEANUPIFFAILED(hr);
		}
		
		if ( fMaxX - fMinX != m_fRangeX )
		{
			m_fRangeX = fMaxX-fMinX;
			
			hr = m_pBvrModifRangeX->SwitchToNumber( m_fRangeX );
			LMCLEANUPIFFAILED(hr);
		}
		
		if ( fMinY != m_fBaseY )
		{
			m_fBaseY = fMinY;
			
			hr = m_pBvrModifBaseY->SwitchToNumber( m_fBaseY );
			LMCLEANUPIFFAILED(hr);
		}
		
		if ( fMaxY - fMinY != m_fRangeY )
		{
			m_fRangeY = fMaxY-fMinY;
			
			hr = m_pBvrModifRangeY->SwitchToNumber( m_fRangeY );
			LMCLEANUPIFFAILED(hr);
		}
	}
	
  cleanup:
	return hr;
}

//*****************************************************************************

HRESULT 
CJumpBvr::buildBehaviorFragments( IDispatch * pActorDisp )
{
    HRESULT hr = S_OK;

	{
		m_dLastUpdateCycle = -1.0;
		
		hr = GetInitialPosition( m_fOrigX, m_fOrigY );
		LMCLEANUPIFFAILED(hr);

		CComPtr<IDATransform2> pbvrTransform;
		hr = Build2DTransform(&pbvrTransform);
		LMCLEANUPIFFAILED(hr);

		// Sample it
		CComPtr<IDABehavior> pBvrSampled;

		hr = m_pSampler->Attach( pbvrTransform, &pBvrSampled );
		LMCLEANUPIFFAILED(hr);
	
		// REVIEW: Supporting only absolute
		hr = AttachBehaviorToActor( pActorDisp, pBvrSampled,
									CComBSTR( L"translation" ),
									e_Absolute,
									e_Translation );
		LMCLEANUPIFFAILED(hr);
	}
	
  cleanup:
    return S_OK;

} // BuildAnimationAsDABehavior

HRESULT
CJumpBvr::GetNumberModifiableBvr( float fNumber, IDAModifiableBehavior ** out_ppModifiable, IDANumber ** out_ppNumberModifiable )
{
	HRESULT		hr = S_OK;
	
	IDA2Statics * pStatics  = GetDAStatics();
	if ( pStatics == NULL ) return E_FAIL;

	{
		CComPtr<IDANumber>	pnum;

		hr = pStatics->ModifiableNumber( fNumber, out_ppNumberModifiable );
		LMCLEANUPIFFAILED(hr);

		hr = (*out_ppNumberModifiable)->QueryInterface( IID_IDAModifiableBehavior,
														(LPVOID *) out_ppModifiable );
		LMCLEANUPIFFAILED(hr);
	}
	
  cleanup:
	return hr;
}

//*****************************************************************************

HRESULT
CJumpBvr::GetRandomNumber( IDA2Statics 	*pStatics,
						   IDANumber   	*pnumBase,
						   IDANumber   	*pnumRange,
						   IDANumber **ppnumReturn )
{
    DASSERT( pDAStatics != NULL );
    DASSERT( ppnumReturn != NULL );
    *ppnumReturn = NULL;

    DASSERT( fMin != fMax );

    HRESULT hr = S_OK;

	{
		CComPtr<IDANumber> pnumRand;
		CComPtr<IDANumber> pnumMod;
		CComPtr<IDANumber> pnumRandMulRange;

		hr = pStatics->SeededRandom( rand(), &pnumRand );
		LMCLEANUPIFFAILED(hr);

		hr = pStatics->Mul( pnumRand, pnumRange, &pnumRandMulRange );
		LMCLEANUPIFFAILED(hr);

		hr = pStatics->Add( pnumRandMulRange, pnumBase, ppnumReturn );
		LMCLEANUPIFFAILED(hr);
	}

  cleanup:
    return hr;

} // GetRandomNumber

//*****************************************************************************

HRESULT 
CJumpBvr::GetJumpRanges( float& fMinX, float& fMaxX, float& fMinY, float& fMaxY )
{
	HRESULT	hr	= S_OK;

	{
		// First determine position & dimensions of element
		//----------------------------------------------------------------------
		CComPtr<IHTMLElement>   pElement;
		hr = GetElementToAnimate( &pElement );
		LMCLEANUPIFFAILED(hr);

		CComQIPtr<IHTMLElement2, &IID_IHTMLElement2> pElement2( pElement );
		LMRETURNIFNULL( pElement2 );

		CComPtr<IHTMLRect>	pRect;
		long				lBoundLeft, lBoundTop, lBoundRight, lBoundBottom;

		hr = pElement2->getBoundingClientRect( &pRect );
		LMCLEANUPIFFAILED(hr);

		pRect->get_left( &lBoundLeft );
		LMCLEANUPIFFAILED(hr);
		pRect->get_top( &lBoundTop );
		LMCLEANUPIFFAILED(hr);
		pRect->get_right( &lBoundRight );
		LMCLEANUPIFFAILED(hr);
		pRect->get_bottom( &lBoundBottom );
		LMCLEANUPIFFAILED(hr);

		CComPtr<IDispatch>		pDispDoc;
		hr = pElement->get_document( &pDispDoc );
		LMCLEANUPIFFAILED(hr);

		CComQIPtr<IHTMLDocument2, &IID_IHTMLDocument2> pDoc2( pDispDoc );
		LMRETURNIFNULL( pDoc2 );

		// Determine the range
		//----------------------------------------------------------------------
		long lRefLeft, lRefTop, lRefWidth, lRefHeight;

		CComPtr<IHTMLElement> pEltBody;
		hr = pDoc2->get_body( &pEltBody );
		LMCLEANUPIFFAILED(hr);

		CComQIPtr<IHTMLElement2, &IID_IHTMLElement2> pElt2Body( pEltBody );
		LMRETURNIFNULL( pElt2Body );

		// Range: Page
		//----------------------------------------------------------------------
		if ( m_eTargetType == TARGET_PAGE )
		{
			lRefLeft	= 0;
			lRefTop		= 0;

			hr = pElt2Body->get_scrollWidth( &lRefWidth );
			LMCLEANUPIFFAILED(hr);
			hr = pElt2Body->get_scrollHeight( &lRefHeight );
			LMCLEANUPIFFAILED(hr);
		}
		// Range: Window
		//----------------------------------------------------------------------
		else if ( m_eTargetType == TARGET_WINDOW )
		{
			hr = pElt2Body->get_clientLeft( &lRefLeft );
			LMCLEANUPIFFAILED(hr);
			hr = pElt2Body->get_clientTop( &lRefTop );
			LMCLEANUPIFFAILED(hr);
			hr = pElt2Body->get_clientWidth( &lRefWidth );
			LMCLEANUPIFFAILED(hr);
			hr = pElt2Body->get_clientHeight( &lRefHeight );
			LMCLEANUPIFFAILED(hr);
		}
		// Range: some element on the page
		//----------------------------------------------------------------------
		else if ( m_eTargetType == TARGET_ELEMENT )
		{
			CComPtr<IHTMLElementCollection> pEltColl;
			CComPtr<IDispatch> pDispReference;

			hr = pDoc2->get_all( &pEltColl );
			LMCLEANUPIFFAILED(hr);

			hr = pEltColl->item( m_varRange, CComVariant( 0L ), &pDispReference );
			LMCLEANUPIFFAILED(hr);
			LMRETURNIFNULL( pDispReference );

			if ( pDispReference == NULL ) return E_FAIL;
			CComQIPtr<IHTMLElement2, &IID_IHTMLElement2> pElt2Ref(pDispReference);
			LMRETURNIFNULL( pElt2Ref );

			hr = pElt2Ref->get_clientLeft( &lRefLeft );
			LMCLEANUPIFFAILED(hr);
			hr = pElt2Ref->get_clientTop( &lRefTop );
			LMCLEANUPIFFAILED(hr);
			hr = pElt2Ref->get_clientWidth( &lRefWidth );
			LMCLEANUPIFFAILED(hr);
			hr = pElt2Ref->get_clientHeight( &lRefHeight );
			LMCLEANUPIFFAILED(hr);

			// The area must be offset by position in the body
			CComPtr<IHTMLRect>	pRectRef;
			long				lBoundLeft, lBoundTop;

			hr = pElt2Ref->getBoundingClientRect( &pRectRef );
			LMCLEANUPIFFAILED(hr);
			hr = pRectRef->get_left( &lBoundLeft );
			LMCLEANUPIFFAILED(hr);
			hr = pRectRef->get_top( &lBoundTop );
			LMCLEANUPIFFAILED(hr);

			lRefLeft	+= lBoundLeft;
			lRefTop		+= lBoundTop;
		}
		else
		{
			return E_FAIL;
		}
		
		// Now compute the range behaviors
		//----------------------------------------------------------------------
		fMinX = (float) (lRefLeft - m_lOrigBoundingLeft);
		fMaxX = (float) (lRefLeft + lRefWidth -
						 (m_lOrigBoundingLeft+lBoundRight-lBoundLeft));
		
		fMinY = (float) (lRefTop - m_lOrigBoundingTop);
		fMaxY = (float) (lRefTop + lRefHeight -
						 (m_lOrigBoundingTop+lBoundBottom-lBoundTop));

		// REVIEW: do this only if offset is absolute
		fMinX += m_fOrigX;
		fMaxX += m_fOrigX;

		fMinY += m_fOrigY;
		fMaxY += m_fOrigY;
	}
	
  cleanup:
	return hr;
}

//*****************************************************************************

HRESULT 
CJumpBvr::BuildJumpRangeBehaviors( IDANumber ** ppnumJumpX, 
								   IDANumber ** ppnumJumpY )
{
	DASSERT( ppnumJumpX != NULL );
	DASSERT( ppnumJumpY != NULL );

	HRESULT	hr	= S_OK;

	{
		hr = CUtils::InsurePropertyVariantAsBSTR( &m_varRange );

		CComBSTR	bstrRange( DEFAULT_JUMPBVR_RANGE );
		if ( SUCCEEDED(hr) && ( V_VT( &m_varRange ) == VT_BSTR ) )
			bstrRange = V_BSTR( &m_varRange );

		if ( _wcsicmp( bstrRange, SZ_RANGE_PAGE ) == 0 )
		{
			m_eTargetType = TARGET_PAGE;
		}
		else if ( _wcsicmp( bstrRange, SZ_RANGE_WINDOW ) == 0 )
		{
			m_eTargetType = TARGET_WINDOW;
		}
		else
		{
			m_eTargetType = TARGET_ELEMENT;
		}

		// Get original bounding left & top
		//----------------------------------------------------------------------
		CComPtr<IHTMLElement>   pElement;
		hr = GetElementToAnimate( &pElement );
		LMCLEANUPIFFAILED(hr);

		CComQIPtr<IHTMLElement2, &IID_IHTMLElement2> pElement2( pElement );
		LMRETURNIFNULL( pElement2 );

		CComPtr<IHTMLRect>	pRect;
		long				lBoundRight, lBoundBottom;

		hr = pElement2->getBoundingClientRect( &pRect );
		LMCLEANUPIFFAILED(hr);

		pRect->get_left( &m_lOrigBoundingLeft );
		LMCLEANUPIFFAILED(hr);
		pRect->get_top( &m_lOrigBoundingTop );
		LMCLEANUPIFFAILED(hr);
		LMCLEANUPIFFAILED(hr);
		
		// Now build the range behaviors
		//----------------------------------------------------------------------
		float fMaxX, fMaxY;
		
		hr = GetJumpRanges( m_fBaseX, fMaxX, m_fBaseY, fMaxY );
		LMCLEANUPIFFAILED(hr);

		m_fRangeX = fMaxX - m_fBaseX;
		m_fRangeY = fMaxY - m_fBaseY;
		
		// Now get random numbers
		IDA2Statics * pStatics  = GetDAStatics();

		CComPtr<IDANumber> pBaseX;
		CComPtr<IDANumber> pRangeX;
		CComPtr<IDANumber> pBaseY;
		CComPtr<IDANumber> pRangeY;
		
		hr = GetNumberModifiableBvr( m_fBaseX, &m_pBvrModifBaseX, &pBaseX );
		LMCLEANUPIFFAILED(hr);
		hr = GetNumberModifiableBvr( m_fRangeX, &m_pBvrModifRangeX, &pRangeX );
		LMCLEANUPIFFAILED(hr);
		hr = GetNumberModifiableBvr( m_fBaseY, &m_pBvrModifBaseY, &pBaseY );
		LMCLEANUPIFFAILED(hr);
		hr = GetNumberModifiableBvr( m_fRangeY, &m_pBvrModifRangeY, &pRangeY );
		LMCLEANUPIFFAILED(hr);
		
		hr = GetRandomNumber( pStatics, pBaseX, pRangeX, ppnumJumpX );
		LMCLEANUPIFFAILED(hr);
		hr = GetRandomNumber( pStatics, pBaseY, pRangeY, ppnumJumpY );
		LMCLEANUPIFFAILED(hr);
	}
	
  cleanup:
	return hr;

} // BuildJumpRangeBehaviors

//*****************************************************************************

HRESULT 
CJumpBvr::Build2DTransform(IDATransform2 **ppbvrTransform)
{
    HRESULT hr  = S_OK;

	{
		// Check our parameters.
		//----------------------------------------------------------------------
		IDA2Statics * pStatics  = GetDAStatics();
		if ( pStatics == NULL ) return E_FAIL;

		DASSERT(ppbvrTransform != NULL);
		*ppbvrTransform = NULL;

		m_fFrequency = 1.0f/DEFAULT_JUMPBVR_INTERVAL;

		if ( ( V_VT( &m_varInterval ) != VT_EMPTY ) &&
			 ( V_VT( &m_varInterval ) != VT_NULL ) )
		{
			hr = CUtils::InsurePropertyVariantAsFloat( &m_varInterval );
			LMRETURNIFFAILED(hr);

			if ( V_R4( &m_varInterval ) <= 0.0f )
				return E_FAIL;
			
			m_fFrequency = 1/V_R4( &m_varInterval );
		}
		
		// Compute jump range
		//----------------------------------------------------------------------
		CComPtr<IDANumber> pnumJumpX;
		CComPtr<IDANumber> pnumJumpY;

		hr = BuildJumpRangeBehaviors( &pnumJumpX, &pnumJumpY );
		LMCLEANUPIFFAILED(hr);
	
		// Jump according to jump interval
		//----------------------------------------------------------------------
		CComPtr<IDANumber> pnumProgress;
		CComPtr<IDANumber> pnumFrequency;
		CComPtr<IDANumber> pnumProgressMulFrequency;
		CComPtr<IDANumber> pnumStepTime;

		hr = pStatics->get_LocalTime( &pnumProgress );
		LMCLEANUPIFFAILED(hr);
		hr = CDAUtils::GetDANumber( pStatics, m_fFrequency, &pnumFrequency );
		LMCLEANUPIFFAILED(hr);
		hr = pStatics->Mul( pnumProgress, pnumFrequency, &pnumProgressMulFrequency );
		LMCLEANUPIFFAILED(hr);
		hr = pStatics->Floor( pnumProgressMulFrequency, &pnumStepTime );
		LMCLEANUPIFFAILED(hr);

		CComPtr<IDABehavior> pbvrJumpXStep;
		CComPtr<IDABehavior> pbvrJumpYStep;
		hr = pnumJumpX->SubstituteTime( pnumStepTime, &pbvrJumpXStep );
		LMCLEANUPIFFAILED(hr);
		hr = pnumJumpY->SubstituteTime( pnumStepTime, &pbvrJumpYStep );
		LMCLEANUPIFFAILED(hr);

		CComQIPtr<IDANumber, &IID_IDANumber> pnumJumpXStep( pbvrJumpXStep );
		CComQIPtr<IDANumber, &IID_IDANumber> pnumJumpYStep( pbvrJumpYStep );

		hr = CDAUtils::BuildMoveTransform2( pStatics, pnumJumpXStep, pnumJumpYStep,
											ppbvrTransform );
	}
	
  cleanup:
    return hr;

} // Build2DTransform

//*****************************************************************************

HRESULT 
CJumpBvr::Apply2DTransformToAnimationElement(IDATransform2 *pbvrMove)
{
    HRESULT hr  = S_OK;
	
	{
		float	fOrigX, fOrigY;

		hr = GetInitialPosition( fOrigX, fOrigY );
		LMCLEANUPIFFAILED(hr);

		// REVIEW: Supporting only absolute
		hr = ApplyAbsolute2DMoveBehavior( pbvrMove, fOrigX, fOrigY );
    }
	
  cleanup:
    return hr;

} // Apply2DTransformToAnimationElement

//*****************************************************************************

HRESULT
CJumpBvr::GetInitialPosition( float &fOrigX, float &fOrigY )
{
	HRESULT					hr = S_OK;

	{
		CComPtr<IHTMLElement>		   pElement;
		CComPtr<IHTMLCurrentStyle>     pStyle;
		float                   fLeft, fTop;

		hr = GetElementToAnimate( &pElement );
		LMCLEANUPIFFAILED(hr);

		CComQIPtr<IHTMLElement2, &IID_IHTMLElement2> pElement2( pElement );
		
		pElement2->get_currentStyle( &pStyle );
		LMCLEANUPIFFAILED(hr);

		long left, top;
		hr = pElement->get_offsetLeft( &left );
		LMCLEANUPIFFAILED(hr);
		hr = pElement->get_offsetTop( &top );
		LMCLEANUPIFFAILED(hr);

		fOrigX = (float) left;
		fOrigY = (float) top;
	}
	
  cleanup:
	return hr;

} // GetInitialPosition

//*****************************************************************************
//ILMJumpBvr
//*****************************************************************************

//*****************************************************************************

STDMETHODIMP
CJumpBvr::put_interval( VARIANT varInterval )
{
    return VariantCopy( &m_varInterval, &varInterval );
}

//*****************************************************************************

STDMETHODIMP
CJumpBvr::get_interval( VARIANT *varInterval )
{
    return VariantCopy( varInterval, &m_varInterval );
}

//*****************************************************************************

STDMETHODIMP
CJumpBvr::put_range( VARIANT varRange )
{
    return VariantCopy( &m_varRange, &varRange );
}

//*****************************************************************************

STDMETHODIMP
CJumpBvr::get_range( VARIANT *varRange )
{
    return VariantCopy( varRange, &m_varRange );
}

//*****************************************************************************
//End ILMJumpBvr
//*****************************************************************************

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\behaviors\avoidfollow.h ===
#ifndef __AVOIDFOLLOW_H_
#define __AVOIDFOLLOW_H_
//*****************************************************************************
//
// Microsoft LiquidMotion
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    AvoidFollowBvr.h
//
// Author:	kurtj
//
// Created:	11/06/98
//
// Abstract:    Definition of the LM Avoid Follow Behavior.
//
//*****************************************************************************

#include <resource.h>
#include "lmrt.h"
#include "..\chrome\include\basebvr.h"
#include "..\chrome\include\sampler.h"

//*****************************************************************************

typedef enum AF_TargetType
{
	targetInvalid,
	targetMouse,
	targetElement
} AF_TargetType;

#define NUM_AVOIDFOLLOW_PROPS 3


class ATL_NO_VTABLE CAvoidFollowBvr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAvoidFollowBvr, &CLSID_LMAvoidFollowBvr>,
    public IConnectionPointContainerImpl<CAvoidFollowBvr>,
    public IPropertyNotifySinkCP<CAvoidFollowBvr>,
	public IDispatchImpl<ILMAvoidFollowBvr, &IID_ILMAvoidFollowBvr, &LIBID_LiquidMotion>,
    public IPersistPropertyBag2,
	public IElementBehavior,
    public CBaseBehavior
{
public:
DECLARE_REGISTRY_RESOURCEID(IDR_AVOIDFOLLOWBVR)

BEGIN_COM_MAP(CAvoidFollowBvr)
	COM_INTERFACE_ENTRY(ILMAvoidFollowBvr)
    COM_INTERFACE_ENTRY(IPersistPropertyBag2)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IElementBehavior)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

// Connection Point to allow IPropertyNotifySink 
BEGIN_CONNECTION_POINT_MAP(CAvoidFollowBvr)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

public:
	CAvoidFollowBvr();
    virtual ~CAvoidFollowBvr();
    HRESULT                 FinalConstruct              ();

    // IElementBehavior
    //
	STDMETHOD			    (Init)						(IElementBehaviorSite *pBehaviorSite);
	STDMETHOD			    (Notify)					(LONG event, VARIANT *pVar);
	STDMETHOD			    (Detach)					();

    //
    //ILMAvoidFollowBvr
    //
    //animates
    STDMETHOD			    (put_animates)				( VARIANT varAnimates );
    STDMETHOD			    (get_animates)				( VARIANT *varAnimates );
    //radius
    STDMETHOD			    (put_radius)				( VARIANT varRadius );
    STDMETHOD			    (get_radius)				( VARIANT *varRadius );
    //target
    STDMETHOD			    (put_target)				( VARIANT varTarget );
    STDMETHOD			    (get_target)				( VARIANT *varTarget );
    //velocity
    STDMETHOD			    (put_velocity)				( VARIANT varVelocity );
    STDMETHOD			    (get_velocity)				( VARIANT *varVelocity );
	//methods
	STDMETHOD			    (buildBehaviorFragments)	( IDispatch *pActorDisp );

    //IPersistPropertyBag2 methods
    STDMETHOD               (GetClassID)                (CLSID* pclsid);
	STDMETHOD               (InitNew)                   (void);
    STDMETHOD               (IsDirty)                   (void){return S_OK;};
    STDMETHOD               (Load)                      (IPropertyBag2 *pPropBag,
                                                         IErrorLog *pErrorLog);
    STDMETHOD               (Save)                      (IPropertyBag2 *pPropBag, 
                                                         BOOL fClearDirty, 
                                                         BOOL fSaveAllProperties);

    // Needed by CBaseBehavior
    void * 				    GetInstance					();
	
    HRESULT				    GetTypeInfo					(ITypeInfo ** ppInfo);

	static HRESULT			SampleOnBvr					(void *thisPtr,
														 double startTime,
														 double globalNow,
														 double localNow,
														 IDABehavior * sampleVal);

protected:

	HRESULT					(Sample)					( double startTime, 
                                                          double globalNow, 
                                                          double localNow,
														  IDABehavior *sampleVal);

    virtual HRESULT		    BuildAnimationAsDABehavior	();

	HRESULT				    MapToLocal					( long* pX, long* pY );
    HRESULT				    UpdateSourcePos				();
	HRESULT				    UpdateTargetPos				();
	HRESULT				    UpdateWindowTopLeft			();

	HRESULT				    GetElementClientPosition	(IHTMLElement2 *pElement2, 
                                                         long *pLeft, 
                                                         long *pTop);
	HRESULT					GetElementClientDimension	( IHTMLElement2 *pElement2, 
														  long *pWidth, 
														  long* pHeight );

    virtual HRESULT		    GetPropertyBagInfo			(ULONG *pulProperties, 
                                                         WCHAR ***pppPropName);
    virtual HRESULT		    GetConnectionPoint			(REFIID riid, 
                                                         IConnectionPoint **ppICP);

    virtual VARIANT *	    VariantFromIndex			(ULONG iIndex);

	void				    ReleaseTridentInterfaces	();
	void				    ReleaseDAInterfaces			();
	HRESULT				    CacheWindow3				();
	HRESULT					CacheBody2					();
	HRESULT				    FindTargetElement			();

	bool					IsTargetPosLegal			();
	bool					IsElementAbsolute			(IHTMLElement2 *pElement2 );

private:

    HRESULT				    InitializeProperties		();
	HRESULT				    SetTargetType				();

    //properties
    VARIANT				    m_radius;
    VARIANT				    m_target;
    VARIANT				    m_velocity;

    //cached values
    //the coords of the object that we are avoid/following
    long				    m_targetLeft;
    long				    m_targetTop;
	long					m_targetClientTop;  //only defined for target == mouse
	long					m_targetClientLeft;
    //the coordinates of the object that we are moving
    long				    m_sourceLeft;
    long				    m_sourceTop;
    //the coordinates of the trident window top left for translating mouse events
    long				    m_screenLeft;
    long				    m_screenTop;

	double				    m_dVelocity;
	double				    m_dRadius;
	double				    m_currentX;
	double				    m_currentY;
    long                    m_originalX;
    long                    m_originalY;
    long                    m_originalLeft;
    long                    m_originalTop;

	//These should be released in ReleaseTridentInterfaces
	IHTMLElement*		    m_pElement;
	IHTMLElement*		    m_pAnimatedElement;
	IHTMLElement2*          m_pAnimatedElement2;
	IHTMLElement2*		    m_pTargetElement2;
	IHTMLWindow3*		    m_pWindow3;
	IHTMLElement2*			m_pBody2;

    IDANumber*			    m_leftBvr;
    IDANumber*			    m_topBvr;

	VARIANT_BOOL			m_lastOn;

    //the sampler.  used to hook us up to whomever is going to tell us to sample
    CSampler*			    m_sampler;

	AF_TargetType		    m_targetType;
	
	double				    m_lastSampleTime;
	double				    m_timeDelta;

    static WCHAR            *m_rgPropNames[NUM_AVOIDFOLLOW_PROPS]; 

}; // CAvoidFollowBvr

//*****************************************************************************
//inlines
//*****************************************************************************

inline void*
CAvoidFollowBvr::GetInstance()
{
	return (ILMAvoidFollowBvr *) this ;
}

inline HRESULT 
CAvoidFollowBvr::GetTypeInfo(ITypeInfo ** ppInfo)
{
	return GetTI(GetUserDefaultLCID(), ppInfo);
}

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif //__AVOIDFOLLOW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\behaviors\jump.h ===
#ifndef __JUMP_H_
#define __JUMP_H_

//*****************************************************************************
//
// Microsoft LiquidMotion
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    jump.h
//
// Author:	elainela
//
// Created:	11/11/98
//
// Abstract:    Definition of the LM Jump Behavior.
//
//*****************************************************************************

#include <resource.h>
#include "lmrt.h"
#include "..\chrome\include\basebvr.h"
#include "..\chrome\include\sampler.h"

//*****************************************************************************

#define NUM_JUMP_PROPS 2

class ATL_NO_VTABLE CJumpBvr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CJumpBvr, &CLSID_LMJumpBvr>,
    public IConnectionPointContainerImpl<CJumpBvr>,
    public IPropertyNotifySinkCP<CJumpBvr>,
	public IDispatchImpl<ILMJumpBvr, &IID_ILMJumpBvr, &LIBID_LiquidMotion>,
    public IPersistPropertyBag2,
	public IElementBehavior,
	public ILMSample,
    public CBaseBehavior
	
{
public:
DECLARE_REGISTRY_RESOURCEID(IDR_JUMPBVR)

BEGIN_COM_MAP(CJumpBvr)
	COM_INTERFACE_ENTRY(ILMJumpBvr)
    COM_INTERFACE_ENTRY(IPersistPropertyBag2)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IElementBehavior)
    COM_INTERFACE_ENTRY(ILMSample)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

// Connection Point to allow IPropertyNotifySink 
BEGIN_CONNECTION_POINT_MAP(CJumpBvr)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

	CJumpBvr();
    ~CJumpBvr();
    HRESULT FinalConstruct();
    // IElementBehavior
    //
	STDMETHOD(Init)(IElementBehaviorSite *pBehaviorSite);
	STDMETHOD(Notify)(LONG event, VARIANT *pVar);
	STDMETHOD(Detach)();

    // ILMSample
    STDMETHOD(Sample) (double dStart, double dGlobalNow, double dLocalNow );

    //
    //ILMJumpBvr
    //
    STDMETHOD(put_interval)( VARIANT varInterval );
    STDMETHOD(get_interval)( VARIANT *varInterval );
    STDMETHOD(put_range)( VARIANT varRange );
    STDMETHOD(get_range)( VARIANT *varRange );
	STDMETHOD(buildBehaviorFragments)(IDispatch *pActorDisp);
    
    //IPersistPropertyBag2 methods
    STDMETHOD(GetClassID)(CLSID* pclsid);
	STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void){return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    // Needed by CBaseBehavior
    void * 	GetInstance() { return (ILMJumpBvr *) this ; }
	
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }


protected:
    virtual VARIANT *VariantFromIndex(ULONG iIndex);
    virtual HRESULT BuildAnimationAsDABehavior() { return S_OK; }

protected:
	enum TargetType
	{
		TARGET_NONE     = -1,
		TARGET_PAGE     = 0,
		TARGET_WINDOW   = 1,
		TARGET_ELEMENT  = 2,
		NUM_TARGETTYPES = 3
	};
	
protected:
	HRESULT GetNumberModifiableBvr( float fNumber, IDAModifiableBehavior ** out_ppModifiable, IDANumber ** out_ppNumberModifiable );
	HRESULT GetRandomNumber( IDA2Statics *pDAStatics, IDANumber * pnumBase, IDANumber * pnumRange, IDANumber **ppnumReturn );
	HRESULT GetJumpRanges( float& fMinX, float& fMaxX, float& fMinY, float& fMaxY );
	HRESULT BuildJumpRangeBehaviors( IDANumber ** ppnumJumpX, IDANumber ** ppnumJumpY );
    HRESULT Build2DTransform(IDATransform2 **ppbvrTransform);
    HRESULT Apply2DTransformToAnimationElement(IDATransform2 *pbvrTransform);
	HRESULT	GetInitialPosition( float& fX, float& fY );

    virtual HRESULT GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropName);
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);

private:
	VARIANT	m_varInterval;
	VARIANT	m_varRange;
    float	m_fFrequency;
	
    static WCHAR                *m_rgPropNames[NUM_JUMP_PROPS];
	float						m_fOrigX;
	float						m_fOrigY;
	long						m_lOrigBoundingLeft;
	long						m_lOrigBoundingTop;
	CSampler					* m_pSampler;
	TargetType					m_eTargetType;
	double						m_dLastUpdateCycle;

	float						m_fBaseX;
	float						m_fRangeX;
	float						m_fBaseY;
	float						m_fRangeY;

	
	CComPtr<IDAModifiableBehavior>		m_pBvrModifRangeX;
	CComPtr<IDAModifiableBehavior>		m_pBvrModifBaseX;
	CComPtr<IDAModifiableBehavior>		m_pBvrModifRangeY;
	CComPtr<IDAModifiableBehavior>		m_pBvrModifBaseY;

}; // CJumpBvr

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif //__JUMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\behaviors\headers.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Precompiled headers for appel.dll
*******************************************************************************/

#ifndef LM_HEADERS_HXX
#define LM_HEADERS_HXX

/*********** Headers from external dependencies *********/

//#ifdef DEBUG
//#define DEBUGMEM
//#endif

/* Standard */
#include <math.h>
//#ifdef DEBUGMEM
//#include "crtdbg.h"
//#endif
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#ifndef _NO_CRT
#include <ios.h>
#include <fstream.h>
#include <iostream.h>
#include <ostream.h>
#include <strstrea.h>
#include <istream.h>
#include <ctype.h>
#include <sys/types.h>
#endif
#include <string.h>
#include <malloc.h>
#include <memory.h>
#include <wtypes.h>

// Warning 4786 (identifier was truncated to 255 chars in the browser
// info) can be safely disabled, as it only has to do with generation
// of browsing information.
#pragma warning(disable:4786)
#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif
// ATL - needs to be before windows.h
#include "lmatl.h"

/* Windows */
#include <windows.h>
#include <windowsx.h>

/*DA*/
#include <danim.h>

/*mshtml*/
#include <mshtml.h>

/*
#ifdef DEBUGMEM
#ifndef DEBUG_NEW
#define DEBUG_NEW                   new(_NORMAL_BLOCK, __FILE__, __LINE__)
#endif
#define new                         DEBUG_NEW
#define malloc(size)                _malloc_dbg(size, _NORMAL_BLOCK, __FILE__, __LINE__)
#define free(p)                     _free_dbg(p, _NORMAL_BLOCK)
#define calloc(c, s)                _calloc_dbg(c, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define realloc(p, s)               _realloc_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define _expand(p, s)               _expand_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define _msize(p)                   _msize_dbg(p, _NORMAL_BLOCK)
#endif
*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\behaviors\lmfactory.cpp ===
// LMBehaviorFactory.cpp : Implementation of CLMBehaviorFactory

#include "headers.h"

#include "lmattrib.h"
#include "lmfactory.h"

//chrome includes
#include "..\chrome\include\utils.h"
#include "..\chrome\include\defaults.h"
#include "..\chrome\include\factory.h"

// Behaviors
//#include "jump.h" //punted for v1
//#include "avoidfollow.h" //punted for v1
#include "autoeffect.h"

/////////////////////////////////////////////////////////////////////////////
// CLMBehaviorFactory

CLMBehaviorFactory::CLMBehaviorFactory():m_chromeFactory(NULL)
{
}

CLMBehaviorFactory::~CLMBehaviorFactory()
{
    if( m_chromeFactory != NULL )
    {
        ReleaseInterface( m_chromeFactory );
    }
}

STDMETHODIMP CLMBehaviorFactory::FindBehavior( LPOLESTR pchBehaviorName,
											   LPOLESTR	pchBehaviorURL,
											   IUnknown * pUnkArg,
											   IElementBehavior ** ppBehavior)
{
    HRESULT hr = E_FAIL;

    // (TIME bails if we are in 16 or less color mode. Need to the same
    // here because LM crashes if time is not around.)
    // If we are in 16 or less color mode on the Primary Device, bail.
    // Note: Multi-monitor API are currently unavailable in this build
    HWND hwndDesktop = NULL;
    hwndDesktop = GetDesktopWindow();
    if (NULL != hwndDesktop)
    {
        HDC hdcPrimaryDevice = NULL;
        hdcPrimaryDevice = GetDC(NULL);
        if (NULL != hdcPrimaryDevice)
        {
            int bpp = 32;
            bpp = GetDeviceCaps(hdcPrimaryDevice, BITSPIXEL);
            ReleaseDC(hwndDesktop, hdcPrimaryDevice);
            if (bpp <= 4)
            {
                // This prevents LM bvrs from being created
                return E_FAIL;
            }
        }
    }

    // check the paramters passed in to ensure they are valid
	if (pUnkArg == NULL ||
		ppBehavior == NULL) 
	{
		DPF_ERR("Invalid Parameter passed into FindBehavior is NULL");
		return SetErrorInfo(E_INVALIDARG);
	}

    BSTR bstrTagName;
    if (pchBehaviorName == NULL || _wcsicmp(DEFAULT_BEHAVIOR_AS_TAG_URL, pchBehaviorName) == 0)
    {
        // we need to get the tag name from the HTMLElement that we are being
        // created from.  To do this we use the IUnknown to get a IElementBehaviorSite,
        // from this we get the HTMLElement, and get the tagname from this.
        IElementBehaviorSite *pBehaviorSite;
        hr = pUnkArg->QueryInterface(IID_TO_PPV(IElementBehaviorSite, &pBehaviorSite));
        if (FAILED(hr))
        {
            DPF_ERR("Unable to get an ElementBehaviorSite from IUnknown in FindBehavior");
            return SetErrorInfo(hr);
        }
        DASSERT(pBehaviorSite != NULL);
        IHTMLElement *pElement;
        hr = pBehaviorSite->GetElement(&pElement);
        ReleaseInterface(pBehaviorSite);
        if (FAILED(hr))
        {
            DPF_ERR("Error retrieving HTMLElement from BehaviorSite in FindBehavior");
            return SetErrorInfo(hr);
        }
        DASSERT(pElement != NULL);
        hr = pElement->get_tagName(&bstrTagName);
        ReleaseInterface(pElement);
        if (FAILED(hr))
        {
            DPF_ERR("Error retrieving tagname from HTML element in FindBehavior");
            return SetErrorInfo(hr);
        }
    }
    else
    {
        bstrTagName = pchBehaviorName;
    }
    if (_wcsicmp(BEHAVIOR_TYPE_AUTOEFFECT, bstrTagName) == 0)
	{
        CComObject<CAutoEffectBvr> *pAutoEffect;
        hr = CComObject<CAutoEffectBvr>::CreateInstance(&pAutoEffect);
        if (FAILED(hr))
		{
			DPF_ERR("Error creating auto effect behavior in FindBehavior");
			return SetErrorInfo(hr);
		}
		// this will do the necessary AddRef to the object
        hr = pAutoEffect->QueryInterface(IID_TO_PPV(IElementBehavior, ppBehavior));
		DASSERT(SUCCEEDED(hr));
	}
    else if (_wcsicmp(BEHAVIOR_TYPE_AVOIDFOLLOW, bstrTagName) == 0)
	{
        //AvoidFollow punted for version 1
        /*
        CComObject<CAvoidFollowBvr> *pAvoidFollow;
        hr = CComObject<CAvoidFollowBvr>::CreateInstance(&pAvoidFollow);
        if( SUCCEEDED( hr ) )
        {
            // this will do the necessary AddRef to the object
            hr = pAvoidFollow->QueryInterface(IID_TO_PPV(IElementBehavior, ppBehavior));
		    DASSERT(SUCCEEDED(hr));
        }
        else //failed to create the avoid follow behavior
		{
			DPF_ERR("Error creating AvoidFollow behavior in FindBehavior");
			return SetErrorInfo(hr);
        }
        */
        hr = E_INVALIDARG;
	}
    else if ( _wcsicmp(BEHAVIOR_TYPE_JUMP, bstrTagName) == 0 )
	{
        //Jump punted for version 1
        /*
        CComObject<CJumpBvr> *pJump;
        hr = CComObject<CJumpBvr>::CreateInstance(&pJump);
        if (FAILED(hr))
		{
			DPF_ERR("Error creating Jump behavior in FIndBehavior");
			return SetErrorInfo(hr);
		}
		// this will do the necessary AddRef to the object
        hr = pJump->QueryInterface(IID_TO_PPV(IElementBehavior, ppBehavior));
		DASSERT(SUCCEEDED(hr));
        */
        hr = E_INVALIDARG;
	}
    else
    {
        //this may be a request for a chrome behavior.
        //request the behavior from the chrome factory.
        if( m_chromeFactory == NULL )
        {
            //cache a chrome factory
            CComObject<CCrBehaviorFactory> *pFactory;
            hr = CComObject<CCrBehaviorFactory>::CreateInstance(&pFactory);
            if( SUCCEEDED( hr ) )
            {
                hr = pFactory->QueryInterface( IID_TO_PPV(IElementBehaviorFactory, &m_chromeFactory) );
                if( FAILED( hr ) )
                {
                    DPF_ERR( "Error Querying the chrome behavior factory for IElementBehaviorFactory" );
                    return SetErrorInfo( hr );
                }
                //otherwise we succeeded and all is well.
            }
            else
            {
                DPF_ERR( "Error creating the chrome behavior factory" );
                return SetErrorInfo( hr );
            }
        }

        // QI pUnkArg for pBehaviorSite and pass to FindBehavior(...)
        // TODO: (dilipk) this QI goes away with the old FindBehavior Signature (#38656).
        IElementBehaviorSite *pBehaviorSite = NULL;
        hr = pUnkArg->QueryInterface(IID_TO_PPV(IElementBehaviorSite, &pBehaviorSite)); 
        if (FAILED(hr))
        {
            DPF_ERR("Error Querying for IElementBehaviorSite in FindBehavior");
            return hr;
        }
        hr = m_chromeFactory->FindBehavior( pchBehaviorName, 
                                            pchBehaviorURL, 
                                            pBehaviorSite, 
                                            ppBehavior );
        ReleaseInterface(pBehaviorSite);
    }
    if (bstrTagName != pchBehaviorName)
        SysFreeString(bstrTagName);
	
    return hr;

}

STDMETHODIMP CLMBehaviorFactory::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
	if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
		return E_POINTER;
	HRESULT hr = S_OK;

	if (riid == IID_IDispatch)
	{
		*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
		*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
	}
	else if (riid == IID_IPersistPropertyBag2 )
	{
		*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
		*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_DATA;
	}
	else
	{
		*pdwSupportedOptions = 0;
		*pdwEnabledOptions = 0;
		hr = E_NOINTERFACE;
	}
	return hr;
}

STDMETHODIMP CLMBehaviorFactory::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{	
	// If we're being asked to set our safe for scripting or
	// safe for initialization options then oblige
	if (riid == IID_IDispatch || riid == IID_IPersistPropertyBag2 )
	{
		// Store our current safety level to return in GetInterfaceSafetyOptions
		m_dwSafety = dwEnabledOptions & dwOptionSetMask;
		return S_OK;
	}

	return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\behaviors\lmfactory.h ===
// LMBehaviorFactory.h : Declaration of the CLMBehaviorFactory

#ifndef __LMBEHAVIORFACTORY_H_
#define __LMBEHAVIORFACTORY_H_

#include "resource.h"       // main symbols

#include "..\chrome\include\autobase.h"

#include "lmrt.h"

/////////////////////////////////////////////////////////////////////////////
// CLMBehaviorFactory
class ATL_NO_VTABLE CLMBehaviorFactory : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CLMBehaviorFactory, &CLSID_LMBehaviorFactory>,
    public IDispatchImpl<ILMBehaviorFactory, &IID_ILMBehaviorFactory, &LIBID_LiquidMotion>,
    public IObjectSafetyImpl<CLMBehaviorFactory>,
    public IElementBehaviorFactory,
    public CAutoBase
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_LMBVRFACTORY)

    CLMBehaviorFactory();
    ~CLMBehaviorFactory();

    // IObjectSafetyImpl
    STDMETHOD(SetInterfaceSafetyOptions)(
                            /* [in] */ REFIID riid,
                            /* [in] */ DWORD dwOptionSetMask,
                            /* [in] */ DWORD dwEnabledOptions);
    STDMETHOD(GetInterfaceSafetyOptions)(
                            /* [in] */ REFIID riid, 
                            /* [out] */DWORD *pdwSupportedOptions, 
                            /* [out] */DWORD *pdwEnabledOptions);
    //
    // IElementBehaviorFactory
    //

    STDMETHOD(FindBehavior)(LPOLESTR pchNameSpace, 
                            LPOLESTR pchTagName, 
                            IElementBehaviorSite *pUnkArg, 
                            IElementBehavior **ppBehavior)
    {
        return FindBehavior(pchNameSpace, pchTagName, static_cast<IUnknown*>(pUnkArg), ppBehavior);
    }

    STDMETHOD(FindBehavior)(LPOLESTR pchNameSpace, 
                            LPOLESTR pchTagName, 
                            IUnknown *pUnkArg, 
                            IElementBehavior **ppBehavior);

    STDMETHODIMP UIDeactivate() { return S_OK; }

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CLMBehaviorFactory)
    COM_INTERFACE_ENTRY(ILMBehaviorFactory)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IElementBehaviorFactory)
END_COM_MAP()


private:
    DWORD m_dwSafety;

    IElementBehaviorFactory *m_chromeFactory;

// ILMBehaviorFactory
public:
};

#endif //__LMBEHAVIORFACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\dll\stdafx.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Ole Object initialization

Revision:

--*/

#include "headers.h"
#include "resource.h"

#undef map
#undef SubclassWindow

// Put this here to initialize all the ATL stuff

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\dll\main.cpp ===
//*****************************************************************************
//
// Microsoft Chrome
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    main.cpp
//
// Author:	    jeffort
//
// Created:	    10/07/98
//
// Abstract:    main dll file
// Modifications:
// 10/07/98 jeffort created file
//
//*****************************************************************************
#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#include "headers.h"
#include "crbvr.h"
#include "factory.h"
#include "colorbvr.h"
#include "rotate.h"
#include "scale.h"
#include "move.h"
#include "path.h"
#include "number.h"
#include "set.h"
#include "actorbvr.h"
#include "effect.h"

//*****************************************************************************

CComModule _Module;

//*****************************************************************************

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CrBehaviorFactory, CCrBehaviorFactory)
    OBJECT_ENTRY(CLSID_CrColorBvr, CColorBvr)
    OBJECT_ENTRY(CLSID_CrRotateBvr, CRotateBvr)
    OBJECT_ENTRY(CLSID_CrScaleBvr, CScaleBvr)
    OBJECT_ENTRY(CLSID_CrMoveBvr, CMoveBvr)
    OBJECT_ENTRY(CLSID_CrPathBvr, CPathBvr)
    OBJECT_ENTRY(CLSID_CrNumberBvr, CNumberBvr)
    OBJECT_ENTRY(CLSID_CrSetBvr, CSetBvr)
    OBJECT_ENTRY(CLSID_CrActorBvr, CActorBvr)
    OBJECT_ENTRY(CLSID_CrEffectBvr, CEffectBvr)
END_OBJECT_MAP()

//*****************************************************************************

HINSTANCE  hInst;

//*****************************************************************************

extern "C"
BOOL WINAPI 
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        hInst = hInstance;
        DisableThreadLibraryCalls(hInstance);
        _Module.Init(ObjectMap, hInstance);
    }        
    else if (dwReason == DLL_PROCESS_DETACH) {
        _Module.Term();
//#ifdef DEBUGMEM
//		_CrtDumpMemoryLeaks();
//#endif
	
    }
    
    return TRUE;    // ok
} //DllMain

//*****************************************************************************

STDAPI 
DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
} // DllCanUnloadNow

//*****************************************************************************

STDAPI 
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
} // DllGetClassObject

//*****************************************************************************

STDAPI 
DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
} // DllRegisterServer

//*****************************************************************************

STDAPI 
DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
} // DllUnregisterServer

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\behaviors\pathmaker.h ===
//*****************************************************************************
//
// Microsoft LiquidMotion
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    PathMaker.h
//
// Author:	elainela
//
// Created:	11/20/98
//
// Abstract:    Definition of the PathMaker for the AutoEffect.
//
//*****************************************************************************

#ifndef __PATHMAKER_H__
#define __PATHMAKER_H__

#include "lmrt.h"

#include <vector>

using namespace std;

//**********************************************************************

struct PathNode
{
	float	fIncomingBCPX;
	float	fIncomingBCPY;
	float	fAnchorX;
	float	fAnchorY;
	float	fOutgoingBCPX;
	float	fOutgoingBCPY;
	int		nAnchorType;
};

typedef vector<PathNode>	VecPathNodes;

class CPathMaker
{
public:
	static HRESULT CreatePathBvr( IDA2Statics * pStatics, VecPathNodes& vecNodes, bool fClosed, IDAPath2 ** ppPath );
	
	static HRESULT CreateStarPath(int cArms, double dInnerRadius,
								  double dOuterRadius,
								  VecPathNodes& vecNodes );
};

#endif // __PATHMAKER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\behaviors\sparkmaker.h ===
//*****************************************************************************
//
// Microsoft LiquidMotion
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    SparkMaker.h
//
// Author:	elainela
//
// Created:	11/19/98
//
// Abstract:    Definition of the SparkMaker for the AutoEffect.
//
//*****************************************************************************

#ifndef __SPARKMAKER_H__
#define __SPARKMAKER_H__

#include <vector>

#include "lmrt.h"
#include "pathmaker.h"

using namespace std;

typedef CComPtr<IDATransform2>	DATransform2Ptr;
typedef vector<DATransform2Ptr> VecDATransforms;

#define	SPARK_SCALE		(1 << 0)
#define SPARK_ROTATE	(1 << 1)
#define SPARK_TRANSLATE	(1 << 2)

//**********************************************************************

struct HSL
{
	float hue;
	float sat;
	float lum;
};

struct SparkOptions
{
	HSL	hslPrimary;
	HSL hslSecondary;
};

//**********************************************************************

class CSparkMaker
{
public:
	enum Type
	{
		SPARKLES,
		TWIRLERS,
		BUBBLES,
		FILLEDBUBBLES,
		CLOUDS,
		SMOKE,
		NUM_TYPES
	};

	static HRESULT CreateSparkMaker( IDA2Statics * pStatics, Type iType, CSparkMaker ** ppMaker );
	
public:
	CSparkMaker( IDA2Statics * pStatics );
	virtual ~CSparkMaker();
	
public:
	virtual HRESULT	Init( SparkOptions * );
	
	virtual HRESULT	GetSparkImageBvr( SparkOptions *, IDANumber * pnumAgeRatio, IDAImage ** ppImageBvr );

	virtual long	GetTransformFlags() { return 0L; }
	
	virtual HRESULT AddScaleTransforms( IDANumber * pnumAge, VecDATransforms& ) { return S_OK; }
	virtual HRESULT AddRotateTransforms( IDANumber * pnumAge, VecDATransforms& ) { return S_OK; }
	virtual HRESULT AddTranslateTransforms( IDANumber * pnumAge, VecDATransforms& ) { return S_OK; }
	
protected:
	virtual HRESULT CreateLineStyleBvr( IDALineStyle ** ppLineStyle );
	virtual HRESULT CreateBasicSparkImageBvr( SparkOptions *, IDANumber * pnumAgeRatio, IDAImage ** ppImageBvr ) = 0;

protected:
	IDA2Statics 	* m_pStatics;
	bool			m_fInitialized;
};

//**********************************************************************

class CStarMaker : public CSparkMaker
{
public:
	CStarMaker( IDA2Statics * );

	HRESULT	Init( SparkOptions *);

protected:
	static const int	NUM_STARARMS;
	
protected:
	HRESULT	CreateBasicSparkImageBvr( SparkOptions *, IDANumber * pnumAgeRatio, IDAImage ** ppImageBvr ) ;

protected:
	CComPtr<IDAImage> m_pBaseImage;
};

//**********************************************************************

class CSparkleMaker : public CStarMaker
{
public:
	CSparkleMaker( IDA2Statics * );

	long	GetTransformFlags()	{ return SPARK_SCALE; }
	
	HRESULT AddScaleTransforms( IDANumber * pnumAgeRatio, VecDATransforms& );
};

//**********************************************************************

class CTwirlerMaker : public CStarMaker
{
public:
	CTwirlerMaker( IDA2Statics * );

	long	GetTransformFlags()	{ return SPARK_ROTATE; }
	
	HRESULT AddRotateTransforms( IDANumber * pnumAgeRatio, VecDATransforms& );
};

//**********************************************************************

class CFilledBubbleMaker : public CSparkMaker
{
public:
	CFilledBubbleMaker( IDA2Statics * );

	HRESULT	Init( SparkOptions * );

protected:
	HRESULT	CreateBasicSparkImageBvr( SparkOptions *, IDANumber * pnumAgeRatio, IDAImage ** ppImageBvr ) ;

protected:
	CComPtr<IDAImage> m_pBaseImage;
};

//**********************************************************************

class CBubbleMaker : public CSparkMaker
{
public:
	CBubbleMaker( IDA2Statics * );

	HRESULT	Init( SparkOptions * );

protected:
	HRESULT	CreateBasicSparkImageBvr( SparkOptions *, IDANumber * pnumAgeRatio, IDAImage ** ppImageBvr ) ;
	HRESULT	MakeGlintPath( float fRadius, VecPathNodes& vecNodes );

protected:
	CComPtr<IDAImage> m_pBaseImage;
};

//**********************************************************************

class CCloudMaker : public CSparkMaker
{
public:
	CCloudMaker( IDA2Statics * );

	HRESULT	Init( SparkOptions * );

protected:
	HRESULT	CreateBasicSparkImageBvr( SparkOptions *, IDANumber * pnumAgeRatio, IDAImage ** ppImageBvr ) ;

protected:
	CComPtr<IDAPath2> m_pPathBvr;
};

//**********************************************************************

class CSmokeMaker : public CSparkMaker
{
public:
	CSmokeMaker( IDA2Statics * );

	HRESULT	Init( SparkOptions * );

	long	GetTransformFlags()	{ return SPARK_SCALE; }
	
	HRESULT AddScaleTransforms( IDANumber * pnumAgeRatio, VecDATransforms& );
	
protected:
	HRESULT	CreateBasicSparkImageBvr( SparkOptions *, IDANumber * pnumAgeRatio, IDAImage ** ppImageBvr ) ;

protected:
	CComPtr<IDAPath2> m_pPathBvr;
};

//**********************************************************************
// Inlines
//**********************************************************************

inline CSparkMaker::CSparkMaker( IDA2Statics * pStatics )
{
	m_fInitialized	= false;
	m_pStatics		= pStatics;		// weak ref
}

inline CSparkMaker::~CSparkMaker()
{
}

inline HRESULT CSparkMaker::Init( SparkOptions * )
{
	m_fInitialized = true;
	return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\behaviors\sparkmaker.cpp ===
#include "headers.h" 

#include "sparkmaker.h"

#include "..\chrome\src\dautil.h"
#include "..\chrome\include\utils.h"

static	const float PI		= 3.14159265359f;
const	int CSparkleMaker::NUM_STARARMS		= 8;

HRESULT CSparkMaker::CreateSparkMaker( IDA2Statics * pStatics, Type iType, CSparkMaker ** ppMaker )
{
	HRESULT	hr = S_OK;
	
	switch ( iType )
	{
		default:
		case SPARKLES:
			*ppMaker = new CSparkleMaker( pStatics );
			break;

		case TWIRLERS:
			*ppMaker = new CTwirlerMaker( pStatics );
			break;

		case BUBBLES:
			*ppMaker = new CBubbleMaker( pStatics );
			break;
			
		case FILLEDBUBBLES:
			*ppMaker = new CFilledBubbleMaker( pStatics );
			break;

		case CLOUDS:
			*ppMaker = new CCloudMaker( pStatics );
			break;

		case SMOKE:
			*ppMaker = new CSmokeMaker( pStatics );
			break;
	}

	return hr;
}

HRESULT
CSparkMaker::GetSparkImageBvr( SparkOptions * pSparkOptions, IDANumber * pnumAgeRatio, IDAImage ** ppImageBvr )
{
	HRESULT	hr;
	
	if ( !m_fInitialized )
	{
		hr = Init( pSparkOptions );
		LMRETURNIFFAILED(hr);
	}

	return CreateBasicSparkImageBvr( pSparkOptions, pnumAgeRatio, ppImageBvr );
}

HRESULT
CSparkMaker::CreateLineStyleBvr( IDALineStyle ** ppLineStyle )
{
	HRESULT hr = S_OK;

	CComPtr<IDALineStyle> 	pLineStyleDefault;
	
	hr = m_pStatics->get_DefaultLineStyle( &pLineStyleDefault );
	LMRETURNIFFAILED(hr);

	hr = pLineStyleDefault->AntiAliasing( 1.0, ppLineStyle );
	LMRETURNIFFAILED(hr);

	return hr;
}

//**********************************************************************
// Star Maker
//**********************************************************************

CStarMaker::CStarMaker( IDA2Statics * pStatics ) :
	CSparkMaker( pStatics )
{
}

HRESULT
CStarMaker::Init( SparkOptions * pOptions )
{
	HRESULT hr = CSparkMaker::Init( pOptions );
	LMRETURNIFFAILED(hr);

	// Colors
	//----------------------------------------------------------------------
	CComPtr<IDAColor> pColorPrimary;
	CComPtr<IDAColor> pColorSecondary;
	
	HSL hsl = pOptions->hslPrimary;
	hr = CDAUtils::BuildDAColorFromStaticHSL( m_pStatics, hsl.hue, hsl.sat, hsl.lum, &pColorPrimary );
	LMRETURNIFFAILED(hr);

	hsl = pOptions->hslSecondary;
	hr = CDAUtils::BuildDAColorFromStaticHSL( m_pStatics, hsl.hue, hsl.sat, hsl.lum, &pColorSecondary );
	LMRETURNIFFAILED(hr);

	// Create outer star path
	//----------------------------------------------------------------------
	CComPtr<IDAPath2> pOuterPathBvr;
	VecPathNodes vecNodes;
	
	hr = CPathMaker::CreateStarPath( NUM_STARARMS, 0, 1.0, vecNodes );
	LMRETURNIFFAILED(hr);

	hr = CPathMaker::CreatePathBvr( m_pStatics, vecNodes, true, &pOuterPathBvr );
	LMRETURNIFFAILED(hr);

    // Create inner star path
	//----------------------------------------------------------------------
	CComPtr<IDAPath2> pInnerPathBvr;
	
	vecNodes.clear();

	hr = CPathMaker::CreateStarPath( NUM_STARARMS, 0, 0.5f, vecNodes );
	LMRETURNIFFAILED(hr);

	hr = CPathMaker::CreatePathBvr( m_pStatics, vecNodes, true, &pInnerPathBvr );
	LMRETURNIFFAILED(hr);

	// Basic image
	//----------------------------------------------------------------------
	CComPtr<IDALineStyle> 	pLineStyleDefault;
	CComPtr<IDALineStyle>	pLineStyleOuter;
	CComPtr<IDALineStyle>	pLineStyleInner;
	CComPtr<IDAImage>		pImageOuter;
	CComPtr<IDAImage>		pImageInner;

	hr = CreateLineStyleBvr( &pLineStyleDefault );
	LMRETURNIFFAILED(hr);

	hr = pLineStyleDefault->Color( pColorPrimary, &pLineStyleInner );
	LMRETURNIFFAILED(hr);

	hr = pLineStyleDefault->Color( pColorSecondary, &pLineStyleOuter );
	LMRETURNIFFAILED(hr);

  	hr = pInnerPathBvr->Draw( pLineStyleInner, &pImageInner );
  	LMRETURNIFFAILED(hr);

  	hr = pOuterPathBvr->Draw( pLineStyleOuter, &pImageOuter );
  	LMRETURNIFFAILED(hr);

	hr = m_pStatics->Overlay( pImageInner, pImageOuter, &m_pBaseImage );
  	LMRETURNIFFAILED(hr);
	
	return		hr;
}

HRESULT
CStarMaker::CreateBasicSparkImageBvr( SparkOptions * pSparkOptions, IDANumber *, IDAImage ** ppBaseImage )
{
	HRESULT 	hr = S_OK;

	if ( m_pBaseImage == NULL )	return E_FAIL;

	*ppBaseImage = m_pBaseImage;
	(*ppBaseImage)->AddRef();
	
	return hr;
}

//**********************************************************************
// Sparkle Maker
//**********************************************************************

CSparkleMaker::CSparkleMaker( IDA2Statics * pStatics ) : CStarMaker( pStatics )
{
}

HRESULT
CSparkleMaker::AddScaleTransforms( IDANumber * pnumAgeRatio, VecDATransforms& vecTransforms )
{
	HRESULT	hr	= S_OK;

	CComPtr<IDANumber>		pnumOne;
	CComPtr<IDANumber>		pnumScaleAnim;
	CComPtr<IDATransform2>	pTransScaleAnim;

	hr = CDAUtils::GetDANumber( m_pStatics, 1.0f, &pnumOne );
	LMRETURNIFFAILED(hr);

	hr = m_pStatics->Sub( pnumOne, pnumAgeRatio, &pnumScaleAnim );
	LMRETURNIFFAILED(hr);

	hr = m_pStatics->Scale2UniformAnim( pnumScaleAnim, &pTransScaleAnim );
	LMRETURNIFFAILED(hr);

	vecTransforms.push_back( pTransScaleAnim );
	
	return S_OK;
}

//**********************************************************************
// Twirler Maker
//**********************************************************************

CTwirlerMaker::CTwirlerMaker( IDA2Statics * pStatics ) : CStarMaker( pStatics )
{
}

HRESULT
CTwirlerMaker::AddRotateTransforms( IDANumber * pnumAgeRatio, VecDATransforms& vecTransforms )
{
	HRESULT	hr	= S_OK;

	CComPtr<IDANumber>		pnumRotateAnim;
	CComPtr<IDATransform2>	pTransRotateAnim;

	hr = m_pStatics->Rotate2Rate( 7.0, &pTransRotateAnim );
	LMRETURNIFFAILED(hr);

	vecTransforms.push_back( pTransRotateAnim );
	
	return S_OK;
}

//**********************************************************************
// Filled Bubble Maker
//**********************************************************************

CFilledBubbleMaker::CFilledBubbleMaker( IDA2Statics * pStatics ) :
	CSparkMaker( pStatics )
{
}

HRESULT
CFilledBubbleMaker::Init( SparkOptions * pOptions )
{
	HRESULT hr = CSparkMaker::Init( pOptions );
	LMRETURNIFFAILED(hr);
	
	// Colors
	//----------------------------------------------------------------------
	CComPtr<IDAColor> pColorPrimary;
	CComPtr<IDAColor> pColorSecondary;
	
	HSL hsl = pOptions->hslPrimary;
	hr = CDAUtils::BuildDAColorFromStaticHSL( m_pStatics, hsl.hue, hsl.sat, hsl.lum, &pColorPrimary );
	LMRETURNIFFAILED(hr);

	hsl = pOptions->hslSecondary;
	hr = CDAUtils::BuildDAColorFromStaticHSL( m_pStatics, hsl.hue, hsl.sat, hsl.lum, &pColorSecondary );
	LMRETURNIFFAILED(hr);

	// Path
	//----------------------------------------------------------------------
	CComPtr<IDAPath2> pPathBvr;
	
	hr = m_pStatics->Oval( 2.0f, 2.0f, &pPathBvr );

	// Base image
	//----------------------------------------------------------------------
	CComPtr<IDAImage>		pFillImage;
	CComPtr<IDALineStyle> 	pLineStyleDefault;
	CComPtr<IDALineStyle>	pLineStyle;
	
	hr = m_pStatics->SolidColorImage( pColorPrimary, &pFillImage );
	LMRETURNIFFAILED(hr);

	hr = CreateLineStyleBvr( &pLineStyleDefault );
	LMRETURNIFFAILED(hr);

	hr = pLineStyleDefault->Color( pColorSecondary, &pLineStyle );
	LMRETURNIFFAILED(hr);

  	hr = pPathBvr->Fill( pLineStyle, pFillImage, &m_pBaseImage );
  	LMRETURNIFFAILED(hr);

	return		hr;
}

HRESULT
CFilledBubbleMaker::CreateBasicSparkImageBvr( SparkOptions * pSparkOptions, IDANumber *, IDAImage ** ppBaseImage )
{
	HRESULT 	hr = S_OK;

	if ( m_pBaseImage == NULL )	return E_FAIL;

	*ppBaseImage = m_pBaseImage;
	(*ppBaseImage)->AddRef();
	
	return hr;
}

//**********************************************************************
// Bubble Maker
//**********************************************************************

CBubbleMaker::CBubbleMaker( IDA2Statics * pStatics ) :
	CSparkMaker( pStatics )
{
}

HRESULT
CBubbleMaker::Init( SparkOptions * pOptions )
{
	HRESULT hr = CSparkMaker::Init( pOptions );
	LMRETURNIFFAILED(hr);

	// Colors
	//----------------------------------------------------------------------
	CComPtr<IDAColor> pColorPrimary;
	CComPtr<IDAColor> pColorSecondary;
	
	HSL hsl = pOptions->hslPrimary;
	hr = CDAUtils::BuildDAColorFromStaticHSL( m_pStatics, hsl.hue, hsl.sat, hsl.lum, &pColorPrimary );
	LMRETURNIFFAILED(hr);

	hsl = pOptions->hslSecondary;
	hr = CDAUtils::BuildDAColorFromStaticHSL( m_pStatics, hsl.hue, hsl.sat, hsl.lum, &pColorSecondary );
	LMRETURNIFFAILED(hr);
	
	// Bubble and glint paths
	//----------------------------------------------------------------------
	CComPtr<IDAPath2> pBubblePathBvr;
	CComPtr<IDAPath2> pGlintPathBvr;
	
	hr = m_pStatics->Oval( 2.0f, 2.0f, &pBubblePathBvr );
	LMRETURNIFFAILED(hr);

	VecPathNodes vecNodes;
	hr = MakeGlintPath( 1.0f, vecNodes );
	LMRETURNIFFAILED(hr);

	hr = CPathMaker::CreatePathBvr( m_pStatics, vecNodes, true, &pGlintPathBvr );
	
	CComPtr<IDALineStyle>	pLineStyleDefault;
	CComPtr<IDALineStyle>	pLineStyleOuter;
	CComPtr<IDALineStyle>	pLineStyleInner;
	CComPtr<IDAImage>		pImageOuter;
	CComPtr<IDAImage>		pImageInner;

	hr = CreateLineStyleBvr( &pLineStyleDefault );
	LMRETURNIFFAILED(hr);
	
	hr = pLineStyleDefault->Color( pColorPrimary, &pLineStyleInner );
	LMRETURNIFFAILED(hr);

	hr = pLineStyleDefault->Color( pColorSecondary, &pLineStyleOuter );
	LMRETURNIFFAILED(hr);

  	hr = pGlintPathBvr->Draw( pLineStyleInner, &pImageInner );
  	LMRETURNIFFAILED(hr);

  	hr = pBubblePathBvr->Draw( pLineStyleOuter, &pImageOuter );
  	LMRETURNIFFAILED(hr);

	hr = m_pStatics->Overlay( pImageInner, pImageOuter, &m_pBaseImage );
  	LMRETURNIFFAILED(hr);
	
	return		hr;
}

HRESULT
CBubbleMaker::CreateBasicSparkImageBvr( SparkOptions * pSparkOptions, IDANumber *, IDAImage ** ppBaseImage )
{
	HRESULT 	hr = S_OK;

	if ( m_pBaseImage == NULL )	return E_FAIL;

	*ppBaseImage = m_pBaseImage;
	(*ppBaseImage)->AddRef();
	
	return hr;
}

HRESULT
CBubbleMaker::MakeGlintPath( float fRadius, VecPathNodes& vecNodes )
{
	HRESULT	hr	= S_OK;
	
	fRadius *= 0.7f;

	static const float HANDLE_RATIO = 0.5522919f;
	float fHR = fRadius * HANDLE_RATIO;

	PathNode pn1, pn2, pn3, pn4;

	pn1.nAnchorType = 0;
	pn2.nAnchorType = 0;
	pn3.nAnchorType = 0;
	pn4.nAnchorType = 0;

	pn1.fAnchorX = -fRadius * 1.0f;		pn1.fAnchorY = 0.0f;
	pn2.fAnchorX = 0.0f;	            pn2.fAnchorY = fRadius * 1.0f;
	pn3.fAnchorX = 0.0f;            	pn3.fAnchorY = fRadius;
	pn4.fAnchorX = -fRadius;        	pn4.fAnchorY = 0.0f;

	pn1.fIncomingBCPX = pn1.fAnchorX;
	pn1.fIncomingBCPY = pn1.fAnchorY;
	pn1.fOutgoingBCPX = pn1.fAnchorX;
	pn1.fOutgoingBCPY = pn1.fAnchorY+fHR; 

	pn2.fIncomingBCPX = pn2.fAnchorX-fHR;
	pn2.fIncomingBCPY = pn2.fAnchorY; 
	pn2.fOutgoingBCPX = pn2.fAnchorX;
	pn2.fOutgoingBCPY = pn2.fAnchorY;

	pn3.fIncomingBCPX = pn3.fAnchorX;
	pn3.fIncomingBCPY = pn3.fAnchorY;
	pn3.fOutgoingBCPX = pn3.fAnchorX-fHR;
	pn3.fOutgoingBCPY = pn3.fAnchorY; 

	pn4.fIncomingBCPX = pn4.fAnchorX;
	pn4.fIncomingBCPY = pn4.fAnchorY+fHR; 
	pn4.fOutgoingBCPX = pn4.fAnchorX;
	pn4.fOutgoingBCPY = pn4.fAnchorY;

	vecNodes.push_back( pn1 );
	vecNodes.push_back( pn2 );
	vecNodes.push_back( pn3 );
	vecNodes.push_back( pn4 );
	
	return hr;
}

//**********************************************************************
// Cloud Maker
//**********************************************************************

CCloudMaker::CCloudMaker( IDA2Statics * pStatics ) :
	CSparkMaker( pStatics )
{
}

HRESULT
CCloudMaker::Init( SparkOptions * pOptions )
{
	HRESULT hr = CSparkMaker::Init( pOptions );
	LMRETURNIFFAILED(hr);

	// Smoke path
	//----------------------------------------------------------------------
	PathNode rgPathNodes[] = 
	{
		{-37.25f, 13.0f, -17.808838f, 9.077637f, -7.0f, 28.75f, 0},
		{24.5f, 16.5f, 19.0f, 5.5f, 25.0f, 7.5f, 0},
		{35.0f, 7.0f, 37.0f, 0.75f, 41.5f, 2.75f, 0},
		{47.75f, -2.25f, 46.75f, -6.25f, 74.5f, -9.5f, 0},
		{63.5f, -26.5f, 31.011475f, -21.54663f, 20.5f, -28.75f, 0},
		{-7.75f, -25.25f, -10.008911f, -21.6875f, -20.5f, -25.5f, 0},
		{-48.0f, -26.0f, -50.770508f, -19.394653f, -73.75f, -19.75f, 0},
		{-61.0f, -0.25f, -49.557495f, -4.092285f, -50.75f, 5.25f, 0}
	};

	CComPtr<IDAPath2>	pPathBvr;
	VecPathNodes		vecNodes;
	long	cNodes = sizeof( rgPathNodes ) / sizeof( rgPathNodes[0] );

	for ( int i = 0; i < cNodes; i++ )
	{
		vecNodes.push_back( rgPathNodes[i] );
	}
	
	hr = CPathMaker::CreatePathBvr( m_pStatics, vecNodes, true,
									&pPathBvr );
	LMRETURNIFFAILED(hr);

	// REVIEW: Scale the points here.
	CComPtr<IDATransform2>	pTransScale;
	hr = m_pStatics->Scale2Uniform( 0.25, &pTransScale );
	LMRETURNIFFAILED(hr);

	hr = pPathBvr->Transform( pTransScale, &m_pPathBvr );
	
	return		hr;
}

HRESULT
CCloudMaker::CreateBasicSparkImageBvr( SparkOptions * pOptions, IDANumber * pnumAgeRatio, IDAImage ** ppBaseImage )
{
	HRESULT 	hr = S_OK;

	CComPtr<IDANumber>		pnumHue;
	CComPtr<IDANumber>		pnumLum;
	CComPtr<IDANumber>		pnumSat;
	CComPtr<IDAColor>		pColorAnim;
	CComPtr<IDAImage>		pFillImage;
	HSL						hsl1 = pOptions->hslPrimary;
	HSL						hsl2 = pOptions->hslSecondary;

	// Interpolate between the 2 colors
	//----------------------------------------------------------------------
	hr = CDAUtils::TIMEInterpolateNumbers( m_pStatics, hsl1.hue, hsl2.hue, pnumAgeRatio, &pnumHue );
	LMRETURNIFFAILED(hr);
	
	hr = CDAUtils::TIMEInterpolateNumbers( m_pStatics, hsl1.sat, hsl2.sat, pnumAgeRatio, &pnumSat );
	LMRETURNIFFAILED(hr);
	
	hr = CDAUtils::TIMEInterpolateNumbers( m_pStatics, hsl1.lum, hsl2.lum, pnumAgeRatio, &pnumLum );
	LMRETURNIFFAILED(hr);

	hr = m_pStatics->ColorHslAnim( pnumHue, pnumSat, pnumLum, &pColorAnim );
	LMRETURNIFFAILED(hr);

	hr = m_pStatics->SolidColorImage( pColorAnim, &pFillImage );
	LMRETURNIFFAILED(hr);

	CComPtr<IDALineStyle> 	pLineStyleEmpty;
	hr = m_pStatics->get_EmptyLineStyle( &pLineStyleEmpty );
	LMRETURNIFFAILED(hr);

  	hr = m_pPathBvr->Fill( pLineStyleEmpty, pFillImage, ppBaseImage );
  	LMRETURNIFFAILED(hr);

	return hr;
}


//**********************************************************************
// Smoke Maker
//**********************************************************************

CSmokeMaker::CSmokeMaker( IDA2Statics * pStatics ) :
	CSparkMaker( pStatics )
{
}

HRESULT
CSmokeMaker::Init( SparkOptions * pOptions )
{
	HRESULT hr = CSparkMaker::Init( pOptions );
	LMRETURNIFFAILED(hr);

	// Smoke path
	//----------------------------------------------------------------------
	PathNode rgPathNodes[] = 
	{
		{-16.918701f, 11.05835f, -12.742432f, 11.241455f, -15.564819f, 17.944336f, 0},
		{-1.7054443f, 20.058594f, 0.23352051f, 15.299072f, 5.901123f, 20.333252f, 0},
		{17.907715f, 14.597412f, 13.137573f, 8.6188965f, 19.995728f, 12.034668f, 0},
		{24.321045f, 0.92907715f, 18.355103f, -0.04724121f, 24.171875f, -1.1456299f, 0},
		{24.917725f, -14.447876f, 11.643433f, -12.12915f, 13.582275f, -16.278564f, 0},
		{4.633423f, -19.939697f, -0.7359619f, -15.058105f, -5.0612793f, -20.305786f, 0},
		{-20.423706f, -16.522583f, -17.589844f, -7.6136475f, -21.616821f, -7.9798584f, 0},
		{-23.555786f, -3.4643555f, -19.976196f, -1.5117188f, -25.35852f, -0.043701172f, 0},
		{-23.321411f, 8.708008f, -15.725464f, 7.946289f, -15.725464f, 7.946289f, 0}
	};

	CComPtr<IDAPath2>	pPathBvr;
	VecPathNodes		vecNodes;
	long	cNodes = sizeof( rgPathNodes ) / sizeof( rgPathNodes[0] );

	for ( int i = 0; i < cNodes; i++ )
	{
		vecNodes.push_back( rgPathNodes[i] );
	}
	
	hr = CPathMaker::CreatePathBvr( m_pStatics, vecNodes, true,
									&pPathBvr );
	LMRETURNIFFAILED(hr);

	// REVIEW: Scale the points here.
	CComPtr<IDATransform2>	pTransScale;
	hr = m_pStatics->Scale2Uniform( 0.25, &pTransScale );
	LMRETURNIFFAILED(hr);

	hr = pPathBvr->Transform( pTransScale, &m_pPathBvr );
	
	return		hr;
}

HRESULT
CSmokeMaker::AddScaleTransforms( IDANumber * pnumAgeRatio, VecDATransforms& vecTransforms )
{
	HRESULT	hr	= S_OK;

	CComPtr<IDATransform2>	pTransScaleAnim;

	hr = m_pStatics->Scale2UniformAnim( pnumAgeRatio, &pTransScaleAnim );
	LMRETURNIFFAILED(hr);

	vecTransforms.push_back( pTransScaleAnim );
	
	return S_OK;
}

HRESULT
CSmokeMaker::CreateBasicSparkImageBvr( SparkOptions * pOptions, IDANumber * pnumAgeRatio, IDAImage ** ppBaseImage )
{
	HRESULT 	hr = S_OK;

	CComPtr<IDANumber>		pnumHue;
	CComPtr<IDANumber>		pnumLum;
	CComPtr<IDANumber>		pnumSat;
	CComPtr<IDAColor>		pColorAnim;
	CComPtr<IDAImage>		pFillImage;
	HSL						hsl1 = pOptions->hslPrimary;
	HSL						hsl2 = pOptions->hslSecondary;

	// Interpolate between the 2 colors
	//----------------------------------------------------------------------
	hr = CDAUtils::TIMEInterpolateNumbers( m_pStatics, hsl1.hue, hsl2.hue, pnumAgeRatio, &pnumHue );
	LMRETURNIFFAILED(hr);
	
	hr = CDAUtils::TIMEInterpolateNumbers( m_pStatics, hsl1.sat, hsl2.sat, pnumAgeRatio, &pnumSat );
	LMRETURNIFFAILED(hr);
	
	hr = CDAUtils::TIMEInterpolateNumbers( m_pStatics, hsl1.lum, hsl2.lum, pnumAgeRatio, &pnumLum );
	LMRETURNIFFAILED(hr);

	hr = m_pStatics->ColorHslAnim( pnumHue, pnumSat, pnumLum, &pColorAnim );
	LMRETURNIFFAILED(hr);

	hr = m_pStatics->SolidColorImage( pColorAnim, &pFillImage );
	LMRETURNIFFAILED(hr);

	CComPtr<IDALineStyle> 	pLineStyleEmpty;
	hr = m_pStatics->get_EmptyLineStyle( &pLineStyleEmpty );
	LMRETURNIFFAILED(hr);

  	hr = m_pPathBvr->Fill( pLineStyleEmpty, pFillImage, ppBaseImage );
  	LMRETURNIFFAILED(hr);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\behaviors\pathmaker.cpp ===
#include "headers.h" 

#include "pathmaker.h"

#include "..\chrome\src\dautil.h"
#include "..\chrome\include\utils.h"

typedef CComPtr<IDAPoint2> DAPoint2Ptr;
typedef CComPtr<IDANumber> DANumberPtr;

static const float PI		= 3.14159265359f;
static const float LINETO	= 2.0f;
static const float BEZIERTO = 4.0f;
static const float MOVETO	= 6.0f;
	
HRESULT
CPathMaker::CreatePathBvr( IDA2Statics * pStatics, VecPathNodes& vecNodes, bool fClosed, IDAPath2 ** ppPath )
{
	HRESULT	hr = S_OK;

	long cNodes = vecNodes.size();
	
	// don't loop around to beginning if path isn't closed.
	if ( !fClosed ) cNodes--;
	
	vector<DAPoint2Ptr> vecPoints;
	vector<DANumberPtr> vecCodes;
	
	// Move to 1st point
	//----------------------------------------------------------------------
	long				cPoints				= 0;
	CComPtr<IDANumber>	pnumCodeLineTo;
	CComPtr<IDANumber>	pnumCodeMoveTo;
	CComPtr<IDANumber>	pnumCodeBezierTo;
	CComPtr<IDAPoint2>	pPointFirst;
	
	hr = CDAUtils::GetDANumber( pStatics, LINETO, &pnumCodeLineTo );
	LMRETURNIFFAILED(hr);
	
	hr = CDAUtils::GetDANumber( pStatics, MOVETO, &pnumCodeMoveTo );
	LMRETURNIFFAILED(hr);

	hr = CDAUtils::GetDANumber( pStatics, BEZIERTO, &pnumCodeBezierTo );
	LMRETURNIFFAILED(hr);

	hr = pStatics->Point2( vecNodes[0].fAnchorX, vecNodes[0].fAnchorY, &pPointFirst );
	LMRETURNIFFAILED(hr);

	vecPoints.push_back( pPointFirst );
	vecCodes.push_back( pnumCodeMoveTo );
	cPoints++;

	// Add curves
	//----------------------------------------------------------------------
	for ( long liNode = 0; liNode < cNodes; liNode++ )
	{
		PathNode& nodePrev = vecNodes[ liNode ];
		PathNode& nodeNext = vecNodes[ (liNode+1) % cNodes ];

		CComPtr<IDAPoint2>	pPointAnchor;
		
		// Special case of linear bezier segment?
		//----------------------------------------------------------------------
		if ( ( nodePrev.fAnchorX == nodePrev.fOutgoingBCPX ) &&
			 ( nodePrev.fAnchorY == nodePrev.fOutgoingBCPY ) &&
			 ( nodeNext.fAnchorX == nodeNext.fIncomingBCPX ) &&
			 ( nodeNext.fAnchorY == nodeNext.fIncomingBCPY ) )
		{
			// Anchor point
			hr = pStatics->Point2( nodeNext.fAnchorX, nodeNext.fAnchorY,
								   &pPointAnchor );
			LMRETURNIFFAILED(hr);
		
			vecPoints.push_back( pPointAnchor );
			vecCodes.push_back( pnumCodeLineTo );
			cPoints++;
		}
		// Bezier curve segment
		//----------------------------------------------------------------------
		else
		{
			CComPtr<IDAPoint2>	pPointOutgoing; 
			CComPtr<IDAPoint2>	pPointIncoming; 

			// Outgoing point
			hr = pStatics->Point2( nodePrev.fOutgoingBCPX, nodePrev.fOutgoingBCPY,
								   &pPointOutgoing );
			LMRETURNIFFAILED(hr);
		
			vecPoints.push_back( pPointOutgoing );
			vecCodes.push_back( pnumCodeBezierTo );
			cPoints++;

			// Incoming point
			hr = pStatics->Point2( nodeNext.fIncomingBCPX, nodeNext.fIncomingBCPY,
								   &pPointIncoming );
			LMRETURNIFFAILED(hr);
		
			vecPoints.push_back( pPointIncoming );
			vecCodes.push_back( pnumCodeBezierTo );
			cPoints++;
		
			// Anchor point
			hr = pStatics->Point2( nodeNext.fAnchorX, nodeNext.fAnchorY,
								   &pPointAnchor );
			LMRETURNIFFAILED(hr);
		
			vecPoints.push_back( pPointAnchor );
			vecCodes.push_back( pnumCodeBezierTo );
			cPoints++;
		}
	}

	// Now tell DA to create the path bvr for us.
	//----------------------------------------------------------------------
	IDAPoint2 ** rgPoints = new IDAPoint2 * [ cPoints ];
	IDANumber ** rgCodes  = new IDANumber * [ cPoints ];

	if ( ( rgPoints == NULL ) || ( rgCodes == NULL ) )
	{
		delete [] rgPoints;
		delete [] rgCodes;
		return E_OUTOFMEMORY;
	}
	
	for ( long liPoint = 0; liPoint < cPoints; liPoint++ )
	{
		rgPoints[liPoint]	= vecPoints[liPoint];
		rgCodes[liPoint]	= vecCodes[liPoint];
	}
	
	hr = pStatics->PolydrawPathEx( cPoints, rgPoints, cPoints, rgCodes, ppPath );
	
	delete [] rgPoints;
	delete [] rgCodes;
	
	return hr;
}

//**********************************************************************

// Following the version in PathUtils.java
HRESULT
CPathMaker::CreateStarPath( int cArms,
							double dInnerRadius,
							double dOuterRadius,
							VecPathNodes& vecNodes )
{
	HRESULT	hr	= S_OK;

	if ( ( cArms < 3 ) ||
		 ( dInnerRadius < 0.0 ) ||
		 ( dOuterRadius < dInnerRadius ) )
	{
		return E_FAIL;
	}

	// Step angle: 360 degrees divided by number of arms.
	//----------------------------------------------------------------------
	double	dHalfStepAngle		= PI / cArms;
	double	dStepAngle			= 2.0 * dHalfStepAngle;
	double	dOffsetAngle		= PI / 2.0;

	// Move to first vertex
	//----------------------------------------------------------------------
	double	dOuterVertexX = dOuterRadius * cos( dOffsetAngle );
	double	dOuterVertexY = dOuterRadius * sin( dOffsetAngle );

	PathNode	node;

	node.fAnchorX = node.fOutgoingBCPX = node.fIncomingBCPX = dOuterVertexX;
	node.fAnchorY = node.fOutgoingBCPY = node.fIncomingBCPY = dOuterVertexY;
	node.nAnchorType = 0;
	vecNodes.push_back( node );

	double	dOuterVertexAngle;
	double	dInnerVertexAngle;
	double 	dInnerVertexX, dInnerVertexY;
		
	for ( int iArm = 0; iArm < cArms; iArm++ )
	{
		//	Compute angle for the (i + 1)th outer vertex
		//	and the angle for the i'th inner vertex.
		dOuterVertexAngle	= (iArm+1) * dStepAngle + dOffsetAngle;
		dInnerVertexAngle	= dOuterVertexAngle - dHalfStepAngle;

		//	Extend a line from the outer vertex of the current arm
		//	to the inner vertex between this arm and the next.
		dInnerVertexX = dInnerRadius * cos( dInnerVertexAngle );
		dInnerVertexY = dInnerRadius * sin( dInnerVertexAngle );
		
		node.fAnchorX = node.fOutgoingBCPX = node.fIncomingBCPX = dInnerVertexX;
		node.fAnchorY = node.fOutgoingBCPY = node.fIncomingBCPY = dInnerVertexY;
		node.nAnchorType = 0;
		vecNodes.push_back( node );

		//	Extend a line from the inner vertex between this arm and
		//	the next to the outer vertex of the next arm.  For the
		//	last arm this will extend a line back to the outer vertex
		//	of the very first arm.
		dOuterVertexX = dOuterRadius * cos( dOuterVertexAngle );
		dOuterVertexY = dOuterRadius * sin( dOuterVertexAngle );

		node.fAnchorX = node.fOutgoingBCPX = node.fIncomingBCPX = dOuterVertexX;
		node.fAnchorY = node.fOutgoingBCPY = node.fIncomingBCPY = dOuterVertexY;
		node.nAnchorType = 0;
		vecNodes.push_back( node );
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\idl\crbvrdispid.h ===
#ifndef __CRBEHAVIORDISPID_H_
#define __CRBEHAVIORDISPID_H_
//*********************************************************************************
//
// File: crbvrdispid.h
// Author: jeff ort
// Date Created: Sept 26, 1998
//
//
// Modification List:
// Date		Author		Change
// 09/26/98	jeffort		Created this file
//
//*********************************************************************************


// Since these are DHTML behaviors, we need to keep the
// dispid's low due to a MSHTML bug.  We will make each
// group have a base of 1, and increment from here

#define DISPID_COLORBVR_BASE						1
#define DISPID_ICRCOLORBVR_FROM						(DISPID_COLORBVR_BASE + 0)
#define DISPID_ICRCOLORBVR_TO						(DISPID_COLORBVR_BASE + 1)
#define DISPID_ICRCOLORBVR_PROPERTY					(DISPID_COLORBVR_BASE + 2)
#define DISPID_ICRCOLORBVR_DIRECTION				(DISPID_COLORBVR_BASE + 3)
#define DISPID_ICRCOLORBVR_ANIMATES					(DISPID_COLORBVR_BASE + 4)
#define DISPID_ICRCOLORBVR_BUILDBVRFRAGS			(DISPID_COLORBVR_BASE + 5)

#define DISPID_ROTATEBVR_BASE						1
#define DISPID_ICRROTATEBVR_FROM					(DISPID_ROTATEBVR_BASE + 0)
#define DISPID_ICRROTATEBVR_TO						(DISPID_ROTATEBVR_BASE + 1)
#define DISPID_ICRROTATEBVR_BY						(DISPID_ROTATEBVR_BASE + 2)
#define DISPID_ICRROTATEBVR_TYPE					(DISPID_ROTATEBVR_BASE + 3)
#define DISPID_ICRROTATEBVR_MODE					(DISPID_ROTATEBVR_BASE + 4)
#define DISPID_ICRROTATEBVR_ANIMATES				(DISPID_ROTATEBVR_BASE + 5)
#define DISPID_ICRROTATEBVR_BUILDBVRFRAGS			(DISPID_ROTATEBVR_BASE + 6)

#define DISPID_SCALEBVR_BASE						1
#define DISPID_ICRSCALEBVR_FROM						(DISPID_SCALEBVR_BASE + 0)
#define DISPID_ICRSCALEBVR_TO					    (DISPID_SCALEBVR_BASE + 1)
#define DISPID_ICRSCALEBVR_BY						(DISPID_SCALEBVR_BASE + 2)
#define DISPID_ICRSCALEBVR_TYPE						(DISPID_SCALEBVR_BASE + 3)
#define DISPID_ICRSCALEBVR_MODE						(DISPID_SCALEBVR_BASE + 4)
#define DISPID_ICRSCALEBVR_ANIMATES					(DISPID_SCALEBVR_BASE + 5)
#define DISPID_ICRSCALEBVR_BUILDBVRFRAGS			(DISPID_SCALEBVR_BASE + 6)

#define DISPID_MOVEBVR_BASE							1
#define DISPID_ICRMOVEBVR_FROM						(DISPID_MOVEBVR_BASE + 0)
#define DISPID_ICRMOVEBVR_TO						(DISPID_MOVEBVR_BASE + 1)
#define DISPID_ICRMOVEBVR_BY						(DISPID_MOVEBVR_BASE + 2)
#define DISPID_ICRMOVEBVR_ANIMATES					(DISPID_MOVEBVR_BASE + 3)
#define DISPID_ICRMOVEBVR_V							(DISPID_MOVEBVR_BASE + 4)
#define DISPID_ICRMOVEBVR_TYPE						(DISPID_MOVEBVR_BASE + 5)
#define DISPID_ICRMOVEBVR_MODE						(DISPID_MOVEBVR_BASE + 6)
#define DISPID_ICRMOVEBVR_DIRECTION					(DISPID_MOVEBVR_BASE + 7)
#define DISPID_ICRMOVEBVR_BUILDBVRFRAGS				(DISPID_MOVEBVR_BASE + 8)

#define DISPID_ICRMOVEBVR_CURRENTX					(DISPID_MOVEBVR_BASE + 9)
#define DISPID_ICRMOVEBVR_CURRENTY					(DISPID_MOVEBVR_BASE + 10)

#define DISPID_PATHBVR_BASE							1
#define DISPID_ICRPATHBVR_V							(DISPID_PATHBVR_BASE + 0)
#define DISPID_ICRPATHBVR_DATRANSFORM				(DISPID_PATHBVR_BASE + 1)

#define DISPID_NUMBERBVR_BASE						1
#define DISPID_ICRNUMBERBVR_FROM					(DISPID_NUMBERBVR_BASE + 0)
#define DISPID_ICRNUMBERBVR_TO						(DISPID_NUMBERBVR_BASE + 1)
#define DISPID_ICRNUMBERBVR_BY						(DISPID_NUMBERBVR_BASE + 2)
#define DISPID_ICRNUMBERBVR_TYPE					(DISPID_NUMBERBVR_BASE + 3)
#define DISPID_ICRNUMBERBVR_MODE					(DISPID_NUMBERBVR_BASE + 4)
#define DISPID_ICRNUMBERBVR_PROPERTY				(DISPID_NUMBERBVR_BASE + 5)
#define DISPID_ICRNUMBERBVR_EXPRESSION				(DISPID_NUMBERBVR_BASE + 6)
#define DISPID_ICRNUMBERBVR_ANIMATES				(DISPID_NUMBERBVR_BASE + 7)
#define DISPID_ICRNUMBERBVR_BUILDBVRFRAGS			(DISPID_NUMBERBVR_BASE + 8)

#define DISPID_SETBVR_BASE							1
#define DISPID_ICRSETBVR_VALUE						(DISPID_SETBVR_BASE + 0)
#define DISPID_ICRSETBVR_PROPERTY					(DISPID_SETBVR_BASE + 1)
#define DISPID_ICRSETBVR_TYPE						(DISPID_SETBVR_BASE + 2)
#define DISPID_ICRSETBVR_ANIMATES					(DISPID_SETBVR_BASE + 3)
#define DISPID_ICRSETBVR_BUILDBVRFRAGS				(DISPID_SETBVR_BASE + 4)

#define DISPID_ACTORBVR_BASE						1
#define DISPID_ICRACTORBVR_ANIMATES					(DISPID_ACTORBVR_BASE + 0)
#define DISPID_ICRACTORBVR_SCALE					(DISPID_ACTORBVR_BASE + 1)
#define DISPID_ICRACTORBVR_PIXELSCALE				(DISPID_ACTORBVR_BASE + 2)
#define DISPID_ICRACTORBVR_ADDBEHAVIORFRAGMENT		(DISPID_ACTORBVR_BASE + 3)
#define DISPID_ICRACTORBVR_ADDMOUSELISTENER			(DISPID_ACTORBVR_BASE + 4)
#define DISPID_ICRACTORBVR_REMOVEMOUSELISTENER		(DISPID_ACTORBVR_BASE + 5)
#define DISPID_ICRACTORBVR_GETACTORBEHAVIOR			(DISPID_ACTORBVR_BASE + 6)

#define DISPID_ICRACTORBVR_ADDBEHAVIORFRAGMENTEX	(DISPID_ACTORBVR_BASE + 7)
#define DISPID_ICRACTORBVR_REMOVEBEHAVIORFRAGMENT	(DISPID_ACTORBVR_BASE + 8)
#define DISPID_ICRACTORBVR_REQUESTREBUILD			(DISPID_ACTORBVR_BASE + 9)
#define DISPID_ICRACTORBVR_CANCELREBUILDREQUESTS	(DISPID_ACTORBVR_BASE + 10)
#define DISPID_ICRACTORBVR_REBUILDNOW				(DISPID_ACTORBVR_BASE + 11)
#define DISPID_ICRACTORBVR_GETSTATIC				(DISPID_ACTORBVR_BASE + 12)
#define DISPID_ICRACTORBVR_SETSTATIC				(DISPID_ACTORBVR_BASE + 13)
#define DISPID_ICRACTORBVR_GETDYNAMIC				(DISPID_ACTORBVR_BASE + 14)
#define DISPID_ICRACTORBVR_APPLYSTATICS				(DISPID_ACTORBVR_BASE + 15)
#define DISPID_ICRACTORBVR_APPLYDYNAMICS			(DISPID_ACTORBVR_BASE + 16)

#define DISPID_EFFECTBVR_BASE						1
#define DISPID_ICREFFECTBVR_TYPE					(DISPID_EFFECTBVR_BASE + 0)
#define DISPID_ICREFFECTBVR_ANIMATES				(DISPID_EFFECTBVR_BASE + 1)
#define DISPID_ICREFFECTBVR_CLASSID					(DISPID_EFFECTBVR_BASE + 2)
#define DISPID_ICREFFECTBVR_TRANSITION				(DISPID_EFFECTBVR_BASE + 3)
#define DISPID_ICREFFECTBVR_PROGID					(DISPID_EFFECTBVR_BASE + 4)
#define DISPID_ICREFFECTBVR_BUILDBVRFRAGS			(DISPID_EFFECTBVR_BASE + 5)
#define DISPID_ICREFFECTBVR_DIRECTION				(DISPID_EFFECTBVR_BASE + 6)
#define DISPID_ICREFFECTBVR_IMAGE					(DISPID_EFFECTBVR_BASE + 7)
		
#define DISPID_ACTIONBVR_BASE						1
#define DISPID_ICRACTION_BUILDBVRFRAGS				(DISPID_ACTIONBVR_BASE + 0)

//*********************************************************************************
//
// End of File
//
//*********************************************************************************
#endif //__CRBEHAVIORDISPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\idl\makefile.inc ===
$(SDKDIR)\crbvr.h : $(O)\crbvr.h
    copy /v $** $@

$(SDKDIR)\crbvr.tlb : $(O)\crbvr.tlb
    copy /v $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\actorbvr.h ===
#pragma once
#ifndef __ACTORBVR_H__
#define __ACTORBVR_H__
  
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:        actorbvr.h
//
// Author:          ColinMc
//
// Created:         10/15/98
//
// Abstract:        The CrIME Actor behavior.
//
// Modifications:
// 10/15/98 ColinMc Created this file
// 11/17/98 Kurtj	Added support for events and actor construction
// 11/18/98 kurtj   now animates the element to which it is attached
// 11/18/98 markhal	Added ApplyImageBvrToElement
// 11/19/98 markhal Added CColorBvrTrack
// 11/20/98 markhal Added CStringBvrTrack
//
//*****************************************************************************


//get the std library vector
#include <list>

#include <resource.h>
#include "basebvr.h"
#include "dispmethod.h"
#include "evtmgrclient.h"
#include "eventmgr.h"
#include "sampler.h"
#include "elementprop.h"

//*****************************************************************************

#ifdef    CRSTANDALONE
#define TYPELIBID &LIBID_ChromeBehavior
#else  // CRSTANDALONE
#define TYPELIBID &LIBID_LiquidMotion
#endif // CRSTANDALONE

//*****************************************************************************
//
// The Actor Behavior Class
//
// The intermediary between "real" behaviors and the actual element being
// animated.
// The Actor performs in a number of ways:
// *   Adds new properties to an HTML element that we wish were
//     just part of the element (like static rotation and scale).
// *   Abstracts away the necessary action code from the behavior
//     and underlying element (specifically rotating a VML element
//     is easy, rotating and HTML element is hard). The actor does
//     the mapping so the behavior doesn't have to worry about it.
// *   Disambiguates overlapping behaviors (either just letting one
//     win or composing them).
// See the file header for a description of the actor behavrtio
//
//*****************************************************************************

#define NUM_ACTOR_PROPS 3

typedef enum PosAttrib
{
	e_posattribLeft,
	e_posattribTop,
	e_posattribWidth,
	e_posattribHeight
}PosAttrib;

typedef enum ValueOnChangeType
{
	on_no_change,
	on_change,
	value_no_change,
	value_change
}ValueOnChangeType;

typedef enum PositioningType
{
	e_posAbsolute,
	e_posRelative,
	e_posStatic
} PositioningType;

typedef enum UnitType
{
	e_unknownUnit = -1,
	e_in = 0,
	e_cm,
	e_mm,
	e_pt,
	e_pc,
	e_em,
	e_ex,
	e_px,
	e_percent
} UnitType;

//where a ratio is lNum/lDenom
struct Ratio
{
	long lNum;
	long lDenom;
};

class CActorBvr;

class COnResizeHandler: public CDispatchMethod
{
public:
	COnResizeHandler( CActorBvr* parent );
	~COnResizeHandler();

	void Invalidate() { m_pActor = NULL; }

	HRESULT HandleEvent();
private:
	CActorBvr *m_pActor;
};

class COnUnloadHandler: public CDispatchMethod
{
public:
	COnUnloadHandler(CActorBvr* parent);
	~COnUnloadHandler();

	void Invalidate(){ m_pActor = NULL; }

	HRESULT HandleEvent();
private:
	CActorBvr *m_pActor;
};


class CVarEmptyString
{
public:
	CVarEmptyString();
	~CVarEmptyString();

	const VARIANT	*GetVar();
private:
	VARIANT m_varEmptyString;
};//CVarEmptyString

class CBehaviorRebuild;
typedef std::list<CBehaviorRebuild*> BehaviorRebuildList;

class CBehaviorFragmentRemoval;
typedef std::list<CBehaviorFragmentRemoval*> BehaviorFragmentRemovalList;

class ATL_NO_VTABLE CActorBvr :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CActorBvr, &CLSID_CrActorBvr>,
    public IConnectionPointContainerImpl<CActorBvr>,
    public IPropertyNotifySinkCP<CActorBvr>,
    public IPersistPropertyBag2,
    public IDispatchImpl<ICrActorBvr2, &IID_ICrActorBvr2, TYPELIBID>,
    public IElementBehavior,
	public IEventManagerClient,
	public IPropertyNotifySink,
    public CBaseBehavior,
	public IElementLocalTimeListener
{

// COM Map
BEGIN_COM_MAP(CActorBvr)
    COM_INTERFACE_ENTRY(ICrActorBvr)
	COM_INTERFACE_ENTRY(ICrActorBvr2)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IElementBehavior)
	COM_INTERFACE_ENTRY(IPersistPropertyBag2)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IPropertyNotifySink)
END_COM_MAP()

// Connection Point to allow IPropertyNotifySink 
BEGIN_CONNECTION_POINT_MAP(CActorBvr)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

    //*************************************************************************
    //
    // Nested classes
    //
    //*************************************************************************

    //*************************************************************************
    //
    // class CTimelineSampler
    //
    //*************************************************************************
	class CBvrTrack;

	class CTimelineSampler : public CSampler
	{
	private:
		CBvrTrack *m_pTrack;
		double m_prevSample;
		double m_currSample;
		double m_prevSampleTime;
		double m_currSampleTime;
		double m_lastOnTime;
		double m_lastOffTime;
		int    m_signDerivative;
		bool   m_fRestarted;

	public:
							CTimelineSampler(CBvrTrack *pTrack);
		DWORD				RestartMask();
		void				TurnOn();
		void				TurnOff();

		static HRESULT TimelineCallback(void *thisPtr,
									  long id,
									  double startTime,
									  double globalNow,
									  double localNow,
									  IDABehavior * sampleVal,
								      IDABehavior **ppReturn);

	};

    //*************************************************************************
    //
    // class CBvrTrack
    //
    //*************************************************************************

    class CBvrTrack
    {
	protected:
        //*********************************************************************
        //
        // class CBvrFragment
        //
        // Private class which represents a single fragment in the list of
        // behaviors for a track.
        //
        //*********************************************************************

        class CBvrFragment
        {
        public:
        
			ActorBvrFlags	m_eFlags;				// The flags
            IDABehavior    *m_pdabvrAction;         // The action action to take.
            IDABoolean     *m_pdaboolActive;        // True when this behavior is
                                                    // active
			IDANumber	   *m_pdanumTimeline;		// Goes from 0 to dur for the behavior
			IDABehavior	   *m_pModifiableIntermediate;// A modifiable behavior
													// representing the composed
													// behaviors so far. Used in getIntermediate
			IDABehavior	   *m_pModifiableFrom;		// A switchable behavior representing from

			IHTMLElement   *m_pelemBehaviorElement; //a pointer to the IHTMLElement of the element
													// to which the behavior that added this fragment
													//  is attached
			long			m_lCookie;				//the cookie that uniquely identifies this fragment in this actor

			CBvrFragment   *m_pfragNext;			//The next fragment in the list


                            CBvrFragment(ActorBvrFlags eFlags,
										 IDABehavior *pdabvrAction,
                                         IDABoolean  *pdaboolActive,
										 IDANumber	 *pdanumTimeline,
										 IDispatch	 *pdispBehaviorElement,
								         long 		 lCookie);
                           ~CBvrFragment();

			//returns the long that fragments should be compared with for sorting and
			//  searching.
			long GetOrderLong() const;

			//returns the cookie that uniquely identifies this behavior fragment for this actor
			long GetCookie() const;


        }; // CBvrFragment

	protected:

		bool			m_bStyleProp;			// True if we are animating a style property
        CActorBvr      *m_pbvrActor;            // Our parent actor
        BSTR            m_bstrPropertyName;     // Name of property being animated
		BSTR		   *m_pNameComponents;		// Array of components making up the property name
		int				m_cNumComponents;		// Number of components
        ActorBvrType    m_eType;                // Type of this track
		

		CBvrFragment   *m_pfragAbsListHead;		//pointer to the head of the absolute fragment list

		CBvrFragment   *m_pfragRelListHead;     //pointer to the head of the relative fragment list

        IDABehavior    *m_pdabvrFinal;          // Final computed bvr.
		bool			m_bFinalComputed;		// True if final has been computed
		bool			m_bFinalExternallySet;  // True if someone external set the final bvr
		bool			m_fApplied;				// True if this track has already been applied
		
		IDABehavior	   *m_pdabvrComposed;		// The composed bvr
		bool			m_bComposedComputed;	// True if composed has been computed
		IDABehavior	   *m_pModifiableStatic;	// A modifiable behavior representing
		IDABehavior	   *m_pModifiableComposed;	// A modifiable behavior representing the composed behavior
		IDABehavior	   *m_pModifiableFinal;  	// A modifiable behavior representing the final behavior
												// the static behavior.  Used in getIntermediate
		IDABehavior	   *m_pModifiableFrom;		// A modifiable behavior representing a returned from behavior
		IDABehavior    *m_pModifiableIntermediate; //the cached value for the intermediate value that the next 
												   //fragment to be added has requested.
        CBvrTrack      *m_pNext;                // Next track in the track list

		int				m_cFilters;		// True if a filter has been added to the relative list

		bool			m_bDoNotApply;			// True if the track should not be applied

		CSampler		*m_pOnSampler;			//samples the bvr that tells us whether or not this track
												// is on
		VARIANT_BOOL	m_varboolOn;				//VARIANT_TRUE when one of the fragments in this track is on
												// VARIANT_FALSE otherwise.

		CSampler		*m_pIndexSampler;		// Sampler for absolute index

		CSampler		**m_ppMaskSamplers;		// Samplers for masks

		DWORD			*m_pCurrMasks;			// Current mask values

		DWORD			*m_pNewMasks;			// New mask values

		CTimelineSampler **m_ppTimelineSamplers; // Samplers for timeline

		int				m_numIndices;			// The count of indices we are tracking

		int				m_numMasks;				// The count of masks we are tracking

		IDANumber		*m_pIndex;

		int				m_currIndex;

		double			*m_pIndexTimes;			// Times when the absolute behaviors became active

		IDABehavior		**m_ppAccumBvrs;			// Accumulated behaviors for e_RelativeAccum

		static CVarEmptyString s_emptyString;		//a static variable containing the empty string

        HRESULT         ComposeAbsBvrFragList(IDABehavior *pStatic, IDABehavior **ppdabvrComposite);
        HRESULT         ComposeRelBvrFragList(IDABehavior *pAbsolute, IDABehavior **ppdabvrComposite);

		IDABoolean		*m_pdaboolOn;
        bool			m_fOnSampled;
        VARIANT			m_varStaticValue;
        VARIANT         m_varCurrentValue;
		bool			m_fValueSampled;
		bool			m_fValueChangedThisSample;
		bool			m_fForceValueChange;
		long 			m_lOnId;

		long			m_lFirstIndexId;

		HRESULT			UpdateOnValueState( ValueOnChangeType type );

		//tracking of behaivors added to TIME
		DWORD			m_dwAddedBehaviorFlags;

		long			m_lOnCookie;

		bool			m_bDirty; //true if this track has been modified in some way.

		bool			m_bWasAnimated;

		bool			IsRelativeTrack( ActorBvrFlags eFlags );


		HRESULT			AddBehaviorToTIME( IDABehavior *pdabvrToAdd, long* plCookie, DWORD flag );
		HRESULT			RemoveBehaviorFromTIME( long lCookie, DWORD flag );

		void			InsertInOrder( CBvrFragment** vect, CBvrFragment* pfragToInsert );

		bool			FindFragmentInList( CBvrFragment *pfragListHead,
											long cookie, 
											CBvrFragment** ppfragPrev,
											CBvrFragment** ppfragFragment );


		bool			m_fChangesLockedOut;
		bool			m_fSkipNextStaticUpdate;

		virtual HRESULT			UpdateStaticBvr();

		virtual HRESULT	GetComposedBvr(IDABehavior *pStatic, IDABehavior **ppComposite, bool fStaticSetExternally );

		virtual HRESULT	GetFinalBvr(IDABehavior *pStatic, IDABehavior **ppFinal, bool fStaticSetExternally );

		bool			AttribIsTimeAnimated();

		
    public:
                        CBvrTrack(CActorBvr *pbvrActor, ActorBvrType eType);
        virtual        ~CBvrTrack();

        CActorBvr*      Actor(void) const;

        HRESULT         SetPropertyName(BSTR bstrPropertyName);

        HRESULT         AddBvrFragment(ActorBvrFlags  eFlags,
                                       IDABehavior   *pdabvrAction,
                                       IDABoolean    *pdaboolActive,
									   IDANumber	 *pdanumTimline,
									   IDispatch	 *pdispBehaivorElement,
									   long			 *pCookie);

		HRESULT			RemoveBvrFragment( ActorBvrFlags eFlags,
										   long cookie );

		bool			IsRelativeFragment( ActorBvrFlags eFlags );

		HRESULT         ApplyBvrToElement(IDABehavior *pBvr);

		HRESULT			SetPropFromVariant(VARIANT *pVal);

		void			DoNotApply()	{ m_bDoNotApply = true; }

		virtual HRESULT HookBvr(IDABehavior *pBvr) { return E_FAIL; }

		virtual HRESULT HookAccumBvr(IDABehavior *pBvr, IDABehavior **ppResult) { return E_FAIL; }

        // Return an identity behavior for this type of behavior track. The
        // actual type of this behavior is dependent on the track type, for
        // example, for number behaviors this is simply a DA number behavior
        // for the value zero, for a move behavior its a translation of 0, 0 etc.
        // Each behavior track type must override this and provide the appropriate
        // type of identity behavior
        virtual HRESULT IdentityBvr(IDABehavior **ppdabvrIdentity) = 0;

        // Return the static behavior for this behavior track. This involves
        // querying the actor for the properties initial value, converting
        // that property value into an appropriate type for track type and
        // building a DA behavior which simply holds that value forever.
        virtual HRESULT StaticBvr(IDABehavior** ppdabvrStatic) = 0;

		// Return an uninitialized behavior for this behavior track
		virtual HRESULT UninitBvr(IDABehavior **ppUninit);

		//Return a switchable behavior for this behavior track
		virtual HRESULT ModifiableBvr( IDABehavior **ppModifiable );

		//Return a switchable behavior for this behavior track that has pdabvrInitialValue as
		// its initial value.
		virtual HRESULT ModifiableBvr( IDABehavior* pdabvrInitalValue, IDABehavior **ppModifiable);

		// Return the inverse behavior for this track
		virtual HRESULT InverseBvr(IDABehavior *pOriginal, IDABehavior **ppInverse) { return E_NOTIMPL; }

        // Compose two relative behaviors together. The actual composition action
        // is dependent on the type of the behavior track. For example, for number
        // behaviors this is a simple addition, for move behaviors this is a
        // translation etc.
        // Each behavior track type must override this and provide the appropriate
        // type of composition action
        virtual HRESULT Compose(IDABehavior  *pdabvr1,
                                IDABehavior  *pdabvr2,
                                IDABehavior **ppdabvrResult) = 0;

		// Called to process the behavior before it is composed
		virtual HRESULT ProcessBvr(IDABehavior *pOriginal,
								   ActorBvrFlags eFlags,
								   IDABehavior **ppResult);
        //Called to process the intermediate behavior before it is used to initialize the
        //  intermediate value for a track.
        virtual HRESULT ProcessIntermediate( IDABehavior *pOriginal,
                                             ActorBvrFlags eFlags,
								             IDABehavior **ppResult);

		// Computes the composed bvr value, given a static value
		virtual HRESULT ComputeComposedBvr(IDABehavior *pStatic, bool fStaticSetExternally );

		// Returns the composed bvr value, given a static value
		virtual HRESULT	GetComposedBvr(IDABehavior *pStatic, IDABehavior **ppComposite);

		// Returns the composed bvr value, computing the static value itself
		virtual HRESULT GetComposedBvr(IDABehavior **ppComposite);
		
		// Returns the final bvr value, given a static value
		virtual HRESULT	GetFinalBvr(IDABehavior *pStatic, IDABehavior **ppFinal);

		// Returns the final bvr value, computing the static value itself
        virtual HRESULT GetFinalBvr(IDABehavior **ppFinal);

		// Sets the final bvr value - probably means that someone got the composed
		// value, did something to it, and are now setting it back as the final bvr
		virtual HRESULT SetFinalBvr(IDABehavior *pFinal, bool fCalledExternally = true);

		// Returns a bvr value (static, intermediate, composed, or final)
		virtual HRESULT	GetBvr(ActorBvrFlags eFlags, IDABehavior **ppResult);

		// Builds and applies the final bvr to the track's property, but only if
		// noone has called ComputeFinalBvr or GetFinalBvr, which implies that the track
		// has been used already.
        virtual HRESULT ApplyIfUnmarked(void);

		//Rebuilds the track after changes have been made.  Does nothing if
		// the track is not dirty.
		virtual HRESULT BeginRebuild(void);

		//forces a rebuild of this track even if it has not had any fragments added to it
		// or removed from it.
		virtual HRESULT ForceRebuild();

		inline bool IsDirty(){return m_bDirty;}

		inline bool IsAnimated() {return (m_pfragRelListHead != NULL || m_pfragAbsListHead != NULL || m_bFinalExternallySet ); }

		inline bool IsOn(){ return m_varboolOn != VARIANT_FALSE; }

        virtual HRESULT CleanTrackState( void );

		virtual bool	ContainsFilter();

		virtual HRESULT SwitchAccum(IDABehavior *pModifiable);

		HRESULT			GetTrackOn( IDABoolean **ppdaboolAbsoluteOn );
		HRESULT			OrWithOnBvr( IDABoolean *pdaboolToOr );

		void			ReleaseAllFragments();

		//called by m_pOnSampler when the overall on boolean is sampled by DA.
		static HRESULT OnCallback(void *thisPtr,
								  long id,
								  double startTime,
								  double globalNow,
								  double localNow,
								  IDABehavior * sampleVal,
								  IDABehavior **ppReturn);

		HRESULT	OnSampled( VARIANT_BOOL varboolOn );

		//called by m_pIndexSampler when the index into the absolute bvr list changes.
		static HRESULT IndexCallback(void *thisPtr,
								  long id,
								  double startTime,
								  double globalNow,
								  double localNow,
								  IDABehavior * sampleVal,
								  IDABehavior **ppReturn);

		//called by mask sampler
		static HRESULT MaskCallback(void *thisPtr,
								  long id,
								  double startTime,
								  double globalNow,
								  double localNow,
								  IDABehavior * sampleVal,
								  IDABehavior **ppReturn);

		HRESULT			ComputeIndex(long id, double currTime, IDABehavior **ppReturn);

		//detach this track from anything that might call it back
		// this should be called before any modifications to the track are made.
		virtual HRESULT	Detach();

		virtual HRESULT PutStatic( VARIANT *pvarStatic );
		HRESULT	SkipNextStaticUpdate();

		virtual HRESULT GetStatic( VARIANT *pvarStatic );

		virtual HRESULT GetDynamic( VARIANT *pvarDynamic );

		virtual HRESULT DABvrFromVariant( VARIANT *pvarValue, IDABehavior **ppdabvr );

		HRESULT			AcquireChangeLockout();
		HRESULT			ReleaseChangeLockout();

		HRESULT			ApplyStatic();
		HRESULT			ApplyDynamic();

		//called when the structure around the behavior output by this track could change
		//  This will cause the track to ditch the behavior ids that it is currently using
		//  to track its da behaviors.  It will pick up new ones on the next sample.
		void			StructureChange() { m_lFirstIndexId = -1; m_lOnId = -1; }
		
        friend CActorBvr;
    }; // CBvrTrack

    //*****************************************************************************
    //
    // class CTransformBvrTrack
    //
    //*****************************************************************************

    class CTransformBvrTrack :
        public CBvrTrack
    {
	private:
		CSampler		*m_pSampler;
		double			m_lastX;
		double			m_lastY;
		long			m_lTransformId;

    public:
                        CTransformBvrTrack(CActorBvr *pbvrActor, ActorBvrType eType);
		virtual			~CTransformBvrTrack();
        virtual HRESULT IdentityBvr(IDABehavior **ppdabvrIdentity);
        virtual HRESULT StaticBvr(IDABehavior **ppdabvrStatic);
		virtual HRESULT UninitBvr(IDABehavior **ppUninit);
		virtual HRESULT ModifiableBvr( IDABehavior **ppModifiable );
		virtual HRESULT InverseBvr(IDABehavior *pOriginal, IDABehavior **ppInverse);
        virtual HRESULT Compose(IDABehavior  *pdabvr1,
                                IDABehavior  *pdabvr2,
                                IDABehavior **ppdabvrResult);


		virtual HRESULT SwitchAccum(IDABehavior *pModifiable);

		virtual HRESULT HookAccumBvr(IDABehavior *pBvr, IDABehavior **ppResult);

		HRESULT GetAbsoluteMapTransform2( IDATransform2 **ppdatfm2Map );

        static HRESULT  CreateInstance(CActorBvr     *pbvrActor,
                                       BSTR           bstrPropertyName,
                                       ActorBvrType   eType,
                                       CBvrTrack    **pptrackResult);

		static HRESULT TransformCallback(void *thisPtr,
									  long id,
									  double startTime,
									  double globalNow,
									  double localNow,
									  IDABehavior * sampleVal,
								      IDABehavior **ppReturn);

    }; // CTransformBvrTrack

    //*****************************************************************************
    //
    // class CNumberBvrTrack
    //
    //*****************************************************************************

    class CNumberBvrTrack :
        public CBvrTrack    
    {
	private:
		CSampler		*m_pSampler;				// Our sampler
		double			m_currVal;
		double			m_currStatic;
		CSampler		*m_pAccumSampler;
		double			m_currAccumVal;
		long			m_lAccumId;
		BSTR			m_bstrUnits;

		long			m_lNumberCookie;
		long			m_lNumberId;

		bool			m_fSkipNextStaticUpdate;

    public:
                        CNumberBvrTrack(CActorBvr *pbvrActor, ActorBvrType eType);
		virtual			~CNumberBvrTrack();
        virtual HRESULT IdentityBvr(IDABehavior **ppdabvrIdentity);
        virtual HRESULT StaticBvr(IDABehavior **ppdabvrStatic);
		virtual HRESULT UninitBvr(IDABehavior **ppUninit);
		virtual HRESULT ModifiableBvr( IDABehavior **ppModifiable );
		virtual HRESULT ModifiableBvr( IDABehavior* pdabvrInitalValue, IDABehavior **ppModifiable);
		virtual HRESULT InverseBvr(IDABehavior *pOriginal, IDABehavior **ppInverse);
        virtual HRESULT Compose(IDABehavior  *pdabvr1,
                                IDABehavior  *pdabvr2,
                                IDABehavior **ppdabvrResult);

		virtual HRESULT SwitchAccum(IDABehavior *pModifiable);

		virtual HRESULT HookBvr(IDABehavior *pBvr);

		virtual HRESULT HookAccumBvr(IDABehavior *pBvr, IDABehavior **ppResult);

		HRESULT			ValueSampled(double val, bool firstSample );

        static HRESULT  CreateInstance(CActorBvr     *pbvrActor,
                                       BSTR           bstrPropertyName,
                                       ActorBvrType   eType,
                                       CBvrTrack    **pptrackResult);

		static HRESULT NumberCallback(void *thisPtr,
									  long id,
									  double startTime,
									  double globalNow,
									  double localNow,
									  IDABehavior * sampleVal,
								      IDABehavior **ppReturn);

		static HRESULT AccumNumberCallback(void *thisPtr,
									  long id,
									  double startTime,
									  double globalNow,
									  double localNow,
									  IDABehavior * sampleVal,
								      IDABehavior **ppReturn);

		BSTR GetUnits();

		virtual HRESULT Detach();

		virtual HRESULT DABvrFromVariant( VARIANT *pvarValue, IDABehavior **ppdabvr );
		

    }; // CNumberBvrTrack

    //*****************************************************************************
    //
    // class CImageBvrTrack
    //
    //*****************************************************************************

    class CImageBvrTrack :
        public CBvrTrack
    {
    public:
						CImageBvrTrack(CActorBvr *pbvrActor, ActorBvrType eType);
        virtual HRESULT IdentityBvr(IDABehavior **ppdabvrIdentity);
        virtual HRESULT StaticBvr(IDABehavior **ppdabvrStatic);
		virtual HRESULT UninitBvr(IDABehavior **ppUninit);
		virtual HRESULT ModifiableBvr( IDABehavior **ppModifiable );
        virtual HRESULT Compose(IDABehavior  *pdabvr1,
                                IDABehavior  *pdabvr2,
                                IDABehavior **ppdabvrResult);
		virtual HRESULT ProcessBvr(IDABehavior *pOriginal,
								   ActorBvrFlags eFlags,
								   IDABehavior **ppResult);
        virtual HRESULT ProcessIntermediate( IDABehavior *pOriginal,
                                             ActorBvrFlags eFlags,
								             IDABehavior **ppResult);

        static HRESULT  CreateInstance(CActorBvr     *pbvrActor,
                                       BSTR           bstrPropertyName,
                                       ActorBvrType   eType,
                                       CBvrTrack    **pptrackResult);
    }; // CImageBvrTrack

    //*****************************************************************************
    //
    // class CColorBvrTrack
    //
    //*****************************************************************************

    class CColorBvrTrack :
        public CBvrTrack
    {
	private:
		CSampler	*m_pRedSampler;
		CSampler	*m_pGreenSampler;
		CSampler	*m_pBlueSampler;
		short		m_currRed;
		short		m_currGreen;
		short		m_currBlue;
		short		m_newRed;
		short		m_newGreen;
		short		m_newBlue;
		short		m_newCount;

		//time cookie tracking
		long 		m_lRedCookie;
		long		m_lGreenCookie;
		long		m_lBlueCookie;
		long		m_lColorId;

		bool		m_fFirstSample;

    public:
						CColorBvrTrack(CActorBvr *pbvrActor, ActorBvrType eType);
		virtual			~CColorBvrTrack();
        virtual HRESULT IdentityBvr(IDABehavior **ppdabvrIdentity);
        virtual HRESULT StaticBvr(IDABehavior **ppdabvrStatic);
		virtual HRESULT UninitBvr(IDABehavior **ppUninit);
		virtual HRESULT ModifiableBvr( IDABehavior ** ppModifiable );
        virtual HRESULT Compose(IDABehavior  *pdabvr1,
                                IDABehavior  *pdabvr2,
                                IDABehavior **ppdabvrResult);

		virtual HRESULT HookBvr(IDABehavior *pBvr);
		virtual HRESULT HookAccumBvr(IDABehavior *pBvr, IDABehavior **ppResult);
		virtual HRESULT SwitchAccum(IDABehavior *pModifiable);

		HRESULT			SetNewValue(double value, short *pNew );
		HRESULT			ValueSampled(short red, short green, short blue, bool fFirstSample );
		inline OLECHAR	HexChar(short n) { return (n<=9) ? (L'0'+n) : (L'A' + (n-10)); }

        static HRESULT  CreateInstance(CActorBvr     *pbvrActor,
                                       BSTR           bstrPropertyName,
                                       ActorBvrType   eType,
                                       CBvrTrack    **pptrackResult);

		static HRESULT RedCallback(void *thisPtr,
									  long id,
									  double startTime,
									  double globalNow,
									  double localNow,
									  IDABehavior * sampleVal,
								      IDABehavior **ppReturn);

		static HRESULT GreenCallback(void *thisPtr,
									  long id,
									  double startTime,
									  double globalNow,
									  double localNow,
									  IDABehavior * sampleVal,
								      IDABehavior **ppReturn);

		static HRESULT BlueCallback(void *thisPtr,
									  long id,
									  double startTime,
									  double globalNow,
									  double localNow,
									  IDABehavior * sampleVal,
								      IDABehavior **ppReturn);

		virtual HRESULT Detach();

		virtual HRESULT DABvrFromVariant( VARIANT *pvarValue, IDABehavior **ppdabvr );



    }; // CColorBvrTrack

    //*****************************************************************************
    //
    // class CStringBvrTrack
    //
    //*****************************************************************************

    class CStringBvrTrack :
        public CBvrTrack
    {
	protected:
		IDAString		*m_pEmptyString;
		CSampler		*m_pSampler;
		BSTR			m_bstrCurrValue;

		//time cookie tracking
		long			m_lStringCookie;

		long 			m_lStringId;

    public:
						CStringBvrTrack(CActorBvr *pbvrActor, ActorBvrType eType);
		virtual			~CStringBvrTrack();

        virtual HRESULT IdentityBvr(IDABehavior **ppdabvrIdentity);
        virtual HRESULT StaticBvr(IDABehavior **ppdabvrStatic);
        virtual HRESULT Compose(IDABehavior  *pdabvr1,
                                IDABehavior  *pdabvr2,
                                IDABehavior **ppdabvrResult);

		virtual HRESULT HookBvr(IDABehavior *pBvr);

		HRESULT			ValueSampled(BSTR bstrValue, bool fFirstSample );

        static HRESULT  CreateInstance(CActorBvr     *pbvrActor,
                                       BSTR           bstrPropertyName,
                                       ActorBvrType   eType,
                                       CBvrTrack    **pptrackResult);

		static HRESULT StringCallback(void *thisPtr,
									  long id,
									  double startTime,
									  double globalNow,
									  double localNow,
									  IDABehavior * sampleVal,
								      IDABehavior **ppReturn);

		virtual HRESULT Detach();

		virtual HRESULT DABvrFromVariant( VARIANT *pvarValue, IDABehavior **ppdabvr );
    }; // CStringBvrTrack

    //*****************************************************************************
    //
    // class CFloatManager
    //
    //*****************************************************************************

	class CFloatManager
	{
	protected:
		CActorBvr		*m_pActor;
		IDispatch		*m_pFilter;
		IHTMLElement	*m_pElement;
		IHTMLElement2	*m_pElement2;
		CSampler		*m_pWidthSampler;
		CSampler		*m_pHeightSampler;
		double			 m_currWidth;
		double			 m_currHeight;
		long			 m_origWidth;
		long			 m_origHeight;
		long			 m_origLeft;
		long			 m_origTop;

		long			 m_lWidthCookie;
		long			 m_lHeightCookie;
	public:
						CFloatManager(CActorBvr *pActor);
						~CFloatManager();

		HRESULT			GetElement(IHTMLElement **ppElement);
		HRESULT			GetFilter(IDispatch **ppFilter);
		HRESULT			Detach();
		HRESULT			ApplyImageBvr(IDAImage *pImage);
		HRESULT			HookBvr(IDABehavior *pBvr,
								SampleCallback callback,
								CSampler **ppSampler,
								long *plCookie);
		HRESULT			UpdateElementRect();

		HRESULT			UpdateZIndex();
		HRESULT			UpdateVisibility();
		HRESULT			UpdateDisplay();

		HRESULT			UpdateRect(long left, long top, long width, long height);

		static HRESULT	widthCallback(void *thisPtr,
									  long id,
									  double startTime,
								      double globalNow,
								      double localNow,
								      IDABehavior * sampleVal,
									  IDABehavior **ppReturn);

		static HRESULT	heightCallback(void *thisPtr,
									  long id,
									  double startTime,
								      double globalNow,
								      double localNow,
								      IDABehavior * sampleVal,
								      IDABehavior **ppReturn);

		friend	CActorBvr;

	};
    //*****************************************************************************
    //
    // class CImageInfo
    //
    //*****************************************************************************
	class CImageInfo
	{
	public:

		CImageInfo( IDA2Image* pdaimg2Cropped, IDA2Behavior* pdabvrSwitchable );
		~CImageInfo();

		void			SetNext( CImageInfo* pNext );
		CImageInfo		*GetNext();
		IDA2Image		*GetCroppedNoRef(); //does not add a reference to the bvr
		IDA2Behavior	*GetSwitchableNoRef(); //does not add a reference to the bvr

	private:
		CImageInfo		*m_pNext;
		IDA2Image		*m_pdaimg2Cropped;
		IDA2Behavior	*m_pdabvr2Switchable;

		friend CActorBvr;
	};

	//*****************************************************************************
    //
    // class CFinalDimensionSampler
    //
    //*****************************************************************************
	class CFinalDimensionSampler
	{
	public:
		CFinalDimensionSampler(CActorBvr *pParent );
		~CFinalDimensionSampler( );
		
		HRESULT Attach( IDANumber* pFinalWidth, IDANumber *pFinalHeight );
		HRESULT	Detach();

	private:

		CActorBvr					   *m_pActor;

		CSampler					   *m_pFinalWidthSampler;
		CSampler					   *m_pFinalHeightSampler;
		bool							m_fFinalWidthSampled;
		bool							m_fFinalHeightSampled;
		long							m_lFinalWidthId;
		long							m_lFinalHeightId;
		double							m_dLastFinalWidthValue;
		double							m_dLastFinalHeightValue;
		bool							m_fFinalDimensionChanged;

		HRESULT							CollectFinalDimensionSamples( );

		static HRESULT					FinalWidthCallback(void *thisPtr,
															long id,
															double startTime,
															double globalNow,
															double localNow,
															IDABehavior * sampleVal,
															IDABehavior **ppReturn);
		static HRESULT					FinalHeightCallback(void *thisPtr,
															long id,
															double startTime,
															double globalNow,
															double localNow,
															IDABehavior * sampleVal,
															IDABehavior **ppReturn);

	public:
		CActorBvr						*Actor() { return m_pActor; }

		long							m_lWidthCookie;
		long							m_lHeightCookie;
		friend CActorBvr;
	};

	//*****************************************************************************
    //
    // class CCookieMap
    //
    //*****************************************************************************
	class CCookieMap
	{
	public:
		class CCookieData
		{
		public:
			CCookieData( long lCookie, CBvrTrack *pTrack, ActorBvrFlags eFlags );

			long m_lCookie;
			
			CBvrTrack* m_pTrack;
			ActorBvrFlags m_eFlags;

			CCookieData *m_pNext;
		};
	public:
		CCookieMap();
		~CCookieMap();

		void Insert( long lCookie, CBvrTrack* pTrack, ActorBvrFlags eFlags );
		void Remove( long lCookie );
		void Clear();
		CCookieData *GetDataFor( long lCookie );
	private:
		CCookieData *m_pHead;


		friend CActorBvr;
	};


public:

DECLARE_REGISTRY_RESOURCEID(IDR_ACTORBVR)

                                    CActorBvr();
                                   ~CActorBvr();
    HRESULT                         FinalConstruct();

    // IElementBehavior
    STDMETHOD(Init)                 (IElementBehaviorSite *pBehaviorSite);
    STDMETHOD(Notify)               (LONG event, VARIANT *pVar);
    STDMETHOD(Detach)               (void);

    // ICrActorBvr
	STDMETHOD(put_animates)			(VARIANT  varAnimates);
	STDMETHOD(get_animates)			(VARIANT* pvarAnimates);
    STDMETHOD(put_scale)            (VARIANT  varScale);
    STDMETHOD(get_scale)            (VARIANT *pvarScale);
    STDMETHOD(put_pixelScale)		(VARIANT  varPixelScale);
    STDMETHOD(get_pixelScale)		(VARIANT *pvarPixelScale);

	STDMETHOD(getActorBehavior)		(BSTR			bstrProperty,
									 ActorBvrFlags	eFlags,
									 ActorBvrType	eType,
									 VARIANT		*pvarRetBvr);

    STDMETHOD(addBehaviorFragment)  (BSTR           bstrProperty,
                                     IUnknown      *punkAction,
                                     IUnknown      *punkActive,
									 IUnknown	   *punkTimline,
                                     ActorBvrFlags  eFlags,
                                     ActorBvrType   eType);
	
    STDMETHOD(addMouseEventListener)		(IUnknown * pUnkListener );
    STDMETHOD(removeMouseEventListener)		(IUnknown * pUnkListener );

	//ICrActorBvr2

    STDMETHOD(addBehaviorFragmentEx)    (BSTR           bstrProperty,
                                         IUnknown      *punkAction,
                                         IUnknown      *punkActive,
									     IUnknown	   *punkTimline,
                                         ActorBvrFlags  eFlags,
                                         ActorBvrType   eType,
		                                 IDispatch     *pdispBehaviorElement,
										 long          *pCookie);
	STDMETHOD(removeBehaviorFragment)	( long cookie );
	STDMETHOD(requestRebuild)			( IDispatch *pdispBehaviorElement );
	// A behavior should call this if they are removed with a rebuild request pending.
	STDMETHOD(cancelRebuildRequests)	( IDispatch *pdispBehaviorElement );
	STDMETHOD(rebuildNow)				();

	STDMETHOD(getStatic)				( BSTR bstrTrackName, VARIANT *varRetStatic );
	STDMETHOD(setStatic)				( BSTR bstrTrackName, VARIANT varStatic );

	STDMETHOD(getDynamic)				( BSTR bstrTrackName, VARIANT *varRetDynamic );

	STDMETHOD(applyStatics)				( );
	STDMETHOD(applyDynamics)			( );

	//IPersistPropertyBag2 methods
    STDMETHOD(GetClassID)(CLSID* pclsid);
	STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void){return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

	// IPropertyNotifySink methods
	STDMETHOD(OnChanged)(DISPID dispID);
	STDMETHOD(OnRequestEdit)(DISPID dispID);
 

	// IEventManagerClient
	virtual IHTMLElement*			GetElementToSink		();
	virtual IElementBehaviorSite*	GetSiteToSendFrom		();
	virtual HRESULT					TranslateMouseCoords	( long x, long y, long * pxTrans, long * pyTrans );

	//Event callbacks
	virtual void					OnLoad					();
	virtual void					OnUnload				();
	virtual void					OnReadyStateChange		( e_readyState state );

	//IElementLocalTimeListener
	STDMETHOD(OnLocalTimeChange)( float localTime );

    HRESULT                         GetTypeInfo(ITypeInfo **ppInfo);
    // Needed by CBaseBehavior
    void * 	GetInstance() { return (ICrActorBvr *) this ; }
	
protected:
	HRESULT							UpdatePixelDimensions();

    virtual HRESULT                 BuildAnimationAsDABehavior();
	HRESULT							BuildChildren();
	HRESULT							BuildAnimation();
    virtual VARIANT *				VariantFromIndex(ULONG iIndex);
    virtual HRESULT					GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropName);
    virtual HRESULT					GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);
    virtual WCHAR *					GetBehaviorTypeAsURN(){return DEFAULT_ACTOR_URN;};
    // The actor does not need an actor attached to what it
    // is animating since it is this.
    virtual HRESULT					AttachActorBehaviorToAnimatedElement();
	HRESULT							InitPropertySink();
	HRESULT							UnInitPropertySink();
	HRESULT							GetCurrStyleNotifyConnection(IConnectionPoint **ppConnection);
	HRESULT							InitPixelWidthHeight();

	//rebuilds all the dirty tracks in this actor and all of the elements of the actor that need
	//  to be rebuilt as a result of those rebuilds.
	HRESULT							RebuildActor();
	HRESULT							ProcessPendingRebuildRequests();

	//returns S_OK if any of the transform tracks is dirty, and S_FALSE otherwise.
	HRESULT							TransformTrackIsDirty( DWORD *pdwState );
	bool							IsAnyTrackDirty(); //returns true if a track is dirty.

	//returns S_OK if the image track is dirty, and S_FALSE otherwise.
	HRESULT							ImageTrackIsDirty();

public:
	HRESULT							ApplyImageBvrToFloatElement(IDAImage *pImage);
	HRESULT							SetElementOnFilter();
	HRESULT							SetElementOnFilter(IDispatch *pFilter, IHTMLElement *pElement);
	HRESULT							GetElementFilter(IDispatch **pFilter);
	HRESULT							GetElementFilter(IHTMLElement *pElement, IDispatch **ppFilter);

	HRESULT							RemoveElementFilter( );
	HRESULT							RemoveElementFilter( IHTMLElement* pElement );

	HRESULT							OnWindowUnload();

private:
    // Properties
	VARIANT                         m_varAnimates;
    VARIANT                         m_varScale;
	VARIANT							m_varPixelScale;

	bool							m_bEditMode;

	PositioningType					m_desiredPosType;

	PositioningType					m_currPosType;

	bool							m_simulDispNone;
	bool							m_simulVisHidden;

	DWORD							m_dwAdviseCookie;

    static WCHAR				   *m_rgPropNames[NUM_ACTOR_PROPS]; 

    IDATransform2                  *m_pScale;				 // Final composite scale bvr
    IDATransform2                  *m_pRotate;				 // Final composite rotate bvr
    IDATransform2                  *m_pTranslate;			 // Final composite translate bvr

	IDAPoint2					   *m_pOrigLeftTop;			 // Original top and left (before scales and translates)
	IDAVector2					   *m_pOrigWidthHeight;		 // Original width and height

	IDANumber					   *m_pPixelWidth;			 // The width of the element in pixels
	IDANumber					   *m_pPixelHeight;

	long							m_pixelWidth;
	long							m_pixelHeight;

	long							m_pixelLeft;
	long							m_pixelTop;

	long 							m_nextFragmentCookie;	 //The next cookie for a behavior fragment  starts at 1

	IDAPoint2					   *m_pBoundsMin;			 // Bounds of the element (in DA coord space)
	IDAPoint2					   *m_pBoundsMax;

    IDAVector2					   *m_pTransformCenter;		 // Center of transform

	IDAImage					   *m_pElementImage;		 // Image filtered from element

	IDispatch					   *m_pElementFilter;		 // The filter on the element

    CBvrTrack                      *m_ptrackHead;            // Head of track list

    CBvrTrack				   	   *m_ptrackTop;			 //the top track
    CBvrTrack				   	   *m_ptrackLeft;			 //the left track

	CEventMgr					   *m_pEventManager;		 //The manager for events coming from the DOM

	CFloatManager				   *m_pFloatManager;		 // The manager for the float element

	IHTMLStyle					   *m_pRuntimeStyle;		 // The runtimeStyle object of the element we are animating

	IHTMLStyle					   *m_pStyle;				 // The style object of the element we are animating

	IDispatch					   *m_pVMLRuntimeStyle;		 // The runtimeStyle object from VML


	IDispatch					   *m_pBodyElement;			 // The body element


	CCookieMap						m_mapCookieToTrack;		 //map from cookie to the fragment to which it corresponds to

	bool							m_fRebuildRequested;	 //true if a rebuild of the graph has been requested

	CElementPropertyMonitor		   *m_pBodyPropertyMonitor;	 //monitors props on the body element

	//body event monitor management
	HRESULT							EnsureBodyPropertyMonitorAttached(); //attached the body prop monitor if it isn't already
	HRESULT							AttachBodyPropertyMonitor();  //attaches the body prop monitor to the body of the
															   //  document of the element to which this actor is attached
	HRESULT							DetachBodyPropertyMonitor();  //detaches the body prop monitor from the body, but does not
															   // destroy it.
	HRESULT							DestroyBodyPropertyMonitor(); //destroy the body prop monitor

	COnResizeHandler				*m_pOnResizeHandler;//a handler for the onresize event on the animated element.
	COnUnloadHandler				*m_pOnUnloadHandler;//a handler for the onunload event on IHTMLWindow3 

	bool							m_fUnloading;

	bool							m_fVisSimFailed;

	HRESULT							AttachEvents(); //attaches to events on the animated element
	HRESULT							DetachEvents(); //detaches from events on the animated element


	BehaviorFragmentRemovalList		m_listPendingRemovals;
	BehaviorRebuildList				m_listPendingRebuilds;
	BehaviorRebuildList				m_listUpdatePendingRebuilds;
	bool							m_bPendingRebuildsUpdating;
	bool							m_bRebuildListLockout;
	void							ReleaseRebuildLists();

	inline long				        GetNextFragmentCookie();  //returns the next fragment cookie

	//Image management
	CImageInfo					   *m_pImageInfoListHead;	//The head of the image info list
	HRESULT						    AddImageInfo( IDA2Image* pdaimgCropped, IDABehavior* pdabvrSwitchable );
	HRESULT						    SetRenderResolution( double dX, double dY );

	// Methods

	//returns DANumbers that represent the final dimensions of the animated element.  When a floating Div is 
	//  being used, the width and height returned are the width and height of that div.  Otherwise the width
	//  and height returned are those of the animated element itself, as changed by all behaviors.
	HRESULT						   GetFinalElementDimension( IDANumber** ppdanumWidth, IDANumber** ppdanumHeight);
	HRESULT						   SetFinalElementDimension( IDANumber* pdanumWidth, IDANumber* pdanumHeight, bool fHook );
	IDANumber					   *m_pdanumFinalElementWidth;
	IDANumber					   *m_pdanumFinalElementHeight;
	CFinalDimensionSampler		   *m_pFinalElementDimensionSampler;

    // Methods

    void                            DiscardBvrCache(void);

	//DATIME Cookie tracking
	DWORD							m_dwAddedBehaviorFlags;

	long							m_lOnCookie;

	HRESULT							AddBehaviorToTIME( IDABehavior *pbvrAdd, long *plCookie );
	HRESULT							AddBehaviorToTIME( IDABehavior *pbvrAdd );
	HRESULT							RemoveBehaviorFromTIME( long cookie );

    // BUGBUG (ColinMc): These methods should be encapsulated in a track manager class.
    HRESULT							FindTrack(LPWSTR       wzPropertyName,
                                              ActorBvrType eType,
											  CBvrTrack **ppTrack);
	HRESULT							FindTrackNoType(LPWSTR       wzPropertyName,
       												CBvrTrack	 **ppTrack);
   
    HRESULT                         CreateTrack(BSTR           bstrPropertyName,
                                                ActorBvrType   eType,
                                                CBvrTrack    **pptrack);
    HRESULT                         GetTrack(BSTR           bstrPropertyName,
                                             ActorBvrType   eType,
                                             CBvrTrack    **pptrack);
	DWORD							m_dwCurrentState;
	HRESULT							GetCurrentState( DWORD *pdwState );
	HRESULT							UpdateCurrentState( );

	HRESULT							IsStaticRotationSet( bool *pfIsSet );
	HRESULT							IsStaticScaleSet( bool *pfIsSet );

	HRESULT							UpdateLayout();

	HRESULT							RequestRebuildFromExternal();

public:
    HRESULT                         GetPropAsDANumber(IHTMLElement *pElement,
													  LPWSTR       *pPropNames,
													  int		    numPropNames,
                                                      IDANumber   **ppdanum,
													  BSTR		    *pRetUnits);

    HRESULT                         GetElementPropAsDANumber(LPWSTR     *pPropNames,
															 int		 numPropNames,
                                                             IDANumber **ppdanum,
															 BSTR		*pRetUnits);

	HRESULT							GetPropFromElement(IHTMLElement *pElement,
													   LPWSTR		*pPropNames,
													   int			 numPropNames,
													   bool			 current,
													   VARIANT		*varResult);
													   
	HRESULT							GetPropFromAnimatedElement( LPWSTR		*pPropNames,
																int			numPropNames,
																bool		current,
																VARIANT		*pvarResult );

	HRESULT							GetPropertyAsDispatch(IDispatch *pDispatch,
														  BSTR name,
														  IDispatch **ppDispatch);

	HRESULT							GetPropertyOnDispatch(IDispatch *pDispatch,
														  BSTR name,
														  VARIANT *pReturn);

	HRESULT							SetPropertyOnDispatch(IDispatch *pDispatch,
														  BSTR name,
														  VARIANT *pVal);

	HRESULT							GetElementImage(IDAImage **ppElementImage);

	HRESULT							GetOriginalTranslation( IDATransform2 **ppdatfmOrig );
	HRESULT							GetOriginalRotation( IDANumber **ppRotation );
	HRESULT							GetOriginalScale( IDATransform2 **ppdatfmOrig );
	HRESULT							IsAnimatedElementVML(bool *pResult);
	HRESULT							GetAnimatedElement(IHTMLElement** ppElem);
	HRESULT							GetAnimatedElementId(VARIANT *pvarId);
	HRESULT							GetRuntimeStyle(IHTMLStyle **ppStyle);
	HRESULT							GetCurrentStyle(IHTMLCurrentStyle **ppResult);
	HRESULT							GetStyle(IHTMLStyle **ppStyle);
	HRESULT							SetVMLAttribute(BSTR propertyName, VARIANT *pVal);
	HRESULT							ConvertToDegrees(IDANumber *pNumber, BSTR units, IDANumber **ppConverted);

	double							MapGlobalTime(double gTime);
	bool							IsAnimatingVML();

	HRESULT							AnimatedElementOnResize();

private:
	HRESULT							GetPositioningAttributeAsVariant( IHTMLElement *pElement, PosAttrib attrib, VARIANT *pvarAttrib );

	HRESULT							GetPositioningAttributeAsDouble( IHTMLElement *pElement, PosAttrib attrib, double *pDouble, BSTR *pRetUnits);
	HRESULT							GetPositioningAttributeAsDANumber( IHTMLElement *pElement, PosAttrib attrib, IDANumber **ppdanum, BSTR *pRetUnits );
	HRESULT							FindCSSUnits( BSTR bstrValWithUnits, OLECHAR** ppUnits );
	HRESULT							GetCurrentStyle( IHTMLElement *pElement, IHTMLCurrentStyle **ppstyleCurrent );

	HRESULT							GetComposedBvr(LPWSTR          wzPropertyName,
												   ActorBvrType    eType,
												   IDABehavior   **ppResult);

	HRESULT							GetFinalBvr(LPWSTR          wzPropertyName,
												ActorBvrType    eType,
												IDABehavior   **ppResult);
	
	HRESULT                         GetTransformFinalBvr(LPWSTR          wzPropertyName,
                                                         ActorBvrType    eType,
                                                         IDATransform2 **ppdabvrScale);

	HRESULT							GetRotationFinalBvr(IDATransform2 **ppRotation);

//    HRESULT                         GetTopLeftBvr(IDAPoint2 **ppdapnt2TopLeft);
//    HRESULT                         GetWidthHeightBvr(IDAVector2 **ppdavct2WidthHeight);
	HRESULT							BuildTransformCenter();
	HRESULT							ConvertTransformCenterUnits(IDAVector2 **ppCenter);
	HRESULT							GetUnitConversionBvr(BSTR bstrFrom, BSTR bstrTo, IDANumber ** ppnumConvert, double dPixelPerPercent=1.0);
	HRESULT							GetUnitToMeterBvr(BSTR bstrUnit, IDANumber ** ppnumConvert, double dPixelPerPercent=1.0);
	HRESULT							GetPixelsPerPercentValue(double& dPixelPerPercentX, double& dPixelPerPercentY);
	
//    HRESULT                         ApplyTransformsToHTMLElement(void);

	HRESULT							ApplyImageTracks();
	HRESULT							ApplyTransformTracks();

    HRESULT                         PrepareImageForDXTransform( IDAImage *pOriginal, IDAImage **ppResult);
	HRESULT							ApplyClipToImage( IDAImage *pImageIn, IDAPoint2 *pMin, IDAPoint2 *pMax, IDAImage** ppImageOut );


	HRESULT							CallBuildBehaviors( IDispatch *pDisp, DISPPARAMS *pParams, VARIANT* pResult );

	HRESULT							ProcessRebuildRequests();
	
	//resource management
	HRESULT							ReleaseAnimation();
	void							ReleaseFinalElementDimensionSampler();
	void							ReleaseFloatManager();
	void							ReleaseTracks();
	void							ReleaseImageInfo();
	void							ReleaseEventManager();

	HRESULT							CalculateVGXLeftPixelOffset( IHTMLElement *pelem, long *plOffset );
	HRESULT							GetInlineMarginLeftAsPixel( IHTMLStyle *pstyleInline, long* plMargin );

	HRESULT							CalculateVGXTopPixelOffset( IHTMLElement *pelem, long *plOffset );
	HRESULT							GetInlineMarginTopAsPixel( IHTMLStyle *pstyleInline, long* plMargin );

	HRESULT							GetMarginLeftAsPixel( IHTMLElement *pelem, IHTMLCurrentStyle *pstyleCurrent, long *plMargin);
	HRESULT							GetMarginTopAsPixel( IHTMLElement* pelem, IHTMLCurrentStyle *pstyleCurrent, long *plMargin);
	HRESULT							GetPixelValue( VARIANT *pvarStringWithUnit, long *plResult, bool bHorizontal );
	HRESULT							VariantToPixelLong( VARIANT* pvar, long* pLong, bool fHorizontal );

	bool							IsDocumentInEditMode();

	HRESULT							GetBodyElement(IDispatch **ppResult);
	HRESULT							GetParentWindow( IHTMLWindow2 **ppWindow );
	HRESULT							InitVisibilityDisplay();
	HRESULT							UpdateVisibilityDisplay();
	HRESULT							UpdateDesiredPosition();

	HRESULT							VisSimSetOffscreen( IHTMLStyle *pRuntimeStyle, bool fResample );

	HRESULT							DebugPrintBoundingClientRect();

	static Ratio					s_unitConversion[5][5];

	int								GetPixelsPerInch( bool fHorizontal );
	UnitType						GetUnitTypeFromString( LPOLESTR strUnits );

	IConnectionPoint				*m_pcpCurrentStyle;

	friend CCookieMap;
	friend CFloatManager;
	friend CBvrTrack;
	friend CNumberBvrTrack;
	friend CImageBvrTrack;
	friend CTransformBvrTrack;
	friend CColorBvrTrack;
	friend CStringBvrTrack;
	friend CImageInfo;
	friend CFinalDimensionSampler;

}; // CActorBvr


//*****************************************************************************
//
// Helper Classes
//
//*****************************************************************************

class CBehaviorRebuild
{
public:
	
					CBehaviorRebuild				( IDispatch *pdispBehaviorElem );
					~CBehaviorRebuild				();

	HRESULT			RebuildBehavior				( DISPPARAMS *pParams, VARIANT* pResult );
	bool			IsRebuildFor				( IUnknown* punkBehaviorElem ) { return m_punkBehaviorElem == punkBehaviorElem; }
	
private:

	IDispatch *m_pdispBehaviorElem;
	IUnknown  *m_punkBehaviorElem;
};

class CBehaviorFragmentRemoval
{
public:
					CBehaviorFragmentRemoval( long cookie ):m_lCookie(cookie){}
					~CBehaviorFragmentRemoval(){}

	long			GetCookie() { return m_lCookie; }
private:
	long			m_lCookie;
};


//*****************************************************************************
//
// Inlines
//
//*****************************************************************************

inline const VARIANT*
CVarEmptyString::GetVar()
{
	return &m_varEmptyString;
}

//*****************************************************************************

inline CActorBvr*
CActorBvr::CBvrTrack::Actor(void) const
{
    DASSERT(NULL != m_pbvrActor);
    return m_pbvrActor;
} // Actor

//*****************************************************************************

inline
CActorBvr::CImageBvrTrack::CImageBvrTrack(CActorBvr *pbvrActor, ActorBvrType eType)
:   CBvrTrack(pbvrActor, eType)
{
} // CImageBvrTrack

//*****************************************************************************

inline BSTR
CActorBvr::CNumberBvrTrack::GetUnits()
{
	return m_bstrUnits;
}

//*****************************************************************************

inline
void
CActorBvr::CImageInfo::SetNext( CActorBvr::CImageInfo* pNext )
{
	m_pNext = pNext;
}

//*****************************************************************************

inline
CActorBvr::CImageInfo *
CActorBvr::CImageInfo::GetNext()
{
	return m_pNext;
}

//*****************************************************************************

inline
IDA2Image*
CActorBvr::CImageInfo::GetCroppedNoRef()
{
	return m_pdaimg2Cropped;
}

//*****************************************************************************

inline
IDA2Behavior*
CActorBvr::CImageInfo::GetSwitchableNoRef()
{
	return m_pdabvr2Switchable;
}

//*****************************************************************************


inline HRESULT
CActorBvr::GetTypeInfo(ITypeInfo **ppInfo)
{
    return GetTI(GetUserDefaultLCID(), ppInfo);
} // GetTypeInfo

//*****************************************************************************

inline long
CActorBvr::GetNextFragmentCookie()
{
	//always skip 0
	if( m_nextFragmentCookie + 1 == 0 )
		m_nextFragmentCookie ++;
	return m_nextFragmentCookie++;
}

//*****************************************************************************
//
// End of File
//
//*****************************************************************************

#endif // __ACTORBVR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\autobase.h ===
#pragma once
#ifndef __CRAUTOBASE_H__
#define __CRAUTOBASE_H__

//*****************************************************************************
//
// FileName:	    autobase.h
//
// Created:	    10/08/97
//
// Author:	    ColinMc
//
// Abstract:	    The base class for all automatable objects
//                  in Trident3D. Stuff that is common across
//                  all scriptable objects should be placed
//                  here
//
// Modifications:
// 10/08/97 ColinMc Created this file
//
//*****************************************************************************


class ATL_NO_VTABLE CAutoBase
{

protected:
    // The constructor and destructor are protected to ensure
    // nobody external ever tries to create one of these
    // babies
		    CAutoBase();
    virtual        ~CAutoBase();

public:
    // Automation compatible error reporting functions
    HRESULT         SetErrorInfo(HRESULT   hr,
			         UINT      nDescriptionID = 0U,
			         LPGUID    pguidInterface = NULL,
			         DWORD     dwHelpContext  = 0UL,
			         LPOLESTR  szHelpFile    = NULL,
			         UINT      nProgID        = 0U);
    void            ClearErrorInfo();

protected:
    HRESULT         GetErrorInfo(IErrorInfo** pperrinfo);
    HINSTANCE       GetErrorModuleHandle();
}; // CAutoBase

//*****************************************************************************
//
// End of file
//
//*****************************************************************************

#endif // __CRAUTOBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\attrib.h ===
#pragma once
#ifndef __ATTRIB_H_
#define __ATTRIB_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    attrib.h
//
// Author:	jeffort
//
// Created:	10/07/98
//
// Abstract:    definition of attribute strings
// Modifications:
// 10/07/98 jeffort created file
//
//*****************************************************************************

#define BEHAVIOR_TYPE_COLOR                L"color"
#define BEHAVIOR_TYPE_ROTATE               L"rotate"
#define BEHAVIOR_TYPE_SCALE                L"scale"
#define BEHAVIOR_TYPE_MOVE                 L"move"
#define BEHAVIOR_TYPE_PATH                 L"path"
#define BEHAVIOR_TYPE_NUMBER               L"number"
#define BEHAVIOR_TYPE_SET                  L"set"
#define BEHAVIOR_TYPE_ACTOR                L"actor"
#define BEHAVIOR_TYPE_EFFECT               L"effect"
#define BEHAVIOR_TYPE_ACTION			   L"action"
#define BEHAVIOR_TYPE_DA                   L"da"

#define BEHAVIOR_PROPERTY_BY               L"by"
#define BEHAVIOR_PROPERTY_TO               L"to"
#define BEHAVIOR_PROPERTY_FROM             L"from"
#define BEHAVIOR_PROPERTY_DIRECTION        L"direction"
#define BEHAVIOR_PROPERTY_PROPERTY         L"property"
#define BEHAVIOR_PROPERTY_ANIMATES         L"animates"
#define BEHAVIOR_PROPERTY_V                L"v"
#define BEHAVIOR_PROPERTY_EXPRESSION       L"expression"
#define BEHAVIOR_PROPERTY_VALUE            L"value"

#define BEHAVIOR_PROPERTY_TYPE             L"type"
#define BEHAVIOR_PROPERTY_MODE			   L"mode"
#define BEHAVIOR_PROPERTY_CLASSID          L"classid"
#define BEHAVIOR_PROPERTY_TRANSITION       L"transition"
#define BEHAVIOR_PROPERTY_PROGID           L"progid"

#define BEHAVIOR_PROPERTY_OFFSET           L"offset"
#define BEHAVIOR_PROPERTY_DIRECTION        L"direction"
#define BEHAVIOR_PROPERTY_IMAGE		       L"image"

#define BEHAVIOR_PROPERTY_ROTATION		   L"rotation"
#define BEHAVIOR_PROPERTY_SCALE			   L"scale"
#define BEHAVIOR_PROPERTY_TRANSFORMCENTER  L"transformcenter"
#define BEHAVIOR_PROPERTY_PIXELSCALE	   L"pixelscale"

#define BEHAVIOR_TYPE_ABSOLUTE			   L"absolute"
#define BEHAVIOR_TYPE_RELATIVE		       L"relative"

#define BEHAVIOR_DIRECTION_CLOCKWISE       L"clockwise"
#define BEHAVIOR_DIRECTION_NOHUE           L"nohue"
#define BEHAVIOR_DIRECTION_COUNTERCLOCKWISE L"cclockwise"
//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif //__ATTRIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\action.h ===
#pragma once
#ifndef __ACTION_H_
#define __ACTION_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    action.h
//
// Author:	kurtj
//
// Created:	11/23//98
//
// Abstract:    set behavior class definition
// Modifications:
// 11/23/98 kurtj created file
//
//*****************************************************************************

#include <resource.h>
#include "basebvr.h"

#define NUM_ACTION_PROPS 0

//*****************************************************************************

class ATL_NO_VTABLE CActionBvr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CActionBvr, &CLSID_CrActionBvr>,
    public IConnectionPointContainerImpl<CActionBvr>,
    public IPropertyNotifySinkCP<CActionBvr>,
    public IPersistPropertyBag2,
#ifdef CRSTANDALONE
	public IDispatchImpl<ICrActionBvr, &IID_ICrActionBvr, &LIBID_ChromeBehavior>,
    error me here
#else
	public IDispatchImpl<ICrActionBvr, &IID_ICrActionBvr, &LIBID_LiquidMotion>,
#endif // CRSTANDALONE
	public IElementBehavior,
    public CBaseBehavior
	
{

BEGIN_COM_MAP(CActionBvr)
	COM_INTERFACE_ENTRY(ICrActionBvr)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IElementBehavior)
	COM_INTERFACE_ENTRY(IPersistPropertyBag2)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

// Connection Point to allow IPropertyNotifySink 
BEGIN_CONNECTION_POINT_MAP(CActionBvr)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

public:
DECLARE_REGISTRY_RESOURCEID(IDR_ACTIONBVR)

	CActionBvr();
    virtual ~CActionBvr();
    HRESULT FinalConstruct();
    // IElementBehavior
    //
	STDMETHOD(Init)(IElementBehaviorSite *pBehaviorSite);
	STDMETHOD(Notify)(LONG event, VARIANT *pVar);
	STDMETHOD(Detach)();

    // Needed by CBaseBehavior
    void * 	GetInstance() { return (ICrActionBvr *) this ; }
	
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }

    //ICrActionBvr
	STDMETHOD(buildBehaviorFragments)( IDispatch* pActorDisp );

	//IPersistPropertyBag2 methods
    STDMETHOD(GetClassID)(CLSID* pclsid);
	STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void){return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

protected:
    virtual HRESULT BuildAnimationAsDABehavior();
    virtual VARIANT *VariantFromIndex(ULONG iIndex);
    virtual HRESULT GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropName);
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);

	HRESULT BuildChildren( IDispatch *pdispActor );
	HRESULT CallBuildBehaviors( IDispatch *pDisp, DISPPARAMS *pParams, VARIANT *pResult );

private:
	static WCHAR                *m_rgPropNames[NUM_ACTION_PROPS]; 


}; // CActionBvr

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif //__ACTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\colorbvr.h ===
#pragma once
#ifndef __COLORBVR_H_
#define __COLORBVR_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    colorbvr.h
//
// Author:	jeffort
//
// Created:	10/07/98
//
// Abstract:    color behavior class definition
// Modifications:
// 10/07/98 jeffort created file
// 11/19/98 markhal added buildBehaviorFragments
//
//*****************************************************************************

#include <resource.h>
#include "basebvr.h"

#define NUM_COLOR_PROPS 4

//*****************************************************************************

class ATL_NO_VTABLE CColorBvr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CColorBvr, &CLSID_CrColorBvr>,
    public IConnectionPointContainerImpl<CColorBvr>,
    public IPropertyNotifySinkCP<CColorBvr>,
    public IPersistPropertyBag2,
#ifdef CRSTANDALONE
	public IDispatchImpl<ICrColorBvr, &IID_ICrColorBvr, &LIBID_ChromeBehavior>,
    error me here
#else
	public IDispatchImpl<ICrColorBvr, &IID_ICrColorBvr, &LIBID_LiquidMotion>,
#endif // CRSTANDALONE
	public IElementBehavior,
    public CBaseBehavior
	
{

BEGIN_COM_MAP(CColorBvr)
	COM_INTERFACE_ENTRY(ICrColorBvr)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IElementBehavior)
	COM_INTERFACE_ENTRY(IPersistPropertyBag2)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

// Connection Point to allow IPropertyNotifySink 
BEGIN_CONNECTION_POINT_MAP(CColorBvr)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

public:
DECLARE_REGISTRY_RESOURCEID(IDR_COLORBVR)

	CColorBvr();
    virtual ~CColorBvr();
    HRESULT FinalConstruct();
    // IElementBehavior
    //
	STDMETHOD(Init)(IElementBehaviorSite *pBehaviorSite);
	STDMETHOD(Notify)(LONG event, VARIANT *pVar);
	STDMETHOD(Detach)();

    // Needed by CBaseBehavior
    void * 	GetInstance() { return (ICrColorBvr *) this ; }
	
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }

    // ICrColorBehavior
	STDMETHOD(put_from)(VARIANT varFrom);
	STDMETHOD(get_from)(VARIANT *pRetFrom);
	STDMETHOD(put_to)(VARIANT varTo);
	STDMETHOD(get_to)(VARIANT *pRetTo);
	STDMETHOD(put_property)(VARIANT varProperty);
	STDMETHOD(get_property)(VARIANT *pRetProperty);
	STDMETHOD(put_direction)(VARIANT varDirection);
	STDMETHOD(get_direction)(VARIANT *pRetDirection);
	STDMETHOD(put_animates)(VARIANT varAnimates);
	STDMETHOD(get_animates)(VARIANT *pRetAnimates);
	STDMETHOD(buildBehaviorFragments)( IDispatch* pActorDisp );

	//IPersistPropertyBag2 methods
    STDMETHOD(GetClassID)(CLSID* pclsid);
	STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void){return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

protected:
    virtual HRESULT BuildAnimationAsDABehavior();
    virtual VARIANT *VariantFromIndex(ULONG iIndex);
    virtual HRESULT GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropName);
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);

private:

	HRESULT GetColorToBvr(IDispatch *pActorDisp, IDAColor **ppResult);

    HRESULT BuildHueNumber(float, float, IDANumber*, IDANumber**);

    HRESULT NormalizeProgressValue(IDA2Statics *pDAStatics,
                                     IDANumber *pbvrProgress, 
                                     float flStartPercentage,
                                     float flEndPercentage,
                                     IDANumber **ppbvrReturn);
    static WCHAR                *m_rgPropNames[NUM_COLOR_PROPS]; 
    VARIANT                     m_varFrom;
    VARIANT                     m_varTo;
    VARIANT                     m_varProperty;
    VARIANT                     m_varDirection;

    IDispatch					*m_pdispActor;
    long						m_lCookie;

    HRESULT						RemoveFragment();

}; // CColorBvr

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif //__COLORBVR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\basebvr.h ===
#pragma once
#ifndef __BASEBEHAVIOR_H_
#define __BASEBEHAVIOR_H_
//*****************************************************************************
//
// File:    basebvr.h
// Author:  jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Definition of CBaseBehavior object 
//
// Modification List:
// Date		Author		Change
// 09/26/98	jeffort		Created this file
// 10/16/98 jeffort     Renamed functions, added functions to apply
//                      DA behavior to a property
// 10/21/98 jeffort     added BuildTIMEInterpolatedNumber()
// 11/16/98 markhal		added ApplyImageToAnimationElement
// 11/17/98 kurtj		support for actor construction.
// 11/18/98 kurtj       moved addImageToTime into protected for actor
//
//*****************************************************************************

#include "autobase.h"
#include "..\idl\crbvrdispid.h"
#include "defaults.h"

//*****************************************************************************

class ATL_NO_VTABLE CBaseBehavior:
		public CAutoBase
{

public:
	CBaseBehavior();
	virtual ~CBaseBehavior();

	//IElementBehavior methods
	HRESULT Init(IElementBehaviorSite *pSite);
	HRESULT Notify(LONG event, VARIANT *pVar);
	HRESULT Detach();
protected:

    HRESULT SetAnimatesProperty(VARIANT varAnimates);
    HRESULT GetAnimatesProperty(VARIANT *pvarAnimates);
    HRESULT SetOffsetProperty(VARIANT varOffset);
    HRESULT GetOffsetProperty(VARIANT *pvrOffset);

    HRESULT GetIdOfAnimatedElement(VARIANT *pvarId);

    virtual HRESULT BuildAnimationAsDABehavior() = 0;
    HRESULT GetAnimatedParentElement(IHTMLElement **ppElementReturn);
/*
    HRESULT GetAttributeFromHTMLElement(IHTMLElement *pElement,
                                        WCHAR *pwzAttributeName,
										boolean current,
                                        VARIANT *pvarReturn);
    HRESULT GetAttributeFromHTMLElement(IHTMLElement *pElement,
                                        WCHAR *pwzAttributeName, 
                                        VARIANT *pvarReturn);
	HRESULT GetCurrAttribFromHTMLElement(IHTMLElement *pElement,
										 WCHAR *pwzAttributeName,
										 VARIANT *pvarReturn);
    HRESULT GetAttributeFromHTMLElement(WCHAR *pwzAttributeName, 
                                    VARIANT *pvarReturn);
	HRESULT GetCurrAttribFromHTMLElement(WCHAR *pwzAttributeName,
										VARIANT *pvarReturn);
    HRESULT GetAttributeFromParentHTMLElement(WCHAR *pwzAttributeName, 
                                          VARIANT *pvarReturn);
	HRESULT GetCurrAttribFromParentHTMLElement(WCHAR *pwzAttributeName,
												VARIANT *pvarReturn);
    HRESULT GetAttributeFromAnimatedHTMLElement(WCHAR *pwzAttributeName, 
                                          VARIANT *pvarReturn);
*/
    // For behavior that implement a direction, they
    // may want to reverse this progress number.  We
    // will decalre this as virtual and let them override
    // it so that this can occur
    virtual HRESULT GetTIMEProgressNumber(IDANumber **ppbvrRet);
    virtual HRESULT GetTIMETimelineBehavior(IDANumber **ppbvrRet);
    HRESULT GetTIMEBooleanBehavior(IDABoolean **ppbvrRet);

    HRESULT GetTIMEImageBehaviorFromElement(IHTMLElement *pElement,
                                            IDAImage **pbvrReturnImage);

    HRESULT GetElementToAnimate(IHTMLElement **ppElementReturn);

	// TODO (markhal): All these apply methods go away when behaviors talk to actor
    HRESULT ApplyColorBehaviorToAnimationElement(IDAColor *pbvrColor,
                                                 WCHAR *pwzProperty);    
    HRESULT ApplyNumberBehaviorToAnimationElement(IDANumber *pbvrNumber,
                                                  WCHAR *pwzProperty);    
    HRESULT ApplyStringBehaviorToAnimationElement(IDAString *pbvrString,
                                                  WCHAR *pwzProperty);    
    HRESULT ApplyRotationBehaviorToAnimationElement(IDANumber *pbvrNumber,
                                                  WCHAR *pwzProperty);  
    HRESULT ApplyEffectBehaviorToAnimationElement(IUnknown *pbvrUnk, 
                                                  IDABehavior **ppbvrInputs,
                                                  long cInputs);
	HRESULT ApplyImageBehaviorToAnimationElement(IDAImage *pbvrImage);

	// These are the methods for talking to the actor
	HRESULT GetImageFromActor(IDispatch   *pActorDisp,
								 IDAImage	 **ppImage);

	HRESULT GetBvrFromActor(IDispatch *pActorDisp,
							WCHAR *pwzProperty,
							ActorBvrFlags eFlags,
							ActorBvrType eType,
							IDABehavior **ppResult);
								 
	HRESULT AttachBehaviorToActor(IDispatch   *pActorDisp,
								  IDABehavior *pbvrAttach,
                                  BSTR        bstrProperty,
                                  ActorBvrFlags  eFlags,
                                  ActorBvrType   eType);

    HRESULT AttachBehaviorToActorEx( IDispatch     *pActorDisp,
                                     IDABehavior   *pbvrAttach,
                                     BSTR           bstrProperty,
                                     ActorBvrFlags  eFlags,
                                     ActorBvrType   eType,
                                     IDispatch     *pdispBehaviorElement,
                                     long          *pCookie);

    HRESULT RemoveBehaviorFromActor( IDispatch     *pActorDisp,
                                     long           cookie );

    HRESULT RemoveBehaviorFromActor( long cookie );

    HRESULT AttachEffectToActor(IDispatch *pActorDisp,
								IUnknown *pbvrUnk, 
                                IDABehavior **ppbvrInputs,
                                long cInputs,
                                IDispatch *pdispThis,
                                long *pCookie);

    HRESULT BuildTIMEInterpolatedNumber(float flFrom,
                                        float flTo,
                                        float flOriginal,
                                        IDANumber **ppbvrReturn);

    HRESULT BuildTIMEInterpolatedNumber(float flFrom,
                                        float flTo,
                                        IDANumber **ppbvrReturn);

    HRESULT BuildTIMEInterpolatedNumber(IDANumber *pFrom,
                                        IDANumber *pTo,
                                        IDANumber **ppResult);

    HRESULT CallInvokeOnHTMLElement(IHTMLElement *pElement,
                                    LPWSTR lpProperty,
                                    WORD wFlags,
                                    DISPPARAMS *pdispParms,
                                    VARIANT *pvarResult);
	HRESULT CallInvokeOnDispatch(IDispatch* pDisp,
                                 LPWSTR lpProperty,
                                 WORD wFlags,
                                 DISPPARAMS *pdispParms,
                                 VARIANT *pvarResult);
    virtual HRESULT AttachActorBehaviorToAnimatedElement();

	HRESULT	AttachDABehaviorsToElement( IHTMLElement *pElement );

	HRESULT	RequestRebuild();
	HRESULT CancelRebuildRequests();


    HRESULT FinalConstruct();
    IHTMLElement *GetHTMLElement();

    HRESULT GetHTMLElementDispatch( IDispatch **ppdisp );

    HRESULT ApplyRelative2DMoveBehavior(IDATransform2 *pbvrMove, float, float);
    HRESULT ApplyAbsolute2DMoveBehavior(IDATransform2 *pbvrMove, float, float);

	HRESULT AddBehaviorToTIME(IDABehavior *pbvrAdd);
	HRESULT AddImageToTIME(IHTMLElement *pElement, IDAImage *pbvrAdd, bool enable);

	ActorBvrFlags FlagFromTypeMode(bool relative, VARIANT *pVarType, VARIANT *pVarMode);
	ActorBvrFlags FlagFromTypeMode(ActorBvrFlags flags, VARIANT *pVarType, VARIANT *pVarMode);

    HRESULT NotifyPropertyChanged(DISPID dispid);
	//IPersistPropertyBag2 methods
    STDMETHOD(GetClassID)(CLSID* pclsid);
	STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void){return m_fPropertiesDirty;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);
    
    virtual HRESULT GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropNames) = 0;
    virtual VARIANT *VariantFromIndex(ULONG iIndex) = 0;
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP) = 0;
    virtual WCHAR *GetBehaviorTypeAsURN(void){return NULL;};
    virtual WCHAR *GetBehaviorName( ){ return WZ_DEFAULT_BEHAVIOR_NAME; }
    CLSID   m_clsid;

   	HRESULT SafeCond( IDA2Statics *pstatics, 
					  IDABoolean *pdaboolCondition, 
					  IDABehavior *pdabvrIfTrue, 
				  	  IDABehavior *pdabvrIfFalse, 
				  	  IDABehavior **ppdabvrResult );


	HRESULT	AddBehaviorToAnimatedElement( IDABehavior* pdabvr, long *plCookie );
	HRESULT RemoveBehaviorFromAnimatedElement( long cookie );

public:
    IDA2Statics *GetDAStatics();

private:
    HRESULT GetDAStaticsFromTime(IDA2Statics **ppReturn);
    HRESULT CheckElementForActor( IHTMLElement*pElement, bool *pfActorPresent);
    HRESULT CheckElementForBehaviorURN(IHTMLElement *pElement, WCHAR *wzURN, bool *pfReturn);
    HRESULT CheckElementForDA(IHTMLElement* pElement, bool *pfReturn);
    HRESULT Apply2DMoveBvrToPoint(IDATransform2 *pbvrMove, IDAPoint2 *pbvrOrg, float, float);

	IElementBehaviorSite  					*m_pBehaviorSite;
    IHTMLElement                            *m_pHTMLElement;
    IDA2Statics                             *m_pDAStatics;
    VARIANT                                 m_varAnimates;
    bool                                    m_fPropertiesDirty;

    bool									m_fAcceptRebuildRequests;

	IDANumber								*m_pdanumZero;
    IDANumber								*m_pdanumOne;

    IHTMLElement							*m_pelemAnimatedParent;
}; // CBaseBehavior

//*****************************************************************************
// 
// Inline methods
//
//*****************************************************************************

inline IHTMLElement *
CBaseBehavior::GetHTMLElement()
{
    return m_pHTMLElement;
} // GetHTMLElement

//*****************************************************************************

inline IDA2Statics *
CBaseBehavior::GetDAStatics()
{
    return m_pDAStatics;
} // GetDAStatics

//*****************************************************************************
//
// End of File
//
//*****************************************************************************

#endif //__BASEBEHAVIOR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\defaults.h ===
#pragma once
#ifndef __DEFAULTS_H_
#define __DEFAULTS_H_
//*****************************************************************************
//
// Microsoft Chrome
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    defaults.h
//
// Author:	jeffort
//
// Created:	10/07/98
//
// Abstract:    default definitions for this project
// Modifications:
// 10/07/98 jeffort created file
// 10/21/98 jeffort added additional scale defaults
//
//*****************************************************************************

#define DEFAULT_BEHAVIOR_AS_TAG_URL L"anim"

#define DEFAULT_COLORBVR_FROM       0x00000000
#define DEFAULT_COLORBVR_TO         0x00FFFFFF

#define DEFAULT_SCALE_HEIGHT        0x00000100
#define DEFAULT_SCALE_WIDTH         0x00000100

#define DEFAULT_MOVE_TOP            0x00000100
#define DEFAULT_MOVE_LEFT           0x00000100

#define DEFAULT_ROTATEBVR_PROPERTY  L"style.rotation"
#define DEFAULT_COLORBVR_PROPERTY   L"style.color"
#define DEFAULT_SCALEBVR_PROPERTY   L"style."

#define PROPERTY_INVALIDCOLOR       0x99999999

#define MIN_NUM_SCALE_VALUES        2
#define MIN_NUM_MOVE_VALUES         2
#define NUM_VECTOR_VALUES_2D        2
#define NUM_VECTOR_VALUES_3D        3

#define DEFAULT_ACTOR_URN    L"LMBehavior_Actor_Behavior"

#define WZ_DEFAULT_BEHAVIOR_NAME	L"LMBehavior_DefaultName"

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif //__DEFAULTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\dispmethod.h ===
#pragma once
#ifndef __DISPMETHOD_H__
#define __DISPMETHOD_H__


/************************************************************
*
*
*************************************************************/

typedef HRESULT (*InvokeProxy)(void* pvData);

class CDispatchMethod: public IDispatch
{
public:
	CDispatchMethod();
	virtual ~CDispatchMethod();

	//IUnknown
   	STDMETHOD(QueryInterface)           ( REFIID riid, void** ppv );

    STDMETHOD_(ULONG, AddRef)           ();

    STDMETHOD_(ULONG, Release)          ();

    //IDispatch
    STDMETHOD(GetTypeInfoCount)         (UINT *pctInfo);

    STDMETHOD(GetTypeInfo)              ( UINT iTypeInfo,
                                          LCID lcid,
                                          ITypeInfo** ppTypeInfo);

    STDMETHOD(GetIDsOfNames)            ( REFIID riid,
                                          LPOLESTR* rgszNames,
                                          UINT cNames,
                                          LCID lcid,
                                          DISPID* rgid );

    STDMETHOD(Invoke)                   ( DISPID id,
                                          REFIID riid,
                                          LCID lcid,
                                          WORD wFlags,
                                          DISPPARAMS *pDispParams,
                                          VARIANT *pvarResult,
                                          EXCEPINFO *pExcepInfo,
                                          UINT *puArgErr );
    //subclasses should implement this to determine event specific behavior.

    virtual HRESULT	HandleEvent			()=0;
                                              
private:

	ULONG								m_cRefs;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\evtmgrclient.h ===
///////////////////////////////////////////////////////////////
// Copyright (c) 1998 Microsoft Corporation
//
// File: evtmgrclient.h
//
// Abstract:  
//
///////////////////////////////////////////////////////////////

#ifndef __EVTMGRCLIENT_H
#define __EVTMGRCLIENT_H


enum e_readyState {
	EVTREADYSTATE_UNKNOWN = 0,
	EVTREADYSTATE_COMPLETE = 1,
	EVTREADYSTATE_INTERACTIVE = 2 
};
class IEventManagerClient
{

public:

	//information methods
	virtual IHTMLElement*			GetElementToSink		()=0;
	virtual IElementBehaviorSite*	GetSiteToSendFrom		()=0;
	virtual HRESULT					TranslateMouseCoords	( long lX, long lY, long * pXTrans, long * pYTrans )=0;
	
	//Event callbacks
	virtual void					OnLoad					()=0;
	virtual void					OnUnload				()=0;
	virtual void					OnReadyStateChange		( e_readyState state )=0;
};

#endif //__EVTMGRCLIENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\eventmgr.h ===
///////////////////////////////////////////////////////////////
// Copyright (c) 1998 Microsoft Corporation
//
// File: EventMgr.h
//
// Abstract:
//
///////////////////////////////////////////////////////////////

#ifndef _EVENTMGR_H
#define _EVENTMGR_H

#include "basebvr.h"
#include "evtmgrclient.h"

#include <list>
using namespace std;

typedef list<IUnknown *>	ListUnknowns;

enum TIME_EVENT
{
    TE_ONBEGIN = 0,
    TE_ONPAUSE, 
    TE_ONRESUME, 
    TE_ONEND,
    TE_ONRESYNC,
    TE_ONREPEAT,
    TE_ONREVERSE,
    TE_ONMEDIACOMPLETE,
    TE_MAX
};

class CEventSink;

class CEventMgr
    : public IDispatch
{
  public:
    CEventMgr(IEventManagerClient *bvr);
    ~CEventMgr();

    //methods
    HRESULT Init();
    HRESULT Deinit();    
    //  Parameters needed to be packed into Variants by the caller
    HRESULT FireEvent(TIME_EVENT TimeEvent, 
                      long Count, 
                      LPWSTR szParamNames[], 
                      VARIANT varParams[]); 

	HRESULT AddMouseEventListener( LPUNKNOWN pUnkListener );
	HRESULT RemoveMouseEventListener( LPUNKNOWN pUnkListener );
	
    void ReadyStateChange(BSTR ReadyState);
    void PropertyChange(BSTR PropertyName);

    void MouseEvent(long x, 
                    long y, 
                    VARIANT_BOOL bMove,
                    VARIANT_BOOL bUp,
                    VARIANT_BOOL bShift, 
                    VARIANT_BOOL bAlt,
                    VARIANT_BOOL bCtrl,
                    long button);
    
    void KeyEvent(VARIANT_BOOL bLostFocus,
                  VARIANT_BOOL bUp,
                  VARIANT_BOOL bShift, 
                  VARIANT_BOOL bAlt,
                  VARIANT_BOOL bCtrl,
                  long KeyCode,
                  long RepeatCount);

    //QueryInterface 
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
    STDMETHODIMP GetTypeInfo(/* [in] */ UINT iTInfo,
                             /* [in] */ LCID lcid,
                             /* [out] */ ITypeInfo** ppTInfo);
    STDMETHODIMP GetIDsOfNames(
        /* [in] */ REFIID riid,
        /* [size_is][in] */ LPOLESTR *rgszNames,
        /* [in] */ UINT cNames,
        /* [in] */ LCID lcid,
        /* [size_is][out] */ DISPID *rgDispId);
    STDMETHODIMP Invoke(
        /* [in] */ DISPID dispIdMember,
        /* [in] */ REFIID riid,
        /* [in] */ LCID lcid,
        /* [in] */ WORD wFlags,
        /* [out][in] */ DISPPARAMS  *pDispParams,
        /* [out] */ VARIANT  *pVarResult,
        /* [out] */ EXCEPINFO *pExcepInfo,
        /* [out] */ UINT *puArgErr);

  protected:
	bool	FindUnknown( const ListUnknowns& listUnknowns,
						 LPUNKNOWN pUnk,
						 ListUnknowns::iterator& iterator );
	
  protected:
    //Cookie for the Window ConnectionPoint
    IEventManagerClient*              m_client;
    CEventSink *                      m_pEventSink;
    CComPtr<IConnectionPoint>         m_pWndConPt;
    CComPtr<IConnectionPoint>         m_pDocConPt;
    CComPtr<IHTMLWindow2>             m_pWindow;
    
    IHTMLElement *                    m_pElement;
    IHTMLElement2 **                  m_pBeginElement;
    IHTMLElement2 **                  m_pEndElement;
    long                              m_lBeginEventCount;
    long                              m_lEndEventCount;
    long                              m_lRepeatCount;
    BOOL                              m_bAttached;

    //Cookies
    DWORD                             m_cookies[TE_MAX];
    DWORD                             m_dwWindowEventConPtCookie;
    DWORD                             m_dwDocumentEventConPtCookie;
    
    //reference goo
    long                              m_refCount;
    
    HRESULT                           RegisterEvents();
    HRESULT                           Attach(BSTR Event, BOOL bAttach, IHTMLElement2 *pEventElement[], long Count);
    HRESULT                           ConnectToContainerConnectionPoint();
    HRESULT                           GetEventName(BSTR bstrEvent, BSTR **pElementName, BSTR **pEventName, long Count);
    long                              GetEventCount(BSTR bstrEvent);
    bool                              MatchEvent(BSTR bstrEvent, IHTMLEventObj *pEventObj, long Count);
    BYTE                              GetModifiers(VARIANT_BOOL bShift, VARIANT_BOOL bCtrl, VARIANT_BOOL bAlt);
        
        //input event parameters
    BYTE                              m_lastKeyMod;
    DWORD                             m_lastKey;
    int                               m_lastKeyCount;
    HWND                              m_hwndCurWnd;    
    long                              m_lastX;
    long                              m_lastY;
    long                              m_lastButton;
    BYTE                              m_lastMouseMod;
	ListUnknowns					  m_listMouseEventListeners;
};

#endif /* _EVENTMGR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\eventsink.h ===
///////////////////////////////////////////////////////////////
// Copyright (c) 1998 Microsoft Corporation
//
// File: EventSink.h
//
// Abstract:  
//
///////////////////////////////////////////////////////////////

#ifndef _EVENTSINK_H
#define _EVENTSINK_H

#include "evtmgrclient.h"

enum ELEMENT_EVENT
{
    EE_ONPROPCHANGE = 0,
    //add non-input related events to hook here
    EE_ONREADYSTATECHANGE, 
    EE_ONMOUSEMOVE,
    EE_ONMOUSEDOWN,
    EE_ONMOUSEUP,
    EE_ONKEYDOWN,
    EE_ONKEYUP,
    EE_ONBLUR,
    //add input related events here
    EE_MAX
};

class CEventSink
    : public IDispatch
{
  public:
    CEventSink(IEventManagerClient* bvr, CEventMgr *pEventMgr);
    ~CEventSink();

    //methods
    HRESULT Init();
    HRESULT Deinit();
    HRESULT InitMouse();

    //QueryInterface 
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
    STDMETHODIMP GetTypeInfo(/* [in] */ UINT iTInfo,
                             /* [in] */ LCID lcid,
                             /* [out] */ ITypeInfo** ppTInfo);
    STDMETHODIMP GetIDsOfNames(
        /* [in] */ REFIID riid,
        /* [size_is][in] */ LPOLESTR *rgszNames,
        /* [in] */ UINT cNames,
        /* [in] */ LCID lcid,
        /* [size_is][out] */ DISPID *rgDispId);
    STDMETHODIMP Invoke(
        /* [in] */ DISPID dispIdMember,
        /* [in] */ REFIID riid,
        /* [in] */ LCID lcid,
        /* [in] */ WORD wFlags,
        /* [out][in] */ DISPPARAMS  *pDispParams,
        /* [out] */ VARIANT  *pVarResult,
        /* [out] */ EXCEPINFO *pExcepInfo,
        /* [out] */ UINT *puArgErr);


  protected:
    //methods
    HRESULT                           AttachEvents();
    HRESULT                           DetachEvents();
    HRESULT                           NotifyReadyState(IHTMLEventObj *pEventObj);
    HRESULT                           NotifyPropertyChange(IHTMLEventObj *pEventObj);
    HRESULT                           NotifyMouseMove(IHTMLEventObj *pEventObj);
    HRESULT                           NotifyMouseUp(IHTMLEventObj *pEventObj);
    HRESULT                           NotifyMouseDown(IHTMLEventObj *pEventObj);
    HRESULT                           NotifyKeyDown(IHTMLEventObj *pEventObj);
    HRESULT                           NotifyKeyUp(IHTMLEventObj *pEventObj);

    //properties
    IHTMLElement *                    m_pElement;
    IEventManagerClient*			  m_client;
    long                              m_refCount;
    DWORD                             m_dwElementEventConPtCookie;
    CComPtr<IConnectionPoint>         m_pElementConPt;
    CEventMgr *                       m_pEventMgr;

};

#endif /* _EVENTSINK_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\elementprop.h ===
#pragma once
#ifndef __ELEMENTPROP_H__
#define __ELEMENTPROP_H__
  
//*****************************************************************************
//
// Microsoft LMRT
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:        elementprop.h
//
// Author:          KurtJ
//
// Created:         2/14/99
//
// Abstract:        Sinks IHTMLElement property changes.
//
// Modifications:
// 1/14/98 KurtJ Created this file
//
//*****************************************************************************


class IElementLocalTimeListener
{
public:
    STDMETHOD(OnLocalTimeChange)( float localTime )=0;
};


class CElementPropertyMonitor:
	public IPropertyNotifySink
{
public:

								CElementPropertyMonitor			();
								~CElementPropertyMonitor		();

    //IUnknown
    STDMETHOD					(QueryInterface)				( REFIID riid, void** ppv );

    STDMETHOD_					(ULONG, AddRef)					();

    STDMETHOD_					(ULONG, Release)				();

	//IPropertyNotifySink
	STDMETHOD					(OnChanged)						( DISPID dispid );
	STDMETHOD					(OnRequestEdit)					( DISPID dispid );

    //IElementEventMonitor
    STDMETHOD					(SetLocalTimeListener)			( IElementLocalTimeListener *pListener );

    STDMETHOD					(Attach)						( IHTMLElement* pelemToListen );
    STDMETHOD					(Detach)						();
	bool						IsAttached						(){return (m_pelemElement != NULL);};

	STDMETHOD					(UpdateDISPIDCache)				();

private:

    IElementLocalTimeListener	*m_pLocalTimeListener;

	DWORD						m_dwElementPropertyConPtCookie;
    IConnectionPoint            *m_pconptElement;

    IHTMLElement                *m_pelemElement;
	IDispatch					*m_pdispElement;

	DISPID						m_dispidLocalTime;

    long                        m_refCount;

    HRESULT						ProcessLocalTimeChange			();
    
    HRESULT                     AttachToElementConPt			();
    HRESULT                     DetachFromElementConPt			();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\move.h ===
#pragma once
#ifndef __MOVEBVR_H_
#define __MOVEBVR_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    MoveBvr.h
//
// Author:	jeffort
//
// Created:	10/07/98
//
// Abstract:    move behavior class definition
// Modifications:
// 10/07/98 jeffort created file
// 10/21/98 jeffort brought closer to spec including 3D and percentage work
//
//*****************************************************************************

#include <resource.h>
#include "basebvr.h"
#include "path.h"
#include "sampler.h"

#define NUM_MOVE_PROPS 7
//*****************************************************************************

class ATL_NO_VTABLE CMoveBvr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMoveBvr, &CLSID_CrMoveBvr>,
    public IConnectionPointContainerImpl<CMoveBvr>,
    public IPropertyNotifySinkCP<CMoveBvr>,
    public IPersistPropertyBag2,
#ifdef CRSTANDALONE
	public IDispatchImpl<ICrMoveBvr2, &IID_ICrMoveBvr2, &LIBID_ChromeBehavior>,
#else
	public IDispatchImpl<ICrMoveBvr2, &IID_ICrMoveBvr2, &LIBID_LiquidMotion>,
#endif // CRSTANDALONE
	public IElementBehavior,
    public CBaseBehavior	
{

BEGIN_COM_MAP(CMoveBvr)
	COM_INTERFACE_ENTRY(ICrMoveBvr)
	COM_INTERFACE_ENTRY(ICrMoveBvr2)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IElementBehavior)
	COM_INTERFACE_ENTRY(IPersistPropertyBag2)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

// Connection Point to allow IPropertyNotifySink 
BEGIN_CONNECTION_POINT_MAP(CMoveBvr)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

public:

DECLARE_REGISTRY_RESOURCEID(IDR_MOVEBVR)

	CMoveBvr();
    virtual ~CMoveBvr();
    HRESULT FinalConstruct();
    // IElementBehavior
    //
	STDMETHOD(Init)(IElementBehaviorSite *pBehaviorSite);
	STDMETHOD(Notify)(LONG event, VARIANT *pVar);
	STDMETHOD(Detach)();

    // Needed by CBaseBehavior
    void * 	GetInstance() { return (ICrMoveBvr *) this ; }
	
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }

    // ICrColorBehavior
	STDMETHOD(put_from)(VARIANT varFrom);
	STDMETHOD(get_from)(VARIANT *pRetFrom);
	STDMETHOD(put_to)(VARIANT varTo);
	STDMETHOD(get_to)(VARIANT *pRetTo);
	STDMETHOD(put_by)(VARIANT varBy);
	STDMETHOD(get_by)(VARIANT *pRetBy);
	STDMETHOD(put_v)(VARIANT varPath);
	STDMETHOD(get_v)(VARIANT *pRetPath);
	STDMETHOD(put_animates)(VARIANT varAnimates);
	STDMETHOD(get_animates)(VARIANT *pRetAnimates);
    STDMETHOD(put_type)(VARIANT varType);
    STDMETHOD(get_type)(VARIANT *pRetType);
	STDMETHOD(put_mode)(VARIANT varMode);
	STDMETHOD(get_mode)(VARIANT *pRetMode);
    STDMETHOD(put_direction)(VARIANT varDirection);
    STDMETHOD(get_direction)(VARIANT *pRetDirection);
	STDMETHOD(buildBehaviorFragments)(IDispatch *pActorDisp);

	// ICrMoveBvr2
	STDMETHOD(get_currentX)(VARIANT *pRetCurrent);
	STDMETHOD(get_currentY)(VARIANT *pRetCurrent);
	
	//IPersistPropertyBag2 methods
    STDMETHOD(GetClassID)(CLSID* pclsid);
	STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void){return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    //sample callback
    static HRESULT PositionSampled( void *thisPtr,
								  	long id,
								  	double startTime,
								  	double globalNow,
								  	double localNow,
								  	IDABehavior * sampleVal,
								  	IDABehavior **ppReturn);

	HRESULT	UpdatePosition( IDABehavior *sampleVal );

protected:
    virtual HRESULT BuildAnimationAsDABehavior();
    virtual VARIANT *VariantFromIndex(ULONG iIndex);
    virtual HRESULT GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropName);
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);
    virtual HRESULT GetTIMEProgressNumber(IDANumber **ppbvrRet);

private:

    HRESULT InitializeProperties();
    HRESULT GetMove2DVectorValues(float  rgflFrom[2],
                                float  rgflTo[2]);
    HRESULT Build2DTransform(IDispatch *pActorDisp, IDATransform2 **ppbvrTransform);
	HRESULT GetMoveToTransform(IDispatch *pActorDisp, IDATransform2 **ppResult);


    static WCHAR                *m_rgPropNames[NUM_MOVE_PROPS]; 
    CPathManager                *m_pPathManager;
    VARIANT                     m_varFrom;
    VARIANT                     m_varTo;
    VARIANT                     m_varBy;
    VARIANT                     m_varPath;
    VARIANT                     m_varType;
	VARIANT						m_varMode;
    VARIANT                     m_varDirection;
    ActorBvrFlags               m_DefaultType;

    IDispatch					*m_pdispActor;
    long						m_lCookie;

    CSampler					*m_pSampler;
    long						m_lSampledCookie;

    VARIANT						m_varCurrentX;
    VARIANT						m_varCurrentY;
}; // CMoveBvr

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif //__MOVEBVR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\lmtrace.h ===
#ifndef _LM_TRACE_INC_
#define _LM_TRACE_INC_
/////////////////////////////////////////////////////////////
//trace definitions stolen from ATL 30 headers and customized
/////////////////////////////////////////////////////////////

/////////////////////////////////////
// LM DEBUG Defines
////////////////////////////////////
#ifdef _DEBUG
#include <assert.h>
#define LMASSERT(expr) assert((expr))

#define LM_TRACE_CATEGORY	(lmTraceNone)
#define LM_TRACE_LEVEL		(0)
#else
#define LMASSERT(expr) ((void)0)
#endif //_DEBUG
////////////////////////////////////
// End LM DEBUG Defines
////////////////////////////////////

enum lmTraceFlags
{
	//LM defined categories
	lmTraceNone					= 0x00000000,
	lmTraceLMRT 				= 0x00000001,
	lmTraceBaseBehavior			= 0x00000002,
	lmTraceMoveBehavior			= 0x00000004,
	lmTraceColorBehavior 		= 0x00000008,
	lmTraceAll					= 0xFFFFFFFF,
};

#ifndef LM_TRACE_CATEGORY
#define LM_TRACE_CATEGORY (lmTraceAll)
#endif

#ifdef _DEBUG

#ifndef LM_TRACE_LEVEL
#define LM_TRACE_LEVEL 0
#endif

inline void _cdecl LmTrace(LPCSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	char szBuffer[512];

	nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
	LMASSERT(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

	OutputDebugStringA(szBuffer);
	va_end(args);
}
inline void _cdecl LmTrace2(DWORD category, UINT level, LPCSTR lpszFormat, ...)
{
	if (category & LM_TRACE_CATEGORY && level <= LM_TRACE_LEVEL)
	{
		va_list args;
		va_start(args, lpszFormat);

		int nBuf;
		char szBuffer[512];

		nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
		LMASSERT(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

		OutputDebugStringA("LM: ");
		OutputDebugStringA(szBuffer);
		va_end(args);
	}
}
#ifndef OLE2ANSI
inline void _cdecl LmTrace(LPCWSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	WCHAR szBuffer[512];

	nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer) / sizeof(szBuffer[0]), lpszFormat, args);
	LMASSERT(nBuf < sizeof(szBuffer) / sizeof(szBuffer[0]));//Output truncated as it was > sizeof(szBuffer)

	OutputDebugStringW(szBuffer);
	va_end(args);
}
inline void _cdecl LmTrace2(DWORD category, UINT level, LPCWSTR lpszFormat, ...)
{
	if (category & LM_TRACE_CATEGORY && level <= LM_TRACE_LEVEL)
	{
		va_list args;
		va_start(args, lpszFormat);

		int nBuf;
		WCHAR szBuffer[512];

		nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer) / sizeof(szBuffer[0]), lpszFormat, args);
		LMASSERT(nBuf < sizeof(szBuffer));//Output truncated as it was > sizeof(szBuffer)

		OutputDebugStringW(L"LM: ");
		OutputDebugStringW(szBuffer);
		va_end(args);
	}
}
#endif //!OLE2ANSI


#ifndef LMTRACE
#define LMTRACE            LmTrace
#define LMTRACE2           LmTrace2
#endif
#define LMTRACENOTIMPL(funcname)   LMTRACE2(lmTraceNotImpl, 2, _T("LM: %s not implemented.\n"), funcname); return E_NOTIMPL
#else // !DEBUG
inline void _cdecl LmTrace(LPCSTR , ...){}
inline void _cdecl LmTrace2(DWORD, UINT, LPCSTR , ...){}
#ifndef OLE2ANSI
inline void _cdecl LmTrace(LPCWSTR , ...){}
inline void _cdecl LmTrace2(DWORD, UINT, LPCWSTR , ...){}
#endif //OLE2ANSI
#ifndef LMTRACE
#define LMTRACE            1 ? (void)0 : LmTrace
#define LMTRACE2			1 ? (void)0 : LmTrace2
#endif //LMTRACE
#define LMTRACENOTIMPL(funcname)   return E_NOTIMPL
#endif //_DEBUG

#endif //_LM_TRACE_INC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\effect.h ===
#pragma once
#ifndef __EFFECTBVR_H_
#define __EFFECTBVR_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    EffectBvr.h
//
// Author:	jeffort
//
// Created:	10/07/98
//
// Abstract:    effect behavior class definition
// Modifications:
// 10/07/98 jeffort created file
//
//*****************************************************************************

#include <resource.h>
#include "dispex.h"
#include "dxtrans.h"
#include "basebvr.h"

#define NUM_EFFECT_PROPS 6

#ifndef CHECK_RETURN_SET_NULL
#define CHECK_RETURN_SET_NULL(x) {if (!(x)) { return E_POINTER ;} else {*(x) = NULL;}}
#endif

//*****************************************************************************

class ATL_NO_VTABLE CEffectBvr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CEffectBvr, &CLSID_CrEffectBvr>,
    public IConnectionPointContainerImpl<CEffectBvr>,
    public IPropertyNotifySinkCP<CEffectBvr>,
    public ICrEffectBvr,
    public IDispatchEx,
	public IElementBehavior,
    public IPersistPropertyBag2,
    public IOleClientSite,
    public IServiceProvider,
    public CBaseBehavior
	
{

BEGIN_COM_MAP(CEffectBvr)
    COM_INTERFACE_ENTRY2(IDispatch, IDispatchEx)
    COM_INTERFACE_ENTRY(IDispatchEx)
	COM_INTERFACE_ENTRY(ICrEffectBvr)
	COM_INTERFACE_ENTRY(IPersistPropertyBag2)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IElementBehavior)
	COM_INTERFACE_ENTRY(IOleClientSite)
	COM_INTERFACE_ENTRY(IServiceProvider)
END_COM_MAP()

// Connection Point to allow IPropertyNotifySink 
BEGIN_CONNECTION_POINT_MAP(CEffectBvr)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

public:

DECLARE_REGISTRY_RESOURCEID(IDR_EFFECTBVR)

	CEffectBvr();
    virtual ~CEffectBvr();
    HRESULT FinalConstruct();
    // IElementBehavior
    //
	STDMETHOD(Init)(IElementBehaviorSite *pBehaviorSite);
	STDMETHOD(Notify)(LONG event, VARIANT *pVar);
	STDMETHOD(Detach)();

    // Needed by CBaseBehavior
    void * 	GetInstance() { return (ICrEffectBvr *) this ; }
	
	STDMETHOD(put_type)(VARIANT varType);
	STDMETHOD(get_type)(VARIANT *pRetType);
	STDMETHOD(put_transition)(VARIANT varTransition);
	STDMETHOD(get_transition)(VARIANT *pRetTransition);
	STDMETHOD(put_classid)(VARIANT varClassId);
	STDMETHOD(get_classid)(VARIANT *pRetClassId);
	STDMETHOD(put_animates)(VARIANT varAnimates);
	STDMETHOD(get_animates)(VARIANT *pRetAnimates);
	STDMETHOD(put_progid)(VARIANT varProgId);
	STDMETHOD(get_progid)(VARIANT *pRetProgId);
	STDMETHOD(put_direction)(VARIANT varDirection);
	STDMETHOD(get_direction)(VARIANT *pRetDirection);
	STDMETHOD(put_image)(VARIANT varImage);
	STDMETHOD(get_image)(VARIANT *pRetImage);
	STDMETHOD(buildBehaviorFragments)( IDispatch* pActorDisp );

    // IDispatch and IDispatchEx methods
    STDMETHOD(GetTypeInfoCount)(/*[out]*/UINT FAR* pctinfo);
    STDMETHOD(GetTypeInfo)(/*[in]*/UINT itinfo, 
                            /*[in]*/LCID lcid, 
                            /*[out]*/ITypeInfo ** pptinfo);
    STDMETHOD(GetIDsOfNames)(/*[in]*/REFIID riid,
                            /*[in,size_is(cNames)]*/LPOLESTR * rgszNames,
                            /*[in]*/UINT cNames,
                            /*[in]*/LCID lcid,
                            /*[out,size_is(cNames)]*/DISPID FAR* rgdispid);
    STDMETHOD(Invoke)(/*[in]*/DISPID dispidMember,
                        /*[in]*/REFIID riid,
                        /*[in]*/LCID lcid,
                        /*[in]*/WORD wFlags,
                        /*[in,out]*/DISPPARAMS * pdispparams,
                        /*[out]*/VARIANT * pvarResult,
                        /*[out]*/EXCEPINFO * pexcepinfo,
                        /*[out]*/UINT * puArgErr);
    STDMETHOD(GetDispID)(/*[in]*/BSTR bstrName,
                            /*[in]*/DWORD grfdex,
                            /*[out]*/DISPID *pid);
    STDMETHOD(InvokeEx)(/*[in]*/DISPID dispidMember,
                        /*[in]*/LCID lcid,
                        /*[in]*/WORD wFlags,
                        /*[in]*/DISPPARAMS * pdispparams,
                        /*[in,out,unique]*/VARIANT * pvarResult,
                        /*[in,out,unique]*/EXCEPINFO * pexcepinfo,
                        /*[in,unique]*/IServiceProvider *pSrvProvider);
    STDMETHOD(DeleteMemberByName)(/*[in]*/BSTR bstr,
                                    /*[in]*/DWORD grfdex);
    STDMETHOD(DeleteMemberByDispID)(/*[in]*/DISPID id);
    STDMETHOD (GetMemberProperties)(/*[in]*/DISPID id,
                                    /*[in]*/DWORD grfdexFetch,
                                    /*[out]*/DWORD *pgrfdex);
    STDMETHOD (GetMemberName)(/*[in]*/DISPID id,
                              /*[out]*/BSTR *pbstrName);
    STDMETHOD (GetNextDispID)(/*[in]*/DWORD grfdex,
                                /*[in]*/DISPID id,
                                /*[out]*/DISPID *prgid);
    STDMETHOD (GetNameSpaceParent)(/*[out]*/IUnknown **ppunk);

	//IPersistPropertyBag2 methods
    STDMETHOD(GetClassID)(CLSID* pclsid);
	STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void){return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    // IOleClientSite interfaces
    STDMETHOD(SaveObject)()
    { return E_NOTIMPL; }
    STDMETHOD(GetMoniker)(DWORD dwAssign,
                          DWORD dwWhichMoniker, 
                          LPMONIKER * ppmk)
    { CHECK_RETURN_SET_NULL(ppmk); return E_NOTIMPL; }
    STDMETHOD(GetContainer)(LPOLECONTAINER * ppContainer)
    { CHECK_RETURN_SET_NULL(ppContainer); return E_NOTIMPL; }
    STDMETHOD(ShowObject)()
    { return E_NOTIMPL; }
    STDMETHOD(OnShowWindow)(BOOL fShow)
    { return E_NOTIMPL; }
    STDMETHOD(RequestNewObjectLayout)()
    { return E_NOTIMPL; }

    // IServiceProvider interfaces
    STDMETHOD(QueryService)(REFGUID guidService,
                            REFIID riid,
                            void** ppv);
protected:
    virtual HRESULT BuildAnimationAsDABehavior();
    virtual VARIANT *VariantFromIndex(ULONG iIndex);
    virtual HRESULT GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropName);
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);
    virtual HRESULT GetTIMEProgressNumber(IDANumber **ppbvrRet);


private:
    // Type information helper class "borrowed" from ATL's IDispatch code
    static CComTypeInfoHolder s_tihTypeInfo;

    HRESULT GetClassIdFromType(WCHAR **pwzClassId);
    HRESULT BuildTransform();

    static WCHAR                *m_rgPropNames[NUM_EFFECT_PROPS]; 
    VARIANT                     m_varType;
    VARIANT                     m_varTransition;
    VARIANT                     m_varClassId;
    VARIANT                     m_varProgId;
    VARIANT                     m_varDirection;
    VARIANT                     m_varImage;
    IDXTransform                *m_pTransform;
    IServiceProvider            *m_pSp;
    IHTMLDocument2              *m_pHTMLDoc;

    IDispatch					*m_pdispActor;
    long						m_lCookie;

}; // CEffectBvr

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif //__EFFECTBVR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\factory.h ===
#pragma once
#ifndef __CRBEHAVIORFACTORY_H_
#define __CRBEHAVIORFACTORY_H_

//*****************************************************************************
//
// File: factory.h
// Author: jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Definition of CCrBehaviorFactory object which implements
//           the chromeffects factory of DHTML behaviors
//
// Modification List:
// Date     Author      Change
// 09/26/98 jeffort     Created this file
//
//*****************************************************************************

#include <resource.h>
#include "autobase.h"

//*****************************************************************************

typedef enum
{
    crbvrRotate,
    crbvrScale,
    crbvrSet,
    crbvrNumber,
    crbvrMove,
    crbvrPath,
    crbvrColor,
    crbvrActor,
    crbvrEffect,
    crbvrAction,
    crbvrDA,
    crbvrUnknown
} ECRBEHAVIORTYPE;



class ATL_NO_VTABLE CCrBehaviorFactory : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CCrBehaviorFactory, &CLSID_CrBehaviorFactory>,
#ifdef CRSTANDALONE
    public IDispatchImpl<ICrBehaviorFactory, &IID_ICrBehaviorFactory, &LIBID_ChromeBehavior>,
#else
    public IDispatchImpl<ICrBehaviorFactory, &IID_ICrBehaviorFactory, &LIBID_LiquidMotion>,
#endif // CRSTANDALONE
    public IObjectSafetyImpl<CCrBehaviorFactory>,
    public CAutoBase,
    public IElementBehaviorFactory
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_CRBVRFACTORY)

    CCrBehaviorFactory()
    {
    }

    // IObjectSafetyImpl
    STDMETHOD(SetInterfaceSafetyOptions)(
                            /* [in] */ REFIID riid,
                            /* [in] */ DWORD dwOptionSetMask,
                            /* [in] */ DWORD dwEnabledOptions);
    STDMETHOD(GetInterfaceSafetyOptions)(
                            /* [in] */ REFIID riid, 
                            /* [out] */DWORD *pdwSupportedOptions, 
                            /* [out] */DWORD *pdwEnabledOptions);
    //
    // IElementBehaviorFactory
    //

    STDMETHOD(FindBehavior)(LPOLESTR pchNameSpace, 
                            LPOLESTR pchTagName, 
                            IElementBehaviorSite *pUnkArg, 
                            IElementBehavior **ppBehavior)
    {
        return FindBehavior(pchNameSpace, pchTagName, static_cast<IUnknown*>(pUnkArg), ppBehavior);
    }

    STDMETHOD(FindBehavior)(LPOLESTR pchNameSpace, 
                            LPOLESTR pchTagName, 
                            IUnknown *pUnkArg, 
                            IElementBehavior **ppBehavior);

    STDMETHODIMP UIDeactivate() 
    { 
        return S_OK; 
    } // UIDeactivate
    
DECLARE_PROTECT_FINAL_CONSTRUCT()
BEGIN_COM_MAP(CCrBehaviorFactory)
    COM_INTERFACE_ENTRY(ICrBehaviorFactory)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IElementBehaviorFactory)
END_COM_MAP()


private:
    ECRBEHAVIORTYPE GetBehaviorTypeFromBstr(BSTR bstrBehaviorType);
    DWORD m_dwSafety;
}; // CCrBehaviorFactory

//*****************************************************************************
//
// End of File
//
//*****************************************************************************

#endif //__CRBEHAVIORFACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\number.h ===
#pragma once
#ifndef __NUMBERBVR_H_
#define __NUMBERBVR_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    numberbvr.h
//
// Author:	jeffort
//
// Created:	10/07/98
//
// Abstract:    number behavior class definition
// Modifications:
// 10/07/98 jeffort created file
// 11/16/98 jeffort implemented expression attribute
// 11/17/98 kurtj	moved to actor construction model
//
//*****************************************************************************

#include <resource.h>
#include "basebvr.h"

#define NUM_NUMBER_PROPS 6

//*****************************************************************************

class ATL_NO_VTABLE CNumberBvr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CNumberBvr, &CLSID_CrNumberBvr>,
    public IConnectionPointContainerImpl<CNumberBvr>,
    public IPropertyNotifySinkCP<CNumberBvr>,
    public IPersistPropertyBag2,
#ifdef CRSTANDALONE
	public IDispatchImpl<ICrNumberBvr, &IID_ICrNumberBvr, &LIBID_ChromeBehavior>,
    error me here
#else
	public IDispatchImpl<ICrNumberBvr, &IID_ICrNumberBvr, &LIBID_LiquidMotion>,
#endif // CRSTANDALONE
	public IElementBehavior,
    public IDABvrHook,
    public CBaseBehavior
	
{

BEGIN_COM_MAP(CNumberBvr)
	COM_INTERFACE_ENTRY(ICrNumberBvr)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IElementBehavior)
	COM_INTERFACE_ENTRY(IPersistPropertyBag2)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

// Connection Point to allow IPropertyNotifySink 
BEGIN_CONNECTION_POINT_MAP(CNumberBvr)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

public:
DECLARE_REGISTRY_RESOURCEID(IDR_NUMBERBVR)

	CNumberBvr();
    virtual ~CNumberBvr();
    HRESULT FinalConstruct();
    // IElementBehavior
    //
	STDMETHOD(Init)(IElementBehaviorSite *pBehaviorSite);
	STDMETHOD(Notify)(LONG event, VARIANT *pVar);
	STDMETHOD(Detach)();

    // Needed by CBaseBehavior
    void * 	GetInstance() { return (ICrNumberBvr *) this ; }
	
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }

    // ICrNumberBehavior
	STDMETHOD(put_from)(VARIANT varFrom);
	STDMETHOD(get_from)(VARIANT *pRetFrom);
	STDMETHOD(put_to)(VARIANT varTo);
	STDMETHOD(get_to)(VARIANT *pRetTo);
	STDMETHOD(put_by)(VARIANT varBy);
	STDMETHOD(get_by)(VARIANT *pRetBy);
	STDMETHOD(put_type)(VARIANT varType);
	STDMETHOD(get_type)(VARIANT *pRetType);
	STDMETHOD(put_mode)(VARIANT varMode);
	STDMETHOD(get_mode)(VARIANT *pRetMode);
	// Unfortunately, there is an IE5 bug where executing
	// script does not return the correct value, so we can
	// not support expression at this time.  Therefor, these
    // methods are not exposed by any interface at this time
	STDMETHOD(put_expression)(VARIANT varExpression);
	STDMETHOD(get_expression)(VARIANT *pRetExpression);
	STDMETHOD(put_property)(VARIANT varProperty);
	STDMETHOD(get_property)(VARIANT *pRetProperty);
	STDMETHOD(get_beginProperty)(VARIANT *pRetBeginProperty);
	STDMETHOD(put_animates)(VARIANT varAnimates);
	STDMETHOD(get_animates)(VARIANT *pRetAnimates);
	STDMETHOD(buildBehaviorFragments)( IDispatch* pActorDisp );

    // IDABvrHook
    virtual HRESULT STDMETHODCALLTYPE Notify(LONG id,
                                             VARIANT_BOOL startingPerformance,
                                             double startTime,
                                             double gTime,
                                             double lTime,
                                             IDABehavior *sampleVal,
                                             IDABehavior *curRunningBvr,
                                             IDABehavior **ppBvr);
	//IPersistPropertyBag2 methods
    STDMETHOD(GetClassID)(CLSID* pclsid);
	STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void){return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

protected:
    virtual HRESULT BuildAnimationAsDABehavior();
    virtual VARIANT *VariantFromIndex(ULONG iIndex);
    virtual HRESULT GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropName);
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);

private:

    HRESULT EvaluateScriptExpression(WCHAR *wzScript, float &flReturn);

    static WCHAR                *m_rgPropNames[NUM_NUMBER_PROPS]; 
    VARIANT                     m_varFrom;
    VARIANT                     m_varTo;
    VARIANT                     m_varBy;
	VARIANT						m_varType;
	VARIANT						m_varMode;
    VARIANT                     m_varProperty;
    VARIANT                     m_varExpression;
    VARIANT                     m_varBeginProperty;

    IDispatch					*m_pdispActor;
    long						m_lCookie;

    HRESULT						RemoveFragment();

}; // CNumberBvr

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif //__NUMBERBVR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\path.h ===
#pragma once
#ifndef __PATH_H_
#define __PATH_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    path.h
//
// Author:	jeffort
//
// Created:	10/07/98
//
// Abstract:    path behavior class definition
// Modifications:
// 10/07/98 jeffort  created file
// 11/09/98 jeffwall split out extra objects
//
//*****************************************************************************

#include <resource.h>
#include "basebvr.h"

#include "pmanager.h"

#define NUM_PATH_PROPS 1

//*****************************************************************************

class ATL_NO_VTABLE CPathBvr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CPathBvr, &CLSID_CrPathBvr>,
    public IConnectionPointContainerImpl<CPathBvr>,
    public IPropertyNotifySinkCP<CPathBvr>,
    public IPersistPropertyBag2,
#ifdef CRSTANDALONE
	public IDispatchImpl<ICrPathBvr, &IID_ICrPathBvr, &LIBID_ChromeBehavior>,
    error me here
#else
	public IDispatchImpl<ICrPathBvr, &IID_ICrPathBvr, &LIBID_LiquidMotion>,
#endif // CRSTANDALONE
	public IElementBehavior,
    public CBaseBehavior
	
{

BEGIN_COM_MAP(CPathBvr)
	COM_INTERFACE_ENTRY(ICrPathBvr)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IElementBehavior)
	COM_INTERFACE_ENTRY(IPersistPropertyBag2)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

// Connection Point to allow IPropertyNotifySink 
BEGIN_CONNECTION_POINT_MAP(CPathBvr)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

public:
DECLARE_REGISTRY_RESOURCEID(IDR_PATHBVR)

	CPathBvr();
    virtual ~CPathBvr();
    HRESULT FinalConstruct();
    // IElementBehavior
    //
	STDMETHOD(Init)(IElementBehaviorSite *pBehaviorSite);
	STDMETHOD(Notify)(LONG event, VARIANT *pVar);
	STDMETHOD(Detach)();

    // Needed by CBaseBehavior
    void * 	GetInstance() { return (ICrPathBvr *) this ; }
	
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }

    // ICrPathBehavior
	STDMETHOD(put_v)(VARIANT varPath);
	STDMETHOD(get_v)(VARIANT *pRetPath);
    STDMETHOD(GetDATransform)(IDispatch *pDispProgress, 
                              VARIANT *pRetTrans);
	//IPersistPropertyBag2 methods
    STDMETHOD(GetClassID)(CLSID* pclsid);
	STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void){return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

protected:
    virtual HRESULT BuildAnimationAsDABehavior();
    virtual VARIANT *VariantFromIndex(ULONG iIndex);
    virtual HRESULT GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropName);
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);

private:
    static WCHAR                *m_rgPropNames[NUM_PATH_PROPS]; 
    VARIANT                     m_varPath;
    CPathManager                *m_pPathManager;
}; // CPathBvr

#endif //__PATH_H_ 

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\pcurve.h ===
#pragma once
#ifndef __PATHCURV_H_
#define __PATHCURV_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    pathcurv.h
//
// Author:	jeffwall
//
// Created:	11/09/98
//
// Abstract:    path curve class definition
// Modifications:
// 11/09/98 jeffwall created file from path.h
//
//*****************************************************************************

#include "pelement.h"
#include "pathline.h"

//*****************************************************************************

class CPathCurve : public CPathElement
{
public:
    CPathCurve();
    virtual ~CPathCurve();
    float Distance();
    HRESULT SetValues(float flStartX, 
                   float flStartY, 
                   float flControl1X,
                   float flControl1Y,
                   float flControl2X,
                   float flControl2Y,
                   float flEndX, 
                   float flEndY);

    virtual HRESULT BuildTransform(IDA2Statics *pDAStatics,
                                   IDANumber *pbvrProgress, 
                                   float flStartPercentage,
                                   float flEndPercentage,
                                   IDATransform2 **ppbvrResult);
private:
    HRESULT createCurveSegments(float *pflXComponents,
                                 float *pflYComponents,
                                 float *pflLength,
                                 float flTolerance);

    float m_flStartX;
    float m_flStartY;
    float m_flControl1X;
    float m_flControl1Y;
    float m_flControl2X;
    float m_flControl2Y;
    float m_flEndX;
    float m_flEndY;
    float m_flDistance;
    int   m_segCount;

    CPathLineSegment *m_pListHead;
    CPathLineSegment *m_pListTail;
}; // CPathCurve

#endif //__PATHCURV_H_


//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\pathline.h ===
#pragma once
#ifndef __PATHLINE_H_
#define __PATHLINE_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    pathline.h
//
// Author:	jeffwall
//
// Created:	11/09/98
//
// Abstract:    path line seqment class definition
// Modifications:
// 11/09/98 jeffwall created file from path.h
//
//*****************************************************************************

#include "pelement.h"

//*****************************************************************************

class CPathLineSegment : public CPathElement
{
public:
    CPathLineSegment();
    virtual ~CPathLineSegment();
    float Distance();
    void SetValues(float flStartX, float flStartY, float flEndX, float flEndY);
    virtual HRESULT BuildTransform(IDA2Statics *pDAStatics,
                                   IDANumber *pbvrProgress, 
                                   float flStartPercentage,
                                   float flEndPercentage,
                                   IDATransform2 **ppbvrResult);

    float m_flStartX;
    float m_flStartY;
    float m_flEndX;
    float m_flEndY;
}; // CPathLineSegment

#endif // __PATHLINE_H_


//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\pmanager.h ===
#pragma once
#ifndef __PATHMNGR_H_
#define __PATHMNGR_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    pathmngr.h
//
// Author:	jeffwall
//
// Created:	11/09/98
//
// Abstract:    path manager class definition
// Modifications:
// 11/09/98 jeffwall created file from path.h
//
//*****************************************************************************

#include "pelement.h"

//*****************************************************************************

class CPathManager : CPathElement
{
public:
    CPathManager();
    virtual ~CPathManager();
    virtual HRESULT Initialize(BSTR bstrPath);
    virtual HRESULT BuildTransform(IDA2Statics *pDAStatics,
                                   IDANumber *pbvrProgress, 
                                   float flStartPercentage,
                                   float flEndPercentage,
                                   IDATransform2 **ppbvrResult);
    float Distance();
    void AddPathObjectToList(CPathElement *pObject);

private:

	void DeletePathList();
	
    HRESULT ParseForPathElements(BSTR *pbstrPath);
    HRESULT ParseLineElement(BSTR *pbstrPath);
    HRESULT ParseCurveElement(BSTR *pbstrPath);
    HRESULT ParseEllipseElement(BSTR *pbstrPath);
    HRESULT ParseArcElement(BSTR *pbstrPath);
    HRESULT ParseEllipseQuadrant(BSTR *pbstrPath);

    void GetAngle(float, float, float*);

    HRESULT RecursiveBuildAllPathTransforms(IDA2Statics *pDAStatics,
                                            IDANumber *pbvrProgress,
                                            CPathElement *pPathObj,
                                            float flStartPercentage,
                                            float flTotalPercentage,
                                            float flTotalDistance,
                                            IDATransform2 **ppbvrResult);
    CPathElement    *m_pPathTail;
    CPathElement    *m_pPathHead;
    float           m_flStartX;
    float           m_flStartY;
    float           m_flEndX;
    float           m_flEndY;
}; // CPathManager

#endif // __PATHMNGR_H_


//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\pelement.h ===
#pragma once
#ifndef __PATHELMT_H_
#define __PATHELMT_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    pathelmt.h
//
// Author:	jeffwall
//
// Created:	11/09/98
//
// Abstract:    path Element class definition
// Modifications:
// 11/09/98 jeffwall created file from path.h
//
//*****************************************************************************

#include <resource.h>

//*****************************************************************************

class CPathElement
{
public:
    CPathElement();
    virtual ~CPathElement();
    virtual HRESULT Initialize(BSTR *pbstrPath, float flStartX, float flStartY)
    {
        return S_OK;
    }
    virtual HRESULT BuildTransform(IDA2Statics *pDAStatics,
                                   IDANumber *pbvrProgress, 
                                   float flStartPercentage,
                                   float flEndPercentage,
                                   IDATransform2 **pbvrResult) = 0;
    virtual float Distance() = 0;
    CPathElement    *m_pNext;

protected:
    // this is a helper function that every path element
    // will most likely need
    HRESULT NormalizeProgressValue(IDA2Statics *pDAStatics,
                           IDANumber *pbvrProgress, 
                           float flStartPercentage,
                           float flEndPErcentage,
                           IDANumber **ppbvrReturn);
}; // CPathElement

#endif // __PATHELMT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\pellipse.h ===
#pragma once
#ifndef __PATHANGE_H_
#define __PATHANGE_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    pathange.h
//
// Author:	jeffwall
//
// Created:	11/09/98
//
// Abstract:    path AngleElipse class definition
// Modifications:
// 11/09/98 jeffwall created file
//
//*****************************************************************************

#include "pelement.h" 

//*****************************************************************************

class CPathEllipse : public CPathElement
{
public:
    CPathEllipse();
    virtual ~CPathEllipse();
    float Distance();
    void SetValues(float flCenterX, 
                      float flCenterY, 
                      float flWidth,
                      float flHeight,
                      float flStartAngle,
                      float flSweep,
                      float *flStartX,
                      float *flStartY,
                      float *flEndX,
                      float *flEndY);

    virtual HRESULT BuildTransform(IDA2Statics *pDAStatics,
                                   IDANumber *pbvrProgress, 
                                   float flStartPercentage,
                                   float flEndPercentage,
                                   IDATransform2 **ppbvrResult);
private:

    float internalDistance();

    float m_flHeight;
    float m_flWidth;
    float m_flStartAngle;
    float m_flSweep;
    float m_flDistance;
    float m_flCenterX;
    float m_flCenterY;
}; // CPathEllipse

#endif //__PATHANGE_H_


//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\resource.h ===
#pragma once
#ifndef _CRRESOURCE_H
#define _CRRESOURCE_H
//*****************************************************************************
//
// Microsoft Chrome
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    resource.h
//
// Author:	    jeffort
//
// Created:	    10/07/98
//
// Abstract:    resource definitions for this project
// Modifications:
// 10/07/98 jeffort created file
// 11/03/98 kurtj   relocated idrs to allow space for lmrt idrs
//
//*****************************************************************************

//these should be offset from the top end of the resources allocated for lmrt
// but doing addition in a resid is apparently a no no.

#define IDR_CRBVRFACTORY        301
#define IDR_COLORBVR		302
#define IDR_ROTATEBVR           303
#define IDR_SCALEBVR            304
#define IDR_MOVEBVR             305
#define IDR_PATHBVR             306
#define IDR_NUMBERBVR           307
#define IDR_SETBVR              308
#define IDR_ACTORBVR            309
#define IDR_EFFECTBVR           310
#define IDR_ACTIONBVR           311

// We could potentially be included in the lmrt resource file, which will define 
// this for itself, so we only want it defined if it is currently not defined
#ifndef RESID_TYPELIB
#define RESID_TYPELIB           1
#endif // RESID_TYPELIB


//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif /* _CRRESOURCE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\scale.h ===
#pragma once
#ifndef __SCALEBVR_H_
#define __SCALEBVR_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    ScaleBvr.h
//
// Author:	jeffort
//
// Created:	10/07/98
//
// Abstract:    scale behavior class definition
// Modifications:
// 10/07/98 jeffort created file
// 10/21/98 jeffort brought closer to spec including 3D and percentage work
//
//*****************************************************************************

#include <resource.h>
#include "basebvr.h"

#define NUM_SCALE_PROPS 5

//*****************************************************************************

class ATL_NO_VTABLE CScaleBvr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CScaleBvr, &CLSID_CrScaleBvr>,
    public IConnectionPointContainerImpl<CScaleBvr>,
    public IPropertyNotifySinkCP<CScaleBvr>,
    public IPersistPropertyBag2,
#ifdef CRSTANDALONE
	public IDispatchImpl<ICrScaleBvr, &IID_ICrScaleBvr, &LIBID_ChromeBehavior>,
#else
	public IDispatchImpl<ICrScaleBvr, &IID_ICrScaleBvr, &LIBID_LiquidMotion>,
#endif // CRSTANDALONE
	public IElementBehavior,
    public CBaseBehavior
	
{

BEGIN_COM_MAP(CScaleBvr)
	COM_INTERFACE_ENTRY(ICrScaleBvr)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IElementBehavior)
	COM_INTERFACE_ENTRY(IPersistPropertyBag2)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

// Connection Point to allow IPropertyNotifySink 
BEGIN_CONNECTION_POINT_MAP(CScaleBvr)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

public:

DECLARE_REGISTRY_RESOURCEID(IDR_SCALEBVR)

	CScaleBvr();
    virtual ~CScaleBvr();
    HRESULT FinalConstruct();
    // IElementBehavior
    //
	STDMETHOD(Init)(IElementBehaviorSite *pBehaviorSite);
	STDMETHOD(Notify)(LONG event, VARIANT *pVar);
	STDMETHOD(Detach)();

    // Needed by CBaseBehavior
    void * 	GetInstance() { return (ICrScaleBvr *) this ; }
	
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }

    // ICrColorBehavior
	STDMETHOD(put_from)(VARIANT varFrom);
	STDMETHOD(get_from)(VARIANT *pRetFrom);
	STDMETHOD(put_to)(VARIANT varTo);
	STDMETHOD(get_to)(VARIANT *pRetTo);
	STDMETHOD(put_by)(VARIANT varBy);
	STDMETHOD(get_by)(VARIANT *pRetBy);
	STDMETHOD(put_type)(VARIANT varType);
	STDMETHOD(get_type)(VARIANT *pRetType);
	STDMETHOD(put_mode)(VARIANT varMode);
	STDMETHOD(get_mode)(VARIANT *pRetMode);
	STDMETHOD(put_animates)(VARIANT varAnimates);
	STDMETHOD(get_animates)(VARIANT *pRetAnimates);
	STDMETHOD(buildBehaviorFragments)(IDispatch *pActorDisp);
	//IPersistPropertyBag2 methods
    STDMETHOD(GetClassID)(CLSID* pclsid);
	STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void){return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

protected:
    virtual HRESULT BuildAnimationAsDABehavior();
    virtual VARIANT *VariantFromIndex(ULONG iIndex);
    virtual HRESULT GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropName);
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);

private:

    HRESULT InitializeProperties();
    HRESULT GetScaleVectorValues(float  rgflFrom[3],
                                 float  rgflTo[3],
                                 int    *piNumValues,
								 bool	*prelative);
    HRESULT Build2DTransform(float  rgflFrom[3],
                             float  rgflTo[3],
                             IDATransform2 **ppbvrTransform);

	HRESULT GetScaleToTransform(IDispatch *pActorDisp, IDATransform2 **ppResult);

//    HRESULT Build3DTransform(float  rgflFrom[3],
//                             float  rgflTo[3],
//                             IDATransform3 **ppbvrTransform);
//    HRESULT Apply2DScaleBehaviorToAnimationElement(IDATransform2 *pbvrScale);

    static WCHAR                *m_rgPropNames[NUM_SCALE_PROPS]; 
    VARIANT                     m_varFrom;
    VARIANT                     m_varTo;
    VARIANT                     m_varBy;
	VARIANT						m_varType;
	VARIANT						m_varMode;

	long						m_lCookie;
	IDispatch					*m_pdispActor;
}; // CScaleBvr

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif //__SCALEBVR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\rotate.h ===
#pragma once
#ifndef __ROTATEBVR_H_
#define __ROTATEBVR_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    RotateBvr.h
//
// Author:	jeffort
//
// Created:	10/07/98
//
// Abstract:    rotate behavior class definition
// Modifications:
// 10/07/98 jeffort created file
//
//*****************************************************************************

#include <resource.h>
#include "basebvr.h"

#define NUM_ROTATE_PROPS 5
//*****************************************************************************

class ATL_NO_VTABLE CRotateBvr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CRotateBvr, &CLSID_CrRotateBvr>,
    public IConnectionPointContainerImpl<CRotateBvr>,
    public IPropertyNotifySinkCP<CRotateBvr>,
    public IPersistPropertyBag2,
#ifdef CRSTANDALONE
	public IDispatchImpl<ICrRotateBvr, &IID_ICrRotateBvr, &LIBID_ChromeBehavior>,
#else
	public IDispatchImpl<ICrRotateBvr, &IID_ICrRotateBvr, &LIBID_LiquidMotion>,
#endif // CRSTANDALONE
	public IElementBehavior,
    public CBaseBehavior
	
{

BEGIN_COM_MAP(CRotateBvr)
	COM_INTERFACE_ENTRY(ICrRotateBvr)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IElementBehavior)
	COM_INTERFACE_ENTRY(IPersistPropertyBag2)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

// Connection Point to allow IPropertyNotifySink 
BEGIN_CONNECTION_POINT_MAP(CRotateBvr)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

public:

DECLARE_REGISTRY_RESOURCEID(IDR_ROTATEBVR)

	CRotateBvr();
    virtual ~CRotateBvr();
    HRESULT FinalConstruct();
    // IElementBehavior
    //
	STDMETHOD(Init)(IElementBehaviorSite *pBehaviorSite);
	STDMETHOD(Notify)(LONG event, VARIANT *pVar);
	STDMETHOD(Detach)();

    // Needed by CBaseBehavior
    void * 	GetInstance() { return (ICrRotateBvr *) this ; }
	
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }

    // ICrColorBehavior
	STDMETHOD(put_from)(VARIANT varFrom);
	STDMETHOD(get_from)(VARIANT *pRetFrom);
	STDMETHOD(put_to)(VARIANT varTo);
	STDMETHOD(get_to)(VARIANT *pRetTo);
	STDMETHOD(put_by)(VARIANT varBy);
	STDMETHOD(get_by)(VARIANT *pRetBy);
	STDMETHOD(put_type)(VARIANT varType);
	STDMETHOD(get_type)(VARIANT *pRetType);
	STDMETHOD(put_mode)(VARIANT varMode);
	STDMETHOD(get_mode)(VARIANT *pRetMode);
	STDMETHOD(put_animates)(VARIANT varAnimates);
	STDMETHOD(get_animates)(VARIANT *pRetAnimates);
	STDMETHOD(buildBehaviorFragments)( IDispatch* pActorDisp );

	//IPersistPropertyBag2 methods
    STDMETHOD(GetClassID)(CLSID* pclsid);
	STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void){return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

protected:
    virtual HRESULT BuildAnimationAsDABehavior();
    virtual VARIANT *VariantFromIndex(ULONG iIndex);
    virtual HRESULT GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropName);
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);

private:

    HRESULT InitializeProperties();

    static WCHAR                *m_rgPropNames[NUM_ROTATE_PROPS]; 

    VARIANT                     m_varFrom;
    VARIANT                     m_varTo;
    VARIANT                     m_varBy;
	VARIANT						m_varType;
	VARIANT						m_varMode;

	IDispatch					*m_pdispActor;
	long						m_lCookie;

	HRESULT						RemoveFragment();
}; // CRotateBvr

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif //__ROTATEBVR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\utils.h ===
#pragma once
#ifndef _UTILS_H_
#define _UTILS_H_

//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1997
//
// FileName:	    utils.h
//
// Created:	        10/07/98
//
// Author:	        jeffort
// 
// Abstract:	    shared utility functions
//
// Change History:
// 10/07/98 jeffort Created this file.
// 10/16/98 jeffort added InsurePropertyVariantAsFloat
// 11/17/98 kurtj   added ARRAY_SIZE
//
//*****************************************************************************


#pragma warning(disable:4002)
#define DPFINIT(h,s)
#define DPF()
#ifdef _DEBUG
#define DPF_ERR(x)\
{\
	char buffer[512];\
	int ret = sprintf( buffer, "%s file:%s line:%d\n", x, __FILE__, __LINE__ ); \
	DASSERT( ret < 512 ); \
	OutputDebugStringA( buffer );\
}
#else
#define DPF_ERR(x)
#endif
#define DPGUID(s,r)
#define DASSERT(condition)
#define DVERIFY(condition)   (condition)

#include "lmtrace.h"

//*****************************************************************************

#define LCID_ENGLISH MAKELCID(MAKELANGID(0x09, 0x01), SORT_DEFAULT)
//use English for all scripting
#define LCID_SCRIPTING 0x0409

//*****************************************************************************

#define IID_TO_PPV(_type,_src)      IID_##_type, \
                                    reinterpret_cast<void **>(static_cast<_type **>(_src))

//*****************************************************************************

#if (_M_IX86 >= 300) && defined(DEBUG)
  #define PSEUDORETURN(dw)    _asm { mov eax, dw }
#else
  #define PSEUDORETURN(dw)
#endif // not _M_IX86
//*****************************************************************************

#define CheckBitSet( pattern, bit ) ( ( pattern & bit ) != 0 )

//*****************************************************************************

#define CheckBitNotSet( pattern, bit ) ( ( pattern & bit ) == 0 )

//*****************************************************************************

#define SetBit( pattern, bit ) ( pattern |= bit )

//*****************************************************************************

#define ClearBit( pattern, bit ) ( pattern &= ~bit )

//*****************************************************************************
//
// ReleaseInterface calls 'Release' and NULLs the pointer
// The Release() return will be in eax for IA builds.
//
//*****************************************************************************
#define ReleaseInterface(p)\
{\
    ULONG cRef = 0u; \
    if (NULL != (p))\
    {\
        cRef = (p)->Release();\
        DASSERT((int)cRef>=0);\
        (p) = NULL;\
    }\
    PSEUDORETURN(cRef) \
} 

//*****************************************************************************

#define CheckHR( hr, msg, label )\
if( FAILED( hr ) )\
{\
	DPF_ERR(msg);\
	goto label;\
}

//*****************************************************************************

#define CheckPtr( pointer, hr, newHr, msg, label )\
if( pointer == NULL )\
{\
	DPF_ERR(msg);\
	hr = newHr;\
	goto label;\
}

//*****************************************************************************

#define ReturnIfArgNull( pointer )\
if( pointer == NULL )\
{\
	DPF_ERR("argument is null");\
	return E_INVALIDARG;\
}

//*****************************************************************************

#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))

//*****************************************************************************

class CUtils
{
public:
    static HRESULT InsurePropertyVariantAsBSTR(VARIANT *varValue);
    static HRESULT InsurePropertyVariantAsFloat(VARIANT *varFloat);
    static HRESULT InsurePropertyVariantAsBool(VARIANT *varFloat);
    static DWORD GetColorFromVariant(VARIANT *varColor);
    static void GetHSLValue(DWORD dwInputColor, 
						 float *pflHue, 
						 float *pflSaturation, 
						 float *pflLightness);
    static HRESULT GetVectorFromVariant(VARIANT *varVector,
                                        int *piFloatsReturned, 
                                        float *pflX = NULL, 
                                        float *pflY = NULL, 
                                        float *pflZ = NULL);
    static void SkipWhiteSpace(LPWSTR *ppwzString);

    static HRESULT ParseFloatValueFromString(LPWSTR *ppwzFloatString, 
                                             float *pflRet);
    static bool CompareForEqualFloat(float flComp1, float flComp2);

}; // CUtils

//************************************************************
//
// Inline methods
//
//************************************************************

inline void CUtils::SkipWhiteSpace(LPWSTR *ppwzString)
{
  while(iswspace(**ppwzString))
    (*ppwzString)++;
} // SkipWhiteSpace

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\set.h ===
#pragma once
#ifndef __SETBVR_H_
#define __SETBVR_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    setbvr.h
//
// Author:	jeffort
//
// Created:	10/07/98
//
// Abstract:    set behavior class definition
// Modifications:
// 10/07/98 jeffort created file
// 11/20/98 markhal	converted to work with actor
//
//*****************************************************************************

#include <resource.h>

#include "basebvr.h"

#define NUM_SET_PROPS 3

//*****************************************************************************

class ATL_NO_VTABLE CSetBvr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSetBvr, &CLSID_CrSetBvr>,
    public IConnectionPointContainerImpl<CSetBvr>,
    public IPropertyNotifySinkCP<CSetBvr>,
    public IPersistPropertyBag2,
#ifdef CRSTANDALONE
	public IDispatchImpl<ICrSetBvr, &IID_ICrSetBvr, &LIBID_ChromeBehavior>,
    error me here
#else
	public IDispatchImpl<ICrSetBvr, &IID_ICrSetBvr, &LIBID_LiquidMotion>,
#endif // CRSTANDALONE
	public IElementBehavior,
    public CBaseBehavior
	
{

BEGIN_COM_MAP(CSetBvr)
	COM_INTERFACE_ENTRY(ICrSetBvr)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IElementBehavior)
	COM_INTERFACE_ENTRY(IPersistPropertyBag2)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

// Connection Point to allow IPropertyNotifySink 
BEGIN_CONNECTION_POINT_MAP(CSetBvr)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

public:
DECLARE_REGISTRY_RESOURCEID(IDR_SETBVR)

	CSetBvr();
    virtual ~CSetBvr();
    HRESULT FinalConstruct();
    // IElementBehavior
    //
	STDMETHOD(Init)(IElementBehaviorSite *pBehaviorSite);
	STDMETHOD(Notify)(LONG event, VARIANT *pVar);
	STDMETHOD(Detach)();

    // Needed by CBaseBehavior
    void * 	GetInstance() { return (ICrSetBvr *) this ; }
	
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }

    // ICrSetBehavior
	STDMETHOD(put_value)(VARIANT varValue);
	STDMETHOD(get_value)(VARIANT *pRetValue);
	STDMETHOD(put_property)(VARIANT varProperty);
	STDMETHOD(get_property)(VARIANT *pRetProperty);
    STDMETHOD(put_type)(VARIANT varType);
    STDMETHOD(get_type)(VARIANT *pRetType);
    STDMETHOD(put_animates)(VARIANT varAnimates);
	STDMETHOD(get_animates)(VARIANT *pRetAnimates);
	STDMETHOD(buildBehaviorFragments)( IDispatch* pActorDisp );

	//IPersistPropertyBag2 methods
    STDMETHOD(GetClassID)(CLSID* pclsid);
	STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void){return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

protected:
    virtual HRESULT BuildAnimationAsDABehavior();
    virtual VARIANT *VariantFromIndex(ULONG iIndex);
    virtual HRESULT GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropName);
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);

private:

    HRESULT ExtractColor(VARIANT, IDAColor **);
    HRESULT ExtractNumber(VARIANT, IDANumber **);

    static WCHAR                *m_rgPropNames[NUM_SET_PROPS]; 
    VARIANT                     m_varValue;
    VARIANT                     m_varProperty;
    VARIANT                     m_varType;

    long                        m_lCookie;
    IDispatch                   *m_pdispActor;
}; // CSetBvr

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif //__SETBVR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\include\sampler.h ===
//*****************************************************************************
//
// File:            sampler.h
// Author:          kurtj
// Date Created:    11/10/98
//
// Abstract: Abstracts the notion of sampling a behavior
//
//*****************************************************************************

#ifndef __SAMPLER_H
#define __SAMPLER_H

#include "lmrt.h"

// Definition of a pointer to a callback function
typedef HRESULT (*SampleCallback)(void *thisPtr,
								  long id,
								  double startTime,
								  double globalNow,
								  double localNow,
								  IDABehavior * sampleVal,
								  IDABehavior **ppReturn);

class CSampler :
    public IDABvrHook
{
public:
    //
    // IUnknown Interface
    //
    STDMETHOD(QueryInterface)( REFIID riid, void** ppv );
    STDMETHOD_(ULONG,  AddRef)();
    STDMETHOD_(ULONG, Release)();


    CSampler( ILMSample* target );
	CSampler( SampleCallback callback, void *thisPtr );
    ~CSampler();

    
    STDMETHOD(Invalidate)();
    STDMETHOD(Attach)( IDABehavior* bvrToHook, IDABehavior** result );

    //
    //IDABvrHook Interface
    //
    STDMETHOD(Notify)( LONG id,
                        VARIANT_BOOL startingPerformance,
                        double startTime,
                        double gTime,
                        double lTime,
                        IDABehavior * sampleVal,
                        IDABehavior * curRunningBvr,
                        IDABehavior ** ppBvr);
private:
    //weak ref.
    ILMSample* m_target;

	// callback function
	SampleCallback m_callback;

	// This ptr (uggh)
	void	*m_thisPtr;

    //refcount
    ULONG m_cRefs;

};
#endif // __SAMPLER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\messages\usa\makefile.inc ===
crbvr.rc : $(TARGETPATH)\$(TARGET_DIRECTORY)\crbvr.tlb \
          crfactory.rgs \
		  crcolor.rgs		\
		  crrotate.rgs	\
		  crscale.rgs	\
		  crmove.rgs	\
		  crpath.rgs   \
		  craction.rgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\src\action.cpp ===
//*****************************************************************************
//
// File:    setbvr.cpp
// Author:  jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Implementation of CActionBvr object which implements
//			 the chromeffects Action.  Simple behavior that just forwards
//           buildBehaviorFragments calls to its children
//
// Modification List:
// Date		Author		Change
// 11-23-98	kurtj		Created this file
//*****************************************************************************

#include "headers.h"

#include "action.h"
#include "attrib.h"
#include "dautil.h"

#undef THIS
#define THIS CActionBvr
#define SUPER CBaseBehavior

#include "pbagimp.cpp"

// These are used for the IPersistPropertyBag2 as it is implemented
// in the base class.  This takes an array of BSTR's, gets the
// attributes, queries this class for the variant, and copies
// the result.  The order of these defines is important


WCHAR * CActionBvr::m_rgPropNames[] = {NULL};

//*****************************************************************************

CActionBvr::CActionBvr() 
{
    m_clsid = CLSID_CrActionBvr;
} // CActionBvr

//*****************************************************************************

CActionBvr::~CActionBvr()
{
} // ~ActionBvr

//*****************************************************************************

HRESULT CActionBvr::FinalConstruct()
{
    HRESULT hr = SUPER::FinalConstruct();
    if (FAILED(hr))
    {
        DPF_ERR("Error in action behavior FinalConstruct initializing base classes");
        return hr;
    }
    return S_OK;
} // FinalConstruct

//*****************************************************************************

VARIANT *
CActionBvr::VariantFromIndex(ULONG iIndex)
{
	DASSERT(FALSE);
    return NULL;
} // VariantFromIndex

//*****************************************************************************

HRESULT 
CActionBvr::GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropNames)
{
    *pulProperties = NUM_ACTION_PROPS;
    *pppPropNames = m_rgPropNames;
    return S_OK;
} // GetPropertyBagInfo

//*****************************************************************************

STDMETHODIMP 
CActionBvr::Init(IElementBehaviorSite *pBehaviorSite)
{
	return SUPER::Init(pBehaviorSite);
} // Init

//*****************************************************************************

STDMETHODIMP 
CActionBvr::Notify(LONG event, VARIANT *pVar)
{
	return SUPER::Notify(event, pVar);
} // Notify

//*****************************************************************************

STDMETHODIMP
CActionBvr::Detach()
{
	return SUPER::Detach();
} // Detach 

//*****************************************************************************

HRESULT 
CActionBvr::BuildAnimationAsDABehavior()
{
	// TODO (markhal): This will go away when all behaviors have been converted
	return S_OK;
}

//*****************************************************************************

STDMETHODIMP
CActionBvr::buildBehaviorFragments( IDispatch* pActorDisp )
{
	if( pActorDisp == NULL )
		return E_INVALIDARG;

	HRESULT hr = E_FAIL;

	hr = BuildChildren(pActorDisp);
	if( FAILED( hr ) )
	{
		DPF_ERR("failed to build the children of an action");
	}

	return hr;
} //buildBehaviorFragments

//*****************************************************************************

HRESULT
CActionBvr::BuildChildren( IDispatch *pdispActor )
{
	if( pdispActor == NULL )
		return E_INVALIDARG;
	//cycle through out direct children calling buildAnimationFragments

	HRESULT hr = E_FAIL;
	
	IHTMLElement* pElem;
	pElem = GetHTMLElement( );
	if( pElem != NULL )
	{
		IDispatch *pChildrenDisp;
		hr = pElem->get_children( &pChildrenDisp );
		if( SUCCEEDED( hr ) )
		{
			IHTMLElementCollection *pChildrenCol;
			hr = pChildrenDisp->QueryInterface( IID_TO_PPV( IHTMLElementCollection, &pChildrenCol ) );
			ReleaseInterface( pChildrenDisp );
			if( SUCCEEDED( hr ) )
			{
				long length;

				hr = pChildrenCol->get_length(&length);
				if( SUCCEEDED( hr ) )
				{
					if( length != 0 )
					{
						VARIANT name;
						VARIANT index;
						VARIANT rgvarInput[1];

						IDispatch *pCurrentElem;
						
						VariantInit( &name );
						V_VT(&name) = VT_I4;

						VariantInit( &index );
						V_VT(&index) = VT_I4;
						V_I4(&index) = 0;

						VariantInit( &rgvarInput[0] );
						V_VT( &rgvarInput[0] ) = VT_DISPATCH;
						V_DISPATCH( &rgvarInput[0] ) = pdispActor;

						DISPPARAMS params;
						params.rgvarg				= rgvarInput;
						params.rgdispidNamedArgs	= NULL;
						params.cArgs				= 1;
						params.cNamedArgs			= 0;

						for(V_I4(&name) = 0; V_I4(&name) < length ; V_I4(&name)++ )
						{
							hr = pChildrenCol->item( name, index, &pCurrentElem );
							if( SUCCEEDED( hr ) )
							{
								CallBuildBehaviors( pCurrentElem, &params, NULL );
								ReleaseInterface( pCurrentElem );
							}
						}
					}
				}
				else //failed to get the length from the children collection
				{
					DPF_ERR("failed to get the length from the children collection");
				}
				ReleaseInterface( pChildrenCol );
			}
			else //failed to get IHTMLElementCollection from dispatch returned from elem->get_children
			{
				DPF_ERR("failed to get IHTMLElementCollection from dispatch returned from elem->get_children");
			}
		}
		else //failed to get the children collection from the actor element
		{
			DPF_ERR("failed to get the children collection from the actor element");
		}

	}
	else//failed to get the actor element
	{
		DPF_ERR("failed to get the actor element");
	}

	return hr;
}

//*****************************************************************************

HRESULT
CActionBvr::CallBuildBehaviors( IDispatch *pDisp, DISPPARAMS *pParams, VARIANT* pResult)
{
	HRESULT hr = S_OK;

	DISPID dispid;

	WCHAR* wszBuildMethodName = L"buildBehaviorFragments";

	hr = pDisp->GetIDsOfNames( IID_NULL,
							   &wszBuildMethodName,
							   1,
							   LOCALE_SYSTEM_DEFAULT,
							   &dispid);
	if( SUCCEEDED( hr ) )
	{
		EXCEPINFO		excepInfo;
		UINT			nArgErr;
		hr = pDisp->Invoke( dispid,
							IID_NULL,
							LOCALE_SYSTEM_DEFAULT,
							DISPATCH_METHOD,
							pParams,
							pResult,
							&excepInfo,
							&nArgErr );
		if( FAILED( hr ) )
		{
			if( pResult != NULL )
				VariantClear( pResult );
		}

	}
	else//failed to get the id of "buildBehaviors" on pDisp
	{
		if( pResult != NULL )
			VariantClear( pResult );
	}


	return hr;
}

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\src\actorbvr.cpp ===
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:        actorbvr.cpp
//
// Author:          ColinMc
//
// Created:         10/15/98
//
// Abstract:        The CrIME Actor behavior.
//
// Modifications:
// 10/15/98 ColinMc Created this file
// 11/17/98 Kurtj	construction algorithm
// 11/18/98 kurtj   now animates the element to which it is attached
// 11/19/98 markhal Added CImageBvrTrack and CColorBvrTrack
//
//*****************************************************************************

#include "headers.h"

#include "actorbvr.h"
#include "attrib.h"
#include "dautil.h"


#undef THIS
#define THIS CActorBvr
#define SUPER CBaseBehavior

#include "pbagimp.cpp"

// These are used for the IPersistPropertyBag2 as it is implemented
// in the base class.  This takes an array of BSTR's, gets the
// attributes, queries this class for the variant, and copies
// the result.  The order of these defines is important

#define VAR_ANIMATES			0
#define VAR_SCALE				1
#define VAR_PIXELSCALE			2

#define INVALID_SAMPLE_TIME		-1.0

WCHAR * CActorBvr::m_rgPropNames[] = {
                                     BEHAVIOR_PROPERTY_ANIMATES,
                                     BEHAVIOR_PROPERTY_SCALE,
									 BEHAVIOR_PROPERTY_PIXELSCALE
                                    };

CVarEmptyString CActorBvr::CBvrTrack::s_emptyString;

static const double	METERS_PER_INCH	= 0.0254;
static const double POINTS_PER_INCH = 72.0;
static const double POINTS_PER_PICA = 12.0;

// These are used to define the number of absolute fragments we can handle and
// the bit patterns we use in masking and indexing
#define MSK_INDEX_BITS	4		// Number of bits to be used as an index
#define MSK_FREE_BITS	28		// Number of bits free to be used for the mask
#define MSK_INDEX_MASK	0xf		// Mask used to give index
#define MSK_MAX_FRAGS	448		// Max number of fragments we can handle with this scheme

//bits that are used to describe which cookie values have been set in the actor

//for BvrTrack
#define ONBVR_COOKIESET			0x00000001

//for NumberBvrTrack
#define NUMBERBVR_COOKIESET		0x00000002

//for ColorBvrTrack
#define REDBVR_COOKIESET		0x00000002
#define GREENBVR_COOKIESET		0x00000004
#define BLUEBVR_COOKIESET		0x00000008


//for StringBvrTrack
#define STRINGBVR_COOKIESET		0x00000002

//These are used to create a bit pattern that gives us state on what
// tracks are dirty for a particular rebuild pass.

#define TRANSLATION_DIRTY	0x00000001
#define SCALE_DIRTY			0x00000002
#define ROTATION_DIRTY		0x00000004
#define TOP_DIRTY			0x00000008
#define LEFT_DIRTY			0x00000010
#define WIDTH_DIRTY			0x00000020
#define HEIGHT_DIRTY		0x00000040

//flags to determine the current state of the actor so that we don't
// have to talk to trident for every one.

#define PIXEL_SCALE_ON		0x00000001
#define STATIC_SCALE		0x00000002
#define STATIC_ROTATION		0x00000004
#define ELEM_IS_VML			0x00000008
#define FLOAT_ON			0x00000010

// Determines the smallest change in time that the timeline sampler will accept as a change
// in time.  This is to workaround a bogosity in TIME where a paused movie will cause tiny
// changes in time.  Why they couldn't do this on their side is beyond me.
#define MIN_TIMELINE_DIFF	0.00000001


//*****************************************************************************
// Unit conversion table
//*****************************************************************************

Ratio CActorBvr::s_unitConversion[5][5] = 
{
	{//from in
		{1,1}, //to in
		{254, 100}, //to cm
		{254, 10}, //to mm
		{72, 1}, //to pt
		{72, 12 }  //to pc
	},
	{//from cm
		{100, 254}, //to in
		{1, 1}, //to cm
		{10, 1}, //to mm
		{7200, 254}, //to pt
		{7200, 254*12}  //to pc
	},
	{//from mm
		{10, 254}, //to in
		{1, 10}, //to cm
		{1,1}, //to mm
		{720, 254}, //to pt
		{720, 254*12}  //to pc
	},
	{	//from pt
		{1, 72}, //to in
		{254, 7200}, //to cm
		{254, 720}, //to mm
		{1, 1}, //to pt
		{1, 12}  //to pc
	},
	{//from pc
		{12, 72}, //to in
		{254*12, 7200}, //to cm
		{254*12, 720}, //to mm
		{12, 1}, //to pt
		{1, 1}  //to pc
	},
};


//*****************************************************************************
//
// Table of useful information about ActorBvrType(s).
//
// Currently contains only a pointer to a function to instantiate a bvr track
// of the appropriate type.
//
//*****************************************************************************

typedef HRESULT (*CreateTrackInstance)(CActorBvr             *pbvrActor,
                                       BSTR                   bstrPropertyName,
                                       ActorBvrType           eType,
                                       CActorBvr::CBvrTrack **pptrackResult);

class CActorBvrType
{
public:
    ActorBvrType        m_eType;
    CreateTrackInstance m_fnCreate;
}; // CActorBvrType

static CActorBvrType
s_rgActorBvrTable[] =
{
    { e_Translation, &CActorBvr::CTransformBvrTrack::CreateInstance },
    { e_Rotation,    &CActorBvr::CTransformBvrTrack::CreateInstance },
    { e_Scale,       &CActorBvr::CTransformBvrTrack::CreateInstance },
    { e_Number,      &CActorBvr::CNumberBvrTrack::CreateInstance    },
	{ e_String,      &CActorBvr::CStringBvrTrack::CreateInstance    },
	{ e_Color,       &CActorBvr::CColorBvrTrack::CreateInstance     },
	{ e_Image,       &CActorBvr::CImageBvrTrack::CreateInstance		},
}; // s_rgActorBvrTable

const int s_cActorBvrTableEntries = (sizeof(s_rgActorBvrTable) / sizeof(CActorBvrType));


//*****************************************************************************
//
// class COnResizeHandler
//
//*****************************************************************************
COnResizeHandler::COnResizeHandler( CActorBvr* parent ):
	m_pActor( parent )
{
}

COnResizeHandler::~COnResizeHandler()
{
	m_pActor = NULL;
}

HRESULT
COnResizeHandler::HandleEvent()
{ 
	if( m_pActor!= NULL ) 
		return m_pActor->AnimatedElementOnResize(); 
	else 
		return S_OK;
}

//*****************************************************************************
//
// class COnUnloadHandler
//
//*****************************************************************************

COnUnloadHandler::COnUnloadHandler( CActorBvr *parent):
	m_pActor( parent )
{
}

COnUnloadHandler::~COnUnloadHandler()
{
	m_pActor = NULL;
}

HRESULT
COnUnloadHandler::HandleEvent()
{
	if( m_pActor != NULL )
		return m_pActor->OnWindowUnload();
	else
		return S_OK;
}

//*****************************************************************************
//
// class CBehaviorRebuild
//
//*****************************************************************************

CBehaviorRebuild::CBehaviorRebuild( IDispatch *pdispBehaviorElem )
{
	if( pdispBehaviorElem != NULL )
	{
		m_pdispBehaviorElem = pdispBehaviorElem;
		m_pdispBehaviorElem->AddRef();

		m_pdispBehaviorElem->QueryInterface( IID_TO_PPV( IUnknown, &m_punkBehaviorElem ) );
	}
	else
	{
		m_pdispBehaviorElem = NULL;
		m_punkBehaviorElem = NULL;
	}
}

//*****************************************************************************


CBehaviorRebuild::~CBehaviorRebuild()
{
	ReleaseInterface(m_pdispBehaviorElem);
	ReleaseInterface(m_punkBehaviorElem);
}

//*****************************************************************************

HRESULT
CBehaviorRebuild::RebuildBehavior( DISPPARAMS *pParams, VARIANT* pResult )
{
	if( pParams == NULL )
		return E_INVALIDARG;

	//it is legal to request a rebuild with null as the arg
	if( m_pdispBehaviorElem == NULL )
		return S_OK;

	//if they gave us a behavior disp to call through call through that,
	// otherwise call through the element

	HRESULT hr = S_OK;

//	IDispatch *pdispBehavior = NULL;

	DISPID dispid;

	WCHAR* wszBuildMethodName = L"buildBehaviorFragments";

/*
	IDispatch *pdispBehaviorElem = NULL;

	hr = m_pdispBehaviorElem->QueryInterface( IID_TO_PPV( IDispatch, &pdispBehaviorElem ) );
	CheckHR( hr, "", end );

	hr = CUtils::FindLMRTBehavior( pdispBehaviorElem, &pdispBehavior );
	ReleaseInterface( pdispBehaviorElem );
	CheckHR( hr, "Failed to get the lmrt behavior off of the element", end );

	hr = pdispBehavior->GetIDsOfNames( IID_NULL,
											 &wszBuildMethodName,
											 1,
											 LOCALE_SYSTEM_DEFAULT,
											 &dispid);

	CheckHR( hr, "Failed to find the id for buildBehaviorFragments on the dispatch", end );

	hr = pdispBehavior->Invoke( dispid,
									  IID_NULL,
									  LOCALE_SYSTEM_DEFAULT,
									  DISPATCH_METHOD,
									  pParams,
									  pResult,
									  NULL,
									  NULL );

	CheckHR( hr, "Failed to invoke buildBehaviorFragments on the behavior element", end );

*/
	hr = m_pdispBehaviorElem->GetIDsOfNames( IID_NULL,
											 &wszBuildMethodName,
											 1,
											 LOCALE_SYSTEM_DEFAULT,
											 &dispid);

	CheckHR( hr, "Failed to find the id for buildBehaviorFragments on the dispatch", end );

	

	hr = m_pdispBehaviorElem->Invoke( dispid,
									  IID_NULL,
									  LOCALE_SYSTEM_DEFAULT,
									  DISPATCH_METHOD,
									  pParams,
									  pResult,
									  NULL,
									  NULL );

	CheckHR( hr, "Failed to invoke buildBehaviorFragments on the behavior element", end );
		
end:

	//ReleaseInterface( pdispBehavior );
	if( FAILED( hr ) )
	{
		if( pResult != NULL )
			VariantClear( pResult );
	}

	return hr;

}

//*****************************************************************************
//
// class CBvrFragment
//
//*****************************************************************************

//*****************************************************************************

CActorBvr::CBvrTrack::CBvrFragment::CBvrFragment(ActorBvrFlags eFlags,
												 IDABehavior *pdabvrAction,
                                                 IDABoolean  *pdaboolActive,
												 IDANumber   *pdanumTimeline,
												 IDispatch	 *pdispBehaviorElement,
												 long		 lCookie)
{
    DASSERT(NULL != pdabvrAction);
    DASSERT(NULL != pdaboolActive);
	DASSERT(NULL != pdanumTimeline);
	DASSERT(pdispBehaviorElement != NULL);

	m_eFlags = eFlags;
    m_pdabvrAction  = pdabvrAction;
    m_pdabvrAction->AddRef();
    m_pdaboolActive = pdaboolActive;
    m_pdaboolActive->AddRef();
	m_pdanumTimeline = pdanumTimeline;
	m_pdanumTimeline->AddRef();
	HRESULT hr = pdispBehaviorElement->QueryInterface( IID_TO_PPV(IHTMLElement, &m_pelemBehaviorElement) );
	if( FAILED( hr ) )
	{
		DPF_ERR("QI for IHTMLElement on the dispatch of the element failed.  An invalid behavior fragment has been created." );
		m_pelemBehaviorElement = NULL;
	}
	m_pModifiableIntermediate = NULL;
	m_pModifiableFrom = NULL;

	m_lCookie = lCookie;
} // CBvrFragment

//*****************************************************************************

CActorBvr::CBvrTrack::CBvrFragment::~CBvrFragment()
{
    ReleaseInterface(m_pdabvrAction);
    ReleaseInterface(m_pdaboolActive);
	ReleaseInterface(m_pdanumTimeline);
	ReleaseInterface(m_pelemBehaviorElement);
	ReleaseInterface(m_pModifiableIntermediate);
	ReleaseInterface(m_pModifiableFrom);
} // ~CBvrFragment

//*****************************************************************************

/**
*  Returns a long that establishes a strict ordering for any list of behavior
*  fragments.  
*  Currently this method requires that no more that one behaviorFrag per 
*  vector (absolute or relative) per track comes from the same element.
*/
long
CActorBvr::CBvrTrack::CBvrFragment::GetOrderLong() const
{
	DASSERT( pelemBehaviorElement != NULL );
	
	long orderLong = -1;

	HRESULT hr = m_pelemBehaviorElement->get_sourceIndex( &orderLong );
	if( FAILED( hr ) )
	{
		DPF_ERR( "Failed to get the source index from a behavior fragment" );
	}

	return orderLong;
	
}

//*****************************************************************************

long
CActorBvr::CBvrTrack::CBvrFragment::GetCookie() const
{
	return m_lCookie;
}

//*****************************************************************************

CVarEmptyString::CVarEmptyString()
{
	VariantInit( &m_varEmptyString );
	V_VT(&m_varEmptyString) = VT_BSTR;
	V_BSTR(&m_varEmptyString) = SysAllocString( L"" );
}

//*****************************************************************************

CVarEmptyString::~CVarEmptyString()
{
	VariantClear( &m_varEmptyString );
}

//*****************************************************************************
//
// class CTimelineSampler
//
//*****************************************************************************

#define REQ_SAMPLE		0x1
#define REQ_OVERRIDE	0x2
#define REQ_OFF			0x4

CActorBvr::CTimelineSampler::CTimelineSampler(CBvrTrack *pTrack)
:	CSampler(TimelineCallback, (void*)this),
	m_pTrack(pTrack),
	m_currSampleTime(-1),
	m_prevSampleTime(-1),
	m_lastOnTime(-1),
	m_lastOffTime(-1),
	m_signDerivative(0),
	m_fRestarted( false )
{	
}

DWORD
CActorBvr::CTimelineSampler::RestartMask()
{
	// This is called to determine whether we think we have restarted,
	// either because of a loop or a beginEvent while we were running
	if (m_currSampleTime == -1 || m_prevSampleTime == -1)
	{
		// we're just starting up, assume we're not restarting
		// assume derivative is not negative yet
		return 0;
	}

	double diff = m_currSample - m_prevSample;

	if (diff > -MIN_TIMELINE_DIFF && diff < MIN_TIMELINE_DIFF)
		diff = 0;

	bool fRestarted = false;


	DWORD result = 0;

	if (diff < 0)
	{
		// Moving backward

		// Did we just start going backwards?  Does this mean we've autoreversed
		// or does it mean we've restarted?
		if (m_signDerivative != -1 && diff < -2*(m_currSampleTime - m_prevSampleTime))
		{
			LMTRACE2( 1, 2, "requested sample because of a big jump diff:%lg big: %lg\n", diff, -2*(m_currSampleTime - m_prevSampleTime) );
			// We detected a 'big jump' - request a sample and an override
			result = REQ_SAMPLE | REQ_OVERRIDE;

			fRestarted = true;
		}			
		
		m_signDerivative = -1;
	}
	else if (diff > 0)
	{
		// Moving forward
		if (m_signDerivative == -1 && !m_fRestarted )
		{
			LMTRACE2( 1, 2, "Requesting a sample because we bounced off the beginning of time\n" );
			// This is the 'bounce' condition where we bounce off the beginning time
			// Override and sample
			result = REQ_SAMPLE | REQ_OVERRIDE;
		}
		else if (m_signDerivative == 0 && m_lastOnTime != m_prevSampleTime)
		{
			LMTRACE2( 1, 2, "Requesting a sample because of a transition to endhold\n" );
			// This is a 'fudge' condition because the on boolean we get from DA
			// is messed up in autoReverse and endHold conditions, which means that
			// we miss the on transition.  This is an attempt to notice this by
			// seeing when we go from 0 derivative to positive derivative.  We try
			// not to do this when we sent an 'on' condition at the last sample
			result = REQ_SAMPLE | REQ_OVERRIDE;
		}

		m_signDerivative = 1;
	}
	else
	{
		m_signDerivative = 0;
	}

	m_fRestarted = fRestarted;

	return result;
}

void
CActorBvr::CTimelineSampler::TurnOn()
{
	m_lastOnTime = m_currSampleTime;
}

void
CActorBvr::CTimelineSampler::TurnOff()
{
	m_lastOffTime = m_currSampleTime;
}

HRESULT
CActorBvr::CTimelineSampler::TimelineCallback(void *thisPtr,
										   long id,
										   double startTime,
										   double globalNow,
										   double localNow,
										   IDABehavior *sampleVal,
										   IDABehavior **ppReturn)
{
	HRESULT hr = S_OK;

	IDANumber *pNumber = NULL;
	hr = sampleVal->QueryInterface(IID_TO_PPV(IDANumber, &pNumber));
	if (FAILED(hr))
		return hr;

	double value;
	hr = pNumber->Extract(&value);
	ReleaseInterface(pNumber);
	if (FAILED(hr))
		return hr;

	CTimelineSampler *pSampler = (CTimelineSampler*)thisPtr;

	if (pSampler == NULL)
		return E_FAIL;

	globalNow = pSampler->m_pTrack->Actor()->MapGlobalTime(globalNow);

	if (globalNow != pSampler->m_currSampleTime)
	{
		pSampler->m_prevSample = pSampler->m_currSample;
		pSampler->m_prevSampleTime = pSampler->m_currSampleTime;

		pSampler->m_currSample = value;
		pSampler->m_currSampleTime = globalNow;
	}

	return S_OK;
}

//*****************************************************************************
//
// class CBvrTrack
//
//*****************************************************************************

CActorBvr::CBvrTrack::CBvrTrack(CActorBvr    *pbvrActor,
                                ActorBvrType  eType)
:   m_pbvrActor(pbvrActor),
    m_eType(eType),
    m_bstrPropertyName(NULL),
	m_pNameComponents(NULL),
	m_cNumComponents(0),
	m_bStyleProp(false),
	m_pfragAbsListHead( NULL ),
	m_pfragRelListHead( NULL ),
    m_pdabvrFinal(NULL),
	m_bFinalComputed(false),
	m_bFinalExternallySet(false),
	m_pdabvrComposed(NULL),
	m_bComposedComputed(false),
	m_pModifiableStatic(NULL),
	m_pModifiableComposed(NULL),
	m_pModifiableFinal(NULL),
	m_pModifiableFrom(NULL),
	m_pModifiableIntermediate( NULL ),
    m_pNext(NULL),
	m_cFilters(0),
	m_bDoNotApply(false),
	m_pOnSampler( NULL ),
	m_varboolOn( VARIANT_FALSE ),
	m_pdaboolOn( NULL ),
	m_pIndexSampler(NULL),
	m_ppMaskSamplers(NULL),
	m_pCurrMasks(NULL),
	m_pNewMasks(NULL),
	m_ppTimelineSamplers(NULL),
	m_numIndices(0),
	m_numMasks(0),
	m_pIndex(NULL),
	m_currIndex(0),
	m_pIndexTimes(NULL),
	m_ppAccumBvrs(NULL),
    m_fOnSampled( false ),
	m_fValueSampled( false ),
	m_fValueChangedThisSample( false ),
	m_fForceValueChange( false ),
	m_dwAddedBehaviorFlags( 0 ),
	m_lOnCookie( 0 ),
	m_bDirty( false ),
	m_fApplied( false ),
	m_fChangesLockedOut(false),
	m_fSkipNextStaticUpdate( false ),
	m_lOnId( -1 ),
	m_lFirstIndexId( -1 ),
	m_bWasAnimated( false )
{
    DASSERT(NULL != pbvrActor);

    VariantInit( &m_varCurrentValue );
    VariantInit( &m_varStaticValue );

} // CBvrTrack

//*****************************************************************************

CActorBvr::CBvrTrack::~CBvrTrack()
{

	//detach this track from DA
	Detach();
	
    // Discard the property name
    ::SysFreeString(m_bstrPropertyName);

	// Discard name components
	if (m_pNameComponents != NULL)
	{
		for (int i=0; i<m_cNumComponents; i++)
			::SysFreeString(m_pNameComponents[i]);

		delete m_pNameComponents;
	}

	if( m_pOnSampler != NULL )
	{
		m_pOnSampler->Invalidate();
		m_pOnSampler = NULL;
	}

	if (m_pIndexSampler != NULL)
	{
		m_pIndexSampler->Invalidate();
		m_pIndexSampler = NULL;
	}

	if (m_ppMaskSamplers != NULL)
	{
		for (int i=0; i<m_numMasks; i++)
		{
			if (m_ppMaskSamplers[i] != NULL)
			{
				m_ppMaskSamplers[i]->Invalidate();
			}
		}
		delete[] m_ppMaskSamplers;
		m_ppMaskSamplers = NULL;
	}

	if (m_ppTimelineSamplers != NULL)
	{
		for (int i=0; i<m_numIndices; i++)
		{
			if (m_ppTimelineSamplers[i] != NULL)
			{
				m_ppTimelineSamplers[i]->Invalidate();
			}
		}
		delete[] m_ppTimelineSamplers;
		m_ppTimelineSamplers = NULL;
	}

	if (m_pCurrMasks != NULL)
	{
		delete[] m_pCurrMasks;
	}

	if (m_pNewMasks != NULL)
	{
		delete[] m_pNewMasks;
	}

	if (m_pIndexTimes != NULL)
	{
		delete[] m_pIndexTimes;
	}

	if (m_ppAccumBvrs != NULL)
	{
		for (int i=0; i<m_numIndices; i++)
			ReleaseInterface(m_ppAccumBvrs[i]);
		delete[] m_ppAccumBvrs;
		m_ppAccumBvrs = NULL;
	}

	VariantClear( &m_varCurrentValue );
	VariantClear( &m_varStaticValue );


	ReleaseAllFragments();

    ReleaseInterface(m_pdabvrFinal);
	ReleaseInterface(m_pdabvrComposed);
	ReleaseInterface(m_pModifiableStatic);
	ReleaseInterface(m_pModifiableComposed);
	ReleaseInterface(m_pModifiableFinal);
	ReleaseInterface(m_pModifiableFrom);
	ReleaseInterface(m_pdaboolOn);
	ReleaseInterface(m_pIndex);
	
} // ~CBvrTrack

//*****************************************************************************

bool
CActorBvr::CBvrTrack::ContainsFilter()
{
	// TODO (markhal): Rename this to absRelative?
	return (m_cFilters != 0);
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::BeginRebuild()
{
	//return S_FALSE if a rebuild was not required.
	if( !m_bDirty )
		return S_FALSE;

	HRESULT hr = S_OK;

	//detach all behaviors from time.
	Detach();

	//clean up state left by the last build of this track.
	CleanTrackState();

	//mark the track as clean
	m_bDirty = false;

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::ForceRebuild()
{
	m_bDirty = true;

	return BeginRebuild();
}


//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::CleanTrackState()
{

	//reset all on/value state
	m_fOnSampled = false;
	m_fValueSampled = false;
	m_fValueChangedThisSample = false;
	m_fForceValueChange = false;
    //release the non switcher final
	m_bFinalComputed = false;
	m_bFinalExternallySet = false;
	ReleaseInterface( m_pdabvrFinal );

    //release the non switchabe composed bvr
	m_bComposedComputed = false;
	ReleaseInterface( m_pdabvrComposed );

	//release on sampling 
	if (m_pOnSampler != NULL )
	{
		m_pOnSampler->Invalidate();
		m_pOnSampler = NULL;
	}
	ReleaseInterface( m_pdaboolOn );

    //release the index sampler
	if( m_pIndexSampler != NULL )
	{
		m_pIndexSampler->Invalidate();
		m_pIndexSampler = NULL;
	}

    //release the index behavior
	ReleaseInterface( m_pIndex );
	m_lFirstIndexId = -1;

    //release the mask samplers if there are any
	if (m_ppMaskSamplers != NULL)
	{
		for (int i=0; i<m_numMasks; i++)
		{
			if (m_ppMaskSamplers[i] != NULL)
			{
				m_ppMaskSamplers[i]->Invalidate();
			}
		}
		delete[] m_ppMaskSamplers;
		m_ppMaskSamplers = NULL;
	}

    //release the index times
	delete[] m_pIndexTimes;
    m_pIndexTimes = NULL;

    //release the accumulated behaviors
	if (m_ppAccumBvrs != NULL)
	{
		for (int i=0; i<m_numIndices; i++)
			ReleaseInterface(m_ppAccumBvrs[i]);
		delete[] m_ppAccumBvrs;
		m_ppAccumBvrs = NULL;
	}

    //release the timeline samplers
	if (m_ppTimelineSamplers != NULL)
	{
		for (int i=0; i<m_numIndices; i++)
		{
			if (m_ppTimelineSamplers[i] != NULL)
			{
				m_ppTimelineSamplers[i]->Invalidate();
			}
		}
		delete[] m_ppTimelineSamplers;
		m_ppTimelineSamplers = NULL;
	}

	m_fApplied = false;

    //when the light is green the track is clean...

    return S_OK;
	
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::UninitBvr(IDABehavior **ppUninit)
{
	// This needs to be overridden
	return E_NOTIMPL;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::ModifiableBvr( IDABehavior **ppModifiable )
{
	return E_NOTIMPL;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::ModifiableBvr( IDABehavior *pdabvrInitialValue, IDABehavior **ppModifiable )
{
	return E_NOTIMPL;
}

//*****************************************************************************

// Compose all of the absolute behavior fragments into a single composite
// behavior based on the boolean active parameters.
//
// NOTE: The list is organized in ascending priority order (highest priority
// behavior at the tail of the list - lowest at the head).

HRESULT
CActorBvr::CBvrTrack::ComposeAbsBvrFragList(IDABehavior *pStatic, IDABehavior **ppdabvrComposite)
{
	HRESULT hr = S_OK;

    DASSERT(NULL != ppdabvrComposite);
    *ppdabvrComposite = NULL;

	// Count up the number of fragments
	int count =  0;
	CBvrFragment* pfragCurrent = m_pfragAbsListHead;
	while(pfragCurrent != NULL)
	{
		count++;
		pfragCurrent = pfragCurrent->m_pfragNext;
	}

	// Return static if there are no frags
	if (count == 0)
	{
		*ppdabvrComposite = pStatic;
		if (pStatic != NULL)
			pStatic->AddRef();
		return S_OK;
	}

	// Can only handle x of these :-)
	if (count > MSK_MAX_FRAGS)
		return E_FAIL;

	// Allocate count index times
	if (m_pIndexTimes != NULL)
		delete[] m_pIndexTimes;

	m_pIndexTimes = new double[count];
	if (m_pIndexTimes == NULL)
		return E_FAIL;

	for (int i=0; i<count; i++)
		m_pIndexTimes[i] = -1;

	//free the accumBvrs
	if (m_ppAccumBvrs != NULL)
	{
		for (int i=0; i<m_numIndices; i++)
			ReleaseInterface(m_ppAccumBvrs[i]);
		delete[] m_ppAccumBvrs;
		m_ppAccumBvrs = NULL;
	}
	

	// Allocate this many timeline samplers
	if (m_ppTimelineSamplers != NULL)
	{
		for( int curSampler = 0; curSampler < m_numIndices; curSampler++ )
		{
			if( m_ppTimelineSamplers[curSampler] != NULL )
				m_ppTimelineSamplers[curSampler]->Invalidate();
		}
		delete[] m_ppTimelineSamplers;
	}

	m_numIndices = count;


	m_ppTimelineSamplers = new CTimelineSampler*[m_numIndices];
	if (m_ppTimelineSamplers == NULL)
		return E_FAIL;

	for (i=0; i<m_numIndices; i++)
		m_ppTimelineSamplers[i] = NULL;

	// Allocate this number of curr and new masks and samplers
	if (m_ppMaskSamplers != NULL)
	{
		for( int curSampler = 0; curSampler < m_numMasks; curSampler++ )
		{
			if( m_ppMaskSamplers[curSampler] != NULL )
				m_ppMaskSamplers[curSampler]->Invalidate();
		}
		delete[] m_ppMaskSamplers;
	}

	// Figure out how many masks we'll need
	m_numMasks = ((m_numIndices-1) / MSK_FREE_BITS) + 1;


	m_ppMaskSamplers = new CSampler*[m_numMasks];
	if (m_ppMaskSamplers == NULL)
		return E_FAIL;

	for (i=0; i<m_numMasks; i++)
		m_ppMaskSamplers[i] = NULL;

	if (m_pCurrMasks != NULL)
		delete[] m_pCurrMasks;

	m_pCurrMasks = new DWORD[m_numMasks];
	if (m_pCurrMasks == NULL)
		return E_FAIL;

	if (m_pNewMasks != NULL)
		delete[] m_pNewMasks;

	m_pNewMasks = new DWORD[m_numMasks];
	if (m_pNewMasks == NULL)
		return E_FAIL;

	for (i=0; i<m_numMasks; i++)
	{
		m_pCurrMasks[i] = m_pNewMasks[i] = 0;
	}

	// Allocate count+1 bvrs
	// These things are released in the failure goto
	IDABehavior **ppBvrs = new IDABehavior*[count+1];
	IDANumber *pIndex = NULL;
	IDANumber *pLocalIndex = NULL;
	IDANumber *pLocalTimeline = NULL;
	IDANumber *pZero = NULL;
	IDABehavior *pTemp = NULL;
	IDANumber *pNumTemp = NULL;
	IDAArray *pArray = NULL;
	int multiplier = 1 << MSK_INDEX_BITS;
	int position = 1;
	int currIndex = 0;


	// NULL them out so we can do error recovery
	for (i=0; i<=count; i++)
		ppBvrs[i] = NULL;

	// Put static in slot 0
	if (pStatic != NULL)
	{
		ppBvrs[0] = pStatic;
		pStatic->AddRef();
	}
	else
	{
		// static is NULL, put in the identity
		hr = IdentityBvr(&(ppBvrs[0]));
		if (FAILED(hr))
		{
			ppBvrs[0] = NULL;
			goto failure;
		}
	}

	// Get zero number
	hr = Actor()->GetDAStatics()->DANumber(0, &pZero);
	if (FAILED(hr))
	{
		pZero = NULL;
		goto failure;
	}

	// Initialize local index with 0 
	pLocalIndex = pZero;
	pZero->AddRef();

	// Loop through other behaviors putting them in and making up a bit pattern from the
	// booleans
	pfragCurrent = m_pfragAbsListHead;
    while (pfragCurrent != NULL)
    {
        CBvrFragment* pfragNext = pfragCurrent->m_pfragNext;

		// Process the bvr
		IDABehavior *pProcessed = NULL;
		hr = ProcessBvr(pfragCurrent->m_pdabvrAction, pfragCurrent->m_eFlags, &pProcessed);
		if (FAILED(hr))
			goto failure;

		// Handle RelativeAccum and RelativeReset
		if (pfragCurrent->m_eFlags == e_Absolute)
		{
			if (pfragCurrent->m_pModifiableFrom != NULL)
			{
				// Initialize with static
				hr = pfragCurrent->m_pModifiableFrom->SwitchTo(ppBvrs[0]);
				if (FAILED(hr))
					goto failure;
			}
		}
		else if (pfragCurrent->m_eFlags == e_AbsoluteAccum)
		{
			if (pfragCurrent->m_pModifiableFrom != NULL)
			{
				// Initialize with sample

				// Allocate m_ppAccumBvrs if necessary, because we don't
				// always allocate it
				if (m_ppAccumBvrs == NULL)
				{
					m_ppAccumBvrs = new IDABehavior*[m_numIndices];
					if (m_ppAccumBvrs == NULL)
						goto failure;

					for (int i=0; i<m_numIndices; i++)
						m_ppAccumBvrs[i] = NULL;
				}

				// Create a modifiable behavior based on the static value
				hr = Actor()->GetDAStatics()->ModifiableBehavior(ppBvrs[0], &m_ppAccumBvrs[position-1]);
				if (FAILED(hr))
				{
					m_ppAccumBvrs[position-1] = NULL;
					goto failure;
				}

				hr = pfragCurrent->m_pModifiableFrom->SwitchTo(m_ppAccumBvrs[position-1]);
				if (FAILED(hr))
					goto failure;
			}
		}
		else if (pfragCurrent->m_eFlags == e_RelativeReset)
		{
			if (pfragCurrent->m_pModifiableFrom != NULL)
			{
				// Initialize with identity
				IDABehavior *pIdentity = NULL;
				hr = IdentityBvr(&pIdentity);
				if (FAILED(hr))
					goto failure;

				hr = pfragCurrent->m_pModifiableFrom->SwitchTo(pIdentity);
				ReleaseInterface(pIdentity);
				if (FAILED(hr))
					goto failure;
			}

			// In this case we simply compose the behavior with the static value
			hr = Compose(ppBvrs[0], pProcessed, &pTemp);
			ReleaseInterface(pProcessed);
			if (FAILED(hr))
				goto failure;
			pProcessed = pTemp;
			pTemp = NULL;
		}
		else if (pfragCurrent->m_eFlags == e_RelativeAccum)
		{
			// Allocate m_ppAccumBvrs if necessary, because we don't
			// always allocate it
			if (m_ppAccumBvrs == NULL)
			{
				m_ppAccumBvrs = new IDABehavior*[m_numIndices];
				if (m_ppAccumBvrs == NULL)
					goto failure;

				for (int i=0; i<m_numIndices; i++)
					m_ppAccumBvrs[i] = NULL;
			}

			// Create a modifiable behavior based on the static value
			hr = Actor()->GetDAStatics()->ModifiableBehavior(ppBvrs[0], &m_ppAccumBvrs[position-1]);
			if (FAILED(hr))
			{
				m_ppAccumBvrs[position-1] = NULL;
				goto failure;
			}

			if (pfragCurrent->m_pModifiableFrom != NULL)
			{
				// Initialize with accum-static and compose with static
				IDABehavior *pInverse = NULL;
				hr = InverseBvr(ppBvrs[0], &pInverse);
				if (FAILED(hr))
					goto failure;

				IDABehavior *pInitial = NULL;
				hr = Compose(m_ppAccumBvrs[position-1], pInverse, &pInitial);
				ReleaseInterface(pInverse);
				if (FAILED(hr))
					goto failure;

				hr = pfragCurrent->m_pModifiableFrom->SwitchTo(pInitial);
				ReleaseInterface(pInitial);
				if (FAILED(hr))
					goto failure;

				// Compose with static
				hr = Compose(ppBvrs[0], pProcessed, &pTemp);
				ReleaseInterface(pProcessed);
				if (FAILED(hr))
					goto failure;
				pProcessed = pTemp;
				pTemp = NULL;
			}
			else
			{
				// Compose with the modifiable
				hr = Compose(m_ppAccumBvrs[position-1], pProcessed, &pTemp);
				ReleaseInterface(pProcessed);
				if (FAILED(hr))
					goto failure;
				pProcessed = pTemp;
				pTemp = NULL;
			}
		}

		// Put it in the array
		ppBvrs[position] = pProcessed;
		pProcessed = NULL;

        // Build the boolean for on
        IDABehavior* pTemp = NULL;
		IDANumber *pNum = NULL;
		hr = Actor()->GetDAStatics()->DANumber(multiplier, &pNum);
		if (FAILED(hr))
			goto failure;

		/*
        hr = Actor()->GetDAStatics()->Cond(pfragCurrent->m_pdaboolActive,
                                           pNum,
                                           pZero,
                                           &pTemp);
        */
        hr = Actor()->SafeCond( Actor()->GetDAStatics(),
					   		   pfragCurrent->m_pdaboolActive,
        			   		   pNum,
        			   		   pZero,
        			   		   &pTemp );
        			   
		ReleaseInterface(pNum);
		if (FAILED(hr))
			goto failure;

		// Get the num back out and add it to the local index
		hr = pTemp->QueryInterface(IID_TO_PPV(IDANumber, &pNum));
		ReleaseInterface(pTemp);
		if (FAILED(hr))
			goto failure;

		if (pLocalIndex == NULL)
			pLocalIndex = pNum;
		else
		{
			IDANumber *pTotal = NULL;
			hr = Actor()->GetDAStatics()->Add(pLocalIndex, pNum, &pTotal);
			ReleaseInterface(pNum);
			ReleaseInterface(pLocalIndex);
			if (FAILED(hr))
				goto failure;
			pLocalIndex = pTotal;
		}

		// Sample the timeline
		m_ppTimelineSamplers[position-1] = new CTimelineSampler(this);
		if (m_ppTimelineSamplers[position-1] == NULL)
			goto failure;

		hr = m_ppTimelineSamplers[position-1]->Attach(pfragCurrent->m_pdanumTimeline, &pTemp);
		if (FAILED(hr))
			goto failure;

		hr = pTemp->QueryInterface(IID_TO_PPV(IDANumber, &pNum));
		ReleaseInterface(pTemp);
		if (FAILED(hr))
			goto failure;

		if (pLocalTimeline == NULL)
			pLocalTimeline = pNum;
		else
		{
			IDANumber *pTotal = NULL;
			hr = Actor()->GetDAStatics()->Add(pLocalTimeline, pNum, &pTotal);
			ReleaseInterface(pNum);
			ReleaseInterface(pLocalTimeline);
			if (FAILED(hr))
				goto failure;
			pLocalTimeline = pTotal;
		}

		pfragCurrent = pfragNext;

		if ((position % MSK_FREE_BITS) != 0 && pfragCurrent != NULL)
		{
			// Normal case - step to next position/bit
			position++;
			multiplier *= 2;
		}
		else
		{
			// We've used up all our free bits or fragments.
			// We sample local forward and local index

			// Create a sampler for local forward
			m_ppMaskSamplers[currIndex] = new CSampler(MaskCallback, (void*)this);
			if (m_ppMaskSamplers[currIndex] == NULL)
				goto failure;

			hr = m_ppMaskSamplers[currIndex]->Attach(pLocalIndex, &pTemp);
			ReleaseInterface(pLocalIndex);
			if (FAILED(hr))
				goto failure;

			hr = pTemp->QueryInterface(IID_TO_PPV(IDANumber, &pLocalIndex));
			ReleaseInterface(pTemp);
			if (FAILED(hr))
				goto failure;

			// Subtract pLocalTimeline from pLocalIndex.  Add to pIndex
			hr = Actor()->GetDAStatics()->Sub(pLocalIndex, pLocalTimeline, &pNumTemp);
			ReleaseInterface(pLocalTimeline);
			ReleaseInterface(pLocalIndex);
			if (FAILED(hr))
				goto failure;

			if (pIndex == NULL)
			{
				pIndex = pNumTemp;
			}
			else
			{
				hr = Actor()->GetDAStatics()->Add(pIndex, pNumTemp, &pLocalIndex);
				ReleaseInterface(pIndex);
				ReleaseInterface(pNumTemp);
				if (FAILED(hr))
					goto failure;
				pIndex = pLocalIndex;
				pLocalIndex = NULL;
			}

			if (pfragCurrent != NULL)
			{
				// Set up for next time around the loop
				currIndex++;
				position++;
				multiplier = 1 << MSK_INDEX_BITS;

				hr = Actor()->GetDAStatics()->DANumber(currIndex, &pLocalIndex);
				if (FAILED(hr))
					goto failure;
			}
		}
	}

	// Sample the index behavior
	m_pIndexSampler = new CSampler(IndexCallback, (void*)this);
	if (m_pIndexSampler == NULL)
		goto failure;

	hr = m_pIndexSampler->Attach(pIndex, &pTemp);
	ReleaseInterface(pIndex);
	if (FAILED(hr))
		goto failure;
	
	hr = pTemp->QueryInterface(IID_TO_PPV(IDANumber, &pIndex));
	ReleaseInterface(pTemp);
	if (FAILED(hr))
		goto failure;

	// Create an array of bvrs
	hr = Actor()->GetDAStatics()->DAArrayEx(count+1, ppBvrs, &pArray);
	if (FAILED(hr))
		goto failure;

	// Index into it
	IDABehavior *pResult;
	hr = pArray->NthAnim(pIndex, &pResult);
	ReleaseInterface(pIndex);
	ReleaseInterface(pArray);
	if (FAILED(hr))
		goto failure;

	if (m_ppAccumBvrs != NULL)
	{
		// We need to hook the result
		hr = HookAccumBvr(pResult, &pTemp);
		ReleaseInterface(pResult);
		if (FAILED(hr))
			goto failure;

		pResult = pTemp;
		pTemp = NULL;
	}

	*ppdabvrComposite = pResult;
	pResult = NULL;

    hr = S_OK;

failure:
	// Need to release all the entries in the array
	for (i=0; i<=count; i++)
		ReleaseInterface(ppBvrs[i]);

	delete[] ppBvrs;

	ReleaseInterface(pIndex);
	ReleaseInterface(pLocalIndex);
	ReleaseInterface(pLocalTimeline);
	ReleaseInterface(pZero);

	return hr;
} // ComposeAbsBvrFragList

HRESULT
CActorBvr::CBvrTrack::ComputeIndex(long id, double currTime, IDABehavior **ppReturn)
{
	DWORD changedMask;
	DWORD onMask;
	int newIndex;

	if( m_lFirstIndexId == -1 )
		m_lFirstIndexId = id;

	if ( m_lFirstIndexId != id )
	{
		newIndex = m_currIndex;
	}
	else
	{


		int currMask = -1;
		int maxPos = -1;
		double max = -1;
		for (int i=0; i<m_numIndices; i++)
		{
			if (i % MSK_FREE_BITS == 0)
			{
				// We've switched to a new set of masks
				currMask++;

				// Figure out who has changed on/off
				changedMask = m_pNewMasks[currMask] ^ m_pCurrMasks[currMask];
				m_pCurrMasks[currMask] = m_pNewMasks[currMask];

				onMask = m_pNewMasks[currMask];
			}

			// Figure out whether we should resample and/or override
			DWORD sampleOverrideMask = m_ppTimelineSamplers[i]->RestartMask();

			if ((changedMask & 0x1) != 0 || sampleOverrideMask != 0)
			{
				// This index either turned on/off or restarted
				if ((onMask & 0x1) == 0)
				{
					// This index is off now
					m_pIndexTimes[i] = -1;

					// Tell the sampler that we've turned off
					m_ppTimelineSamplers[i]->TurnOff();
				}
				else if ((sampleOverrideMask & REQ_OFF) != 0)
				{
					// This is a special 'fudge' condition that occurs when
					// the boolean is incorrect and we need to estimate when we turned off
					m_pIndexTimes[i] = -1;
				}
				else
				{
					if ((changedMask & 0x1) != 0)
					{
						LMTRACE2( 1, 2, "Requesting sample because we turned on" );
						// We turned on, always want to sample and override
						sampleOverrideMask = REQ_SAMPLE | REQ_OVERRIDE;

						// Tell the sampler that we've turned on so it can record the time
						m_ppTimelineSamplers[i]->TurnOn();
					}

					if ((sampleOverrideMask & REQ_OVERRIDE) != 0)
					{
						// Need to override others
						m_pIndexTimes[i] = currTime;
					}

					// Do we need to resample?
					if ((sampleOverrideMask & REQ_SAMPLE) != 0 &&
						m_ppAccumBvrs != NULL &&
						m_ppAccumBvrs[i] != NULL)
					{
						SwitchAccum(m_ppAccumBvrs[i]);
					}
				}
			}

			// Check if we got a new max
			if (m_pIndexTimes[i] >= max)
			{
				max = m_pIndexTimes[i];
				maxPos = i;
			}

			changedMask >>= 1;
			onMask >>= 1;
		}

		if (max == -1)
		{
			// Nothing is on, just use 0
			newIndex = 0;
		}
		else
		{
			// Something was on, the index we want to return is maxPos+1,
			// since we have the static in pos 0 of the array
			newIndex = maxPos+1;
		}
	}

	if (m_currIndex != newIndex || m_pIndex == NULL)
	{
		LMTRACE2( 1, 2, "Index changed! %d->%d\n", m_currIndex, newIndex );
		m_currIndex = newIndex;

		ReleaseInterface(m_pIndex);

		HRESULT hr = Actor()->GetDAStatics()->DANumber(newIndex, &m_pIndex);
		if (FAILED(hr))
			return hr;
	}

	*ppReturn = m_pIndex;
	m_pIndex->AddRef();

	return S_OK;
}

HRESULT
CActorBvr::CBvrTrack::IndexCallback(void* thisPtr,
						long id,
						double startTime,
						double globalNow,
						double localNow,
						IDABehavior* sampleVal,
						IDABehavior **ppReturn)
{

	CBvrTrack *pTrack = reinterpret_cast<CBvrTrack*>(thisPtr);

	if( pTrack == NULL )
		return E_FAIL;

	globalNow = pTrack->Actor()->MapGlobalTime(globalNow);

	pTrack->ComputeIndex(id, globalNow, ppReturn);

	return S_OK;
}

HRESULT
CActorBvr::CBvrTrack::MaskCallback(void* thisPtr,
						long id,
						double startTime,
						double globalNow,
						double localNow,
						IDABehavior* sampleVal,
						IDABehavior **ppReturn)
{
	CBvrTrack *pTrack = reinterpret_cast<CBvrTrack*>(thisPtr);

	if( pTrack == NULL || sampleVal == NULL )
		return E_INVALIDARG;

	HRESULT hr;

	// Extract the sampled value
	IDANumber *pSample = NULL;
	hr = sampleVal->QueryInterface(IID_TO_PPV(IDANumber, &pSample));
	if (FAILED(hr))
		return hr;

	double val = 0;
	hr = pSample->Extract(&val);
	ReleaseInterface(pSample);
	if (FAILED(hr))
		return hr;

	// Cast it to a DWORD
	DWORD mask = (DWORD)val;

	// Figure out which index to put it into
	int index = mask & MSK_INDEX_MASK;

	// Figure out what the real mask is
	mask >>= MSK_INDEX_BITS;

	// Stick it into the array
	if (index < pTrack->m_numMasks)
		pTrack->m_pNewMasks[index] = mask;

	return S_OK;
}

HRESULT
CActorBvr::CBvrTrack::SwitchAccum(IDABehavior *pModifiable)
{
	// Base implementation does nothing
	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::Detach()
{
	HRESULT hr = S_OK;

	hr = RemoveBehaviorFromTIME( m_lOnCookie, ONBVR_COOKIESET );
	m_lOnId = -1;
    
	return hr;
	
}

//*****************************************************************************
//  changes the current value of the static property as this track sees it.

HRESULT
CActorBvr::CBvrTrack::PutStatic( VARIANT *pvarNewStatic )
{

	if( pvarNewStatic == NULL )
		return E_INVALIDARG;
	//TODO: do we want to update the value on the element itself here?
	HRESULT hr = S_OK;

	IDABehavior *pdabvrStatic = NULL;

	//we have to change the static to a string here, since some attributes, event
	// though they return non strings when you get them, dont like it when you 
	// set that same non string back into them. ( i.e. color properties on VML )
	hr = VariantChangeTypeEx( &m_varStaticValue, pvarNewStatic, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR );
	CheckHR( hr, "Failed to change the passed static to a string", end );
	
	/*
	//copy the value of the variant into our internal variant
	hr = VariantCopy( &m_varStaticValue, pvarNewStatic );
	CheckHR( hr, "Failed to copy the new static value into the track", end );
	*/

	//convert the variant into a da behavior of the correct type for this track
	hr = DABvrFromVariant( pvarNewStatic, &pdabvrStatic );
	CheckHR( hr, "Failed to create a DA Behavior for the variant", end );

	//if the switchable static value has not yet been created
	if( m_pModifiableStatic == NULL )
	{
		//create it.
		hr = Actor()->GetDAStatics()->ModifiableBehavior( pdabvrStatic, &m_pModifiableStatic );

		if( FAILED( hr ) )
		{
			LMTRACE2(1, 1000, "Failure to create modifiable behavior for %S\n", m_bstrPropertyName );
		}

		CheckHR( hr, "Failed to create a modifiable behavior for the static", end );
	}
	else
	{
		//switch the new value into the static behavior.
		hr = m_pModifiableStatic->SwitchTo( pdabvrStatic );
		CheckHR( hr, "Failed to switch in new static bvr", end );
	}

end:
	ReleaseInterface( pdabvrStatic );

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::SkipNextStaticUpdate()
{
	m_fSkipNextStaticUpdate = true;

	return S_OK;
}


//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::GetStatic( VARIANT *pvarStatic )
{
	if( pvarStatic == NULL )
		return E_INVALIDARG;
		
	HRESULT hr = S_OK;

	hr = VariantCopy( pvarStatic, &m_varStaticValue );

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::GetDynamic( VARIANT *pvarDynamic )
{

	if( pvarDynamic == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	hr = VariantCopy( pvarDynamic, &m_varCurrentValue );

	return hr;
	
}


//*****************************************************************************
// subclasses should convert the variant into the proper type of DA Behavior and
//   return that as ppdabvr.

HRESULT
CActorBvr::CBvrTrack::DABvrFromVariant( VARIANT *pvarVariant, IDABehavior **ppdabvr )
{
	return E_NOTIMPL;
}

//*****************************************************************************


HRESULT
CActorBvr::CBvrTrack::AcquireChangeLockout()
{
	LMTRACE2(1, 1000, L"Change lockout for track %s acquired\n", m_bstrPropertyName );
	m_fChangesLockedOut = true;

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::ReleaseChangeLockout()
{
	LMTRACE2( 1, 1000, L"Change lockout for track %s released\n", m_bstrPropertyName );
	m_fChangesLockedOut = false;

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::ApplyStatic()
{
	HRESULT hr = S_OK;
	
	if( m_bStyleProp )
	{
		//remove the settings in the runtime style
		hr = SetPropFromVariant( const_cast<VARIANT*>(s_emptyString.GetVar()));
	}
	else
	{
		//set back the static value into the property
		hr = SetPropFromVariant( &m_varStaticValue );
	}

	return hr;
}

//*****************************************************************************


HRESULT
CActorBvr::CBvrTrack::ApplyDynamic()
{
	HRESULT hr;

	hr = SetPropFromVariant( &m_varCurrentValue );

	return hr;
}

//*****************************************************************************

// Compose all of the relative behavior fragments into a single composite
// behavior based on the boolean active parameters.
//
// NOTE: The list is organized in ascending priority order (highest priority
// behavior at the tail of the list - lowest at the head).
HRESULT
CActorBvr::CBvrTrack::ComposeRelBvrFragList(IDABehavior *pAbsolute, IDABehavior **ppdabvrComposite)
{
    DASSERT(NULL != ppdabvrComposite);
    *ppdabvrComposite = NULL;

    // Compute the identity for this track.
    IDABehavior* pIdentity = NULL;
    HRESULT hr = IdentityBvr(&pIdentity);
    if (FAILED(hr))
    {
        DPF_ERR("Failed to create the identity behavior for this track type");
        return hr;
    }

	// This is the composite. pAbsolute might be NULL
	IDABehavior *pComposite = pAbsolute;
	if (pComposite != NULL)
		pComposite->AddRef();

	//init the head intermediate with the absolute value.
	if( m_pfragRelListHead != NULL && 
		m_pfragRelListHead->m_pModifiableIntermediate != NULL )
	{
		//process the absolute behavior
		IDABehavior *pInitWith;
        hr = ProcessIntermediate( pAbsolute, m_pfragRelListHead->m_eFlags, &pInitWith );
        if( FAILED(hr) )
        {
			DPF_ERR("Failed to process intermediate");
			return hr;
        }

		//switch in the intermediate value for the first fragment
		hr = m_pfragRelListHead->m_pModifiableIntermediate->SwitchTo(pInitWith);
        ReleaseInterface( pInitWith );
		if (FAILED(hr))
		{
			DPF_ERR("Failed to initialize intermediate");
			return hr;
		}
	}

	CBvrFragment* pfragCurrent = m_pfragRelListHead;

    while (pfragCurrent != NULL)
    {
		CBvrFragment* pfragNext = pfragCurrent->m_pfragNext;

        // Build a behavior which consists of the identity
        // behavior when the boolean is not active and the fragment
		// behavior when it is.
        IDABehavior* pTemp1 = NULL;
		IDABehavior* pTemp2 = NULL;

		// Process the bvr
		IDABehavior *pProcessed = NULL;
		hr = ProcessBvr(pfragCurrent->m_pdabvrAction, pfragCurrent->m_eFlags, &pProcessed);
		if (FAILED(hr))
		{
			ReleaseInterface(pComposite);
			ReleaseInterface(pIdentity);
			return hr;
		}

		if (pfragCurrent->m_eFlags == e_Filter)
		{
			// if pComposite it still NULL, make it the identity
			if (pComposite == NULL)
			{
				hr = IdentityBvr(&pComposite);
				if (FAILED(hr))
				{
					DPF_ERR("Failed to get identity");
					ReleaseInterface(pIdentity);
					return hr;
				}
			}

			// Filters are like absolute things in the middle of a relative list
			/*
			hr = Actor()->GetDAStatics()->Cond(pfragCurrent->m_pdaboolActive,
											   pProcessed,
											   pComposite,
											   &pTemp1);
			*/
			
			hr = Actor()->SafeCond( Actor()->GetDAStatics(),
								   pfragCurrent->m_pdaboolActive,
								   pProcessed,
								   pComposite,
								   &pTemp1 );
								   
			ReleaseInterface(pProcessed);
			ReleaseInterface(pComposite);
			if (FAILED(hr))
			{
				ReleaseInterface(pIdentity);
				DPF_ERR("Failed to create conditional");
				return hr;
			}
			
			pComposite = pTemp1;
			/*
			ReleaseInterface(pComposite );
			pComposite = pProcessed;
			*/
		}
		else
		{

			/*
			hr = Actor()->GetDAStatics()->Cond(pfragCurrent->m_pdaboolActive,
											   pProcessed,
											   pIdentity,
											   &pTemp1);
			*/
			hr = Actor()->SafeCond( Actor()->GetDAStatics(),
					   			   pfragCurrent->m_pdaboolActive,
					   			   pProcessed,
					   			   pIdentity,
					   			   &pTemp1 );
			ReleaseInterface(pProcessed);
			if (FAILED(hr))
			{
				ReleaseInterface(pComposite);
				ReleaseInterface(pIdentity);
				DPF_ERR("Failed to create conditional");
				return hr;
			}

			if (pComposite == NULL)
			{
				// No composite just yet
				pComposite = pTemp1;
				pTemp1 = NULL;
			}
			else
			{
				// Compose this conditional with the existing composite
				HRESULT hr = Compose(pTemp1,
									 pComposite,
									 &pTemp2);
				ReleaseInterface(pTemp1);
				ReleaseInterface(pComposite);
				if (FAILED(hr))
				{
					ReleaseInterface(pComposite);
					ReleaseInterface(pIdentity);
					DPF_ERR("Failed to compose");
					return hr;
				}
				pComposite = pTemp2;
				pTemp2 = NULL;
			}
		}

		// If there is a modifiable intermediate on the next fragment, switch it now
		if (pfragNext != NULL && pfragNext->m_pModifiableIntermediate != NULL)
		{
            IDABehavior *pInitWith;
            hr = ProcessIntermediate( pComposite, pfragNext->m_eFlags, &pInitWith );
            if( FAILED(hr) )
            {
                ReleaseInterface(pComposite);
				ReleaseInterface(pIdentity);
				DPF_ERR("Failed to process intermediate");
				return hr;
            }

			hr = pfragNext->m_pModifiableIntermediate->SwitchTo(pInitWith);
            ReleaseInterface( pInitWith );
			if (FAILED(hr))
			{
				ReleaseInterface(pComposite);
				ReleaseInterface(pIdentity);
				DPF_ERR("Failed to initialize intermediate");
				return hr;
			}
		}

		pfragCurrent = pfragNext;

    }

	ReleaseInterface(pIdentity);

    *ppdabvrComposite = pComposite;

    return S_OK;
} // ComposeRelBvrFragList

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::ProcessBvr(IDABehavior *pOriginal,
								 ActorBvrFlags eFlags,
								 IDABehavior **ppResult)
{
	// Default implementation does no processing
	DASSERT(ppResult != NULL);

	*ppResult = pOriginal;
	pOriginal->AddRef();

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::ProcessIntermediate( IDABehavior *pOriginal,
                                           ActorBvrFlags eFlags,
								           IDABehavior **ppResult )
{
    if( ppResult == NULL )
        return E_INVALIDARG;

    *ppResult = pOriginal;
    pOriginal->AddRef();

    return S_OK;
}

//*****************************************************************************


HRESULT
CActorBvr::CBvrTrack::GetTrackOn(IDABoolean **ppdaboolTrackOn)
{
	if( ppdaboolTrackOn == NULL )
		return E_INVALIDARG;

	if( m_pdaboolOn != NULL )
	{
		m_pdaboolOn->AddRef();
		(*ppdaboolTrackOn) = m_pdaboolOn;
		return S_OK;
	}

	HRESULT hr = E_FAIL;

	IDABoolean *pdaboolComposite = NULL;

    CBvrFragment* pfragCurrent = m_pfragAbsListHead;

	if( pfragCurrent != NULL )
	{
		pdaboolComposite = pfragCurrent->m_pdaboolActive;
		pfragCurrent->m_pdaboolActive->AddRef();
		pfragCurrent = pfragCurrent->m_pfragNext;
	}

	CBvrFragment *pfragNext = NULL;
    while( pfragCurrent != NULL )
    {
		pfragNext = pfragCurrent->m_pfragNext;
        
		IDABoolean *pdaboolTemp;
        hr = Actor()->GetDAStatics()->Or( pfragCurrent->m_pdaboolActive, pdaboolComposite, &pdaboolTemp );
        ReleaseInterface(pdaboolComposite);

        if (FAILED(hr))
        {
            DPF_ERR("Failed to or active booleans");
            return hr;
        }
        // Replace the current composite behavior with the newely computed
        // one.
        pdaboolComposite = pdaboolTemp;

		pfragCurrent = pfragNext;
    }

	pfragCurrent = m_pfragRelListHead;

	if( pdaboolComposite == NULL && pfragCurrent != NULL )
	{
		pdaboolComposite = pfragCurrent->m_pdaboolActive;
		pdaboolComposite->AddRef();
		pfragCurrent = pfragCurrent->m_pfragNext;
	}

    while( pfragCurrent != NULL )
    {
		pfragNext = pfragCurrent->m_pfragNext;
		
		IDABoolean *pdaboolTemp;
        hr = Actor()->GetDAStatics()->Or( pfragCurrent->m_pdaboolActive, pdaboolComposite, &pdaboolTemp );
        ReleaseInterface(pdaboolComposite);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to or active booleans");
            return hr;
        }
        // Replace the current composite behavior with the newely computed
        // one.
        pdaboolComposite = pdaboolTemp;

		pfragCurrent = pfragNext;
    }

	m_pdaboolOn = pdaboolComposite;
	if( m_pdaboolOn != NULL )
		m_pdaboolOn->AddRef();
    *ppdaboolTrackOn = pdaboolComposite;

    return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::OrWithOnBvr( IDABoolean *pdaboolToOr )
{
	if( pdaboolToOr == NULL )
		return S_OK;

	HRESULT hr = E_FAIL;
	
	IDABoolean *pdaboolCurrentOn;

	hr = GetTrackOn( &pdaboolCurrentOn );
	CheckHR( hr, "Failed to get the Track on", cleanup );

	if( pdaboolCurrentOn == NULL )
	{
		m_pdaboolOn = pdaboolToOr;
		m_pdaboolOn->AddRef();
		return S_OK;
	}

	IDABoolean *pdaboolNewOn;
	hr = Actor()->GetDAStatics()->Or( pdaboolCurrentOn, pdaboolToOr, &pdaboolNewOn );
	ReleaseInterface( pdaboolCurrentOn );
	CheckHR( hr, "Failed to or the passed booleanbvr with the current one", cleanup );

	ReleaseInterface( m_pdaboolOn );
	m_pdaboolOn = pdaboolNewOn;

cleanup:
	return hr;
}

//*****************************************************************************

void
CActorBvr::CBvrTrack::ReleaseAllFragments()
{
	CBvrFragment *pfragCurrent = m_pfragAbsListHead;
	CBvrFragment *pfragNext = NULL;
	
	while( pfragCurrent != NULL )
	{
		pfragNext = pfragCurrent->m_pfragNext;
		delete pfragCurrent;
		pfragCurrent = pfragNext;
	}

	pfragCurrent = m_pfragRelListHead;

	while( pfragCurrent != NULL )
	{
		pfragNext = pfragCurrent->m_pfragNext;
		delete pfragCurrent;
		pfragCurrent = pfragNext;
	}

	m_pfragAbsListHead = NULL;

	m_pfragRelListHead = NULL;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::ComputeComposedBvr(IDABehavior *pStatic, bool fStaticSetExternally )
{
    // If there is an existing final behavior blow it away.
    ReleaseInterface(m_pdabvrComposed);

	HRESULT hr = S_OK;

	// If there is an uninitialized static, initialize it now
	if (m_pModifiableStatic != NULL && fStaticSetExternally )
	{
		if (pStatic == NULL)
		{
			// Need to set static to the identity
			hr = IdentityBvr(&pStatic);
			if (FAILED(hr))
			{
				DPF_ERR("Failed to compute static");
				return hr;
			}
		}

		hr = m_pModifiableStatic->SwitchTo(pStatic);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to initialize static uninit");
			return hr;
		}
	}

    // Build the composite absolute behaviors, passing in the static value

    IDABehavior* pAbsolute = NULL;
    hr = ComposeAbsBvrFragList(pStatic, &pAbsolute);
    if (FAILED(hr))
    {
        DPF_ERR("Failed to compose the absolute behaviors");
        return hr;
    }


    // Build the composite relative behaviors onto the absolute
    hr = ComposeRelBvrFragList(pAbsolute, &m_pdabvrComposed);
	ReleaseInterface(pAbsolute);
    if (FAILED(hr))
    {
        DPF_ERR("Failed to compose the relative behaviors");
		m_pdabvrFinal = NULL;
        return hr;
    }	

	if (m_pModifiableComposed != NULL)
	{
		hr = m_pModifiableComposed->SwitchTo(m_pdabvrComposed);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to initialize composed uninit");
			return hr;
		}
	}
	
	m_bComposedComputed = true;

    return S_OK;
}

//*****************************************************************************

/**
* Get composed bvr using the given static value
*/
HRESULT
CActorBvr::CBvrTrack::GetComposedBvr(IDABehavior *pStatic, IDABehavior **ppComposite, bool fStaticSetExternally)
{
	DASSERT(ppComposite != NULL);
	*ppComposite = NULL;

    // If we haven't got a composed behavior yet then generate one now.
    if (!m_bComposedComputed || m_bDirty)
    {
		// Compute the composed behavior

        HRESULT hr = ComputeComposedBvr(pStatic, fStaticSetExternally);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to compute composed behavior");
            return hr;
        }
        
    }

	if (m_pdabvrComposed != NULL)
		m_pdabvrComposed->AddRef();
    *ppComposite = m_pdabvrComposed;

    return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::GetComposedBvr(IDABehavior *pStatic, IDABehavior **ppComposite)
{
	return GetComposedBvr( pStatic, ppComposite, true );
}

//*****************************************************************************


/**
* Get composed bvr without being given a static value (get it from the property)
*/
HRESULT
CActorBvr::CBvrTrack::GetComposedBvr(IDABehavior **ppComposite)
{
	HRESULT hr;

	if (!m_bComposedComputed || m_bDirty )
	{
		// Need to get the static value
		IDABehavior *pStatic = NULL;
		hr = StaticBvr(&pStatic);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to get static value");
			return hr;
		}

		hr = GetComposedBvr(pStatic, ppComposite, false);
		ReleaseInterface(pStatic);
		return hr;
	}

	*ppComposite = m_pdabvrComposed;
	if (m_pdabvrComposed != NULL)
		m_pdabvrComposed->AddRef();
	return S_OK;
}

//*****************************************************************************


HRESULT
CActorBvr::CBvrTrack::UpdateStaticBvr()
{
	//get the current value of the static by getting the current value
	//  of the property from the element.

	HRESULT hr = S_OK;
	VARIANT varStatic;
	
	::VariantInit( &varStatic );

	hr = Actor()->GetPropFromAnimatedElement( m_pNameComponents, m_cNumComponents, true, &varStatic );
	CheckHR( hr, "Failed to get the property from the animated element", end );

	if( m_eType == e_Number &&
		m_bstrPropertyName != NULL && 
		( wcsicmp( L"style.top", m_bstrPropertyName ) == 0 || 
		  wcsicmp( L"style.left", m_bstrPropertyName) == 0 ) 
	  )
	{
		if( V_VT( &varStatic ) == VT_R8 && V_R8( &varStatic ) < -8000.0 )
		{
			goto end;
		}
	}
	
	//put the new value for the static into the track.
	hr = PutStatic( &varStatic );
	CheckHR( hr, "Failed to put the static in update Static bvr", end );
	
end:
	::VariantClear( &varStatic );
	return hr;
}

//*****************************************************************************

/**
* Get final bvr using the given static value
*/
HRESULT
CActorBvr::CBvrTrack::GetFinalBvr(IDABehavior *pStatic, IDABehavior **ppFinal, bool fStaticSetExternally )
{
    // If we haven't got a final behavior yet then generate one now.
    if (!m_bFinalComputed || m_bDirty)
    {
		// Get the composed behavior
		IDABehavior *pComposed = NULL;
        HRESULT hr = GetComposedBvr(pStatic, &pComposed, fStaticSetExternally);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to compute composed behavior");
            return hr;
        }
		
		// Set it as the final behavior
		hr = SetFinalBvr(pComposed, false);
		ReleaseInterface(pComposed);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to set final bvr");
			return hr;
		}
    }

    *ppFinal = m_pdabvrFinal;
	if (m_pdabvrFinal != NULL)
		m_pdabvrFinal->AddRef();

    return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::GetFinalBvr( IDABehavior *pStatic, IDABehavior **ppFinal )
{
	return GetFinalBvr( pStatic, ppFinal, true );
}

//*****************************************************************************

/**
* Get final bvr without being given a static value (get it from the property)
*/
HRESULT
CActorBvr::CBvrTrack::GetFinalBvr(IDABehavior **ppFinal)
{
	HRESULT hr = S_OK;

	if (!m_bFinalComputed || m_bDirty )
	{
		// Need to get the static value
		IDABehavior *pStatic = NULL;
		hr = StaticBvr(&pStatic);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to get static value");
			return hr;
		}

		hr = GetFinalBvr(pStatic, ppFinal, false);
		ReleaseInterface(pStatic);
		return hr;
	}

	*ppFinal = m_pdabvrFinal;
	if (m_pdabvrFinal != NULL)
		m_pdabvrFinal->AddRef();
	return S_OK;
}

//*****************************************************************************

/**
* Set final bvr
*/
HRESULT
CActorBvr::CBvrTrack::SetFinalBvr(IDABehavior *pFinal, bool fCalledExternally)
{
	HRESULT	hr = S_OK;
	
	if (m_pdabvrFinal != NULL)
	{
		ReleaseInterface( m_pdabvrFinal);
	}

	m_bFinalComputed = true;
	m_pdabvrFinal = pFinal;
	if (fCalledExternally)
		m_bFinalExternallySet = true;
	
	if (m_pdabvrFinal != NULL)
	{
		m_pdabvrFinal->AddRef();

		if (m_pModifiableFinal != NULL)
		{
			hr = m_pModifiableFinal->SwitchTo(m_pdabvrFinal);
			if (FAILED(hr))
			{
				DPF_ERR("Failed to initialize final uninit");
				return hr;
			}
		}
	}
	
	return hr;
}

//*****************************************************************************

/**
* Return value of the bvr specified (static, intermediate, composed, final).
* Most tracks cannot do this, so
* this base implementation fails.
*/
HRESULT
CActorBvr::CBvrTrack::GetBvr(ActorBvrFlags eFlags, IDABehavior **ppResult)
{
	// TODO (markhal): Currently this only works for relative tracks like image
	// To include absolute tracks we'd probably have to compose them?

	if (ppResult == NULL)
	{
		DPF_ERR("NULL pointer passed as argument");
		return E_POINTER;
	}

    HRESULT hr = S_OK;

	*ppResult = NULL;
    IDABehavior **ppSource = NULL;
		
    //NOTE: The from and intermediate are stored temporarily in the track
    //  and transferred to the fragment when it is added.

	// Return from behavior
	if (eFlags == e_From)
	{
        ppSource = &m_pModifiableFrom;
	}
	//Intermediate behavior
	else if( eFlags == e_Intermediate )
	{
        ppSource = &m_pModifiableIntermediate;
	}
	// static behavior
	else if ((eFlags == e_Static))
    {
        ppSource = &m_pModifiableStatic;
	}
	// Composed behavior
	else if (eFlags == e_Composed)
	{
		ppSource = &m_pModifiableComposed;
	}
	// Final behavior
	else //if (eFlags == e_Final)
	{
		ppSource = &m_pModifiableFinal;
	}

    //now we know what the source is...
    //if the source is non null
    if( (*ppSource) != NULL )
    {
        //return it
        (*ppResult) = (*ppSource);
        (*ppResult)->AddRef();
    }
    else  //the source is null
    {
	    // Create an uninitialized variable
	    hr = ModifiableBvr(ppResult);
        CheckHR( hr, "Failed to create Modifiable behavior", end );

        //store it away in the source
        (*ppSource) = (*ppResult);
        (*ppSource)->AddRef();
    }
end:
	
	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::SetPropertyName(BSTR bstrPropertyName)
{
    DASSERT(NULL != bstrPropertyName);
    DASSERT(NULL == m_bstrPropertyName);

    m_bstrPropertyName = ::SysAllocString(bstrPropertyName);
    if (NULL == m_bstrPropertyName)
    {
        DPF_ERR("Insufficient memory to allocate the property name");
        return E_OUTOFMEMORY;
    }

	// Figure out whether we are animating a property on the element or on the element's style.
	// Break the name out into components

	// First count the number of .'s in it
	int count = 0;
	OLECHAR *c = m_bstrPropertyName;
	while (c != NULL)
	{
		c = wcschr(c, L'.');
		
		if (c != NULL)
		{
			count++;
			c++;
		}
	}

	// There is 1 more string than .'s
	count++;

	// Allocate this many strings
	m_pNameComponents = new BSTR[count];
	if (m_pNameComponents == NULL)
		return E_FAIL;

	m_cNumComponents = count;

	// Copy them in
	OLECHAR *start = m_bstrPropertyName;
	for (int i=0; i<count; i++)
	{
		OLECHAR *end = wcschr(start, L'.');

		if (end == NULL)
		{
			// Copy all the rest
			m_pNameComponents[i] = ::SysAllocString(start);
		}
		else
		{
			// Copy up until just before the .
			m_pNameComponents[i] = ::SysAllocStringLen(start, end-start);
			start = end+1;
		}

		if (m_pNameComponents[i] == NULL)
		{
			// This is bad
			delete m_pNameComponents;
			m_pNameComponents = NULL;
			m_cNumComponents = 0;
			return E_FAIL;
		}
	}

	// Detect special case of animating style
	if (count == 2 && wcscmp(L"style", m_pNameComponents[0]) == 0)
	{
		// Property name begins with style.
		m_bStyleProp = true;
	}

    return S_OK;
} // SetPropertyName

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::AddBvrFragment(ActorBvrFlags  eFlags,
                                     IDABehavior   *pdabvrAction,
                                     IDABoolean    *pdaboolActive,
									 IDANumber	   *pdanumTimeline,
									 IDispatch     *pdispBehaviorElement,
									 long		   *pCookie)
{
    DASSERT(NULL != pdabvrAction);
    DASSERT(NULL != pdaboolActive);
	DASSERT(pCookie != NULL );

	long fragCookie = Actor()->GetNextFragmentCookie();
    // Create the new fragment.
    CBvrFragment *pfragNew = new CBvrFragment(eFlags, pdabvrAction, pdaboolActive, pdanumTimeline, pdispBehaviorElement, fragCookie);
    if (NULL == pfragNew)
    {
        DPF_ERR("Insufficient memory to allocate the new fragment");
        return E_OUTOFMEMORY;
    }

	(*pCookie) = fragCookie;

	// Transfer over any modifiable from
	if (m_pModifiableFrom != NULL)
	{
		pfragNew->m_pModifiableFrom = m_pModifiableFrom;
		m_pModifiableFrom = NULL;
	}

	//Transfer over any modifiable intermediate
	if( m_pModifiableIntermediate != NULL )
	{
		pfragNew->m_pModifiableIntermediate = m_pModifiableIntermediate;
		m_pModifiableIntermediate = NULL;
	}

	if (eFlags == e_Filter)
		m_cFilters++;

    // Which list to add the fragment to?
	// TODO (markhal): This is icky, but I cannot OR enums?
	// TODO (markhal): Call this something more generic like e_AbsRelative?
    if ( IsRelativeFragment( eFlags ) )
    {
		//insert the fragment into the relative list in order
		InsertInOrder( &m_pfragRelListHead, pfragNew );
    }
    else
    {
		//insert the fragment into the absolute list in order
		InsertInOrder( &m_pfragAbsListHead, pfragNew );
    }

    m_bWasAnimated = false;

	m_bDirty = true;

    return S_OK;
} // AddBvrFragment

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::RemoveBvrFragment( ActorBvrFlags eFlags, long cookie )
{
	CBvrFragment *pfragToRemove = NULL;
	CBvrFragment *pfragPrev = NULL;
	//find the behavior in the given track that has a matching cookie
	if( IsRelativeFragment( eFlags ) )
	{
		if( FindFragmentInList( m_pfragRelListHead, cookie, &pfragPrev, &pfragToRemove ) )
		{
			if( pfragToRemove->m_eFlags == e_Filter )
				m_cFilters--;
			//if this is not the first element in the list
			if( pfragPrev != NULL )
			{
				//remove the element
				pfragPrev->m_pfragNext = pfragToRemove->m_pfragNext;
			}
			else//it's the first element
			{
				//update the head of the list
				m_pfragRelListHead = pfragToRemove->m_pfragNext;
			}

			//mark the track as needing a rebuild
			m_bDirty = true;

			delete pfragToRemove;
		}
		else
		{
			return E_FAIL;
		}
	}
	else //it's an absoute fragment
	{
		if( FindFragmentInList( m_pfragAbsListHead, cookie, &pfragPrev, &pfragToRemove ) )
		{
			if( pfragToRemove->m_eFlags == e_Filter )
				m_cFilters--;

			if( pfragPrev != NULL )
			{
				//remove the element
				pfragPrev->m_pfragNext = pfragToRemove->m_pfragNext;
			}
			else // it's the first element
			{
				//update the head of the list
				m_pfragAbsListHead = pfragToRemove->m_pfragNext;
			}
			
			//mark the track as needing a rebuild.
			m_bDirty = true;

			delete pfragToRemove;
		}
		else//cookie not found
		{
			return E_FAIL;
		}
	}

	m_bWasAnimated = ( m_pfragAbsListHead == NULL && m_pfragRelListHead == NULL );

	return S_OK;
}//RemoveBvrFragment

//*****************************************************************************

bool
CActorBvr::CBvrTrack::FindFragmentInList( CBvrFragment *pfragListHead, 
										   long cookie, 
										   CBvrFragment** ppfragPrev,
										   CBvrFragment** ppfragFragment)
{
	DASSERT( ppfragFragment != NULL && ppfragPrev != NULL );
	CBvrFragment *pfragCurrent = pfragListHead;
	CBvrFragment *pfragPrev = NULL;
	bool bFound = false;

	//loop through the fragment list
	while( pfragCurrent != NULL )
	{
		//if we found a match stop looping
		if( pfragCurrent->GetCookie() == cookie )
		{
			bFound = true;
			break;
		}
		pfragPrev = pfragCurrent;
		pfragCurrent = pfragCurrent->m_pfragNext;
	}

	(*ppfragPrev) = pfragPrev;
	(*ppfragFragment) = pfragCurrent;
	return bFound;
}

//*****************************************************************************

bool
CActorBvr::CBvrTrack::IsRelativeFragment( ActorBvrFlags eFlags )
{
	return (eFlags == e_Relative ||
			eFlags == e_Filter ||
			eFlags == e_ScaledImage ||
			eFlags == e_UnscaledImage);
}//IsRelativeFragment

//*****************************************************************************

void
CActorBvr::CBvrTrack::InsertInOrder( CBvrFragment** ppListHead, CBvrFragment* pfragToInsert )
{
	CBvrFragment* pfragCurrent = (*ppListHead);

	//if the list is empty then insert at the top
	if( pfragCurrent == NULL )
	{
		//first element
		(*ppListHead) = pfragToInsert;
		pfragToInsert->m_pfragNext = NULL;
		return;
	}

	CBvrFragment* pfragPrev = NULL;
	while( pfragCurrent != NULL && 
		   pfragCurrent->GetOrderLong() < pfragToInsert->GetOrderLong() )
	{
		pfragPrev = pfragCurrent;
		pfragCurrent = pfragCurrent->m_pfragNext;
	}
	//pfragPrev will point to the last element whose order long is < the
	//order long of the element that we are inserting, or null if there is no such
	//element in the list.

	if( pfragPrev != NULL )
	{
		//insert after pfragPrev
		pfragToInsert->m_pfragNext = pfragPrev->m_pfragNext;
		pfragPrev->m_pfragNext = pfragToInsert;
		
	}
	else
	{
		//insert at the top of the list.
		pfragToInsert->m_pfragNext = (*ppListHead);
		(*ppListHead) = pfragToInsert;
	}
}

//*****************************************************************************

/**
* This method works for the types e_Number, e_Color, and e_String.  Other
* bvr types need to override and do whatever they want (like nothing)
*/
// TODO (markhal): Change the name of this?
HRESULT
CActorBvr::CBvrTrack::ApplyIfUnmarked(void)
{
	HRESULT hr = S_OK;

	if (m_eType != e_Number &&
		m_eType != e_Color &&
		m_eType != e_String)
	{
		// This is not a failure, just a do-nothing
		return S_OK;
	}

	//do not apply this track again if it is already applied
	if( m_fApplied )
		return S_OK;

	if (m_bDoNotApply)
		return S_OK;

    DASSERT(NULL != m_bstrPropertyName);

	// We compute the behaviors if
	// 1) There is a final behavior already set OR
	// 2) There are fragments present OR
	// 3) Someone asked for the final or composed behaviors
	// This avoids applying tracks like width and height that were created simply
	// to get composed DA versions of their static values
	if (!m_bFinalComputed &&
		m_pfragAbsListHead == NULL&&
		m_pfragRelListHead ==NULL &&
		m_pModifiableFinal == NULL &&
		m_pModifiableComposed == NULL)
	{
		//if this track was animated, and just lost all of its animated components
		// then we need to reset the value in the document.
		if( m_bWasAnimated )
		{
			ApplyStatic();
			m_bWasAnimated = false;
		}
		
		m_varboolOn = VARIANT_FALSE;

		return S_OK;
	}

	// Get the final behavior, passing no static.  The static value will be pulled off
	// the property.
    IDABehavior *pdabvrFinal = NULL;
    hr = GetFinalBvr(&pdabvrFinal);
    if (FAILED(hr))
    {
        DPF_ERR("Could not get a final behavior");
        return hr;
    }
    
	// We apply this track if:
	// 1) There is a final behavior already set OR
	// 2) There are fragments present
	// REVIEW: would it be enough to have saved the value of m_bFinalComputed before
	// calling GetFinalBvr(), instead of introducing m_bFinalSetExternally?
	if (!m_bFinalExternallySet && 
		m_pfragAbsListHead == NULL && 
		m_pfragRelListHead == NULL )
		return hr;
	
	if (pdabvrFinal != NULL)
	{
		DASSERT(NULL != Actor());
		hr = ApplyBvrToElement(pdabvrFinal);
		ReleaseInterface(pdabvrFinal);
		if (FAILED(hr))
		{
			DPF_ERR("Could not apply behavior to animated element");
			return hr;
		}
	}

	m_fApplied = true;

	//if this track is a style track and it is no longer animated
	if( !IsAnimated() )
	{
		ApplyStatic();
		m_varboolOn = VARIANT_FALSE;
	}

	#ifdef _DEBUG
	if( m_bstrPropertyName != NULL )
		LMTRACE2(1, 1000, L"Added behaivor %s to da\n", m_bstrPropertyName );
	else
		LMTRACE2(1, 1000, L"Added non property behavior to da\n" );
	#endif

    return S_OK;
} // Apply

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::ApplyBvrToElement(IDABehavior *pBvr)
{
	HRESULT hr = S_OK;

	hr = HookBvr(pBvr);
	if (FAILED(hr))
		return hr;

	//hook the overall on booleanbvr for this track so that we can unset the value
	//  when it goes off.
	if( m_pOnSampler != NULL )
	{
		m_pOnSampler->Invalidate();
		m_pOnSampler = NULL;
	}

	IDABoolean *pdaboolOn = NULL;
	hr = GetTrackOn( &pdaboolOn );
	if( FAILED( hr ) )
		return hr;

	if( pdaboolOn != NULL )
	{
		m_pOnSampler = new CSampler( OnCallback, reinterpret_cast<void*>(this) );

		if( m_pOnSampler == NULL )
		{
			ReleaseInterface( pdaboolOn );
			return E_FAIL;
		}

		IDABehavior *pdabvrHooked;
		hr = m_pOnSampler->Attach( pdaboolOn, &pdabvrHooked );
		ReleaseInterface( pdaboolOn );
		if( FAILED( hr ) )
			return hr;

		hr = AddBehaviorToTIME( pdabvrHooked, &m_lOnCookie, ONBVR_COOKIESET);
		ReleaseInterface( pdabvrHooked );
		if( FAILED( hr ) )
			return hr;
	}

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::UpdateOnValueState( ValueOnChangeType type )
{
	//ensure that this method doesn't get called more than once per tick for each on and value, 
	//respectively
	//ASSERT( m_lastOnSampleTime != globalTimeOfChange && m_lastValueSampleTime != globalTimeOfChange );

	HRESULT hr = S_OK;
	switch( type )
	{
	case on_no_change:
		{
			//if value has already been sampled
			if( m_fValueSampled )
			{
				//clear out the sampled flags
				m_fValueSampled = false;
				//if we are currently on
				if( m_varboolOn != VARIANT_FALSE )
				{
					//if the value changed
					if( m_fValueChangedThisSample )
					{
						// apply the new value to property
						SetPropFromVariant( &m_varCurrentValue);
					}
				}//else the property should already be ""
				// reset the valueChanged state
				m_fValueChangedThisSample = false;
			}
			else
			{
				m_fOnSampled = true;
			}
		}break;
	case on_change:
		{

			//if we are off now
			if( m_varboolOn == VARIANT_FALSE )
			{
				//check the current value of the property on the element
				// to see if it is different from what we origianlly set.
				// if so then we should not set the runtime style to ""
				//set the property to ""
				if( !AttribIsTimeAnimated() )
				{
					if( m_bStyleProp )	
					{
						SetPropFromVariant( const_cast<VARIANT*>(s_emptyString.GetVar()));
					}
					else
					{
						//set the static value back.
						SetPropFromVariant( &m_varStaticValue );
					}
					m_fValueChangedThisSample = false;
				}
				//else // don't set anything
			}
			else//else we are on now
			{
				if( !m_fSkipNextStaticUpdate )
					UpdateStaticBvr();
				else
					m_fSkipNextStaticUpdate = false;
				
				//if we have already sampled the value
				if( m_fValueSampled)
				{
					//set value to prop
					SetPropFromVariant( &m_varCurrentValue);
					m_fValueChangedThisSample = false;
				}
				else//else value has not yet been sampled
				{
					//indicate that we are forcing a value set when value is sampled
					m_fForceValueChange = true;
				}
			}
			if( m_fValueSampled )
				m_fValueSampled = false;
			else
				m_fOnSampled = true;
		}break;
	case value_no_change:
		{
			//if we are being forced to set value to property
			if( m_fForceValueChange )
			{				
				//set value to property
				SetPropFromVariant( &m_varCurrentValue);
				//clear the force flag
				m_fForceValueChange = false;
			}
			if( m_fOnSampled )
				m_fOnSampled = false;
			else
				m_fValueSampled = true;
		}break;
	case value_change:
		{
			//if on has been sampled
			if( m_fOnSampled )
			{
				//reset state, we're done.
				m_fOnSampled = false;

				//if we are on
				if( m_varboolOn != VARIANT_FALSE )
				{
					//commit value to property
					SetPropFromVariant( &m_varCurrentValue );
				}
				m_fForceValueChange = false;
			}
			else//else on has not been sampled yet
			{
				m_fValueSampled = true;
				//indicate that the value has changed and needs to be set.
				m_fValueChangedThisSample = true;
			}
		}break;
	}

	return hr;
}//UpdateOnValueState

//*****************************************************************************

bool
CActorBvr::CBvrTrack::AttribIsTimeAnimated()
{
	if( !m_bStyleProp )
		return false;

	//this attribute could be animated by time if is is display or visibility.
	if( ( wcsicmp( L"visibility", m_pNameComponents[1]) == 0 ) ||
	  	( wcsicmp( L"display", m_pNameComponents[1] ) == 0 ) )
	{
		HRESULT hr = S_OK;
		//get the t:timeAction property off of the animated element
		CComVariant varTimeAction;
		CComPtr<IHTMLElement> pelemAnimated;

		hr = Actor()->GetAnimatedElement( &pelemAnimated );
		if( FAILED( hr ) || pelemAnimated == NULL )
			return false;

		hr = pelemAnimated->getAttribute( L"timeAction", 0, &varTimeAction );
		if( FAILED( hr ) )
			return false;

		hr = varTimeAction.ChangeType( VT_BSTR );
		if( FAILED( hr ) )
			return false;
		// if t:timeaction == m_pNameComponents[1] 
		return ( wcsicmp( m_pNameComponents[1], V_BSTR( &varTimeAction ) ) == 0 );
			//time and this track are animating the same attribute
	}
	else
		return false;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::OnCallback(void* thisPtr, 
								 long id, 
								 double startTime, 
								 double globalNow, 
								 double localNow, 
								 IDABehavior* sampleVal, 
								 IDABehavior **ppReturn)
{
	CBvrTrack *pTrack = reinterpret_cast<CBvrTrack*>(thisPtr);

	if( pTrack == NULL || sampleVal == NULL )
		return E_INVALIDARG;

	HRESULT hr;
	VARIANT_BOOL varboolOn = VARIANT_FALSE;
	IDABoolean *pdaboolOn = NULL;


	if( pTrack->m_lOnId == -1 )
		pTrack->m_lOnId = id;

	//bail if this is an instance we don't care about.
	if( pTrack->m_lOnId != id )
		goto cleanup;
		
	hr = sampleVal->QueryInterface( IID_TO_PPV( IDABoolean, &pdaboolOn ) );
	CheckHR( hr, "Failed to get IDABoolean from the sampled behavior", cleanup );

	hr = pdaboolOn->Extract( &varboolOn );
	ReleaseInterface( pdaboolOn );
	CheckHR( hr, "Failed to extract the boolean val from the sampled value", cleanup );

	hr = pTrack->OnSampled( varboolOn );

cleanup:
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::OnSampled( VARIANT_BOOL varboolOn )
{
    if( varboolOn != m_varboolOn )
	{
		m_varboolOn = varboolOn;
		UpdateOnValueState( on_change );
    }
	else
	{
		UpdateOnValueState( on_no_change );
	}

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::SetPropFromVariant(VARIANT *pVal )
{
	if( m_fChangesLockedOut )
		return S_OK;
		
	HRESULT hr = S_OK;
    
	if (m_bStyleProp)
	{

#if 0		
		#ifdef _DEBUG
		if( V_VT( pVal ) == VT_BSTR )
			LMTRACE2( 1, 2, L"track %s setting value %s\n", m_bstrPropertyName, V_BSTR( pVal ) );
		else if( V_VT( pVal ) == VT_R8 )
			LMTRACE2( 1, 2, L"track %s setting value %f\n", m_bstrPropertyName, V_R8( pVal ) );

		if( Actor()->IsAnimatingVML() )
		{
			LMTRACE2( 1, 1000, L"This is a vml shape\n" );
		}
		#endif
#endif
		
		if (Actor()->IsAnimatingVML())
		{
			// If VML, then attempt to set it using special accessor method.
			// If this fails, fall back to runtimeStyle
			hr = Actor()->SetVMLAttribute(m_pNameComponents[1], pVal);

			if (SUCCEEDED(hr))
				return S_OK;
		}

		// Animate property on runtimeStyle
		IHTMLStyle *pStyle = NULL;
		hr = Actor()->GetRuntimeStyle(&pStyle);
		//hr = Actor()->GetStyle(&pStyle);
		if (FAILED(hr))
			return S_OK;
		
		hr = pStyle->setAttribute(m_pNameComponents[1], *pVal, 0);
		ReleaseInterface(pStyle);
	
		// NOTE: We don't really care what happened here.  There might have
		// been an error returned, but we don't want to break if people set bogus values
		return S_OK;
	}
	else if (m_cNumComponents == 1)
	{
		// Must be a property on the element itself
		IHTMLElement *pElement = NULL;
		hr = Actor()->GetAnimatedElement(&pElement);
		if (FAILED(hr))
			return hr;

		hr = pElement->setAttribute(m_pNameComponents[0], *pVal, 0);
		ReleaseInterface(pElement);

		// NOTE: We don't really care what happened here.  There might have
		// been an error returned, but we don't want to break if people set bogus values
		return S_OK;
	}
	else
	{
		// Multicomponent name
		// Do property gets and a final set to drill down

		// Start with the element itself
		IHTMLElement *pElement = NULL;
		hr = Actor()->GetAnimatedElement(&pElement);
		if (FAILED(hr))
			return hr;

		// Get a dispatch from it
		IDispatch *pDispatch = NULL;
		hr = pElement->QueryInterface(IID_TO_PPV(IDispatch, &pDispatch));
		ReleaseInterface(pElement);
		if (FAILED(hr))
			return hr;

		// Now loop over the stored property names, except the last one, doing getDispatch
		// Note that we don't care if we fail
		for (int i=0; i<m_cNumComponents-1; i++)
		{
			IDispatch *pPropDispatch = NULL;
			hr = Actor()->GetPropertyAsDispatch(pDispatch, m_pNameComponents[i], &pPropDispatch);
			ReleaseInterface(pDispatch);
			if (FAILED(hr))
				return S_OK;
	
			pDispatch = pPropDispatch;
		}

		// Now set the final one
		hr = Actor()->SetPropertyOnDispatch(pDispatch, m_pNameComponents[m_cNumComponents-1], pVal);
		ReleaseInterface(pDispatch);
		
		return S_OK;
	}
}


//*****************************************************************************

/**
 * Call this to add a behaivor to the time behavior.  plCookie should be set to the old value
 * of the cookie for the behaivor to be added in the case that that behavior's cookie flag
 * has not yet been removed from the set of added behavior flags( it has not been removed
 * from time yet).
*/
HRESULT
CActorBvr::CBvrTrack::AddBehaviorToTIME( IDABehavior* pdabvrToAdd, long* plCookie, DWORD flag )
{
	if( pdabvrToAdd == NULL || plCookie == NULL || flag == 0 )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	//if the cookie is already set
	if( ( m_dwAddedBehaviorFlags & flag ) != 0 )
	{
		//we have to remove it.
		hr = RemoveBehaviorFromTIME( (*plCookie), flag );
		CheckHR( hr, "Failed to remove a previously set behavior from TIME", end );
	}
	
	hr = Actor()->AddBehaviorToTIME( pdabvrToAdd, plCookie );
	CheckHR( hr, "Failed to add a behaivor to time from the track", end );

	
	m_dwAddedBehaviorFlags |= flag;
	
  end:
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CBvrTrack::RemoveBehaviorFromTIME( long lCookie, DWORD flag )
{
	if( flag == 0 )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = S_OK;

	//if the cookie is not set there is nothing to do
	if( ( m_dwAddedBehaviorFlags & flag ) == 0 )
		return S_OK;

	//otherwise remove the behavior
	Actor()->RemoveBehaviorFromTIME( lCookie );
	CheckHR( hr, "Failed to remove a behavior from time", end);
	
	ClearBit( m_dwAddedBehaviorFlags, flag );

  end:
	return hr;
}

//*****************************************************************************
//
// class CTransformBvrTrack
//
//*****************************************************************************

//*****************************************************************************

CActorBvr::CTransformBvrTrack::CTransformBvrTrack(CActorBvr *pbvrActor, ActorBvrType eType)
:   CBvrTrack(pbvrActor, eType),
	m_pSampler(NULL),
	m_lTransformId(-1)
{
}

CActorBvr::CTransformBvrTrack::~CTransformBvrTrack()
{
	if (m_pSampler != NULL)
	{
		m_pSampler->Invalidate();
		m_pSampler = NULL;
	}
}

HRESULT
CActorBvr::CTransformBvrTrack::IdentityBvr(IDABehavior **ppdabvrIdentity)
{
    DASSERT(NULL != ppdabvrIdenity);
    *ppdabvrIdentity = NULL;

    IDATransform2 *pdabvrTemp = NULL;
    HRESULT hr = Actor()->GetDAStatics()->get_IdentityTransform2(&pdabvrTemp);
    if (FAILED(hr))
    {
        DPF_ERR("Failed to create the transform bvr's identity behavior");
        return hr;
    }

    *ppdabvrIdentity = pdabvrTemp;

    return S_OK;
} // IdentityBvr

//*****************************************************************************

HRESULT
CActorBvr::CTransformBvrTrack::StaticBvr(IDABehavior **ppdabvrStatic)
{
	// The static defaults to the identity.  Usually the get methods will be
	// called with an alternative static
	return IdentityBvr(ppdabvrStatic);
} // StaticBvr

//*****************************************************************************

HRESULT
CActorBvr::CTransformBvrTrack::UninitBvr(IDABehavior **ppUninit)
{
	DASSERT(ppUninit != NULL);

	*ppUninit = NULL;

    HRESULT hr = CoCreateInstance(CLSID_DATransform2, 
								  NULL, 
								  CLSCTX_INPROC_SERVER, 
								  IID_IDABehavior, 
								  (void**)ppUninit);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to cocreate uninit transform2");
		return hr;
	}

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CTransformBvrTrack::ModifiableBvr( IDABehavior **ppModifiable )
{
	ReturnIfArgNull(ppModifiable );

	*ppModifiable = NULL;

	HRESULT hr = S_OK;

	IDATransform2* pIdentity = NULL;

	hr = Actor()->GetDAStatics()->get_IdentityTransform2( &pIdentity );
	CheckHR( hr, "Failed to get identity transform2 from DA", end );
	
	Actor()->GetDAStatics()->ModifiableBehavior( pIdentity, ppModifiable );
	CheckHR( hr, "Failed to create a modifiable behavior for a transform track", end );

end:
	ReleaseInterface( pIdentity );

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CTransformBvrTrack::InverseBvr(IDABehavior *pOriginal, IDABehavior **ppInverse)
{
	HRESULT hr = S_OK;

	DASSERT(pBehavior != NULL);
	DASSERT(ppInverse != NULL);

	*ppInverse = NULL;

	IDATransform2 *pOrigTrans = NULL;
	hr = pOriginal->QueryInterface(IID_TO_PPV(IDATransform2, &pOrigTrans));
	if (FAILED(hr))
		return hr;

	IDATransform2 *pInverse = NULL;
	hr = pOrigTrans->Inverse(&pInverse);
	ReleaseInterface(pOrigTrans);
	if (FAILED(hr))
		return hr;

	*ppInverse = pInverse;

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CTransformBvrTrack::Compose(IDABehavior*  pdabvr1,
                                       IDABehavior*  pdabvr2,
                                       IDABehavior** ppdabvrResult)
{
    DASSERT(NULL != pdabvr1);
    DASSERT(NULL != pdabvr2);
    DASSERT(NULL != ppdabvrResult);
    *ppdabvrResult = NULL;

    IDATransform2 *pdabvrTrans1 = NULL;
    HRESULT hr = pdabvr1->QueryInterface( IID_TO_PPV(IDATransform2, &pdabvrTrans1) );
    if (FAILED(hr))
    {
        DPF_ERR("Failed to QI for IDATransform2 from input behavior 1");
        return hr;
    }
    IDATransform2 *pdabvrTrans2 = NULL;
    hr = pdabvr2->QueryInterface( IID_TO_PPV(IDATransform2, &pdabvrTrans2) );
    if (FAILED(hr))
    {
        DPF_ERR("Failed to QI for IDATransform2 from input behavior 2");
        ReleaseInterface(pdabvrTrans1);
        return hr;
    }

	IDATransform2 *pResult = NULL;
    hr = Actor()->GetDAStatics()->Compose2(pdabvrTrans1,
                                           pdabvrTrans2,
                                           &pResult);
    ReleaseInterface(pdabvrTrans1);
    ReleaseInterface(pdabvrTrans2);
    if (FAILED(hr))
    {
        DPF_ERR("Failed to compose two transform behaviors");
        return hr;
    }

	*ppdabvrResult = pResult;

    return S_OK;
} // Compose

//*****************************************************************************

HRESULT
CActorBvr::CTransformBvrTrack::SwitchAccum(IDABehavior *pModifiable)
{
	HRESULT hr = S_OK;

	if (pModifiable == NULL)
		return E_FAIL;

	if (m_lTransformId != -1)
	{
		IDATransform2 *pTransform = NULL;
		if (m_eType == e_Scale)
		{
			hr = Actor()->GetDAStatics()->Scale2(m_lastX, m_lastY, &pTransform);
			if (FAILED(hr))
				return hr;
		}
		else
		{
			hr = Actor()->GetDAStatics()->Translate2(m_lastX, m_lastY, &pTransform);
			if (FAILED(hr))
				return hr;
		}

		hr = pModifiable->SwitchTo(pTransform);
		ReleaseInterface(pTransform);
	}

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CTransformBvrTrack::HookAccumBvr(IDABehavior *pBvr, IDABehavior **ppResult)
{
	HRESULT hr = S_OK;

	if (m_pSampler != NULL)
	{
		m_pSampler->Invalidate();
		m_pSampler = NULL;
	}
	// We need to hook this behavior
	m_pSampler = new CSampler(TransformCallback, (void*)this);

	if (m_pSampler == NULL)
		return E_FAIL;

	// Originally I tried just hooking the transform, but this did not let
	// me use the sampled value for anything useful.  Instead I'll transform a point
	// and sample the transformed x and y.  Uggh.
	IDAPoint2 *pPoint = NULL;
	if (m_eType == e_Scale)
	{
		// Need to transform 1,1
		hr = Actor()->GetDAStatics()->Point2(1, 1, &pPoint);
		if (FAILED(hr))
			return hr;
	}
	else
	{
		// Need to transform 0, 0
		hr = Actor()->GetDAStatics()->get_Origin2(&pPoint);
		if (FAILED(hr))
			return hr;
	}

	IDATransform2 *pTransform = NULL;
	hr = pBvr->QueryInterface(IID_TO_PPV(IDATransform2, &pTransform));
	if (FAILED(hr))
	{
		ReleaseInterface(pPoint);
		return hr;
	}

	IDAPoint2 *pTransPoint = NULL;
	hr = pPoint->Transform(pTransform, &pTransPoint);
	ReleaseInterface(pTransform);
	ReleaseInterface(pPoint);
	if (FAILED(hr))
		return hr;

	IDABehavior *pHooked = NULL;
	hr = m_pSampler->Attach(pTransPoint, &pHooked);
	ReleaseInterface(pTransPoint);
	if (FAILED(hr))
		return hr;

	hr = pHooked->QueryInterface(IID_TO_PPV(IDAPoint2, &pTransPoint));
	ReleaseInterface(pHooked);
	if (FAILED(hr))
		return hr;

	IDANumber *pX = NULL;
	hr = pTransPoint->get_X(&pX);
	if (FAILED(hr))
	{
		ReleaseInterface(pTransPoint);
		return hr;
	}

	IDANumber *pY = NULL;
	hr = pTransPoint->get_Y(&pY);
	ReleaseInterface(pTransPoint);
	if (FAILED(hr))
		return hr;

	if (m_eType == e_Scale)
		hr = Actor()->GetDAStatics()->Scale2Anim(pX, pY, &pTransform);
	else
		hr = Actor()->GetDAStatics()->Translate2Anim(pX, pY, &pTransform);
	ReleaseInterface(pX);
	ReleaseInterface(pY);
	if (FAILED(hr))
		return hr;

	*ppResult = pTransform;

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CTransformBvrTrack::TransformCallback(void *thisPtr,
										   long id,
										   double startTime,
										   double globalNow,
										   double localNow,
										   IDABehavior *sampleVal,
										   IDABehavior **ppReturn)
{
	HRESULT hr = S_OK;

	CTransformBvrTrack *pTrack = (CTransformBvrTrack*)thisPtr;

	if (pTrack == NULL)
		return E_FAIL;

	if( pTrack->m_lTransformId == -1 )
		pTrack->m_lTransformId = id;

	if( pTrack->m_lTransformId != id )
		return S_OK;
		
	// Get the point and get x and y
	IDAPoint2 *pPoint = NULL;
	hr = sampleVal->QueryInterface(IID_TO_PPV(IDAPoint2, &pPoint));
	if (FAILED(hr))
		return hr;

	IDANumber *pNum = NULL;
	hr = pPoint->get_X(&pNum);
	if (FAILED(hr))
	{
		ReleaseInterface(pPoint);
		return hr;
	}

	hr = pNum->Extract(&(pTrack->m_lastX));
	ReleaseInterface(pNum);
	if (FAILED(hr))
	{
		ReleaseInterface(pPoint);
		return hr;
	}

	hr = pPoint->get_Y(&pNum);
	ReleaseInterface(pPoint);
	if (FAILED(hr))
		return hr;

	hr = pNum->Extract(&(pTrack->m_lastY));
	ReleaseInterface(pNum);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CTransformBvrTrack::CreateInstance(CActorBvr             *pbvrActor,
                                              BSTR                   bstrPropertyName,
                                              ActorBvrType           eType,
                                              CActorBvr::CBvrTrack **pptrackResult)
{
    DASSERT(NULL != pbvrActor);
    DASSERT(NULL != bstrPropertyName);
    DASSERT(NULL != pptrackResult);
    *pptrackResult = NULL;

    // Create the new bvr track
    CBvrTrack* ptrack = new CTransformBvrTrack(pbvrActor, eType);
    if (NULL == ptrack)
    {
        DPF_ERR("Insufficient memory to allocate a new transform bvr track");
        return E_OUTOFMEMORY;
    }

    // Set the property name
    HRESULT hr = ptrack->SetPropertyName(bstrPropertyName);
    if (FAILED(hr))
    {
        DPF_ERR("Could not set the bvr track's property name");
        delete ptrack;
        return hr;
    }

    *pptrackResult = ptrack;
    return hr;
} // CreateInstance

//*****************************************************************************
//
// class CNumberBvrTrack
//
//*****************************************************************************

CActorBvr::CNumberBvrTrack::CNumberBvrTrack(CActorBvr *pbvrActor, ActorBvrType eType)
:   CBvrTrack(pbvrActor, eType),
	m_pSampler(NULL),
	m_currVal(0),
	m_pAccumSampler(NULL),
	m_currAccumVal(0),
	m_lAccumId(-1),
	m_bstrUnits(NULL),
	m_lNumberCookie( 0 ),
	m_lNumberId( -1 )
{
} // CNumberBvrTrack

//*****************************************************************************

CActorBvr::CNumberBvrTrack::~CNumberBvrTrack()
{
	if (m_pSampler != NULL)
	{
		m_pSampler->Invalidate();
		m_pSampler = NULL;
	}

	if (m_pAccumSampler != NULL)
	{
		m_pAccumSampler->Invalidate();
		m_pAccumSampler = NULL;
	}

	if (m_bstrUnits != NULL)
		::SysFreeString(m_bstrUnits);

}

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::IdentityBvr(IDABehavior **ppdabvrIdentity)
{
    DASSERT(NULL != ppdabvrIdentity);
    *ppdabvrIdentity = NULL;

    IDANumber *pdanumTemp = NULL;
    HRESULT hr = Actor()->GetDAStatics()->DANumber(0.0, &pdanumTemp);
    if (FAILED(hr))
    {
        DPF_ERR("Failed to create the number bvr's identity behavior");
        return hr;
    }

    *ppdabvrIdentity = pdanumTemp;
    return S_OK;
} // IdentityBvr

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::StaticBvr(IDABehavior **ppdabvrStatic)
{
    DASSERT(NULL != ppdabvrStatic);
    HRESULT hr = S_OK;
    *ppdabvrStatic = NULL;

	if( m_pModifiableStatic == NULL )
	{
		hr = UpdateStaticBvr();
	}

	if( SUCCEEDED( hr ) )
	{
		(*ppdabvrStatic) = m_pModifiableStatic;
		(*ppdabvrStatic)->AddRef();
	}
    else
    {
        // Need to return something
		return IdentityBvr(ppdabvrStatic);
    }

    return S_OK;
} // StaticBvr

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::UninitBvr(IDABehavior **ppUninit)
{
	DASSERT(ppUninit != NULL);

	*ppUninit = NULL;

    HRESULT hr = CoCreateInstance(CLSID_DANumber, 
								  NULL, 
								  CLSCTX_INPROC_SERVER, 
								  IID_IDABehavior, 
								  (void**)ppUninit);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to cocreate uninit number");
		return hr;
	}

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::ModifiableBvr( IDABehavior **ppModifiable )
{
	ReturnIfArgNull( ppModifiable );

	HRESULT hr = S_OK;

	(*ppModifiable) = NULL;

	IDANumber *pNum = NULL;

	hr = Actor()->GetDAStatics()->ModifiableNumber( 0.0, &pNum );
	CheckHR( hr, "Failed to create a modifiable number", end );

	hr = pNum->QueryInterface( IID_TO_PPV( IDABehavior, ppModifiable) );
	CheckHR( hr, "Failed to QI number returned from modifiable number for IDABehavior", end);

end:
	ReleaseInterface( pNum );

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::ModifiableBvr( IDABehavior *pdabvrInitialValue, IDABehavior **ppModifiable )
{
	if( pdabvrInitialValue == NULL || ppModifiable == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	(*ppModifiable) = NULL;

	hr = Actor()->GetDAStatics()->ModifiableBehavior( pdabvrInitialValue, ppModifiable );
	CheckHR( hr, "Failed to create a modifiable behavior for the number track", end );
	

end:
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::InverseBvr(IDABehavior *pOriginal, IDABehavior **ppInverse)
{
	HRESULT hr = S_OK;

	DASSERT(pBehavior != NULL);
	DASSERT(ppInverse != NULL);

	*ppInverse = NULL;

	IDANumber *pOrigNum = NULL;
	hr = pOriginal->QueryInterface(IID_TO_PPV(IDANumber, &pOrigNum));
	if (FAILED(hr))
		return hr;

	IDANumber *pInverse = NULL;
	hr = Actor()->GetDAStatics()->Neg(pOrigNum, &pInverse);
	ReleaseInterface(pOrigNum);
	if (FAILED(hr))
		return hr;

	*ppInverse = pInverse;

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::Compose(IDABehavior  *pdabvr1,
                                    IDABehavior  *pdabvr2,
                                    IDABehavior **ppdabvrResult)
{
    // Composition for number behaviors is currently defined as simply addition
    DASSERT(NULL != pdabvr1);
    DASSERT(NULL != pdabvr2);
    DASSERT(NULL != ppdabvrResult);
    *ppdabvrResult = NULL;

    // Get the number behavior interfaces
    IDANumber* pdanum1 = NULL;
    HRESULT hr = pdabvr1->QueryInterface( IID_TO_PPV( IDANumber, &pdanum1) );
    if (FAILED(hr))
    {
        DPF_ERR("Could not QI for IDANumber from bvr1 of number track's compose");
        return hr;
    }
    IDANumber* pdanum2 = NULL;
    hr = pdabvr2->QueryInterface( IID_TO_PPV(IDANumber, &pdanum2) );
    if (FAILED(hr))
    {
        DPF_ERR("Could not QI for IDANumber from bvr2 of number track's compose");
        ReleaseInterface(pdanum1);
        return hr;
    }

    // Now create an addition behavior to add the two numbers up.
    IDANumber *pdanumTemp = NULL;
    hr = Actor()->GetDAStatics()->Add(pdanum1, pdanum2, &pdanumTemp);
    ReleaseInterface(pdanum1);
    ReleaseInterface(pdanum2);
    if (FAILED(hr))
    {
        DPF_ERR("Could not create the Add behavior in number track's compose");
        return hr;
    }

    *ppdabvrResult = pdanumTemp;

    return S_OK;
} // Compose

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::HookBvr(IDABehavior *pBvr)
{
	HRESULT hr = S_OK;

	if (m_pSampler != NULL)
	{
		m_pSampler->Invalidate();
		m_pSampler = NULL;
	}
	
	// We need to hook this behavior
	m_pSampler = new CSampler(NumberCallback, (void*)this);

	if (m_pSampler == NULL)
		return E_FAIL;

	IDABehavior *pHookedBvr = NULL;
	hr = m_pSampler->Attach(pBvr, &pHookedBvr);
	if (FAILED(hr))
		return hr;

	// Add the behavior to the TIME element so it runs and samples
	hr = AddBehaviorToTIME( pHookedBvr, &m_lNumberCookie, NUMBERBVR_COOKIESET );
	ReleaseInterface(pHookedBvr);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::NumberCallback(void *thisPtr,
										   long	id,
										   double startTime,
										   double globalNow,
										   double localNow,
										   IDABehavior *sampleVal,
										   IDABehavior **ppReturn)
{
	HRESULT hr = S_OK;

	CNumberBvrTrack *pTrack = (CNumberBvrTrack*)thisPtr;
	bool firstSample = false;

	if( pTrack->m_lNumberId == -1 )
	{
		firstSample = true;
		pTrack->m_lNumberId = id;
	}

	//if this is a sample of an instance that we are not watching.
	if( pTrack->m_lNumberId != id )
		return S_OK;

	IDANumber *pNumber = NULL;
	hr = sampleVal->QueryInterface(IID_TO_PPV(IDANumber, &pNumber));
	if (FAILED(hr))
		return hr;

	double value;
	hr = pNumber->Extract(&value);
	ReleaseInterface(pNumber);
	if (FAILED(hr))
		return hr;
		
	if (pTrack == NULL)
		return E_FAIL;

	return pTrack->ValueSampled(value, firstSample);
}

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::ValueSampled(double val, bool firstSample )
{
	HRESULT hr = S_OK;

	if (m_currVal != val || firstSample )
	{			
		m_currVal = val;

		// Value has changed, push it through
		::VariantClear( &m_varCurrentValue );

		if (m_bstrUnits == NULL || wcsicmp(m_bstrUnits, L"px") == 0)
		{
			// No units, set as R8	
			V_VT(&m_varCurrentValue) = VT_R8;
			V_R8(&m_varCurrentValue) = val;
		}
		else
		{
			// Set as BSTR with units appended.  Grrr.
			char buffer[1024];
			if (sprintf(buffer, "%f", val) >= 1)
			{
				CComBSTR stringVal(buffer);
				stringVal += m_bstrUnits;

				V_VT(&m_varCurrentValue) = VT_BSTR;
				V_BSTR(&m_varCurrentValue) = stringVal.Detach();
			}
			else
				return S_OK;
		}

		hr = UpdateOnValueState( value_change );

	}
	else
	{
		hr = UpdateOnValueState( value_no_change );
	}

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::SwitchAccum(IDABehavior *pModifiable)
{
	HRESULT hr = S_OK;

	if (pModifiable == NULL)
		return E_FAIL;

	if (m_lAccumId != -1)
		hr = pModifiable->SwitchToNumber(m_currAccumVal);

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::HookAccumBvr(IDABehavior *pBvr, IDABehavior **ppResult)
{
	HRESULT hr = S_OK;

	if (m_pAccumSampler != NULL)
	{
		m_pAccumSampler->Invalidate();
		m_pAccumSampler = NULL;
	}
	
	// We need to hook this behavior
	m_pAccumSampler = new CSampler(AccumNumberCallback, (void*)this);

	if (m_pAccumSampler == NULL)
		return E_FAIL;

	hr = m_pAccumSampler->Attach(pBvr, ppResult);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::AccumNumberCallback(void *thisPtr,
										   long id,
										   double startTime,
										   double globalNow,
										   double localNow,
										   IDABehavior *sampleVal,
										   IDABehavior **ppReturn)
{
	HRESULT hr = S_OK;

	CNumberBvrTrack *pTrack = (CNumberBvrTrack*)thisPtr;

	if( pTrack->m_lAccumId == -1 )
		pTrack->m_lAccumId = id;

	if( pTrack->m_lAccumId != id )
		return S_OK;


	IDANumber *pNumber = NULL;
	hr = sampleVal->QueryInterface(IID_TO_PPV(IDANumber, &pNumber));
	if (FAILED(hr))
		return hr;

	double value;
	hr = pNumber->Extract(&value);
	ReleaseInterface(pNumber);
	if (FAILED(hr))
		return hr;

	if (pTrack == NULL)
		return E_FAIL;

	pTrack->m_currAccumVal = value;

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::CreateInstance(CActorBvr     *pbvrActor,
                                           BSTR           bstrPropertyName,
                                           ActorBvrType   eType,
                                           CBvrTrack    **pptrackResult)
{
    DASSERT(NULL != pbvrActor);
    DASSERT(NULL != bstrPropertyName);
    DASSERT(NULL != pptrackResult);
    *pptrackResult = NULL;

    // Create the new bvr track
    CBvrTrack* ptrack = new CNumberBvrTrack(pbvrActor, eType);
    if (NULL == ptrack)
    {
        DPF_ERR("Insufficient memory to allocate a new number bvr track");
        return E_OUTOFMEMORY;
    }

    // Set the property name
    HRESULT hr = ptrack->SetPropertyName(bstrPropertyName);
    if (FAILED(hr))
    {
        DPF_ERR("Could not set the bvr track's property name");
        delete ptrack;
        return hr;
    }

    *pptrackResult = ptrack;
    return hr;
} // CreateInstance

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::Detach()
{
	HRESULT hr = S_OK;

	m_lNumberId = -1;
	m_lAccumId = -1;
	hr = RemoveBehaviorFromTIME( m_lNumberCookie, NUMBERBVR_COOKIESET );
	CheckHR( hr, "Failed to remove number behavior from time", end );

	hr = CBvrTrack::Detach();

  end:
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CNumberBvrTrack::DABvrFromVariant( VARIANT *pvarValue, IDABehavior **ppdabvr )
{
	if( pvarValue == NULL || ppdabvr == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;
	VARIANT varValue;
	IDANumber *pdanum = NULL;

	::VariantInit( &varValue );

	//copy the incoming varaint
	hr = ::VariantCopy( &varValue, pvarValue );
	CheckHR( hr, "Failed to copy the variant", end );

	//if the type of the variant is a bstr
	if( V_VT( &varValue ) == VT_BSTR )
	{
		//strip the unit string off of the variant
		BSTR bstrVal = V_BSTR(&varValue);
		OLECHAR* pUnits;

		hr = Actor()->FindCSSUnits( bstrVal, &pUnits );
		if( SUCCEEDED(hr) && pUnits != NULL )
		{
			SysFreeString( m_bstrUnits );
			m_bstrUnits = SysAllocString( pUnits );
			
			(*pUnits) = L'\0';
			BSTR bstrNewVal = SysAllocString(bstrVal);
			V_BSTR(&varValue) = bstrNewVal;
			SysFreeString(bstrVal);
		}
	}

	

	//convert the unitless variant to a double
	hr = ::VariantChangeTypeEx( &varValue, &varValue, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R8 );
	CheckHR( hr, "Failed to change the type of the variant", end );

	//create a danumber from the converted value
	hr = Actor()->GetDAStatics()->DANumber( V_R8(&varValue), &pdanum );
	CheckHR( hr, "Failed to create a danumber for the variant", end );

	if (m_bstrUnits != NULL)
	{
		// See if we need to convert to degrees
		IDANumber *pConverted = NULL;
		hr = Actor()->ConvertToDegrees(pdanum, m_bstrUnits, &pConverted);

		if (SUCCEEDED(hr))
		{
			// This means that we did do a conversion, so grab the converted
			// and toss our units
			ReleaseInterface(pdanum);
			pdanum = pConverted;
			::SysFreeString(m_bstrUnits);
			m_bstrUnits = NULL;
		}
	}
	
	//return a bvr
	hr = pdanum->QueryInterface( IID_TO_PPV( IDABehavior, ppdabvr ) );
	CheckHR( hr, "QI for IDABehavior on IDANumber failed", end );

end:
	::VariantClear( &varValue );
	ReleaseInterface( pdanum );

	return hr;
}


//*****************************************************************************
//
// class CImageBvrTrack
//
//*****************************************************************************

HRESULT
CActorBvr::CImageBvrTrack::IdentityBvr(IDABehavior **ppdabvrIdentity)
{
    DASSERT(NULL != ppdabvrIdentity);
    *ppdabvrIdentity = NULL;

    IDAImage *pImage = NULL;
    HRESULT hr = Actor()->GetDAStatics()->get_EmptyImage(&pImage);
    if (FAILED(hr))
    {
        DPF_ERR("Failed to create the image bvr's identity behavior");
        return hr;
    }

    *ppdabvrIdentity = pImage;
    return S_OK;
} // IdentityBvr

//*****************************************************************************

HRESULT
CActorBvr::CImageBvrTrack::StaticBvr(IDABehavior **ppdabvrStatic)
{
	// This returns the Identity.  Usually an appropriate static will be passed in.

	return IdentityBvr(ppdabvrStatic);
} // StaticBvr

//*****************************************************************************

HRESULT
CActorBvr::CImageBvrTrack::UninitBvr(IDABehavior **ppUninit)
{
	DASSERT(ppUninit != NULL);

	*ppUninit = NULL;

    HRESULT hr = CoCreateInstance(CLSID_DAImage, 
								  NULL, 
								  CLSCTX_INPROC_SERVER, 
								  IID_IDABehavior, 
								  (void**)ppUninit);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to cocreate uninit image");
		return hr;
	}

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CImageBvrTrack::ModifiableBvr( IDABehavior **ppModifiable )
{
	ReturnIfArgNull( ppModifiable );

	HRESULT hr = S_OK;

	(*ppModifiable) = NULL;

	IDAImage *pEmpty = NULL;

	hr = Actor()->GetDAStatics()->get_EmptyImage( &pEmpty );
	CheckHR( hr, "Failed to get the empty image from DA", end );

	hr = Actor()->GetDAStatics()->ModifiableBehavior( pEmpty, ppModifiable );
	CheckHR( hr, "Failed to create a modifiable image from the empty image", end );

end:
	ReleaseInterface( pEmpty );

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CImageBvrTrack::Compose(IDABehavior  *pdabvr1,
                                    IDABehavior  *pdabvr2,
                                    IDABehavior **ppdabvrResult)
{
    // Composition for image behaviors is defined as overlay
    DASSERT(NULL != pdabvr1);
    DASSERT(NULL != pdabvr2);
    DASSERT(NULL != ppdabvrResult);
    *ppdabvrResult = NULL;

    // Get the image behavior interfaces
    IDAImage* pImage1 = NULL;
    HRESULT hr = pdabvr1->QueryInterface(IID_TO_PPV(IDAImage, &pImage1));
    if (FAILED(hr))
    {
        DPF_ERR("Could not QI for IDAImage from bvr1 of image track's compose");

        return hr;
    }
    IDAImage* pImage2 = NULL;
    hr = pdabvr2->QueryInterface(IID_TO_PPV(IDAImage, &pImage2));
    if (FAILED(hr))
    {
        DPF_ERR("Could not QI for IDAImage from bvr2 of image track's compose");
        ReleaseInterface(pImage1);
        return hr;
    }

    // Now create an overlay behavior.
    IDAImage *pImageTemp = NULL;
    hr = Actor()->GetDAStatics()->Overlay(pImage1, pImage2, &pImageTemp);
    ReleaseInterface(pImage1);
    ReleaseInterface(pImage2);
    if (FAILED(hr))
    {
        DPF_ERR("Could not create the Overlay behavior in image track's compose");
        return hr;
    }

    *ppdabvrResult = pImageTemp;

    return S_OK;
} // Compose

//*****************************************************************************

HRESULT
CActorBvr::CImageBvrTrack::ProcessBvr(IDABehavior *pOriginal,
								      ActorBvrFlags eFlags,
								      IDABehavior **ppResult)
{
	// If flag is set to e_ScaledImage, then scale it if there is a scale
	// matrix
	DASSERT(ppResult != NULL);
	*ppResult = NULL;

	HRESULT hr = S_OK;

	if (eFlags == e_ScaledImage && Actor()->m_pScale != NULL)
	{
		// Scale the image
		IDAImage *pImage = NULL;
		hr = pOriginal->QueryInterface(IID_TO_PPV(IDAImage, &pImage));
		if (FAILED(hr))
			return hr;

		IDAImage *pScaledImage = NULL;
		hr = pImage->Transform(Actor()->m_pScale, &pScaledImage);
		ReleaseInterface(pImage);
		if (FAILED(hr))
			return hr;

		*ppResult = pScaledImage;
	}
	else
	{
		// Just return original with no processing
		*ppResult = pOriginal;
		pOriginal->AddRef();
	}

	return S_OK;
}

//*****************************************************************************

HRESULT 
CActorBvr::CImageBvrTrack::ProcessIntermediate( IDABehavior *pOriginal,
                                                ActorBvrFlags eFlags,
								                IDABehavior **ppResult)
{
    if( pOriginal == NULL || ppResult == NULL )
        return E_INVALIDARG;

    HRESULT hr;

    IDAImage *pdaimgOriginal = NULL;
    IDAImage *pdaimgPrepared = NULL;

    hr = pOriginal->QueryInterface( IID_TO_PPV(IDAImage, &pdaimgOriginal));
    CheckHR( hr, "Failed to QI the incoming original for IDAImage", cleanup );

    hr = Actor()->PrepareImageForDXTransform( pdaimgOriginal, &pdaimgPrepared );
    CheckHR( hr, "Failed to prepare the image for a DX Transform", cleanup );

    hr = pdaimgPrepared->QueryInterface( IID_TO_PPV( IDABehavior, ppResult ) );
    CheckHR( hr, "Failed QI of image for IDABehavoir", cleanup );

cleanup:

    if( FAILED( hr ) )
    {
        *ppResult = NULL;
    }
    ReleaseInterface( pdaimgOriginal );
    ReleaseInterface( pdaimgPrepared );

    return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CImageBvrTrack::CreateInstance(CActorBvr     *pbvrActor,
                                           BSTR           bstrPropertyName,
                                           ActorBvrType   eType,
                                           CBvrTrack    **pptrackResult)
{
    DASSERT(NULL != pbvrActor);
    DASSERT(NULL != pptrackResult);
    *pptrackResult = NULL;

    // Create the new bvr track
    CBvrTrack* ptrack = new CImageBvrTrack(pbvrActor, eType);
    if (NULL == ptrack)
    {
        DPF_ERR("Insufficient memory to allocate a new image bvr track");
        return E_OUTOFMEMORY;
    }

    // Set the property name
    HRESULT hr = ptrack->SetPropertyName(bstrPropertyName);
    if (FAILED(hr))
    {
        DPF_ERR("Could not set the bvr track's property name");
        delete ptrack;
        return hr;
    }

    *pptrackResult = ptrack;

    return hr;
} // CreateInstance

//*****************************************************************************
//
// class CColorBvrTrack
//
//*****************************************************************************

CActorBvr::CColorBvrTrack::CColorBvrTrack(CActorBvr *pbvrActor, ActorBvrType eType)
:   CBvrTrack(pbvrActor, eType),
	m_pRedSampler(NULL),
	m_pGreenSampler(NULL),
	m_pBlueSampler(NULL),
	m_currRed(-1),
	m_currGreen(-1),
	m_currBlue(-1),
	m_newCount(0),
	m_lRedCookie(0),
	m_lGreenCookie(0),
	m_lBlueCookie(0),
	m_lColorId(-1),
	m_fFirstSample( true )
{
} // CColorBvrTrack

//*****************************************************************************

CActorBvr::CColorBvrTrack::~CColorBvrTrack()
{
	if (m_pRedSampler != NULL)
		m_pRedSampler->Invalidate();

	if (m_pGreenSampler != NULL)
		m_pGreenSampler->Invalidate();

	if (m_pBlueSampler != NULL)
		m_pBlueSampler->Invalidate();
}

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::IdentityBvr(IDABehavior **ppdabvrIdentity)
{
	HRESULT hr = S_OK;

    DASSERT(NULL != ppdabvrIdentity);
    *ppdabvrIdentity = NULL;

    // There is not really an identity for color (you cannot compose colors)
	// but in some situations we really need a color.  Return white just for the
	// fun of it
	IDAColor *pColor = NULL;

	hr = Actor()->GetDAStatics()->get_White(&pColor);
	if (FAILED(hr))
		return hr;

	*ppdabvrIdentity = pColor;

    return S_OK;
} // IdentityBvr

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::StaticBvr(IDABehavior **ppdabvrStatic)
{
    DASSERT(NULL != ppdabvrStatic);
    HRESULT hr = S_OK;
    *ppdabvrStatic = NULL;

	if( m_pModifiableStatic == NULL )
	{
		hr = UpdateStaticBvr();
	}

	if( SUCCEEDED( hr ) )
	{
		(*ppdabvrStatic) = m_pModifiableStatic;
		(*ppdabvrStatic)->AddRef();
	}
    else
    {
        // Need to return something
		return IdentityBvr(ppdabvrStatic);
    }

    return S_OK;
} // StaticBvr

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::UninitBvr(IDABehavior **ppUninit)
{
	DASSERT(ppUninit != NULL);

	*ppUninit = NULL;

    HRESULT hr = CoCreateInstance(CLSID_DAColor, 
								  NULL, 
								  CLSCTX_INPROC_SERVER, 
								  IID_IDABehavior, 
								  (void**)ppUninit);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to cocreate uninit color");
		return hr;
	}

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::ModifiableBvr( IDABehavior **ppModifiable )
{
	ReturnIfArgNull( ppModifiable );

	HRESULT hr = S_OK;

	(*ppModifiable) = NULL;

	IDAColor *pRed = NULL;

	hr = Actor()->GetDAStatics()->get_Red( &pRed );
	CheckHR( hr, "Failed to get red from da", end );

	hr = Actor()->GetDAStatics()->ModifiableBehavior( pRed, ppModifiable );
	CheckHR( hr, "Failed to create a modifiable behavior for a color track", end );

end:
	ReleaseInterface( pRed );

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::Compose(IDABehavior  *pdabvr1,
                                    IDABehavior  *pdabvr2,
                                    IDABehavior **ppdabvrResult)
{
	// Cannot compose Colors

    return E_NOTIMPL;
} // Compose

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::HookBvr(IDABehavior *pBvr)
{
	HRESULT hr = S_OK;

	// We need to hook this behavior
	m_pRedSampler = new CSampler(RedCallback, (void*)this);
	m_pGreenSampler = new CSampler(GreenCallback, (void*)this);
	m_pBlueSampler = new CSampler(BlueCallback, (void*)this);

	if (m_pRedSampler == NULL || m_pGreenSampler == NULL || m_pBlueSampler == NULL)
		return E_FAIL;

	IDAColor *pColor = NULL;
	hr = pBvr->QueryInterface(IID_TO_PPV(IDAColor, &pColor));
	if (FAILED(hr))
		return hr;

	IDANumber *pNumber = NULL;
	IDABehavior *pHooked = NULL;

	// Hook Red
	pColor->get_Red(&pNumber);
	if (FAILED(hr))
	{
		ReleaseInterface(pColor);
		return hr;
	}
	hr = m_pRedSampler->Attach(pNumber, &pHooked);
	ReleaseInterface(pNumber);
	if (FAILED(hr))
	{
		ReleaseInterface(pColor);
		return hr;
	}
	hr = AddBehaviorToTIME( pHooked, &m_lRedCookie, REDBVR_COOKIESET );
	ReleaseInterface(pHooked);
	if (FAILED(hr))
	{
		ReleaseInterface(pColor);
		return hr;
	}

	// Hook Green
	pColor->get_Green(&pNumber);
	if (FAILED(hr))
	{
		ReleaseInterface(pColor);
		return hr;
	}
	hr = m_pGreenSampler->Attach(pNumber, &pHooked);
	ReleaseInterface(pNumber);
	if (FAILED(hr))
	{
		ReleaseInterface(pColor);
		return hr;
	}
	hr = AddBehaviorToTIME( pHooked, &m_lGreenCookie, GREENBVR_COOKIESET );
	ReleaseInterface(pHooked);
	if (FAILED(hr))
	{
		ReleaseInterface(pColor);
		return hr;
	}

	// Hook Blue
	pColor->get_Blue(&pNumber);
	if (FAILED(hr))
	{
		ReleaseInterface(pColor);
		return hr;
	}
	hr = m_pBlueSampler->Attach(pNumber, &pHooked);
	ReleaseInterface(pNumber);
	if (FAILED(hr))
	{
		ReleaseInterface(pColor);
		return hr;
	}
	hr = AddBehaviorToTIME( pHooked, &m_lBlueCookie, BLUEBVR_COOKIESET );
	ReleaseInterface(pHooked);
	if (FAILED(hr))
	{
		ReleaseInterface(pColor);
		return hr;
	}

	ReleaseInterface(pColor);

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::RedCallback(void *thisPtr,
										   long id,
										   double startTime,
										   double globalNow,
										   double localNow,
										   IDABehavior *sampleVal,
										   IDABehavior **ppReturn)
{
	HRESULT hr = S_OK;

	CColorBvrTrack *pTrack = (CColorBvrTrack*)thisPtr;

	if( pTrack->m_lColorId == -1 )
	{
		pTrack->m_fFirstSample = true;
		pTrack->m_lColorId = id;
	}

	if( pTrack->m_lColorId != id )
		return S_OK;
	

	IDANumber *pNumber = NULL;
	hr = sampleVal->QueryInterface(IID_TO_PPV(IDANumber, &pNumber));
	if (FAILED(hr))
		return hr;

	double value;
	hr = pNumber->Extract(&value);
	ReleaseInterface(pNumber);
	if (FAILED(hr))
		return hr;

	return pTrack->SetNewValue(value, &(pTrack->m_newRed) );
}

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::GreenCallback(void *thisPtr,
										   long id,
										   double startTime,
										   double globalNow,
										   double localNow,
										   IDABehavior *sampleVal,
										   IDABehavior **ppReturn)
{
	HRESULT hr = S_OK;

	CColorBvrTrack *pTrack = (CColorBvrTrack*)thisPtr;

	if( pTrack->m_lColorId == -1 )
	{
		pTrack->m_fFirstSample = true;
		pTrack->m_lColorId = id;
	}

	if( pTrack->m_lColorId != id )
		return S_OK;


	IDANumber *pNumber = NULL;
	hr = sampleVal->QueryInterface(IID_TO_PPV(IDANumber, &pNumber));
	if (FAILED(hr))
		return hr;

	double value;
	hr = pNumber->Extract(&value);
	ReleaseInterface(pNumber);
	if (FAILED(hr))
		return hr;

	return pTrack->SetNewValue(value, &(pTrack->m_newGreen) );
}

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::BlueCallback(void *thisPtr,
										   long id,
										   double startTime,
										   double globalNow,
										   double localNow,
										   IDABehavior *sampleVal,
										   IDABehavior **ppReturn)
{
	HRESULT hr = S_OK;

	CColorBvrTrack *pTrack = (CColorBvrTrack*)thisPtr;

	if( pTrack->m_lColorId == -1 )
	{
		pTrack->m_fFirstSample = true;
		pTrack->m_lColorId = id;
	}

	if( pTrack->m_lColorId != id )
		return S_OK;


	IDANumber *pNumber = NULL;
	hr = sampleVal->QueryInterface(IID_TO_PPV(IDANumber, &pNumber));
	if (FAILED(hr))
		return hr;

	double value;
	hr = pNumber->Extract(&value);
	ReleaseInterface(pNumber);
	if (FAILED(hr))
		return hr;

	return pTrack->SetNewValue(value, &(pTrack->m_newBlue) );
}

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::SetNewValue(double value, short *pNew )
{
	*pNew = (short)(value * 255.0);

	// Need to count up to three Sets

	m_newCount++;

	if (m_newCount == 3)
	{
		m_newCount = 0;

		HRESULT hr = ValueSampled(m_newRed, m_newGreen, m_newBlue, m_fFirstSample );

		m_fFirstSample = false;

		return hr;
	}

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::ValueSampled(short red, short green, short blue, bool fFirstSample )
{
	HRESULT hr = S_OK;

	if (m_currRed != red || m_currGreen != green || m_currBlue != blue || fFirstSample )
	{
		m_currRed = red;
		m_currGreen = green;
		m_currBlue = blue;

		short nRed =	(red<0)	? 0 :	((red>255) ? 255 :red);
		short nGreen =	(green<0) ? 0 : ((green>255) ? 255 : green);
		short nBlue =	(blue<0) ? 0 :	((blue>255) ? 255 : blue);

		::VariantClear( &m_varCurrentValue );

		// Value has changed, push it through
		V_VT(&m_varCurrentValue) = VT_BSTR;
		V_BSTR(&m_varCurrentValue) = ::SysAllocStringLen(NULL, 7); 

		m_varCurrentValue.bstrVal[0] = L'#';
		m_varCurrentValue.bstrVal[1] = HexChar(nRed >> 4);
		m_varCurrentValue.bstrVal[2] = HexChar(nRed & 0xf);
		m_varCurrentValue.bstrVal[3] = HexChar(nGreen >> 4);
		m_varCurrentValue.bstrVal[4] = HexChar(nGreen & 0xf);
		m_varCurrentValue.bstrVal[5] = HexChar(nBlue >> 4);
		m_varCurrentValue.bstrVal[6] = HexChar(nBlue & 0xf);

		hr = UpdateOnValueState( value_change );
	}
	else
	{
		hr = UpdateOnValueState( value_no_change );
	}

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::SwitchAccum(IDABehavior *pModifiable)
{
	HRESULT hr = S_OK;

	if (pModifiable == NULL)
		return E_FAIL;

	if (m_lColorId != -1)
	{
		IDAColor *pColor = NULL;
		hr = Actor()->GetDAStatics()->ColorRgb255(m_currRed, m_currGreen, m_currBlue, &pColor);
		if (FAILED(hr))
			return hr;

		hr = pModifiable->SwitchTo(pColor);
		ReleaseInterface(pColor);
	}

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::HookAccumBvr(IDABehavior *pBvr, IDABehavior **ppResult)
{
	*ppResult = pBvr;
	pBvr->AddRef();

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::CreateInstance(CActorBvr     *pbvrActor,
                                           BSTR           bstrPropertyName,
                                           ActorBvrType   eType,
                                           CBvrTrack    **pptrackResult)
{
    DASSERT(NULL != pbvrActor);
    DASSERT(NULL != pptrackResult);
    *pptrackResult = NULL;

    // Create the new bvr track
    CBvrTrack* ptrack = new CColorBvrTrack(pbvrActor, eType);
    if (NULL == ptrack)
    {
        DPF_ERR("Insufficient memory to allocate a new color bvr track");
        return E_OUTOFMEMORY;
    }

    // Set the property name
    HRESULT hr = ptrack->SetPropertyName(bstrPropertyName);
    if (FAILED(hr))
    {
        DPF_ERR("Could not set the bvr track's property name");
        delete ptrack;
        return hr;
    }

    *pptrackResult = ptrack;

    return hr;
} // CreateInstance

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::Detach()
{
	HRESULT hr = S_OK;

	hr = RemoveBehaviorFromTIME( m_lRedCookie, REDBVR_COOKIESET );
	CheckHR( hr, "Failed to remove the red behaivor from time in detach", end );

	hr = RemoveBehaviorFromTIME( m_lGreenCookie, GREENBVR_COOKIESET );
	CheckHR( hr, "Failed to remove the green behaivor from time in detach", end );

	hr = RemoveBehaviorFromTIME( m_lBlueCookie, BLUEBVR_COOKIESET );
	CheckHR( hr, "Failed to remove the blue behaivor from time in detach", end );

	m_lColorId = -1;
	
	hr = CBvrTrack::Detach();

  end:
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CColorBvrTrack::DABvrFromVariant( VARIANT *pvarValue, IDABehavior **ppdabvr )
{
	if( pvarValue == NULL || ppdabvr == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	VARIANT varValue;
	DWORD color = 0;
	float colorH = 0.0; 
	float colorS = 0.0;
	float colorL = 0.0;
	IDAColor *pColor = NULL;

	VariantInit( &varValue );

	
	hr = VariantChangeTypeEx(&varValue, pvarValue, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR);
	CheckHR( hr, "Could not get color property as string", end );
	
	color = CUtils::GetColorFromVariant(&varValue);

	if (color == PROPERTY_INVALIDCOLOR)
	{
		DPF_ERR("Could not translate property into color value");
		hr = E_FAIL;
		goto end;
	}

    CUtils::GetHSLValue(color, &colorH, &colorS, &colorL);

	hr = CDAUtils::BuildDAColorFromStaticHSL( Actor()->GetDAStatics(), colorH, colorS, colorL, &pColor);
	CheckHR( hr, "Failed to build DA color from HSL", end );

	hr = pColor->QueryInterface( IID_TO_PPV( IDABehavior, ppdabvr ) );
	CheckHR( hr, "Failed to get the dabehavior from the color bvr", end );
	
end:
	ReleaseInterface( pColor );

	VariantClear( &varValue );

    return S_OK;

}


//*****************************************************************************
//
// class CStringBvrTrack
//
//*****************************************************************************

CActorBvr::CStringBvrTrack::CStringBvrTrack(CActorBvr *pbvrActor, ActorBvrType eType)
:   CBvrTrack(pbvrActor, eType),
	m_pEmptyString(NULL),
	m_pSampler(NULL),
	m_bstrCurrValue(NULL),
	m_lStringCookie(0),
	m_lStringId(-1)
{
}

//*****************************************************************************

CActorBvr::CStringBvrTrack::~CStringBvrTrack()
{
	ReleaseInterface(m_pEmptyString);

	if (m_pSampler != NULL)
	{
		m_pSampler->Invalidate();
		m_pSampler = NULL;
	}
	
	if (m_bstrCurrValue != NULL)
		::SysFreeString(m_bstrCurrValue);
}

//*****************************************************************************

HRESULT
CActorBvr::CStringBvrTrack::IdentityBvr(IDABehavior **ppdabvrIdentity)
{
    DASSERT(NULL != ppdabvrIdentity);
    *ppdabvrIdentity = NULL;

	HRESULT hr = E_FAIL;

    if (m_pEmptyString == NULL)
	{
		CComBSTR empty = L"";

		hr = Actor()->GetDAStatics()->DAString(empty, &m_pEmptyString);

		if (FAILED(hr))
		{
			m_pEmptyString = NULL;
			DPF_ERR("Failed to create empty string");
			return hr;
		}
	}

	*ppdabvrIdentity = m_pEmptyString;
	m_pEmptyString->AddRef();

    return S_OK;
} // IdentityBvr

//*****************************************************************************

HRESULT
CActorBvr::CStringBvrTrack::StaticBvr(IDABehavior **ppdabvrStatic)
{
    DASSERT(NULL != ppdabvrStatic);
    HRESULT hr = S_OK;
    *ppdabvrStatic = NULL;

	if( m_pModifiableStatic == NULL )
	{
		hr = UpdateStaticBvr();
	}

	if( SUCCEEDED( hr ) )
	{
		(*ppdabvrStatic) = m_pModifiableStatic;
		(*ppdabvrStatic)->AddRef();
	}
	else
	{
		return IdentityBvr( ppdabvrStatic );
	}
		

	return S_OK;
} // StaticBvr

//*****************************************************************************

HRESULT
CActorBvr::CStringBvrTrack::Compose(IDABehavior  *pdabvr1,
                                    IDABehavior  *pdabvr2,
                                    IDABehavior **ppdabvrResult)
{
	// Cannot compose Strings

	// TODO (markhal): Potentially do composition as concatenation

    return E_NOTIMPL;
} // Compose

//*****************************************************************************

HRESULT
CActorBvr::CStringBvrTrack::HookBvr(IDABehavior *pBvr)
{
	HRESULT hr = S_OK;

	if (m_pSampler != NULL)
	{
		m_pSampler->Invalidate();
		m_pSampler = NULL;
	}

	// We need to hook this behavior
	m_pSampler = new CSampler(StringCallback, (void*)this);

	if (m_pSampler == NULL)
		return E_FAIL;

	IDABehavior *pHookedBvr = NULL;
	hr = m_pSampler->Attach(pBvr, &pHookedBvr);
	if (FAILED(hr))
		return hr;

	// Add the behavior to the TIME element so it runs and samples
	hr = AddBehaviorToTIME( pHookedBvr, &m_lStringCookie, STRINGBVR_COOKIESET );
	ReleaseInterface(pHookedBvr);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CStringBvrTrack::StringCallback(void *thisPtr,
										   long id,
										   double startTime,
										   double globalNow,
										   double localNow,
										   IDABehavior *sampleVal,
										   IDABehavior **ppReturn)
{
	if( thisPtr == NULL )
		return E_INVALIDARG;
		
	HRESULT hr = S_OK;

	CStringBvrTrack *pTrack = (CStringBvrTrack*)thisPtr;

	bool fFirstSample = false;

	if( pTrack->m_lStringId == -1 )
	{
		pTrack->m_lStringId = id;
		fFirstSample = true;
	}

	if( pTrack->m_lStringId != id )
		return S_OK;

	IDAString *pString = NULL;
	hr = sampleVal->QueryInterface(IID_TO_PPV(IDAString, &pString));
	if (FAILED(hr))
		return hr;

	BSTR value;
	hr = pString->Extract(&value);
	ReleaseInterface(pString);
	if (FAILED(hr))
		return hr;

	if (pTrack == NULL)
		return E_FAIL;

	hr = pTrack->ValueSampled( value, fFirstSample );

	::SysFreeString(value);

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CStringBvrTrack::ValueSampled(BSTR val, bool fFirstSample )
{
	HRESULT hr = S_OK;

	if (m_bstrCurrValue == NULL || wcscmp(val, m_bstrCurrValue) != 0 || fFirstSample )
	{
		if (m_bstrCurrValue != NULL)
			::SysFreeString(m_bstrCurrValue);

		m_bstrCurrValue = ::SysAllocString(val);

		// Value has changed, push it through
		::VariantClear( &m_varCurrentValue );
		V_VT(&m_varCurrentValue) = VT_BSTR;
		V_BSTR(&m_varCurrentValue) = ::SysAllocString(val); 

		hr = UpdateOnValueState( value_change );
	}
	else
	{
		hr = UpdateOnValueState( value_no_change );
	}

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CStringBvrTrack::CreateInstance(CActorBvr     *pbvrActor,
                                           BSTR           bstrPropertyName,
                                           ActorBvrType   eType,
                                           CBvrTrack    **pptrackResult)
{
    DASSERT(NULL != pbvrActor);
    DASSERT(NULL != pptrackResult);
    *pptrackResult = NULL;

    // Create the new bvr track
    CBvrTrack* ptrack = new CStringBvrTrack(pbvrActor, eType);
    if (NULL == ptrack)
    {
        DPF_ERR("Insufficient memory to allocate a new string bvr track");
        return E_OUTOFMEMORY;
    }

    // Set the property name
    HRESULT hr = ptrack->SetPropertyName(bstrPropertyName);
    if (FAILED(hr))
    {
        DPF_ERR("Could not set the bvr track's property name");
        delete ptrack;
        return hr;
    }

    *pptrackResult = ptrack;

    return hr;
} // CreateInstance

//*****************************************************************************

HRESULT
CActorBvr::CStringBvrTrack::Detach()
{
	HRESULT hr = S_OK;

	m_lStringId = -1;
	hr = RemoveBehaviorFromTIME( m_lStringCookie, STRINGBVR_COOKIESET );
	CheckHR( hr, "Could not remove the string bvr from time in detach", end );
	
	hr = CBvrTrack::Detach();
	
  end:
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CStringBvrTrack::DABvrFromVariant( VARIANT *pvarValue, IDABehavior **ppdabvr)
{
	if( pvarValue == NULL || ppdabvr == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;
	VARIANT varString;
	IDAString *pdastr = NULL;

	::VariantInit( &varString );

	hr = ::VariantChangeTypeEx( &varString, pvarValue, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR );
	CheckHR( hr, "Failed to change the type of the variant to a string", end );

	hr = Actor()->GetDAStatics()->DAString( V_BSTR( &varString ), &pdastr );
	CheckHR( hr, "Failed to create a da string from the variant", end );

	hr = pdastr->QueryInterface( IID_TO_PPV( IDABehavior, ppdabvr ) );
	CheckHR( hr, "Failed to QI final string for IDABehavior", end );

end:
	::VariantClear( &varString );
	ReleaseInterface( pdastr );

	return hr;
}


//*****************************************************************************
//
// class CFloatManager
//
//*****************************************************************************

CActorBvr::CFloatManager::CFloatManager(CActorBvr *pActor)
:	m_pActor(pActor),
	m_pFilter(NULL),
	m_pElement(NULL),
	m_pElement2(NULL),
	m_pWidthSampler(NULL),
	m_pHeightSampler(NULL),
	m_currWidth(0),
	m_currHeight(0),
	m_origWidth(0),
	m_origHeight(0),
	m_origLeft(-1),
	m_origTop(-1),
	m_lWidthCookie(0),
	m_lHeightCookie(0)
{
}

CActorBvr::CFloatManager::~CFloatManager()
{
	ReleaseInterface(m_pFilter);
	ReleaseInterface(m_pElement);
	ReleaseInterface(m_pElement2);

	if (m_pWidthSampler != NULL)
		m_pWidthSampler->Invalidate();

	if (m_pHeightSampler != NULL)
		m_pHeightSampler->Invalidate();
}

HRESULT
CActorBvr::CFloatManager::GetElement(IHTMLElement **ppElement)
{
	DASSERT(ppElement != NULL);
	*ppElement = NULL;

	if (m_pElement == NULL)
	{
		// Create the floating element using markup services
		HRESULT hr = E_FAIL;

		// Get animated element
		IHTMLElement *pAnimatedElement;
		hr = m_pActor->GetAnimatedElement( &pAnimatedElement );
		if (FAILED( hr ))
		{
			DPF_ERR("Error getting element to animate");
			return hr;
		}

		// Get document
		IDispatch *pDocumentDisp;
		hr = pAnimatedElement->get_document(&pDocumentDisp);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to get document");
			return hr;
		}

		// Query for markup services
		IMarkupServices *pMarkupServices = NULL;
		hr = pDocumentDisp->QueryInterface(IID_TO_PPV(IMarkupServices, &pMarkupServices));
		ReleaseInterface(pDocumentDisp);
		if (FAILED(hr))
		{
			ReleaseInterface(pAnimatedElement);
			return hr;
		}

		// Create a div
		IHTMLElement *pElement = NULL;
		hr = pMarkupServices->CreateElement(TAGID_DIV, L"style=position:absolute;background-color:green;border:1 solid black", &pElement);
		if (FAILED(hr))
		{
			m_pElement = NULL;
			ReleaseInterface(pMarkupServices);
			ReleaseInterface(pAnimatedElement);
			return hr;
		}

		// Position a pointer after the animated element
		IMarkupPointer *pPointer = NULL;
		hr = pMarkupServices->CreateMarkupPointer(&pPointer);
		if (FAILED(hr))
		{
			ReleaseInterface(pMarkupServices);
			ReleaseInterface(pAnimatedElement);
			ReleaseInterface(pElement);
			return hr;
		}

		hr = pPointer->MoveAdjacentToElement(pAnimatedElement, ELEM_ADJ_BeforeBegin);
		ReleaseInterface(pAnimatedElement);
		if (FAILED(hr))
		{
			ReleaseInterface(pMarkupServices);
			ReleaseInterface(pElement);
			return hr;
		}

		// Insert the new element
		hr = pMarkupServices->InsertElement(pElement, pPointer, NULL);
		ReleaseInterface(pPointer);
		ReleaseInterface(pMarkupServices);
		if (FAILED(hr))
		{
			ReleaseInterface(pElement);
			return hr;
		}

		// Succeeded
		m_pElement = pElement;
		pElement = NULL;

		hr = m_pElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &m_pElement2));
		if (FAILED(hr))
			return hr;

		// Make sure we are in sync with zIndex, visibility, display
		UpdateZIndex();
		UpdateVisibility();
		UpdateDisplay();

		// Make sure we are in sync with width and height
		UpdateRect(m_pActor->m_pixelLeft,
				   m_pActor->m_pixelTop,
				   m_pActor->m_pixelWidth,
				   m_pActor->m_pixelHeight);
	}

	*ppElement = m_pElement;
	m_pElement->AddRef();

	return S_OK;
}

HRESULT
CActorBvr::CFloatManager::GetFilter(IDispatch **ppFilter)
{
	HRESULT hr = S_OK;

	*ppFilter = NULL;

	if (m_pFilter == NULL)
	{
		// Get the float element
		IHTMLElement *pElement = NULL;
		hr = GetElement(&pElement);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to get float element");
			return hr;
		}

		// Get a filter from it
		hr = m_pActor->GetElementFilter(pElement, &m_pFilter);
		ReleaseInterface(pElement);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to get filter");
			return hr;
		}
	}

	*ppFilter = m_pFilter;
	m_pFilter->AddRef();

	return S_OK;
}

HRESULT
CActorBvr::CFloatManager::Detach()
{
	if (m_pFilter != NULL)
		m_pActor->SetElementOnFilter(m_pFilter, NULL);
	
	return S_OK;
}

HRESULT
CActorBvr::CFloatManager::ApplyImageBvr(IDAImage *pImage)
{
	DASSERT(pImage != NULL);

	HRESULT hr = S_OK;

	//if we have already added a sampled witdth to time
	if( m_lWidthCookie != 0 )
	{
		//remove the sampled value from time.
		hr = m_pActor->RemoveBehaviorFromTIME( m_lWidthCookie );
		if( FAILED( hr ) )
		{
			return hr;
		}

		m_pWidthSampler->Invalidate();
		m_pWidthSampler = NULL;

		m_lWidthCookie = 0;
	}

	//if we have already added a sampled height to time
	if( m_lHeightCookie != 0 )
	{
		//remove th esampled value from time.
		hr = m_pActor->RemoveBehaviorFromTIME( m_lHeightCookie );
		if( FAILED( hr ) )
		{
			return hr;
		}

		m_pHeightSampler->Invalidate();
		m_pHeightSampler = NULL;

		m_lHeightCookie = 0;
	}

	// Attach image to TIME element but disable rendering
	hr = m_pActor->AddImageToTIME(m_pActor->GetHTMLElement(), pImage, false);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to apply image to element");
		return hr;
	}

	// Set original element on filter
	IDispatch *pFilter = NULL;
	hr = GetFilter(&pFilter);
	if (FAILED(hr))
		return hr;

	hr = m_pActor->SetElementOnFilter(pFilter, m_pActor->GetHTMLElement());
	ReleaseInterface(pFilter);
	if (FAILED(hr))
		return hr;

	// Observe width and height of image
	// Get bounding box
	IDABbox2 *pBbox = NULL;
	hr = pImage->get_BoundingBox(&pBbox);
	if (FAILED(hr))
		return hr;

	// Get max and min
	IDAPoint2 *pMin = NULL;
	IDAPoint2 *pMax = NULL;
	hr = pBbox->get_Min(&pMin);
	if (FAILED(hr))
	{
		ReleaseInterface(pBbox);
		return hr;
	}

	hr = pBbox->get_Max(&pMax);
	ReleaseInterface(pBbox);
	if (FAILED(hr))
	{
		ReleaseInterface(pMin);
		return hr;
	}

	// Get diff
	IDAVector2 *pDiff = NULL;
	hr = m_pActor->GetDAStatics()->SubPoint2(pMax, pMin, &pDiff);
	ReleaseInterface(pMax);
	ReleaseInterface(pMin);
	if (FAILED(hr))
		return hr;

	// Scale into pixels
	IDANumber *pPixel = NULL;
	hr = m_pActor->GetDAStatics()->get_Pixel(&pPixel);
	if (FAILED(hr))
	{
		ReleaseInterface(pDiff);
		return hr;
	}

	IDAVector2 *pTemp = NULL;
	hr = pDiff->DivAnim(pPixel, &pTemp);
	ReleaseInterface(pDiff);
	ReleaseInterface(pPixel);
	if (FAILED(hr))
		return hr;
	pDiff = pTemp;
	pTemp = NULL;

	// Get width
	IDANumber *pWidth = NULL;
	hr = pDiff->get_X(&pWidth);
	if (FAILED(hr))
	{
		ReleaseInterface(pDiff);
		return hr;
	}

	
	
	// Hook it
	hr = HookBvr(pWidth, widthCallback, &m_pWidthSampler, &m_lWidthCookie);
	ReleaseInterface(pWidth);
	if (FAILED(hr))
	{
		ReleaseInterface(pDiff);
		return hr;
	}

	// Get height
	IDANumber *pHeight = NULL;
	hr = pDiff->get_Y(&pHeight);
	ReleaseInterface(pDiff);
	if (FAILED(hr))
		return hr;

	// Hook it
	hr = HookBvr(pHeight, heightCallback, &m_pHeightSampler, &m_lHeightCookie);
	ReleaseInterface(pHeight);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

HRESULT
CActorBvr::CFloatManager::HookBvr(IDABehavior *pBvr,
								  SampleCallback callback,
								  CSampler **ppSampler,
								  long *plCookie)
{
	if( plCookie == NULL )
		return E_INVALIDARG;
	HRESULT hr = S_OK;

	// Create sampler for height
	if (*ppSampler == NULL)
	{
		*ppSampler = new CSampler(callback, (void*)this);

		if (*ppSampler == NULL)
			return E_FAIL;
	}

	// Ask it to hook the bvr
	IDABehavior *pHookedBvr = NULL;
	hr = (*ppSampler)->Attach(pBvr, &pHookedBvr);
	if (FAILED(hr))
		return hr;

	// Add the behavior to the TIME element so it runs and samples
	hr = m_pActor->AddBehaviorToTIME(pHookedBvr, plCookie);
	ReleaseInterface(pHookedBvr);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

HRESULT
CActorBvr::CFloatManager::UpdateElementRect()
{
	HRESULT hr = S_OK;

	if( m_currWidth == -HUGE_VAL || m_currHeight == -HUGE_VAL )
		return S_OK;


	// Get style
	IHTMLStyle *pStyle = NULL;
	hr = m_pElement2->get_runtimeStyle(&pStyle);
	if (FAILED(hr))
		return hr;

	// Ignore errors
	pStyle->put_pixelLeft((long)((m_origLeft + ((double)m_origWidth)/2 - m_currWidth/2) + .5));
	pStyle->put_pixelTop((long)((m_origTop + ((double)m_origHeight)/2 - m_currHeight/2) + .5));
	pStyle->put_pixelWidth((long)(m_currWidth + .5));
	pStyle->put_pixelHeight((long)(m_currHeight + .5));

	ReleaseInterface(pStyle);

	return S_OK;
}

HRESULT
CActorBvr::CFloatManager::UpdateRect(long left, long top, long width, long height)
{
	m_origLeft = left;
	m_origTop = top;
	m_origWidth = width;
	m_origHeight = height;

	return UpdateElementRect();
}

HRESULT
CActorBvr::CFloatManager::UpdateZIndex()
{
	HRESULT hr = S_OK;

	if (m_pElement2 == NULL)
		return S_OK;

	// Get the current style for the animated element
	IHTMLElement *pElement = NULL;
	hr = m_pActor->GetAnimatedElement(&pElement);
	if (FAILED(hr))
		return hr;

	IHTMLCurrentStyle *pCurrStyle = NULL;
	hr = m_pActor->GetCurrentStyle(pElement, &pCurrStyle);
	ReleaseInterface(pElement);
	if (FAILED(hr))
		return hr;

	// Get the zIndex
	VARIANT varValue;
	VariantInit(&varValue);
	hr = pCurrStyle->get_zIndex(&varValue);
	ReleaseInterface(pCurrStyle);
	if (FAILED(hr))
		return hr;

	// Get the runtime style
	IHTMLStyle *pStyle = NULL;
	hr = m_pElement2->get_runtimeStyle(&pStyle);
	if (FAILED(hr))
	{
		VariantClear(&varValue);
		return hr;
	}

	// Set the zIndex on it
	hr = pStyle->put_zIndex(varValue);
	VariantClear(&varValue);
	if (FAILED(hr))
	{
		// There is currently a bug in IE that if you set zIndex to auto
		// this fails.  Since this is a primary use case, we're going to have
		// to hack it to set it to 0 at this point.  When the bug in IE is
		// fixed this code will never get hit
		V_VT(&varValue) = VT_I4;
		V_I4(&varValue) = 0;
		hr = pStyle->put_zIndex(varValue);
		VariantClear(&varValue);
		if (FAILED(hr))
			return hr;
	}	
	ReleaseInterface(pStyle);

	return S_OK;
}

HRESULT
CActorBvr::CFloatManager::UpdateVisibility()
{
	HRESULT hr = S_OK;

	if (m_pElement2 == NULL)
		return S_OK;

	// Get the current style for the animated element
	IHTMLElement *pElement = NULL;
	hr = m_pActor->GetAnimatedElement(&pElement);
	if (FAILED(hr))
		return hr;

	IHTMLCurrentStyle *pCurrStyle = NULL;
	hr = m_pActor->GetCurrentStyle(pElement, &pCurrStyle);
	ReleaseInterface(pElement);
	if (FAILED(hr))
		return hr;

	// Get the visibility
	BSTR bstrVal;
	hr = pCurrStyle->get_visibility(&bstrVal);
	ReleaseInterface(pCurrStyle);
	if (FAILED(hr))
		return hr;

	// Get the runtime style
	IHTMLStyle *pStyle = NULL;
	hr = m_pElement2->get_runtimeStyle(&pStyle);
	if (FAILED(hr))
	{
		::SysFreeString(bstrVal);
		return hr;
	}

	// Set the visibility on it
	hr = pStyle->put_visibility(bstrVal);
	ReleaseInterface(pStyle);
	::SysFreeString(bstrVal);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

HRESULT
CActorBvr::CFloatManager::UpdateDisplay()
{
	HRESULT hr = S_OK;

	if (m_pElement2 == NULL)
		return S_OK;

	// Get the current style for the animated element
	IHTMLElement *pElement = NULL;
	hr = m_pActor->GetAnimatedElement(&pElement);
	if (FAILED(hr))
		return hr;

	IHTMLCurrentStyle *pCurrStyle = NULL;
	hr = m_pActor->GetCurrentStyle(pElement, &pCurrStyle);
	ReleaseInterface(pElement);
	if (FAILED(hr))
		return hr;

	// Get the display
	BSTR bstrVal;
	hr = pCurrStyle->get_display(&bstrVal);
	ReleaseInterface(pCurrStyle);
	if (FAILED(hr))
		return hr;

	// Get the runtime style
	IHTMLStyle *pStyle = NULL;
	hr = m_pElement2->get_runtimeStyle(&pStyle);
	if (FAILED(hr))
	{
		::SysFreeString(bstrVal);
		return hr;
	}

	// Set the visibility on it
	hr = pStyle->put_display(bstrVal);
	ReleaseInterface(pStyle);
	::SysFreeString(bstrVal);
	if (FAILED(hr))
		return hr;

	return S_OK;
}



HRESULT
CActorBvr::CFloatManager::widthCallback(void *thisPtr,
										long id,
										double startTime,
										double globalNow,
										double localNow,
										IDABehavior * sampleVal,
										IDABehavior **ppReturn)
{
	IDANumber *pNumber = NULL;
	HRESULT hr = sampleVal->QueryInterface(IID_TO_PPV(IDANumber, &pNumber));
	if (FAILED(hr))
		return hr;

	double val = 0;
	hr = pNumber->Extract(&val);
	ReleaseInterface(pNumber);
	if (FAILED(hr))
		return hr;

	CFloatManager *pManager = (CFloatManager*)thisPtr;

	if (val != pManager->m_currWidth)
	{
		pManager->m_currWidth = val;

		pManager->UpdateElementRect();
	}

	return S_OK;
}
 
HRESULT
CActorBvr::CFloatManager::heightCallback(void *thisPtr,
										long id,
										double startTime,
										double globalNow,
										double localNow,
										IDABehavior * sampleVal,
										IDABehavior **ppReturn)
{
	IDANumber *pNumber = NULL;
	HRESULT hr = sampleVal->QueryInterface(IID_TO_PPV(IDANumber, &pNumber));
	if (FAILED(hr))
		return hr;

	double val = 0;
	hr = pNumber->Extract(&val);
	ReleaseInterface(pNumber);
	if (FAILED(hr))
		return hr;

	CFloatManager *pManager = (CFloatManager*)thisPtr;

	if (val != pManager->m_currHeight)
	{
		pManager->m_currHeight = val;

		pManager->UpdateElementRect();
	}

	return S_OK;
}

//*****************************************************************************
//
// class CImageInfo
//
//*****************************************************************************

CActorBvr::CImageInfo::CImageInfo( IDA2Image* pdaimg2Cropped, 
								   IDA2Behavior* pdabvrSwitchable )
:	m_pdaimg2Cropped( pdaimg2Cropped ),
	m_pdabvr2Switchable( pdabvrSwitchable ),
	m_pNext( NULL )
{
	m_pdaimg2Cropped->AddRef();
	m_pdabvr2Switchable->AddRef();
}

//*****************************************************************************

CActorBvr::CImageInfo::~CImageInfo()
{
	ReleaseInterface( m_pdaimg2Cropped );
	ReleaseInterface( m_pdabvr2Switchable );
}


//*****************************************************************************
//
// class CFinalDimensionSampler
//
//*****************************************************************************
CActorBvr::CFinalDimensionSampler::CFinalDimensionSampler( CActorBvr* pParent )
:
m_pActor( pParent ),
m_pFinalWidthSampler( NULL ),
m_pFinalHeightSampler( NULL ),
m_lFinalWidthId(-1),
m_lFinalHeightId(-1),
m_fFinalWidthSampled( false ),
m_fFinalHeightSampled( false ),
m_dLastFinalWidthValue( -1.0 ),
m_dLastFinalHeightValue( -1.0 ),
m_fFinalDimensionChanged( true ),
m_lWidthCookie(0),
m_lHeightCookie(0)
{
	DASSERT(pParent != NULL );
}

//*****************************************************************************

CActorBvr::CFinalDimensionSampler::~CFinalDimensionSampler( )
{	
	Detach();
}

//*****************************************************************************

HRESULT
CActorBvr::CFinalDimensionSampler::Attach( IDANumber* pFinalWidth, IDANumber* pFinalHeight )
{

	if( pFinalWidth == NULL || pFinalHeight == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;
	IDABehavior *pbvrHooked = NULL;

	//hook the final width behavior
	m_pFinalWidthSampler = new CSampler( FinalWidthCallback, reinterpret_cast<void*>(this) );
	if( m_pFinalWidthSampler == NULL )
	{
		hr = E_OUTOFMEMORY;
		goto cleanup;
	}

	hr = m_pFinalWidthSampler->Attach( pFinalWidth, &pbvrHooked );
	CheckHR( hr, "Failed to hook the final width", cleanup );

	hr = m_pActor->AddBehaviorToTIME( pbvrHooked, &m_lWidthCookie );
	ReleaseInterface( pbvrHooked );
	CheckHR( hr, "Failed to add hooked final width behaivor to time", cleanup );

	//hook the final height behavior

	m_pFinalHeightSampler = new CSampler( FinalHeightCallback, reinterpret_cast<void*>(this) );
	if( m_pFinalHeightSampler == NULL )
	{
		hr = E_OUTOFMEMORY;
		goto cleanup;
	}

	hr = m_pFinalHeightSampler->Attach( pFinalHeight, &pbvrHooked );
	CheckHR( hr, "Failed to hook the final Height", cleanup );

	hr = m_pActor->AddBehaviorToTIME( pbvrHooked, &m_lHeightCookie );
	ReleaseInterface( pbvrHooked );
	CheckHR( hr, "Failed to add hooked final Height behaivor to time", cleanup );

cleanup:
	if( FAILED( hr ) )
	{
		Detach();
	}

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CFinalDimensionSampler::Detach()
{
	m_lFinalWidthId = -1;
	m_lFinalHeightId = -1;
	if( m_pFinalWidthSampler != NULL )
	{
		m_pFinalWidthSampler->Invalidate();
		m_pFinalWidthSampler = NULL;
	}

	if( m_pFinalHeightSampler != NULL )
	{
		m_pFinalHeightSampler->Invalidate();
		m_pFinalHeightSampler = NULL;
	}
	
	return S_OK;
}

//*****************************************************************************


HRESULT
CActorBvr::CFinalDimensionSampler::CollectFinalDimensionSamples( )
{
	if( m_fFinalWidthSampled && m_fFinalHeightSampled )
	{
		m_fFinalWidthSampled = false;
		m_fFinalHeightSampled = false;
		if( m_fFinalDimensionChanged )
		{
			m_fFinalDimensionChanged = false;
			return m_pActor->SetRenderResolution( m_dLastFinalWidthValue, m_dLastFinalHeightValue );
		}
	}

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::CFinalDimensionSampler::FinalWidthCallback(void *thisPtr,
							  long id,
   						      double startTime,
						      double globalNow,
						      double localNow,
						      IDABehavior * sampleVal,
						      IDABehavior **ppReturn)
{
	if( thisPtr == NULL || sampleVal == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	//cast the this pointer
	CFinalDimensionSampler *pThis = reinterpret_cast<CFinalDimensionSampler*>(thisPtr);

	bool fFirstSample = false;

	if( pThis->m_lFinalWidthId == -1 )
	{
		pThis->m_lFinalWidthId = id;
		fFirstSample = true;
	}

	if( pThis->m_lFinalWidthId != id )
		return S_OK;

	//extract the current value from the sample
	IDANumber *pdanumCurrVal = NULL;
	hr = sampleVal->QueryInterface( IID_TO_PPV( IDANumber, &pdanumCurrVal ) );
	CheckHR( hr, "Failed to QI the sample val for IDANubmer", cleanup );

	double currVal;
	hr = pdanumCurrVal->Extract(&currVal);
	ReleaseInterface( pdanumCurrVal );
	CheckHR( hr, "Failed to extract the current value from the sampled behavior", cleanup );

	//if the value has changed mark for update
	if( pThis->m_dLastFinalWidthValue != currVal || fFirstSample )
	{
		pThis->m_dLastFinalWidthValue = currVal;
		pThis->m_fFinalDimensionChanged = true;

	}

	pThis->m_fFinalWidthSampled = true;

	//collect samples
	pThis->CollectFinalDimensionSamples();

cleanup:
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CFinalDimensionSampler::FinalHeightCallback(void *thisPtr,
					long id,
					double startTime,
					double globalNow,
					double localNow,
					IDABehavior * sampleVal,
					IDABehavior **ppReturn)
{
	if( thisPtr == NULL || sampleVal == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	//cast the this pointer
	CFinalDimensionSampler *pThis = reinterpret_cast<CFinalDimensionSampler*>(thisPtr);

	bool fFirstSample = false;

	if( pThis->m_lFinalHeightId == -1 )
	{
		pThis->m_lFinalHeightId = id;
		fFirstSample = true;
	}

	if( pThis->m_lFinalHeightId != id )
		return S_OK;

	//extract the current value from the sample
	IDANumber *pdanumCurrVal = NULL;
	hr = sampleVal->QueryInterface( IID_TO_PPV( IDANumber, &pdanumCurrVal ) );
	CheckHR( hr, "Failed to QI the sample val for IDANubmer", cleanup );

	double currVal;
	hr = pdanumCurrVal->Extract(&currVal);
	ReleaseInterface( pdanumCurrVal );
	CheckHR( hr, "Failed to extract the current value from the sampled behavior", cleanup );

	//if the value has changed mark for update
	if( pThis->m_dLastFinalHeightValue != currVal || fFirstSample )
	{
		pThis->m_dLastFinalHeightValue = currVal;
		pThis->m_fFinalDimensionChanged = true;

	}

	//set the last sample time
	pThis->m_fFinalHeightSampled = true;

	//collect samples
	pThis->CollectFinalDimensionSamples();

cleanup:
	return hr;
}


//*****************************************************************************
//
// class CCookieData
//
//*****************************************************************************

CActorBvr::CCookieMap::CCookieData::CCookieData( long lCookie, CBvrTrack *pTrack, ActorBvrFlags eFlags ):
	m_pNext( NULL ),
	m_lCookie( lCookie ),
	m_pTrack( pTrack ),
	m_eFlags( eFlags )
{
}


//*****************************************************************************
//
// class CCookieMap
//
//*****************************************************************************


CActorBvr::CCookieMap::CCookieMap():
	m_pHead(NULL)
{
}

//*****************************************************************************

CActorBvr::CCookieMap::~CCookieMap()
{
	Clear();
}

//*****************************************************************************

void
CActorBvr::CCookieMap::Insert( long lCookie, CActorBvr::CBvrTrack *pTrack, ActorBvrFlags eFlags )
{

	CCookieData *pNew = new CCookieData( lCookie, pTrack, eFlags );
	if( pNew == NULL )
	{
		DPF_ERR("Failed to build a cookie data.  Out of memory" );
		return;
	}

	//if the list is empty insert at the top.
	if( m_pHead == NULL )
	{
		m_pHead = pNew;
		pNew->m_pNext = NULL;
		return;
	}

	CCookieData *pCurrent = m_pHead;
	CCookieData *pPrev = NULL;

	//look for the first cookieData that has a cookie >= the
	//  cookie to be inserted.
	while( pCurrent != NULL && pCurrent->m_lCookie < lCookie )
	{
		pPrev = pCurrent;
		pCurrent = pCurrent->m_pNext;
	}

	//if we are inserting after the beginning of the list
	if( pPrev != NULL )
	{
		pNew->m_pNext = pCurrent;
		pPrev->m_pNext = pNew;
	}
	else // insert at the top
	{
		pNew->m_pNext = m_pHead;
		m_pHead = pNew;
	}
}

//*****************************************************************************

void
CActorBvr::CCookieMap::Remove( long lCookie )
{
	if( m_pHead == NULL )
	{
		return;
	}

	CCookieData *pCurrent = m_pHead;
	CCookieData *pPrev = NULL;

	//find the data in the map
	while( pCurrent != NULL && pCurrent->m_lCookie != lCookie )
	{
		pPrev = pCurrent;
		pCurrent = pCurrent->m_pNext;
	}

	if( pCurrent == NULL )
	{
		//we failed to find the cookie
		return;
	}

	//remove it
	//found a match in the list
	if( pPrev != NULL )
	{
		pPrev->m_pNext = pCurrent->m_pNext;
	}
	else //found a match at the top
	{
		m_pHead = pCurrent->m_pNext;
	}

	pCurrent->m_pNext = NULL;
	delete pCurrent;
}

//*****************************************************************************

void
CActorBvr::CCookieMap::Clear()
{
	CCookieData *pCurrent = m_pHead;
	CCookieData *pNext = NULL;

	while( pCurrent != NULL )
	{
		pNext = pCurrent->m_pNext;
		pCurrent->m_pNext = NULL;
		delete pCurrent;
		pCurrent = pNext;
	}

	m_pHead = NULL;

}
//*****************************************************************************

CActorBvr::CCookieMap::CCookieData*
CActorBvr::CCookieMap::GetDataFor( long lCookie )
{
	CCookieData *pCurrent = m_pHead;

	//find the data with the right cookie
	while( pCurrent != NULL && pCurrent->m_lCookie != lCookie )
	{
		pCurrent = pCurrent->m_pNext;
	}

	return pCurrent;

}

//*****************************************************************************
//
// The Actor Behavior Class
//
// The intermediary between "real" behaviors and the actual element being
// animated.
// The Actor performs in a number of ways:
// *   Adds new properties to an HTML element that we wish were
//     just part of the element (like static rotation and scale).
// *   Abstracts away the necessary action code from the behavior
//     and underlying element (specifically rotating a VML element
//     is easy, rotating and HTML element is hard). The actor does
//     the mapping so the behavior doesn't have to worry about it.
// *   Disambiguates overlapping behaviors (either just letting one
//     win or composing them).
// See the file header for a description of the actor behavior
//
//*****************************************************************************

CActorBvr::CActorBvr()
:   m_ptrackHead(NULL),
    m_pScale(NULL),
    m_pRotate(NULL),
    m_pTranslate(NULL),
    m_pOrigLeftTop(NULL),
    m_pOrigWidthHeight(NULL),
	m_pBoundsMin(NULL),
	m_pBoundsMax(NULL),
	m_pPixelWidth(NULL),
	m_pPixelHeight(NULL),
    m_pTransformCenter(NULL),
	m_pElementImage(NULL),
	m_pElementFilter(NULL),
	m_pFloatManager(NULL),
	m_pRuntimeStyle(NULL),
	m_pStyle(NULL),
	m_pVMLRuntimeStyle(NULL),
	m_dwAdviseCookie(0),
	m_pImageInfoListHead(NULL),
	m_pdanumFinalElementWidth(NULL),
	m_pdanumFinalElementHeight(NULL),
	m_pFinalElementDimensionSampler(NULL),
	m_bEditMode(false),
	m_simulDispNone(false),
	m_simulVisHidden(false),
	m_pBodyElement(NULL),
	m_pBodyPropertyMonitor( NULL ),
	m_bPendingRebuildsUpdating( false ),
	m_bRebuildListLockout( false ),
    m_nextFragmentCookie( 1 ),
    m_ptrackTop( NULL ),
    m_ptrackLeft( NULL ),
    m_dwCurrentState( 0 ),
    m_pOnResizeHandler( NULL ),
    m_pOnUnloadHandler( NULL ),
    m_fUnloading( false ),
	m_fVisSimFailed( false ),
	m_pcpCurrentStyle( NULL )
{
	VariantInit(&m_varAnimates);
    VariantInit(&m_varScale);
	VariantInit(&m_varPixelScale);
	m_clsid = CLSID_CrActorBvr;

	m_pEventManager = new CEventMgr( this );
} // CActorBvr

//*****************************************************************************

CActorBvr::~CActorBvr()
{
	VariantClear(&m_varAnimates);
    VariantClear(&m_varScale);
	VariantClear(&m_varPixelScale);

	ReleaseTracks();

	ReleaseInterface( m_pdanumFinalElementWidth );
	ReleaseInterface( m_pdanumFinalElementHeight );

	ReleaseInterface(m_pScale);
	ReleaseInterface(m_pRotate);
	ReleaseInterface(m_pTranslate);
    ReleaseInterface(m_pTransformCenter);
	ReleaseInterface(m_pElementImage);
	ReleaseInterface(m_pOrigLeftTop);
	ReleaseInterface(m_pOrigWidthHeight);
	ReleaseInterface(m_pPixelWidth);
	ReleaseInterface(m_pPixelHeight);
	ReleaseInterface(m_pBoundsMin);
	ReleaseInterface(m_pBoundsMax);

	ReleaseInterface(m_pStyle);
	ReleaseInterface(m_pRuntimeStyle);
	ReleaseInterface(m_pVMLRuntimeStyle);


	ReleaseInterface(m_pBodyElement);

	ReleaseFinalElementDimensionSampler();

	// TODO: Should probably remove these filters
	ReleaseInterface(m_pElementFilter);

	ReleaseFloatManager();

	ReleaseImageInfo();

    DiscardBvrCache();

	ReleaseEventManager();

	ReleaseRebuildLists();

	DestroyBodyPropertyMonitor();

} // ~CActorBvr

//*****************************************************************************

VARIANT *
CActorBvr::VariantFromIndex(ULONG iIndex)
{
    DASSERT(iIndex < NUM_ACTOR_PROPS);
    switch (iIndex)
    {
    case VAR_ANIMATES:
        return &m_varAnimates;
        break;
    case VAR_SCALE:
        return &m_varScale;
        break;
    case VAR_PIXELSCALE:
        return &m_varPixelScale;
        break;
    default:
        // We should never get here
        DASSERT(false);
        return NULL;
    }
} // VariantFromIndex

//*****************************************************************************

HRESULT 
CActorBvr::GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropNames)
{
    *pulProperties = NUM_ACTOR_PROPS;
    *pppPropNames = m_rgPropNames;
    return S_OK;
} // GetPropertyBagInfo

//*****************************************************************************

HRESULT
CActorBvr::FinalConstruct()
{
    return SUPER::FinalConstruct();
} // FinalConstruct

//*****************************************************************************

STDMETHODIMP 
CActorBvr::Init(IElementBehaviorSite *pBehaviorSite)
{
	
	LMTRACE2( 1, 1000, L"Begin Init of ActorBvr <%p>\n", this );

	HRESULT hr = SUPER::Init( pBehaviorSite );
	CheckHR( hr, "Initialization of super class of actor failed", end );
	
	hr = m_pEventManager->Init();
	CheckHR( hr, "Failed to initialize event Manager", end );

	
	if( SUCCEEDED( hr ) )
	{
		// Are we in edit mode?
		m_bEditMode = IsDocumentInEditMode();

		// Simulate visibility/display changes if in edit mode
		if (m_bEditMode)
		{
			InitVisibilityDisplay();

			//register for the context change event
			hr = pBehaviorSite->RegisterNotification(BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE);
			CheckHR( hr, "Failed to register for the context change event", end );

		}

		// Initialize property sink (used to observe property changes on element)
		InitPropertySink();
	}

	LMTRACE2( 1, 1000, L"End Init of ActorBvr <%p>\n", this );
	
	end:

	return hr;

} // Init

//*****************************************************************************

STDMETHODIMP 
CActorBvr::Notify(LONG event, VARIANT *pVar)
{
	HRESULT hr = SUPER::Notify(event, pVar);
	CheckHR( hr, "Notify in base class failed", end);

	switch( event )
	{
	case BEHAVIOREVENT_CONTENTREADY:
		{
			LMTRACE2(1, 1000,  L"Actor<%p> Got Content Ready\n", this);

			//start listening to events on the animated element.
			//we wait until here to do this so that we are guarenteed that the properties have
			//  been read from the element ( we need the animates property )
			
			hr = AttachEvents();
			CheckHR( hr, "Failed to attach to events on the animated element", end );
			
			
			hr = UpdateCurrentState( );			
			CheckHR( hr, "Failed to update the current actor state", end );
		}break;	
	case BEHAVIOREVENT_DOCUMENTREADY:
		{
			LMTRACE2(1, 1000, L"Actor<%p> Got Document Ready\n", this);
						
			hr = UpdateCurrentState( );			
			CheckHR( hr, "Failed to update the current actor state", end );
		}break;
	case BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE:
		{
			LMTRACE2( 1, 2, "Got document context change\n" );

			IHTMLElement *pelemParent = NULL;

			hr = GetHTMLElement()->get_parentElement( &pelemParent );
			CheckHR( hr, "Failed to get the parent element", ccEnd );

			//if the parent of this element is null
			if( pelemParent == NULL )
			{
				// then we are being moved out of the document
				// set all the properties that we are animating back to their static values
				//this causes much badness.
				//applyStatics();
			}
			else//else we are being moved either to a different position in the document, or back into the document
			{
				//remove the filter from the element and rebuild the image track.
				hr = RemoveElementFilter();
				CheckHR( hr, "Failed to remove the element filter", ccEnd );

				ApplyImageTracks();
				CheckHR( hr, "Failed to apply the image tracks", ccEnd );

			}
		ccEnd:
			ReleaseInterface( pelemParent );
			if( FAILED( hr ) )
				goto end;
				
		}break;
	}

end:
	
	return hr;

} // Notify

//*****************************************************************************

STDMETHODIMP
CActorBvr::Detach()
{

	LMTRACE2( 1, 2, L"Detaching ActorBvr. <%p>\n", this );
	HRESULT hr = S_OK;

	// If we have a connection point detach it.  Need to do this before super.detach because it uses
	// the HTML element.
	UnInitPropertySink();

	DetachEvents();


	hr = m_pEventManager->Deinit();
	if( FAILED( hr ) )
	{
		DPF_ERR( "failed to detach the event manager" );
	}

	// If we have filters, set their elements to NULL
	if (m_pElementFilter != NULL)
		SetElementOnFilter(m_pElementFilter, NULL);

	if (m_pFloatManager != NULL)
		m_pFloatManager->Detach();

	if( m_pFinalElementDimensionSampler != NULL )
	{
		delete m_pFinalElementDimensionSampler;
		m_pFinalElementDimensionSampler = NULL;
	}

	DestroyBodyPropertyMonitor();

	ReleaseRebuildLists();

	ReleaseAnimation();

	ReleaseInterface(m_pBodyElement);

	//remove the filter from the element
	hr = RemoveElementFilter();
	if( FAILED( hr ) )
	{
		DPF_ERR("Failed to remove the element filter" );
	}

	hr = SUPER::Detach();
	if( FAILED( hr ) )
	{
		DPF_ERR("failed to detach the superclass");
	}

	ReleaseInterface( m_pcpCurrentStyle );
	ReleaseInterface(m_pStyle);
	ReleaseInterface(m_pRuntimeStyle);
	ReleaseInterface(m_pVMLRuntimeStyle);


	LMTRACE2( 1, 2, L"End detach ActorBvr <%p>\n", this );

	return hr;
} // Detach 

//*****************************************************************************

/**
* Initializes a property sink on the current style of the animated element so that
* can observe changes in width, height, visibility, zIndex, etc.
*/
HRESULT
CActorBvr::InitPropertySink()
{
	HRESULT hr = S_OK;

	// Get connection point
	IConnectionPoint *pConnection = NULL;
	hr = GetCurrStyleNotifyConnection(&pConnection);
	if (FAILED(hr))
		return hr;

	// Advise on it
	hr = pConnection->Advise(GetUnknown(), &m_dwAdviseCookie);
	ReleaseInterface(pConnection);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::UnInitPropertySink()
{
	HRESULT hr = S_OK;

	if (m_dwAdviseCookie == 0)
		return S_OK;

	// Get connection point
	IConnectionPoint *pConnection = NULL;
	hr = GetCurrStyleNotifyConnection(&pConnection);
	if (FAILED(hr) || pConnection == NULL )
		return hr;

	// Unadvise on it
	hr = pConnection->Unadvise(m_dwAdviseCookie);
	ReleaseInterface(pConnection);
	if (FAILED(hr))
		return hr;

	m_dwAdviseCookie = 0;

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::GetCurrStyleNotifyConnection(IConnectionPoint **ppConnection)
{
	HRESULT hr = S_OK;

	DASSERT(ppConnection != NULL);
	*ppConnection = NULL;

	if( m_pcpCurrentStyle == NULL )
	{
		IConnectionPointContainer *pContainer = NULL;
		IHTMLElement *pElement = NULL;

		// Get animated element
		hr = GetAnimatedElement(&pElement);
		CheckHR( hr, "Failed to get he animated element", getConPtend );
		CheckPtr( pElement, hr, E_POINTER, "Failed to get the animated element", getConPtend );
		
		// Get connection point container
		hr = pElement->QueryInterface(IID_TO_PPV(IConnectionPointContainer, &pContainer));
		CheckHR( hr, "QI for IConnectionPointContainer on the animated element failed", getConPtend );
		
		// Find the IPropertyNotifySink connection
		hr = pContainer->FindConnectionPoint(IID_IPropertyNotifySink, &m_pcpCurrentStyle);
		CheckHR( hr, "Failed to find a connection point IID_IPropertyNotifySink", getConPtend );

	getConPtend:
		ReleaseInterface( pElement );
		ReleaseInterface( pContainer );
		if( FAILED( hr ) )
			goto end;
	}
	
	(*ppConnection) = m_pcpCurrentStyle;
	(*ppConnection)->AddRef();

end:

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::InitPixelWidthHeight()
{
	HRESULT hr = S_OK;

	// Get the pixel width and height
	IHTMLElement *pElement = NULL;
	hr = GetAnimatedElement(&pElement);
	if (FAILED(hr))
		return hr;

	hr = pElement->get_offsetWidth(&m_pixelWidth);
	if (FAILED(hr))
	{
		ReleaseInterface(pElement);
		return hr;
	}

	hr = pElement->get_offsetHeight(&m_pixelHeight);
	if (FAILED(hr))
	{
		ReleaseInterface(pElement);
		return hr;
	}

	hr = pElement->get_offsetLeft(&m_pixelLeft);
	if (FAILED(hr))
	{
		ReleaseInterface(pElement);
		return hr;
	}

	hr = pElement->get_offsetTop(&m_pixelTop);
	ReleaseInterface(pElement);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

bool
CActorBvr::IsDocumentInEditMode()
{
    HRESULT hr;
    bool result = false;
    BSTR bstrMode = NULL;
    IDispatch *pDisp = NULL;
    IHTMLDocument2 *pDoc = NULL;
    IHTMLElement *pElem = GetHTMLElement();

	if (pElem == NULL)
		goto done;

    hr = pElem->get_document(&pDisp);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pDisp->QueryInterface(IID_TO_PPV(IHTMLDocument2, &pDoc));
    ReleaseInterface(pDisp);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pDoc->get_designMode(&bstrMode);
    ReleaseInterface(pDoc);
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (wcsicmp(bstrMode, L"On") == 0)
    {
        result = true;
    }

    SysFreeString(bstrMode);

done:
    return result;
}

HRESULT
CActorBvr::GetBodyElement(IDispatch **ppResult)
{
	HRESULT hr = S_OK;

	if (m_pBodyElement == NULL)
	{
		IDispatch *pDocDispatch = NULL;
		IHTMLDocument2 *pDocument = NULL;
		IHTMLElement *pBody = NULL;

		hr = GetHTMLElement()->get_document(&pDocDispatch);
		CheckHR(hr, "Failed to get document", done);
		CheckPtr( pDocDispatch, hr, E_POINTER, "Got a null document from crappy trident", done );

		hr = pDocDispatch->QueryInterface(IID_TO_PPV(IHTMLDocument2, &pDocument));
		CheckHR(hr, "Failed to get IDispatch from doc", done);

		hr = pDocument->get_body(&pBody);
		CheckHR(hr, "Failed to get body element", done);
		CheckPtr( pBody, hr, E_POINTER, "Got a null pointer from crappy trident", done );

		hr = pBody->QueryInterface(IID_TO_PPV(IDispatch, &m_pBodyElement));
		CheckHR(hr, "Failed to get IDispatch from body", done);

done:
		ReleaseInterface(pDocDispatch);
		ReleaseInterface(pDocument);
		ReleaseInterface(pBody);
	}

	if (m_pBodyElement != NULL)
	{
		*ppResult = m_pBodyElement;
		m_pBodyElement->AddRef();
	}

	return hr;
}

HRESULT
CActorBvr::GetParentWindow( IHTMLWindow2 **ppWindow )
{
	if( ppWindow == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	IDispatch *pdispDoc = NULL;
	IHTMLDocument2 *pdoc2Doc = NULL;
	IHTMLElement *pelemParent = NULL;

	hr = GetHTMLElement()->get_parentElement( &pelemParent );
	CheckHR( hr, "Failed to get the parent element", end );
	CheckPtr( pelemParent, hr, E_FAIL, "The parent element of the element was null: can't get the window or trident will crash", end );

	hr = GetHTMLElement()->get_document( &pdispDoc );
	CheckHR( hr, "Failed to get the document", end );
	CheckPtr( pdispDoc, hr, E_POINTER, "got a null document", end );

	hr = pdispDoc->QueryInterface( IID_TO_PPV( IHTMLDocument2, &pdoc2Doc ) );
	CheckHR( hr, "Failed to get doc2 from the doc disp", end );

	hr = pdoc2Doc->get_parentWindow( ppWindow );
	CheckHR( hr, "Failed to get the parent window", end );
	CheckPtr( (*ppWindow), hr, E_POINTER, "Got a null parent window pointer", end );

end:
	ReleaseInterface( pdispDoc );
	ReleaseInterface( pdoc2Doc );
	ReleaseInterface( pelemParent );

	return hr;
}

double
CActorBvr::MapGlobalTime(double gTime)
{
	if (!m_bEditMode)
		return gTime;

	HRESULT hr = S_OK;
	double result = -1;

	VARIANT varResult;
	VariantInit(&varResult);
	IDispatch *pBodyElement = NULL;

	hr = GetBodyElement(&pBodyElement);
	CheckHR(hr, "Failed to get body element", done);


	hr = GetPropertyOnDispatch(pBodyElement, L"localTime", &varResult);
	CheckHR(hr, "Failed to get local time", done);

	hr = VariantChangeTypeEx(&varResult, &varResult, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R4);
	CheckHR(hr, "Failed to change type to R4", done);

	result = varResult.fltVal;

done:
	ReleaseInterface(pBodyElement);
	VariantClear(&varResult);

	return result;
}


HRESULT
CActorBvr::GetCurrentStyle(IHTMLCurrentStyle **ppResult)
{
	HRESULT hr = S_OK;

	DASSERT(ppResult != NULL);
	*ppResult = NULL;

	IHTMLElement *pElement = NULL;
	IHTMLElement2 *pElement2 = NULL;

	hr = GetAnimatedElement(&pElement);
	CheckHR(hr, "Failed to get animated element", done);
	CheckPtr( pElement, hr, E_POINTER, "Got a null animated element", done );

	hr = pElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElement2));
	CheckHR(hr, "Failed to get IHTMLElement2", done);

	hr = pElement2->get_currentStyle(ppResult);
	CheckHR(hr, "Failed to get current style", done);
	CheckPtr( (*ppResult), hr, E_POINTER, "Got a null currentStyle from Trident", done );

done:
	ReleaseInterface(pElement);
	ReleaseInterface(pElement2);

	return hr;
}

HRESULT
CActorBvr::InitVisibilityDisplay()
{
	HRESULT hr = S_OK;
	
	hr = UpdateDesiredPosition();
	CheckHR( hr, "Failed to update the preferred Position", done );

	hr = UpdateVisibilityDisplay();
	CheckHR( hr, "Failed to update the visibility and display", done );

done:
	return hr;
}

HRESULT
CActorBvr::UpdateDesiredPosition()
{
	HRESULT hr = S_OK;

	IHTMLStyle *pstyleInline = NULL;

	IHTMLStyle *pstyleRuntime = NULL;
	IHTMLStyle2 *pstyle2Runtime = NULL;

	BSTR bstrPosition = NULL;

	BSTR position = NULL;

	PositioningType oldDesiredPosType = m_desiredPosType;

	//TODO: what about positioning applied using class=?
	hr = GetStyle( &pstyleInline );
	CheckHR( hr, "Failed to get the inline style", end );

	hr = pstyleInline->get_position(&position);
	CheckHR(hr, "Failed to get position string", end);

	if (position != NULL)
	{
		if (wcsicmp(position, L"absolute") == 0)
		{
			LMTRACE2( 1,2, "Desired Position is Absolute\n" );
			m_currPosType = e_posAbsolute;
		}
		else if (wcsicmp(position, L"relative") == 0)
		{
			LMTRACE2( 1, 2, "Desired Position is Relative\n" );
			m_currPosType = e_posRelative;
		}
		else
		{
			LMTRACE2( 1, 2, "Desired Position is Static\n" );
			m_currPosType = e_posStatic;
		}

		::SysFreeString(position);
	}
	else
		m_currPosType = e_posStatic;

	m_desiredPosType = m_currPosType;

	if( m_desiredPosType != oldDesiredPosType )
	{		
		//if we are not simulating display and we are simulating visibility
		if( !m_simulDispNone && m_simulVisHidden )
		{
			hr = GetRuntimeStyle(&pstyleRuntime);
			CheckHR(hr, "Failed to get runtime style", end);
			CheckPtr( pstyleRuntime, hr, E_POINTER, "Trident gave us a null pointer for runtimeStyle", end );

			hr = pstyleRuntime->QueryInterface(IID_TO_PPV(IHTMLStyle2, &pstyle2Runtime));
			CheckHR(hr, "Failed to get IHTMLStyle2", end);
			
			if( ( oldDesiredPosType == e_posStatic || 
				  oldDesiredPosType == e_posRelative ) &&
				m_desiredPosType == e_posAbsolute )
			{
				//set the element absolute
				bstrPosition = SysAllocString( L"absolute" );
				CheckPtr( bstrPosition, hr, E_OUTOFMEMORY, "Ran out of memory trying to create a string", end );

				hr= pstyle2Runtime->put_position( bstrPosition );

				SysFreeString( bstrPosition );
				bstrPosition = NULL;
				
				CheckHR( hr, "Failed to set the position on the runtimStyle", end );
				
			}
			else if( oldDesiredPosType == e_posAbsolute && 
					 ( m_desiredPosType == e_posRelative || 
					   m_desiredPosType == e_posStatic ) 
				   )
			{
				//set the element relative
				bstrPosition = SysAllocString( L"relative" );
				CheckPtr( bstrPosition, hr, E_OUTOFMEMORY, "Ran out of memory trying to create a string", end );

				hr= pstyle2Runtime->put_position( bstrPosition );

				SysFreeString( bstrPosition );
				bstrPosition = NULL;
				
				CheckHR( hr, "Failed to set the position on the runtimeStyle", end );

			}
		}
	}

end:
	ReleaseInterface( pstyleInline );
	ReleaseInterface( pstyleRuntime );
	ReleaseInterface( pstyle2Runtime );

	return hr;

}

HRESULT
CActorBvr::UpdateVisibilityDisplay()
{
	HRESULT hr = S_OK;

	IHTMLCurrentStyle *pCurrStyle = NULL;
	IHTMLStyle *pRuntimeStyle = NULL;
	IHTMLStyle2 *pRuntimeStyle2 = NULL;

	bool visHidden = false;
	bool dispNone = false;
	bool restoreAll = false;
	bool setOffscreen = false;
	bool setAbsolute = false;
	bool setRelative = false;

	BSTR val = NULL;

	hr = GetCurrentStyle(&pCurrStyle);
	CheckHR(hr, "Failed to get current style", done);

	hr = pCurrStyle->get_visibility(&val);
	CheckHR(hr, "Failed to get visibility value", done);

	if (val != NULL)
	{
		visHidden = (wcsicmp(val, L"hidden") == 0);

		::SysFreeString(val);
	}

	hr = pCurrStyle->get_display(&val);
	CheckHR(hr, "Failed to get display value", done);

	if (val != NULL)
	{
		dispNone = (wcsicmp(val, L"none") == 0);

		::SysFreeString(val);
	}

#ifdef _DEBUG
	if (visHidden)
		::OutputDebugString("visibility: hidden   ");
	else
		::OutputDebugString("visibility: normal   ");

	if (dispNone)
		::OutputDebugString("display:none\n");
	else
		::OutputDebugString("display:normal\n");
#endif

	if (dispNone != m_simulDispNone)
	{
		// Display value differs from what we are simulating
		if (dispNone)
		{
			// Need to start simulating display:none
			setOffscreen = setAbsolute = true;
		}
		else
		{
			// Need to stop simulating display:none
			if (m_simulVisHidden)
			{
				// Still simulating visibility, if this element is not supposed to
				// be absolute then request a set back to relative
				if (m_desiredPosType != e_posAbsolute)
					setRelative = true;
			}
			else
			{
				// Not simulating visibility, restore everything
				restoreAll = true;
			}
		}

		m_simulDispNone = dispNone;
	}
	
	if (visHidden != m_simulVisHidden)
	{
		// Visibility value differs from what we are simulating
		if (visHidden)
		{
			// Need to start simulating visibility:hidden
			setOffscreen = true;

			// Cannot force to relative if this element should be absolute
			if (m_desiredPosType == e_posAbsolute)
				setAbsolute = true;
			else
				setRelative = true;
		}
		else
		{
			// Need to stop simulating visibility:hidden
			if (!m_simulDispNone)
			{
				// Not simulating display, restore everything
				restoreAll = true;
			}
		}

		m_simulVisHidden = visHidden;
	}
			

	if (restoreAll || setOffscreen || setAbsolute || setRelative)
	{
		// Need to do something

		hr = GetRuntimeStyle(&pRuntimeStyle);
		CheckHR(hr, "Failed to get runtime style", done);

		hr = pRuntimeStyle->QueryInterface(IID_TO_PPV(IHTMLStyle2, &pRuntimeStyle2));
		CheckHR(hr, "Failed to get IHTMLStyle2", done);

		VARIANT var;
		VariantInit(&var);

		if (setOffscreen)
		{
			VisSimSetOffscreen( pRuntimeStyle, true );
		}
		
		if (setAbsolute)
		{
			// Set position to absolute
			BSTR bstr = ::SysAllocString(L"absolute");
			if (bstr == NULL)
			{
				hr = E_FAIL;
				goto done;
			}

			pRuntimeStyle2->put_position(bstr);
			::SysFreeString(bstr);

//			m_currPosType = e_posAbsolute;
		}

		if (setRelative)
		{
			BSTR bstrOldPos = NULL;

			// Set position to relative
			BSTR bstr = ::SysAllocString(L"relative");
			if (bstr == NULL)
			{
				hr = E_FAIL;
				goto done;
			}

			pRuntimeStyle2->put_position(bstr);

			::SysFreeString(bstr);

//			m_currPosType = e_posRelative;
		}




		
		if (restoreAll)
		{
			
			VARIANT var;
			VariantInit(&var);
			V_VT(&var) = VT_BSTR;
			V_BSTR(&var) = ::SysAllocString(L"");

			hr = pRuntimeStyle2->put_position(V_BSTR(&var));
			
			if( CheckBitNotSet( m_dwCurrentState, ELEM_IS_VML) )
			{
				hr = pRuntimeStyle->put_top(var);
				hr = pRuntimeStyle->put_left(var);
			}
			else
			{
				//clear out the vgx runtime style.
				hr = SetVMLAttribute( L"top", &var );
				hr = SetVMLAttribute( L"left", &var );
			}

			VariantClear(&var);

			//allow the top and left track to change top and left again
			if( m_ptrackLeft != NULL )
				m_ptrackLeft->ReleaseChangeLockout();
			if( m_ptrackTop != NULL )
				m_ptrackTop->ReleaseChangeLockout();

		}
		
		
	}

done:
	ReleaseInterface(pCurrStyle);
	ReleaseInterface(pRuntimeStyle);
	ReleaseInterface(pRuntimeStyle2);

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::VisSimSetOffscreen( IHTMLStyle *pRuntimeStyle, bool fResample )
{
	HRESULT hr = S_OK;
	
	VARIANT var;
	VariantInit(&var);

	IHTMLElement 	*pelemAnimated = NULL;

	hr = GetAnimatedElement( &pelemAnimated );
	CheckHR( hr, "Failed to get the animated element", done );


	if( m_ptrackTop == NULL )
	{
		//create it.
		hr = GetTrack( L"style.top", e_Number, &m_ptrackTop );
		CheckHR( hr, "track mismatch creating top track", done );
	}

	if( m_ptrackLeft == NULL )
	{
		//create it
		hr = GetTrack( L"style.left", e_Number, &m_ptrackLeft );
		CheckHR( hr, "Track mismatch creating left track", done );
	}

	//switch the current values for top and left into the top and left
	// tracks as statics.
	
	if( fResample && m_ptrackTop != NULL && m_ptrackLeft != NULL )
	{

		LMTRACE2( 1, 1000, L"VISSIM:Saving away the top and left in the top and left tracks\n" );
		
		//keep the top and left track from changing top and left
		m_ptrackTop->AcquireChangeLockout();
		m_ptrackLeft->AcquireChangeLockout();

		//we need to get the current values out of the top and left tracks so 
		// we can correct for the changes made by the track.
		

		if( !m_ptrackTop->IsOn() )
		{
			hr = m_ptrackTop->UpdateStaticBvr();
			CheckHR( hr, "The top track failed to update its static", staticUpdateDone );

		}

		hr =m_ptrackTop->SkipNextStaticUpdate();
		CheckHR( hr, "Failed to tell the track to skip its next update", staticUpdateDone );


		if( !m_ptrackLeft->IsOn() )
		{
			hr = m_ptrackLeft->UpdateStaticBvr();
			CheckHR( hr, "The left track failed to update its static", staticUpdateDone );
		}

		hr =m_ptrackLeft->SkipNextStaticUpdate();
		CheckHR( hr, "Failed to tell the track to skip its next update", staticUpdateDone );

		
	staticUpdateDone:
	
		LMTRACE2( 1, 1000, L"VISSIM: End Saving away the top and left in the top and left tracks\n" );
		
		if( FAILED( hr ) )
		{
			goto done;
		}
	}
	

	::VariantClear( &var );
	
	// Set top/left to offscreen
	V_VT(&var) = VT_I4;
	V_I4(&var) = -10000;

	if( CheckBitNotSet( m_dwCurrentState, ELEM_IS_VML ) )
	{
		hr = pRuntimeStyle->put_top(var);
		hr = pRuntimeStyle->put_left(var);
	}
	else
	{
		//animate the vgx runtime style.
		hr = SetVMLAttribute( L"top", &var );

		if( SUCCEEDED( hr ) )
		{
			hr = SetVMLAttribute( L"left", &var );
		}

		if( FAILED( hr ) )
			m_fVisSimFailed = true;
		else
			m_fVisSimFailed = false;
	}

done:
	VariantClear(&var);
	ReleaseInterface( pelemAnimated );


	return hr;
}


//*****************************************************************************


HRESULT
CActorBvr::RebuildActor()
{
	LMTRACE2(1, 1000, L"Processing rebuild requests on Actor <%p>\n", this );

	HRESULT hr = S_OK;

	UpdateCurrentState( );

	DWORD dirtyFlags = 0;
	CBvrTrack *ptrack = NULL;

	//now check to see if we need to rebuild the transform tracks
	
    hr = TransformTrackIsDirty( &dirtyFlags );
    CheckHR( hr, "Failed to check to see if a transform track is dirty", end );
    //if a transform track is dirty or the transform tracks have not been built yet.
    if( hr == S_OK || m_ptrackLeft == NULL )
    {
		LMTRACE2( 1, 1000, L"ActorBvr <%p> applying transform tracks\n", this );
    	hr = ApplyTransformTracks();
    	CheckHR( hr, "Failed to rebuild the transform tracks", end );
    }

    hr = ImageTrackIsDirty();
    CheckHR( hr, "failed to check if an image track is dirty", end );

    //we need to rebuild the image track if
    // 1) pixel scale is on and the scale track is dirty
    // 2) the element is not VML and the rotation track is dirty, or there is a static rotation
    // 3) there is a static scale on the element

    if( hr == S_OK ||  
    	( CheckBitSet(m_dwCurrentState, PIXEL_SCALE_ON ) && CheckBitSet(dirtyFlags, SCALE_DIRTY) ) ||
		( CheckBitNotSet(m_dwCurrentState, ELEM_IS_VML) && 
		  ( CheckBitSet( dirtyFlags, ROTATION_DIRTY ) || CheckBitSet(m_dwCurrentState, STATIC_ROTATION ) ) )  ||
	 	 CheckBitSet(m_dwCurrentState, STATIC_SCALE)
      )
    {
		LMTRACE2( 1, 1000, L"ActorBvr<%p> applying image tracks\n", this );
    	hr = ApplyImageTracks();
    	CheckHR( hr, "Failed to rebuild the Image tracks", end );
    }
	

	// Run the track list applying an unused tracks to their properties
    ptrack = m_ptrackHead;

    while (NULL != ptrack)
    {
		hr = ptrack->BeginRebuild();
		CheckHR( hr, "Failed to BeginRebuild Track", end );
		
        ptrack = ptrack->m_pNext;
    }

	//now apply all of the tracks that were rebuilt.
    ptrack = m_ptrackHead;

    while( ptrack != NULL )
    {
    	hr = ptrack->ApplyIfUnmarked();
    	CheckHR( hr, "Failed to apply track", end );
    	
    	ptrack = ptrack->m_pNext;
    }

end:

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::UpdatePixelDimensions()
{

	// Something changed, compute offset left, top, width, height
	// You would think you could just get offsetLeft etc, but for some
	// IE reason they aren't updated all the time.


	HRESULT hr = S_OK;
	
	IHTMLElement *pElement = NULL;
	hr = GetAnimatedElement(&pElement);
	if (FAILED(hr))
		return hr;

	IHTMLElement *pOffsetParent = NULL;
	hr = pElement->get_offsetParent(&pOffsetParent);
	if (FAILED(hr) || pOffsetParent == NULL )
	{
		LMTRACE2( 1, 1000, "Offset parent problems <%p>\n", pOffsetParent );
		ReleaseInterface(pElement);
		return hr;
	}

	IHTMLElement2 *pElement2 = NULL;
	hr = pElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElement2));
	ReleaseInterface(pElement);
	if (FAILED(hr))
	{
		ReleaseInterface(pOffsetParent);
		return hr;
	}

	IHTMLRect *pRect = NULL;
	hr = pElement2->getBoundingClientRect(&pRect);
	ReleaseInterface(pElement2);
	if (FAILED(hr) || pRect == NULL )
	{
		LMTRACE2( 1, 1000, "Bounding Client rect problems <%p>\n", pRect );
		ReleaseInterface(pOffsetParent);
		return hr;
	}

	long left, top, right, bottom;
	hr = pRect->get_left(&left);
	if (FAILED(hr))
	{
		ReleaseInterface(pRect);
		ReleaseInterface(pOffsetParent);
		return hr;
	}

	hr = pRect->get_top(&top);
	if (FAILED(hr))
	{
		ReleaseInterface(pRect);
		ReleaseInterface(pOffsetParent);
		return hr;
	}

	hr = pRect->get_right(&right);
	if (FAILED(hr))
	{
		ReleaseInterface(pRect);
		ReleaseInterface(pOffsetParent);
		return hr;
	}

	hr = pRect->get_bottom(&bottom);
	ReleaseInterface(pRect);
	if (FAILED(hr))
	{
		ReleaseInterface(pOffsetParent);
		return hr;
	}

	hr = pOffsetParent->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElement2));
	ReleaseInterface(pOffsetParent);
	if (FAILED(hr))
		return hr;

	hr = pElement2->getBoundingClientRect(&pRect);
	ReleaseInterface(pElement2);
	if (FAILED(hr) || pRect == NULL )
	{
		LMTRACE2(1, 1000, "bounding client rect problems <%p>\n", pRect );
		return hr;
	}

	long parentLeft, parentTop;
	hr = pRect->get_left(&parentLeft);
	if (FAILED(hr))
	{
		ReleaseInterface(pRect);
		return hr;
	}

	hr = pRect->get_top(&parentTop);
	ReleaseInterface(pRect);
	if (FAILED(hr))
		return hr;

	long pixelWidth = right - left;
	long pixelHeight = bottom - top;
	long pixelTop = top - parentTop;
	long pixelLeft = left - parentLeft;

	if (pixelWidth != m_pixelWidth ||
		pixelHeight != m_pixelHeight ||
		pixelTop != m_pixelTop ||
		pixelLeft != m_pixelLeft)
	{
#if 0
		LMTRACE2( 1, 2, "Change! pixelTop: %d pixelLeft:%d pixelWidth:%d pixelHeight:%d\n", pixelTop, pixelLeft, pixelWidth, pixelHeight );
#ifdef _DEBUG

		//get the current values from the top and left tracks
		if( m_ptrackLeft != NULL )
		{
			VARIANT varLeft;
			VariantInit( &varLeft );

			m_ptrackLeft->GetDynamic( &varLeft );
			VariantChangeTypeEx( &varLeft, &varLeft, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR );
			LMTRACE2( 1, 2, "Left track dynamic: %S", V_BSTR( &varLeft ) );
			VariantClear( &varLeft );

			m_ptrackLeft->GetStatic( &varLeft );
			VariantChangeTypeEx( &varLeft, &varLeft, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR );
			LMTRACE2( 1, 2, "Left Track static: %S\n", V_BSTR( &varLeft ) );
			VariantClear( &varLeft );

			if( m_ptrackLeft->IsOn() )
				LMTRACE2( 1, 2, "On\n" );
			else
				LMTRACE2( 1, 2, "Off\n" );

			IHTMLCurrentStyle *pstyle = NULL;

			GetCurrentStyle( &pstyle );
			if( pstyle != NULL )
			{
				long pixel = 0;

				pstyle->get_left( &varLeft );

				VariantChangeTypeEx( &varLeft, &varLeft, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR );
				VariantToPixelLong( &varLeft, &pixel, true );
				LMTRACE2( 1, 2, "CurrentStyle.left: %S %d\n", V_BSTR(&varLeft ), pixel );
				VariantClear( &varLeft );
			}
			ReleaseInterface( pstyle );
		}
#endif
#endif

		if (m_pixelWidth != pixelWidth && m_pPixelWidth != NULL)
			m_pPixelWidth->SwitchToNumber(pixelWidth);

		if (m_pixelHeight != pixelHeight && m_pPixelHeight != NULL)
			m_pPixelHeight->SwitchToNumber(pixelHeight);

		if (m_pFloatManager != NULL)
		{
			m_pFloatManager->UpdateRect(pixelLeft, pixelTop, pixelWidth, pixelHeight);
		}
		else
		{
			hr = SetRenderResolution( pixelWidth, pixelHeight );
			if( FAILED( hr ) )
				return hr;
		}


		m_pixelWidth = pixelWidth;
		m_pixelHeight = pixelHeight;
		m_pixelTop = pixelTop;
		m_pixelLeft = pixelLeft;
	}

	return hr;
}

//*****************************************************************************
// IPropertyNotifySink
//*****************************************************************************

STDMETHODIMP
CActorBvr::OnChanged(DISPID dispID)
{
	HRESULT hr = S_OK;

	if (dispID == DISPID_IHTMLCURRENTSTYLE_TOP ||
		dispID == DISPID_IHTMLCURRENTSTYLE_LEFT )
	{
		//width and height changes are handled by onresize
		
		// TODO: Should only do this when really necessary
		
		hr = UpdatePixelDimensions();

	}

/*
	if (dispID == DISPID_IHTMLCURRENTSTYLE_WIDTH ||
		dispID == DISPID_IHTMLCURRENTSTYLE_HEIGHT)
	{
		// Width or height changed

		// Get the pixel width and height
		IHTMLElement *pElement = NULL;
		hr = GetAnimatedElement(&pElement);
		if (FAILED(hr))
			return hr;

		long offsetWidth;
		hr = pElement->get_offsetWidth(&offsetWidth);
		if (FAILED(hr))
		{
			ReleaseInterface(pElement);
			return hr;
		}

		long offsetHeight;
		hr = pElement->get_offsetHeight(&offsetHeight);
		ReleaseInterface(pElement);
		if (FAILED(hr))
			return hr;

		if (offsetWidth != m_pixelWidth ||
			offsetHeight != m_pixelHeight)
		{
			m_pixelWidth = offsetWidth;
			m_pixelHeight = offsetHeight;

			if (m_pPixelWidth != NULL)
				m_pPixelWidth->SwitchToNumber(m_pixelWidth);

			if (m_pPixelHeight != NULL)
				m_pPixelHeight->SwitchToNumber(m_pixelHeight);

			if (m_pFloatManager != NULL)
				m_pFloatManager->UpdateWidthHeight(offsetWidth, offsetHeight);
		}
	}

	if (dispID == DISPID_IHTMLCURRENTSTYLE_TOP ||
		dispID == DISPID_IHTMLCURRENTSTYLE_LEFT)
	{
		// Top or left changed

		// Get the pixel left and top
		IHTMLElement *pElement = NULL;
		hr = GetAnimatedElement(&pElement);
		if (FAILED(hr))
			return hr;

		long offsetLeft;
		hr = pElement->get_offsetLeft(&offsetLeft);
		if (FAILED(hr))
		{
			ReleaseInterface(pElement);
			return hr;
		}

		long offsetTop;
		hr = pElement->get_offsetTop(&offsetTop);
		ReleaseInterface(pElement);
		if (FAILED(hr))
			return hr;

		if (offsetLeft != m_pixelLeft ||
			offsetTop != m_pixelTop)
		{
			m_pixelLeft = offsetLeft;
			m_pixelTop = offsetTop;

			if (m_pFloatManager != NULL)
				m_pFloatManager->UpdateLeftTop(offsetLeft, offsetTop);
		}
	}
*/
	if (dispID == DISPID_IHTMLCURRENTSTYLE_ZINDEX)
	{
		// zIndex changed
		if (m_pFloatManager != NULL)
			return m_pFloatManager->UpdateZIndex();
	}

	if (dispID == DISPID_IHTMLCURRENTSTYLE_VISIBILITY)
	{
		// visibility changed
		if (m_pFloatManager != NULL)
			return m_pFloatManager->UpdateVisibility();

		if (m_bEditMode)
			UpdateVisibilityDisplay();
	}

	if (dispID == DISPID_IHTMLCURRENTSTYLE_DISPLAY)
	{
		//trident may have delayed processing the bounding box of this element until it became 
		// visible.

		UpdateLayout();
		if( FAILED( hr ) )
		{
			DPF_ERR("Failed to update the pixel dimensions on a display change" );
		}

		// display changed
		if (m_pFloatManager != NULL)
			return m_pFloatManager->UpdateDisplay();

		if (m_bEditMode)
			UpdateVisibilityDisplay();
	}

	if( dispID == DISPID_IHTMLSTYLE_POSITION )
	{
		LMTRACE2( 1, 2, "Static StylePosition Changed\n" );
		UpdateDesiredPosition();
	}


	return S_OK;
}

//*****************************************************************************


STDMETHODIMP
CActorBvr::OnRequestEdit(DISPID dispID)
{
	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::UpdateLayout()
{
	HRESULT hr = S_OK;
	IHTMLCurrentStyle *pstyleCurrent = NULL;
	BSTR bstrDisplay;

	hr = GetCurrentStyle( &pstyleCurrent );
	CheckHR( hr, "Failed to get the current sytle", end );

	hr = pstyleCurrent->get_display( &bstrDisplay );
	CheckHR( hr, "Failed to get the display from the current style", end );
	CheckPtr( bstrDisplay, hr, E_FAIL, "Got null for the display", end );
	
	//if the element is now not display none
	if( wcsicmp( bstrDisplay, L"none" ) != 0 )
	{
		CBvrTrack *ptrack = NULL;
		//update the pixel layout attributes for the element
		UpdatePixelDimensions();
		CheckHR( hr, "Failed to update the pixel Dimensions", end );
		/*
		// update the top and left tracks
		if( m_ptrackTop != NULL )
			m_ptrackTop->UpdateStaticBvr();
		if( m_ptrackLeft != NULL )
			m_ptrackLeft->UpdateStaticBvr();
			
		// update the width and height tracks if they exist
		FindTrackNoType( L"style.width", &ptrack );
		if( ptrack != NULL )
			ptrack->UpdateStaticBvr();

		FindTrackNoType( L"style.height", &ptrack );
		if( ptrack != NULL )
			ptrack->UpdateStaticBvr();
		*/
	}

end:
	ReleaseInterface( pstyleCurrent );
	SysFreeString( bstrDisplay );

	return hr;
		
}

//*****************************************************************************

HRESULT
CActorBvr::RequestRebuildFromExternal()
{
	HRESULT hr = S_OK;
	
	IHTMLWindow2* 	pwindow2 = NULL;
	IDispatch*		pdispExternal = NULL;

	DISPID dispid = -1;
	LPWSTR wstrMethod = L"ANRequestRebuild";


	//get window.external
	hr = GetParentWindow( &pwindow2 );
	CheckHR( hr, "Failed to get the parent window", end );

	hr = pwindow2->get_external( &pdispExternal );
	CheckHR( hr, "Failed to get the external interface from the window", end );
	CheckPtr( pdispExternal, hr, E_FAIL, "got a null external", end );

	//check to see if the external interface supports ANRequestRebuild
	
	hr = pdispExternal->GetIDsOfNames(  IID_NULL, 
										&wstrMethod, 
                              			1,
                              			LCID_SCRIPTING, 
                              			&dispid);
	CheckHR( hr, "Didn't find ANRequestRebuild on window.external", end );

	//if window.external implements LMRTRequestRebuild
	if( dispid != DISPID_UNKNOWN )
	{
		DISPPARAMS		params;
        VARIANT			varResult;
    	VARIANT			rgvarInput[1];

    	IDispatch		*pdispElem = NULL;

    	VariantInit(&varResult);
        VariantInit(&rgvarInput[0]);


    	hr = GetHTMLElement()->QueryInterface( IID_TO_PPV(IDispatch, &pdispElem ) );
    	CheckHR( hr, "Failed to get IDispatch from element", invokeEnd );

    	V_VT(&rgvarInput[0]) = VT_DISPATCH;
    	V_DISPATCH(&rgvarInput[0]) = pdispElem;

        params.rgvarg					= rgvarInput;
        params.rgdispidNamedArgs		= NULL;
        params.cArgs					= 1;
        params.cNamedArgs				= 0;
        
		//send our element as an argument
		hr = pdispExternal->Invoke( dispid,
									IID_NULL,
									LCID_SCRIPTING,
									DISPATCH_METHOD,
									&params,
									&varResult,
									NULL,
									NULL );
		//invoke the dispid we got.

	invokeEnd:
		ReleaseInterface( pdispElem );
		VariantClear( &varResult );

		if( FAILED( hr ) )
		{
			goto end;
		}
	}

end:
	ReleaseInterface( pwindow2 );
	ReleaseInterface( pdispExternal );
	
	return hr;
}

//*****************************************************************************
// IEventManagerClient
//*****************************************************************************

IHTMLElement *
CActorBvr::GetElementToSink()
{
	return GetHTMLElement();
}

//*****************************************************************************

IElementBehaviorSite *
CActorBvr::GetSiteToSendFrom()
{
	return NULL;
}

//*****************************************************************************

HRESULT CActorBvr::TranslateMouseCoords	( long lX, long lY, long * pXTrans, long * pYTrans )
{
	if ( ( pXTrans == NULL ) || ( pYTrans == NULL ) )
		return E_POINTER;
	
	HRESULT	hr = S_OK;

	CComPtr<IHTMLElement> pElem = GetHTMLElement();
	if ( FAILED(hr) ) return hr;

	CComQIPtr<IHTMLElement2, &IID_IHTMLElement2> pElement2( pElem );
	if ( pElement2 == NULL ) return E_FAIL;

	CComPtr<IHTMLRect>	pRect;
	long				left, top;

	hr = pElement2->getBoundingClientRect( &pRect );
	if ( FAILED(hr) ) return hr;

	pRect->get_left( &left );
	if ( FAILED(hr) ) return hr;
	pRect->get_top( &top );
	if ( FAILED(hr) ) return hr;

	*pXTrans = lX - left;
	*pYTrans = lY - top;
	
	return hr;
}

//*****************************************************************************

void
CActorBvr::OnLoad()
{

	RebuildActor();

	//if we are in edit mode.
	if( !m_bEditMode )
	{
		// update all of the static behaviors (they may have been changed by other behaviors)
		CBvrTrack *ptrack = m_ptrackHead;

		while( ptrack != NULL )
		{
			if( !ptrack->IsOn() )
				ptrack->UpdateStaticBvr();
			ptrack = ptrack->m_pNext;
		}
	}
}

//*****************************************************************************

//this should no longer be needed.
HRESULT
CActorBvr::BuildChildren()
{
	//cycle through out direct children calling buildAnimationFragments

	HRESULT hr = E_FAIL;
	
	IHTMLElement* pElem;
	pElem = GetHTMLElement( );
	if( pElem != NULL )
	{
		IDispatch *pChildrenDisp;
		hr = pElem->get_children( &pChildrenDisp );
		if( SUCCEEDED( hr ) )
		{
			IHTMLElementCollection *pChildrenCol;
			hr = pChildrenDisp->QueryInterface( IID_TO_PPV( IHTMLElementCollection, &pChildrenCol ) );
			ReleaseInterface( pChildrenDisp );
			if( SUCCEEDED( hr ) )
			{
				long length;

				hr = pChildrenCol->get_length(&length);
				if( SUCCEEDED( hr ) )
				{
					if( length != 0 )
					{
						VARIANT name;
						VARIANT index;
						VARIANT rgvarInput[1];

						IDispatch *pCurrentElem;
						
						VariantInit( &name );
						V_VT(&name) = VT_I4;

						VariantInit( &index );
						V_VT(&index) = VT_I4;
						V_I4(&index) = 0;

						VariantInit( &rgvarInput[0] );
						V_VT( &rgvarInput[0] ) = VT_DISPATCH;
						V_DISPATCH( &rgvarInput[0] ) = static_cast<IDispatch*>(this);

						DISPPARAMS params;
						params.rgvarg				= rgvarInput;
						params.rgdispidNamedArgs	= NULL;
						params.cArgs				= 1;
						params.cNamedArgs			= 0;

						for(V_I4(&name) = 0; V_I4(&name) < length ; V_I4(&name)++ )
						{
							hr = pChildrenCol->item( name, index, &pCurrentElem );
							if( SUCCEEDED( hr ) )
							{
								CallBuildBehaviors( pCurrentElem, &params, NULL );
								ReleaseInterface( pCurrentElem );
							}
						}
					}
				}
				else //failed to get the length from the children collection
				{
					DPF_ERR("failed to get the length from the children collection");
				}
				ReleaseInterface( pChildrenCol );
			}
			else //failed to get IHTMLElementCollection from dispatch returned from elem->get_children
			{
				DPF_ERR("failed to get IHTMLElementCollection from dispatch returned from elem->get_children");
			}
		}
		else //failed to get the children collection from the actor element
		{
			DPF_ERR("failed to get the children collection from the actor element");
		}

	}
	else//failed to get the actor element
	{
		DPF_ERR("failed to get the actor element");
	}

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CallBuildBehaviors( IDispatch *pDisp, DISPPARAMS *pParams, VARIANT* pResult)
{
	HRESULT hr = S_OK;

	DISPID dispid;

	WCHAR* wszBuildMethodName = L"buildBehaviorFragments";

	hr = pDisp->GetIDsOfNames( IID_NULL,
							   &wszBuildMethodName,
							   1,
							   LOCALE_SYSTEM_DEFAULT,
							   &dispid);
	if( SUCCEEDED( hr ) )
	{
		EXCEPINFO		excepInfo;
		UINT			nArgErr;
		hr = pDisp->Invoke( dispid,
							IID_NULL,
							LOCALE_SYSTEM_DEFAULT,
							DISPATCH_METHOD,
							pParams,
							pResult,
							&excepInfo,
							&nArgErr );
		if( FAILED( hr ) )
		{
			if( pResult != NULL )
				VariantClear( pResult );
		}

	}
	else//failed to get the id of "buildBehaviors" on pDisp
	{
		if( pResult != NULL )
			VariantClear( pResult );
	}


	return hr;
}

//*****************************************************************************

void
CActorBvr::OnUnload()
{
}

//*****************************************************************************

void
CActorBvr::OnReadyStateChange( e_readyState state )
{
}

//*****************************************************************************

STDMETHODIMP
CActorBvr::OnLocalTimeChange( float localTime )
{
	LMTRACE2( 1, 1000, L"Local time change to %f for Actor <%p>\n", (double)localTime, this );
	HRESULT hr = ProcessPendingRebuildRequests();
	CheckHR( hr, "Failed to process the pending rebuild requests", end );

end:

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::ProcessPendingRebuildRequests()
{
	LMTRACE2( 1, 2, "Processing pending rebuild requests\n" );
	HRESULT hr = S_OK;

	m_bPendingRebuildsUpdating = true;

	bool fNeedRebuild = false;

    bool fLeaveAttached = false;

	//if there are any pending removals
	if( !m_listPendingRemovals.empty() )
	{
		//do them now.
		CCookieMap::CCookieData *pdata = NULL;
		

		for( BehaviorFragmentRemovalList::iterator curRemoval = m_listPendingRemovals.begin();
			 curRemoval != m_listPendingRemovals.end();
			 curRemoval++)
		{
			pdata = m_mapCookieToTrack.GetDataFor( (*curRemoval)->GetCookie() );

			if( pdata != NULL )
			{
				hr = pdata->m_pTrack->RemoveBvrFragment( pdata->m_eFlags, (*curRemoval)->GetCookie() );
				if( FAILED( hr ) )
				{
					DPF_ERR( "failed to remove behaivor fragment" );
				}
			}

			delete (*curRemoval);
			(*curRemoval) = NULL;
		}
		m_listPendingRemovals.clear();

		fNeedRebuild = true;
	}

	//if any child behaivors have requested a rebuild
	if( !m_listPendingRebuilds.empty() )
	{
		//tell the pending children that they can now rebuild.

		IDispatch *pdispThis = NULL;

		hr = GetUnknown()->QueryInterface( IID_TO_PPV( IDispatch, &pdispThis ) );
		if( FAILED(hr) )
		{
			DPF_ERR("Failed to get IDispatch from our unknown" );
			return hr;
		}

		DISPPARAMS dispparamsBuildArgs;
		VARIANT varThis;

		::VariantInit( &varThis );

		V_VT(&varThis) = VT_DISPATCH;
		V_DISPATCH(&varThis) = pdispThis;

		dispparamsBuildArgs.cArgs = 1;
		dispparamsBuildArgs.cNamedArgs = 0;
		dispparamsBuildArgs.rgvarg = &varThis;
		dispparamsBuildArgs.rgdispidNamedArgs = NULL;
		

        BehaviorRebuildList::iterator iterNextData = m_listPendingRebuilds.begin();
		BehaviorRebuildList::iterator iterCurData = m_listPendingRebuilds.begin();
		while( iterCurData != m_listPendingRebuilds.end() )
		{
			hr = (*iterCurData)->RebuildBehavior( &dispparamsBuildArgs, NULL );
			
            iterNextData = iterCurData;
            iterNextData++;
            //if we didn't fail
            if( SUCCEEDED( hr ) )
            {
                //remove the request from the pending list
			    delete (*iterCurData);
			    (*iterCurData) = NULL;
                m_listPendingRebuilds.erase( iterCurData );
            }
            else //we failed to rebuild the behavior
            {
                //wait until next time to try again.
                fLeaveAttached = true;
            }

            iterCurData = iterNextData;
		}

		ReleaseInterface( pdispThis );

		//if anyone added behaviors to the pending list while we were updating
		if( !m_listUpdatePendingRebuilds.empty() )
		{
			//move the update list into the pending list.
			m_listPendingRebuilds.insert( m_listPendingRebuilds.end(), 
										  m_listUpdatePendingRebuilds.begin(), 
										  m_listUpdatePendingRebuilds.end() );
			m_listUpdatePendingRebuilds.clear();
		}

		fNeedRebuild = true;
	}

    if( !fLeaveAttached )
	{
		//we don't need to listen to local time changes until
		//  we get another rebuild or removal request
		hr = DetachBodyPropertyMonitor();
		if(FAILED( hr ) )
		{
			DPF_ERR("Failed to detach the body property monitor");
		}
	}

	m_bPendingRebuildsUpdating = false;

	//now rebuild the actor
	if( fNeedRebuild || IsAnyTrackDirty() )
	{
		hr = RebuildActor();
		if( FAILED( hr ) )
		{
			DPF_ERR("failed to rebuild the actor" );
		}
	}

	if( fLeaveAttached )
		return S_FALSE;
	else
		return hr;
}

//*****************************************************************************

void
CActorBvr::ReleaseRebuildLists()
{
	m_bRebuildListLockout = true;

	if( !m_listPendingRebuilds.empty() )
	{
		BehaviorRebuildList::iterator iterCurData = m_listPendingRebuilds.begin();
		for( ; iterCurData != m_listPendingRebuilds.end(); iterCurData++ )
		{	
			delete (*iterCurData);
			(*iterCurData) = NULL;
		}
		m_listPendingRebuilds.clear();
	}

	if( !m_listUpdatePendingRebuilds.empty() )
	{
		BehaviorRebuildList::iterator iterCurData = m_listUpdatePendingRebuilds.begin();
		for( ; iterCurData != m_listUpdatePendingRebuilds.end(); iterCurData++ )
		{	
			delete (*iterCurData);
			(*iterCurData) = NULL;
		}
		m_listUpdatePendingRebuilds.clear();
	}

	if( !m_listPendingRemovals.empty() )
	{
		BehaviorFragmentRemovalList::iterator iterCurRemoval = m_listPendingRemovals.begin();
		for( ; iterCurRemoval != m_listPendingRemovals.end(); iterCurRemoval++ )
		{
			delete (*iterCurRemoval);
			(*iterCurRemoval) = NULL;
		}
		m_listPendingRemovals.clear();
	}

	//leave the update lists locked out

}

//*****************************************************************************

STDMETHODIMP
CActorBvr::put_animates(VARIANT  varAnimates)
{
	HRESULT hr = VariantCopy(&m_varAnimates, &varAnimates);
    if (FAILED(hr))
    {
        DPF_ERR("Error copying variant in put_animates");
        return SetErrorInfo(hr);
    }
    return NotifyPropertyChanged(DISPID_ICRACTORBVR_ANIMATES);
} // put_animates

//*****************************************************************************

STDMETHODIMP
CActorBvr::get_animates(VARIANT *pvarAnimates)
{
	HRESULT hr = VariantCopy(pvarAnimates, &m_varAnimates);
    if (FAILED(hr))
    {
        DPF_ERR("Error copying variant in get_animates");
        return SetErrorInfo(hr);
    }
    return S_OK;
} // get_animates

//*****************************************************************************

STDMETHODIMP
CActorBvr::put_scale(VARIANT  varScale)
{
    return E_NOTIMPL;
} // put_scale

//*****************************************************************************

STDMETHODIMP
CActorBvr::get_scale(VARIANT *pvarScale)
{
    return E_NOTIMPL;
} // get_scale

//*****************************************************************************

STDMETHODIMP
CActorBvr::put_pixelScale(VARIANT varPixelScale)
{
	HRESULT hr = VariantCopy(&m_varPixelScale, &varPixelScale);
    if (FAILED(hr))
    {
        DPF_ERR("Error copying variant in put_pixelScale");
        return SetErrorInfo(hr);
    }
    return NotifyPropertyChanged(DISPID_ICRACTORBVR_PIXELSCALE);
} 

//*****************************************************************************

STDMETHODIMP
CActorBvr::get_pixelScale(VARIANT *pvarPixelScale)
{
	HRESULT hr = VariantCopy(pvarPixelScale, &m_varPixelScale);
    if (FAILED(hr))
    {
        DPF_ERR("Error copying variant in get_pixelScale");
        return SetErrorInfo(hr);
    }
    return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::RemoveElementFilter( IHTMLElement* pElement)
{

	HRESULT hr = S_OK;
	
	// Get the style object
	IHTMLStyle *pStyle = NULL;
	VARIANT_BOOL varboolSuccess = VARIANT_FALSE;
	
	SetElementOnFilter( m_pElementFilter, NULL );

	hr = pElement->get_style(&pStyle);
	CheckHR( hr, "Failed to get the style off of the element", end );

	// Take the filter off
	hr = pStyle->removeAttribute( L"filter", VARIANT_FALSE, &varboolSuccess );
	ReleaseInterface(pStyle);
	CheckHR( hr, "Failed to remove the filter on the element", end );
	if( varboolSuccess == VARIANT_FALSE)
	{
		DPF_ERR("failed to remove the filter attribute from the style" );
	}

	ReleaseInterface( m_pElementFilter );

	ReleaseInterface( m_pElementImage );
	
end:
	ReleaseInterface( pStyle );

	return hr;
	
}

//*****************************************************************************

HRESULT
CActorBvr::RemoveElementFilter()
{
	if( m_pElementFilter == NULL )
		return S_OK;

	HRESULT hr = S_OK;

	IHTMLElement *pElement= NULL;

	hr = GetAnimatedElement( &pElement );
	CheckHR( hr, "Failed to get the animated element", end );

	hr = RemoveElementFilter( pElement );
	CheckHR( hr, "Failed to remove the filter from the animated element", end );

end:

	ReleaseInterface( pElement );

	return hr;
	
}

//*****************************************************************************

HRESULT
CActorBvr::GetElementFilter(IDispatch **ppFilter)
{
	HRESULT hr = S_OK;

	*ppFilter = NULL;

	if (m_pElementFilter == NULL)
	{

		// Get the animated element
		IHTMLElement *pElement = NULL;
		hr = GetAnimatedElement(&pElement);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to get animated element");
			return hr;
		}

		// Get a filter from it
		hr = GetElementFilter(pElement, &m_pElementFilter);
		ReleaseInterface(pElement);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to get filter");
			return hr;
		}
	}

	*ppFilter = m_pElementFilter;
	m_pElementFilter->AddRef();

	return S_OK;
}


//*****************************************************************************

HRESULT
CActorBvr::GetElementFilter(IHTMLElement *pElement, IDispatch **ppFilter)
{
	HRESULT hr = S_OK;

	*ppFilter = NULL;

	// Get the style object
	IHTMLStyle *pStyle = NULL;
	hr = pElement->get_style(&pStyle);
	if (FAILED(hr))
	{
		DPF_ERR("Error getting style from element");
		return hr;
	}

	CComBSTR filterName = L"redirect";

	// Put the filter on
	hr = pStyle->put_filter(filterName);
	ReleaseInterface(pStyle);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to put the filter on the element");
		return hr;
	}

	// Get the filter back out
	IHTMLFiltersCollection *pFilters = NULL;
	hr = pElement->get_filters(&pFilters);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to get collection of filters");
		return hr;
	}

	VARIANT varIndex;
	VARIANT varResult;
	VariantInit(&varIndex);
	VariantInit(&varResult);
	V_VT(&varIndex) = VT_I4;
	V_I4(&varIndex) = 0;

	hr = pFilters->item(&varIndex, &varResult);
	ReleaseInterface(pFilters);
	VariantClear(&varIndex);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to get filter from collection");
		return hr;
	}

	hr = VariantChangeType(&varResult, &varResult, 0, VT_DISPATCH);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to get IDispatch of filter");
		VariantClear(&varResult);
		return hr;
	}

	*ppFilter = V_DISPATCH(&varResult);
	(*ppFilter)->AddRef();
	VariantClear(&varResult);

	return S_OK;
/* This is another possible implementation that knows about the redirect effect headers
		// Need to add the redirect filter to grab the bits

		// Create the redirect effect
        IDispRedirectEffect *pRedirect = NULL;
        hr = CoCreateInstance(CLSID_RedirectEffect, 
                              NULL, 
                              CLSCTX_INPROC_SERVER, 
                              IID_IDispRedirectEffect, 
                              (void**)&pRedirect);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to create Redirect filter");
			return hr;
		}

		// Get the animated element
		IHTMLElement *pElement = NULL;
		hr = GetAnimatedElement(&pElement);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to get animated element");
			ReleaseInterface(pRedirect);
			return hr;
		}

		// Query for IHTMLElement2
		IHTMLElement2 *pElement2 = NULL;
		hr = pElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElement2));
		ReleaseInterface(pElement);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to get IHTMLElement2");
			ReleaseInterface(pRedirect);
			return hr;
		}

		// Add the filter to the element
		hr = pElement2->addFilter(pRedirect);
		ReleaseInterface(pElement2);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to add filter to element");
			return hr;
		}

		// Get the image from the filter
		hr = pRedirect->ElementImage(pvarActorImage);
		ReleaseInterface(pRedirect);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to get ElementImage from filter");
			VariantClear(pvarActorImage);
			return hr;
		}

		// Coerce to IUnknown
		hr = VariantChangeType(pvarActorImage, pvarActorImage, 0, VT_UNKNOWN);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to change type to IUnknown");
			VariantClear(pvarActorImage);
			return hr;
		}

		// Stash it away
		m_punkActorImage = pvarActorImage->punkVal;
		m_punkActorImage->AddRef();
*/

}

//*****************************************************************************

HRESULT
CActorBvr::GetElementImage(IDAImage **ppElementImage)
{
	HRESULT hr = E_FAIL;

	if (m_pElementImage == NULL)
	{
		IDispatch *pFilter = NULL;
		hr = GetElementFilter(&pFilter);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to get filter");
			return hr;
		}

		VARIANT varImage;
		VariantInit(&varImage);
		DISPPARAMS params;
		params.rgvarg = NULL;
		params.rgdispidNamedArgs = NULL;
		params.cArgs = 0;
		params.cNamedArgs = 0;

		hr = CallInvokeOnDispatch(pFilter,
                                    L"ElementImage", 
                                    DISPATCH_METHOD,
                                    &params,
                                    &varImage);
		ReleaseInterface(pFilter);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to get ElementImage from filter");
			return hr;
		}

		hr = VariantChangeType(&varImage, &varImage, 0, VT_UNKNOWN);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to change type to Unknown");
			VariantClear(&varImage);
			return hr;
		}

		// Query it for IDAImage
		hr = V_UNKNOWN(&varImage)->QueryInterface(IID_TO_PPV(IDAImage, &m_pElementImage));
		VariantClear(&varImage);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to get IDAImage");
			return hr;
		}

		// Happiness abounds
	}

	// Return the stashed value
	*ppElementImage = m_pElementImage;
	m_pElementImage->AddRef();

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::GetCurrentStyle( IHTMLElement *pElement, IHTMLCurrentStyle **ppstyleCurrent )
{
	if( ppstyleCurrent == NULL )
		return E_INVALIDARG;

	HRESULT hr = E_FAIL;

	IHTMLElement2 *pElement2;
	hr = pElement->QueryInterface( IID_TO_PPV(IHTMLElement2, &pElement2 ) );
	if( SUCCEEDED( hr ) )
	{
		hr = pElement2->get_currentStyle(ppstyleCurrent);
		ReleaseInterface( pElement2 );
		if( FAILED( hr ) ) //failed to get the current style
		{
			DPF_ERR("failed to get the currentSyle off of the current element");
		}
	}
	else //failed to get IHTMLElement2
	{
		DPF_ERR("failed to get IHTMLElement2 off of animated element");
	}
	
	return hr;


}

//*****************************************************************************

HRESULT
CActorBvr::GetPositioningAttributeAsVariant( IHTMLElement *pElement, PosAttrib attrib, VARIANT *pvarAttrib )
{
	if( pvarAttrib == NULL )
		return E_INVALIDARG;

	::VariantClear( pvarAttrib );
	
	HRESULT hr = E_FAIL;
	//we know that this is a positioning property get.  get it without units.
	IHTMLCurrentStyle *pstyleCurrent;
	hr = GetCurrentStyle( pElement, &pstyleCurrent );
	if( SUCCEEDED( hr ) && pstyleCurrent != NULL )
	{
		VARIANT varValue;
		VariantInit(&varValue);

		//if the element we are animating is not vml
 		if( CheckBitNotSet( m_dwCurrentState, ELEM_IS_VML ) )
		{
			LMTRACE2( 1, 1000, L"Getting positioning attrib from current style" );
			switch( attrib )
			{
			case e_posattribLeft:
				hr = pstyleCurrent->get_left( &varValue );
				break;
			case e_posattribTop:
				hr = pstyleCurrent->get_top( &varValue );
				break;
			case e_posattribWidth:
				hr = pstyleCurrent->get_width( &varValue );
				break;
			case e_posattribHeight:
				hr = pstyleCurrent->get_height( &varValue );
				break;
			}
		}
		else // the element is vml get the values from the style itself
		{
			LMTRACE2( 1, 2, L"Getting attribute from vml\n");
			
			IHTMLStyle *pstyle = NULL;

			hr = pElement->get_style( &pstyle );
			if( FAILED( hr ) )
			{
				ReleaseInterface( pstyleCurrent );
				return hr;
			}

			if( pstyle == NULL )
			{
				ReleaseInterface( pstyleCurrent );
				return E_POINTER;
			}
			
			switch( attrib )
			{
				case e_posattribLeft:
					hr = pstyle->get_left( &varValue );
					//TODO: get margin left and add that
					break;
				case e_posattribTop:
					hr = pstyle->get_top( &varValue );
					//TODO: get margin top and add that
					break;
				case e_posattribWidth:
					hr = pstyle->get_width( &varValue );
					break;
				case e_posattribHeight:
					hr = pstyle->get_height( &varValue );
					break;
					
			}
			ReleaseInterface( pstyle );
		}

		//if we got a variant from the element.
		if( SUCCEEDED( hr ) )
		{
			double dblValue = 0;

			if( V_VT(&varValue) == VT_BSTR )
			{
				int length = SysStringLen( V_BSTR(&varValue) );
				if( V_BSTR(&varValue) != NULL && length != 0 && wcsicmp( V_BSTR(&varValue), L"auto" ) != 0 )
				{
					::VariantCopy( pvarAttrib, &varValue );

					::VariantClear( &varValue );
					ReleaseInterface( pstyleCurrent );

					return S_OK;
				}
				else // varValue was either null or had no length or was equal to "auto"
				{
					LMTRACE2( 1, 1000, "value of positioning attribute from the style was empty\n");
					//this means that style.top/left/top/width/height was neither set by the inline style or by css
					// we need to get the left/top/width/height of this element as laid out by trident
					long lValue;
					bool isRelative = false;
					if( attrib == e_posattribLeft || attrib == e_posattribTop )
					{
						//get the position and figure out whether or not we are relative
						BSTR bstrPos = NULL;
						hr = pstyleCurrent->get_position( &bstrPos );
						if( SUCCEEDED( hr ) )
						{
							if( bstrPos != NULL && SysStringLen( bstrPos ) != 0 ) 
							{
								if( wcsicmp( bstrPos, L"absolute" ) != 0 )
									isRelative = true;
								else//if the element is not absolutely positioned then we will set it to relative when we begin
									isRelative = false;
							}
							else //assume we are static and will set the position to relative
								isRelative = true;
						}
						else//failed to get the position from the current style on the animated element
						{
							DPF_ERR("failed to get the position from the current style on the animated element");
						}
						::SysFreeString( bstrPos );
						bstrPos = NULL;
					}
					switch( attrib )
					{
					case e_posattribLeft:
						if( !isRelative )
						{
							hr = pElement->get_offsetLeft( &lValue );
							//we need to account for the marginLeft
							if( SUCCEEDED( hr ) )
							{
								long lMargin = 0;
								hr = GetMarginLeftAsPixel( pElement, pstyleCurrent, &lMargin );
								if( SUCCEEDED( hr ) )
									lValue -= lMargin;
								else
									//ignore errors in the margin code
									hr = S_OK;
								
								if( CheckBitSet( m_dwCurrentState, ELEM_IS_VML ) )
								{
									long lVGXOffset = 0;
									hr = CalculateVGXLeftPixelOffset( pElement, &lVGXOffset );
									if( SUCCEEDED( hr ) )
									{
										LMTRACE2( 1, 2, "\nCorrecting for vgx offset of %d\n\n", lVGXOffset );
										lValue -= lVGXOffset;
									}
									else
									{
										hr = S_OK; //ignore errors.
									}
								}

								
							}
						}
						else
							lValue = 0;
						break;
					case e_posattribTop:
						if( !isRelative )
						{
							hr = pElement->get_offsetTop( &lValue );
							//we need to account for the marginTop
							if( SUCCEEDED( hr ) )
							{
								long lMargin = 0;
								hr = GetMarginTopAsPixel( pElement, pstyleCurrent, &lMargin );
								if( SUCCEEDED( hr ) )
									lValue -= lMargin;
								else
									//ignore errors in the margin code
									hr = S_OK;
								
								if( CheckBitSet( m_dwCurrentState, ELEM_IS_VML ) )
								{
									long lVGXOffset = 0;
									hr = CalculateVGXTopPixelOffset( pElement, &lVGXOffset );
									if( SUCCEEDED( hr ) )
									{
										LMTRACE2( 1, 2, "\nCorrecting for vgx offset of %d\n\n", lVGXOffset );
										lValue -= lVGXOffset;
									}
									else
									{
										hr = S_OK; //ignore errors.
									}
								}
							}
															
						}
						else
						{
							lValue = 0;
						}
						break;
					case e_posattribWidth:
						hr = pElement->get_offsetWidth( &lValue );
						break;
					case e_posattribHeight:
						hr = pElement->get_offsetHeight( &lValue );
						break;
					}
					if( SUCCEEDED( hr ) )
					{
						dblValue = static_cast<double>(lValue);
					}
					else //failed to get offsetWidth from the animated element
					{
						DPF_ERR("failed to get offsetWidth from the animated element");
					}
				}
			}

			if( SUCCEEDED( hr ) )
			{
				// Got the value as a double so now build the VARIANT representing it
				V_VT( pvarAttrib ) = VT_R8;
				V_R8( pvarAttrib ) = dblValue;
			}
		}
		else //failed to get left/top/width/height from the current style
		{
			DPF_ERR("failed to get left, top, width, or height from the current style");
		}

		ReleaseInterface( pstyleCurrent );
		::VariantClear(&varValue);
	}
	else //failed to get the currentSyle off of the animated element
	{
		DPF_ERR("failed to get the currentSyle off of the animated element");
	}
	
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CalculateVGXTopPixelOffset( IHTMLElement *pelem, long *plOffset )
{
	if( pelem == NULL || plOffset == NULL )
	{
		return E_INVALIDARG;
	}
	
	HRESULT hr = S_OK;

	(*plOffset) = 0;

	long lRuntimeTop = 0;
	long lInlineMarginTop = 0;
	long lTopDynamic = 0;
	
	IHTMLStyle *pstyleInline = NULL;
	IHTMLStyle *pstyleRuntime = NULL;

	VARIANT varValue;

	VariantInit( &varValue );

	hr = GetRuntimeStyle( &pstyleRuntime );
	CheckHR( hr, "failed to get the runtime style", end );
	CheckPtr( pstyleRuntime, hr, E_POINTER, "runtimeStyle is null", end );

	hr = GetStyle( &pstyleInline );
	CheckHR( hr, "failed to get the inline style", end );
	CheckPtr( pstyleInline, hr, E_POINTER, "inline style is null", end );

	//get the runtime style value for top
	hr = pstyleRuntime->get_top( &varValue );
	CheckHR( hr, "Failed to get top", end );

	//if we got NULL or "" or "auto for the runtimeStyle.top then bail
	if( V_VT( &varValue ) == VT_BSTR )
	{
		if( V_BSTR(&varValue) == NULL )
		{
			LMTRACE2( 1,2, "Got Null for runtimeStyle.top" );
			goto end;
		}
		if( SysStringLen( V_BSTR(&varValue) ) == 0 || wcsicmp( L"auto", V_BSTR(&varValue) ) == 0 )
		{
			LMTRACE2( 1,2, "Got \"\" or \"auto\" for runtimeStyle.top" );
			goto end;
		}
	}

	hr = VariantToPixelLong( &varValue, &lRuntimeTop, false  );
	CheckHR( hr, "Failed to get the pixel value for runtimeStyle.top", end );
	
	VariantClear( &varValue );
	
	//get the margin top from the inline style
	hr = GetInlineMarginTopAsPixel( pstyleInline, &lInlineMarginTop );
	CheckHR( hr, "Failed to get style.marginTop", end );
	
	//get the dynamic value from the top track
	if( m_ptrackTop != NULL && m_ptrackTop->IsOn() )
	{
		hr = m_ptrackTop->GetDynamic( &varValue );
		CheckHR( hr, "Failed to get the dynamic value of the top track", end );

		hr = VariantToPixelLong( &varValue, &lTopDynamic, true );
		CheckHR( hr, "Failed to convert the topTrack dynamic to pixels", end );

		VariantClear( &varValue );
	}
	//calculate the offset that vgx has made
	LMTRACE2( 1, 2, "calculating vgx offset.  runtimeStyle.top: %d style.marginTop: %d topTrack.dynamic %d\n", lRuntimeTop, lInlineMarginTop, lTopDynamic );
	(*plOffset) = lRuntimeTop-lInlineMarginTop-lTopDynamic;
	
end:
	ReleaseInterface( pstyleInline );
	ReleaseInterface( pstyleRuntime );

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::GetInlineMarginTopAsPixel( IHTMLStyle *pstyleInline, long* plMargin )
{
	if( pstyleInline == NULL || plMargin == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	VARIANT varMargin;
	::VariantInit( &varMargin );

	(*plMargin) = 0;
	
	//get the marginTop from the inline style.
	hr = pstyleInline->get_marginTop( &varMargin );
	CheckHR( hr, "Failed to get the marginTop from the element", end );
	
	hr = VariantToPixelLong( &varMargin, plMargin, false );
	CheckHR( hr, "error trying to get a pixel long from marginTop", end );
	//if the variant value was not "auto" or null
	if( hr != S_FALSE )
	{
		//return
		goto end;
	}


	//got auto or null for inlineStyle.marginTop, try marginRight
	
	::VariantClear( &varMargin );
	hr = pstyleInline->get_marginBottom( &varMargin );
	CheckHR( hr, "Failed to get the marginBottom from the element", end );

	hr = VariantToPixelLong( &varMargin, plMargin, true );
	CheckHR( hr, "error trying to get a pixel long from marginBottom", end );

	//if all of the above failed to get a valid value
	//return 0
	
end:
	::VariantClear( &varMargin );
	
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::CalculateVGXLeftPixelOffset( IHTMLElement *pelem, long *plOffset )
{
	if( pelem == NULL || plOffset == NULL )
	{
		return E_INVALIDARG;
	}
	
	HRESULT hr = S_OK;

	(*plOffset) = -1;

	long lRuntimeLeft = 0;
	long lInlineMarginLeft = 0;
	long lLeftDynamic = 0;
	
	IHTMLStyle *pstyleInline = NULL;
	IHTMLStyle *pstyleRuntime = NULL;

	VARIANT varValue;

	VariantInit( &varValue );

	hr = GetRuntimeStyle( &pstyleRuntime );
	CheckHR( hr, "failed to get the runtime style", end );
	CheckPtr( pstyleRuntime, hr, E_POINTER, "runtimeStyle is null", end );

	hr = GetStyle( &pstyleInline );
	CheckHR( hr, "failed to get the inline style", end );
	CheckPtr( pstyleInline, hr, E_POINTER, "inline style is null", end );

	//get the runtime style value for left
	hr = pstyleRuntime->get_left( &varValue );
	CheckHR( hr, "Failed to get left", end );

	//if we got NULL or "" or "auto for the runtimeStyle.left then bail
	if( V_VT( &varValue ) == VT_BSTR )
	{
		if( V_BSTR(&varValue) == NULL )
		{
			LMTRACE2( 1,2, "Got Null for runtimeStyle.left" );
			goto end;
		}
		if( SysStringLen( V_BSTR(&varValue) ) == 0 || wcsicmp( L"auto", V_BSTR(&varValue) ) == 0 )
		{
			LMTRACE2( 1,2, "Got \"\" or \"auto\" for runtimeStyle.left" );
			goto end;
		}
	}

	hr = VariantToPixelLong( &varValue, &lRuntimeLeft, true  );
	CheckHR( hr, "Failed to get the pixel value for runtimeStyle.left", end );
	
	VariantClear( &varValue );
	
	//get the margin left from the inline style
	hr = GetInlineMarginLeftAsPixel( pstyleInline, &lInlineMarginLeft );
	CheckHR( hr, "Failed to get style.marginLeft", end );
	
	//get the dynamic value from the left track
	if( m_ptrackLeft != NULL && m_ptrackLeft->IsOn() )
	{
		hr = m_ptrackLeft->GetDynamic( &varValue );
		CheckHR( hr, "Failed to get the dynamic value of the left track", end );

		hr = VariantToPixelLong( &varValue, &lLeftDynamic, true );
		CheckHR( hr, "Failed to convert the leftTrack dynamic to pixels", end );

		VariantClear( &varValue );
	}
	//calculate the offset that vgx has made
	LMTRACE2( 1, 2, "calculating vgx offset.  runtimeStyle.left: %d style.marginLeft: %d leftTrack.dynamic %d\n", lRuntimeLeft, lInlineMarginLeft, lLeftDynamic );
	(*plOffset) = lRuntimeLeft-lInlineMarginLeft-lLeftDynamic;
	
end:
	ReleaseInterface( pstyleInline );
	ReleaseInterface( pstyleRuntime );

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::GetInlineMarginLeftAsPixel( IHTMLStyle *pstyleInline, long* plMargin )
{
	if( pstyleInline == NULL || plMargin == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	VARIANT varMargin;
	::VariantInit( &varMargin );

	(*plMargin) = -1;
	
	//get the marginLeft from the inline style.
	hr = pstyleInline->get_marginLeft( &varMargin );
	CheckHR( hr, "Failed to get the marginLeft from the element", end );
	
	hr = VariantToPixelLong( &varMargin, plMargin, true );
	CheckHR( hr, "error trying to get a pixel long from marginLeft", end );
	//if the variant value was not "auto" or null
	if( hr != S_FALSE )
	{
		//return
		goto end;
	}


	//got auto or null for inlineStyle.marginLeft, try marginRight
	
	::VariantClear( &varMargin );
	hr = pstyleInline->get_marginRight( &varMargin );
	CheckHR( hr, "Failed to get the marginRight from the element", end );

	hr = VariantToPixelLong( &varMargin, plMargin, true );
	CheckHR( hr, "error trying to get a pixel long from marginRight", end );

	//if all of the above failed to get a valid value
	//return 0
	
end:
	::VariantClear( &varMargin );
	
	return hr;
}


//*****************************************************************************

HRESULT
CActorBvr::GetPositioningAttributeAsDouble( IHTMLElement *pElement, PosAttrib attrib, double *pDouble, BSTR *pRetUnits)
{
	if( pDouble == NULL )
		return E_INVALIDARG;

	HRESULT hr = E_FAIL;
	//we know that this is a positioning property get.  get it without units.
	IHTMLCurrentStyle *pstyleCurrent;
	hr = GetCurrentStyle( pElement, &pstyleCurrent );
	if( SUCCEEDED( hr ) && pstyleCurrent != NULL )
	{
		VARIANT varValue;
		VariantInit(&varValue);

		//if the element we are animating is not vml
 		if( CheckBitNotSet( m_dwCurrentState, ELEM_IS_VML ) )
		{
			LMTRACE2( 1, 1000, L"Getting positioning attrib from current style" );
			switch( attrib )
			{
			case e_posattribLeft:
				hr = pstyleCurrent->get_left( &varValue );
				break;
			case e_posattribTop:
				hr = pstyleCurrent->get_top( &varValue );
				break;
			case e_posattribWidth:
				hr = pstyleCurrent->get_width( &varValue );
				break;
			case e_posattribHeight:
				hr = pstyleCurrent->get_height( &varValue );
				break;
			}
		}
		else // the element is vml get the values from the style itself
		{
			LMTRACE2( 1, 2, L"Getting attribute from vml\n");
			
			IHTMLStyle *pstyle = NULL;

			hr = pElement->get_style( &pstyle );
			if( FAILED( hr ) )
			{
				ReleaseInterface( pstyleCurrent );
				return hr;
			}

			if( pstyle == NULL )
			{
				ReleaseInterface( pstyleCurrent );
				return E_POINTER;
			}
			
			switch( attrib )
			{
				case e_posattribLeft:
					hr = pstyle->get_left( &varValue );
					//TODO: get margin left and add that
					break;
				case e_posattribTop:
					hr = pstyle->get_top( &varValue );
					//TODO: get margin top and add that
					break;
				case e_posattribWidth:
					hr = pstyle->get_width( &varValue );
					break;
				case e_posattribHeight:
					hr = pstyle->get_height( &varValue );
					break;
					
			}
			ReleaseInterface( pstyle );
		}

		if( SUCCEEDED( hr ) )
		{
			double dblValue = 0;

			if( V_VT(&varValue) == VT_BSTR )
			{
				int length = SysStringLen( V_BSTR(&varValue) );
				if( V_BSTR(&varValue) != NULL && length != 0 && wcsicmp( V_BSTR(&varValue), L"auto" ) != 0 )
				{
					OLECHAR *pUnits = NULL;
					BSTR bstrValueWithUnits = V_BSTR(&varValue);
					hr = FindCSSUnits( bstrValueWithUnits, &pUnits );
					if( SUCCEEDED( hr )  )
					{
						BSTR bstrValue = NULL;
						if( pUnits != NULL )
						{
							// Copy to return value if necessary
							if (pRetUnits != NULL)
							{
								*pRetUnits = ::SysAllocString(pUnits);
							}

							(*pUnits) = L'\0';
							bstrValue = SysAllocString(bstrValueWithUnits);
							V_BSTR(&varValue) = bstrValue;
							SysFreeString( bstrValueWithUnits );
						}
						// Okay, we have the value as a variant but we need it as a number
						// Force the conversion.
						hr = ::VariantChangeTypeEx(&varValue,
												 &varValue,
												 LCID_SCRIPTING,
												 VARIANT_NOUSEROVERRIDE,
												 VT_R8);
						if( SUCCEEDED( hr ) )
						{
							dblValue = V_R8(&varValue);
							::VariantClear(&varValue);
						}
						else//failed to change the type of a number property to double
						{
							DPF_ERR("failed to change the type of a number property to a double" );
						}

					}
					else//failed to get the units from the returned string
					{
						dblValue = 0;
					}
				}
				else // varValue was either null or had no length or was equal to "auto"
				{
					LMTRACE2( 1, 1000, "value of positioning attribute from the style was empty\n");
					//this means that style.top/left/top/width/height was neither set by the inline style or by css
					// we need to get the left/top/width/height of this element as laid out by trident
					long lValue;
					bool isRelative = false;
					if( attrib == e_posattribLeft || attrib == e_posattribTop )
					{
						//get the position and figure out whether or not we are relative
						BSTR bstrPos = NULL;
						hr = pstyleCurrent->get_position( &bstrPos );
						if( SUCCEEDED( hr ) )
						{
							if( bstrPos != NULL && SysStringLen( bstrPos ) != 0 ) 
							{
								if( wcsicmp( bstrPos, L"absolute" ) != 0 )
									isRelative = true;
								else//if the element is not absolutely positioned then we will set it to relative when we begin
									isRelative = false;
							}
							else //assume we are static and will set the position to relative
								isRelative = true;
						}
						else//failed to get the position from the current style on the animated element
						{
							DPF_ERR("failed to get the position from the current style on the animated element");
						}
						::SysFreeString( bstrPos );
						bstrPos = NULL;
					}
					switch( attrib )
					{
					case e_posattribLeft:
						if( !isRelative )
						{
							hr = pElement->get_offsetLeft( &lValue );
							//we need to account for the marginLeft
							if( SUCCEEDED( hr ) )
							{
								long lMargin = 0;
								hr = GetMarginLeftAsPixel( pElement, pstyleCurrent, &lMargin );
								if( SUCCEEDED( hr ) )
									lValue -= lMargin;
								else
									//ignore errors in the margin code
									hr = S_OK;
							}
						}
						else
							lValue = 0;
						break;
					case e_posattribTop:
						if( !isRelative )
						{
							hr = pElement->get_offsetTop( &lValue );
							//we need to account for the marginTop
							if( SUCCEEDED( hr ) )
							{
								long lMargin = 0;
								hr = GetMarginTopAsPixel( pElement, pstyleCurrent, &lMargin );
								if( SUCCEEDED( hr ) )
									lValue -= lMargin;
								else
									//ignore errors in the margin code
									hr = S_OK;
							}
						}
						else
						{
							lValue = 0;
						}
						break;
					case e_posattribWidth:
						hr = pElement->get_offsetWidth( &lValue );
						break;
					case e_posattribHeight:
						hr = pElement->get_offsetHeight( &lValue );
						break;
					}
					if( SUCCEEDED( hr ) )
					{
						dblValue = static_cast<double>(lValue);
					}
					else //failed to get offsetWidth from the animated element
					{
						DPF_ERR("failed to get offsetWidth from the animated element");
					}
				}
			}
			else //varValue was not a bstr
			{
				//try to coerce it to a double
				hr = ::VariantChangeTypeEx(&varValue,
										 &varValue,
										 LCID_SCRIPTING,
										 VARIANT_NOUSEROVERRIDE,
										 VT_R8);
				if( SUCCEEDED( hr ) )
				{
					dblValue = V_R8(&varValue);
				}
				else//failed to change the type of a number property to double
				{
					DPF_ERR("failed to change the type of a number property to a double" );
					dblValue = 0;
				}
			}

			LMTRACE2( 1, 1000, L"Got a positioning attribute %s whose value is %f\n", ( (attrib==e_posattribLeft) ? L"left":
																			( (attrib==e_posattribTop) ?L"top" : 
																			( (attrib==e_posattribWidth)? L"width": 
																			  L"height" ) ) ) ,dblValue );
			
			if( SUCCEEDED( hr ) )
			{
				// Got the value as a double so now build the DANumber representing it.
				(*pDouble) = dblValue;
			}
			else
			{
				(*pDouble) = 0.0;
			}
		}
		else //failed to get left/top/width/height from the current style
		{
			DPF_ERR("failed to get left, top, width, or height from the current style");
			(*pDouble) = 0.0;
		}

		ReleaseInterface( pstyleCurrent );
		::VariantClear(&varValue);
	}
	else //failed to get the currentSyle off of the animated element
	{
		DPF_ERR("failed to get the currentSyle off of the animated element");
		(*pDouble) = 0.0;
	}
	
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::GetMarginLeftAsPixel( IHTMLElement *pelem, IHTMLCurrentStyle* pstyleCurrent, long* plMargin )
{
	if( pstyleCurrent == NULL || plMargin == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	IHTMLStyle *pstyleInline = NULL;

	VARIANT varMargin;
	::VariantInit( &varMargin );

	(*plMargin) = 0;

	//get the marginLeft from the current style.
	hr = pstyleCurrent->get_marginLeft( &varMargin );
	CheckHR( hr, "Failed to get the marginLeft from the element", end );
	
	hr = VariantToPixelLong( &varMargin, plMargin, true );
	CheckHR( hr, "error trying to get a pixel long from currentStyle.marginLeft", end );
	//if the variant value was not "auto" or null
	if( hr != S_FALSE )
	{
		//return
		goto end;
	}
	
	//we did not get a viable value from currentStyle.marginLeft
	// try currentStyle.marginRight

	//get the marginRight from the current style.
	::VariantClear( &varMargin );
	hr = pstyleCurrent->get_marginRight( &varMargin );
	CheckHR( hr, "Failed to get the marginRight from the element", end );
	
	hr = VariantToPixelLong( &varMargin, plMargin, true );
	CheckHR( hr, "error trying to get a pixel long from marginRight", end );
	//if the variant value was not "auto" or null
	if( hr != S_FALSE )
	{
		//return
		goto end;
	}

	//we got auto or NULL for both currentStyle.marginLeft and currentStyle.marginRight
	//  fall back to the inline style.

	//get the inline style from the passed element
	hr = pelem->get_style( &pstyleInline );
	CheckHR( hr, "Failed to get the inline style", end );
	CheckPtr( pstyleInline, hr, E_POINTER, "got a null inline style from trident", end );
	
	//get the marginLeft from the inline style.
	::VariantClear( &varMargin );
	hr = pstyleInline->get_marginLeft( &varMargin );
	CheckHR( hr, "Failed to get the marginLeft from the element", end );
	
	hr = VariantToPixelLong( &varMargin, plMargin, true );
	CheckHR( hr, "error trying to get a pixel long from marginLeft", end );
	//if the variant value was not "auto" or null
	if( hr != S_FALSE )
	{
		//return
		goto end;
	}


	//got auto or null for inlineStyle.marginLeft, try marginRight
	
	::VariantClear( &varMargin );
	hr = pstyleInline->get_marginRight( &varMargin );
	CheckHR( hr, "Failed to get the marginRight from the element", end );

	hr = VariantToPixelLong( &varMargin, plMargin, true );
	CheckHR( hr, "error trying to get a pixel long from marginRight", end );

	//if all of the above failed to get a valid value
	//return 0
	
end:
	ReleaseInterface( pstyleInline );
	::VariantClear( &varMargin );
	
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::GetMarginTopAsPixel( IHTMLElement *pelem, IHTMLCurrentStyle* pstyleCurrent, long* plMargin )
{
	if( pstyleCurrent == NULL || plMargin == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	IHTMLStyle *pstyleInline = NULL;

	VARIANT varMargin;
	::VariantInit( &varMargin );

	(*plMargin) = 0;

	//get the marginTop from the current style.
	hr = pstyleCurrent->get_marginTop( &varMargin );
	CheckHR( hr, "Failed to get the marginTop from the element", end );
	
	hr = VariantToPixelLong( &varMargin, plMargin, true );
	CheckHR( hr, "error trying to get a pixel long from currentStyle.marginLeft", end );
	//if the variant value was not "auto" or null
	if( hr != S_FALSE )
	{
		//return
		goto end;
	}
	
	//we did not get a viable value from currentStyle.marginTop
	// try currentStyle.marginBottom

	//get the marginBottom from the current style.
	::VariantClear( &varMargin );
	hr = pstyleCurrent->get_marginBottom( &varMargin );
	CheckHR( hr, "Failed to get the marginRight from the element", end );
	
	hr = VariantToPixelLong( &varMargin, plMargin, true );
	CheckHR( hr, "error trying to get a pixel long from marginBottom", end );
	//if the variant value was not "auto" or null
	if( hr != S_FALSE )
	{
		//return
		goto end;
	}

	//we got auto or NULL for both currentStyle.marginTop and currentStyle.marginBottom
	//  fall back to the inline style.

	//get the inline style from the passed element
	hr = pelem->get_style( &pstyleInline );
	CheckHR( hr, "Failed to get the inline style", end );
	CheckPtr( pstyleInline, hr, E_POINTER, "got a null inline style from trident", end );
	
	//get the marginTop from the inline style.
	::VariantClear( &varMargin );
	hr = pstyleInline->get_marginTop( &varMargin );
	CheckHR( hr, "Failed to get the marginTop from the element", end );
	
	hr = VariantToPixelLong( &varMargin, plMargin, true );
	CheckHR( hr, "error trying to get a pixel long from marginTop", end );
	//if the variant value was not "auto" or null
	if( hr != S_FALSE )
	{
		//return
		goto end;
	}


	//got auto or null for inlineStyle.marginLeft, try marginBottom
	
	::VariantClear( &varMargin );
	hr = pstyleInline->get_marginRight( &varMargin );
	CheckHR( hr, "Failed to get the marginBottom from the element", end );

	hr = VariantToPixelLong( &varMargin, plMargin, true );
	CheckHR( hr, "error trying to get a pixel long from marginBottom", end );

	//if all of the above failed to get a valid value
	//return
	
end:
	ReleaseInterface( pstyleInline );
	::VariantClear( &varMargin );
	
	return hr;
}


//*****************************************************************************

HRESULT
CActorBvr::VariantToPixelLong( VARIANT* pvar, long* pLong, bool fHorizontal )
{

	HRESULT hr = S_OK;

	(*pLong) = 0;
	
	//if the value is a bstr
	if( V_VT( pvar ) == VT_BSTR )
	{
		//if it is not null, and not auto
		if( V_BSTR(pvar) != NULL && 
			_wcsicmp( V_BSTR(pvar), L"auto" ) != 0 )
		{
			//convert it to pixels
			hr = GetPixelValue( pvar, pLong, fHorizontal );
			CheckHR( hr, "Failed to get a pixel value for the marginRight", end );
			//return
			goto end;
		}
		//we got auto or a null value
		hr = S_FALSE;
	}
	else//else it was not a bstr
	{
		//try to convert it to a long
		hr = ::VariantChangeTypeEx( pvar, pvar, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_I4 );
		CheckHR( hr, "Failed to change the type of returned for the value of marginRight", end );
		
		//return
		(*pLong) = V_I4( pvar );
		goto end;
	}

end:
	return hr;
}

//*****************************************************************************


HRESULT
CActorBvr::GetPixelValue( VARIANT *pvarStringWithUnit, long *plResult, bool bHorizontal )
{
	if( pvarStringWithUnit == NULL || plResult == NULL )
		return E_INVALIDARG;
	//make sure that the variant is a string
	if( V_VT(pvarStringWithUnit) != VT_BSTR || V_BSTR(pvarStringWithUnit) == NULL)
		return E_FAIL;

	HRESULT hr = S_OK;
	int ret = 0;
	//find the css units on the variant
	OLECHAR *pUnits = NULL;
	hr = FindCSSUnits( V_BSTR(pvarStringWithUnit), &pUnits );
	//if css units were not found
	if( hr != S_OK )
	{
		//this value is already in pixels
		//convert it to a long
		ret = swscanf( V_BSTR(pvarStringWithUnit), L"%ld", plResult );
		if( ret == 0 || ret == EOF )
			return E_FAIL;
		else
			return S_OK;
	}
	if( pUnits == NULL )
		return E_FAIL;
	//this value needs to be converted
	//chop the unit string off of the contents of the variant
	double dValue = 0.0;
	OLECHAR cOldValue = (*pUnits);
	(*pUnits) = L'\0';
	//parse the double out of the remaining string
	ret = swscanf( V_BSTR(pvarStringWithUnit), L"%lf", &dValue );
	(*pUnits) = cOldValue;
	if( ret == 0 || ret == EOF )
		return E_FAIL;

	double dConvertedValue = 0.0;
	//TODO:this needs to handle other units as well
	//convert the value from its unit to pixels
	//The key conversions here are
	//  2.54 cm/in
	//  1/72 in/pt
	//  12 pt/pc

	//snag the conversion from inches to pixels from the root dc
	int pixelsPerInch = 1;

	HDC hdc = ::GetDC( NULL );
	if( hdc != NULL )
	{
		if( bHorizontal )
		{
			pixelsPerInch = ::GetDeviceCaps( hdc, LOGPIXELSX );
		}
		else
		{
			pixelsPerInch = ::GetDeviceCaps( hdc, LOGPIXELSY );
		}
		::ReleaseDC( NULL, hdc );
	}
	else
	{
		return E_FAIL;
	}


	if( _wcsicmp( pUnits, L"px" ) == 0 )
	{
		//already in pixels
		dConvertedValue = dValue;
	}
	else if( _wcsicmp( pUnits, L"pt" ) == 0 )
	{
		//convert to in then to cm then to m then to pixels
		dConvertedValue = dValue/72.0*pixelsPerInch;
	}
	else if( _wcsicmp( pUnits, L"pc" ) == 0 )
	{
		//convert to pts then to in then to cm then to m then to pixels
		dConvertedValue = (dValue*12.0)/72.0*pixelsPerInch;
	}
	else if( _wcsicmp( pUnits, L"mm")  == 0 )
	{
		dConvertedValue = dValue/25.4*pixelsPerInch;
	}
	else if( _wcsicmp( pUnits, L"cm") == 0 )
	{
		dConvertedValue = dValue/2.54*pixelsPerInch;
	}
	else if( _wcsicmp( pUnits, L"in") == 0 )
	{
		//convert to cm then to m then to pixels
		dConvertedValue = dValue*pixelsPerInch;
	}
	else
	{
		return E_FAIL;
	}
	//round and assign return value
	(*plResult) = (long)(dConvertedValue + 0.5 );

	return S_OK;

}

//*****************************************************************************


HRESULT
CActorBvr::GetPositioningAttributeAsDANumber( IHTMLElement *pElement, PosAttrib attrib, IDANumber **ppdanum, BSTR *pRetUnits )
{
	if( ppdanum == NULL )
		return E_INVALIDARG;

	HRESULT hr = E_FAIL;

	double dblValue = 0.0;
	hr = GetPositioningAttributeAsDouble( pElement, attrib, &dblValue, pRetUnits );
	if( SUCCEEDED( hr ) )
	{
		hr = GetDAStatics()->DANumber(dblValue, ppdanum);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to create the number bvr");
			(*ppdanum) = NULL;
		}
	}
	else//Failed to get the positioning attribute as a double
	{
		DPF_ERR("Failed to get the positioning attribute as a double" );	
	}

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::GetPropAsDANumber(IHTMLElement *pElement,
							 LPWSTR       *pPropNames,
							 int		   numPropNames,
                             IDANumber   **ppdanum,
							 BSTR		  *pRetUnits)
{
    DASSERT(NULL != ppdanum);
    *ppdanum = NULL;

	HRESULT hr = E_FAIL;

	// Check for special cases
	if (numPropNames == 2 && wcsicmp(L"style", pPropNames[0]) == 0)
	{
		if( wcsicmp( pPropNames[1], L"width" ) == 0 )
		{
			return GetPositioningAttributeAsDANumber( pElement, e_posattribWidth, ppdanum, pRetUnits );
		}
		else if( wcsicmp( pPropNames[1], L"height" ) == 0 )
		{
			return GetPositioningAttributeAsDANumber( pElement, e_posattribHeight, ppdanum, pRetUnits );
		}
		else if( wcsicmp( pPropNames[1], L"left" ) == 0 )
		{
			return GetPositioningAttributeAsDANumber( pElement, e_posattribLeft, ppdanum, pRetUnits );
		}
		else if( wcsicmp( pPropNames[1], L"top" ) == 0 )
		{
			return GetPositioningAttributeAsDANumber( pElement, e_posattribTop, ppdanum, pRetUnits );
		}
	}

	double dblValue = 0;
	// Step one is to get the property being animated as a variant.
	VARIANT varValue;
	::VariantInit(&varValue);
	hr = GetPropFromElement(pElement,
							pPropNames,
							numPropNames,
							true,
							&varValue);
	if (FAILED(hr))
	{
		DPF_ERR("Could not get property value from HTML");
		return hr;
	}
	
	//if the variant we got back is a bstr
	if( V_VT(&varValue) == VT_BSTR )
	{
		//strip off the units
		//BUGBUG kurtj we should store these away keyed by the property so that when we
		//  set the property on the element again we can append the unit string
		BSTR bstrVal = V_BSTR(&varValue);
		OLECHAR* pUnits;

		hr = FindCSSUnits( bstrVal, &pUnits );
		if( SUCCEEDED(hr) && pUnits != NULL )
		{
			// Have units.  Copy to output if necessary
			if (pRetUnits != NULL)
			{
				*pRetUnits = ::SysAllocString(pUnits);
			}

			(*pUnits) = L'\0';
			BSTR bstrNewVal = SysAllocString(bstrVal);
			V_BSTR(&varValue) = bstrNewVal;
			SysFreeString(bstrVal);
		}
		//else //no css units, oh well.
		
	}
	// Okay, we have the value as a variant but we need it as a number
	// Force the conversion.
	hr = ::VariantChangeTypeEx(&varValue,
		&varValue,
		LCID_SCRIPTING,
		VARIANT_NOUSEROVERRIDE,
		VT_R8);
	if( FAILED( hr ) )
	{
		DPF_ERR("failed to change the type of a number property to a double" );
		::VariantClear( &varValue );
		return hr;
	}
	dblValue = V_R8(&varValue);
	::VariantClear(&varValue);
	
	// Got the value as a double so now build the DANumber representing it.
	hr = GetDAStatics()->DANumber(dblValue, ppdanum);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to create the number bvr");
		return hr;
	}

    return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::GetElementPropAsDANumber(LPWSTR      *pPropNames,
									int			numPropNames,
                                    IDANumber **ppNumber,
									BSTR	   *pRetUnits)
{
	return GetPropAsDANumber(GetHTMLElement(),pPropNames, numPropNames, ppNumber, pRetUnits);
}


//*****************************************************************************

HRESULT
CActorBvr::GetPropFromAnimatedElement( LPWSTR		*pPropNames,
									   int 			numPropNames,
									   bool			current,
									   VARIANT		*pvarResult )
{
	HRESULT hr = S_OK;
	
	IHTMLElement *pelemAnimated = NULL;

	hr = GetAnimatedElement( &pelemAnimated );
	CheckHR( hr, "Failed to get the animated element", end );

	hr = GetPropFromElement( pelemAnimated, pPropNames, numPropNames, current, pvarResult );

end:
	ReleaseInterface( pelemAnimated );
	return hr;
}


//*****************************************************************************


/**
 * Retrieves a variant that represents the value of the given attribute on
 * the given attribute.  Recognizes names that begin with style. as referencing
 * a style attribute.  If current is true, accesses style attributes in
 * currentStyle, not style.
 */
HRESULT 
CActorBvr::GetPropFromElement(IHTMLElement *pElement, 
                                  LPWSTR	   *pPropNames,
								  int			numPropNames,
								  bool			current,
                                  VARIANT		*pReturn)
{
    DASSERT(pElement != NULL);
    DASSERT(pPropNames != NULL);
    DASSERT(pReturn != NULL);

    HRESULT hr;
    // this function supports the possibility that the attribute
    // specified might be style.XXXX where XXXX is the attribute
    // of the HTML style attached to the element.  We will first
    // examine the string to determine if this is the case
    if (numPropNames == 2 && wcsicmp(pPropNames[0], L"style") == 0)
    {
        // they want a style param, we need to get this object and
        // use the string following the "style." for the attribute
		if (current)
		{

			
			if( wcsicmp( pPropNames[1], L"width" ) == 0 )
			{
				return GetPositioningAttributeAsVariant( pElement, e_posattribWidth, pReturn );
			}
			else if( wcsicmp( pPropNames[1], L"height" ) == 0 )
			{
				return GetPositioningAttributeAsVariant( pElement, e_posattribHeight, pReturn );
			}
			else if( wcsicmp( pPropNames[1], L"left" ) == 0 )
			{
				return GetPositioningAttributeAsVariant( pElement, e_posattribLeft, pReturn );
			}
			else if( wcsicmp( pPropNames[1], L"top" ) == 0 )
			{
				return GetPositioningAttributeAsVariant( pElement, e_posattribTop, pReturn );
			}
			

			// Reference currentStyle
			IHTMLCurrentStyle *pCurrStyle = NULL;
			IHTMLElement2 *pElement2 = NULL;
			hr = pElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElement2));
			if (FAILED(hr))
			{
				DPF_ERR("Error obtaining IHTMLElement2 from HTMLElement");
				return SetErrorInfo(hr);
			}

			hr = pElement2->get_currentStyle(&pCurrStyle);
			ReleaseInterface(pElement2);

			if (FAILED(hr))
			{
				DPF_ERR("Error obtaining current style element from HTML element");
				return SetErrorInfo(hr);
			}

			if(pCurrStyle == NULL)
			{
				DPF_ERR("The current style was null" );
				return E_FAIL;
			}

			hr = pCurrStyle->getAttribute(pPropNames[1], 0, pReturn);
			ReleaseInterface(pCurrStyle);
			if (FAILED(hr))
			{
				DPF_ERR("Error obtaining an attribute from a style object in GetHTMLAttributeFromElement");
    			return SetErrorInfo(hr);
			}
		}
		else
		{
			// Reference the inline style
			IHTMLStyle *pStyle = NULL;
			hr = pElement->get_style(&pStyle);

			if (FAILED(hr))
			{
				DPF_ERR("Error obtaining style element from HTML element in GetHTMLAttributeFromElement");
    			return SetErrorInfo(hr);
			}
			DASSERT(pStyle != NULL);

			hr = pStyle->getAttribute(pPropNames[1], 0, pReturn);
			ReleaseInterface(pStyle);
			if (FAILED(hr))
			{
				DPF_ERR("Error obtaining an attribute from a style object in GetHTMLAttributeFromElement");
    			return SetErrorInfo(hr);
			}
		}
    }
    else if (numPropNames == 1)
    {
		// Just get it off the element directly
        hr = pElement->getAttribute(pPropNames[0], 0, pReturn);
        if (FAILED(hr))
        {
            DPF_ERR("Error obtaining attribute from HTML element in GetHTMLAttributeFromElement");
    		return SetErrorInfo(hr);
        }
    }
	else
	{
		// Multi-component name.  Need to drill down using IDispatch

		// Get a dispatch from element
		IDispatch *pDispatch = NULL;
		hr = pElement->QueryInterface(IID_TO_PPV(IDispatch, &pDispatch));
		if (FAILED(hr))
			return hr;

		// Now loop over the stored property names, except the last one, doing getDispatch
		// Note that we don't care if we fail
		for (int i=0; i<numPropNames-1; i++)
		{
			IDispatch *pPropDispatch = NULL;
			hr = GetPropertyAsDispatch(pDispatch, pPropNames[i], &pPropDispatch);
			ReleaseInterface(pDispatch);
			if (FAILED(hr))
				return S_OK;
	
			pDispatch = pPropDispatch;
		}

		// Now get the final one
		hr = GetPropertyOnDispatch(pDispatch, pPropNames[numPropNames-1], pReturn);
		ReleaseInterface(pDispatch);
		
		return S_OK;

	}

    return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::GetPropertyAsDispatch(IDispatch *pDispatch, BSTR name, IDispatch **ppDispatch)
{
    DASSERT(ppDispatch != NULL);
    *ppDispatch = NULL;

    HRESULT hr;
	DISPPARAMS		params;
	VARIANT			varResult;

	VariantInit(&varResult);

	params.rgvarg				= NULL;
	params.rgdispidNamedArgs	= NULL;
	params.cArgs				= 0;
	params.cNamedArgs			= 0;
	
    hr = CallInvokeOnDispatch(pDispatch,
                              name, 
                              DISPATCH_PROPERTYGET,
                              &params,
                              &varResult);

	if (FAILED(hr))
		return hr;

	// Change type to dispatch
	hr = VariantChangeType(&varResult, &varResult, 0, VT_DISPATCH);
	if (FAILED(hr))
	{
		VariantClear(&varResult);
		return hr;
	}

	*ppDispatch = V_DISPATCH(&varResult);
	(*ppDispatch)->AddRef();

	VariantClear(&varResult);

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::GetPropertyOnDispatch(IDispatch *pDispatch, BSTR name, VARIANT *pReturn)
{
    DASSERT(pReturn != NULL);
	VariantInit(pReturn);

    HRESULT hr;
	DISPPARAMS		params;

	params.rgvarg				= NULL;
	params.rgdispidNamedArgs	= NULL;
	params.cArgs				= 0;
	params.cNamedArgs			= 0;
	
    hr = CallInvokeOnDispatch(pDispatch,
                              name, 
                              DISPATCH_PROPERTYGET,
                              &params,
                              pReturn);

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::SetPropertyOnDispatch(IDispatch *pDispatch, BSTR name, VARIANT *pVal)
{
    HRESULT hr = S_OK;
	DISPPARAMS		params;
	VARIANT			varResult;
	VariantInit(&varResult);

    DISPID mydispid = DISPID_PROPERTYPUT;
	params.rgvarg = pVal;
	params.rgdispidNamedArgs = &mydispid;
	params.cArgs = 1;
	params.cNamedArgs = 1;
	hr = CallInvokeOnDispatch(pDispatch,
							  name,
							  DISPATCH_PROPERTYPUT,
							  &params,
							  &varResult);
	VariantClear(&varResult);

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::FindCSSUnits( BSTR bstrValWithUnits, OLECHAR** ppUnits )
{
	if( bstrValWithUnits == NULL || ppUnits == NULL )
		return E_INVALIDARG;
	
	int length = SysStringLen(bstrValWithUnits);
	int curChar = length - 1;
	while(curChar >= 0 && (bstrValWithUnits[curChar] < L'0' || bstrValWithUnits[curChar] > L'9') )
		curChar--;
	if( curChar >= 0 && curChar < length-1 )
	{
		(*ppUnits) = &(bstrValWithUnits[curChar+1]);
		return S_OK;
	}
	else
	{
		(*ppUnits) = NULL;
	}
	//the units were either not there or there was no number here.
	return S_FALSE;
}

//*****************************************************************************

HRESULT
CActorBvr::FindTrack(LPWSTR wzPropertyName, ActorBvrType eType, CActorBvr::CBvrTrack **ppTrack)
{
    DASSERT(NULL != wzPropertyName);
	DASSERT(NULL != ppTrack);
	*ppTrack = NULL;

    for (CBvrTrack *ptrackCurrent = m_ptrackHead;
         NULL != ptrackCurrent;
         ptrackCurrent = ptrackCurrent->m_pNext)
    {
        // BUGBUG (ColinMc): Is case insensitive comparison correct here?
        // BUGBUG (ColinMc): Move this code inside the track class?
        DASSERT(NULL != ptrackCurrent->m_bstrPropertyName);
        if (0 == wcsicmp(ptrackCurrent->m_bstrPropertyName, wzPropertyName))
		{
			// Matched the property name.  If the types are different we are in trouble,
			// since it means that we already saw a behavior with a different type
			if (ptrackCurrent->m_eType != eType)
				return E_FAIL;

            // Got a match - return this track...
			*ppTrack = ptrackCurrent;

            return S_OK;
        }
    }

    // If we got this far we have no track of this name and type, return NULL
    return S_OK;
} // FindTrack

//*****************************************************************************

HRESULT
CActorBvr::FindTrackNoType(LPWSTR wzPropertyName, CActorBvr::CBvrTrack **ppTrack)
{
    DASSERT(NULL != wzPropertyName);
	DASSERT(NULL != ppTrack);
	*ppTrack = NULL;

    for (CBvrTrack *ptrackCurrent = m_ptrackHead;
         NULL != ptrackCurrent;
         ptrackCurrent = ptrackCurrent->m_pNext)
    {
        // BUGBUG (ColinMc): Is case insensitive comparison correct here?
        // BUGBUG (ColinMc): Move this code inside the track class?
        DASSERT(NULL != ptrackCurrent->m_bstrPropertyName);
        if (0 == wcsicmp(ptrackCurrent->m_bstrPropertyName, wzPropertyName))
		{
			//WARNING: this does not check the type of the track.  The calling code should ensure that this track is not 
			//  the wrong type.
			
            // Got a match - return this track...
			*ppTrack = ptrackCurrent;

            return S_OK;
        }
    }

    // If we got this far we have no track of this name and type, return NULL
    return S_OK;
} // FindTrack


//*****************************************************************************

HRESULT
CActorBvr::CreateTrack(BSTR           bstrPropertyName,
                       ActorBvrType   eType,
                       CBvrTrack    **pptrack)
{
    DASSERT(NULL != bstrPropertyName);
    DASSERT(NULL != pptrack);
    *pptrack = NULL;

    // Locate the type record for the given type in the type table.
    int i = 0;
    while (i < s_cActorBvrTableEntries)
    {
        if (eType == s_rgActorBvrTable[i].m_eType)
        {
            // Got the entry, create the instance.
            HRESULT hr = (*s_rgActorBvrTable[i].m_fnCreate)(this,
                                                            bstrPropertyName,
                                                            eType,
                                                            pptrack);
            if (FAILED(hr))
            {
                DPF_ERR("Could not create a bvr track");
                return SetErrorInfo(hr);
            }
			//else we found the track and succeeded building it.
			return S_OK;
        }
        i++;
    }
    
    DPF_ERR("No entry found in type table for specified type");
    DASSERT(false);
    return SetErrorInfo(E_FAIL);
} // CreateTrack

//*****************************************************************************

HRESULT
CActorBvr::GetTrack(LPWSTR         wzPropertyName,
                    ActorBvrType   eType,
                    CBvrTrack    **pptrack)
{
    DASSERT(NULL != wzPropertyName);
    DASSERT(NULL != pptrack);
    *pptrack = NULL;

    // Attempt to find a track of the given type driving the given property
	CBvrTrack* ptrack;
	HRESULT hr = FindTrack(wzPropertyName, eType, &ptrack);

	if (FAILED(hr))
	{
		DPF_ERR("Probable track conflict");
		return SetErrorInfo(hr);
	}

    if (NULL == ptrack)
    {
        // No existing track of that type found so create a new one and
        // add it to the track list (at the head).
        HRESULT hr = CreateTrack(wzPropertyName, eType, &ptrack);
        if (NULL == ptrack)
        {
            DPF_ERR("Could not create a new track instance");
            return hr;
        }
        
        // Insert it into the list
        ptrack->m_pNext = m_ptrackHead;
        m_ptrackHead = ptrack;
    }

    // If we got this far we should have a valid track, return it.
    DASSERT(NULL != ptrack);
    *pptrack = ptrack;
    return S_OK;
} // GetTrack

//*****************************************************************************
HRESULT
CActorBvr::BuildAnimation()
{
	HRESULT hr;

    // Discard any cached behaviors we have...
    DiscardBvrCache();

	hr = ApplyTransformTracks();
	if (FAILED(hr))
	{
		DPF_ERR("Failed to apply transform tracks");
		return hr;
	}


	hr = ApplyImageTracks();
	if (FAILED(hr))
	{
		DPF_ERR("Failed to apply image tracks");
		DiscardBvrCache();
		return hr;
	}

	//we are done with the special cases do all of the rest now.

	// Run the track list applying an unused tracks to their properties
    CBvrTrack *ptrack = m_ptrackHead;
    while (NULL != ptrack)
    {
		hr = ptrack->ApplyIfUnmarked();
		if (FAILED(hr))
		{
			DPF_ERR("Failed to apply track to property");
			return SetErrorInfo(hr);
		}

        ptrack = ptrack->m_pNext;
    }

	return S_OK;
}
//*****************************************************************************


HRESULT
CActorBvr::BuildAnimationAsDABehavior()
{
	//this should go away soon...
	return S_OK;
}

//*****************************************************************************

STDMETHODIMP
CActorBvr::getActorBehavior(BSTR			bstrProperty,
							ActorBvrFlags	eFlags,
							ActorBvrType	eType,
							VARIANT		*pvarRetBvr)
{
	if (NULL == bstrProperty)
	{
		DPF_ERR("Invalid property name passed to getActorBehavior");
		return SetErrorInfo(E_POINTER);
	}

	VariantInit(pvarRetBvr);

    // Attempt to locate the appropriate track for this behavior
    CBvrTrack *ptrack = NULL;
    HRESULT hr = GetTrack(bstrProperty, eType, &ptrack);
    if (FAILED(hr))
    {
        DPF_ERR("Could not get a track for added bvr");
        return hr;
    }

    // Request the behavior from it
	IDABehavior *pResult = NULL;
    hr = ptrack->GetBvr(eFlags, &pResult);
    if (FAILED(hr))
    {
        DPF_ERR("Could not get intermediate bvr");
        return SetErrorInfo(hr);
    }

    // All is well.  Set it into return variant
	V_VT(pvarRetBvr) = VT_UNKNOWN;
	V_UNKNOWN(pvarRetBvr) = pResult;

    return hr;
}

//*****************************************************************************

STDMETHODIMP 
CActorBvr::addBehaviorFragment(BSTR           bstrPropertyName, 
                               IUnknown      *punkAction,
                               IUnknown      *punkActive,
							   IUnknown	     *punkTimeline,
                               ActorBvrFlags  eFlags,
                               ActorBvrType   eType)
{
	return E_NOTIMPL;
} // addBehavior

//*****************************************************************************

STDMETHODIMP 
CActorBvr::addBehaviorFragmentEx(BSTR           bstrPropertyName, 
                                 IUnknown      *punkAction,
                                 IUnknown      *punkActive,
							     IUnknown	   *punkTimeline,
                                 ActorBvrFlags  eFlags,
                                 ActorBvrType   eType,
								 IDispatch		*pdispBehaviorElement,
								 long			*pCookie)
{
	//do not allow fragment adding unless we are processing
	//  rebuild requests
	if( !m_bPendingRebuildsUpdating )
	{
		DPF_ERR( "AddBehaivorFragmentEx called outside the context of a rebuild.");
		DPF_ERR( "You should call requestRebuild and then wait for the call to buildBehaviorFragments." );
		return E_UNEXPECTED;
	}

    if (NULL == bstrPropertyName)
    {
        DPF_ERR("Invalid property name passed to AddBvr");
        return SetErrorInfo(E_POINTER);
    }
    if (NULL == punkAction)
    {
        DPF_ERR("Invalid DA behavior passed to AddBvr");
        return SetErrorInfo(E_POINTER);
    }
    IDABehavior *pdabvrAction = NULL;
    HRESULT hr = punkAction->QueryInterface( IID_TO_PPV(IDABehavior, &pdabvrAction) );
    if (FAILED(hr))
    {
        DPF_ERR("Could not QI for DA behavior");
        return SetErrorInfo(hr);
    }
    if (NULL == punkActive)
    {
        DPF_ERR("Invalid DA boolean passed to AddBvr");
        ReleaseInterface(pdabvrAction);
        return SetErrorInfo(E_POINTER);
    }
    IDABoolean *pdaboolActive = NULL;
    hr = punkActive->QueryInterface(IID_TO_PPV(IDABoolean, &pdaboolActive));
    if (FAILED(hr))
    {
        DPF_ERR("Could not QI for DA behavior");
        ReleaseInterface(pdabvrAction);
        return SetErrorInfo(hr);
    }

	if (NULL == punkTimeline)
	{
		ReleaseInterface(pdabvrAction);
		ReleaseInterface(pdaboolActive);
		return SetErrorInfo(E_POINTER);
	}
	IDANumber *pdanumTimeline = NULL;
	hr = punkTimeline->QueryInterface(IID_TO_PPV(IDANumber, &pdanumTimeline));
	if (FAILED(hr))
	{
		ReleaseInterface(pdabvrAction);
		ReleaseInterface(pdaboolActive);
		return SetErrorInfo(hr);
	}

    // BUGBUG (ColinMc): Need validation on flags and type

    // Attempt to locate the appropriate track for this behavior
    CBvrTrack *ptrack = NULL;
    hr = GetTrack(bstrPropertyName, eType, &ptrack);
    if (FAILED(hr))
    {
        DPF_ERR("Could not get a track for added bvr");
        ReleaseInterface(pdabvrAction);
        ReleaseInterface(pdaboolActive);
		ReleaseInterface(pdanumTimeline);
        return hr;
    }

    // Now add the new behavior fragment to the track
    hr = ptrack->AddBvrFragment(eFlags, pdabvrAction, pdaboolActive, pdanumTimeline, pdispBehaviorElement, pCookie );
	ReleaseInterface(pdabvrAction);
	ReleaseInterface(pdaboolActive);
	ReleaseInterface(pdanumTimeline);
    if (FAILED(hr))
    {
        DPF_ERR("Could not add the behavior fragment to the track");
        return SetErrorInfo(hr);
    }

	//keep a mapping from the cookie to the track that it was added to
	//  and the type. (needed for remove)
	m_mapCookieToTrack.Insert( (*pCookie), ptrack, eFlags );

    // All is well.
    return hr;
} // addBehavior

//*****************************************************************************

STDMETHODIMP
CActorBvr::removeBehaviorFragment( long cookie )
{
	if( m_bRebuildListLockout || m_fUnloading )
		return E_UNEXPECTED;

	//you can't remove the invalid cookie.
	if( cookie == 0 )
		return E_FAIL;

	HRESULT hr = S_OK;

	IHTMLElement *pelemParent =  NULL;


	CCookieMap::CCookieData *pdata = NULL;


	//if we are not in edit mode
	if( !m_bEditMode )
	{
		//use the queue for removals
		
		//if we are not currently running the list of rebuilds
		if( !m_bPendingRebuildsUpdating )
		{
			hr = EnsureBodyPropertyMonitorAttached();
			CheckHR( hr, "Failed to ensure that the body Poperty monitor was attached", end );

			//save this removal until the next update.
			CBehaviorFragmentRemoval *pNewRemoval = new CBehaviorFragmentRemoval( cookie );
			CheckPtr( pNewRemoval, hr, E_OUTOFMEMORY, "Ran out of memory trying to allocate a behavior removal", end );

			m_listPendingRemovals.push_back( pNewRemoval );

			goto end;

		}
	}

	pdata = m_mapCookieToTrack.GetDataFor( cookie );
	CheckPtr( pdata, hr, E_FAIL, "Failed to find a track for the given cookie in remove", end);

	hr = pdata->m_pTrack->RemoveBvrFragment( pdata->m_eFlags, cookie );
	CheckHR( hr, "Failed to remove a behavior fragment from its track", end );

	hr = GetHTMLElement()->get_parentElement( &pelemParent );

	if( pelemParent != NULL && !m_bPendingRebuildsUpdating )
	{
		hr = rebuildNow();
		CheckHR( hr, "Failed to rebuild the actor behavior after a behavior was removed.", end );
	}

end:
	ReleaseInterface( pelemParent );

	return hr;
}

//*****************************************************************************

STDMETHODIMP
CActorBvr::requestRebuild( IDispatch *pdispBehaviorElement )
{

	LMTRACE2( 1, 1000, L"Rebuild requested for element distpatch <%p> on Actor <%p>\n", pdispBehaviorElement, this );

	HRESULT hr = S_OK;
	
	if( pdispBehaviorElement == NULL )
		return E_INVALIDARG;

	if( m_bRebuildListLockout )
		return E_UNEXPECTED;

	//if there is a rebuild already pending for this dispatch then 
	// remove it

	//we have to use IUnknown to compare pointers because Trident returns different pointers
	//  for IDispatch.
	IUnknown *punkBehaviorElement = NULL;

	hr = pdispBehaviorElement->QueryInterface( IID_TO_PPV( IUnknown, &punkBehaviorElement ) );
	if( FAILED( hr ) )
	{
		DPF_ERR("Failed to QI IDisp for IUnknown !!?!" );
		return hr;
	}
	
	//loop through the pending rebuild requests removing any requests for this disp.
	BehaviorRebuildList::iterator iterCurRebuild = m_listPendingRebuilds.begin();
	
	for( iterCurRebuild = m_listPendingRebuilds.begin(); 
		 iterCurRebuild != m_listPendingRebuilds.end(); 		 	
		 iterCurRebuild ++ )
	{
		if( (*iterCurRebuild)->IsRebuildFor( punkBehaviorElement ) )
		{
            delete (*iterCurRebuild);
            (*iterCurRebuild) = NULL;
			//erase the rebuild request
			m_listPendingRebuilds.erase( iterCurRebuild );
			//there can be only one.
			break;
		}
	}

	ReleaseInterface( punkBehaviorElement );

	//add a new request at the end of the queue.
	
	CBehaviorRebuild *pNewRequest = new CBehaviorRebuild( pdispBehaviorElement );

	//if we are not currently updating the pending rebuild list
	if( !m_bPendingRebuildsUpdating )
	{
		EnsureBodyPropertyMonitorAttached();
		//add this request to the pending list
		m_listPendingRebuilds.push_back( pNewRequest );

		if( m_bEditMode )
		{
			//request that the containing app call us back to 
			// rebuild
			RequestRebuildFromExternal();
		}

	}
	else
	{
		//add this request to the update pending list so it will
		// get added after the update has completed
		m_listUpdatePendingRebuilds.push_back( pNewRequest );
	}

	return S_OK;
}

//*****************************************************************************

STDMETHODIMP
CActorBvr::cancelRebuildRequests( IDispatch *pdispBehaviorElement )
{
	if( pdispBehaviorElement == NULL )
		return E_FAIL;

	HRESULT hr = S_OK;

	IUnknown *punkBehaviorElement = NULL;

	hr = pdispBehaviorElement->QueryInterface( IID_TO_PPV( IUnknown, &punkBehaviorElement ) );
	if( FAILED( hr ) )
	{
		DPF_ERR("Failed to QI IDisp for IUnknown !!?!" );
		return hr;
	}

	//loop through the pending rebuild requests removing any requests for this disp.
	BehaviorRebuildList::iterator iterCurRebuild = m_listPendingRebuilds.begin();

	for( iterCurRebuild = m_listPendingRebuilds.begin(); 
		 iterCurRebuild != m_listPendingRebuilds.end(); 		 	
		 iterCurRebuild ++ )
	{
		if( (*iterCurRebuild)->IsRebuildFor( punkBehaviorElement ) )
		{
            delete (*iterCurRebuild);
            (*iterCurRebuild) = NULL;
			//erase the rebuild request
			m_listPendingRebuilds.erase( iterCurRebuild );
			//there can be only one
			break;
		}
	}

	ReleaseInterface( punkBehaviorElement );

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::rebuildNow()
{
	HRESULT hr = S_OK;

	hr = ProcessPendingRebuildRequests();
	CheckHR( hr, "Failed to rebuild the actor", end );

end:
	return hr;
}

//*****************************************************************************

STDMETHODIMP
CActorBvr::getStatic( BSTR bstrTrackName, VARIANT *varRetStatic )
{
	if( bstrTrackName == NULL || varRetStatic == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	CBvrTrack *ptrack = NULL;

	::VariantClear( varRetStatic );
	
	//find the track for bstrTrackName
	hr = FindTrackNoType( bstrTrackName, &ptrack );
	//if the track was found
	if( ptrack != NULL && ptrack->IsAnimated() )
	{
		//get the static value from the track
		hr = ptrack->GetStatic( varRetStatic );
		CheckHR( hr, "Failed to get the static from a track", end );
		//return it
	}
	else //else the track was not found
	{
		//just return null;
		hr = E_UNEXPECTED;
	}
end:

	return hr;
}

//*****************************************************************************

STDMETHODIMP
CActorBvr::setStatic( BSTR bstrTrackName, VARIANT varStatic )
{
	if( bstrTrackName == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	CBvrTrack *ptrack = NULL;
	//find the track named bstrTrackName
	hr = FindTrackNoType( bstrTrackName, &ptrack );
	CheckHR( hr, "Failed to find the track in setStatic", end );

	//if the track was found
	if( ptrack != NULL )
	{
		if( V_VT( &varStatic ) == VT_NULL )
		{
			if( !ptrack->IsOn() )
			{
				ptrack->UpdateStaticBvr();
			}
		}
		else if( V_VT( &varStatic ) == VT_EMPTY )
		{
			if( ptrack->IsOn() )
			{
				hr = S_OK;
			}
			else
			{
				hr = S_FALSE;
			}
		}
		else
		{
			//set the new static value into the track
			hr = ptrack->PutStatic( &varStatic );
			CheckHR( hr, "Failed to set the static", end );
		}
	}
	else//else the track was not found
	{
		//TODO: do we create the track here?
		hr = E_UNEXPECTED;
	}

end:
	return hr;
}

//*****************************************************************************

STDMETHODIMP
CActorBvr::getDynamic( BSTR bstrTrackName, VARIANT *varRetDynamic )
{
	if( bstrTrackName == NULL || varRetDynamic == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	CBvrTrack *ptrack = NULL;

	::VariantClear( varRetDynamic );
	
	//find the track for bstrTrackName
	hr = FindTrackNoType( bstrTrackName, &ptrack );
	//if the track was found
	if( ptrack != NULL  && ptrack->IsAnimated() )
	{
		//get the static value from the track
		hr = ptrack->GetDynamic( varRetDynamic );
		CheckHR( hr, "Failed to get the static from a track", end );
		//return it
	}
	else //else the track was not found
	{
		//just return null;
		hr = E_UNEXPECTED;
	}
end:

	return hr;
}

//*****************************************************************************

STDMETHODIMP
CActorBvr::applyStatics( )
{
	HRESULT hr = S_OK;
	//for each track
    for (CBvrTrack *ptrackCurrent = m_ptrackHead;
         NULL != ptrackCurrent;
         ptrackCurrent = ptrackCurrent->m_pNext)
    {

		//if the track is active
		if( ptrackCurrent->IsOn() )
		{
			//apply its static value to the track
			hr = ptrackCurrent->ApplyStatic();
			if( FAILED( hr ) )
			{
				DPF_ERR("Failed to apply the static for a track" );
			}
		}
	}
	
	return S_OK;
}

//*****************************************************************************

STDMETHODIMP
CActorBvr::applyDynamics( )
{
	HRESULT hr = S_OK;
	//for each track
    for (CBvrTrack *ptrackCurrent = m_ptrackHead;
         NULL != ptrackCurrent;
         ptrackCurrent = ptrackCurrent->m_pNext)
    {

		//if the track is active
		if( ptrackCurrent->IsOn() )
		{
			//apply its synamic value to the track
			hr = ptrackCurrent->ApplyDynamic();
			if( FAILED( hr ) )
			{
				DPF_ERR("Failed to apply the dynamic for a track" );
			}
		}
	}
	
	return S_OK;
}

//*****************************************************************************


STDMETHODIMP
CActorBvr::addMouseEventListener(LPUNKNOWN pUnkListener)
{
	return m_pEventManager->AddMouseEventListener( pUnkListener );

} // addMouseListener

//*****************************************************************************

STDMETHODIMP
CActorBvr::removeMouseEventListener(LPUNKNOWN pUnkListener)
{
	return m_pEventManager->RemoveMouseEventListener( pUnkListener );

} // addMouseListener

//*****************************************************************************

HRESULT
CActorBvr::ReleaseAnimation()
{
	HRESULT hr = S_OK;
	//release all of the tracks
	ReleaseTracks();
	//release all of the image infos
	ReleaseImageInfo();
	//detach the event manager
	if( m_pEventManager != NULL )
	{
		m_pEventManager->Deinit();
	}
	//uninit the property sink
	UnInitPropertySink();
	//release the float manager
	ReleaseFloatManager();

	DiscardBvrCache();

	ReleaseInterface( m_pPixelWidth );
	ReleaseInterface( m_pPixelHeight );

	ReleaseInterface( m_pVMLRuntimeStyle );

	return hr;

}//ReleaseAnimation

//*****************************************************************************

void
CActorBvr::ReleaseFinalElementDimensionSampler()
{
	if( m_pFinalElementDimensionSampler != NULL )
	{
		delete m_pFinalElementDimensionSampler;
		m_pFinalElementDimensionSampler = NULL;
	}
}//ReleaseFinalElementDimensionSampler

//*****************************************************************************

void
CActorBvr::ReleaseFloatManager()
{
	if( m_pFloatManager != NULL )
	{
		delete m_pFloatManager;
		m_pFloatManager = NULL;
	}
}//ReleaseFloatManager

//*****************************************************************************

void
CActorBvr::ReleaseEventManager()
{
	HRESULT hr = S_OK;

	if( m_pEventManager != NULL )
	{
		hr = m_pEventManager->Deinit();
		if( FAILED( hr ) )
		{
			DPF_ERR("Failed to deinit event manager before destroying it" );
		}
		delete m_pEventManager;
	}
}

//*****************************************************************************

void
CActorBvr::ReleaseTracks()
{

	m_ptrackTop  = NULL;
	m_ptrackLeft = NULL;
	
	CBvrTrack *ptrackCurrent = m_ptrackHead;
    while (ptrackCurrent != NULL)
    {
        CBvrTrack *ptrackNext = ptrackCurrent->m_pNext;
		ptrackCurrent->Detach();
        delete ptrackCurrent;
        ptrackCurrent = ptrackNext;
    }
	m_ptrackHead = NULL;

}//ReleaseTracks

//*****************************************************************************


HRESULT
CActorBvr::GetComposedBvr(LPWSTR          wzPropertyName,
                          ActorBvrType    eType,
                          IDABehavior   **ppResult)
{
	HRESULT hr = S_OK;

    DASSERT(NULL != wzPropertyName);
	DASSERT(ppResult != NULL);
	*ppResult = NULL;

    // Get the track for this property - forces creation if not there
    CBvrTrack *ptrack = NULL;
	hr = GetTrack(wzPropertyName, eType, &ptrack);
	if (FAILED(hr))
	{
		DPF_ERR("Track mismatch");
		return hr;
	}

	hr = ptrack->GetComposedBvr(ppResult);
    if (FAILED(hr))
    {
        DPF_ERR("Could not get composed behavior for named bvr");
        return hr;
    }

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::GetFinalBvr(LPWSTR          wzPropertyName,
                       ActorBvrType    eType,
                       IDABehavior   **ppResult)
{
	HRESULT hr = S_OK;

    DASSERT(NULL != wzPropertyName);
	DASSERT(ppResult != NULL);
	*ppResult = NULL;

    // Get the track for this property - forces creation if not there
    CBvrTrack *ptrack = NULL;
	hr = GetTrack(wzPropertyName, eType, &ptrack);
	if (FAILED(hr))
	{
		DPF_ERR("Track mismatch");
		return hr;
	}

	hr = ptrack->GetFinalBvr(ppResult);
    if (FAILED(hr))
    {
        DPF_ERR("Could not get final behavior for named bvr");
        return hr;
    }

	return S_OK;
}

//*****************************************************************************
HRESULT
CActorBvr::IsAnimatedElementVML(bool *pResult)
{
	HRESULT hr = S_OK;

	DASSERT(pResult != NULL);
	*pResult = false;

	IHTMLElement *pElement = NULL;
	hr = GetAnimatedElement(&pElement);
	if (FAILED(hr))
		return hr;



	// Just look on the element to see if it supports rotation
	// (Recommended by Robert Parker)
	IDispatch *pDisp = NULL;
	hr = pElement->QueryInterface(IID_TO_PPV(IDispatch, &pDisp));

	if (FAILED(hr))
	{
		ReleaseInterface(pElement);
        DPF_ERR("Error QI'ing IHTMLElement for IDispatch failed");
		return SetErrorInfo(hr);
	}

    DISPID dispid;
	LPWSTR propName = L"rotation";
    hr = pDisp->GetIDsOfNames(IID_NULL, 
                              &propName, 
                              1,
                              LOCALE_SYSTEM_DEFAULT, 
                              &dispid); 
	ReleaseInterface(pDisp);


	//if we failed to find that the element was vml using the more correct method
	if( FAILED( hr ) )
	{
		//try checking the scope name
		IHTMLElement2 *pelem2 = NULL;
		hr = pElement->QueryInterface( IID_TO_PPV( IHTMLElement2, &pelem2 ) );
		ReleaseInterface( pElement );
		if( FAILED( hr ) )
		{
			return hr;
		}

		BSTR bstrScopeName = NULL;

		hr = pelem2->get_scopeName( &bstrScopeName );
		ReleaseInterface( pelem2 );
		if( FAILED( hr ) )
		{
			return hr;
		}

		//we assume that the scopeName for VML shapes is "v" here.  
		if( bstrScopeName != NULL && wcsicmp( bstrScopeName, L"v" ) == 0 )
		{
			*pResult = true;
		}

		SysFreeString( bstrScopeName );
		bstrScopeName = NULL;
	} else {
		ReleaseInterface(pElement);
		*pResult = true;
	}

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::GetRotationFinalBvr(IDATransform2 **ppRotation)
{
    HRESULT hr = S_OK;

    DASSERT(NULL != ppRotation);
    *ppRotation = NULL;

	bool isVML;
	hr = IsAnimatedElementVML(&isVML);
	if (FAILED(hr))
		return hr;

	if (isVML)
	{
		// Do rotation normally through style.rotation
		return S_OK;
	}

    // Get the track for this property
    CBvrTrack *ptrack = NULL;
	hr = FindTrack(L"style.rotation", e_Number, &ptrack);
	if (FAILED(hr))
	{
		DPF_ERR("Track mismatch");
		return hr;
	}

	IDANumber *pNumber = NULL;

	if (ptrack != NULL)
	{
        // We have a track driving the rotation, fetch the composite behavior

		// First, figure out what the original transform is.  We need to do this
		// here rather than in the static bvr of the transform track so that we
		// avoid creating a non-null final bvr when no-one is trying to animate
		// this transform

		//begin a rebuild for the rotation track
		ptrack->BeginRebuild();
		ptrack->StructureChange();
		
		IDANumber *pOriginal = NULL;
		hr = GetOriginalRotation(&pOriginal);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to get original transform");
			return hr;
		}

		// Note: pOriginal is potentially NULL

        IDABehavior *pdabvrTemp = NULL;
		hr = ptrack->GetFinalBvr(pOriginal, &pdabvrTemp);
		ReleaseInterface(pOriginal);
        if (FAILED(hr))
        {
            DPF_ERR("Could not get final behavior for named bvr");
            return SetErrorInfo(hr);
        }

		// Mark the track as something that should not get applied
		ptrack->DoNotApply();

		if( pdabvrTemp != NULL )
		{
			// Now QI for IDANumber
			hr = pdabvrTemp->QueryInterface( IID_TO_PPV(IDANumber, &pNumber) );
			ReleaseInterface(pdabvrTemp);
			if (FAILED(hr))
			{
				DPF_ERR("Could not QI for DANumber for named bvr");
				return SetErrorInfo(hr);
			}
		}
    }
	else
	{
		// No track.  Need to check the style attribute for rotation
		hr = GetOriginalRotation(&pNumber);
		if (FAILED(hr))
			return hr;
	}

	if (pNumber == NULL)
	{
		// This is OK - it just means the overall transform is NULL
		return S_OK;
	}

	//convert the number behavior to a transform bvr
	// Negate it
	IDANumber *pNegNumber = NULL;
	hr = GetDAStatics()->Neg(pNumber, &pNegNumber);
	ReleaseInterface(pNumber);
	if (FAILED(hr))
		return hr;
	pNumber = pNegNumber;
	pNegNumber = NULL;

	// Convert to radians
	IDANumber *pNumberRadians = NULL;
	hr = GetDAStatics()->ToRadians(pNumber, &pNumberRadians);
	ReleaseInterface(pNumber);
	if (FAILED(hr))
		return hr;

	// Turn it into a rotation transform
	hr = GetDAStatics()->Rotate2Anim(pNumberRadians, ppRotation);
	ReleaseInterface(pNumberRadians);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::GetTransformFinalBvr(LPWSTR          wzPropertyName,
                                ActorBvrType    eType,
                                IDATransform2 **ppdabvrTransform)
{
    HRESULT hr = S_OK;

    DASSERT(NULL != ppdabvrTransform);
    *ppdabvrTransform = NULL;

    // Get the track for this property
    CBvrTrack *ptrack = NULL;
	hr = FindTrack(wzPropertyName, eType, &ptrack);
	if (FAILED(hr))
	{
		DPF_ERR("Track mismatch");
		return hr;
	}

	if (ptrack != NULL && ptrack->IsAnimated() )
	{
        // We have a track driving the transform, fetch the composite behavior

		// First, figure out what the original transform is.  We need to do this
		// here rather than in the static bvr of the transform track so that we
		// avoid creating a non-null final bvr when no-one is trying to animate
		// this transform
		IDATransform2 *pOriginal = NULL;
		switch (eType)
		{
		case e_Translation:
			hr = GetOriginalTranslation(&pOriginal);
			break;

		case e_Scale:
			hr = GetOriginalScale(&pOriginal);
			break;

		default:
			hr = E_INVALIDARG;
			break;
		}

		if (FAILED(hr))
		{
			DPF_ERR("Failed to get original transform");
			return hr;
		}

		//if this is the translation track that we are getting force it to rebuild
		// since the top and/or left may have changed
		if( eType == e_Translation )
		{
			ptrack->ForceRebuild();
		}
		else
		{
			//other tracks need to begin rebuild so that they are clean.
			ptrack->BeginRebuild();
			ptrack->StructureChange();
		}

		// Note: pOriginal is potentially NULL
		
		if( eType==e_Scale && pOriginal != NULL )
		{
			IDABoolean *pdaboolTrue;
			hr = GetDAStatics()->get_DATrue( &pdaboolTrue );
			if( FAILED( hr ) )
			{
				ReleaseInterface( pOriginal );
				DPF_ERR("Failed to get DATrue from DAStatics" );
				return SetErrorInfo(hr);
			}
			hr = ptrack->OrWithOnBvr( pdaboolTrue );
			ReleaseInterface( pdaboolTrue );
			if( FAILED( hr ) )
			{
				ReleaseInterface( pOriginal );
				DPF_ERR("Failed to or true with the on bvr for Track" );
				return hr;
			}

		}
		

        IDABehavior *pdabvrTemp = NULL;
		hr = ptrack->GetFinalBvr(pOriginal, &pdabvrTemp);
		ReleaseInterface(pOriginal);

        if (FAILED(hr))
        {
            DPF_ERR("Could not get final behavior for named bvr");
            return SetErrorInfo(hr);
        }

		if (pdabvrTemp != NULL)
		{
			// Now QI for transform2
			hr = pdabvrTemp->QueryInterface( IID_TO_PPV(IDATransform2, ppdabvrTransform) );
			ReleaseInterface(pdabvrTemp);
			if (FAILED(hr))
			{
				DPF_ERR("Could not QI for Transform2 for named bvr");
				return SetErrorInfo(hr);
			}
		}
		else
		{
			*ppdabvrTransform = NULL;
		}
    }
	else
	{
		// No track.  For the cases of rotation and scale we also need to check the
		// actor attributes.  Note that we avoid doing this for translation, since that
		// always returns an original value gleaned from the style
		switch (eType)
		{
		case e_Translation:
			hr = S_OK;
			break;

		case e_Scale:
			hr = GetOriginalScale(ppdabvrTransform);
			break;

		default:
			hr = E_INVALIDARG;
			break;
		}

		if (FAILED(hr))
			return hr;
	}

    return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::GetOriginalTranslation( IDATransform2 **ppdatfmOrig )
{
	HRESULT hr = S_OK;

	DASSERT(ppdatfmOrig != NULL);
	*ppdatfmOrig = NULL;

	// This needs to return a translation of original top and left.  We get it
	// out of the top and left tracks so that we take into account any animation
	// that authors might have done directly on these values.
	IDABehavior *temp = NULL;
	hr = GetComposedBvr(L"style.top", e_Number, &temp);
	if (FAILED(hr))
		return hr;

	IDANumber *top = NULL;
	hr = temp->QueryInterface(IID_TO_PPV(IDANumber, &top));
	ReleaseInterface(temp);
	if (FAILED(hr))
		return hr;

	hr = GetComposedBvr(L"style.left", e_Number, &temp);
	if (FAILED(hr))
	{
		ReleaseInterface(top);
		return hr;
	}

	IDANumber *left = NULL;
	hr = temp->QueryInterface(IID_TO_PPV(IDANumber, &left));
	ReleaseInterface(temp);
	if (FAILED(hr))
	{
		ReleaseInterface(top);
		return hr;
	}

	IDATransform2 *translation = NULL;
	hr = GetDAStatics()->Translate2Anim(left, top, &translation);
	ReleaseInterface(left);
	ReleaseInterface(top);
	if (FAILED(hr))
		return hr;

	*ppdatfmOrig = translation;

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::GetOriginalRotation( IDANumber **ppRotation )
{
	HRESULT hr = S_OK;

	if( ppRotation == NULL )
		return E_INVALIDARG;

	*ppRotation = NULL;

	IDANumber *pNumber = NULL;
	LPWSTR args[] = { L"style", L"rotation" };
	BSTR units = NULL;
	hr = GetElementPropAsDANumber(args, 2, &pNumber, &units);
	if (FAILED(hr))
	{
		// Means there is no rotation argument, return NULL
		return S_OK;
	}

	if (units != NULL)
	{
		IDANumber *pConverted = NULL;
		hr = ConvertToDegrees(pNumber, units, &pConverted);
		if (SUCCEEDED(hr))
		{
			ReleaseInterface(pNumber);
			pNumber = pConverted;
		}

		::SysFreeString(units);
	}

	*ppRotation = pNumber;

	return S_OK;
}

HRESULT
CActorBvr::ConvertToDegrees(IDANumber *pNumber, BSTR units, IDANumber **ppConverted)
{
	HRESULT hr = S_OK;

	// If there were units, we need to convert into degrees
	if (units != NULL)
	{
		if (wcsicmp(units, L"fd") == 0)
		{
			IDANumber *pfdConv = NULL;
			hr = GetDAStatics()->DANumber(65536, &pfdConv);
			if (FAILED(hr))
				return hr;

			hr = GetDAStatics()->Div(pNumber, pfdConv, ppConverted);
			ReleaseInterface(pfdConv);
			
			return hr;
		}
		else if (wcsicmp(units, L"rad") == 0)
		{
			return GetDAStatics()->ToDegrees(pNumber, ppConverted);
		}
		else if (wcsicmp(units, L"grad") == 0)
		{
		}
	}

	// No known units, no conversion
	return E_FAIL;
}


//*****************************************************************************

HRESULT
CActorBvr::GetOriginalScale( IDATransform2 **ppdatfmOrig )
{
	HRESULT hr = S_OK;

	if( ppdatfmOrig == NULL )
		return E_INVALIDARG;

	*ppdatfmOrig = NULL;

    int cReturnedValues;
	float scaleVal[3];


    hr = CUtils::GetVectorFromVariant(&m_varScale, 
                                      &cReturnedValues, 
                                      &(scaleVal[0]), 
                                      &(scaleVal[1]), 
                                      &(scaleVal[2]));

	if (FAILED(hr) || cReturnedValues != 2)
	{
		// This is OK, since it just means they didn't set an appropriate scale.
		return S_OK;
	}

	// Create a scale transform
	hr = GetDAStatics()->Scale2(scaleVal[0]/100.0f, scaleVal[1]/100.0f, ppdatfmOrig);
	if (FAILED(hr))
		return hr;
	
	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::BuildTransformCenter()
{
	//TODO(kurtj): check to see if anyone has set the transform center and use that

	HRESULT hr = S_OK;

	if( m_pTransformCenter != NULL )
		ReleaseInterface( m_pTransformCenter);

	// Currently we just do the default - which is half the original width and height
	// We use m_pOrigWidthHeight.  If this is not set yet it means there's and error
	if (m_pOrigWidthHeight == NULL)
	{
		DPF_ERR("Orig width and height are not set yet");
		return E_FAIL;
	}

	VARIANT varTransCenter;
	VariantInit(&varTransCenter);
	BSTR attrName = ::SysAllocString(L"transformCenter");
	if (attrName != NULL)
	{
		hr = GetHTMLElement()->getAttribute(attrName, 0, &varTransCenter);
		::SysFreeString(attrName);

		if (SUCCEEDED(hr))
		{
			float cx, cy, cz;
			int cValues;

			hr = CUtils::GetVectorFromVariant(&varTransCenter, &cValues, &cx, &cy, &cz);
			VariantClear(&varTransCenter);

			if (SUCCEEDED(hr) && cValues == 2)
			{
				hr = GetDAStatics()->Vector2(cx, cy, &m_pTransformCenter);
				if (SUCCEEDED(hr))
					return S_OK;
			}
		}
	}

	// Scale m_pOrigWidthHeight by .5
	hr = m_pOrigWidthHeight->Mul(.5, &m_pTransformCenter);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to scale center");
		return hr;
	}

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::GetUnitToMeterBvr(BSTR bstrFrom, IDANumber ** ppnumToMeters, double dPixelPerPercent)
{
	HRESULT	hr = S_OK;
	
	IDANumber * pnumMetersPerPixel = NULL;
	IDANumber * pnumPixelPerPercent = NULL;

	hr = GetDAStatics()->get_Pixel( &pnumMetersPerPixel );
	CheckHR(hr, L"GetUnitToMeterBvr failed", done);

	if ( bstrFrom == NULL || wcsicmp(bstrFrom, L"px") == 0 )
	{
		*ppnumToMeters = pnumMetersPerPixel;
		(*ppnumToMeters)->AddRef();
	}
	else if ( wcsicmp(bstrFrom, L"in") == 0 )
		hr = GetDAStatics()->DANumber(METERS_PER_INCH, ppnumToMeters);
	else if ( wcsicmp(bstrFrom, L"cm") == 0 )
		hr = GetDAStatics()->DANumber(0.01, ppnumToMeters);
	else if ( wcsicmp(bstrFrom, L"mm") == 0 )
		hr = GetDAStatics()->DANumber(0.001, ppnumToMeters);
	else if ( wcsicmp(bstrFrom, L"pt") == 0 )
		hr = GetDAStatics()->DANumber(1.0/POINTS_PER_INCH*METERS_PER_INCH, ppnumToMeters);
	else if ( wcsicmp(bstrFrom, L"pc") == 0 )
		hr = GetDAStatics()->DANumber(POINTS_PER_PICA * 1.0/POINTS_PER_INCH * METERS_PER_INCH, ppnumToMeters);
	else if ( wcsicmp(bstrFrom, L"%") == 0 )
	{
		hr = GetDAStatics()->DANumber(dPixelPerPercent, &pnumPixelPerPercent);
		CheckHR(hr, L"GetUnitToMeterBvr failed", done);

		hr = GetDAStatics()->Mul(pnumMetersPerPixel, pnumPixelPerPercent, ppnumToMeters);
		
	}
	// TODO: do the rest: em and ex
	else
		hr = E_FAIL;

	CheckHR(hr, L"GetUnitToMeterBvr failed", done);
	
done:
	ReleaseInterface(pnumMetersPerPixel);
	ReleaseInterface(pnumPixelPerPercent);
	
	return hr;
}

//*****************************************************************************

UnitType
CActorBvr::GetUnitTypeFromString( LPOLESTR strUnits )
{
	if ( strUnits == NULL || wcsicmp( strUnits, L"px" ) == 0 )
		return e_px;
	else if ( wcsicmp(strUnits, L"in") == 0 )
		return e_in;
	else if ( wcsicmp(strUnits, L"cm") == 0 )
		return e_cm;
	else if ( wcsicmp(strUnits, L"mm") == 0 )
		return e_mm;
	else if ( wcsicmp(strUnits, L"pt") == 0 )
		return e_pt;
	else if ( wcsicmp(strUnits, L"pc") == 0 )
		return e_pc;
	else if( wcsicmp(strUnits, L"em") ==  0 )
		return e_em;
	else if( wcsicmp(strUnits, L"ex") ==  0 )
		return e_ex;
	else if( wcsicmp(strUnits, L"%") ==  0 )
		return e_percent;

	return e_unknownUnit;
}

//*****************************************************************************

int
CActorBvr::GetPixelsPerInch( bool fHorizontal )
{
	//Note: we do not cache the pixels per inch here because if someone changes
	// the screen reslolution we would not pick up the change.
	HDC hdc = ::GetDC( NULL );

	int pixelsPerInch = 1;
	
	if( hdc != NULL )
	{
		if( fHorizontal )
		{
			pixelsPerInch = ::GetDeviceCaps( hdc, LOGPIXELSX );
		}
		else
		{
			pixelsPerInch =  ::GetDeviceCaps( hdc, LOGPIXELSY );
		}
		::ReleaseDC( NULL, hdc );
	}

	return pixelsPerInch;
}


//*****************************************************************************

HRESULT
CActorBvr::GetUnitConversionBvr(BSTR bstrFrom, BSTR bstrTo, IDANumber ** ppnumConvert, double dPixelPerPercent)
{
	if ( (bstrFrom == NULL && bstrTo == NULL) ||
		 (bstrFrom != NULL && bstrTo != NULL && wcsicmp(bstrFrom, bstrTo) == 0 ) )
	{
		return GetDAStatics()->DANumber(1.0, ppnumConvert);
	}
	
	HRESULT		hr = S_OK;

	UnitType fromUnits = GetUnitTypeFromString( bstrFrom );
	UnitType toUnits = GetUnitTypeFromString( bstrTo );
	double conversionFactor = 1.0;

	//check for units that we don't yet handle
	if( fromUnits == e_em || toUnits == e_em || 
		fromUnits == e_ex || toUnits == e_ex )
	{
		LMTRACE2( 1, 2, "Unsupported unit conversion from %S to %S\n", bstrFrom, bstrTo );
		return E_FAIL;
	}

	//if we are converting from percent
	if( fromUnits == e_percent )
	{
		//first convert to pixels
		conversionFactor *= dPixelPerPercent;
		//then convert from pixels to the target unit.
		fromUnits = e_px;
	}

	//if the from unit is pixels 
	if( fromUnits == e_px )
	{
		//we need to convert from pixels to inches
		conversionFactor /= ((double)GetPixelsPerInch( true ));
		//then convert from inches to the to unit
		fromUnits = e_in;
	}

	if( fromUnits != toUnits )
	{
		// if the to unit is not pixels 
		if( toUnits == e_px )		
		{
			//multiply the conversion factor by pixels per inch
			conversionFactor *= ((double)(s_unitConversion[fromUnits][e_in].lNum  *  GetPixelsPerInch(true) )) /  
								((double)(s_unitConversion[fromUnits][e_in].lDenom));
		}
		else if( toUnits == e_percent )
		{
			conversionFactor *= ((double)(s_unitConversion[fromUnits][e_in].lNum  *  GetPixelsPerInch(true) )) /  
								((double)(s_unitConversion[fromUnits][e_in].lDenom * dPixelPerPercent ));
		}
		else
		{
			//get the conversion value as a double
			conversionFactor *= ((double) s_unitConversion[fromUnits][toUnits].lNum) / 
								((double)s_unitConversion[fromUnits][toUnits].lDenom);
		}
	}
	
	hr = GetDAStatics()->DANumber( conversionFactor, ppnumConvert );

	return hr;
}

//*****************************************************************************

// REVIEW: this doesn't work if parent width or height is also being animated
HRESULT CActorBvr::GetPixelsPerPercentValue(double& dPixelPerPercentX, double& dPixelPerPercentY)
{
	HRESULT hr = S_OK;
	
	IHTMLElement		*pElement		= NULL;
	IHTMLElement 		*pOffsetParent	= NULL;
	long				lWidth, lHeight;
	
	hr = GetAnimatedElement( &pElement );
	CheckHR( hr, L"GetPixelsPerPercentValue failed", done );
	
	hr = pElement->get_offsetParent( &pOffsetParent );
	CheckHR( hr, L"GetPixelsPerPercentValue failed", done );

	hr = pOffsetParent->get_offsetWidth( &lWidth );
	CheckHR( hr, L"GetPixelsPerPercentValue failed", done );
	
	dPixelPerPercentX = lWidth/100.0;
	
	hr = pOffsetParent->get_offsetHeight( &lHeight );
	CheckHR( hr, L"GetPixelsPerPercentValue failed", done );
	
	dPixelPerPercentY = lHeight/100.0;
	
  done:
	ReleaseInterface(pElement);
	ReleaseInterface(pOffsetParent);

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::ConvertTransformCenterUnits(IDAVector2 ** ppConvertedCenter)
{
	HRESULT	hr	= S_OK;

	// Get top, left, width, height tracks
	CBvrTrack 	*topTrack, *leftTrack, *widthTrack, *heightTrack;
	BSTR		bstrTopUnits, bstrLeftUnits, bstrWidthUnits, bstrHeightUnits;
	
	hr = GetTrack(L"style.top", e_Number, &topTrack);
	if (FAILED(hr))
	{
		DPF_ERR("Track mismatch");
		return hr;
	}
	hr = GetTrack(L"style.left", e_Number, &leftTrack);
	if (FAILED(hr))
	{
		DPF_ERR("Track mismatch");
		return hr;
	}

	hr = GetTrack(L"style.width", e_Number, &widthTrack);
	if (FAILED(hr))
	{
		DPF_ERR("Track mismatch");
		return hr;
	}
	hr = GetTrack(L"style.height", e_Number, &heightTrack);
	if (FAILED(hr))
	{
		DPF_ERR("Track mismatch");
		return hr;
	}
	
	bstrLeftUnits	= ((CNumberBvrTrack *) leftTrack)->GetUnits();
	bstrTopUnits	= ((CNumberBvrTrack *) topTrack)->GetUnits();
	bstrWidthUnits	= ((CNumberBvrTrack *) widthTrack)->GetUnits();
	bstrHeightUnits	= ((CNumberBvrTrack *) heightTrack)->GetUnits();

	double dPercentX = 1.0;
	double dPercentY = 1.0;
	IDANumber * pnumCenterX = NULL;
	IDANumber * pnumCenterY = NULL;
	IDANumber * pnumConvertX = NULL;
	IDANumber * pnumConvertY = NULL;
	IDANumber * pnumX = NULL;
	IDANumber * pnumY = NULL;
	
	// If any units are in percent, we get the pixel per percent value
	if ( ( bstrLeftUnits != NULL && wcsicmp(bstrLeftUnits, L"%") == 0 ) ||
		 ( bstrTopUnits != NULL && wcsicmp(bstrTopUnits, L"%") == 0 ) ||		 
		 ( bstrWidthUnits != NULL && wcsicmp(bstrWidthUnits, L"%") == 0 ) ||		 
		 ( bstrHeightUnits != NULL && wcsicmp(bstrHeightUnits, L"%") == 0 ) )
	{
		hr = GetPixelsPerPercentValue( dPercentX, dPercentY );
		CheckHR(hr, L"Transform center conversion failed", done);
	}
		 
		
	// Get center X & Y, which are in width & height coords

	hr = m_pTransformCenter->get_X(&pnumCenterX);
	CheckHR(hr, L"Transform center conversion failed", done);
		
	hr = m_pTransformCenter->get_Y(&pnumCenterY);
	CheckHR(hr, L"Transform center conversion failed", done);

	hr = GetUnitConversionBvr(bstrWidthUnits, bstrLeftUnits, &pnumConvertX, dPercentX);
	CheckHR(hr, L"Transform center conversion failed", done);
	
	hr = GetUnitConversionBvr(bstrHeightUnits, bstrTopUnits, &pnumConvertY, dPercentY);
	CheckHR(hr, L"Transform center conversion failed", done);

	hr = GetDAStatics()->Mul(pnumCenterX, pnumConvertX, &pnumX);
	CheckHR(hr, L"Transform center conversion failed", done);

	hr = GetDAStatics()->Mul(pnumCenterY, pnumConvertY, &pnumY);
	CheckHR(hr, L"Transform center conversion failed", done);

	hr = GetDAStatics()->Vector2Anim(pnumX, pnumY, ppConvertedCenter);
	CheckHR(hr, L"Transform center conversion failed", done);
	
  done:
	ReleaseInterface(pnumCenterX);
	ReleaseInterface(pnumCenterY);
	ReleaseInterface(pnumConvertX);
	ReleaseInterface(pnumConvertY);
	ReleaseInterface(pnumX);
	ReleaseInterface(pnumY);
	
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::TransformTrackIsDirty( DWORD *pdwState )
{
	HRESULT hr = S_FALSE;

	if( pdwState == NULL )
		return E_INVALIDARG;

	(*pdwState) = 0;
	
	
	CBvrTrack *ptrack = NULL;
	hr = FindTrack( L"translation", e_Translation, &ptrack );
	CheckHR( hr, "Failed to find the track", end );
	if( ptrack != NULL && ptrack->IsDirty() )
	{
		(*pdwState) |= TRANSLATION_DIRTY;
		hr = S_OK; //true
	}

	hr = FindTrack( L"scale", e_Scale, &ptrack );
	CheckHR( hr, "Failed to find the track", end );
	if( ptrack != NULL && ptrack->IsDirty() )
	{
		(*pdwState) |= SCALE_DIRTY;
		hr = S_OK; //true
	}

	hr = FindTrack( L"style.rotation", e_Number, &ptrack );
	CheckHR( hr, "Failed to find the track", end );
	if( ptrack != NULL && ptrack->IsDirty() )
	{
		(*pdwState) |= ROTATION_DIRTY;
		hr = S_OK; //true
	}

	hr = FindTrack( L"style.top", e_Number, &ptrack );
	CheckHR( hr, "Failed to find the track", end );
	if( ptrack != NULL && ptrack->IsDirty() )
	{
		(*pdwState) |= TOP_DIRTY;
		hr = S_OK; //true
	}

	hr = FindTrack( L"style.left", e_Number, &ptrack );
	CheckHR( hr, "Failed to find the track", end );
	if( ptrack != NULL && ptrack->IsDirty() )
	{
		(*pdwState) |= LEFT_DIRTY;
		hr = S_OK; //true
	}

	hr = FindTrack( L"style.width", e_Number, &ptrack );
	CheckHR( hr, "Failed to find the track", end );
	if( ptrack != NULL && ptrack->IsDirty() )
	{
		(*pdwState) |= WIDTH_DIRTY;
		hr = S_OK; //true
	}
	
	hr = FindTrack( L"style.height", e_Number, &ptrack );
	CheckHR( hr, "Failed to find the track", end );
	if( ptrack != NULL && ptrack->IsDirty() )
	{
		(*pdwState) |= HEIGHT_DIRTY;
		hr = S_OK; //true
	}

end:
	return hr;
	
}

//*****************************************************************************

bool
CActorBvr::IsAnyTrackDirty()
{
	bool fTrackDirty = false ;
	
	for (CBvrTrack *ptrackCurrent = m_ptrackHead;
         ptrackCurrent != NULL;
         ptrackCurrent = ptrackCurrent->m_pNext)
    {
    	if( ptrackCurrent->IsDirty() )
    	{
    		fTrackDirty = true;
    		break;
    	}
    }

    return fTrackDirty;
}

//*****************************************************************************


HRESULT
CActorBvr::ImageTrackIsDirty()
{
	HRESULT hr = S_FALSE;

	CBvrTrack *ptrack = NULL;
	
	hr = FindTrack( L"image", e_Image, &ptrack );
	//ignore the hr. If it is E_FAIL then the track was not found
	//  which means it can't be dirty.
	if( ptrack != NULL && ptrack->IsDirty() )
		return S_OK;
		
	return S_FALSE;
}

//*****************************************************************************


HRESULT
CActorBvr::ApplyTransformTracks()
{
	HRESULT hr = S_OK;

	DiscardBvrCache();

	// Get top, left, width, height tracks
	CBvrTrack *topTrack, *leftTrack, *widthTrack, *heightTrack;
	bool	fLeftWasAnimated = false;
	bool	fTopWasAnimated = false;
	bool	fWidthWasAnimated = false;
	bool	fHeightWasAnimated = false;

	hr = GetTrack(L"style.top", e_Number, &topTrack);
	if (FAILED(hr))
	{
		DPF_ERR("Track mismatch");
		return hr;
	}

	m_ptrackTop = topTrack;

	fTopWasAnimated = m_ptrackTop->IsAnimated();

	//force the track to be rebuilt
	hr = topTrack->ForceRebuild();
	if( FAILED(hr) )
	{
		DPF_ERR("failed to force the track to rebuild" );
		return hr;
	}
	
	hr = GetTrack(L"style.left", e_Number, &leftTrack);
	if (FAILED(hr))
	{
		DPF_ERR("Track mismatch");
		return hr;
	}

	m_ptrackLeft = leftTrack;

	fLeftWasAnimated = m_ptrackLeft->IsAnimated();

	//force the track to be rebuilt
	hr = leftTrack->ForceRebuild();
	if( FAILED(hr) )
	{
		DPF_ERR("failed to force the track to rebuild" );
		return hr;
	}


	hr = GetTrack(L"style.width", e_Number, &widthTrack);
	if (FAILED(hr))
	{
		DPF_ERR("Track mismatch");
		return hr;
	}

	fWidthWasAnimated = widthTrack->IsAnimated();

	//force the track to be rebuilt
	hr = widthTrack->ForceRebuild();
	if( FAILED(hr) )
	{
		DPF_ERR("failed to force the track to rebuild" );
		return hr;
	}

	hr = GetTrack(L"style.height", e_Number, &heightTrack);
	if (FAILED(hr))
	{
		DPF_ERR("Track mismatch");
		return hr;
	}

	fHeightWasAnimated = heightTrack->IsAnimated();
	//force the track to be rebuilt
	hr = heightTrack->ForceRebuild();
	if( FAILED(hr) )
	{
		DPF_ERR("failed to force the track to rebuild" );
		return hr;
	}

	// Build the transform behaviors.
	// NOTE!!: These might be set to NULL if there are no attributes set and
	// no tracks.  Program accordingly.
    hr = GetTransformFinalBvr(L"scale", e_Scale, &m_pScale);
    if (FAILED(hr))
    {
        DPF_ERR("Could not get the scale track final bvr");
        return hr;
    }

    hr = GetTransformFinalBvr(L"translation", e_Translation, &m_pTranslate);
    if (FAILED(hr))
    {
        DPF_ERR("Could not get the translate track final bvr");
        DiscardBvrCache();
        return hr;
    }

	// Note: rotation is special.  It is done through the style.rotation track.
	hr = GetRotationFinalBvr(&m_pRotate);
	if (FAILED(hr))
	{
		DiscardBvrCache();
		return hr;
	}


	// Build the original (composed) leftTop and widthHeight

	// Get composed top and left
	IDANumber *compTop;
	IDANumber *compLeft;
	IDABehavior *temp;
	
	hr = topTrack->GetComposedBvr(&temp);
	if (FAILED(hr))
		return hr;
		
	hr = temp->QueryInterface(IID_TO_PPV(IDANumber, &compTop));
	ReleaseInterface(temp);
	if (FAILED(hr))
		return hr;
		
	hr = leftTrack->GetComposedBvr(&temp);
	if (FAILED(hr))
	{
		ReleaseInterface(compTop);
		return hr;
	}
	hr = temp->QueryInterface(IID_TO_PPV(IDANumber, &compLeft));
	ReleaseInterface(temp);
	if (FAILED(hr))
	{
		ReleaseInterface(compTop);
		return E_FAIL;
	}

	// Put them into a Point2
	hr = GetDAStatics()->Point2Anim(compLeft, compTop, &m_pOrigLeftTop);
	ReleaseInterface(compTop);
	ReleaseInterface(compLeft);
	if (FAILED(hr))
		return hr;
	
	// Get composed width and height
	IDANumber *compWidth;
	IDANumber *compHeight;

	hr = widthTrack->GetComposedBvr(&temp);
	if (FAILED(hr))
		return hr;

	hr = temp->QueryInterface(IID_TO_PPV(IDANumber, &compWidth));
	ReleaseInterface(temp);
	if (FAILED(hr))
		return hr;

	hr = heightTrack->GetComposedBvr(&temp);
	if (FAILED(hr))
	{
		ReleaseInterface(compWidth);
		return hr;
	}
	hr = temp->QueryInterface(IID_TO_PPV(IDANumber, &compHeight));
	ReleaseInterface(temp);
	if (FAILED(hr))
	{
		ReleaseInterface(compWidth);
		return E_FAIL;
	}

	// Put them into a Vector2
	hr = GetDAStatics()->Vector2Anim(compWidth, compHeight, &m_pOrigWidthHeight);
	ReleaseInterface(compWidth);
	ReleaseInterface(compHeight);
	if (FAILED(hr))
		return hr;

	if( m_pPixelWidth == NULL || m_pPixelHeight == NULL )
	{
		// Create the pixelWidth and pixelHeight behaviors
		hr = InitPixelWidthHeight();
		if (FAILED(hr))
			return hr;

		IDA2Statics *pStatics2 = NULL;
		hr = GetDAStatics()->QueryInterface(IID_TO_PPV(IDA2Statics, &pStatics2));
		if (FAILED(hr))
			return hr;

		if( m_pPixelWidth == NULL )
		{
			hr = pStatics2->ModifiableNumber(m_pixelWidth, &m_pPixelWidth);
			if (FAILED(hr))
			{
				ReleaseInterface(pStatics2);
				return hr;
			}
		}

		if( m_pPixelHeight == NULL )
		{
			hr = pStatics2->ModifiableNumber(m_pixelHeight, &m_pPixelHeight);
		
			if (FAILED(hr))
			{
				ReleaseInterface( pStatics2 );
				return hr;
			}
		}
		ReleaseInterface(pStatics2);
	}

	
	
	// Compute origBoundsMin and Max
	IDAVector2 *pWidthHeight = NULL;
	hr = GetDAStatics()->Vector2Anim(m_pPixelWidth, m_pPixelHeight, &pWidthHeight);
	if (FAILED(hr))
		return hr;

	IDAVector2 *pHalfWidthHeight = NULL;
	hr = pWidthHeight->Mul(.5, &pHalfWidthHeight);
	ReleaseInterface(pWidthHeight);
	if (FAILED(hr))
		return hr;

	IDANumber *pPixel = NULL;
	hr = GetDAStatics()->get_Pixel(&pPixel);
	if (FAILED(hr))
	{
		ReleaseInterface(pHalfWidthHeight);
		return hr;
	}

	IDAVector2 *pTemp = NULL;
	hr = pHalfWidthHeight->MulAnim(pPixel, &pTemp);
	ReleaseInterface(pHalfWidthHeight);
	ReleaseInterface(pPixel);
	if (FAILED(hr))
		return hr;
	pHalfWidthHeight = pTemp;
	pTemp = NULL;

	// Scale this if necessary
	if (m_pScale != NULL && CheckBitSet( m_dwCurrentState, PIXEL_SCALE_ON ) )
	{
		hr = pHalfWidthHeight->Transform(m_pScale, &pTemp);
		ReleaseInterface(pHalfWidthHeight);
		if (FAILED(hr))
			return hr;
		pHalfWidthHeight = pTemp;
		pTemp = NULL;
	}

	IDAPoint2 *pOrigin = NULL;
	hr = GetDAStatics()->get_Origin2(&pOrigin);
	if (FAILED(hr))
	{
		ReleaseInterface(pHalfWidthHeight);
		return hr;
	}

	hr = GetDAStatics()->SubPoint2Vector(pOrigin, pHalfWidthHeight, &m_pBoundsMin);
	if (FAILED(hr))
	{
		ReleaseInterface(pOrigin);
		ReleaseInterface(pHalfWidthHeight);
		return hr;
	}

	hr = GetDAStatics()->AddPoint2Vector(pOrigin, pHalfWidthHeight, &m_pBoundsMax);
	ReleaseInterface(pOrigin);
	ReleaseInterface(pHalfWidthHeight);
	if (FAILED(hr))
		return hr;

	// See if we need to do some scaling on width and height
	if (CheckBitNotSet( m_dwCurrentState, PIXEL_SCALE_ON ) && m_pScale != NULL)
	{
		// Transform widthHeight by scale
		IDAVector2 *vecScaled = NULL;
		hr = m_pOrigWidthHeight->Transform(m_pScale, &vecScaled);
		if (FAILED(hr))
			return hr;

		// Get scaled width into finalWidth
		IDANumber *finalWidth = NULL;
		hr = vecScaled->get_X(&finalWidth);
		if (FAILED(hr))
		{
			ReleaseInterface(vecScaled);
			return hr;
		}

		// Get scaled height into finalHeight
		IDANumber *finalHeight = NULL;
		hr = vecScaled->get_Y(&finalHeight);
		ReleaseInterface(vecScaled);
		if (FAILED(hr))
		{
			ReleaseInterface(finalWidth);
			return hr;
		}

		// Set finalWidth on the width track
		hr = widthTrack->SetFinalBvr(finalWidth);
		ReleaseInterface(finalWidth);
		if (FAILED(hr))
		{
			ReleaseInterface(finalHeight);
			DPF_ERR("Failed to set final width");
			return hr;
		}

		// Set finalHeight on the height track
		hr = heightTrack->SetFinalBvr(finalHeight);
		ReleaseInterface(finalHeight);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to set final height");
			return hr;
		}

		//the width and the height are now modified by the scale track
		// or its on bvr with the on bvrs of width and height
		CBvrTrack* pScaleTrack;
		hr = FindTrack( L"scale", e_Scale, &pScaleTrack );
		if( FAILED( hr ) )
		{
			DPF_ERR("Failed to get the scale track" );
			return hr;
		}

		IDABoolean *pdaboolScaleOn;
		if( pScaleTrack != NULL )
		{
			hr = pScaleTrack->GetTrackOn( &pdaboolScaleOn );
			if( FAILED( hr ) )
			{
				DPF_ERR("Failed to get the on bvr from the scale track" );
				return hr;
			}
		}
		else //there is no scale track but there is a static scale
		{
			hr = GetDAStatics()->get_DATrue( &pdaboolScaleOn );
			if( FAILED( hr ) )
			{
				DPF_ERR("Failed to get DATrue from DAStatics" );
				return hr;
			}
		}

		hr = widthTrack->OrWithOnBvr( pdaboolScaleOn );
		if( FAILED(hr))
		{
			ReleaseInterface( pdaboolScaleOn );
			DPF_ERR("Failed to or the on bvr for scale with the on bvr for width");
			return hr;
		}

		hr = heightTrack->OrWithOnBvr( pdaboolScaleOn );
		if( FAILED(hr))
		{
			ReleaseInterface( pdaboolScaleOn );
			DPF_ERR("Failed to or the on bvr for scale with the on bvr for height");
			return hr;
		}

		ReleaseInterface( pdaboolScaleOn );
	}
	else
	{
/*
		// Final widthHeight equals original widthHeight
		m_pFinalWidthHeight = m_pOrigWidthHeight;
		m_pFinalWidthHeight->AddRef();
*/
		// TODO (markhal): Should set this onto the track, and set a flag that it
		// shouldn't get applied

		if( fWidthWasAnimated )
			widthTrack->ApplyStatic();
		if( fHeightWasAnimated )
			heightTrack->ApplyStatic();
	}

	// Compute top and left if necessary
	if (m_pTranslate != NULL || (CheckBitNotSet( m_dwCurrentState, PIXEL_SCALE_ON) && m_pScale != NULL))
	{
		// First figure out a point that represents the animated top and left.
		// If there is a translation transform this is found by mapping (0, 0)
		// through the transform, since in creating that transform we already
		// figured all of this out.  If there is no translation we just
		// use m_pOrigLeftTop
		IDAPoint2 *pointTranslated = NULL;
		if (m_pTranslate != NULL)
		{
			IDAPoint2 *zero = NULL;
			hr = GetDAStatics()->get_Origin2(&zero);
			if (FAILED(hr))
				return hr;

			hr = zero->Transform(m_pTranslate, &pointTranslated);
			ReleaseInterface(zero);
			if (FAILED(hr))
				return hr;

			//at this point we know that a translation has changed the top
			// left, so or the onbvr for the translation track with the onbvrs
			// for top and left
			CBvrTrack *pTranslationTrack;
			hr = GetTrack(L"translation", e_Translation, &pTranslationTrack );
			if( FAILED( hr ) )
			{
				DPF_ERR("Failed to get the translation track" );
				return hr;
			}

			IDABoolean *pdaboolTranslationOn;
			hr = pTranslationTrack->GetTrackOn( &pdaboolTranslationOn );
			if( FAILED( hr ) )
			{
				DPF_ERR("Failed to get the on bvr for the translation track");
				return hr;
			}

			hr = leftTrack->OrWithOnBvr( pdaboolTranslationOn );
			if( FAILED( hr ) )
			{
				ReleaseInterface( pdaboolTranslationOn );
				DPF_ERR("Failed to or the on bvr for translation with the on bvr for left" );
				return hr;
			}

			hr = topTrack->OrWithOnBvr( pdaboolTranslationOn );
			if( FAILED( hr ) )
			{
				ReleaseInterface( pdaboolTranslationOn );
				DPF_ERR("Failed to or the on bvr for translation with the on bvr for top" );
				return hr;
			}

			ReleaseInterface( pdaboolTranslationOn );
		}
		else
		{
			pointTranslated = m_pOrigLeftTop;
			pointTranslated->AddRef();
		}

		// Adjust for scaling of transformCenter
		// NOTE: I am going to implement a version that keeps the original top/left
		// on the motion path.  I am not convinced that we want the transformCenter
		// to suddenly jump to the motion path (markhal)
		if (CheckBitNotSet( m_dwCurrentState, PIXEL_SCALE_ON) && m_pScale != NULL)
		{
			// What we want to do is add transformCenter - Scale * transformCenter to pointTranslated

			// Ensure transformCenter is computed
			hr = BuildTransformCenter();
			if( FAILED(hr) )
			{
				ReleaseInterface(pointTranslated);
				DPF_ERR("Could not build the transform center");
				return SetErrorInfo(hr);
			}

			IDAVector2 * pConvertedCenter = NULL;
			hr = ConvertTransformCenterUnits(&pConvertedCenter);
			// If we couldn't convert the transform center, just use the unconverted center
			if (FAILED(hr))
			{
				DPF_ERR("Could not convert the transform center");
				pConvertedCenter = m_pTransformCenter;
				pConvertedCenter->AddRef();
			}

			
			// Add it to pointTranslated
			IDAPoint2 *temp = NULL;
			hr = GetDAStatics()->AddPoint2Vector(pointTranslated, pConvertedCenter, &temp);
			ReleaseInterface( pointTranslated );
			if (FAILED(hr))
			{
				ReleaseInterface(pConvertedCenter);
				return hr;
			}
			pointTranslated = temp;
			temp = NULL;

			// Scale center
			IDAVector2 *scaledCenter = NULL;
			hr = pConvertedCenter->Transform(m_pScale, &scaledCenter);
			ReleaseInterface(pConvertedCenter);
			if (FAILED(hr))
			{
				ReleaseInterface(pointTranslated);
				return hr;
			}

			// Subtract it
			hr = GetDAStatics()->SubPoint2Vector(pointTranslated, scaledCenter, &temp);
			ReleaseInterface(scaledCenter);
			ReleaseInterface( pointTranslated );
			if (FAILED(hr))
			{
				return hr;
			}
			pointTranslated = temp;
			temp = NULL;

			//top and left are now modified by the scale transform so or the onbvr for
			// the scale track with the on bvr for the top and left tracks.
			
			CBvrTrack* pScaleTrack;
			hr = FindTrack( L"scale", e_Scale, &pScaleTrack );
			if( FAILED( hr ) )
			{
				DPF_ERR("Failed to get the scale track" );
				return hr;
			}

			IDABoolean *pdaboolScaleOn;
			if( pScaleTrack != NULL )
			{
				hr = pScaleTrack->GetTrackOn( &pdaboolScaleOn );
				if( FAILED( hr ) )
				{
					DPF_ERR("Failed to get the on bvr from the scale track" );
					return hr;
				}
			}
			else //there is no scale track, but there is a static scale
			{
				//there is always a scale active( the static one )
				hr = GetDAStatics()->get_DATrue( &pdaboolScaleOn );
				if( FAILED( hr ) )
				{
					DPF_ERR("Failed to get DATrue from DAStatics");
					return hr;
				}
			}

			hr = leftTrack->OrWithOnBvr( pdaboolScaleOn );
			if( FAILED(hr))
			{
				ReleaseInterface( pdaboolScaleOn );
				DPF_ERR("Failed to or the on bvr for scale with the on bvr for width");
				return hr;
			}

			hr = topTrack->OrWithOnBvr( pdaboolScaleOn );
			if( FAILED(hr))
			{
				ReleaseInterface( pdaboolScaleOn );
				DPF_ERR("Failed to or the on bvr for scale with the on bvr for height");
				return hr;
			}

			ReleaseInterface( pdaboolScaleOn );
		}
		
		// Get translated top into finalTop
		IDANumber *finalTop = NULL;
		hr = pointTranslated->get_Y(&finalTop);
		if (FAILED(hr))
		{
			ReleaseInterface(pointTranslated);
			return hr;
		}

		// Get translated left into finalLeft
		IDANumber *finalLeft = NULL;
		hr = pointTranslated->get_X(&finalLeft);
		ReleaseInterface(pointTranslated);
		if (FAILED(hr))
		{
			ReleaseInterface(finalTop);
			return hr;
		}
/*
		// Put into m_pFinalLeftTop
		hr = GetDAStatics()->Point2Anim(finalLeft, finalTop, &m_pFinalLeftTop);
		if (FAILED(hr))
		{
			ReleaseInterface(finalLeft);
			ReleaseInterface(finalTop);
			return hr;
		}
*/
		// Set finalTop onto top track
		hr = topTrack->SetFinalBvr(finalTop);
		ReleaseInterface(finalTop);
		if (FAILED(hr))
		{
			ReleaseInterface(finalLeft);
			DPF_ERR("Failed to set final top");
			return hr;
		}

		// Set finalLeft onto left track
		hr = leftTrack->SetFinalBvr(finalLeft);
		ReleaseInterface(finalLeft);
		if (FAILED(hr))
		{
			DPF_ERR("Failed to set final left");
			return hr;
		}
	}
	else
	{
/*
		// final leftTop equals orig leftTop
		m_pFinalLeftTop = m_pOrigLeftTop;
		m_pFinalLeftTop->AddRef();
*/
		// TODO (markhal): Should set this onto the track, and set a flag that it
		// shouldn't get applied

		if( fLeftWasAnimated )
			leftTrack->ApplyStatic();

		if( fTopWasAnimated )
			topTrack->ApplyStatic();
	}
/*
	// Compute final center
	hr = m_pFinalWidthHeight->Mul(.5, &pHalfWidthHeight);
	if (FAILED(hr))
		return hr;

	hr = GetDAStatics()->AddPoint2Vector(m_pFinalLeftTop, pHalfWidthHeight, &m_pFinalCenter);
	ReleaseInterface(pHalfWidthHeight);
	if (FAILED(hr))
		return hr;
*/
	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::ApplyImageTracks()
{
	HRESULT hr = S_OK;

	// Locate the image track
	CBvrTrack *pTrack = NULL;
	hr = FindTrack(L"image", e_Image, &pTrack);
	if (FAILED(hr))
	{
		DPF_ERR("Track mismatch");
		return hr;
	}

	ReleaseImageInfo();

	// We'll set this if we require a filter.
	// We need a filter if:
	// there are any effect filters applied to the image
	// and/or there is a rotation we are handling (i.e. not acting on VML)
	// and/or there is a scale we are handling (pixelScale set and not VML)
	bool requiresFilter = false;

	// We'll set this if we require a floating element
	// We need a floating element if:
	// There is a rotation we are handling
	// and/or there is a scale we are handling
	// and/or there is an expandoImage track
	bool requiresFloat = false;

	if( pTrack != NULL && pTrack->IsAnimated() )
	{

		if (pTrack != NULL && pTrack->ContainsFilter())
			requiresFilter = true;

		// If there is any rotation, m_pRotate will be set
		// TODO: Ignore this if we are on a VML shape
		if (m_pRotate != NULL)
		{
			requiresFilter = true;
			requiresFloat = true;
		}

		// If there is any scale, m_pScale will be set, and if we should
		// use it here, m_bPixelScale will be true
		if (m_pScale != NULL && CheckBitSet(m_dwCurrentState, PIXEL_SCALE_ON) )
		{
			requiresFilter = true;
			requiresFloat = true;
		}

		// If we are rendering images over the top of a VML shape then we
		// need to use a filter
		bool isVML;
		hr = IsAnimatedElementVML(&isVML);
		if (FAILED(hr))
			return E_FAIL;

		if (pTrack != NULL && pTrack->IsAnimated() && isVML)
		{
			requiresFilter = true;
		}

		// If we are rendering and have an animates property, then we need
		// to use a filter
		hr = CUtils::InsurePropertyVariantAsBSTR(&m_varAnimates);
		if ( pTrack != NULL && pTrack->IsAnimated() && SUCCEEDED(hr) && wcslen(V_BSTR(&m_varAnimates)) != 0)
		{
			requiresFilter = true;
		}

		if (pTrack == NULL && !requiresFilter && !requiresFloat)
		{
			// Nothing to do
			return S_OK;
		}

		//store away the final width and height in pixels so that we
		// can use them to prepare images for dxtransforms
		IDAPoint2 *pFinalPixelDimension = NULL;
		hr = GetDAStatics()->Point2Anim( m_pPixelWidth, m_pPixelHeight, &pFinalPixelDimension );
		if( FAILED( hr ) )
		{
			return hr;
		}

		// Compute the final image behavior
		IDABehavior *pFinal = NULL;
		if (pTrack == NULL || requiresFilter)
		{
			// We need to pass the element image (from a filter) in as the static
			IDAImage *pElementImage = NULL;
			hr = GetElementImage(&pElementImage);
			if (FAILED(hr))
			{
				ReleaseInterface( pFinalPixelDimension );
				DPF_ERR("Failed to get element image");
				return hr;
			}

			// Apply pixelScale, if any.
			if (m_pScale != NULL && CheckBitSet( m_dwCurrentState, PIXEL_SCALE_ON) )
			{
				IDAImage *pImageScaled = NULL;
				hr = pElementImage->Transform(m_pScale, &pImageScaled);
				ReleaseInterface(pElementImage);
				if (FAILED(hr))
				{
					ReleaseInterface( pFinalPixelDimension );
					DPF_ERR("Failed to scale image");
					return hr;
				}

				//scale the final pixelWidth/Height by the pixel scale
				IDAPoint2 *pScaledDimension;
				hr = pFinalPixelDimension->Transform( m_pScale, &pScaledDimension );
				ReleaseInterface( pFinalPixelDimension );
				if( FAILED( hr ) )
				{
					DPF_ERR("Failed to scale the final element dimension" );
					return hr;
				}
				pFinalPixelDimension = pScaledDimension;
				pScaledDimension = NULL;


				pElementImage = pImageScaled;
			}

			if (pTrack != NULL)
			{


				if( pTrack->ContainsFilter() )
				{
					//we have to prepare the image for a filter if there is one in the image tracks
            
					IDAImage *pDXTReadyImage;
					hr = PrepareImageForDXTransform( pElementImage, &pDXTReadyImage );
					ReleaseInterface( pElementImage );
					if( FAILED( hr ) )
					{
						ReleaseInterface( pFinalPixelDimension );
						DPF_ERR("failed to prepare the image for a DXTransform");
						return hr;
					}
					pElementImage = pDXTReadyImage;
					pDXTReadyImage = NULL;
				}

            
				hr = pTrack->GetFinalBvr(pElementImage, &pFinal);
				ReleaseInterface(pElementImage);
			}
			else
			{
				pFinal = pElementImage;
				pElementImage = NULL;
			}
		}
		else //the track is != NULL && we do not require a filter
		{
			// Get image with no background
			hr = pTrack->GetFinalBvr(&pFinal);
		}
		if (FAILED(hr))
		{
			ReleaseInterface( pFinalPixelDimension );
			DPF_ERR("Could not get a final behavior from the image track");
			return hr;
		}
    
		// Convert the behavior to an image
		IDAImage *pImageFinal = NULL;
		hr = pFinal->QueryInterface(IID_TO_PPV(IDAImage, &pImageFinal));
		ReleaseInterface(pFinal);
		if (FAILED(hr))
		{
			ReleaseInterface( pFinalPixelDimension );
			DPF_ERR("Could not QI for a DA image from the final behavior");
			return hr;
		}

		bool highQuality = false;

		// Set image quality if scaling.
		if (m_pScale != NULL)
		{
			// Require highQuality
			highQuality = true;
		}

		// Crop it
		IDAImage *pCroppedImage = NULL;
		hr = pImageFinal->Crop(m_pBoundsMin, m_pBoundsMax, &pCroppedImage);
		ReleaseInterface(pImageFinal);
		if (FAILED(hr))
		{
			ReleaseInterface( pFinalPixelDimension );
			return hr;
		}
		

		pImageFinal = pCroppedImage;
		pCroppedImage = NULL;
    

		// Apply any rotation
		if (m_pRotate != NULL)
		{
			//we have to clip when rotating to make sure that 
			//vectors do not render outside the crop.

			IDAImage *pClippedImage = NULL;
			hr = ApplyClipToImage( pImageFinal, m_pBoundsMin, m_pBoundsMax, &pClippedImage );
			ReleaseInterface( pImageFinal );
			if (FAILED(hr))
			{
				ReleaseInterface( pFinalPixelDimension );
				DPF_ERR("Failed to rotate image");
				return hr;
			}

			IDAImage *pImageRotated = NULL;
			hr = pClippedImage->Transform(m_pRotate, &pImageRotated);
			ReleaseInterface(pClippedImage);
			if (FAILED(hr))
			{
				ReleaseInterface( pFinalPixelDimension );
				DPF_ERR("Failed to rotate image");
				return hr;
			}

			pImageFinal = pImageRotated;
			pImageRotated = NULL;

			highQuality = true;
		}
	/*
		if (highQuality)
		{
			// Set the quality flags
			IDA2Image *pImageFinal2 = NULL;
			hr = pImageFinal->QueryInterface(IID_TO_PPV(IDA2Image, &pImageFinal2));
			ReleaseInterface(pImageFinal);
			if (FAILED(hr))
				return hr;

			// Go wild, turn everything on.
			// TODO (markhal): Figure out what should be on
			hr = pImageFinal2->ImageQuality(    DAQUAL_AA_TEXT_ON |
												DAQUAL_AA_LINES_ON |
												DAQUAL_AA_SOLIDS_ON |
												DAQUAL_AA_CLIP_ON |
												DAQUAL_MSHTML_COLORS_ON |
												DAQUAL_QUALITY_TRANSFORMS_ON,
												&pImageFinal);
			ReleaseInterface(pImageFinal2);
			if (FAILED(hr))
				return hr;
		}
	*/

		if (requiresFilter && requiresFloat)
		{
			// Want to render on top of floating element using filtered bits from
			// original element

			hr = ApplyImageBvrToFloatElement(pImageFinal);
			ReleaseInterface(pImageFinal);
			if (FAILED(hr))
			{
				ReleaseInterface( pFinalPixelDimension );
				DPF_ERR("Failed to apply image to element");
				return hr;
			}

			if (m_pScale != NULL && CheckBitSet( m_dwCurrentState, PIXEL_SCALE_ON ) )
			{
				IDANumber *pFinalPixelWidth = NULL;
				IDANumber *pFinalPixelHeight = NULL;
				hr = pFinalPixelDimension->get_X( &pFinalPixelWidth );
				if( FAILED( hr ) )
				{
					ReleaseInterface( pFinalPixelDimension );
					DPF_ERR("Failed to get_x from the final pixel dimension" );
					return hr;
				}

				hr = pFinalPixelDimension->get_Y( &pFinalPixelHeight );
				ReleaseInterface( pFinalPixelDimension );
				if( FAILED( hr ) )
				{
					ReleaseInterface( pFinalPixelWidth );
					DPF_ERR("Failed to get_x from the final pixel dimension" );
					return hr;
				}

				hr = SetFinalElementDimension( pFinalPixelWidth, pFinalPixelHeight, true );
				ReleaseInterface( pFinalPixelWidth );
				ReleaseInterface( pFinalPixelHeight );
				if( FAILED(hr ) )
				{
					DPF_ERR("Failed to set the finalElement dimension from the float" );
					return hr;
				}
			}
			else
			{	
				ReleaseInterface( pFinalPixelDimension);

				hr = SetFinalElementDimension( m_pPixelWidth, m_pPixelHeight, false );
				if( FAILED( hr ) )
				{
					DPF_ERR("Failed to set the final element dimension from the original element" );
				}
			}
		}
		else if (requiresFilter)
		{
			ReleaseInterface( pFinalPixelDimension );

			// Want to render on top of original element using a filter
			// Attach to TIME element but disable rendering
			hr = AddImageToTIME(GetHTMLElement(), pImageFinal, false);
			ReleaseInterface(pImageFinal);
			if (FAILED(hr))
			{
				DPF_ERR("Failed to apply image to element");
				return hr;
			}

			// Set element on filter
			hr = SetElementOnFilter();
			if (FAILED(hr))
			{
				DPF_ERR("Failed to set element on filter");
				return hr;
			}

			hr = SetFinalElementDimension( m_pPixelWidth, m_pPixelHeight, false );
			if( FAILED( hr ) )
			{
				DPF_ERR("Failed to set the final element dimension from the original element" );
			}
		}
		else if (requiresFloat)
		{
			ReleaseInterface( pFinalPixelDimension );
			// Want to render on top of float element but leave original element
			// rendering as normal with no filtering.
		}
		else
		{
			ReleaseInterface( pFinalPixelDimension );
			// Want to render on top of original element with no filtering required

			// Attach to TIME behavior and enable rendering
			hr = AddImageToTIME(GetHTMLElement(), pImageFinal, true);
			ReleaseInterface(pImageFinal);
			if (FAILED(hr))
			{
				DPF_ERR("Failed to apply image to element");
				return hr;
			}
			DASSERT( m_pdanumFinalImageWidth == NULL && m_pdanumFinalImageHeight == NULL );
		}

		ReleaseInterface( pFinalPixelDimension);
	}

	if( !requiresFilter && m_pElementFilter != NULL )
	{
		hr = RemoveElementFilter();
		if( FAILED( hr ) )
		{
			DPF_ERR("Failed to remove the element filter" );
			return hr;
		}

	}
	
    return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::ApplyImageBvrToFloatElement(IDAImage *pbvrImage)
{
	if (m_pFloatManager == NULL)
		m_pFloatManager = new CFloatManager(this);

	if (m_pFloatManager == NULL)
		return E_FAIL;

	return m_pFloatManager->ApplyImageBvr(pbvrImage);
}

//*****************************************************************************

HRESULT
CActorBvr::SetElementOnFilter()
{
	IDispatch *pFilter;
	HRESULT hr = GetElementFilter(&pFilter);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to get filter");
		return hr;
	}

	hr = SetElementOnFilter(pFilter, GetHTMLElement());
	ReleaseInterface(pFilter);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to set element on filter");
		return hr;
	}

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::SetElementOnFilter(IDispatch *pFilter, IHTMLElement *pElement)
{
    HRESULT hr;
	DISPPARAMS		params;
	VARIANT 		varElement;
	VARIANT			varResult;
	
	VariantInit(&varElement);
	varElement.vt = VT_DISPATCH;
	varElement.pdispVal = pElement;   
	VariantInit(&varResult);

	params.rgvarg				= &varElement;
	params.rgdispidNamedArgs	= NULL;
	params.cArgs				= 1;
	params.cNamedArgs			= 0;
    hr = CallInvokeOnDispatch(pFilter,
                                 L"SetDAViewHandler", 
                                 DISPATCH_METHOD,
                                 &params,
                                 &varResult);

	VariantClear(&varResult);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting time element");
		return SetErrorInfo(hr);
    }

	return S_OK;
}

//*****************************************************************************

HRESULT 
CActorBvr::GetAnimatedElementId(VARIANT *pvarId)
{
    HRESULT hr;

    hr = CUtils::InsurePropertyVariantAsBSTR(&m_varAnimates);

    if ((SUCCEEDED(hr)) && (wcslen(m_varAnimates.bstrVal) > 0))
    {
        hr = VariantCopy(pvarId, &m_varAnimates);
    }
    else
    {
        // we need to get the id from the element to which we are attached
		IHTMLElement *pAnimatedElement = GetHTMLElement();
		if (pAnimatedElement == NULL )
		{
			DPF_ERR("Error obtaining animated element");
			return SetErrorInfo(hr);
		}

		hr = pAnimatedElement->getAttribute(L"id", 0, pvarId);

		if ( FAILED(hr) || pvarId->vt != VT_BSTR || pvarId->bstrVal == 0 || SysStringLen(pvarId->bstrVal) == 0)
		{
			// id is not defined on animated element yet, need to assign it a unique id
			IHTMLUniqueName *pUnique;

			hr = pAnimatedElement->QueryInterface(IID_IHTMLUniqueName, (void **)(&pUnique));

			if ( SUCCEEDED(hr) && pUnique != 0 )
			{
				BSTR uniqueID;
				hr = pUnique->get_uniqueID( &uniqueID );
				ReleaseInterface(pUnique);

				if (SUCCEEDED(hr))
				{
					hr = pAnimatedElement->put_id(uniqueID);

					if (SUCCEEDED(hr))
					{
						VariantClear(pvarId);
						V_VT(pvarId) = VT_BSTR;
						V_BSTR(pvarId) = uniqueID;
					}
					else
						SysFreeString(uniqueID);
				}
			}
		}
		
    }

    if (FAILED(hr))
    {
        DPF_ERR("Error getting Id of element to animate in GetAnimatedElementId");
        return SetErrorInfo(hr);
    }

    return S_OK;
} // GetAnimatedElementId

//*****************************************************************************

// TODO (markhal): This should probably cache the animated element
HRESULT
CActorBvr::GetAnimatedElement(IHTMLElement** ppElem)
{
	if( ppElem == NULL )
		return E_INVALIDARG;

	HRESULT hr = E_FAIL;

	//if animates is not set
	hr = CUtils::InsurePropertyVariantAsBSTR(&m_varAnimates);


    if ( FAILED(hr) || wcslen(V_BSTR(&m_varAnimates)) == 0)
	{
		//get the element to which we are attached.
		(*ppElem) = GetHTMLElement();
		(*ppElem)->AddRef();
		hr = S_OK;
	}
	else //else animates is set
	{
		//get the element referred to by animates by name
		IHTMLElement *pElement = GetHTMLElement();
		if( pElement != NULL )
		{
			IDispatch* pdispDocument;
			pElement->get_document( &pdispDocument );
			if( SUCCEEDED( hr ) )
			{
				IHTMLDocument2 *pDoc2;
				hr = pdispDocument->QueryInterface(IID_TO_PPV(IHTMLDocument2, &pDoc2));
				ReleaseInterface( pdispDocument );
				if( SUCCEEDED( hr ) )
				{
					IHTMLElementCollection *pcolElements;
					hr = pDoc2->get_all( &pcolElements );
					ReleaseInterface(pDoc2);
					if( SUCCEEDED( hr ) )
					{
						IDispatch* pdispElement;
						VARIANT index;
						VariantInit( &index );

						V_VT(&index) = VT_I4;
						V_I4(&index) = 0;

						hr = pcolElements->item( m_varAnimates, index, &pdispElement );
						ReleaseInterface( pcolElements );
						VariantClear(&index);
						if( SUCCEEDED( hr ) )
						{
							if (pdispElement == NULL)
							{
								// Couldn't find the element
								hr = E_FAIL;
							}
							else
							{
								hr = pdispElement->QueryInterface( IID_TO_PPV( IHTMLElement, ppElem ) );
								ReleaseInterface( pdispElement );
								if( FAILED( hr ) )
								{
									DPF_ERR("Failed to get IHTMLElement from dispatch returned by all.item()");
								}
							}
						}
						else //failed to get element pointed to by animates from the all collection
						{
							DPF_ERR("failed to get element pointed to by animates from the all collection");
						}

					}
					else //failed to get the all collection from IHTMLDocument2
					{
						DPF_ERR("failed to get the all collection from IHTMLDocument2");
					}
				}
				else //failed to get IHTMLDocument2 from the dispatch for the document
				{
					DPF_ERR("failed to get IHTMLDocument2 from the dispatch for the document");
				}
			}
			else//failed to get the document from the actor element
			{
				DPF_ERR("failed to get the document from the actor element");
			}
		}
		else//failed to get the html element for the actor
		{
			DPF_ERR("failed to get the html element for the actor");
		}
	}
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::GetRuntimeStyle(IHTMLStyle **ppStyle)
{
	HRESULT hr = S_OK;

	DASSERT(ppStyle != NULL);
	*ppStyle = NULL;

	if (m_pRuntimeStyle == NULL)
	{
		IHTMLElement *pElement = NULL;
		hr = GetAnimatedElement(&pElement);
		if (FAILED(hr))
			return hr;

		IHTMLElement2 *pElement2 = NULL;
		hr = pElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElement2));
		ReleaseInterface(pElement);
		if (FAILED(hr))
			return hr;

		hr = pElement2->get_runtimeStyle(&m_pRuntimeStyle);
		ReleaseInterface(pElement2);
		if (FAILED(hr))
			return hr;
	}

	*ppStyle = m_pRuntimeStyle;
	m_pRuntimeStyle->AddRef();

	return S_OK;
}

//*****************************************************************************


HRESULT
CActorBvr::GetStyle(IHTMLStyle **ppStyle)
{
	HRESULT hr = S_OK;

	DASSERT(ppStyle != NULL);
	*ppStyle = NULL;

	if (m_pStyle == NULL)
	{
		IHTMLElement *pElement = NULL;
		hr = GetAnimatedElement(&pElement);
		if (FAILED(hr))
			return hr;

		hr = pElement->get_style(&m_pStyle);
		ReleaseInterface(pElement);
		if (FAILED(hr))
			return hr;
	}

	*ppStyle = m_pStyle;
	m_pStyle->AddRef();

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::AddImageInfo( IDA2Image *pdaimg2Cropped, IDABehavior* pdabvrSwitchable )
{
	if( pdaimg2Cropped == NULL || pdabvrSwitchable == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	CImageInfo *pOldHead = m_pImageInfoListHead;

	IDA2Behavior *pdabvr2Switchable = NULL;
	hr = pdabvrSwitchable->QueryInterface( IID_TO_PPV( IDA2Behavior, &pdabvr2Switchable ) );
	CheckHR( hr, "Failed to get IDA2Behavior from switchable passed to AddImageInfo", cleanup );

	m_pImageInfoListHead = new CImageInfo( pdaimg2Cropped, pdabvr2Switchable );
	ReleaseInterface( pdabvr2Switchable );
	
	if( m_pImageInfoListHead == NULL )
	{
		m_pImageInfoListHead = pOldHead;
		return E_OUTOFMEMORY;
	}

	m_pImageInfoListHead->SetNext( pOldHead );

cleanup:

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::SetRenderResolution( double dX, double dY )
{
	HRESULT hr = S_OK;

	IDAImage *pdaimgNew = NULL;

	CImageInfo *pCurInfo = m_pImageInfoListHead;
	while( pCurInfo != NULL )
	{
		hr =  pCurInfo->GetCroppedNoRef()->RenderResolution( dX, dY, &pdaimgNew );
		CheckHR( hr, "Failed to set render resolution on an image", cleanup );
		
		hr = pCurInfo->GetSwitchableNoRef()->SwitchToEx( pdaimgNew, DAContinueTimeline );
		CheckHR( hr, "Failed to switch in the new image", cleanup );

		ReleaseInterface( pdaimgNew );

		pCurInfo = pCurInfo->GetNext();
	}
cleanup:
	ReleaseInterface( pdaimgNew );

	return hr;
}


//*****************************************************************************

void
CActorBvr::ReleaseImageInfo()
{
	CImageInfo *pCurInfo = m_pImageInfoListHead;
	CImageInfo *pNextInfo = NULL;
	while( pCurInfo != NULL )
	{
		pNextInfo = pCurInfo->GetNext();
		delete pCurInfo;
		pCurInfo = pNextInfo;
	}

	m_pImageInfoListHead = NULL;
}


//*****************************************************************************

HRESULT
CActorBvr::SetVMLAttribute(BSTR propertyName, VARIANT *pVal)
{
	HRESULT hr = S_OK;

	if (m_pVMLRuntimeStyle == NULL)
	{
		// Need to find VML RuntimeStyle
		IHTMLElement *pElement = NULL;
		hr = GetAnimatedElement(&pElement);
		if (FAILED(hr))
			return hr;

		IDispatch *pDispatch = NULL;
		hr = pElement->QueryInterface(IID_TO_PPV(IDispatch, &pDispatch));
		ReleaseInterface(pElement);
		if (FAILED(hr))
			return hr;

		BSTR attrName = ::SysAllocString(L"_vgRuntimeStyle");
		if (attrName == NULL)
		{
			ReleaseInterface(pDispatch);
			return E_FAIL;
		}

		hr = GetPropertyAsDispatch(pDispatch, attrName, &m_pVMLRuntimeStyle);
		ReleaseInterface(pDispatch);
		::SysFreeString(attrName);

		if (FAILED(hr))
		{
			m_pVMLRuntimeStyle = NULL;
			return hr;
		}
	}

	hr = SetPropertyOnDispatch(m_pVMLRuntimeStyle, propertyName, pVal);

	return hr;
}

//*****************************************************************************

void
CActorBvr::DiscardBvrCache(void)
{
    ReleaseInterface(m_pOrigLeftTop);
	ReleaseInterface(m_pOrigWidthHeight);
	ReleaseInterface(m_pBoundsMin);
	ReleaseInterface(m_pBoundsMax);
    ReleaseInterface(m_pTranslate);
    ReleaseInterface(m_pRotate);
    ReleaseInterface(m_pScale);
} // DiscardBvrCache

HRESULT
CActorBvr::AttachActorBehaviorToAnimatedElement()
{
	return S_OK;
};

HRESULT
CActorBvr::GetFinalElementDimension( IDANumber** ppdanumWidth, IDANumber** ppdanumHeight)
{
	if( ppdanumWidth == NULL || ppdanumHeight == NULL )
	{
		return E_INVALIDARG;
	}

	//one of the m_pdanumFinalElement* variables is set without the other being set.
	DASSERT( !((m_pdanumFinalElementWidth == NULL && m_pdanumFinalElementHeight != NULL) ||
			   (m_pdanumFinalElementWidth != NULL && m_pdanumFinalElementHeight == NULL)) );

	HRESULT hr = S_OK;
	//if no one has set the final width and height yet
	if( m_pdanumFinalElementWidth == NULL && m_pdanumFinalElementHeight == NULL )
	{
		//create switchers, we will switch in the final values when they are ready
		hr = GetDAStatics()->ModifiableNumber( 1.0, &m_pdanumFinalElementWidth );
		CheckHR( hr, "Failed to create a modifiable number for the width", cleanup );

		hr = GetDAStatics()->ModifiableNumber( 1.0, &m_pdanumFinalElementHeight );
		CheckHR( hr, "Failed to create a modifiable number for the height", cleanup );
	}
	(*ppdanumWidth) = m_pdanumFinalElementWidth;
	m_pdanumFinalElementWidth->AddRef();

	(*ppdanumHeight) = m_pdanumFinalElementHeight;
	m_pdanumFinalElementHeight->AddRef();

cleanup:

	return hr;
}


HRESULT
CActorBvr::SetFinalElementDimension( IDANumber* pdanumWidth, IDANumber* pdanumHeight, bool fHook )
{
	if( pdanumWidth == NULL || pdanumHeight == NULL )
		return E_INVALIDARG;

	//one of the m_pdanumFinalElement* variables is set without the other being set.
	DASSERT( !((m_pdanumFinalElementWidth == NULL && m_pdanumFinalElementHeight != NULL) ||
			   (m_pdanumFinalElementWidth != NULL && m_pdanumFinalElementHeight == NULL)) );

	HRESULT hr = S_OK;

	if( m_pdanumFinalElementWidth == NULL && m_pdanumFinalElementHeight == NULL )
	{
		IDABehavior *pdabvrModWidth = NULL;
		IDABehavior *pdabvrModHeight = NULL;
		
		//create a modifiable behavior to be the width and height
		hr = GetDAStatics()->ModifiableBehavior( pdanumWidth, &pdabvrModWidth );
		CheckHR( hr, "Failed to create a modifiableNumber", createCleanup );

		hr = pdabvrModWidth->QueryInterface( IID_TO_PPV( IDANumber, &m_pdanumFinalElementWidth) );
		CheckHR( hr, "QI for IDANumber failed", createCleanup );

		hr = GetDAStatics()->ModifiableBehavior( pdanumHeight, &pdabvrModHeight );
		CheckHR( hr, "Failed to create a modifiable behavior", createCleanup );

		hr = pdabvrModHeight->QueryInterface( IID_TO_PPV(IDANumber, &m_pdanumFinalElementHeight ) );
		CheckHR( hr, "QI for IDANumber Failed", createCleanup );
		
	createCleanup:
		ReleaseInterface( pdabvrModWidth );
		ReleaseInterface( pdabvrModHeight );
		if( FAILED( hr ) )
		{
			goto cleanup;
		}
	}
	else //final width and height were already set
	{
		IDA2Behavior *pda2bvrWidth = NULL;
		IDA2Behavior *pda2bvrHeight = NULL;

		hr = m_pdanumFinalElementWidth->QueryInterface( IID_TO_PPV( IDA2Behavior, &pda2bvrWidth ) );
		CheckHR( hr, "Failed QI for IDA2Behavior on the final width behavior", cleanup );

		hr = pda2bvrWidth->SwitchToEx( pdanumWidth, DAContinueTimeline );
		ReleaseInterface( pda2bvrWidth );
		CheckHR( hr, "Failed to switch in the final Element Width", cleanup );

		hr = m_pdanumFinalElementHeight->QueryInterface( IID_TO_PPV( IDA2Behavior, &pda2bvrHeight ) );
		CheckHR( hr, "Failed QI for IDA2Behavior on the final height behavior", cleanup );

		hr = pda2bvrHeight->SwitchToEx( pdanumHeight, DAContinueTimeline );
		ReleaseInterface( pda2bvrHeight );
		CheckHR( hr, "Failed to switch in the final Element Height", cleanup );
	}
	if( fHook && m_pFinalElementDimensionSampler == NULL )
	{
		m_pFinalElementDimensionSampler = new CFinalDimensionSampler( this );
		if( m_pFinalElementDimensionSampler == NULL )
		{
			hr = E_OUTOFMEMORY;
			goto cleanup;
		}

		hr = m_pFinalElementDimensionSampler->Attach(  m_pdanumFinalElementWidth, m_pdanumFinalElementHeight );
		CheckHR( hr, "Failed to attach to final dimensions", cleanup );
	}
cleanup:

	return hr;
}

//*****************************************************************************

HRESULT 
CActorBvr::PrepareImageForDXTransform( IDAImage *pOriginal,
								       IDAImage **ppResult)
{
    if( pOriginal == NULL || ppResult == NULL )
        return E_INVALIDARG;

	/*
    pOriginal->AddRef();
    (*ppResult) = pOriginal;
    return S_OK;
    */
    

    HRESULT hr;

	IDABehavior *pdabvrSwitchable = NULL;
	IDA2Image *pdaimg2Image = NULL;
	IDAImage *pdaimgFinal = NULL;
    IDAImage *pdaimgOverlaid = NULL;
    IDATransform2 *pdatfmPixel = NULL;
    IDAPoint2 *pdapt2MinMeter = NULL;
    IDAPoint2 *pdapt2MaxMeter = NULL;

	IDANumber *pdanumTwo = NULL;
	IDANumber *pdanumHalfPixelWidth = NULL;
	IDANumber *pdanumHalfPixelHeight = NULL;
	IDANumber *pdanumNegHalfPixelWidth = NULL;
	IDANumber *pdanumNegHalfPixelHeight = NULL;

	IDANumber *pdanumFinalPixelWidth = NULL;
	IDANumber *pdanumFinalPixelHeight = NULL;

    IDAImage *pdaimgDetectable;
    hr = GetDAStatics()->get_DetectableEmptyImage(&pdaimgDetectable);
    CheckHR( hr, "Failed to get the detectable empty image from statics", cleanup );
    
    hr = GetDAStatics()->Overlay( pOriginal, pdaimgDetectable, &pdaimgOverlaid );
    ReleaseInterface( pdaimgDetectable );
    CheckHR( hr, "Failed to overlay the original image on the detectableEmptyImage", cleanup );

    IDANumber *pdanumMetersPerPixel;
    hr = GetDAStatics()->get_Pixel( &pdanumMetersPerPixel );
    CheckHR( hr, "Failed to get pixel from statics", cleanup );
    
    hr = GetDAStatics()->Scale2Anim( pdanumMetersPerPixel, pdanumMetersPerPixel, &pdatfmPixel );
    ReleaseInterface( pdanumMetersPerPixel );
    CheckHR( hr, "Failed to create a scale2 for pixel", cleanup );

	hr = GetDAStatics()->DANumber( 2.0, &pdanumTwo );
	CheckHR( hr, "Failed to create a danumber for 2.0", cleanup );

	hr = GetFinalElementDimension( &pdanumFinalPixelWidth, &pdanumFinalPixelHeight );
	CheckHR( hr, "Failed to get the final element dimensions from the actor", cleanup );

	hr = GetDAStatics()->Div( pdanumFinalPixelWidth, pdanumTwo, &pdanumHalfPixelWidth );
	CheckHR( hr, "Failed to divide pixel width by two in da", cleanup );

	hr = GetDAStatics()->Div( pdanumFinalPixelHeight, pdanumTwo, &pdanumHalfPixelHeight );
	CheckHR( hr, "Failed to divide pixel height by two in DA", cleanup );

	hr = GetDAStatics()->Neg( pdanumHalfPixelWidth, &pdanumNegHalfPixelWidth );
	CheckHR( hr, "Failed to negate halfWidth", cleanup );

	hr = GetDAStatics()->Neg( pdanumHalfPixelHeight, &pdanumNegHalfPixelHeight );
	CheckHR( hr, "Failed to negate halfHeight", cleanup );

    IDAPoint2 *pdapt2Min;
    hr = GetDAStatics()->Point2Anim( pdanumNegHalfPixelWidth, pdanumNegHalfPixelHeight, &pdapt2Min );
    CheckHR( hr, "Failed to create the min point", cleanup );

    hr = pdapt2Min->Transform( pdatfmPixel, &pdapt2MinMeter );
    ReleaseInterface( pdapt2Min );
    CheckHR( hr, "Failed to transform the min point", cleanup );

    IDAPoint2 *pdapt2Max;
    hr = GetDAStatics()->Point2Anim( pdanumHalfPixelWidth, pdanumHalfPixelHeight, &pdapt2Max );
    CheckHR( hr, "Failed to create the max point", cleanup );

    hr = pdapt2Max->Transform( pdatfmPixel, &pdapt2MaxMeter );
    ReleaseInterface( pdapt2Max );
    CheckHR( hr, "Failed to transform the max point", cleanup );


	IDAImage *pdaimgCropped;
    hr = pdaimgOverlaid->Crop( pdapt2MinMeter, pdapt2MaxMeter, &pdaimgCropped );
    CheckHR( hr, "Failed to crop the overlaid image", cleanup );

    hr = pdaimgCropped->QueryInterface( IID_TO_PPV( IDA2Image, &pdaimg2Image ) );
    ReleaseInterface( pdaimgCropped );
    CheckHR( hr, "Failed to get IDA2Image off of the final image", cleanup );

    IDAImage *pdaimgNew;
    hr = pdaimg2Image->RenderResolution( m_pixelWidth, m_pixelHeight, &pdaimgNew );
    CheckHR( hr, "Failed to set the render resolution on the final image", cleanup );

	hr = GetDAStatics()->ModifiableBehavior( pdaimgNew, &pdabvrSwitchable );
	ReleaseInterface( pdaimgNew );
	CheckHR( hr, "Failed to create a modifiable behavior", cleanup );

	hr = pdabvrSwitchable->QueryInterface( IID_TO_PPV( IDAImage, &pdaimgFinal ) );
	CheckHR( hr, "QI for image on switchable created from image failed", cleanup );

	hr = AddImageInfo( pdaimg2Image, pdabvrSwitchable );
	CheckHR( hr, "Failed to add Image info to the actor", cleanup );

    (*ppResult) = pdaimgFinal;

cleanup:

    if( FAILED( hr ) )
    {
        *ppResult = NULL;
    }

	ReleaseInterface( pdaimg2Image );
	ReleaseInterface( pdabvrSwitchable );
    ReleaseInterface( pdaimgOverlaid );
    ReleaseInterface( pdatfmPixel );
    ReleaseInterface(pdapt2MinMeter);
    ReleaseInterface(pdapt2MaxMeter);

	ReleaseInterface( pdanumHalfPixelWidth );
	ReleaseInterface( pdanumHalfPixelHeight);
	ReleaseInterface( pdanumNegHalfPixelWidth );
	ReleaseInterface( pdanumNegHalfPixelHeight );
	ReleaseInterface( pdanumTwo );

	ReleaseInterface( pdanumFinalPixelWidth );
	ReleaseInterface( pdanumFinalPixelHeight );

    return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::ApplyClipToImage( IDAImage *pImageIn, IDAPoint2 *pMin, IDAPoint2 *pMax, IDAImage** ppImageOut )
{
	if( pImageIn == NULL || pMin == NULL || pMax == NULL || ppImageOut == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	//declare interface pointers
	IDANumber *pMinX = NULL;
	IDANumber *pMinY = NULL;
	IDANumber *pMaxX = NULL;
	IDANumber *pMaxY = NULL;

	IDAPoint2 *pTopLeft = NULL;
	IDAPoint2 *pBotRight = NULL;

	IDAPoint2 *pPoints[4];

	//get coordinates from the points
	hr = pMin->get_X( &pMinX );
	CheckHR( hr, "Failed to get the x coord from the min point", cleanup );

	hr = pMin->get_Y( &pMinY );
	CheckHR( hr, "Failed to get the y coord from the min point", cleanup );
	
	hr = pMax->get_X( &pMaxX );
	CheckHR( hr, "Failed to get the x coord from the max point", cleanup );

	hr = pMax->get_Y( &pMaxY );
	CheckHR( hr, "Failed to get the y coord from the max point", cleanup );

	//build points for top Left and bottom right
	hr = GetDAStatics()->Point2Anim( pMinX, pMaxY, &pTopLeft );
	CheckHR( hr, "Failed to create a point 2 for the Top left", cleanup );

	hr = GetDAStatics()->Point2Anim( pMaxX, pMinY, &pBotRight );
	CheckHR( hr, "Failed to create a point 2 for the bottom right", cleanup );

	//call clip polygon image on it
	pPoints[0] = pTopLeft;
	pPoints[1] = pMax;
	pPoints[2] = pBotRight;
	pPoints[3] = pMin;

	hr = pImageIn->ClipPolygonImageEx( 4, pPoints, ppImageOut );
	CheckHR( hr, "Failed to clip the image to a polygon", cleanup );

cleanup:
	//release interface pointers
	ReleaseInterface( pMinX );
	ReleaseInterface( pMinY );
	ReleaseInterface( pMaxX );
	ReleaseInterface( pMaxY );
	
	ReleaseInterface( pTopLeft );
	ReleaseInterface( pBotRight );

	return hr;
}

//*****************************************************************************

HRESULT 
CActorBvr::AddBehaviorToTIME(IDABehavior *pbvrAdd, long* plCookie)
{
    DASSERT(pbvrAdd != NULL);
	if( plCookie == NULL )
		return E_INVALIDARG;
	if( GetHTMLElement() == NULL )
		return E_FAIL;
	
    HRESULT hr;
	
	DISPPARAMS              params;
	VARIANT                 varBehavior;
	VARIANT                 varResult;
	
	VariantInit(&varBehavior);
	varBehavior.vt = VT_DISPATCH;
	varBehavior.pdispVal = pbvrAdd;
	
	VariantInit(&varResult);
	
	params.rgvarg                           = &varBehavior;
	params.rgdispidNamedArgs        = NULL;
	params.cArgs                            = 1;
	params.cNamedArgs                       = 0;
    hr = CallInvokeOnHTMLElement(GetHTMLElement(),
								 L"AddDABehavior", 
								 DISPATCH_METHOD,
								 &params,
								 &varResult);

	
    if (FAILED(hr))
    {
        DPF_ERR("Error calling CallInvokeOnHTMLElement in AddBehaviorToTIME");
		VariantClear(&varResult);
		return hr;
    }

	if( V_VT( &varResult ) != VT_I4 )
	{
		//change the type.
		hr = VariantChangeTypeEx( &varResult, &varResult, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_I4 );
		if( FAILED( hr ) )
		{
			DPF_ERR( "Error changing the type of the value returned from addDABehavior to a long " );
			VariantClear( &varResult );
			return hr;
		}

	}

	(*plCookie) = V_I4( &varResult );

	VariantClear(&varResult);

    return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::RemoveBehaviorFromTIME( long cookie )
{
	if( GetHTMLElement() == NULL )
		return E_FAIL;

	
    HRESULT hr;
	
	DISPPARAMS              params;
	VARIANT                 varCookie;
	VARIANT                 varResult;
	
	VariantInit(&varCookie);
	V_VT( &varCookie ) = VT_I4;
	V_I4( &varCookie ) = cookie;
	
	VariantInit(&varResult);
	
	params.rgvarg                           = &varCookie;
	params.rgdispidNamedArgs				= NULL;
	params.cArgs                            = 1;
	params.cNamedArgs                       = 0;
    hr = CallInvokeOnHTMLElement(GetHTMLElement(),
								 L"removeDABehavior", 
								 DISPATCH_METHOD,
								 &params,
								 &varResult);

	
    if (FAILED(hr))
    {
        DPF_ERR("Error calling CallInvokeOnHTMLElement in RemoveBehaviorFromTIME");
		VariantClear(&varResult);
		return hr;
    }

	VariantClear(&varResult);

    return S_OK;
}

//*****************************************************************************

bool
CActorBvr::IsAnimatingVML()
{
	return CheckBitSet( m_dwCurrentState, ELEM_IS_VML );
}

//*****************************************************************************

HRESULT
CActorBvr::GetCurrentState( DWORD *pdwState )
{
	HRESULT hr = S_OK;

	(*pdwState) = 0;

	bool valueSet = false;

	//check the state of pixel scale
	hr = CUtils::InsurePropertyVariantAsBool(&m_varPixelScale);
	if (SUCCEEDED(hr) && (V_BOOL(&m_varPixelScale) == VARIANT_TRUE))
	{
		LMTRACE2(1, 1000, "Pixel scale is on\n" );
		SetBit( (*pdwState), PIXEL_SCALE_ON );
	}


	//check the state of static rotation
	hr = IsStaticRotationSet( &valueSet );
	CheckHR( hr, "Failed to check to see if the static rotation is set", end );
	
	if( valueSet )
	{
		LMTRACE2( 1, 1000, "static rotation is set\n" );
		SetBit( (*pdwState), STATIC_ROTATION );
	}

	//check the state of static scale
	hr = IsStaticScaleSet( &valueSet );
	CheckHR( hr, "Failed to check if the static scale is set", end );
	if ( valueSet )
	{
		LMTRACE2( 1, 1000, "Static Scale is set\n");
		SetBit( (*pdwState), STATIC_SCALE );
	}

	//check whether or not the element is vml
	hr = IsAnimatedElementVML( &valueSet );
	CheckHR( hr, "Failed to check element for VMLness", end );
	if( valueSet )
	{
		LMTRACE2( 1, 2, "this is a VML Shape\n" );

		SetBit( (*pdwState), ELEM_IS_VML );
	}

end:
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::UpdateCurrentState()
{
	HRESULT hr = S_OK;
	
	DWORD dwOldState = m_dwCurrentState;

	hr = GetCurrentState( &m_dwCurrentState );

	//if the element is vml we may have failed to set is offscreen because
	//  the vgx behavior may not have been available yet.
	if( ( CheckBitSet( m_dwCurrentState, ELEM_IS_VML) && 
		  CheckBitNotSet( dwOldState, ELEM_IS_VML) 
		) ||
		m_fVisSimFailed 
	  )
	{
	    if( m_bEditMode && (m_simulVisHidden || m_simulDispNone ) )
		{
			VisSimSetOffscreen( NULL, false );
		}
	}

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::IsStaticScaleSet( bool *pfIsSet )
{
	if( pfIsSet == NULL )
		return E_INVALIDARG;

	(*pfIsSet) = true;
	
	HRESULT hr = S_OK;

	int cReturnedValues;
	float scaleVal[3];


    hr = CUtils::GetVectorFromVariant(&m_varScale, 
                                      &cReturnedValues, 
                                      &(scaleVal[0]), 
                                      &(scaleVal[1]), 
                                      &(scaleVal[2]));

	if (FAILED(hr) || cReturnedValues != 2)
	{
		// This is OK, since it just means they didn't set an appropriate scale.
		(*pfIsSet) = false;
		hr = S_OK;
	}
	

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::IsStaticRotationSet( bool *pfIsSet )
{
	if( pfIsSet == NULL )
		return E_INVALIDARG;
		
	HRESULT hr = S_OK;

	IHTMLElement2 *pelem2 = NULL;
	IHTMLCurrentStyle *pcurstyle = NULL;
	VARIANT varRotation;

	(*pfIsSet) = false;

	::VariantInit( &varRotation );

	hr = GetHTMLElement()->QueryInterface( IID_TO_PPV( IHTMLElement2, &pelem2 ) );
	CheckHR( hr, "QI for IHTMLElement2 on the element failed", end );

	hr = pelem2->get_currentStyle( &pcurstyle );
	CheckHR( hr, "Failed to get the current style from the element", end );
	CheckPtr( pcurstyle, hr, E_POINTER, "Got a null pointer for the current style", end );

	hr = pcurstyle->getAttribute( L"rotation", 0, &varRotation );
	if( SUCCEEDED( hr ) )
	{
		//make sure that this can be converted to a valid rotation value
		if( V_VT( &varRotation ) == VT_BSTR )
		{
			//strip off the units
			BSTR bstrVal = V_BSTR(&varRotation);
			OLECHAR* pUnits;

			hr = FindCSSUnits( bstrVal, &pUnits );
			if( SUCCEEDED(hr) && pUnits != NULL )
			{
				(*pUnits) = L'\0';
				BSTR bstrNewVal = SysAllocString(bstrVal);
				V_BSTR(&varRotation) = bstrNewVal;
				SysFreeString(bstrVal);
			}
			//else oh well no units.
		}

		//try to convert it to a double
		hr = ::VariantChangeTypeEx(&varRotation,
								 &varRotation,
								 LCID_SCRIPTING,
								 VARIANT_NOUSEROVERRIDE,
								 VT_R8);

		//if it got through this then it's a genuine rotation
		if( SUCCEEDED( hr ) )
		{
			(*pfIsSet) = true;
		}
		else
		{
			//this is okay, it just means there's no understandable rotation
			hr = S_OK;
		}
	}
	else 
	{
		//this is okay, it just means there's no rotation
		hr = S_OK;
	}
		

end:

	ReleaseInterface( pelem2 );
	ReleaseInterface( pcurstyle );

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::EnsureBodyPropertyMonitorAttached()
{
	HRESULT hr = S_OK;

	if( m_pBodyPropertyMonitor != NULL )
	{
		if( !m_pBodyPropertyMonitor->IsAttached() )
		{
			hr = AttachBodyPropertyMonitor();
		}
		else
		{
			hr = S_OK;
		}
	}
	else
	{
		hr = AttachBodyPropertyMonitor();
	}


	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::AttachBodyPropertyMonitor()
{
	if( GetHTMLElement() == NULL )
		return E_POINTER;

	HRESULT				hr				= S_OK;

	IDispatch			*pdispDocument	= NULL;
	IHTMLDocument2		*pdoc2Document	= NULL;
	IHTMLElement		*pelemBody		= NULL;

	IHTMLElement		*pelemParent	= NULL;

	//if our parent is null we are not in a valid document, which will
	// cause bad things to happen when we make the later calls in this 
	// method.
	hr = GetHTMLElement()->get_parentElement( &pelemParent );
	CheckHR( hr, "Failed to get the parent Element", end);
	CheckPtr( pelemParent, hr, E_POINTER, "The parent is null", end );

	//get the document from the element to which we are attached.
	hr = GetHTMLElement()->get_document( &pdispDocument );
	CheckHR( hr, "Failed to get the document from the html element of the actor", end );
	CheckPtr( pdispDocument, hr, E_POINTER, "Got a null document from get_document", end );

	hr = pdispDocument->QueryInterface( IID_TO_PPV( IHTMLDocument2, &pdoc2Document ) );
	CheckHR( hr, "Failed to get the document2 interface from document dipatch", end );

	//get the body from the document that we are in
	hr = pdoc2Document->get_body( &pelemBody );
	CheckHR( hr, "Failed to get the body from the document", end );
	CheckPtr( pelemBody, hr, E_POINTER, "Got a null body from the document", end );

	if( m_pBodyPropertyMonitor == NULL )
	{
		//create one
		m_pBodyPropertyMonitor = new CElementPropertyMonitor();
		CheckPtr( m_pBodyPropertyMonitor, hr, E_OUTOFMEMORY, "Ran out of memory trying to allocate the body event monitor", createMonitorEnd );

		//keep it around as long as we need it.
		m_pBodyPropertyMonitor->AddRef();

		//set this actor as the local time listener.
		hr = m_pBodyPropertyMonitor->SetLocalTimeListener( static_cast<IElementLocalTimeListener*>(this) );
		CheckHR( hr, "Failed to set the local time listener on the body event monitor", createMonitorEnd );
	createMonitorEnd:
		if( FAILED( hr ) )
		{
			if( m_pBodyPropertyMonitor != NULL )
			{
				m_pBodyPropertyMonitor->Release();
				m_pBodyPropertyMonitor = NULL;
			}
			goto end;
		}
	}

	//attach the body event monitor to the body element
	hr = m_pBodyPropertyMonitor->Attach( pelemBody );
	CheckHR( hr, "Failed to attach the body event monitor to the body element", end );

end:
	ReleaseInterface( pdispDocument );
	ReleaseInterface( pdoc2Document );
	ReleaseInterface( pelemBody );
	ReleaseInterface( pelemParent );

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::DetachBodyPropertyMonitor()
{
	HRESULT hr = S_OK;

	if( m_pBodyPropertyMonitor != NULL )
	{
		hr = m_pBodyPropertyMonitor->Detach();
		CheckHR( hr, "Failed to detach the event monitor from the body", end );
	}

end:
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::DestroyBodyPropertyMonitor()
{
	HRESULT hr = S_OK;

	if( m_pBodyPropertyMonitor != NULL )
	{
		hr = DetachBodyPropertyMonitor();
		CheckHR( hr, "Failed to detach the body event monitor", end );

		m_pBodyPropertyMonitor->Release();

		m_pBodyPropertyMonitor = NULL;
	}

end:
	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::AnimatedElementOnResize()
{
	UpdatePixelDimensions();

	return S_OK;
}

//*****************************************************************************

HRESULT
CActorBvr::OnWindowUnload()
{
	HRESULT hr = S_OK;

	m_fUnloading = true;

	return hr;
}

//*****************************************************************************

HRESULT
CActorBvr::AttachEvents()
{
	IHTMLElement *pelemAnimated = NULL;
	IHTMLElement2*pelem2Animated = NULL;
	VARIANT_BOOL varboolSuccess;

	HRESULT hr = S_OK;

	hr = GetAnimatedElement( &pelemAnimated );
	CheckHR( hr, "Failed to get the animated element", end );

	hr = pelemAnimated->QueryInterface( IID_TO_PPV( IHTMLElement2, &pelem2Animated ) );
	CheckHR( hr, "Couldn't get IHTMLElement2 from an element", end );

	if( m_pOnResizeHandler == NULL )
	{
		//create one
		m_pOnResizeHandler = new COnResizeHandler( this );
		CheckPtr( m_pOnResizeHandler, hr, E_OUTOFMEMORY, "ran out of memory trying to create an onresize handler", end );
		
		//attach it
		hr = pelem2Animated->attachEvent( L"onresize", m_pOnResizeHandler, &varboolSuccess );
		CheckHR( hr, "Failed to attachEvent to onresize", end );

		if( varboolSuccess == VARIANT_FALSE )
		{
			DPF_ERR("Failed to attach to the onresize event" );
			//delete the handler.
			m_pOnResizeHandler->Release();

			m_pOnResizeHandler = NULL;
		}
	}

	if( m_pOnUnloadHandler == NULL )
	{
		IHTMLWindow2		*pwin2 		= NULL;
		IHTMLWindow3	 	*pwin3		= NULL;
		
		//create one
		m_pOnUnloadHandler = new COnUnloadHandler( this );
		CheckPtr( m_pOnUnloadHandler, hr, E_OUTOFMEMORY, "Ran out of memory trying to create an onunload handler", OnUnloadEnd );

		//attach it
		hr = GetParentWindow( &pwin2 );
		CheckHR( hr, "Failed to get the window", OnUnloadEnd );

		hr = pwin2->QueryInterface( IID_TO_PPV( IHTMLWindow3, &pwin3 ) );
		CheckHR( hr, "Failed to get IHTMLWindow3 from the window", OnUnloadEnd );

		hr = pwin3->attachEvent( L"onunload", m_pOnUnloadHandler, &varboolSuccess );
		CheckHR( hr, "Failed to attach to the onunload event on the window", OnUnloadEnd );

		if( varboolSuccess == VARIANT_FALSE )
		{
			DPF_ERR( "failed to attach to onunload " );

			//delete the hanlder
			m_pOnUnloadHandler->Release();

			m_pOnUnloadHandler = NULL;
		}

	OnUnloadEnd:
		ReleaseInterface( pwin2 );
		ReleaseInterface( pwin3 );

		if( FAILED( hr ) )
		{	
			goto end;
		}
		
	}

end:

	ReleaseInterface( pelemAnimated );
	ReleaseInterface( pelem2Animated );

	return hr;
}


//*****************************************************************************

HRESULT
CActorBvr::DetachEvents()
{
	HRESULT hr = S_OK;

	IHTMLElement *pelemAnimated = NULL;
	IHTMLElement2*pelem2Animated = NULL;

	hr = GetAnimatedElement( &pelemAnimated );
	CheckHR( hr, "Failed to get the animated element", end );

	hr = pelemAnimated->QueryInterface( IID_TO_PPV( IHTMLElement2, &pelem2Animated ) );
	CheckHR( hr, "Couldn't get IHTMLElement2 from an element", end );

	if( m_pOnResizeHandler != NULL )
	{
		hr = pelem2Animated->detachEvent( L"onresize", m_pOnResizeHandler );
		CheckHR( hr, "Failed to detach onresize", end );
	}

	
	if( m_pOnUnloadHandler != NULL )
	{
		IHTMLWindow2 *pwin2 = NULL;
		IHTMLWindow3 *pwin3 = NULL;
		
		hr = GetParentWindow( &pwin2 );
		CheckHR( hr, "failed to get the window", unloadEnd );

		hr = pwin2->QueryInterface( IID_TO_PPV( IHTMLWindow3, &pwin3 ) );
		CheckHR( hr, "Failed to get window3 from the window", unloadEnd );

		hr = pwin3->detachEvent( L"onunload", m_pOnUnloadHandler );
		CheckHR( hr, "Failed to detach from onunload", unloadEnd );
	unloadEnd:
		ReleaseInterface( pwin2 );
		ReleaseInterface( pwin3 );
		if( FAILED( hr ) )
			goto end;

	}


end:
	//we want to release the event handlers no matter what
	if( m_pOnResizeHandler != NULL )
	{
		m_pOnResizeHandler->Invalidate();
		m_pOnResizeHandler->Release();
		m_pOnResizeHandler = NULL;
	}

	if( m_pOnUnloadHandler != NULL )
	{
		m_pOnUnloadHandler->Invalidate();
		m_pOnUnloadHandler->Release();
		m_pOnUnloadHandler = NULL;
	}

	
	ReleaseInterface( pelemAnimated );
	ReleaseInterface( pelem2Animated );

	return hr;
}

//*****************************************************************************
/*
HRESULT 
CBaseBehavior::GetAttributeFromHTMLElement(IHTMLElement *pElement, 
                                           WCHAR *pwzAttributeName, 
                                           VARIANT *pvarReturn)
{
	return GetAttributeFromHTMLElement(pElement, pwzAttributeName, false, pvarReturn);
}
*/
//*****************************************************************************
/*
HRESULT 
CBaseBehavior::GetCurrAttribFromHTMLElement(IHTMLElement *pElement, 
                                           WCHAR *pwzAttributeName, 
                                           VARIANT *pvarReturn)
{
	return GetAttributeFromHTMLElement(pElement, pwzAttributeName, true, pvarReturn);
}
*/
//*****************************************************************************
/*
HRESULT 
CBaseBehavior::GetAttributeFromHTMLElement(WCHAR *pwzAttributeName, 
                                           VARIANT *pvarReturn)
{
    DASSERT(pwzAttributeName != NULL);
    DASSERT(pvarReturn != NULL);
    return GetAttributeFromHTMLElement(m_pHTMLElement, pwzAttributeName, false, pvarReturn);
}
*/
//*****************************************************************************
/*
HRESULT 
CBaseBehavior::GetCurrAttribFromHTMLElement(WCHAR *pwzAttributeName, 
                                           VARIANT *pvarReturn)
{
    DASSERT(pwzAttributeName != NULL);
    DASSERT(pvarReturn != NULL);
    return GetAttributeFromHTMLElement(m_pHTMLElement, pwzAttributeName, true, pvarReturn);
}
*/
//*****************************************************************************
/*
HRESULT 
CBaseBehavior::GetAttributeFromParentHTMLElement(WCHAR *pwzAttributeName, 
                                                 VARIANT *pvarReturn)
{
    DASSERT(pwzAttributeName != NULL);
    DASSERT(pvarReturn != NULL);
    DASSERT(m_pHTMLElement != NULL);

    HRESULT hr;


    IHTMLElement *pParentElement;
    hr = m_pHTMLElement->get_parentElement(&pParentElement);
    if (FAILED(hr))
    {
        DPF_ERR("Error obtaining parent element from HTML element");
		return SetErrorInfo(hr);
    }
    // now extract our attributes from the parent HTMLElement
    hr = GetAttributeFromHTMLElement(pParentElement, pwzAttributeName, false, pvarReturn);
    ReleaseInterface(pParentElement);
    if (FAILED(hr))
    {
        DPF_ERR("Error extracting attribute from HTML element");
		return hr;
    }
    return S_OK;
} // GetAttributeFromParentHTMLElement
*/
//*****************************************************************************
/*
HRESULT 
CBaseBehavior::GetCurrAttribFromParentHTMLElement(WCHAR *pwzAttributeName, 
                                                 VARIANT *pvarReturn)
{
    DASSERT(pwzAttributeName != NULL);
    DASSERT(pvarReturn != NULL);
    DASSERT(m_pHTMLElement != NULL);

    HRESULT hr;


    IHTMLElement *pParentElement;
    hr = m_pHTMLElement->get_parentElement(&pParentElement);
    if (FAILED(hr))
    {
        DPF_ERR("Error obtaining parent element from HTML element");
		return SetErrorInfo(hr);
    }
    // now extract our attributes from the parent HTMLElement
    hr = GetAttributeFromHTMLElement(pParentElement, pwzAttributeName, true, pvarReturn);
    ReleaseInterface(pParentElement);
    if (FAILED(hr))
    {
        DPF_ERR("Error extracting attribute from HTML element");
		return hr;
    }
    return S_OK;
} // GetAttributeFromParentHTMLElement
*/

//*****************************************************************************
/*
// TODO (markhal): Should this go away?  It should refer to actor not animated element
// TODO (markhal): Should add GetCurrAttrib version of whatever it ends up being called
HRESULT 
CBaseBehavior::GetAttributeFromAnimatedHTMLElement(WCHAR *pwzAttributeName, 
                                                   VARIANT *pvarReturn)
{
    DASSERT(pwzAttributeName != NULL);
    DASSERT(pvarReturn != NULL);
    DASSERT(m_pHTMLElement != NULL);

    HRESULT hr;

    IHTMLElement *pAnimatedElement;
    hr = GetElementToAnimate(&pAnimatedElement);
    if (FAILED(hr))
    {
        DPF_ERR("Error obtaining element to animate");
        return SetErrorInfo(hr);
    }
    DASSERT(pAnimatedElement != NULL);
    // get the html attribute here
    hr = GetAttributeFromHTMLElement(pAnimatedElement, pwzAttributeName, pvarReturn);
    ReleaseInterface(pAnimatedElement);
    if (FAILED(hr))
    {
        DPF_ERR("Error extracting attribute from HTML element");
		return hr;
    }
    return S_OK;

} // GetAttributeFromAnimatedHTMLElement
*/
//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\src\autobase.cpp ===
//*****************************************************************************
//
// FileName:	    autobase.cpp
//
// Created:	    10/08/97
//
// Author:	    ColinMc
// 
// Abstract:	    The base class for all automatable objects
//                  in Trident3D. Stuff that is common across
//                  all scriptable objects should be placed
//                  here
//
// Modifications:
// 10/08/97 ColinMc Created this file
// 10/07/98 jeffort added to crbvr project
//
//*****************************************************************************

#include "headers.h"

//*****************************************************************************

#include <autobase.h>

//*****************************************************************************

// Maximum error message size in character
static const int gc_cErrorBuffer = 1024;

//*****************************************************************************

CAutoBase::CAutoBase()
{
    // No-op currently
} // CAutoBase

//*****************************************************************************

CAutoBase::~CAutoBase()
{
    // No-op currently
} // ~CAutoBase

//*****************************************************************************
//
// Author:      ColinMc
// Created:     10/09/97
// Abstract:    Returns an IErrorInfo that can be used to
//              communicate error information to the client
//              uses the currently set error info for this
//              thread if one is set. Otherwise creates a
//              new one and returns it
//              
//*****************************************************************************

HRESULT CAutoBase::GetErrorInfo(IErrorInfo** pperrinfo)
{
    DASSERT(NULL != pperrinfo);
    ICreateErrorInfo* pcerrinfo = NULL;

    *pperrinfo = NULL;

    // Get the current error object for this thread. If there
    // is one we will reuse that object for this error
    // (discarding the unclaimed existing error). Note that
    // the GetErrorInfo() below clears the current error
    // state of the thread
    if (S_FALSE == ::GetErrorInfo(0UL, pperrinfo))
    {
	// If there is no current error object then try and
	// create one.
	HRESULT hr = ::CreateErrorInfo(&pcerrinfo);
	if (FAILED(hr))
	{
	    // The only reason creating the error info should
	    // fail is if there is insufficient memory in which
	    // case we will just rely on the HRESULT to carry
	    // the data.
	    DASSERT(E_OUTOFMEMORY == hr);
	    return hr;
	}

	// Get the IErrorInfo interface to pass back. This
	// should not fail!
	hr = pcerrinfo->QueryInterface(IID_IErrorInfo, (void**)pperrinfo);
	ReleaseInterface(pcerrinfo);
	if (FAILED(hr))
	{
	    DASSERT(SUCCEEDED(hr));
	    return hr;
	}
    }

    DASSERT(NULL != *pperrinfo);

    return S_OK;
} // GetErrorInfo

//*****************************************************************************
//
// Author:      ColinMc
// Created:     10/09/97
// Abstract:    Sets the thread's error object to hold
//              additional data about the error in question
//              NOTE: The return code of this function is
//              the hresult passed in and not a success or
//              failure return from the function itself.
//              This is so you can do a:
//              
//              return SetErrorInfo(hr, ...);
//
//              at the tail of your function
//              
//*****************************************************************************

HRESULT CAutoBase::SetErrorInfo(HRESULT   hr,
				UINT      nDescriptionID,
				LPGUID    pguidInterface,
				DWORD     dwHelpContext,
				LPOLESTR  szHelpFile,
				UINT      nProgID)
{
    TCHAR             szBuffer[gc_cErrorBuffer];
    OLECHAR           wzBuffer[gc_cErrorBuffer];
    IErrorInfo*       perrinfo  = NULL;
    ICreateErrorInfo* pcerrinfo = NULL;
    int               cch;

    // if hr is a SUCCCEEDED case, return
    // NOTE: SUCCEEDED is defined in winerror.h as:
    // #define SUCCEEDED(Status) ((HRESULT)(Status) >= 0)
    // Since we have a debug macro overiding SUCCEEDED, do what
    // the macro in winerror.h is doing.
    if (hr >= 0)
    {
        return hr;
    }

    //print out info on this
    DPF(0, "SetErrorInfo called HRESULT set to [%08X]", hr);
    // Get an IErrorInfo we can use to communicate the
    // error data back to the caller on this thread
    HRESULT hrtmp = GetErrorInfo(&perrinfo);
    if (FAILED(hrtmp))
    {
	// No error object - no extended error information.
	// NOTE: We return the original error and not the one
	// we got trying to allocate an error object
	DPF(0, "Coult not allocate error object - simply returning an HRESULT");
	return hr;
    }

    // Now we have an error object we need to set up the data.
    // To do this we need to get the ICreateErrorInfo
    // interface
    // Currently this is pretty basic.
    // TODO: (ColinMc) Add addition error information to the
    // error object
    hrtmp = perrinfo->QueryInterface(IID_ICreateErrorInfo, (void**)&pcerrinfo);
    if (FAILED(hrtmp))
    {
	// Ouch - the error object does not support
	// ICreateErrorInfo. I don't think this should happen.
	// Again, give the original error back rather than
	// the new one.
	DASSERT(SUCCEEDED(hrtmp));
	return hr;
    }

    // Set the error information. Note, we set it all even if we having
    // nothing to say to ensure we don't return bogus information from 
    // the previous error (as we are re-using the object).
    // If anything fails we just keep going on the assumption that
    // anything is better than nothing.
    DASSERT(NULL != pcerrinfo);
    if (0U != nDescriptionID)
    {
	cch = ::LoadString(GetErrorModuleHandle(), nDescriptionID, szBuffer, sizeof(szBuffer));
	DASSERT(0 != cch);
	::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szBuffer, cch + 1, wzBuffer, gc_cErrorBuffer);
	hrtmp = pcerrinfo->SetDescription(wzBuffer);
    }
    else
    {
	// No description
	hrtmp = pcerrinfo->SetDescription(NULL);
    }
    if (FAILED(hrtmp))
    {
	// Should only fail due insufficient memory
	DASSERT(E_OUTOFMEMORY == hrtmp);
	DPF(0, "Could not set the error description");
    }
    if (NULL != pguidInterface)
	hrtmp = pcerrinfo->SetGUID(*pguidInterface);
    else
	hrtmp = pcerrinfo->SetGUID(GUID_NULL);
    if (FAILED(hrtmp))
    {
	// Should only fail due insufficient memory
	DASSERT(E_OUTOFMEMORY == hrtmp);
	DPF(0, "Could not set the GUID");
    }
    hrtmp = pcerrinfo->SetHelpContext(dwHelpContext);
    if (FAILED(hrtmp))
    {
	// Should only fail due insufficient memory
	DASSERT(E_OUTOFMEMORY == hrtmp);
	DPF(0, "Could not set the help context");
    }
    hrtmp = pcerrinfo->SetHelpFile(szHelpFile);
    if (FAILED(hrtmp))
    {
	// Should only fail due insufficient memory
	DASSERT(E_OUTOFMEMORY == hrtmp);
	DPF(0, "Could not set the help file");
    }
    if (0U != nProgID)
    {
	cch = ::LoadString(GetErrorModuleHandle(), nProgID, szBuffer, sizeof(szBuffer));
	DASSERT(0 != cch);
	::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szBuffer, cch + 1, wzBuffer, gc_cErrorBuffer);
        hrtmp = pcerrinfo->SetSource(wzBuffer);
    }
    else
    {
	// No description
	hrtmp = pcerrinfo->SetSource(NULL);
    }
    if (FAILED(hrtmp))
    {
	// Should only fail due insufficient memory
	DASSERT(E_OUTOFMEMORY == hrtmp);
	DPF(0, "Could not set the source");
    }

    // Done with the creation interface
    ReleaseInterface(pcerrinfo);

    // Finally set the error as the thread's error object.
    // The client should pick this up if it needs more
    // error information
    // NOTE: This should not fail
    hrtmp = ::SetErrorInfo(0UL, perrinfo);
    DASSERT(S_OK == hrtmp);

    // NOTE: The return value of this function is error
    // code passed in and NOT a success or failure value
    // for the function itself.
    return hr;
} // SetErrorInfo

//*****************************************************************************

void CAutoBase::ClearErrorInfo()
{
    // Simply call GetErrorInfo() and release it
    IErrorInfo* perrinfo = NULL;

    // GetErrorInfo clears the current error object as a side
    // effect (which is the point of this function). Therefore
    // we simply discard the resulting error interface.
    HRESULT hr = ::GetErrorInfo(0UL, &perrinfo);
    if (S_OK == hr)
    {
	DASSERT(NULL != perrinfo);
	ReleaseInterface(perrinfo);
	perrinfo = NULL;
    }
} // ClearErrorInfo

//*****************************************************************************

HINSTANCE CAutoBase::GetErrorModuleHandle()
{
    extern CComModule _Module;

    // TODO: (ColinMc) This is a HACK. We need to move to
    // a better scheme for getting the module where the error
    // messages are stored but this will do for now.
    return _Module.GetModuleInstance();
} // GetErrorModuleHandle

//*****************************************************************************
//
// End of file
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\src\basebvr.cpp ===
//*****************************************************************************
//
// File: basebvr.cpp
// Author: jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Implementation of CBaseBehavior object 
//
// Modification List:
// Date         Author          Change
// 09/26/98     jeffort         Created this file
// 10/16/98 jeffort     Added animates property
// 10/16/98 jeffort     Renamed functions, implemented functions to animate
//                      properties
// 10/21/98 jeffort     added BuildTIMEInterpolatedNumber()
// 11/16/98 markhal             added ApplyImageToAnimationElement
// 11/17/98 kurtj       actor construction
// 11/19/98 markhal     Added GetCurrAttrib... methods and prefix hack
//*****************************************************************************

#include "headers.h"

#include "basebvr.h"
#include "dautil.h"
#include "attrib.h"
#include "datime.h"

#define WZ_ACTORDETECTIONMETHOD L"addBehaviorFragment"
#define WZ_ACTOR_URN L"#lmbehavior#actor"
#define WZ_TIMEDA_URN L"#time#da"
#define WZ_TIME_URN L"#time"
#define WZ_TIME_REGISTERED_URN L"TIME_BEHAVIOR_URN"

//*****************************************************************************


CBaseBehavior::CBaseBehavior() :
        m_pBehaviorSite(NULL),
    m_pDAStatics(NULL),
    m_fPropertiesDirty(false),
    m_pHTMLElement(NULL),
    m_fAcceptRebuildRequests( false ),
    m_pdanumZero( NULL ),
    m_pdanumOne( NULL ),
    m_pelemAnimatedParent( NULL )
{
    VariantInit(&m_varAnimates);
} // CBaseBehavior

//*****************************************************************************

CBaseBehavior::~CBaseBehavior()
{
    ReleaseInterface(m_pBehaviorSite);
        // TODO: Figure out why we cannot release this
    //ReleaseInterface(m_pHTMLElement);
    ReleaseInterface(m_pDAStatics);
    VariantClear(&m_varAnimates);

    ReleaseInterface( m_pdanumZero );
    ReleaseInterface( m_pdanumOne );

    ReleaseInterface( m_pelemAnimatedParent );
} // ~CBaseBehavior

//*****************************************************************************

HRESULT 
CBaseBehavior::FinalConstruct()
{
    return S_OK;
} // FinalConstruct

//*****************************************************************************

HRESULT
CBaseBehavior::Init(IElementBehaviorSite *pSite)
{
    HRESULT hr;

    if (pSite == NULL)
    {
        DPF_ERR("Error in Init:  Invalid Site passed into behavior");
        return SetErrorInfo(E_INVALIDARG);
    }
    m_pBehaviorSite = pSite;
    m_pBehaviorSite->AddRef();

    IHTMLElement *pHTMLElement = NULL;
    hr = m_pBehaviorSite->GetElement(&m_pHTMLElement);
    if (FAILED(hr))
    {
        DPF_ERR("Error obtaining an element from an IElementBehaviorSite in GetHTMLAttribute");
        ReleaseInterface(m_pBehaviorSite);
                return SetErrorInfo(hr);
    }
    
    hr = AttachActorBehaviorToAnimatedElement();
    if (FAILED(hr))
    {
        DPF_ERR("Error insuring actor behavior exists");
        ReleaseInterface(m_pBehaviorSite);
        ReleaseInterface(m_pHTMLElement);
        return hr;
    }

    if (GetBehaviorTypeAsURN() != NULL)
    {
        bool fBehaviorExists = false;       
        hr = CheckElementForBehaviorURN(m_pHTMLElement, GetBehaviorTypeAsURN(), &fBehaviorExists);
        if (FAILED(hr))
        {
            DPF_ERR("error detecting if behavior already exists");
            ReleaseInterface(m_pBehaviorSite);
            ReleaseInterface(m_pHTMLElement);
            return hr;
        }
        if (fBehaviorExists)
        {
            DPF_ERR("Error: can not attach behavior of same type to element");
            ReleaseInterface(m_pBehaviorSite);
            ReleaseInterface(m_pHTMLElement);
            // TODO: find better error code
            return SetErrorInfo(E_FAIL);
        }
        // we did not find a match, so set our urn on the behavior site
        IElementBehaviorSiteOM *pSiteOM;
        hr = m_pBehaviorSite->QueryInterface(IID_TO_PPV(IElementBehaviorSiteOM, &pSiteOM));
        if (FAILED(hr))
        {
            DPF_ERR("Error getting behavior IElementBehaviorSiteOM from m_pBehaviorSite");
            ReleaseInterface(m_pBehaviorSite);
            ReleaseInterface(m_pHTMLElement);
            return SetErrorInfo(hr);
        }
        hr = pSiteOM->RegisterUrn(GetBehaviorTypeAsURN());
        ReleaseInterface(pSiteOM);
        if (FAILED(hr))
        {
            DPF_ERR("Error calling RegisterUrn from IElementBehaviorSiteOM");
            ReleaseInterface(m_pBehaviorSite);
            ReleaseInterface(m_pHTMLElement);
            return SetErrorInfo(hr);
        }
    }

	//we need to register a name so that we can communicate with our behaviors if the dispatch on the element has
	// not stabalized yet.
	//BUGBUG: currently this registers the same name for all behaviors.  Since we are not expecting more than one of
	//  our behaviors per element, this should be okay.  If this does change then subclasses should implement GetBehaviorName
	//  with the proper behavior name.
    if( GetBehaviorName() != NULL )
    {
    	IElementBehaviorSiteOM *psiteOM = NULL;

    	hr = m_pBehaviorSite->QueryInterface( IID_TO_PPV( IElementBehaviorSiteOM, &psiteOM ) );
    	if( FAILED( hr ) )
    	{
    		DPF_ERR("Failed to get the behavior site om from the behavior site" );
    		return hr;
    	}

		BSTR bstrName = SysAllocString( GetBehaviorName() );
		if( bstrName == NULL )
		{
			ReleaseInterface( psiteOM );
			return E_OUTOFMEMORY;
		}
		
    	hr = psiteOM->RegisterName( bstrName );
    	ReleaseInterface( psiteOM );
    	SysFreeString( bstrName );
    	if( FAILED( hr ) )
    	{
    		DPF_ERR("Failed to register the behavior name" );
    		return hr;
    	}
    }
    // We need to keep a IDA2Statics interface 
    // We will eventually get this from TIME, which will simply have
    // one created for all objects, 
    hr = GetDAStaticsFromTime(&m_pDAStatics);
    if (FAILED(hr))
    {
        DPF_ERR("Error obtaining DA statics from TIME utility object in Init");
        ReleaseInterface(m_pBehaviorSite);
        ReleaseInterface(m_pHTMLElement);
        return hr;
    }

    return S_OK;    
} // Init

//*****************************************************************************

HRESULT
CBaseBehavior::Notify(LONG dwNotify, VARIANT *pVar)
{
    HRESULT hr = S_OK;

        if (dwNotify == BEHAVIOREVENT_CONTENTREADY)
        {
            m_fAcceptRebuildRequests = true;
        }

        return S_OK;
} // Notify

//*****************************************************************************

HRESULT 
CBaseBehavior::Detach()
{

	CancelRebuildRequests();
	
    ReleaseInterface(m_pBehaviorSite);
    ReleaseInterface(m_pHTMLElement);

    ReleaseInterface( m_pdanumZero );
    ReleaseInterface( m_pdanumOne );

    ReleaseInterface( m_pelemAnimatedParent );
    return S_OK;
} // Detach

//*****************************************************************************

HRESULT 
CBaseBehavior::GetDAStaticsFromTime(IDA2Statics **ppReturn)
{
    DASSERT(ppReturn != NULL);
    DASSERT(m_pHTMLElement != NULL);
    *ppReturn = NULL;

    HRESULT hr;

    // TODO: Eventually this will use IDispatch to get a statics object
    // from TIME.  But this support is not implemented yet
    // So we will simply CoCreate one here
    IDAStatics *pDAStatics;

    hr = CoCreateInstance(CLSID_DAStatics,NULL, CLSCTX_INPROC_SERVER,
                            IID_IDAStatics, (void **)&pDAStatics);      
        if (FAILED(hr))
        {
        DPF_ERR("Error creating DA statics object in Init");
                return SetErrorInfo(hr);
        }
    hr = pDAStatics->QueryInterface(IID_TO_PPV(IDA2Statics, ppReturn));
    ReleaseInterface(pDAStatics);
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing for IDA2Statics from DA statics object");
                return SetErrorInfo(hr);
    }

/*	
    hr = (*ppReturn)->put_ModifiableBehaviorFlags( DAContinueTimeline );
    if ( FAILED( hr ) )
    {
    	DPF_ERR("error setting the modifiable behavior flags on the element" );
    	return hr;
    }
*/
    
    DASSERT(*ppReturn != NULL);
    return S_OK;
} // GetDAStaticsFromTime

//*****************************************************************************

// TODO (markhal): This moves to actor when everything talks to the actor
HRESULT 
CBaseBehavior::AddImageToTIME(IHTMLElement *pElement, IDAImage *pbvrAdd, bool enable)
{
    DASSERT(pbvrAdd != NULL);
    DASSERT(pElement != NULL);

    HRESULT hr;
        DISPPARAMS              params;
        VARIANT                 varResult;
        VariantInit(&varResult);

        BSTR  bstr;
        bstr = ::SysAllocString(enable?L"replace":L"none");

        if (bstr == NULL)
        {
            DPF_ERR("Failed to alloc rendermode string");
            return E_OUTOFMEMORY;
        }
        
        VARIANT                 varValue;
        VariantInit(&varValue);
        V_VT(&varValue) = VT_BSTR;
        V_BSTR(&varValue) = bstr;

    DISPID mydispid = DISPID_PROPERTYPUT;
        params.rgvarg = &varValue;
        params.rgdispidNamedArgs = &mydispid;
        params.cArgs = 1;
        params.cNamedArgs = 1;
        hr = CallInvokeOnHTMLElement(pElement,
                                                                 L"renderMode",
                                                                 DISPATCH_PROPERTYPUT,
                                                                 &params,
                                                                 &varResult);
        VariantClear(&varResult);
        if (FAILED(hr))
        {
                DPF_ERR("Failed to put render status");
                return hr;
        }
        
        VARIANT                 varBehavior;
        VariantInit(&varBehavior);
        varBehavior.vt = VT_DISPATCH;
        varBehavior.pdispVal = pbvrAdd;
        params.rgvarg                           = &varBehavior;
        params.rgdispidNamedArgs        = &mydispid;
        params.cArgs                            = 1;
        params.cNamedArgs                       = 1;
    hr = CallInvokeOnHTMLElement(pElement,
                                 L"Image", 
                                 DISPATCH_PROPERTYPUT,
                                 &params,
                                 &varResult);
        VariantClear(&varResult);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling CallInvokeOnHTMLElement in AddBehaviorToTIME");
                return SetErrorInfo(hr);
    }

    return S_OK;
}

//*****************************************************************************

// TODO (markhal): This moves to actor when everything talks to the actor
HRESULT 
CBaseBehavior::AddBehaviorToTIME(IDABehavior *pbvrAdd)
{
    DASSERT(pbvrAdd != NULL);

    HRESULT hr;

        DISPPARAMS              params;
        VARIANT                 varBehavior;
        VARIANT                 varResult;
        
        VariantInit(&varBehavior);
        varBehavior.vt = VT_DISPATCH;
        varBehavior.pdispVal = pbvrAdd;

        VariantInit(&varResult);

        params.rgvarg                           = &varBehavior;
        params.rgdispidNamedArgs        = NULL;
        params.cArgs                            = 1;
        params.cNamedArgs                       = 0;
    hr = CallInvokeOnHTMLElement(m_pHTMLElement,
                                 L"AddDABehavior", 
                                 DISPATCH_METHOD,
                                 &params,
                                 &varResult);

        VariantClear(&varResult);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling CallInvokeOnHTMLElement in AddBehaviorToTIME");
                return SetErrorInfo(hr);
    }
    return S_OK;
} // AddBehaviorToTIME

//*****************************************************************************

HRESULT 
CBaseBehavior::GetTIMEImageBehaviorFromElement(IHTMLElement *pElement,
                                               IDAImage **pbvrReturnImage)
{
    DASSERT(pElement != NULL);
    DASSERT(pbvrReturnImage != NULL);
    *pbvrReturnImage = NULL;


    HRESULT hr;
        DISPPARAMS              params;
        VARIANT                 varResult;
    VARIANT         rgvarInput[2];


        VariantInit(&varResult);
        VariantInit(&rgvarInput[0]);
        VariantInit(&rgvarInput[1]);

        params.rgvarg                           = rgvarInput;
        params.rgdispidNamedArgs        = NULL;
        params.cArgs                            = 2;
        params.cNamedArgs                       = 0;
        
    hr = CallInvokeOnHTMLElement(pElement,
                                 L"ElementImage", 
                                 DISPATCH_METHOD,
                                 &params,
                                 &varResult);

    if (FAILED(hr))
    {
        DPF_ERR("Error calling CallInvokeOnHTMLElement in GetTIMEImageBehaviorFromElement");
                return SetErrorInfo(hr);
    }

    // we need to fill in our return value here, QI the return value for an IDAImage
    // TODO: coerce to IDips?
    DASSERT(varResult.vt = VT_DISP);
    hr = varResult.pdispVal->QueryInterface(IID_TO_PPV(IDAImage, pbvrReturnImage));
        VariantClear(&varResult);
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing returned disp for DA number");
        return SetErrorInfo(hr);
    }

    return S_OK;
} // GetTIMEImageBehaviorFromElement

//*****************************************************************************

HRESULT 
CBaseBehavior::GetTIMEProgressNumber(IDANumber **ppbvrRet)
{
    DASSERT(ppbvrRet != NULL);
    *ppbvrRet = NULL;

    HRESULT hr;
    DISPPARAMS              params;
    VARIANT                 varResult;

    VariantInit(&varResult);

    params.rgvarg                           = NULL;
    params.rgdispidNamedArgs        		= NULL;
    params.cArgs                            = 0;
    params.cNamedArgs                       = 0;
/*
    IDispatch *pdispDABehavior				=NULL;

    hr = CUtils::FindTimeBehavior( m_pHTMLElement, &pdispDABehavior );
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to find the time da behavior" );
    }
        
    hr = CallInvokeOnDispatch(pdispDABehavior,
                                 L"ProgressBehavior", 
                                 DISPATCH_PROPERTYGET,
                                 &params,
                                 &varResult);

	ReleaseInterface( pdispDABehavior );
*/
	hr = CallInvokeOnHTMLElement(m_pHTMLElement,
                                 L"ProgressBehavior", 
                                 DISPATCH_PROPERTYGET,
                                 &params,
                                 &varResult);

    if (FAILED(hr))
    {
        DPF_ERR("Error calling CallInvokeOnHTMLElement in GetTIMEProgressNumber");
                return SetErrorInfo(hr);
    }

    // we need to fill in our return value here, QI the return value for an IDANumber
    // TODO: coerce to IDips?
    DASSERT(varResult.vt = VT_DISP);
    hr = varResult.pdispVal->QueryInterface(IID_TO_PPV(IDANumber, ppbvrRet));
    VariantClear(&varResult);
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing returned disp for DA number");
        return SetErrorInfo(hr);
    }
    
    return S_OK;
} // GetTIMEProgressNumber

//*****************************************************************************

HRESULT 
CBaseBehavior::GetTIMETimelineBehavior(IDANumber **ppbvrRet)
{
    DASSERT(ppbvrRet != NULL);
    *ppbvrRet = NULL;

    HRESULT hr;
    DISPPARAMS              params;
    VARIANT                 varResult;

    VariantInit(&varResult);

    params.rgvarg                           = NULL;
    params.rgdispidNamedArgs        		= NULL;
    params.cArgs                            = 0;
    params.cNamedArgs                       = 0;
/*
    IDispatch *pdispDABehavior				=NULL;

    hr = CUtils::FindTimeBehavior( m_pHTMLElement, &pdispDABehavior );
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to find the time da behavior" );
    }
        
    hr = CallInvokeOnDispatch(pdispDABehavior,
    							 L"TimelineBehavior", 
                                 DISPATCH_PROPERTYGET,
                                 &params,
                                 &varResult);
    ReleaseInterface( pdispDABehavior );
 */

 	hr = CallInvokeOnHTMLElement(m_pHTMLElement,
 								 L"TimelineBehavior", 
                                 DISPATCH_PROPERTYGET,
                                 &params,
                                 &varResult);
    

    if (FAILED(hr))
    {
        DPF_ERR("Error calling CallInvokeOnHTMLElement in GetTIMETimelineNumber");
                return SetErrorInfo(hr);
    }

    // we need to fill in our return value here, QI the return value for an IDANumber
    // TODO: coerce to IDips?
    DASSERT(varResult.vt = VT_DISP);
    hr = varResult.pdispVal->QueryInterface(IID_TO_PPV(IDANumber, ppbvrRet));
        VariantClear(&varResult);
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing returned disp for DA number");
        return SetErrorInfo(hr);
    }
    
    return S_OK;
} // GetTIMETimelineNumber

//*****************************************************************************

HRESULT 
CBaseBehavior::GetTIMEBooleanBehavior(IDABoolean **ppbvrRet)
{
    DASSERT(ppbvrRet != NULL);
    *ppbvrRet = NULL;

    HRESULT hr;
    DISPPARAMS              params;
    VARIANT                 varResult;

    VariantInit(&varResult);

    params.rgvarg                           = NULL;
    params.rgdispidNamedArgs        		= NULL;
    params.cArgs                            = 0;
    params.cNamedArgs                       = 0;
/*
    IDispatch *pdispDABehavior				= NULL;

    hr = CUtils::FindTimeBehavior( m_pHTMLElement, &pdispDABehavior );
    if( FAILED( hr ) )
    {
    	DPF_ERR("could not find the time da behavior" );
    	return hr;
    }
        
    hr = CallInvokeOnDispatch(pdispDABehavior,
                                 L"OnOffBehavior", 
                                 DISPATCH_PROPERTYGET,
                                 &params,
                                 &varResult);

	ReleaseInterface( pdispDABehavior );
*/

	hr = CallInvokeOnDispatch(m_pHTMLElement,
                                 L"OnOffBehavior", 
                                 DISPATCH_PROPERTYGET,
                                 &params,
                                 &varResult);

	
    if (FAILED(hr))
    {
        DPF_ERR("Error calling CallInvokeOnHTMLElement in GetTIMEBooleanBehavior");
        return SetErrorInfo(hr);
    }

    // we need to fill in our return value here, QI the return value for an IDANumber
    // TODO: coerce to IDips?
    DASSERT(varResult.vt == VT_DISP);
    hr = varResult.pdispVal->QueryInterface(IID_TO_PPV(IDABoolean, ppbvrRet));
        VariantClear(&varResult);
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing returned disp for DA boolean in GetTIMEBooleanBehavior");
        return SetErrorInfo(hr);
    }
    
    return S_OK;
} // GetTIMEBooleanBehavior

//*****************************************************************************

HRESULT 
CBaseBehavior::CallInvokeOnHTMLElement(IHTMLElement *pElement,
                                       LPWSTR lpProperty, 
                                       WORD wFlags,
                                       DISPPARAMS *pdispParms,
                                       VARIANT *pvarResult)
{
    DASSERT(lpProperty != NULL);
    DASSERT(pdispParms != NULL);
    DASSERT(pvarResult != NULL);

    DASSERT(pElement != NULL);

    HRESULT hr;
        IDispatch *pDisp = NULL;
        hr = pElement->QueryInterface(IID_IDispatch, (void **)(&pDisp));
        if (FAILED(hr))
        {
        DPF_ERR("Error QI'ing IHTMLElement for IDispatch failed in CallInvokeOnHTMLElement");
                return SetErrorInfo(hr);
        }

    DISPID dispid;   
    hr = pDisp->GetIDsOfNames(IID_NULL, 
                              &lpProperty, 
                              1,
                              LOCALE_SYSTEM_DEFAULT, 
                              &dispid);    

        if (FAILED(hr))
        {
        DPF_ERR("Error calling GetIDsOFNames in CallInvokeOnHTMLElement");
        LMTRACE(L"The Error was %x\n", hr );
                ReleaseInterface(pDisp);
                return hr;
        }

        EXCEPINFO               excepInfo;
        UINT                    nArgErr;
        
        hr = pDisp->Invoke(dispid,
                                           IID_NULL,
                                           LOCALE_USER_DEFAULT,
                                           wFlags,
                                           pdispParms,
                                           pvarResult,
                                           &excepInfo,
                                           &nArgErr );
    ReleaseInterface(pDisp);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling Invoke on DA TIME behavior in CallInvokeOnHTMLElement");
        VariantClear(pvarResult);
                return hr;
    }

    return S_OK;
} // CallInvokeOnHTMLElement

//*****************************************************************************

// TODO (markhal): Shouldn't the above method call this?
HRESULT 
CBaseBehavior::CallInvokeOnDispatch(IDispatch *pDisp,
                                    LPWSTR lpProperty, 
                                    WORD wFlags,
                                    DISPPARAMS *pdispParms,
                                    VARIANT *pvarResult)
{
    DASSERT(lpProperty != NULL);
    DASSERT(pdispParms != NULL);
    DASSERT(pvarResult != NULL);
        DASSERT(pDispatch  != NULL);

        HRESULT hr = E_FAIL;

    DISPID dispid;   
    hr = pDisp->GetIDsOfNames(IID_NULL, 
                              &lpProperty, 
                              1,
                              LOCALE_SYSTEM_DEFAULT, 
                              &dispid);    

        if (FAILED(hr))
        {
        DPF_ERR("Error calling GetIDsOFNames in Dispatch");
                return hr;
        }

        EXCEPINFO               excepInfo;
        UINT                    nArgErr;
        
        hr = pDisp->Invoke(dispid,
                                           IID_NULL,
                                           LOCALE_USER_DEFAULT,
                                           wFlags,
                                           pdispParms,
                                           pvarResult,
                                           &excepInfo,
                                           &nArgErr );
    if (FAILED(hr))
    {
        DPF_ERR("Error calling Invoke on Dispatch");
        VariantClear(pvarResult);
                return hr;
    }

    return S_OK;
} // CallInvokeOnDispatch

//*****************************************************************************

// TODO (markhal): I think we're going to take animates out of all but the actor
HRESULT 
CBaseBehavior::SetAnimatesProperty(VARIANT varAnimates)
{
    HRESULT hr = VariantCopy(&m_varAnimates, &varAnimates);
    if (FAILED(hr))
    {
        DPF_ERR("Error copying variant in SetAnimatesProperty");
        return SetErrorInfo(hr);
    }
    return S_OK;
} // SetAnimatesProperty

//*****************************************************************************

// TODO (markhal): I think we're going to take animates out of all but the actor
HRESULT 
CBaseBehavior::GetAnimatesProperty(VARIANT *pvarAnimates)
{
    HRESULT hr = VariantCopy(pvarAnimates, &m_varAnimates);
    if (FAILED(hr))
    {
        DPF_ERR("Error copying variant in GetAnimatesProperty");
        return SetErrorInfo(hr);
    }
    return S_OK;
} // GetAnimatesProperty

//*****************************************************************************

// TODO (markhal): This should not be available to behaviors.  What should happen is
// that when buildBehaviorFragments is called we stash the actor IDispatch and calls such
// as this reference that as appropriate, and change names to reflect what's truly happening
HRESULT
CBaseBehavior::GetElementToAnimate(IHTMLElement **ppElementReturn)
{
    HRESULT hr;
    DASSERT(ppElementReturn != NULL);
    *ppElementReturn = NULL;

	IHTMLElement * pActorElement = NULL;
	
	hr = GetAnimatedParentElement(&pActorElement);
	if (FAILED(hr))
	{
		DPF_ERR("Error obtaining animated parent element from HTML element");
		return SetErrorInfo(hr);
	}

	VARIANT	varAnimates;
	VariantInit(&varAnimates);
	hr = pActorElement->getAttribute( BEHAVIOR_PROPERTY_ANIMATES, 0, &varAnimates );
	
    if (FAILED(hr))
    {
		*ppElementReturn = pActorElement;
		return S_OK;
	}
	
	hr = CUtils::InsurePropertyVariantAsBSTR(&varAnimates);
	if ((FAILED(hr)) || (wcslen(varAnimates.bstrVal) == 0))
	{
		*ppElementReturn = pActorElement;
		return S_OK;
	}
		
	ReleaseInterface(pActorElement);
		
	VARIANT varIndex;
	VariantInit(&varIndex);
	varIndex.vt = VT_I4;
	varIndex.intVal = 0;
    
	IDispatch *pDisp = NULL;
	hr = m_pHTMLElement->get_document(&pDisp);
	if (FAILED(hr))
	{
		DPF_ERR("Error obtaining document from HTML element");
		return SetErrorInfo(hr);
	}
	IHTMLDocument2 *pDocument;
	hr = pDisp->QueryInterface(IID_TO_PPV(IHTMLDocument2, &pDocument));
	ReleaseInterface(pDisp);
	if (FAILED(hr))
	{
		DPF_ERR("Error getting a HTMLDocument from IDispatch");
		return SetErrorInfo(hr);
	}
	IHTMLElementCollection *pCollection;
	hr = pDocument->get_all(&pCollection);
	ReleaseInterface(pDocument);
	if (FAILED(hr))
	{
		DPF_ERR("Error obtaining document's all collection");
		return SetErrorInfo(hr);
	}
	DASSERT(pCollection != NULL);
	hr = pCollection->item(varAnimates, varIndex, &pDisp);
	ReleaseInterface(pCollection);
	if (FAILED(hr))
	{
		DPF_ERR("Error searching for item in collection");
		return SetErrorInfo(hr);
	}
	if (pDisp != NULL)
	{
		IHTMLElement *pAnimateElement = NULL;

		hr = pDisp->QueryInterface(IID_TO_PPV(IHTMLElement, ppElementReturn));
		ReleaseInterface(pDisp);
		if (FAILED(hr))
		{
			DPF_ERR("Error obtaining HTMLElement from IDispatch");
			return SetErrorInfo(hr);
		}
	}
	else
	{
		// TODO we can not find the element we are animating????
		// TODO: get a better error string here
		DPF_ERR("Error: animate attribute does not point to valid element");
		return SetErrorInfo(E_FAIL);
	}

    return S_OK;
} // GetElementToAnimate

//*****************************************************************************

// TODO (markhal): I believe we can do without this
HRESULT
CBaseBehavior::GetAnimatedParentElement(IHTMLElement **ppElementReturn)
{

		if( m_pelemAnimatedParent != NULL )
		{
			(*ppElementReturn) = m_pelemAnimatedParent;
			(*ppElementReturn)->AddRef();
			return S_OK;
		}
		
        // Need to skip over actions and sequences and the like.
        // Currently this is pretty simplistic, since we're waiting for the actor code
        IHTMLElement *pCurrElement = m_pHTMLElement;
        pCurrElement->AddRef();

        while (pCurrElement != 0)
        {
                HRESULT hr = pCurrElement->get_parentElement(ppElementReturn);
                ReleaseInterface(pCurrElement);

                if (FAILED(hr))
                {
                        DPF_ERR("Error obtaining parent element");
                        return SetErrorInfo(hr);
                }
                if( (*ppElementReturn) == NULL )
                {
                	DPF_ERR("Got a null parent for the element" );
                	return E_FAIL;
                }

                BSTR bstrTagName;
                hr = (*ppElementReturn)->get_tagName(&bstrTagName);
                int compareResult = _wcsicmp(L"action", bstrTagName);
                SysFreeString(bstrTagName);

                if ( compareResult != 0)
                {
                        // Found a non-action
                        return S_OK;
                }

                pCurrElement = *ppElementReturn;
        }

        return E_FAIL;
}

//*****************************************************************************

// TODO (markhal): This belongs in actor only
HRESULT 
CBaseBehavior::GetIdOfAnimatedElement(VARIANT *pvarId)
{
    HRESULT hr;

    hr = CUtils::InsurePropertyVariantAsBSTR(&m_varAnimates);
    if ((SUCCEEDED(hr)) && (wcslen(m_varAnimates.bstrVal) > 0))
    {
        hr = VariantCopy(pvarId, &m_varAnimates);
    }
    else
    {
        // we need to get the id from our animated parent
		IHTMLElement *pAnimatedElement;
		hr = GetElementToAnimate(&pAnimatedElement);
		if (FAILED(hr))
		{
			DPF_ERR("Error obtaining animated parent element from HTML element");
			return SetErrorInfo(hr);
		}

		hr = pAnimatedElement->getAttribute(L"id", 0, pvarId);

		if ( FAILED(hr) || pvarId->vt != VT_BSTR || pvarId->bstrVal == 0 || SysStringLen(pvarId->bstrVal) == 0)
		{
			// id is not defined on animated parent yet, need to assign it a unique id
			IHTMLUniqueName *pUnique;

			hr = pAnimatedElement->QueryInterface(IID_IHTMLUniqueName, (void **)(&pUnique));

			if ( SUCCEEDED(hr) && pUnique != 0 )
			{
				BSTR uniqueID;
				hr = pUnique->get_uniqueID( &uniqueID );
				ReleaseInterface(pUnique);

				if (SUCCEEDED(hr))
				{
					hr = pAnimatedElement->put_id(uniqueID);

					if (SUCCEEDED(hr))
					{
						VariantClear(pvarId);
						V_VT(pvarId) = VT_BSTR;
						V_BSTR(pvarId) = uniqueID;
					}
					else
						SysFreeString(uniqueID);
				}
			}
		}

		ReleaseInterface(pAnimatedElement);
                
    }

    if (FAILED(hr))
    {
        DPF_ERR("Error getting Id of element to animate in GetIdOfAnimatedElement");
        return SetErrorInfo(hr);
    }

    return S_OK;
} // GetIdOfAnimatedElement

//*****************************************************************************

// TODO (markhal): This goes away when all behaviors talk to the actor
HRESULT
CBaseBehavior::ApplyImageBehaviorToAnimationElement(IDAImage *pbvrImage)
{
        DASSERT(pbvrImage != NULL);

        HRESULT hr;

        IHTMLElement *pAnimatedElement;
        hr = GetElementToAnimate(&pAnimatedElement);
        if (FAILED(hr))
        {
        DPF_ERR("Error getting element to animate");
        return SetErrorInfo(hr);
        }

        hr = AddImageToTIME(pAnimatedElement, pbvrImage, true);
        ReleaseInterface(pAnimatedElement);

        if (FAILED(hr))
        {
        DPF_ERR("Error adding image to TIME");
        return SetErrorInfo(hr);
        }

        return S_OK;
}

//*****************************************************************************

// TODO (markhal): This goes away when all behaviors talk to actor
HRESULT
CBaseBehavior::ApplyColorBehaviorToAnimationElement(IDAColor *pbvrColor,
                                                    WCHAR *pwzProperty)
{
    DASSERT(pbvrColor != NULL);
    DASSERT(pwzProperty != NULL);

    HRESULT hr;

    VARIANT var;
    VariantInit(&var);
    hr = GetIdOfAnimatedElement(&var);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting id of element to animate");
        return hr;
    }
    // change the type of this variant to a bstr
    VARIANT varBstr;
    VariantInit(&varBstr);
    hr = VariantChangeTypeEx(&varBstr, 
                           &var,
                           LCID_SCRIPTING,
                           VARIANT_NOUSEROVERRIDE,
                           VT_BSTR);
    VariantClear(&var);
    if (FAILED(hr))
    {
        DPF_ERR("Error changing variant type to bstr in ApplyColorBehaviorToAnimationElement");
        return SetErrorInfo(hr);
    }
        CComBSTR sProp;
    sProp += varBstr.bstrVal;
    VariantClear(&varBstr);
        sProp += L".";
    sProp += pwzProperty;

    // set this property to be animated on the color
    IDA2Color *pbvrColor2;
    hr = pbvrColor->QueryInterface(IID_TO_PPV(IDA2Color, &pbvrColor2));
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing da color for IDA2Color in ApplyColorBehaviorToAnimationElement");
        return SetErrorInfo(hr);
    }
    IDA2Color *pbvrAnimatesProperty;

        hr = pbvrColor2->AnimateProperty(sProp, L"JScript", 0, 0.02, &pbvrAnimatesProperty);
    ReleaseInterface(pbvrColor2);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling AnimateProperty in ApplyColorBehaviorToAnimationElement");
        return SetErrorInfo(hr);
    }
    hr = AddBehaviorToTIME(pbvrAnimatesProperty);
    ReleaseInterface(pbvrAnimatesProperty);
    if (FAILED(hr))
    {
        DPF_ERR("Error adding a DA behavior to the TIME behavior");
        return hr;
    }
    return S_OK;
} // ApplyColorBehaviorToAnimationElement

//*****************************************************************************

// TODO (markhal): This goes away when all behaviors talk to actor
HRESULT
CBaseBehavior::ApplyNumberBehaviorToAnimationElement(IDANumber *pbvrNumber,
                                                     WCHAR *pwzProperty)
{
    DASSERT(pbvrNumber != NULL);
    DASSERT(pwzProperty != NULL);

    HRESULT hr;

    VARIANT var;
    VariantInit(&var);
    hr = GetIdOfAnimatedElement(&var);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting id of element to animate");
        return hr;
    }
    // change the type of this variant to a bstr
    VARIANT varBstr;
    VariantInit(&varBstr);
    hr = VariantChangeTypeEx(&varBstr, 
                           &var,
                           LCID_SCRIPTING,
                           VARIANT_NOUSEROVERRIDE,
                           VT_BSTR);
    VariantClear(&var);
    if (FAILED(hr))
    {
        DPF_ERR("Error changing variant type to bstr in ApplyNumberBehaviorToAnimationElement");
        return SetErrorInfo(hr);
    }
        CComBSTR sProp;
    sProp += varBstr.bstrVal;
    VariantClear(&varBstr);
        sProp += L".";
    sProp += pwzProperty;

    IDANumber *pbvrAnimatesProperty;
        hr = pbvrNumber->AnimateProperty(sProp, L"JScript", 0, 0.02, &pbvrAnimatesProperty);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling AnimateProperty in ApplyNumberBehaviorToAnimationElement");
        return SetErrorInfo(hr);
    }
    hr = AddBehaviorToTIME(pbvrAnimatesProperty);
    ReleaseInterface(pbvrAnimatesProperty);
    if (FAILED(hr))
    {
        DPF_ERR("Error adding a DA behavior to the TIME behavior");
        return hr;
    }

    return S_OK;
} // ApplyNumberBehaviorToAnimationElement

//*****************************************************************************

// TODO (markhal): This goes away when all behaviors talk to actor
HRESULT
CBaseBehavior::ApplyStringBehaviorToAnimationElement(IDAString *pbvrString,
                                                     WCHAR *pwzProperty)
{
    DASSERT(pbvrString != NULL);
    DASSERT(pwzProperty != NULL);

    HRESULT hr;

    VARIANT var;
    VariantInit(&var);
    hr = GetIdOfAnimatedElement(&var);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting id of element to animate");
        return hr;
    }
    // change the type of this variant to a bstr
    VARIANT varBstr;
    VariantInit(&varBstr);
    hr = VariantChangeTypeEx(&varBstr, 
                           &var,
                           LCID_SCRIPTING,
                           VARIANT_NOUSEROVERRIDE,
                           VT_BSTR);
    VariantClear(&var);
    if (FAILED(hr))
    {
        DPF_ERR("Error changing variant type to bstr in ApplyStringBehaviorToAnimationElement");
        return SetErrorInfo(hr);
    }
        CComBSTR sProp;
    sProp += varBstr.bstrVal;
    VariantClear(&varBstr);
        sProp += L".";
    sProp += pwzProperty;

    IDAString *pbvrAnimatesString;
        hr = pbvrString->AnimateProperty(sProp, L"JScript", 0, 0.02, &pbvrAnimatesString);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling AnimateProperty in ApplyStringBehaviorToAnimationElement");
        return SetErrorInfo(hr);
    }
    hr = AddBehaviorToTIME(pbvrAnimatesString);
    ReleaseInterface(pbvrAnimatesString);
    if (FAILED(hr))
    {
        DPF_ERR("Error adding a DA behavior to the TIME behavior");
        return hr;
    }

    return S_OK;
} // ApplyStringBehaviorToAnimationElement

//*****************************************************************************

// TODO (markhal): This goes away when all behaviors talk to actor
HRESULT 
CBaseBehavior::ApplyEffectBehaviorToAnimationElement(IUnknown *pbvrUnk, 
                                                     IDABehavior **ppbvrInputs,
                                                     long cInputs)
{
    DASSERT(pbvrUnk != NULL);

    HRESULT hr;

    IHTMLElement *pAnimatedElement;
    hr = GetElementToAnimate(&pAnimatedElement);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting element to animate");
        return hr;
    }
    // get the progress from our time element
    IDANumber *pbvrProgress;
    hr = GetTIMEProgressNumber(&pbvrProgress);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting progress behavior from time");
        ReleaseInterface(pAnimatedElement);
        return SetErrorInfo(hr);
    }
    IDADXTransformResult *ptransResult;

    hr = m_pDAStatics->ApplyDXTransformEx(pbvrUnk,
                                          cInputs,
                                          ppbvrInputs,
                                          pbvrProgress,
                                          &ptransResult);
    ReleaseInterface(pbvrProgress);
    if (FAILED(hr))
    {
        DPF_ERR("Error applying transform to image");
        ReleaseInterface(pAnimatedElement);
        return SetErrorInfo(hr);
    }

    IDABehavior *pbvrOutput;
    hr = ptransResult->get_OutputBvr(&pbvrOutput);
    ReleaseInterface(ptransResult);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting output behavior from transfrom");
        ReleaseInterface(pAnimatedElement);
        return SetErrorInfo(hr);
    }
    IDAImage *pbvrFinalImage;
    
    hr = pbvrOutput->QueryInterface(IID_TO_PPV(IDAImage, &pbvrFinalImage));
    ReleaseInterface(pbvrOutput);
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing transform output for DA image");
        return SetErrorInfo(hr);
    }

    hr = AddImageToTIME(pAnimatedElement, pbvrFinalImage, true);
    ReleaseInterface(pAnimatedElement);
    ReleaseInterface(pbvrFinalImage);
    if (FAILED(hr))
    {
        DPF_ERR("Error adding image to TIME in ApplyEffectBehaviorToAnimationElement");
        return SetErrorInfo(hr);
    }
    return S_OK;
} // ApplyEffectBehaviorToAnimationElement

//*****************************************************************************
// TODO (markhal): This goes away when all behaviors talk to actor
HRESULT
CBaseBehavior::ApplyRotationBehaviorToAnimationElement(IDANumber *pbvrNumber,
                                                     WCHAR *pwzProperty)
{
    // ultimately, this will be in the actor object, but lets get
    // it going for testing purposes

    DASSERT(pbvrNumber != NULL);
    DASSERT(pwzProperty != NULL);

    HRESULT hr;

    IHTMLElement *pAnimatedElement;


    IDATransform2 *pRotationTransform;
    hr = CDAUtils::BuildRotationTransform2(m_pDAStatics, pbvrNumber, &pRotationTransform);
    if (FAILED(hr))
    {
        DPF_ERR("Error building transform2 from rotation");
        return SetErrorInfo(hr);
    }

    hr = GetElementToAnimate(&pAnimatedElement);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting element to animate");
        ReleaseInterface(pRotationTransform);
        return hr;
    }
    IDAImage *pbvrOriginalImage;
    hr = GetTIMEImageBehaviorFromElement(pAnimatedElement,
                                         &pbvrOriginalImage);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting original image form HTML element");
        ReleaseInterface(pAnimatedElement);
        ReleaseInterface(pRotationTransform);
        return SetErrorInfo(hr);
    }

    // apply the transform to the image
    IDAImage *pbvrRotatedImage;
    hr = pbvrOriginalImage->Transform(pRotationTransform, &pbvrRotatedImage);
    ReleaseInterface(pRotationTransform);
    ReleaseInterface(pbvrOriginalImage);
    if (FAILED(hr))
    {
        DPF_ERR("Error transforming image in ApplyRotationBehaviorToAnimationElement");
        ReleaseInterface(pAnimatedElement);
        return SetErrorInfo(hr);
    }
    hr = AddImageToTIME(pAnimatedElement, pbvrRotatedImage, true);
    ReleaseInterface(pAnimatedElement);
    ReleaseInterface(pbvrRotatedImage);
    if (FAILED(hr))
    {
        DPF_ERR("Error adding image to TIME in ApplyRotationBehaviorToAnimationElement");
        return SetErrorInfo(hr);
    }
    return S_OK;
} // ApplyRotationBehaviorToAnimationElement

//*****************************************************************************
// TODO (markhal): This won't be necessary when all behaviors talk to actor (no notion of original)
HRESULT
CBaseBehavior::BuildTIMEInterpolatedNumber(float flFrom,
                                           float flTo,
                                           float flOriginal,
                                           IDANumber **ppbvrReturn)
{
    HRESULT hr;

    IDANumber *pbvrProgress;
    hr = GetTIMEProgressNumber(&pbvrProgress);
    if (FAILED(hr))
    {
        DPF_ERR("Unable to access progress value from TIME behavior");
        return hr;
    }
    IDANumber *pbvrInterpolatedValue;
    hr = CDAUtils::TIMEInterpolateNumbers(m_pDAStatics, 
                                          flFrom, 
                                          flTo, 
                                          pbvrProgress, 
                                          &pbvrInterpolatedValue);

    ReleaseInterface(pbvrProgress);
    if (FAILED(hr))
    {
        DPF_ERR("Error interpolating angle in BuildTIMEInterpolatedNumber");
        return hr;
    }

    IDANumber *pbvrOriginalValue;
    hr = CDAUtils::GetDANumber(m_pDAStatics,
                               flOriginal,
                               &pbvrOriginalValue);

    if (FAILED(hr))
    {
        DPF_ERR("Error creating DA number from static values");
        ReleaseInterface(pbvrInterpolatedValue);
        return SetErrorInfo(hr);
    }
    IDABoolean *pbvrBoolean;
    hr = GetTIMEBooleanBehavior(&pbvrBoolean);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting TIME boolean");
        ReleaseInterface(pbvrInterpolatedValue);
        ReleaseInterface(pbvrOriginalValue);
        return SetErrorInfo(hr);
    }
    IDABehavior *pbvrFinalBehavior;
    hr = SafeCond(GetDAStatics(),
                  pbvrBoolean, 
                  pbvrInterpolatedValue,
                  pbvrOriginalValue,
                  &pbvrFinalBehavior);
    ReleaseInterface(pbvrBoolean);
    ReleaseInterface(pbvrInterpolatedValue);
    ReleaseInterface(pbvrOriginalValue);
    if (FAILED(hr))
    {
        DPF_ERR("Error building DA conditional in BuildTIMEInterpolatedNumber");
        return SetErrorInfo(hr);
    }
    hr = pbvrFinalBehavior->QueryInterface(IID_TO_PPV(IDANumber, ppbvrReturn));
    ReleaseInterface(pbvrFinalBehavior);
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing DA behavior for DA number in BuildTIMEInterpolatedNumber");
        return SetErrorInfo(hr);
    }
    return S_OK;
} // BuildTIMEInterpolatedNumber

//*****************************************************************************

HRESULT
CBaseBehavior::BuildTIMEInterpolatedNumber(float flFrom,
                                           float flTo,
                                           IDANumber **ppbvrReturn)
{
    HRESULT hr;

    IDANumber *pbvrProgress;
    hr = GetTIMEProgressNumber(&pbvrProgress);
    if (FAILED(hr))
    {
        DPF_ERR("Unable to access progress value from TIME behavior");
        return hr;
    }
    hr = CDAUtils::TIMEInterpolateNumbers(m_pDAStatics, 
                                          flFrom, 
                                          flTo, 
                                          pbvrProgress, 
                                          ppbvrReturn);

    ReleaseInterface(pbvrProgress);
    if (FAILED(hr))
    {
        DPF_ERR("Error interpolating angle in BuildTIMEInterpolatedNumber");
        return hr;
    }

    return S_OK;
} // BuildTIMEInterpolatedNumber

HRESULT
CBaseBehavior::BuildTIMEInterpolatedNumber(IDANumber *pFrom,
										   IDANumber *pTo,
										   IDANumber **ppResult)
{
    HRESULT hr;

	IDANumber *pDiff;
	hr = GetDAStatics()->Sub(pTo, pFrom, &pDiff);
	if (FAILED(hr))
		return hr;

    IDANumber *pProgress;
    hr = GetTIMEProgressNumber(&pProgress);
	if (FAILED(hr))
	{
		ReleaseInterface(pDiff);
		return hr;
	}

	IDANumber *pFraction;
	hr = GetDAStatics()->Mul(pProgress, pDiff, &pFraction);
	ReleaseInterface(pProgress);
	ReleaseInterface(pDiff);
	if (FAILED(hr))
		return hr;

	hr = GetDAStatics()->Add(pFrom, pFraction, ppResult);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

//*****************************************************************************

/**
* Asks the actor for an image representing the rendered element bits
*/
HRESULT 
CBaseBehavior::GetImageFromActor(IDispatch   *pActorDisp,
                                                                 IDAImage        **ppImage)
{
        // TODO (markhal): The call on the actor is now more generic - it will get
        // a behavior from any track.  At some point we might want to replace this method
        // with a more generic counterpart.  Currently I'll just make it work for image.
    DASSERT(ppImage != NULL);
    *ppImage = NULL;

    HRESULT hr;
        DISPPARAMS              params;
        VARIANT                 varResult;
    VARIANT         rgvarInput[3];
        VariantInit(&varResult);
        VariantInit(&rgvarInput[0]);
        VariantInit(&rgvarInput[1]);
        VariantInit(&rgvarInput[2]);

        params.rgvarg                           = rgvarInput;
        params.rgdispidNamedArgs        = NULL;
        params.cArgs                            = 3;
        params.cNamedArgs                       = 0;
        
    rgvarInput[2].vt = VT_BSTR;
    rgvarInput[2].bstrVal = ::SysAllocString(L"image");

    rgvarInput[1].vt = VT_UI4;
    rgvarInput[1].intVal = e_Intermediate;

    rgvarInput[0].vt = VT_UI4;
    rgvarInput[0].intVal = e_Image;

    hr = CallInvokeOnDispatch(   pActorDisp,
                                 L"getActorBehavior", 
                                 DISPATCH_METHOD,
                                 &params,
                                 &varResult);

    if (FAILED(hr))
    {
        DPF_ERR("Error calling CallInvokeOnDispatch");
                return SetErrorInfo(hr);
    }

    // we need to fill in our return value here, QI the return value for an IDAImage
    hr = VariantChangeType(&varResult, &varResult, 0, VT_UNKNOWN);
        if (FAILED(hr))
        {
                DPF_ERR("Failed to get an IUnknown");
                return SetErrorInfo(hr);
        }

    hr = V_UNKNOWN(&varResult)->QueryInterface(IID_TO_PPV(IDAImage, ppImage));
        VariantClear(&varResult);
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing returned disp for DA Image");
        return SetErrorInfo(hr);
    }
    
    return S_OK;
}

HRESULT 
CBaseBehavior::GetBvrFromActor(IDispatch       *pActorDisp,
							   WCHAR		   *pwzProperty,
							   ActorBvrFlags	eFlags,
							   ActorBvrType		eType,
							   IDABehavior    **ppResult)
{
    DASSERT(ppResult != NULL);
    *ppResult = NULL;

    HRESULT hr;
    DISPPARAMS              params;
    VARIANT                 varResult;
    VARIANT         rgvarInput[3];
    VariantInit(&varResult);
    VariantInit(&rgvarInput[0]);
    VariantInit(&rgvarInput[1]);
    VariantInit(&rgvarInput[2]);

    params.rgvarg                           = rgvarInput;
    params.rgdispidNamedArgs                = NULL;
    params.cArgs                            = 3;
    params.cNamedArgs                       = 0;
    
	BSTR prop = ::SysAllocString(pwzProperty);
    rgvarInput[2].vt = VT_BSTR;
    rgvarInput[2].bstrVal = prop;

    rgvarInput[1].vt = VT_UI4;
    rgvarInput[1].intVal = eFlags;

    rgvarInput[0].vt = VT_UI4;
    rgvarInput[0].intVal = eType;

    hr = CallInvokeOnDispatch(   pActorDisp,
                                 L"getActorBehavior", 
                                 DISPATCH_METHOD,
                                 &params,
                                 &varResult);
	::SysFreeString(prop);

    if (FAILED(hr))
    {
        DPF_ERR("Error calling CallInvokeOnDispatch");
                return SetErrorInfo(hr);
    }

    // we need to fill in our return value here, QI the return value for an IDABehavior
    hr = VariantChangeType(&varResult, &varResult, 0, VT_UNKNOWN);
    if (FAILED(hr))
    {
            DPF_ERR("Failed to get an IUnknown");
            return SetErrorInfo(hr);
    }

    hr = V_UNKNOWN(&varResult)->QueryInterface(IID_TO_PPV(IDABehavior, ppResult));
    VariantClear(&varResult);
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing returned disp for DA Behavior");
        return SetErrorInfo(hr);
    }
    
    return S_OK;
}

//*****************************************************************************

/**
* Passes the given behavior/property/flags/type to the actor
*/
HRESULT 
CBaseBehavior::AttachBehaviorToActor(IDispatch   *pActorDisp,
                                                                         IDABehavior *pbvrAttach,
                                     BSTR        bstrProperty,
                                     ActorBvrFlags  eFlags,
                                     ActorBvrType   eType)
{

    HRESULT                     hr;
        DISPPARAMS              params;
        VARIANT                 varResult;
    VARIANT         rgvarInput[6];

    IDABoolean *pbvrBool;

    hr = GetTIMEBooleanBehavior(&pbvrBool);
    if (FAILED(hr))
    {
        DPF_ERR("Error obtaining boolean from TIME");
        return hr;
    }

	IDANumber *pTimeline = NULL;
	hr = GetTIMETimelineBehavior(&pTimeline);
	if (FAILED(hr))
	{
		ReleaseInterface(pbvrBool);
		return hr;
	}


    VariantInit(&varResult);
    VariantInit(&rgvarInput[0]);
    VariantInit(&rgvarInput[1]);
    VariantInit(&rgvarInput[2]);
    VariantInit(&rgvarInput[3]);
    VariantInit(&rgvarInput[4]);
	VariantInit(&rgvarInput[5]);

    params.rgvarg                           = rgvarInput;
    params.rgdispidNamedArgs        = NULL;
    params.cArgs                            = 6;
    params.cNamedArgs                       = 0;
        
    rgvarInput[5].vt = VT_BSTR;
    rgvarInput[5].bstrVal = bstrProperty;

    rgvarInput[4].vt = VT_UNKNOWN;
    rgvarInput[4].punkVal = pbvrAttach;

    rgvarInput[3].vt = VT_UNKNOWN;
    rgvarInput[3].punkVal = pbvrBool;

	rgvarInput[2].vt = VT_UNKNOWN;
	rgvarInput[2].punkVal = pTimeline;

    rgvarInput[1].vt = VT_UI4;
    rgvarInput[1].intVal = eFlags;

    rgvarInput[0].vt = VT_UI4;
    rgvarInput[0].intVal = eType;

    hr = CallInvokeOnDispatch(   pActorDisp,
                                 L"addBehaviorFragment", 
                                 DISPATCH_METHOD,
                                 &params,
                                 &varResult);
    ReleaseInterface(pbvrBool);
	ReleaseInterface(pTimeline);

    if (FAILED(hr))
    {
        DPF_ERR("Error calling IDispatch into actor behavior");
        return hr;
    }
    return S_OK;
} // AttachBehaviorToActor

//*****************************************************************************

HRESULT 
CBaseBehavior::AttachBehaviorToActorEx(IDispatch   *pActorDisp,
                                       IDABehavior *pbvrAttach,
                                       BSTR        bstrProperty,
                                       ActorBvrFlags  eFlags,
                                       ActorBvrType   eType,
                                       IDispatch     *pdispBehaviorElement,
                                       long* pCookie)
{
    if( pCookie == NULL )
        return E_INVALIDARG;

    HRESULT                     hr;
    DISPPARAMS              params;
    VARIANT                 varResult;
    VARIANT         rgvarInput[7];

    IDABoolean *pbvrBool;

    hr = GetTIMEBooleanBehavior(&pbvrBool);
    if (FAILED(hr))
    {
        DPF_ERR("Error obtaining boolean from TIME");
        return hr;
    }

	IDANumber *pTimeline = NULL;
	hr = GetTIMETimelineBehavior(&pTimeline);
	if (FAILED(hr))
	{
		ReleaseInterface(pbvrBool);
		return hr;
	}


    VariantInit(&varResult);
    VariantInit(&rgvarInput[0]);
    VariantInit(&rgvarInput[1]);
    VariantInit(&rgvarInput[2]);
    VariantInit(&rgvarInput[3]);
    VariantInit(&rgvarInput[4]);
	VariantInit(&rgvarInput[5]);
    VariantInit(&rgvarInput[6]);
    
    params.rgvarg                           = rgvarInput;
    params.rgdispidNamedArgs        		= NULL;
    params.cArgs                            = 7;
    params.cNamedArgs                       = 0;


    V_VT(&rgvarInput[6]) = VT_BSTR;
    V_BSTR(&rgvarInput[6]) = bstrProperty;

    V_VT(&rgvarInput[5]) = VT_UNKNOWN;
    V_UNKNOWN(&rgvarInput[5]) = pbvrAttach;

    V_VT(&rgvarInput[4]) = VT_UNKNOWN;
    V_UNKNOWN(&rgvarInput[4]) = pbvrBool;

	V_VT(&rgvarInput[3]) = VT_UNKNOWN;
	V_UNKNOWN(&rgvarInput[3]) = pTimeline;

    V_VT(&rgvarInput[2]) = VT_UI4;
    V_UI4(&rgvarInput[2]) = eFlags;

    V_VT(&rgvarInput[1]) = VT_UI4;
    V_UI4(&rgvarInput[1]) = eType;

    V_VT(&rgvarInput[0]) = VT_DISPATCH;
    V_DISPATCH(&rgvarInput[0]) = pdispBehaviorElement;

    hr = CallInvokeOnDispatch(   pActorDisp,
                                 L"addBehaviorFragmentEx", 
                                 DISPATCH_METHOD,
                                 &params,
                                 &varResult);
    ReleaseInterface(pbvrBool);
	ReleaseInterface(pTimeline);

    if (FAILED(hr))
    {
        DPF_ERR("Error calling IDispatch into actor behavior");
        return hr;
    }

    if( V_VT(&varResult) != VT_I4 )
    {
        hr = ::VariantChangeTypeEx( &varResult, &varResult, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_I4 );
        if( FAILED(hr) )
        {
               DPF_ERR("Failed to convert return value to I4");
               return hr;
        }
    }

    (*pCookie) = V_I4(&varResult);
    ::VariantClear( &varResult );

    return S_OK;
} // AttachBehaviorToActorEx

//*****************************************************************************

HRESULT
CBaseBehavior::RemoveBehaviorFromActor( IDispatch *pActorDisp, long cookie )
{
    HRESULT                     hr;
    DISPPARAMS              params;
    VARIANT                 varResult;
    VARIANT                 varInput;

    VariantInit( &varResult );
    VariantInit( &varInput );

    V_VT(&varInput) = VT_I4;
    V_I4(&varInput) = cookie;

    params.rgvarg                           = &varInput;
    params.rgdispidNamedArgs                = NULL;
    params.cArgs                            = 1;
    params.cNamedArgs                       = 0;

    hr = CallInvokeOnDispatch( pActorDisp,
                               L"removeBehaviorFragment",
                               DISPATCH_METHOD,
                               &params,
                               &varResult);
    if( FAILED( hr ) )
    {
        DPF_ERR("Failed to invoke removeBehaviorFragment on actor disp" );
        return hr;
    }

    VariantClear( &varResult );

    return hr;
}

//*****************************************************************************

HRESULT
CBaseBehavior::RemoveBehaviorFromActor( long cookie )
{
	HRESULT hr = S_OK;
	IHTMLElement* pelemActor = NULL;
	IDispatch* pdispActorElem = NULL;

	
	hr = GetAnimatedParentElement( &pelemActor );
	CheckHR( hr, "Failed to find animated parent element", end );

	hr = GetHTMLElement()->QueryInterface( IID_TO_PPV( IDispatch, &pdispActorElem ) );
	CheckHR( hr, "QI for IDispatch on the behavior element failed", end );

	hr = RemoveBehaviorFromActor( pelemActor, cookie );

end:
	ReleaseInterface( pelemActor );
	ReleaseInterface( pdispActorElem );
	
	return hr;
}

//*****************************************************************************

HRESULT 
CBaseBehavior::CheckElementForBehaviorURN(IHTMLElement *pElement, WCHAR *wzURN, bool *pfReturn)
{
    DASSERT(pElement != NULL);
    DASSERT(wzURN != NULL);
    DASSERT(pfReturn != NULL);

    *pfReturn = false;
    HRESULT hr;
    IHTMLElement2 *pElement2;
    hr = pElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElement2));
    if (SUCCEEDED(hr) && pElement2 != NULL)
    {
        // get a collection of urns from the element
        IDispatch *pDisp;
        hr = pElement2->get_behaviorUrns(&pDisp);
        ReleaseInterface(pElement2);
        if (FAILED(hr))
        {
            DPF_ERR("Error getting behavior urns from element");
            return SetErrorInfo(hr);
        }
        IHTMLUrnCollection *pUrnCollection;
        hr = pDisp->QueryInterface(IID_TO_PPV(IHTMLUrnCollection, &pUrnCollection));
        ReleaseInterface(pDisp);
        if (FAILED(hr))
        {
            DPF_ERR("Error getting behavior urns from dispatch");
            return SetErrorInfo(hr);
        }
        long cUrns;
        hr = pUrnCollection->get_length(&cUrns);
        if (FAILED(hr))
        {
            DPF_ERR("Error getting behavior urns from dispatch");
            ReleaseInterface(pUrnCollection);
            return SetErrorInfo(hr);
        }
        for (long iUrns = 0; iUrns < cUrns; iUrns++)
        {
            // get the urn from the collection
            BSTR bstrUrn;
            hr = pUrnCollection->item(iUrns, &bstrUrn);
            if (FAILED(hr))
            {
                DPF_ERR("Error getting behavior urns from dispatch");
                ReleaseInterface(pUrnCollection);
                return SetErrorInfo(hr);
            }
            // now compare this urn with our behavior type
            if (bstrUrn != NULL && _wcsicmp(bstrUrn, wzURN) == 0)
            {
                // we have a match. . .get out of here 
                SysFreeString(bstrUrn);
                DPF_ERR("Error getting behavior urns from dispatch");
                ReleaseInterface(pUrnCollection);
                *pfReturn = true;
                return S_OK;

            }
            if (bstrUrn != NULL)
                SysFreeString(bstrUrn);
        }
        ReleaseInterface(pUrnCollection);
    }
    return S_OK;
} // CheckElementForBehaviorURN

//*****************************************************************************

HRESULT
CBaseBehavior::AttachEffectToActor(IDispatch *pActorDisp,
                                   IUnknown *pbvrUnk, 
                                   IDABehavior **ppbvrInputs,
                                   long cInputs,
                                   IDispatch *pdispThis,
                                   long	*pCookie)
{
    DASSERT(pbvrUnk != NULL);

    HRESULT hr;

    // get the progress from our time element
    IDANumber *pbvrProgress;
    hr = GetTIMEProgressNumber(&pbvrProgress);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting progress behavior from time");
        return SetErrorInfo(hr);
    }

    IDADXTransformResult *ptransResult;

    hr = m_pDAStatics->ApplyDXTransformEx(pbvrUnk,
                                          cInputs,
                                          ppbvrInputs,
                                          pbvrProgress,
                                          &ptransResult);
    ReleaseInterface(pbvrProgress);
    if (FAILED(hr))
    {
        DPF_ERR("Error applying transform to image");
        return SetErrorInfo(hr);
    }

    IDABehavior *pbvrOutput;
    hr = ptransResult->get_OutputBvr(&pbvrOutput);
    ReleaseInterface(ptransResult);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting output behavior from transfrom");
        return SetErrorInfo(hr);
    }

    IDAImage *pbvrFinalImage;
    
    hr = pbvrOutput->QueryInterface(IID_TO_PPV(IDAImage, &pbvrFinalImage));
    ReleaseInterface(pbvrOutput);
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing transform output for DA image");
        return SetErrorInfo(hr);
    }

    hr = AttachBehaviorToActorEx(pActorDisp, pbvrFinalImage, L"image", e_Filter, e_Image, pdispThis, pCookie);
    ReleaseInterface(pbvrFinalImage);
    if (FAILED(hr))
    {
        DPF_ERR("Error adding image to Actor");
        return SetErrorInfo(hr);
    }
    return S_OK;
}

//*****************************************************************************

HRESULT 
CBaseBehavior::CheckElementForActor( IHTMLElement* pElement, bool *pfActorPresent)
{

    HRESULT hr;

    DASSERT(pfActorPresent != NULL);
    *pfActorPresent = false;

    // What's the best way to insure this exists???
    // For now we will simply check to see if the method
    // we need to add our behaviors to exists, and if not
    // we will return false.

    DASSERT(pElement != NULL);
    hr = CheckElementForBehaviorURN(pElement, DEFAULT_ACTOR_URN, pfActorPresent);
    if (FAILED(hr))
    {
        DPF_ERR("Error detecting if actor exists");
        return hr;
    }
    return S_OK;
} // CheckAnimatedElementForActor

//*****************************************************************************

HRESULT
CBaseBehavior::CheckElementForDA(IHTMLElement* pElement, bool *pfReturn)
{
    HRESULT hr;

    DASSERT(pfReturn != NULL);
    *pfReturn = false;

    // What's the best way to insure this exists???
    // For now we will simply check to see if the method
    // we need to add TIME behaviors exists, and if not
    // we will return false.
    DASSERT(pElement != NULL);

    IDispatch *pDisp = NULL;
    hr = pElement->QueryInterface(IID_TO_PPV(IDispatch, &pDisp));
    if (FAILED(hr))
    {
    DPF_ERR("Error QI'ing IHTMLElement for IDispatch failed");
            return SetErrorInfo(hr);
    }

    DISPID dispid;
    LPWSTR methodName = L"AddDABehavior";
    hr = pDisp->GetIDsOfNames(IID_NULL, 
                              &methodName, 
                              1,
                              LOCALE_SYSTEM_DEFAULT, 
                              &dispid); 
    ReleaseInterface(pDisp);
	
	if (SUCCEEDED(hr))
		*pfReturn = true;

    return S_OK;
}

//*****************************************************************************

HRESULT
CBaseBehavior::AttachDABehaviorsToElement( IHTMLElement *pElement )
{
	if( pElement == NULL )
		return E_INVALIDARG;

	HRESULT hr;
    
    bool fTimeExist;
    bool fTimeDAExist;

    hr = CheckElementForBehaviorURN(pElement, WZ_TIME_REGISTERED_URN, &fTimeExist);
    if (FAILED(hr))
    {
        return hr;
    }

	// REVIEW: we'd like to check for the registered URN, but DA isn't doing this yet.
    hr = CheckElementForDA(pElement, &fTimeDAExist);
    if (FAILED(hr))
    {
        return hr;
    }
    
    if (!fTimeExist || !fTimeDAExist)
    {
        IHTMLElement2 *pElement2;
        hr = pElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElement2));
        if (FAILED(hr))
        {
            DPF_ERR("Error QI'ing HTML element for IHTMLElement2");
            return SetErrorInfo(hr);
        }

        ITIMEFactory *pTimeFactory;
        hr = CoCreateInstance(CLSID_TIMEFactory, 
                              NULL, 
                              CLSCTX_INPROC_SERVER, 
                              IID_ITIMEFactory, 
                              (void**)&pTimeFactory);
        if (FAILED(hr))
        {
            DPF_ERR("Error creating time factory");
            ReleaseInterface(pElement2);
            return SetErrorInfo(hr);
        }

        // Before we add the TIME behavior, we check to see whether there is
        // a t:timeAction already set on the element
        bool timeActionSet = false;
        VARIANT var;
        VariantInit(&var);
        if (!fTimeExist)
        {
			DISPPARAMS					params;
			params.rgvarg				= NULL;
			params.rgdispidNamedArgs    = NULL;
			params.cArgs                = 0;
			params.cNamedArgs           = 0;
        
			hr = CallInvokeOnHTMLElement(pElement,
										 L"t:timeAction", 
										 DISPATCH_PROPERTYGET,
										 &params,
										 &var);

            if (FAILED(hr) || V_VT(&var) == VT_EMPTY || V_VT(&var) == VT_NULL ||
                (V_VT(&var) == VT_BSTR && V_BSTR(&var) == NULL))
            {
                timeActionSet = false;
            }
            else
                timeActionSet = true;

            VariantClear(&var);
        }
        
        // Risky, and unfun, we need to add a time DA element
        // to the HTML element, hard code this string above
        var.vt = VT_UNKNOWN;
        var.punkVal = pTimeFactory;
        long nCookie;

        // We need to add the da element first in case the element is
        // the body.  If not then the body will have a time element
        // when it should have a time body element
		hr = S_OK;

        if (!fTimeDAExist)
            hr = pElement2->addBehavior(WZ_TIMEDA_URN, &var, &nCookie);

        if (SUCCEEDED(hr) && !fTimeExist)
        {
            hr = pElement2->addBehavior(WZ_TIME_URN, &var, &nCookie);
        }
        
        ReleaseInterface(pTimeFactory);
        if (FAILED(hr))
        {
            DPF_ERR("Error adding time element to html");
            ReleaseInterface(pElement2);
            return SetErrorInfo(hr);
        }

        // If we added TIME, we need to set timeAction=none,
        // otherwise the element would appear and disappear since timeAction defaults
        // to visibility
        // Only do this if we didn't detect a timeAction attribute already
        if (!fTimeExist && !timeActionSet)
        {
            VARIANT varAction;
            VariantInit(&varAction);
            V_VT(&varAction) = VT_BSTR;
            V_BSTR(&varAction) = ::SysAllocString(L"none");

            BSTR attribName = ::SysAllocString(L"timeAction");

            hr = pElement->setAttribute(attribName, varAction);
            ::SysFreeString(attribName);
            VariantClear(&varAction);
            if (FAILED(hr))
            {
                DPF_ERR("Failed to set timeAction attribute");
                return hr;
            }
        }

		ReleaseInterface( pElement2 );
    }

	return hr;
}

//*****************************************************************************

HRESULT
CBaseBehavior::RequestRebuild( )
{
	//if we are not accepting rebuild requests then just return.
	if( !m_fAcceptRebuildRequests )
		return S_OK;
		
	HRESULT hr = S_OK;

	IHTMLElement *pelemActor = NULL;
	IDispatch *pdispBehaviorElem = NULL;
	
	DISPPARAMS params;
	VARIANT varArgs[1];
	VARIANT varResult;

	::VariantInit( &(varArgs[0]) );
	::VariantInit( &varResult );

	hr = GetAnimatedParentElement( &pelemActor );
	CheckHR( hr, "Failed to find animated parent element", end );



	hr = GetHTMLElement()->QueryInterface( IID_TO_PPV( IDispatch, &pdispBehaviorElem ) );
	CheckHR( hr, "QI for IDispatch on the behavior element failed", end );
	
	//call requestRebuild( IDispatch *pdispBehaviorElem );
	V_VT( &(varArgs[0]) ) = VT_DISPATCH;
	V_DISPATCH( &(varArgs[0]) ) = pdispBehaviorElem; 

	params.cArgs = 1;
	params.cNamedArgs = 0;
	params.rgdispidNamedArgs = NULL;
	params.rgvarg = varArgs;

	hr = CallInvokeOnHTMLElement( pelemActor, 
								  L"requestRebuild",
								  DISPATCH_METHOD,
								  &params,
								  &varResult );
	CheckHR( hr, "Failed to call invoke on html element for reques rebuild", end );
										

end:
	ReleaseInterface( pelemActor );
	ReleaseInterface( pdispBehaviorElem );

	::VariantClear( &varResult );

	return hr;
}

//*****************************************************************************

HRESULT
CBaseBehavior::CancelRebuildRequests()
{
	HRESULT hr = S_OK;

	IHTMLElement *pelemActor = NULL;
	IDispatch *pdispBehaviorElem = NULL;
	
	DISPPARAMS params;
	VARIANT varArgs[1];
	VARIANT varResult;

	::VariantInit( &(varArgs[0]) );
	::VariantInit( &varResult );

	hr = GetAnimatedParentElement( &pelemActor );
	CheckHR( hr, "Failed to find animated parent element", end );

	hr = GetHTMLElement()->QueryInterface( IID_TO_PPV( IDispatch, &pdispBehaviorElem ) );
	CheckHR( hr, "QI for IDispatch on the behavior element failed", end );

	//call cancelRebuildRequests( IDispatch *pdispBehaviorElem );
	V_VT( &(varArgs[0]) ) = VT_DISPATCH;
	V_DISPATCH( &(varArgs[0]) ) = pdispBehaviorElem; 

	params.cArgs = 1;
	params.cNamedArgs = 0;
	params.rgdispidNamedArgs = NULL;
	params.rgvarg = varArgs;

	hr = CallInvokeOnHTMLElement( pelemActor, 
								  L"cancelRebuildRequests",
								  DISPATCH_METHOD,
								  &params,
								  &varResult );
	CheckHR( hr, "Failed to call invoke on html element for reques rebuild", end );
										

end:
	ReleaseInterface( pelemActor );
	ReleaseInterface( pdispBehaviorElem );

	::VariantClear( &varResult );

	return hr;
}

//*****************************************************************************


HRESULT 
CBaseBehavior::AttachActorBehaviorToAnimatedElement()
{

    HRESULT hr;
    
    bool fTimeExist;
    bool fTimeDAExist;
    
    IHTMLElement *pElement = NULL;
    hr = GetAnimatedParentElement(&pElement);
    if (FAILED(hr))
    {
        DPF_ERR("Error retrieving element to animate");
        return hr;
    }

    hr = CheckElementForBehaviorURN(pElement, WZ_TIME_REGISTERED_URN, &fTimeExist);
    if (FAILED(hr))
    {
        ReleaseInterface(pElement);
        return hr;
    }

	// REVIEW: we'd like to check for the registered URN, but DA isn't doing this yet.
    hr = CheckElementForDA( pElement, &fTimeDAExist );
    if (FAILED(hr))
    {
        ReleaseInterface(pElement);
        return hr;
    }
    
    if ( !fTimeExist || !fTimeDAExist)
    {
        IHTMLElement2 *pElement2;
        hr = pElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElement2));
        if (FAILED(hr))
        {
            DPF_ERR("Error QI'ing HTML element for IHTMLElement2");
            ReleaseInterface(pElement);
            return SetErrorInfo(hr);
        }

        ITIMEFactory *pTimeFactory;
        hr = CoCreateInstance(CLSID_TIMEFactory, 
                              NULL, 
                              CLSCTX_INPROC_SERVER, 
                              IID_ITIMEFactory, 
                              (void**)&pTimeFactory);
        if (FAILED(hr))
        {
            DPF_ERR("Error creating time factory");
            ReleaseInterface(pElement);
            ReleaseInterface(pElement2);
            return SetErrorInfo(hr);
        }

        // Before we add the TIME behavior, we check to see whether there is
        // a t:timeAction already set on the element
        bool timeActionSet = false;
        VARIANT var;
        VariantInit(&var);
        if (!fTimeExist)
        {
			DISPPARAMS					params;
			params.rgvarg				= NULL;
			params.rgdispidNamedArgs    = NULL;
			params.cArgs                = 0;
			params.cNamedArgs           = 0;
        
			hr = CallInvokeOnHTMLElement(pElement,
										 L"t:timeAction", 
										 DISPATCH_PROPERTYGET,
										 &params,
										 &var);

            if (FAILED(hr) || V_VT(&var) == VT_EMPTY || V_VT(&var) == VT_NULL ||
                (V_VT(&var) == VT_BSTR && V_BSTR(&var) == NULL))
            {
                timeActionSet = false;
            }
            else
                timeActionSet = true;

            VariantClear(&var);
        }
        
        // Risky, and unfun, we need to add a time DA element
        // to the HTML element, hard code this string above
        var.vt = VT_UNKNOWN;
        var.punkVal = pTimeFactory;
        long nCookie;

        // We need to add the da element first in case the element is
        // the body.  If not then the body will have a time element
        // when it should have a time body element
		hr = S_OK;

        if (!fTimeDAExist)
            hr = pElement2->addBehavior(WZ_TIMEDA_URN, &var, &nCookie);

        if (SUCCEEDED(hr) && !fTimeExist)
        {
            hr = pElement2->addBehavior(WZ_TIME_URN, &var, &nCookie);
        }
        
        ReleaseInterface(pTimeFactory);
        if (FAILED(hr))
        {
            DPF_ERR("Error adding time element to html");
            ReleaseInterface(pElement);
            ReleaseInterface(pElement2);
            return SetErrorInfo(hr);
        }

        // If we added TIME, we need to set timeAction=none,
        // otherwise the element would appear and disappear since timeAction defaults
        // to visibility
        // Only do this if we didn't detect a timeAction attribute already
        if (!fTimeExist && !timeActionSet)
        {
            VARIANT varAction;
            VariantInit(&varAction);
            V_VT(&varAction) = VT_BSTR;
            V_BSTR(&varAction) = ::SysAllocString(L"none");

            BSTR attribName = ::SysAllocString(L"timeAction");

            hr = pElement->setAttribute(attribName, varAction);
            ::SysFreeString(attribName);
            VariantClear(&varAction);
            if (FAILED(hr))
            {
				ReleaseInterface(pElement);
                DPF_ERR("Failed to set timeAction attribute");
                return hr;
            }
        }

		ReleaseInterface( pElement2 );
    }

    bool fActorExist;
    hr = CheckElementForActor(pElement, &fActorExist);
    if (FAILED(hr))
    {
        DPF_ERR("Error detecting actor");
        return hr;
    }

	ReleaseInterface( pElement );
    // if the actor does not exist, then we need to add it here
    if (!fActorExist)
    {
        // we need to create a factor, then call add behavior on the
        // HTML element that we are animating for both an actor
        // object and a DA TIME object
        IHTMLElement *pElement;
        hr = GetAnimatedParentElement(&pElement);
        if (FAILED(hr))
        {
            DPF_ERR("Error retrieving element to animate");
            return hr;
        }
        IHTMLElement2 *pElement2;
        hr = pElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElement2));
        ReleaseInterface(pElement);
        if (FAILED(hr))
        {
            DPF_ERR("Error QI'ing HTML element for IHTMLElement2");
            return SetErrorInfo(hr);
        }

        ICrBehaviorFactory *pBehaviorFactory = NULL;
        hr = CoCreateInstance(CLSID_CrBehaviorFactory, 
                              NULL, 
                              CLSCTX_INPROC_SERVER, 
                              IID_ICrBehaviorFactory, 
                              (void**)&pBehaviorFactory);
        if (FAILED(hr))
        {
            DPF_ERR("Error creating behavior factory in AttachActorBehaviorToAnimatedElement");
            ReleaseInterface(pElement2);
            return SetErrorInfo(hr);
        }
        VARIANT var;
        var.vt = VT_UNKNOWN;
        var.punkVal = pBehaviorFactory;

        long nCookie;
        hr = pElement2->addBehavior(WZ_ACTOR_URN, &var, &nCookie);
        ReleaseInterface(pBehaviorFactory);
        ReleaseInterface(pElement2);
        if (FAILED(hr))
        {
            DPF_ERR("Error calling AddBehavior on HTML element");
            return SetErrorInfo(hr);
        }

        // In the debug case insure that this worked
#ifdef DEBUG
		bool fDEBUGActorExists = false;
		IHTMLElement *pDEBUGElement=NULL;
        hr = GetAnimatedParentElement(&pDEBUGElement);
        if (FAILED(hr))
        {
            DPF_ERR("Error retrieving element to animate in DEBUG CHECK");
            goto debugend;
        }

        hr = CheckElementForActor( pDEBUGElement, &fDEBUGActorExists);
		ReleaseInterface( pDEBUGElement );
        if (FAILED(hr))
        {
            DPF_ERR("Error detecting actor in DEBUG CHECK");
            goto debugend;
        }
        
debugend:

		DASSERT(fDEBUGActorExists);
#endif // DEBUG

    }
    return S_OK;

} // AttachActorBehaviorToAnimatedElement

//*****************************************************************************

HRESULT
CBaseBehavior::GetHTMLElementDispatch( IDispatch **ppdisp )
{
	if( ppdisp == NULL )
		return E_INVALIDARG;

	if( m_pHTMLElement != NULL )
	{
		return m_pHTMLElement->QueryInterface( IID_TO_PPV( IDispatch, ppdisp ) );
	}

	return E_FAIL;
}


//*****************************************************************************

HRESULT 
CBaseBehavior::ApplyRelative2DMoveBehavior(IDATransform2 *pbvrMove, float flOriginalX, float flOriginalY)
{

    HRESULT hr;

    IDAPoint2 *pbvrOrg;

    hr = GetDAStatics()->Point2(flOriginalX, flOriginalY, &pbvrOrg);
    if (FAILED(hr))
    {
        DPF_ERR("error creating DA unit vector");
        return SetErrorInfo(hr);
    }

    return Apply2DMoveBvrToPoint(pbvrMove, pbvrOrg, flOriginalX, flOriginalY);
} // ApplyRelative2DMoveBehavior

//*****************************************************************************

HRESULT 
CBaseBehavior::ApplyAbsolute2DMoveBehavior(IDATransform2 *pbvrMove, float flOriginalX, float flOriginalY)
{
    HRESULT hr;

    IDAPoint2 *pbvrOrg;

    hr = GetDAStatics()->Point2(0.0, 0.0, &pbvrOrg);
    if (FAILED(hr))
    {
        DPF_ERR("error creating DA unit vector");
        return SetErrorInfo(hr);
    }
    return Apply2DMoveBvrToPoint(pbvrMove, pbvrOrg, flOriginalX, flOriginalY);
} // ApplyAbsolute2DMoveBehavior

//*****************************************************************************

HRESULT
CBaseBehavior::Apply2DMoveBvrToPoint(IDATransform2 *pbvrMove, IDAPoint2 *pbvrOrg, float flOriginalX, float flOriginalY)
{
    HRESULT hr = S_OK;

    IDAPoint2 *pbvrTransformedPoint;
    hr = pbvrOrg->Transform(pbvrMove, &pbvrTransformedPoint);
    ReleaseInterface(pbvrOrg);
    if (FAILED(hr))
    {
        DPF_ERR("Error transforming unit vector");
        return SetErrorInfo(hr);
    }
    DASSERT(pbvrTransformedPoint != NULL);
    IDANumber *pbvrPointComponent;
    hr = pbvrTransformedPoint->get_X(&pbvrPointComponent);
    if (FAILED(hr))
    {
        DPF_ERR("error extracting X value from point");
        ReleaseInterface(pbvrTransformedPoint);
        return SetErrorInfo(hr);
    }
    DASSERT(pbvrPointComponent != NULL);

    // we need to conditional in the original position of the element
    IDABoolean *pbvrBool;
    hr = GetTIMEBooleanBehavior(&pbvrBool);
    if (FAILED(hr))
    {
        DPF_ERR("Error obtaining TIME boolean value");
        ReleaseInterface(pbvrTransformedPoint);
        ReleaseInterface(pbvrPointComponent);
        return hr;
    }

    IDANumber *pbvrNumber;
    hr = CDAUtils::GetDANumber(GetDAStatics(), flOriginalX, &pbvrNumber);
    if (FAILED(hr))
    {
        DPF_ERR("Error creating da number");
        ReleaseInterface(pbvrTransformedPoint);
        ReleaseInterface(pbvrPointComponent);
        ReleaseInterface(pbvrBool);
        return SetErrorInfo(hr);
    }

    IDABehavior *pbvrResult;
    hr = GetDAStatics()->Cond(pbvrBool, pbvrPointComponent, pbvrNumber, &pbvrResult);
    ReleaseInterface(pbvrPointComponent);
    ReleaseInterface(pbvrBool);
    ReleaseInterface(pbvrNumber);

    if (FAILED(hr))
    {
        DPF_ERR("Error creating conditional for number");
        ReleaseInterface(pbvrTransformedPoint);
        return SetErrorInfo(hr);
    }
    hr = pbvrResult->QueryInterface(IID_TO_PPV(IDANumber, &pbvrPointComponent));
    ReleaseInterface(pbvrResult);
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing result for DA number");
        ReleaseInterface(pbvrTransformedPoint);
        return SetErrorInfo(hr);
    }

    hr = ApplyNumberBehaviorToAnimationElement(pbvrPointComponent, L"style.left");
    ReleaseInterface(pbvrPointComponent);
    if (FAILED(hr))
    {
        DPF_ERR("error calling ApplyNumberBehaviorToAnimationElement");
        ReleaseInterface(pbvrTransformedPoint);
        return SetErrorInfo(hr);
    }    

    hr = pbvrTransformedPoint->get_Y(&pbvrPointComponent);
    ReleaseInterface(pbvrTransformedPoint);
    if (FAILED(hr))
    {
        DPF_ERR("error extracting Y value from point");
        return SetErrorInfo(hr);
    }
    DASSERT(pbvrPointComponent != NULL);

    // we need to conditional in the original position of the element
    hr = GetTIMEBooleanBehavior(&pbvrBool);
    if (FAILED(hr))
    {
        DPF_ERR("Error obtaining TIME boolean value");
        ReleaseInterface(pbvrPointComponent);
        return hr;
    }

    hr = CDAUtils::GetDANumber(GetDAStatics(), flOriginalY, &pbvrNumber);
    if (FAILED(hr))
    {
        DPF_ERR("Error creating da number");
        ReleaseInterface(pbvrPointComponent);
        ReleaseInterface(pbvrBool);
        return SetErrorInfo(hr);
    }

    hr = GetDAStatics()->Cond(pbvrBool, pbvrPointComponent, pbvrNumber, &pbvrResult);
    ReleaseInterface(pbvrPointComponent);
    ReleaseInterface(pbvrBool);
    ReleaseInterface(pbvrNumber);

    if (FAILED(hr))
    {
        DPF_ERR("Error creating conditional for number");
        return SetErrorInfo(hr);
    }
    hr = pbvrResult->QueryInterface(IID_TO_PPV(IDANumber, &pbvrPointComponent));
    ReleaseInterface(pbvrResult);
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing result for DA number");
        return SetErrorInfo(hr);
    }


    hr = ApplyNumberBehaviorToAnimationElement(pbvrPointComponent, L"style.top");
    ReleaseInterface(pbvrPointComponent);
    if (FAILED(hr))
    {
        DPF_ERR("error calling ApplyNumberBehaviorToAnimationElement");
        return SetErrorInfo(hr);
    }    
    return S_OK;
} // Apply2DMoveBvrToPoint

//*****************************************************************************

ActorBvrFlags
CBaseBehavior::FlagFromTypeMode(bool relative, VARIANT *pVarType, VARIANT *pVarMode)
{
	return FlagFromTypeMode((relative ? e_RelativeAccum : e_Absolute), pVarType, pVarMode);
}

ActorBvrFlags
CBaseBehavior::FlagFromTypeMode(ActorBvrFlags flags, VARIANT *pVarType, VARIANT *pVarMode)
{
	// Must pass in e_Absolute, e_AbsoluteAccum, or e_RelativeAccum

	if( V_VT(pVarType) == VT_BSTR && V_BSTR(pVarType) != NULL && SysStringLen( V_BSTR(pVarType) ) != 0  )
	{
		// Use type (if set) to change to relative
		if( wcsicmp( V_BSTR(pVarType), BEHAVIOR_TYPE_ABSOLUTE ) == 0 )
		{
			if (flags == e_RelativeAccum)
				flags = e_Absolute;
		}
		else if ( wcsicmp( V_BSTR(pVarType), BEHAVIOR_TYPE_RELATIVE ) == 0 )
		{
			flags = e_RelativeAccum;
		}
	}

	if( V_VT(pVarMode) == VT_BSTR && V_BSTR(pVarMode) != NULL && SysStringLen( V_BSTR(pVarMode) ) != 0  )
	{
		// They've set the mode
		if (wcsicmp( V_BSTR(pVarMode), L"combine") == 0)
		{
			if (flags != e_AbsoluteAccum)
				return e_Relative;
		}
		else if (wcsicmp( V_BSTR(pVarMode), L"reset") == 0)
		{
			if (flags == e_AbsoluteAccum)
				return e_Absolute;
			else if (flags == e_RelativeAccum)
				return e_RelativeReset;
		}
		else if (wcsicmp( V_BSTR(pVarMode), L"accum") == 0)
		{
			if (flags == e_Absolute)
				return e_RelativeAccum;
			else if (flags == e_RelativeReset)
				return e_RelativeAccum;
		}
	}
	
	return flags;
}

//*****************************************************************************

	STDMETHODIMP 
CBaseBehavior::GetClassID(CLSID* pclsid)
{
        if (!pclsid)
                return E_POINTER;
        *pclsid = m_clsid;
        return S_OK;
} // GetClassID

//*****************************************************************************

STDMETHODIMP 
CBaseBehavior::InitNew(void)
{
        return S_OK;
} // InitNew

//*****************************************************************************

//IPersistPropertyBag2 methods
STDMETHODIMP 
CBaseBehavior::Load(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog)
{
        if (!pPropBag)
                return E_INVALIDARG;

    HRESULT hr;
    WCHAR **ppElmtPropNames;
    ULONG cProperties;

    hr = GetPropertyBagInfo(&cProperties, &ppElmtPropNames);
    if (hr == E_NOTIMPL)
    {
        return S_OK;
    }
    else if (FAILED(hr))
    {
        DPF_ERR("Error calling GetPropertyBagInfo");
        return hr;
    }

    // Unfortunately Load takes an array of Variants and not
    // Variant pointers.  We therefor need to loop through
    // each one and get the correct property this way.
    for (ULONG iProperties = 0; iProperties < cProperties; iProperties++)
    {
        HRESULT hrres = S_OK;
        PROPBAG2 propbag;
        VARIANT var;
        VariantInit(&var);
        propbag.vt = VT_BSTR;
        propbag.pstrName = ppElmtPropNames[iProperties];
        hr = pPropBag->Read(1,
                            &propbag,
                            pErrorLog,
                            &var,
                            &hrres);
        if (SUCCEEDED(hr))
        {
            DASSERT(VariantFromIndex(iProperties) != NULL);
            hr = VariantCopy(VariantFromIndex(iProperties), &var);
            VariantClear(&var);
            if (FAILED(hr))
            {
                DPF_ERR("Error copying variant");
                return SetErrorInfo(hr);
            }
        }
    }
        return S_OK;
} // Load

//*****************************************************************************

STDMETHODIMP 
CBaseBehavior::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
        if (!pPropBag)
                return E_INVALIDARG;

    if (fClearDirty)
        m_fPropertiesDirty = false;
    // TODO:: Need to use fSaveAllProperties to only save values that have
    // changed
    HRESULT hr;
    WCHAR **ppElmtPropNames;
    ULONG cProperties;

    hr = GetPropertyBagInfo(&cProperties, &ppElmtPropNames);
    if (hr == E_NOTIMPL)
    {
        return S_OK;
    }
    else if (FAILED(hr))
    {
        DPF_ERR("Error calling GetPropertyBagInfo");
        return hr;
    }

    for (ULONG iProperties = 0; iProperties < cProperties; iProperties++)
    {
        PROPBAG2 propbag;

        VARIANT var;
                VariantInit(&var);

        propbag.vt = VT_BSTR;
        propbag.pstrName = ppElmtPropNames[iProperties];
        DASSERT(VariantFromIndex(iProperties) != NULL);
        hr = VariantCopy(&var, VariantFromIndex(iProperties));
        if (FAILED(hr))
        {
            DPF_ERR("Error copying variant");
            return SetErrorInfo(hr);
        }
        if (var.vt != VT_EMPTY && var.vt != VT_NULL)
        {
            hr = pPropBag->Write(1,
                                 &propbag,
                                 &var);
            VariantClear(&var);
            if (FAILED(hr))
            {
                DPF_ERR("Error writing variant");
                return SetErrorInfo(hr);
            }
        }
    }
        return S_OK;
} // Save

//*****************************************************************************

HRESULT
CBaseBehavior::NotifyPropertyChanged(DISPID dispid)
{
    HRESULT hr;

    IConnectionPoint *pICP;
    m_fPropertiesDirty = true;
    hr = GetConnectionPoint(IID_IPropertyNotifySink,&pICP); 
    if (SUCCEEDED(hr) && pICP != NULL)
    {
        CComPtr<IEnumConnections> pEnum;
        hr = pICP->EnumConnections(&pEnum);
        ReleaseInterface(pICP);
        if (FAILED(hr))
        {
            DPF_ERR("Error finding connection enumerator");
            return SetErrorInfo(hr);
        }
        CONNECTDATA cdata;
        hr = pEnum->Next(1, &cdata, NULL);
        while (hr == S_OK)
        {
            // check cdata for the object we need
            IPropertyNotifySink *pNotify;
            hr = cdata.pUnk->QueryInterface(IID_TO_PPV(IPropertyNotifySink, &pNotify));
            cdata.pUnk->Release();
            if (FAILED(hr))
            {
                DPF_ERR("Error invalid object found in connection enumeration");
                return SetErrorInfo(hr);
            }
            hr = pNotify->OnChanged(dispid);
            ReleaseInterface(pNotify);
            if (FAILED(hr))
            {
                DPF_ERR("Error calling Notify sink's on change");
                return SetErrorInfo(hr);
            }
            // and get the next enumeration
            hr = pEnum->Next(1, &cdata, NULL);
        }
    }
    return S_OK;
} // NotifyPropertyChanged

//*****************************************************************************


HRESULT
CBaseBehavior::SafeCond( IDA2Statics *pstatics, 
				  		 IDABoolean *pdaboolCondition, 
				  		 IDABehavior *pdabvrIfTrue, 
				  		 IDABehavior *pdabvrIfFalse, 
				  		 IDABehavior **ppdabvrResult )
{
	if( pstatics == NULL || 
		pdaboolCondition == NULL || 
		pdabvrIfTrue == NULL || 
		pdabvrIfFalse == NULL ||
		ppdabvrResult == NULL )
		return E_INVALIDARG;
		
	HRESULT hr = S_OK;

	IDABehavior *pdabvrIndex = NULL;
	IDANumber	*pdanumIndex = NULL;
	IDAArray	*pdaarrArray = NULL;
	IDABehavior *rgpdabvr[2] = {NULL, NULL};

	if( m_pdanumZero == NULL )
	{
		hr = pstatics->DANumber( 0.0, &m_pdanumZero );
		CheckHR( hr, "Failed to create a danumber for 0", end );
	}

	if( m_pdanumOne == NULL )
	{
		hr = pstatics->DANumber( 1.0, &m_pdanumOne );
		CheckHR( hr, "Failed to create a danumber for 1", end );
	}

	//create an index that is 0 when pdaboolCondition is false, and 1 when it is true
	hr = pstatics->Cond( pdaboolCondition, m_pdanumZero, m_pdanumOne, &pdabvrIndex );
	CheckHR( hr, "Failed to create a conditional for the index", end);

	hr = pdabvrIndex->QueryInterface( IID_TO_PPV( IDANumber, &pdanumIndex ) );
	CheckHR( hr, "Failed QI for IDANumber on an idabehavior", end );
	
	//create an array behavior with the first element being ifTrue, and the second ifFalse
	rgpdabvr[0] = pdabvrIfTrue;
	rgpdabvr[1] = pdabvrIfFalse;
	hr = pstatics->DAArrayEx( 2, rgpdabvr, &pdaarrArray );
	CheckHR( hr, "Failed to create an array behavior", end );

	//index into the array
	hr = pdaarrArray->NthAnim( pdanumIndex, ppdabvrResult );
	CheckHR( hr, "Failed to nth an array behavior", end );
	//return the final behavior

end:
	ReleaseInterface( pdabvrIndex );
	ReleaseInterface( pdanumIndex );
	ReleaseInterface( pdaarrArray );

	return hr;
}

//*****************************************************************************
//Do Not call this from the actor.
HRESULT
CBaseBehavior::AddBehaviorToAnimatedElement( IDABehavior *pdabvr, long *plCookie )
{
	if( pdabvr == NULL || plCookie == NULL )
		return E_INVALIDARG;

	HRESULT hr;

	IHTMLElement			*pelemAnimated = NULL;

 	DISPPARAMS              params;
	VARIANT                 varBehavior;
	VARIANT                 varResult;

	//get the animated element
	hr = GetAnimatedParentElement( &pelemAnimated );
	CheckHR( hr, "Failed to get the animated element", end );
	
	
	VariantInit(&varBehavior);
	varBehavior.vt = VT_DISPATCH;
	varBehavior.pdispVal = pdabvr;

	VariantInit(&varResult);

	params.rgvarg					= &varBehavior;
	params.rgdispidNamedArgs		= NULL;
	params.cArgs					= 1;
	params.cNamedArgs				= 0;
    hr = CallInvokeOnHTMLElement(pelemAnimated,
                                 L"AddDABehavior", 
                                 DISPATCH_METHOD,
                                 &params,
                                 &varResult);

	if( V_VT( &varResult ) != VT_I4 )
	{
		//change the type.
		hr = VariantChangeTypeEx( &varResult, &varResult, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_I4 );
		CheckHR( hr, "Failed to change the type of the return to long", end);
	}

	(*plCookie) = V_I4(&varResult);
end:

	VariantClear(&varResult);
	ReleaseInterface( pelemAnimated );

    return hr;
}

//*****************************************************************************
//Do not call this from the actor

HRESULT
CBaseBehavior::RemoveBehaviorFromAnimatedElement( long lCookie )
{
	if( GetHTMLElement() == NULL )
		return E_FAIL;
	
    HRESULT hr;

    IHTMLElement			*pelemAnimated = NULL;
	
	DISPPARAMS              params;
	VARIANT                 varCookie;
	VARIANT                 varResult;

	hr = GetAnimatedParentElement( &pelemAnimated );
	CheckHR( hr, "failed to get the animated element", end );
	
	VariantInit(&varCookie);
	V_VT( &varCookie ) = VT_I4;
	V_I4( &varCookie ) = lCookie;
	
	VariantInit(&varResult);
	
	params.rgvarg                           = &varCookie;
	params.rgdispidNamedArgs				= NULL;
	params.cArgs                            = 1;
	params.cNamedArgs                       = 0;
    hr = CallInvokeOnHTMLElement(pelemAnimated,
								 L"removeDABehavior", 
								 DISPATCH_METHOD,
								 &params,
								 &varResult);

	
    if (FAILED(hr))
    {
        DPF_ERR("Error calling CallInvokeOnHTMLElement in RemoveBehaviorFromTIME");
		VariantClear(&varResult);
		return hr;
    }

end:

	ReleaseInterface( pelemAnimated );
	VariantClear(&varResult);

    return S_OK;
}


//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\src\dautil.h ===
#pragma once
#ifndef __DAUTIL_H_
#define __DAUTIL_H_
//*****************************************************************************
//
// Microsoft Trident3D
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    dautils.h
//
// Author:	    jeffort
//
// Created:	    10/07/98
//
// Abstract:    Definition of DA utility class
// Modifications:
// 10/07/98 jeffort created file
// 10/21/98 jeffort added BuildScaleTransform3 and BuildScaleTransform2
//
//*****************************************************************************

class CDAUtils
{
public:
    static HRESULT TIMEInterpolateNumbers(IDA2Statics *pDAStatics,
                                          float flNum1, 
                                          float flNum2, 
                                          IDANumber *pnumProgress, 
                                          IDANumber **ppnumReturn);
    static HRESULT GetDANumber(IDA2Statics *pDAStatics, 
                               float flValue, 
                               IDANumber **ppnumReturn);
    static HRESULT GetDAString(IDA2Statics *pDAStatics, 
                               BSTR bstrValue, 
                               IDAString **ppbvrReturn);
    static HRESULT BuildDAColorFromHSL(IDA2Statics *pDAStatics,
                                       IDANumber *pnumH, 
                                       IDANumber *pnumS,
                                       IDANumber *pnumL, 
                                       IDAColor **ppbvrReturn);
    static HRESULT BuildDAColorFromStaticHSL(IDA2Statics *pDAStatics,
                                            float flH, 
                                            float flS, 
                                            float flL,
                                            IDAColor **ppbvrReturn);
    static HRESULT BuildDAColorFromRGB(IDA2Statics *pDAStatics,
                                            DWORD dwColor,
                                            IDAColor **ppbvrReturn);
    static HRESULT BuildConditional(IDA2Statics *pDAStatics,
                                    IDABoolean *pbvrConditional, 
                                    IDABehavior *pbvrWhileTrue,
                                    IDABehavior *pbvrWhileFalse,
                                    IDABehavior **ppbvrReturn);
    static HRESULT BuildSafeConditional( IDA2Statics *pDAStatics,
										 IDABoolean *pbvrCondition, 
                           				 IDABehavior *pbvrIfTrue,
                           				 IDABehavior *pbvrIfFalse,
                           				 IDABehavior **ppbvrResult);

    static HRESULT BuildRotationTransform2(IDA2Statics *pDAStatics,
                                           IDANumber *pRotationAngle,
                                           IDATransform2 **ppbvrReturn);
    static HRESULT BuildScaleTransform2(IDA2Statics *pDAStatics,
                                        IDANumber *pbvrScaleX,
                                        IDANumber *pbvrScaleY,
                                        IDATransform2 **ppbvrReturn);
    static HRESULT BuildScaleTransform3(IDA2Statics *pDAStatics,
                                        IDANumber *pbvrScaleX,
                                        IDANumber *pbvrScaleY,
                                        IDANumber *pbvrScaleZ,
                                        IDATransform3 **ppbvrReturn);
    static HRESULT BuildMoveTransform2(IDA2Statics *pDAStatics,
                                       IDANumber *pbvrMoveX,
                                       IDANumber *pbvrMoveY,
                                       IDATransform2 **ppbvrReturn);
    static HRESULT BuildMoveTransform3(IDA2Statics *pDAStatics,
                                       IDANumber *pbvrMoveX,
                                       IDANumber *pbvrMoveY,
                                       IDANumber *pbvrMoveZ,
                                       IDATransform3 **ppbvrReturn);
}; // CDAUtils

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif //__DAUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\src\dispmethod.cpp ===
/******************************************************************************
*
*
*
*
*******************************************************************************/


#include "headers.h"

#include "dispmethod.h"

//*****************************************************************************

CDispatchMethod::CDispatchMethod( ) :
m_cRefs( 1 )
{
}

//*****************************************************************************

CDispatchMethod::~CDispatchMethod()
{
}

//*****************************************************************************
//IUnknown
//*****************************************************************************

STDMETHODIMP
CDispatchMethod::QueryInterface( REFIID riid, void** ppv)
{
    if( ppv == NULL )
        return E_POINTER;

	if( riid == IID_IUnknown )
	{
		(*ppv) = static_cast<IUnknown*>(this);
	}
    else if( riid == IID_IDispatch )
    {
        (*ppv) = static_cast<IDispatch*>(this);
    }   
    else
    {
        (*ppv) = NULL;
        return E_NOINTERFACE;
    }

    static_cast<IUnknown*>(*ppv)->AddRef();

    return S_OK;
}

//*****************************************************************************

STDMETHODIMP_(ULONG)
CDispatchMethod::AddRef()
{
    m_cRefs++;
    return m_cRefs;
}

//*****************************************************************************

STDMETHODIMP_(ULONG)
CDispatchMethod::Release()
{
    ULONG refs = --m_cRefs;

    if( refs == 0 )
        delete this;

    return refs;
}

//*****************************************************************************
//IDispatch
//*****************************************************************************

STDMETHODIMP
CDispatchMethod::GetTypeInfoCount( UINT *pctInfo )
{
    return E_NOTIMPL;
}

//*****************************************************************************

STDMETHODIMP
CDispatchMethod::GetTypeInfo( UINT iTypeInfo,
                              LCID lcid,
                              ITypeInfo** ppTypeInfo )
{
    return E_NOTIMPL;
}

//*****************************************************************************

STDMETHODIMP
CDispatchMethod::GetIDsOfNames( REFIID riid,
                                     LPOLESTR* rgszNames,
                                     UINT cNames,
                                     LCID lcid,
                                     DISPID* rgid )
{
    return E_NOTIMPL;
}

//*****************************************************************************


STDMETHODIMP
CDispatchMethod::Invoke( DISPID id,
                         REFIID riid,
                         LCID lcid,
                         WORD wFlags,
                         DISPPARAMS *pDispParams,
                         VARIANT *pvarResult,
                         EXCEPINFO *pExcepInfo,
                         UINT *puArgErr)
{
	return HandleEvent();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\src\dautil.cpp ===
//*****************************************************************************
//
// Microsoft Chrome
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    dautil.cpp
//
// Author:	    jeffort
//
// Created:	    10/07/98
//
// Abstract:    Implementation of DA utility class
//              This class provides functionality specific
//              to DA objects.  It must be a child
//              of a behavior, and relies on its parent to
//              obtain a ref counted pointer to the DA
//              statics.
// Modifications:
// 10/07/98 jeffort created file
// 10/21/98 jeffort added BuildScaleTransform3 and BuildScaleTransform2
//
//*****************************************************************************

#include "headers.h"

#include "dautil.h"
    
//*****************************************************************************
//
// Abstract: This function is called to create a DA number that is the
//           interpolated value from flNum1 to flNum2.  For TIME, this
//           is not a straight interpolate, but the progress number (pnumProgress)
//           is used for the interpolation.  The formula used is:
//           res = flNum1 + ((flNum2 - flNum1) * pnumProgress).
//           This is returned as a DA number.
//*****************************************************************************

HRESULT
CDAUtils::TIMEInterpolateNumbers(IDA2Statics *pDAStatics,
                                 float flNum1, 
                                 float flNum2, 
                                 IDANumber *pnumProgress, 
                                 IDANumber **ppnumReturn)
{
    DASSERT(pnumProgress != NULL);
    DASSERT(ppnumReturn != NULL);
    DASSERT(pDAStatics != NULL);
    *ppnumReturn = NULL;

    HRESULT hr;

    IDANumber *pnumNumber = NULL;
    IDANumber *pnumIncrement = NULL;
    hr = pDAStatics->DANumber((flNum2 - flNum1), &pnumNumber);
    if (FAILED(hr))
    {
        DPF_ERR("Error creating DA number in TIMEInterpolateNumbers");
        return hr;
    }
    hr = pDAStatics->Mul(pnumNumber, pnumProgress, &pnumIncrement);
    ReleaseInterface(pnumNumber);
    if (FAILED(hr))
    {
        DPF_ERR("Error mutiplyin DA numbers in TIMEInterpolateNumbers");
        return hr;
    }
    hr = pDAStatics->DANumber(flNum1, &pnumNumber);
    if (FAILED(hr))
    {
        DPF_ERR("Error creating DA number in TIMEInterpolateNumbers");
        ReleaseInterface(pnumIncrement);
        return hr;
    }    
    hr = pDAStatics->Add(pnumNumber, pnumIncrement, ppnumReturn);
    ReleaseInterface(pnumIncrement);
    ReleaseInterface(pnumNumber);
    if (FAILED(hr))
    {
        DPF_ERR("Error adding DA numbers in TIMEInterpolateNumbers");
        return hr;
    }
    return S_OK;
} // TIMEInterpolateNumbers

//*****************************************************************************

HRESULT 
CDAUtils::GetDANumber(IDA2Statics *pDAStatics, 
                      float flValue, 
                      IDANumber **ppnumReturn)
{
    DASSERT(pDAStatics != NULL);
    DASSERT(ppnumReturn != NULL);
    *ppnumReturn = NULL;

    HRESULT hr = pDAStatics->DANumber(flValue, ppnumReturn);
    if (FAILED(hr))
    {
        DPF_ERR("Error creating DA number");
        return hr;
    }
    return S_OK;

} // GetDANumber

//*****************************************************************************

HRESULT
CDAUtils::GetDAString(IDA2Statics *pDAStatics, 
                      BSTR bstrValue, 
                      IDAString **ppbvrReturn)
{

    DASSERT(pDAStatics != NULL);
    DASSERT(bstrValue != NULL);
    DASSERT(ppbvrReturn != NULL);
    *ppbvrReturn = NULL;

    HRESULT hr = pDAStatics->DAString(bstrValue, ppbvrReturn);
    if (FAILED(hr))
    {
        DPF_ERR("Error creating DA string");
        return hr;
    }
    return S_OK;

} // GetDAString

//*****************************************************************************

HRESULT
CDAUtils::BuildDAColorFromHSL(IDA2Statics *pDAStatics, 
                              IDANumber *pnumH, 
                              IDANumber *pnumS,
                              IDANumber *pnumL, 
                              IDAColor **ppbvrReturn)
{
    DASSERT(pDAStatics != NULL);
    DASSERT(pnumH != NULLL);
    DASSERT(pnumS != NULLL);
    DASSERT(pnumL != NULLL);
    DASSERT(ppbvrReturn != NULLL);
    *ppbvrReturn = NULL;

    HRESULT hr = pDAStatics->ColorHslAnim(pnumH, pnumS, pnumL, ppbvrReturn);
    if (FAILED(hr))
    {
        DPF_ERR("Error creating DA color in BuildDAColorFromHSL");
        return hr;
    }
    return S_OK;
} // BuildDAColorFromHSL

//*****************************************************************************

HRESULT
CDAUtils::BuildDAColorFromStaticHSL(IDA2Statics *pDAStatics,
                                    float flH, 
                                    float flS, 
                                    float flL,
                                    IDAColor **ppbvrReturn)
{
    DASSERT(pDAStatics != NULL);
    DASSERT(ppbvrReturn != NULLL);
    *ppbvrReturn = NULL;
    HRESULT hr = pDAStatics->ColorHsl(flH, flS, flL, ppbvrReturn);
    if (FAILED(hr))
    {
        DPF_ERR("Error creating DA color in BuildDAColorFromStaticHSL");
        return hr;
    }
    return S_OK;
} // BuildDAColorFromStaticHSL

HRESULT
CDAUtils::BuildDAColorFromRGB(IDA2Statics *pDAStatics,
                              DWORD dwColor,
                              IDAColor **ppbvrReturn)
{
    DASSERT(pDAStatics != NULL);
    DASSERT(ppbvrReturn != NULLL);
    *ppbvrReturn = NULL;

    HRESULT hr = pDAStatics->ColorRgb255(LOBYTE(HIWORD(dwColor)), // red
                                         HIBYTE(LOWORD(dwColor)), // green 
                                         LOBYTE(LOWORD(dwColor)), // blue
                                         ppbvrReturn);    

    if (FAILED(hr))
    {
        DPF_ERR("Error creating DA color in BuildDAColorFromRGB");
        return hr;
    }
    return S_OK;
} // BuildDAColorFromRGB


//*****************************************************************************

HRESULT
CDAUtils::BuildConditional(IDA2Statics *pDAStatics,
                           IDABoolean *pbvrConditional, 
                           IDABehavior *pbvrWhileTrue,
                           IDABehavior *pbvrWhileFalse,
                           IDABehavior **ppbvrReturn)
{
    DASSERT(pDAStatics != NULL);
    DASSERT(ppbvrReturn != NULLL);
    *ppbvrReturn = NULL;

    HRESULT hr = pDAStatics->Cond(pbvrConditional,
                          pbvrWhileTrue,
                          pbvrWhileFalse,
                          ppbvrReturn);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling DA Cond in BuildConditional");
        return hr;
    }
    return S_OK;
} // BuildConditional

//*****************************************************************************


HRESULT
CDAUtils::BuildSafeConditional( IDA2Statics *pstatics,
								IDABoolean *pdaboolCondition, 
                           		IDABehavior *pdabvrIfTrue,
                           		IDABehavior *pdabvrIfFalse,
                           		IDABehavior **ppdabvrResult)
{
	if( pstatics == NULL || 
		pdaboolCondition == NULL || 
		pdabvrIfTrue == NULL || 
		pdabvrIfFalse == NULL ||
		ppdabvrResult == NULL )
		return E_INVALIDARG;
		
	HRESULT hr = S_OK;

	IDABehavior *pdabvrIndex = NULL;
	IDANumber	*pdanumIndex = NULL;
	IDAArray	*pdaarrArray = NULL;
	IDANumber	*pdanumZero  = NULL;
	IDANumber	*pdanumOne	 = NULL;
	IDABehavior *rgpdabvr[2] = {NULL, NULL};

	hr = pstatics->DANumber( 0.0, &pdanumZero );
	CheckHR( hr, "Failed to create a danumber for 0", end );

	hr = pstatics->DANumber( 1.0, &pdanumOne );
	CheckHR( hr, "Failed to create a danumber for 1", end );

	//create an index that is 0 when pdaboolCondition is false, and 1 when it is true
	hr = pstatics->Cond( pdaboolCondition, pdanumZero, pdanumOne, &pdabvrIndex );
	CheckHR( hr, "Failed to create a conditional for the index", end);

	hr = pdabvrIndex->QueryInterface( IID_TO_PPV( IDANumber, &pdanumIndex ) );
	CheckHR( hr, "Failed QI for IDANumber on an idabehavior", end );
	
	//create an array behavior with the first element being ifTrue, and the second ifFalse
	rgpdabvr[0] = pdabvrIfTrue;
	rgpdabvr[1] = pdabvrIfFalse;
	hr = pstatics->DAArrayEx( 2, rgpdabvr, &pdaarrArray );
	CheckHR( hr, "Failed to create an array behavior", end );

	//index into the array
	hr = pdaarrArray->NthAnim( pdanumIndex, ppdabvrResult );
	CheckHR( hr, "Failed to nth an array behavior", end );
	//return the final behavior

end:
	ReleaseInterface( pdabvrIndex );
	ReleaseInterface( pdanumIndex );
	ReleaseInterface( pdaarrArray );
	ReleaseInterface( pdanumZero );
	ReleaseInterface( pdanumOne );

	return hr;

}

//*****************************************************************************

HRESULT
CDAUtils::BuildRotationTransform2(IDA2Statics *pDAStatics,
                                  IDANumber *pRotationAngle,
                                  IDATransform2 **ppbvrReturn)
{
    DASSERT(pDAStatics != NULL);
    DASSERT(pRotationAngle != NULL);
    DASSERT(ppbvrReturn != NULLL);
    *ppbvrReturn = NULL;
    HRESULT hr = pDAStatics->Rotate2Anim(pRotationAngle, ppbvrReturn);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling DA Rotate2Anim in BuildRotationTransform2");
        return hr;
    }
    return S_OK;
} // BuildRotationTransform2

//*****************************************************************************

HRESULT
CDAUtils::BuildScaleTransform2(IDA2Statics *pDAStatics,
                               IDANumber *pbvrScaleX,
                               IDANumber *pbvrScaleY,
                               IDATransform2 **ppbvrReturn)
{
    DASSERT(pDAStatics != NULL);
    DASSERT(pbvrScaleX != NULL);
    DASSERT(pbvrScaleY != NULL);
    DASSERT(ppbvrReturn != NULLL);
    *ppbvrReturn = NULL;
    HRESULT hr = pDAStatics->Scale2Anim(pbvrScaleX, 
                                        pbvrScaleY,
                                        ppbvrReturn);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling DA Scale2Anim in BuildScaleTransform2");
        return hr;
    }
    return S_OK;
} // BuildScaleTransform2

//*****************************************************************************

HRESULT
CDAUtils::BuildScaleTransform3(IDA2Statics *pDAStatics,
                               IDANumber *pbvrScaleX,
                               IDANumber *pbvrScaleY,
                               IDANumber *pbvrScaleZ,
                               IDATransform3 **ppbvrReturn)
{
    DASSERT(pDAStatics != NULL);
    DASSERT(pbvrScaleX != NULL);
    DASSERT(pbvrScaleY != NULL);
    DASSERT(pbvrScaleZ != NULL);
    DASSERT(ppbvrReturn != NULLL);

    *ppbvrReturn = NULL;

    HRESULT hr = pDAStatics->Scale3Anim(pbvrScaleX, 
                                        pbvrScaleY,
                                        pbvrScaleZ,
                                        ppbvrReturn);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling DA Scale3Anim in BuildScaleTransform3");
        return hr;
    }
    return S_OK;
} // BuildScaleTransform3

//*****************************************************************************

HRESULT
CDAUtils::BuildMoveTransform2(IDA2Statics *pDAStatics,
                              IDANumber *pbvrMoveX,
                              IDANumber *pbvrMoveY,
                              IDATransform2 **ppbvrReturn)
{
    DASSERT(pDAStatics != NULL);
    DASSERT(pbvrScaleX != NULL);
    DASSERT(pbvrScaleY != NULL);
    DASSERT(ppbvrReturn != NULLL);
    *ppbvrReturn = NULL;
    HRESULT hr = pDAStatics->Translate2Anim(pbvrMoveX, 
                                            pbvrMoveY,
                                            ppbvrReturn);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling DA Translate2Anim in BuildMoveTransform2");
        return hr;
    }
    return S_OK;
} // BuildMoveTransform2

//*****************************************************************************

HRESULT
CDAUtils::BuildMoveTransform3(IDA2Statics *pDAStatics,
                              IDANumber *pbvrMoveX,
                              IDANumber *pbvrMoveY,
                              IDANumber *pbvrMoveZ,
                              IDATransform3 **ppbvrReturn)
{
    DASSERT(pDAStatics != NULL);
    DASSERT(pbvrScaleX != NULL);
    DASSERT(pbvrScaleY != NULL);
    DASSERT(pbvrScaleZ != NULL);
    DASSERT(ppbvrReturn != NULLL);

    *ppbvrReturn = NULL;

    HRESULT hr = pDAStatics->Translate3Anim(pbvrMoveX, 
                                            pbvrMoveY,
                                            pbvrMoveZ,
                                            ppbvrReturn);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling DA Translate3Anim in BuildMoveTransform3");
        return hr;
    }
    return S_OK;
} // BuildMoveTransform3

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\src\colorbvr.cpp ===
//*****************************************************************************
//
// File:    colorbvr.cpp
// Author:  jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Implementation of CColorBvr object which implements
//			 the chromeffects Color DHTML behavior
//
// Modification List:
// Date		Author		Change
// 09/26/98	jeffort		Created this file
// 10/16/98 jeffort     Added animates property
// 10/16/98 jeffort     Renamed functions
// 11/19/98 markhal     Converted to use actor
//*****************************************************************************

#include "headers.h"

#include "colorbvr.h"
#include "attrib.h"
#include "dautil.h"

#undef THIS
#define THIS CColorBvr
#define SUPER CBaseBehavior

#include "pbagimp.cpp"

// These are used for the IPersistPropertyBag2 as it is implemented
// in the base class.  This takes an array of BSTR's, gets the
// attributes, queries this class for the variant, and copies
// the result.  The order of these defines is important

#define VAR_FROM        0
#define VAR_TO          1
#define VAR_PROPERTY    2
#define VAR_DIRECTION   3

WCHAR * CColorBvr::m_rgPropNames[] = {
                                     BEHAVIOR_PROPERTY_FROM,
                                     BEHAVIOR_PROPERTY_TO,
                                     BEHAVIOR_PROPERTY_PROPERTY,
                                     BEHAVIOR_PROPERTY_DIRECTION
                                    };

//*****************************************************************************

CColorBvr::CColorBvr() :
	m_pdispActor(NULL),
	m_lCookie(0)
{
    VariantInit(&m_varFrom);
    VariantInit(&m_varTo);
    VariantInit(&m_varDirection);
    VariantInit(&m_varProperty);
    m_clsid = CLSID_CrColorBvr;
} // CColorBvr

//*****************************************************************************

CColorBvr::~CColorBvr()
{
    VariantClear(&m_varFrom);
    VariantClear(&m_varTo);
    VariantClear(&m_varDirection);
    VariantClear(&m_varProperty);

    ReleaseInterface( m_pdispActor );
} // ~ColorBvr

//*****************************************************************************

HRESULT CColorBvr::FinalConstruct()
{
    HRESULT hr = SUPER::FinalConstruct();
    if (FAILED(hr))
    {
        DPF_ERR("Error in color behavior FinalConstruct initializing base classes");
        return hr;
    }

	// TODO (markhal): Why is this done here as well as in the GetAttributes method?
    m_varProperty.vt = VT_BSTR;
    m_varProperty.bstrVal = SysAllocString(DEFAULT_COLORBVR_PROPERTY);
    if (m_varProperty.bstrVal == NULL)
    {
        DPF_ERR("Error allocating default property string in CColorBvr::FinalConstruct");
        return SetErrorInfo(E_OUTOFMEMORY);
    }
    return S_OK;
} // FinalConstruct

//*****************************************************************************

VARIANT *
CColorBvr::VariantFromIndex(ULONG iIndex)
{
    DASSERT(iIndex < NUM_COLOR_PROPS);
    switch (iIndex)
    {
    case VAR_FROM:
        return &m_varFrom;
        break;
    case VAR_TO:
        return &m_varTo;
        break;
    case VAR_PROPERTY:
        return &m_varProperty;
        break;
    case VAR_DIRECTION:
        return &m_varDirection;
        break;
    default:
        // We should never get here
        DASSERT(false);
        return NULL;
    }
} // VariantFromIndex

//*****************************************************************************

HRESULT 
CColorBvr::GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropNames)
{
    *pulProperties = NUM_COLOR_PROPS;
    *pppPropNames = m_rgPropNames;
    return S_OK;
} // GetPropertyBagInfo

//*****************************************************************************

STDMETHODIMP 
CColorBvr::Init(IElementBehaviorSite *pBehaviorSite)
{
	return SUPER::Init(pBehaviorSite);
} // Init

//*****************************************************************************

STDMETHODIMP 
CColorBvr::Notify(LONG event, VARIANT *pVar)
{
	HRESULT hr = SUPER::Notify(event, pVar);
	CheckHR( hr, "Notify in base class failed", end);

	switch( event )
	{
	case BEHAVIOREVENT_CONTENTREADY:
		DPF_ERR("Got Content Ready");
			
		{
			hr = RequestRebuild( );
			CheckHR( hr, "Request for rebuild failed", end );
			
		}break;
    case BEHAVIOREVENT_DOCUMENTREADY:
		DPF_ERR("------>ColorBvr: Got Document Ready");
		break;
    case BEHAVIOREVENT_APPLYSTYLE:
		DPF_ERR("Got ApplyStyle");
		break;
    case BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE:
		DPF_ERR("Got Document context change");
		break;
	default:
		DPF_ERR("Unknown event");
	}

end:
	
	return hr;

} // Notify

//*****************************************************************************

STDMETHODIMP
CColorBvr::Detach()
{
	LMTRACE( L"Detaching color bvr <%p>\n", this );
	HRESULT hr = SUPER::Detach();
	if( FAILED( hr ) )
	{
		DPF_ERR( "Failure in detach of superclass" );
	}

	hr = RemoveFragment();
	CheckHR( hr, "Failed to remove the behavior fragment from the actor", end );

	LMTRACE( L"Done Detaching Color bvr <%p>\n", this );
end:
	return hr;
} // Detach 

//*****************************************************************************

STDMETHODIMP
CColorBvr::put_animates(VARIANT varAnimates)
{
    return SUPER::SetAnimatesProperty(varAnimates);
} // put_animates

//*****************************************************************************

STDMETHODIMP
CColorBvr::get_animates(VARIANT *pRetAnimates)
{
    return SUPER::GetAnimatesProperty(pRetAnimates);
} // get_animates

//*****************************************************************************

STDMETHODIMP
CColorBvr::put_from(VARIANT varFrom)
{
    HRESULT hr = VariantCopy(&m_varFrom, &varFrom);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting from for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR( "Failed to rebuild" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRCOLORBVR_FROM);
} // put_from

//*****************************************************************************

STDMETHODIMP
CColorBvr::get_from(VARIANT *pRetFrom)
{
    if (pRetFrom == NULL)
    {
        DPF_ERR("Error in CColorBvr:get_from, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetFrom, &m_varFrom);
} // get_from

//*****************************************************************************

STDMETHODIMP 
CColorBvr::put_to(VARIANT varTo)
{
    HRESULT hr = VariantCopy(&m_varTo, &varTo);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting to for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR( "Failed to rebuild" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRCOLORBVR_TO);
} // put_to

//*****************************************************************************

STDMETHODIMP 
CColorBvr::get_to(VARIANT *pRetTo)
{
    if (pRetTo == NULL)
    {
        DPF_ERR("Error in CColorBvr:get_to, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetTo, &m_varTo);
} // get_to

//*****************************************************************************

STDMETHODIMP 
CColorBvr::put_property(VARIANT varProperty)
{
    HRESULT hr = VariantCopy(&m_varProperty, &varProperty);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting property for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR( "Failed to rebuild" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRCOLORBVR_PROPERTY);
} // put_property

//*****************************************************************************

STDMETHODIMP 
CColorBvr::get_property(VARIANT *pRetProperty)
{
    if (pRetProperty == NULL)
    {
        DPF_ERR("Error in CColorBvr:get_property, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetProperty, &m_varProperty);
} // get_property

//*****************************************************************************

STDMETHODIMP
CColorBvr::put_direction(VARIANT varDirection)
{
    HRESULT hr = VariantCopy(&m_varDirection, &varDirection);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting direction for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR( "Failed to rebuild" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRCOLORBVR_DIRECTION);
} // put_direction

//*****************************************************************************

STDMETHODIMP
CColorBvr::get_direction(VARIANT *pRetDirection)
{
    if (pRetDirection == NULL)
    {
        DPF_ERR("Error in CColorBvr:get_direction, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetDirection, &m_varDirection);
} // get_direction

//*****************************************************************************

HRESULT 
CColorBvr::BuildAnimationAsDABehavior()
{
	// TODO (markhal): This method to go at some point
	return S_OK;
}

//*****************************************************************************

STDMETHODIMP
CColorBvr::buildBehaviorFragments( IDispatch* pActorDisp )
{
    HRESULT hr;

	hr = RemoveFragment();
	if( FAILED( hr ) )
	{
		DPF_ERR("Failed to remove the previous behavior frag from the actor" );
		return hr;
	}
	
    hr = CUtils::InsurePropertyVariantAsBSTR(&m_varProperty);
    if (FAILED(hr))
    {
        DPF_ERR("Error converting property variant to bstr");
        return SetErrorInfo(hr);
    }

	IDAColor *pbvrInterpolatedColor;

	ActorBvrFlags flags = e_AbsoluteAccum;

	// Check for to parameter only, since it uses a different code path
	hr = GetColorToBvr(pActorDisp, &pbvrInterpolatedColor);

	if (FAILED(hr))
	{
		flags = e_Absolute;

		// we need to build our animation in this function.  We do this
		// by first getting the from and to values, and converting these
		// to an interpolated DA number using the returned TIME value
		// for progress
		DWORD dwColorFrom = CUtils::GetColorFromVariant(&m_varFrom);
		DWORD dwColorTo = CUtils::GetColorFromVariant(&m_varTo);
		if (dwColorTo == PROPERTY_INVALIDCOLOR)
			//dwColorTo = DEFAULT_COLORBVR_TO;
			return S_OK;

		if (dwColorFrom == PROPERTY_INVALIDCOLOR)
			dwColorFrom = dwColorTo;

		float flFromH, flFromS, flFromL;
		float flToH, flToS, flToL;

		CUtils::GetHSLValue(dwColorFrom, &flFromH, &flFromS, &flFromL);
		CUtils::GetHSLValue(dwColorTo, &flToH, &flToS, &flToL);

		// We need to get the progree DA number from TIME
		// TODO: implement this, this is not hooked up in TIME yet
		// RSN
		IDANumber *pbvrProgress;

		hr = GetTIMEProgressNumber(&pbvrProgress);
		if (FAILED(hr))
		{
			DPF_ERR("Unable to access progress value from TIME behavior");
			return hr;
		}

		// create our interpolated color values
		IDANumber *pbvrInterpolatedH;
		IDANumber *pbvrInterpolatedS;
		IDANumber *pbvrInterpolatedL;

		hr = BuildHueNumber(flFromH, flToH, pbvrProgress, &pbvrInterpolatedH);
		if (FAILED(hr))
		{
			DPF_ERR("Error building Hue number bvr");
			ReleaseInterface(pbvrProgress);
			return hr;
		}

		hr = CDAUtils::TIMEInterpolateNumbers(GetDAStatics(), flFromS, flToS, pbvrProgress, &pbvrInterpolatedS);
		if (FAILED(hr))
		{
			DPF_ERR("Error interpolating Saturation in BuildAnimationAsDABehavior");
			ReleaseInterface(pbvrProgress);
			ReleaseInterface(pbvrInterpolatedH);
			return hr;
		}
		hr = CDAUtils::TIMEInterpolateNumbers(GetDAStatics(), flFromL, flToL, pbvrProgress, &pbvrInterpolatedL);
		if (FAILED(hr))
		{
			DPF_ERR("Error interpolating Lightness in BuildAnimationAsDABehavior");
			ReleaseInterface(pbvrProgress);
			ReleaseInterface(pbvrInterpolatedH);
			ReleaseInterface(pbvrInterpolatedS);
			return hr;
		}
		ReleaseInterface(pbvrProgress);

		hr = CDAUtils::BuildDAColorFromHSL(GetDAStatics(),
										   pbvrInterpolatedH,
										   pbvrInterpolatedS,
										   pbvrInterpolatedL,
										   &pbvrInterpolatedColor);
		ReleaseInterface(pbvrInterpolatedH);
		ReleaseInterface(pbvrInterpolatedS);
		ReleaseInterface(pbvrInterpolatedL);
		if (FAILED(hr))
		{
			DPF_ERR("Error building a DA color in BuildAnimationAsDABehavior");
			return hr;
		}
	}

	IDispatch *pdispThis  = NULL;

	hr  = GetHTMLElementDispatch( &pdispThis );
	if( FAILED( hr ) )
	{
		DPF_ERR( "Failed to get IDispatch from the element" );
		ReleaseInterface( pbvrInterpolatedColor );
		return hr;
	}
	
	// Attach color to behavior
	hr = AttachBehaviorToActorEx( pActorDisp,
								  pbvrInterpolatedColor,
								  V_BSTR(&m_varProperty),
								  flags,
								  e_Color,
								  pdispThis,
								  &m_lCookie);

	ReleaseInterface( pdispThis );
	ReleaseInterface(pbvrInterpolatedColor);

	if (FAILED(hr))
	{
		DPF_ERR("Failed to attach behavior to actor");
		return SetErrorInfo(hr);
	}

	m_pdispActor = pActorDisp;
	m_pdispActor->AddRef();

    return S_OK;
} // buildBehaviorFragments

//*****************************************************************************

HRESULT
CColorBvr::BuildHueNumber(float flFromH, float flToH, IDANumber *pbvrProgress, IDANumber **ppbvrInterpolatedH)
{
    HRESULT hr = S_OK;

    if (flFromH > 1.0f || flFromH < 0.0f || flToH > 1.0f || flToH < 0.0f)
        return E_INVALIDARG;

    *ppbvrInterpolatedH = NULL;

    hr = CUtils::InsurePropertyVariantAsBSTR(&m_varDirection);
    if (SUCCEEDED(hr))
    {
        if (0 == wcsicmp(BEHAVIOR_DIRECTION_NOHUE, m_varDirection.bstrVal))
        {
            float flHueToUse = flToH;
            if (flHueToUse == 0.0f)
                flHueToUse = flFromH;
            // for no hue, we will simply create a DA Number for the "to" hue
            hr = CDAUtils::GetDANumber(GetDAStatics(),
                                       flHueToUse,
                                       ppbvrInterpolatedH);
            if (FAILED(hr))
            {
                DPF_ERR("Error crating final hue value in nohue case");
                return SetErrorInfo(hr);
            }

        }
        else if (0 == wcsicmp(BEHAVIOR_DIRECTION_CLOCKWISE, m_varDirection.bstrVal))
        {
            if (0.0f == flFromH)
                flFromH = 1.0f;
                
            if (flToH >= flFromH)
            {
                // Behavior from->0 and 1->To
                float flSweep = flFromH + (1.0f - flToH);

                CComPtr<IDANumber> pbvrCutPercentage;
                hr = CDAUtils::GetDANumber(GetDAStatics(), flFromH / flSweep, &pbvrCutPercentage);
                if (FAILED(hr))
                    return hr;

                CComPtr<IDANumber> pbvrFirstPercent;
                hr = NormalizeProgressValue(GetDAStatics(), pbvrProgress, 0.0f, flFromH / flSweep, &pbvrFirstPercent);
                if (FAILED(hr))
                    return hr;

                CComPtr<IDANumber> pbvrFirst;
                hr = CDAUtils::TIMEInterpolateNumbers(GetDAStatics(), flFromH, 0.0f, pbvrFirstPercent, &pbvrFirst);
                if (FAILED(hr))
                    return hr;

                CComPtr<IDANumber> pbvrSecondPercent;
                hr = NormalizeProgressValue(GetDAStatics(), pbvrProgress, flFromH / flSweep, 1.0f, &pbvrSecondPercent);
                if (FAILED(hr))
                    return hr;

                CComPtr<IDANumber> pbvrSecond;
                hr = CDAUtils::TIMEInterpolateNumbers(GetDAStatics(), 1.0f, flToH, pbvrSecondPercent, &pbvrSecond);
                if (FAILED(hr))
                    return hr;

                CComPtr<IDABoolean> pbvrBoolean;
                hr = GetDAStatics()->LTE(pbvrProgress, pbvrCutPercentage, &pbvrBoolean);
                if (FAILED(hr))
                    return hr;

                CComPtr<IDABehavior> pbvrInterpolated;
                hr = SafeCond(GetDAStatics(), pbvrBoolean, pbvrFirst, pbvrSecond, &pbvrInterpolated);
                if (FAILED(hr))
                    return hr;

                hr = pbvrInterpolated->QueryInterface(IID_TO_PPV(IDANumber, ppbvrInterpolatedH));
                if (FAILED(hr))
                    return hr;
            }
            else
            {
                // behavior from->to
                hr = CDAUtils::TIMEInterpolateNumbers(GetDAStatics(), flFromH, flToH, pbvrProgress, ppbvrInterpolatedH);
                if (FAILED(hr))
                {
                    DPF_ERR("Error interpolating Hue in BuildHueNumber");
                    return hr;
                }
            }
        }
        else
        {
            // counterclockwise
            if (0.0f == flToH)
                flToH = 1.0f;

            if (flToH <= flFromH)
            {
                // behavior from->1 and 0->To
                float flSweep = flToH + (1.0f - flFromH);

                CComPtr<IDANumber> pbvrCutPercentage;
                hr = CDAUtils::GetDANumber(GetDAStatics(), (1.0f - flFromH) / flSweep, &pbvrCutPercentage);
                if (FAILED(hr))
                    return hr;

                CComPtr<IDANumber> pbvrFirstPercent;
                hr = NormalizeProgressValue(GetDAStatics(), pbvrProgress, 0.0f, (1.0f - flFromH) / flSweep, &pbvrFirstPercent);
                if (FAILED(hr))
                    return hr;

                CComPtr<IDANumber> pbvrFirst;
                hr = CDAUtils::TIMEInterpolateNumbers(GetDAStatics(), flFromH, 1.0f, pbvrFirstPercent, &pbvrFirst);
                if (FAILED(hr))
                    return hr;

                CComPtr<IDANumber> pbvrSecondPercent;
                hr = NormalizeProgressValue(GetDAStatics(), pbvrProgress, (1.0f - flFromH) / flSweep, 1.0f, &pbvrSecondPercent);
                if (FAILED(hr))
                    return hr;

                CComPtr<IDANumber> pbvrSecond;
                hr = CDAUtils::TIMEInterpolateNumbers(GetDAStatics(), 0.0f, flToH, pbvrSecondPercent, &pbvrSecond);
                if (FAILED(hr))
                    return hr;

                CComPtr<IDABoolean> pbvrBoolean;
                hr = GetDAStatics()->LTE(pbvrProgress, pbvrCutPercentage, &pbvrBoolean);
                if (FAILED(hr))
                    return hr;

                CComPtr<IDABehavior> pbvrInterpolated;
                hr = SafeCond(GetDAStatics(), pbvrBoolean, pbvrFirst, pbvrSecond, &pbvrInterpolated);
                if (FAILED(hr))
                    return hr;

                hr = pbvrInterpolated->QueryInterface(IID_TO_PPV(IDANumber, ppbvrInterpolatedH));
                if (FAILED(hr))
                    return hr;
            }
            else
            {
                // behavior from->to
                hr = CDAUtils::TIMEInterpolateNumbers(GetDAStatics(), flFromH, flToH, pbvrProgress, ppbvrInterpolatedH);
                if (FAILED(hr))
                {
                    DPF_ERR("Error interpolating Hue in BuildHueNumber");
                    return hr;
                }
            }
        }
    }
    else
    {
        // just take the shortest path
        hr = CDAUtils::TIMEInterpolateNumbers(GetDAStatics(), flFromH, flToH, pbvrProgress, ppbvrInterpolatedH);
        if (FAILED(hr))
        {
            DPF_ERR("Error interpolating Hue in BuildHueNumber");
            return hr;
        }
    }

    return S_OK;
} // BuildHueNumber

//*****************************************************************************

HRESULT
CColorBvr::NormalizeProgressValue(IDA2Statics *pDAStatics,
                                  IDANumber *pbvrProgress, 
                                  float flStartPercentage,
                                  float flEndPercentage,
                                  IDANumber **ppbvrReturn)
{

    DASSERT(pDAStatics != NULL);
    DASSERT(pbvrProgress != NULL);
    DASSERT(flStartPercentage >= 0.0f);
    DASSERT(flStartPercentage <= 1.0f);
    DASSERT(flEndPercentage >= 0.0f);
    DASSERT(flEndPercentage <= 1.0f);
    DASSERT(ppbvrReturn != NULL);
    *ppbvrReturn = NULL;
    
    HRESULT hr;

    if (flStartPercentage >= flEndPercentage)
    {
        DPF_ERR("Error, invalid percentage values");
        return E_INVALIDARG;
    }

    IDANumber *pbvrProgressRange;
    hr = CDAUtils::GetDANumber(pDAStatics, (flEndPercentage - flStartPercentage),
                               &pbvrProgressRange);
    if (FAILED(hr))
    {
        DPF_ERR("Error creating DA number in CPathElement::NormalizeProgressValue");
        return hr;
    }
    DASSERT(pbvrProgressRange != NULL);

    IDANumber *pbvrStart;
    hr = CDAUtils::GetDANumber(pDAStatics, flStartPercentage, &pbvrStart);
    if (FAILED(hr))
    {
        DPF_ERR("Error creating DA number in CPathElement::NormalizeProgressValue");
        ReleaseInterface(pbvrProgressRange);
        return hr;
    }
    DASSERT(pbvrStart != NULL);
    IDANumber *pbvrSub;
    hr = pDAStatics->Sub(pbvrProgress, pbvrStart, &pbvrSub);
    ReleaseInterface(pbvrStart);
    if (FAILED(hr))
    {
        DPF_ERR("Error subtracting DA number in CPathElement::NormalizeProgressValue");
        ReleaseInterface(pbvrProgressRange);
        return hr;
    }
    DASSERT(pbvrSub != NULL);
    hr = pDAStatics->Div(pbvrSub, pbvrProgressRange, ppbvrReturn);
    ReleaseInterface(pbvrSub);
    ReleaseInterface(pbvrProgressRange);
    if (FAILED(hr))
    {
        DPF_ERR("Error Dividing DA numbers in CPathElement::NormalizeProgressValue");
        return hr;
    }
    return S_OK;
} // NormalizeProgressValue

HRESULT
CColorBvr::GetColorToBvr(IDispatch *pActorDisp, IDAColor **ppResult)
{
	HRESULT hr = S_OK;

	// Only want to succeed if there is no from color and a valid to color
	DWORD dwColorFrom = CUtils::GetColorFromVariant(&m_varFrom);
	if (dwColorFrom != PROPERTY_INVALIDCOLOR)
		return E_FAIL;

	DWORD dwColorTo = CUtils::GetColorFromVariant(&m_varTo);
	if (dwColorTo == PROPERTY_INVALIDCOLOR)
		return E_FAIL;

	// Get from color from the actor
	IDABehavior *pFromBvr;
	hr = GetBvrFromActor(pActorDisp, V_BSTR(&m_varProperty), e_From, e_Color, &pFromBvr);
	if (FAILED(hr))
		return hr;

	IDAColor *pFrom = NULL;
	IDANumber *pFromH = NULL;
	IDANumber *pFromS = NULL;
	IDANumber *pFromL = NULL;
	IDANumber *pToH = NULL;
	IDANumber *pToS = NULL;
	IDANumber *pToL = NULL;
	IDANumber *pInterpH = NULL;
	IDANumber *pInterpS = NULL;
	IDANumber *pInterpL = NULL;

	hr = pFromBvr->QueryInterface(IID_TO_PPV(IDAColor, &pFrom));
	ReleaseInterface(pFromBvr);
	if (FAILED(hr))
		return hr;

	hr = pFrom->get_Hue(&pFromH);
	if (FAILED(hr))
		goto release;

	hr = pFrom->get_Saturation(&pFromS);
	if (FAILED(hr))
		goto release;

	hr = pFrom->get_Lightness(&pFromL);
	if (FAILED(hr))
		goto release;

	float flToH, flToS, flToL;

	CUtils::GetHSLValue(dwColorTo, &flToH, &flToS, &flToL);

	hr = GetDAStatics()->DANumber(flToH, &pToH);
	if (FAILED(hr))
		goto release;

	hr = GetDAStatics()->DANumber(flToS, &pToS);
	if (FAILED(hr))
		goto release;

	hr = GetDAStatics()->DANumber(flToL, &pToL);
	if (FAILED(hr))
		goto release;

	hr = BuildTIMEInterpolatedNumber(pFromH, pToH, &pInterpH);
	if (FAILED(hr))
		goto release;

	hr = BuildTIMEInterpolatedNumber(pFromS, pToS, &pInterpS);
	if (FAILED(hr))
		goto release;

	hr = BuildTIMEInterpolatedNumber(pFromL, pToL, &pInterpL);
	if (FAILED(hr))
		goto release;

	hr = GetDAStatics()->ColorHslAnim(pInterpH, pInterpS, pInterpL, ppResult);

release:
	ReleaseInterface(pFrom);
	ReleaseInterface(pFromH);
	ReleaseInterface(pFromS);
	ReleaseInterface(pFromL);
	ReleaseInterface(pToH);
	ReleaseInterface(pToS);
	ReleaseInterface(pToL);
	ReleaseInterface(pInterpH);
	ReleaseInterface(pInterpS);
	ReleaseInterface(pInterpL);

	return hr;
}

//*****************************************************************************

HRESULT
CColorBvr::RemoveFragment()
{
	HRESULT hr = S_OK;
	
	if( m_pdispActor != NULL && m_lCookie != 0 )
	{
		hr  = RemoveBehaviorFromActor( m_pdispActor, m_lCookie );
		ReleaseInterface( m_pdispActor );
		m_lCookie = 0;
		CheckHR( hr, "Failed to remove a fragment from the actor", end );
	}

end:

	return hr;
}

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\src\eventmgr.cpp ===
///////////////////////////////////////////////////////////////
// Copyright (c) 1998 Microsoft Corporation
//
// File: EventMgr.cpp
//
// Abstract:  
//
///////////////////////////////////////////////////////////////

#include "headers.h"
#include "eventmgr.h"
#include "mshtmdid.h"
#include "eventsink.h"
#include "dispex.h"
#include "axadefs.h"
#include "utils.h"


#define ATTACH              TRUE
#define DETACH              FALSE
#define MAXNAMELENGTH       50

#define THR(_arg) (_arg)
#define IGNORE_HR(_arg) (_arg)

struct {
    TIME_EVENT event;
    wchar_t * wsz_name;
} g_EventNames[] =
{
    { TE_ONBEGIN,         L"onbegin"         },
    { TE_ONPAUSE,         L"onpause"         },
    { TE_ONRESUME,        L"onresume"        },
    { TE_ONEND,           L"onend"           },
    { TE_ONRESYNC,        L"onresync"        },
    { TE_ONREPEAT,        L"onrepeat"        },
    { TE_ONREVERSE,       L"onreverse"       },
    { TE_ONMEDIACOMPLETE, L"onmediacomplete" },
};

OLECHAR *g_szEventName = L"TE_EventName";
OLECHAR *g_szRepeatCount = L"Iteration";


///////////////////////////////////////////////////////////////
//  Name: CEventMgr
//  Parameters:
//    CTIMEElement  & elm
//                               This parameter must be passed
//                               to the constructor so that 
//                               we can get info from elm
//
//  Abstract:
//    Stash away the element so we can get the OM when we need it
///////////////////////////////////////////////////////////////
CEventMgr::CEventMgr(IEventManagerClient* client)
: m_client(client),
  m_dwWindowEventConPtCookie(0),
  m_dwDocumentEventConPtCookie(0),
  m_pElement(NULL),
  m_pWindow(NULL),
  m_pWndConPt(NULL),
  m_pDocConPt(NULL),
  m_refCount(0),
  m_pEventSink(NULL),
  m_lastKeyMod(0),
  m_lastKey(0),
  m_lastKeyCount(0),
  m_hwndCurWnd(0),
  m_lastX(0),
  m_lastY(0),
  m_lastButton(0),
  m_lastMouseMod(0),
  m_pBeginElement(NULL),
  m_pEndElement(NULL),
  m_lBeginEventCount(0),
  m_lEndEventCount(0),
  m_bAttached(FALSE),
  m_lRepeatCount(0)
{

    // Zero out the cookies
    memset(m_cookies, 0, sizeof(m_cookies));

}

///////////////////////////////////////////////////////////////
//  Name: ~CEventMgr
//
//  Abstract:
//    Cleanup
///////////////////////////////////////////////////////////////
CEventMgr::~CEventMgr()
{
	if( m_pEventSink != NULL )
	{
		m_pEventSink->Deinit();
		delete m_pEventSink;
	}
}



   
///////////////////////////////////////////////////////////////
//  Name:  Init
//  Parameters:  None
//
//  Abstract:
//    Initializes the object
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::Init()
{
    HRESULT hr;
    CComPtr <IDispatch> pDisp;
    CComPtr <IHTMLDocument2> pDoc;

    m_pElement = m_client->GetElementToSink();
    m_pElement->AddRef();

    m_pEventSink = new CEventSink(m_client, this);
    m_pEventSink->Init();

    
    hr = THR(ConnectToContainerConnectionPoint());

    if (FAILED(hr))
    {
        goto done;
    }

    //get a pointer to the window
    hr = THR(m_pElement->get_document(&pDisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDisp->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDoc->get_parentWindow(&m_pWindow));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

  done:
    return hr;
}

///////////////////////////////////////////////////////////////
//  Name:  Deinit
//  Parameters:  None
//
//  Abstract:
//    Cleans up the object
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::Deinit()
{
    if (m_dwWindowEventConPtCookie != 0 && m_pWndConPt)
    {
        m_pWndConPt->Unadvise (m_dwWindowEventConPtCookie);
    }

    if (m_dwDocumentEventConPtCookie != 0 && m_pDocConPt)
    {
        m_pDocConPt->Unadvise (m_dwDocumentEventConPtCookie);
    }

    if (m_pEventSink)
    {
        m_pEventSink->Deinit();
        delete m_pEventSink;
        m_pEventSink = NULL;
    }

    m_dwWindowEventConPtCookie = 0;
    m_dwDocumentEventConPtCookie = 0;

    // Zero out the cookies
    memset(m_cookies, 0, sizeof(m_cookies));
    
    if (m_pElement)
    {
        m_pElement->Release();
        m_pElement = NULL;
    }

    //cleanup memory
    if (m_pBeginElement)
    {
        delete m_pBeginElement;
    }
    if (m_pEndElement)
    {
        delete m_pEndElement;
    }
	
	m_pDocConPt.Release();
	m_pWndConPt.Release();
	m_pWindow.Release();

    return S_OK;
}

///////////////////////////////////////////////////////////////

HRESULT CEventMgr::AddMouseEventListener( LPUNKNOWN pUnkListener )
{
	if ( pUnkListener == NULL ) return E_POINTER;
	
	ListUnknowns::iterator	it;

	if ( FindUnknown( m_listMouseEventListeners, pUnkListener, it ) )
		return S_FALSE;

	// REVIEW: weak ref. to the listeners
	m_listMouseEventListeners.push_back( pUnkListener );
	
	return S_OK;
}

///////////////////////////////////////////////////////////////

HRESULT CEventMgr::RemoveMouseEventListener( LPUNKNOWN pUnkListener )
{
	if ( pUnkListener == NULL ) return E_POINTER;
	
	ListUnknowns::iterator	it;

	if ( !FindUnknown( m_listMouseEventListeners, pUnkListener, it ) )
		return S_FALSE;

	m_listMouseEventListeners.erase( it );
	
	return S_OK;
}

///////////////////////////////////////////////////////////////
//  Name: Attach
// 
//  Parameters:
//    BSTR Event        The element and event to sink to.  This
//                      parameter is in the form "Element.Event"
//                      where element is "this" if an event from
//                      the current element is to be attached to.
//    BOOL bAttach      True to indicate Attach to this event, and
//                      false to indicate Detach from this event.
//
//  Abstract:
//    This is a generic routine that allows both attaching to
//    and detaching from Trident events.  This function decodes
//    the event name to find the correct element
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::Attach(BSTR Event, BOOL bAttach, IHTMLElement2 *pEventElement[], long Count)
{
    VARIANT_BOOL bSuccess = FALSE;
    HRESULT hr = S_OK;
    BSTR *EventName = NULL;
    BSTR *ElementName = NULL;
    int i = 0;


    //pElement = m_bvr.GetElement();

    hr = THR(GetEventName(Event, &ElementName, &EventName, Count));
    if (FAILED(hr))
    {
        goto done;
    }

    for (i = 0; i < Count; i++)
    {
        //get the element to attach to
        if (_wcsicmp(ElementName[i], L"this") == 0)
        {
            hr = THR(m_pElement->QueryInterface(IID_IHTMLElement2, (void **)&(pEventElement[i])));
            if (FAILED(hr))
            {
                continue;
            }

            hr = THR(pEventElement[i]->attachEvent(EventName[i], (IDispatch *)this, &bSuccess));
            if (FAILED(hr))
            {
                continue;
            }

            pEventElement[i]->AddRef();
        }
        else
        {
            if (bAttach == ATTACH)
            {
                CComPtr <IHTMLElement2> pSrcEle;
                CComPtr <IHTMLDocument2> pDoc2;
                CComPtr <IHTMLElementCollection> pEleCol;
                CComPtr <IDispatch> pSrcDisp;
                CComPtr <IDispatch> pDocDisp;
                CComPtr <IDispatchEx> pDispEx;

                //get the document
                hr = THR(m_pElement->get_document(&pDocDisp));
                if (FAILED(hr))
                {
                    continue;
                }

                hr = THR(pDocDisp->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc2));
                if (FAILED(hr))
                {
                    continue;
                }

                //get all elements in the document
                hr = THR(pDoc2->get_all(&pEleCol));
                if (FAILED(hr))
                {
                    continue;
                }

                //find the element with the correct name
                VARIANT vName;
                VARIANT vIndex;

                VariantInit(&vName);
                vName.vt = VT_BSTR;
                vName.bstrVal = SysAllocString(ElementName[i]);

                VariantInit(&vIndex);
                vIndex.vt = VT_I2;
                vIndex.iVal = 0;

                hr = THR(pEleCol->item(vName, vIndex, &pSrcDisp));
                if (FAILED(hr))
                {
                    SysFreeString(vName.bstrVal);
                    VariantClear(&vName);
                    VariantClear(&vIndex);
                    continue;
                }
                SysFreeString(vName.bstrVal);
                VariantClear(&vName);
                VariantClear(&vIndex);

                if (!pSrcDisp) //will be NULL if the vName is invalid element.
                {
                    pEventElement[i] = NULL;
                    continue;
                }

                hr = THR(pSrcDisp->QueryInterface(IID_IHTMLElement2, (void**)&pSrcEle));
                if (FAILED(hr))
                {
                    continue;
                }

                //cache the IHTMLElement2 pointer for use on detach
                pEventElement[i] = pSrcEle;
                pEventElement[i]->AddRef();

                hr = THR(pSrcDisp->QueryInterface(IID_IDispatchEx, (void**)&pDispEx));
                if (SUCCEEDED(hr))
                {
                    //determine if this is a valid event
                    DISPID temp;

                    hr = THR(pDispEx->GetDispID(EventName[i], fdexNameCaseSensitive, &temp));
                    if (SUCCEEDED(hr))
                    {
                        hr = THR(pSrcEle->attachEvent(EventName[i], (IDispatch *)this, &bSuccess));
                    }
                }
            }
            else
            {
                if (pEventElement[i])
                {
                    CComPtr <IDispatchEx> pDispEx;

                    hr = THR(pEventElement[i]->QueryInterface(IID_IDispatchEx, (void**)&pDispEx));
                    if (SUCCEEDED(hr))
                    {
                        //determine if this is a valid event
                        DISPID temp;
                        
                        hr = THR(pDispEx->GetDispID(EventName[i], fdexNameCaseSensitive, &temp));
                        if (SUCCEEDED(hr))
                        {
                            hr = THR(pEventElement[i]->detachEvent(EventName[i], (IDispatch *)this));
                        }

                    }
                    pEventElement[i]->Release();
                    pEventElement[i] = NULL;
                }
            }
        }
    }

  done:

    if (EventName)
    {
        for (i = 0; i < Count; i++)
        {
            SysFreeString(EventName[i]);
            SysFreeString(ElementName[i]);
        }
        delete[] EventName;
        delete[] ElementName;
    }
    return hr;
}


///////////////////////////////////////////////////////////////
//  Name: ConnectToContainerConnectionPoint
// 
//  Abstract:
//    Finds a connection point on the HTMLDocument interface
//    and passes this as an event handler.
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::ConnectToContainerConnectionPoint()
{
    // Get a connection point to the container
    CComPtr<IConnectionPointContainer> pWndCPC;
    CComPtr<IConnectionPointContainer> pDocCPC; 
    CComPtr<IHTMLDocument> pDoc; 
    CComPtr<IDispatch> pDocDispatch;
    CComPtr<IDispatch> pScriptDispatch;

    HRESULT hr;

    hr = THR(m_pElement->get_document(&pDocDispatch));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //get the document and cache it.
    hr = THR(pDocDispatch->QueryInterface(IID_IHTMLDocument, (void**)&pDoc));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //hook the documents events
    hr = THR(pDoc->QueryInterface(IID_IConnectionPointContainer, (void**)&pDocCPC));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(pDocCPC->FindConnectionPoint( DIID_HTMLDocumentEvents, &m_pDocConPt ));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    
    hr = THR(m_pDocConPt->Advise((IUnknown *)this, &m_dwDocumentEventConPtCookie));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //hook the windows events
    hr = THR(pDoc->get_Script (&pScriptDispatch));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(pScriptDispatch->QueryInterface(IID_IConnectionPointContainer, (void**)&pWndCPC));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    } 

    hr = THR(pWndCPC->FindConnectionPoint( DIID_HTMLWindowEvents, &m_pWndConPt ));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(m_pWndConPt->Advise((IUnknown *)this, &m_dwWindowEventConPtCookie));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;  
}


///////////////////////////////////////////////////////////////
//  Name: QueryInterface
// 
//  Abstract:
//    This QI only handles the IDispatch for HTMLWindowEvents
//    and returns this as the interface.
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::QueryInterface( REFIID riid, void **ppv )
{
    if (NULL == ppv)
        return E_POINTER;

    *ppv = NULL;

    if ( InlineIsEqualGUID(riid, IID_IDispatch) || InlineIsEqualGUID(riid, DIID_HTMLWindowEvents))
    {
        *ppv = this;
    }
        
    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;
}

///////////////////////////////////////////////////////////////
//  Name: AddRef
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch  
///////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CEventMgr::AddRef(void)
{
    return ++m_refCount;
}

///////////////////////////////////////////////////////////////
//  Name: Release
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CEventMgr::Release(void)
{
    m_refCount--;
    if (m_refCount == 0)
    {
        //delete this;
    }

    return m_refCount;
}



///////////////////////////////////////////////////////////////
//  Name: GetTypeInfoCount
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: GetTypeInfo
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
                                   /* [in] */ LCID /*lcid*/,
                                   /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: GetIDsOfNames
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::GetIDsOfNames(
    /* [in] */ REFIID /*riid*/,
    /* [size_is][in] */ LPOLESTR* /*rgszNames*/,
    /* [in] */ UINT /*cNames*/,
    /* [in] */ LCID /*lcid*/,
    /* [size_is][out] */ DISPID* /*rgDispId*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: Invoke
// 
//  Abstract:
//    This switches on the dispid looking for dispid's of events
//    that it should handle.  Note, this is called for all events
//    fired from the window, only the selected events are handled.
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::Invoke(
    /* [in] */ DISPID dispIdMember,
    /* [in] */ REFIID /*riid*/,
    /* [in] */ LCID /*lcid*/,
    /* [in] */ WORD /*wFlags*/,
    /* [out][in] */ DISPPARAMS* pDispParams,
    /* [out] */ VARIANT* pVarResult,
    /* [out] */ EXCEPINFO* /*pExcepInfo*/,
    /* [out] */ UINT* puArgErr)
{
    // Listen for the two events we're interested in, and call back if necessary
    HRESULT hr = S_OK;

    switch (dispIdMember)
    {
        case 0: //this is the case for events that have been hooked using attachEvent
        {
            CComPtr <IHTMLEventObj> pEventObj;
            BSTR bstrEventName; 
            BSTR bstrElementName;
    
            hr = THR((pDispParams->rgvarg[0].pdispVal)->QueryInterface(IID_IHTMLEventObj, (void**)&pEventObj));
            if (FAILED(hr))
            {
                goto done;
            }
            THR(pEventObj->get_type(&bstrEventName));

            break;
        }
        
        case DISPID_EVPROP_ONPROPERTYCHANGE:
        case DISPID_EVMETH_ONPROPERTYCHANGE:
            break;


        case DISPID_EVPROP_ONMOUSEMOVE:
        case DISPID_EVMETH_ONMOUSEMOVE:
            if (m_hwndCurWnd != 0 && m_pWindow)
            {
                CComPtr <IHTMLEventObj> pEventObj;
                long x, y, button;
                VARIANT_BOOL bMove, bUp, bShift, bAlt, bCtrl;

                hr = THR(m_pWindow->get_event(&pEventObj));
                if (FAILED (hr))
                {
                    break;
                }
                
                bMove = TRUE;
                bUp = FALSE;
                hr = THR(pEventObj->get_x(&x));
                hr = THR(pEventObj->get_y(&y));
                hr = THR(pEventObj->get_shiftKey(&bShift));
                hr = THR(pEventObj->get_altKey(&bAlt));
                hr = THR(pEventObj->get_ctrlKey(&bCtrl));
                hr = THR(pEventObj->get_button(&button));
                MouseEvent(x, y, bMove, bUp, bShift, bAlt, bCtrl, button);
                
                VariantInit(pVarResult);
                pVarResult->vt = VT_BOOL;
                pVarResult->boolVal = VARIANT_TRUE;
            }
            break;

        case DISPID_EVPROP_ONMOUSEUP:
        case DISPID_EVMETH_ONMOUSEUP:
            if (m_hwndCurWnd != 0 && m_pWindow)
            {
                CComPtr <IHTMLEventObj> pEventObj;
                long x, y, button;
                VARIANT_BOOL bMove, bUp, bShift, bAlt, bCtrl;

                hr = THR(m_pWindow->get_event(&pEventObj));
                if (FAILED (hr))
                {
                    break;
                }
                
                bMove = FALSE;
                bUp = TRUE;
                hr = THR(pEventObj->get_x(&x));
                hr = THR(pEventObj->get_y(&y));
                hr = THR(pEventObj->get_shiftKey(&bShift));
                hr = THR(pEventObj->get_altKey(&bAlt));
                hr = THR(pEventObj->get_ctrlKey(&bCtrl));
                hr = THR(pEventObj->get_button(&button));
                MouseEvent(x, y, bMove, bUp, bShift, bAlt, bCtrl, button);
                
                VariantInit(pVarResult);
                pVarResult->vt = VT_BOOL;
                pVarResult->boolVal = VARIANT_TRUE;
            }
            break;

 
        case DISPID_EVPROP_ONMOUSEOUT:
        case DISPID_EVMETH_ONMOUSEOUT:
            if (m_hwndCurWnd != 0 && m_pWindow)
            {
                CComPtr <IHTMLEventObj> pEventObj;
                
                hr = THR(m_pWindow->get_event(&pEventObj));
                if (FAILED (hr))
                {
                    break;
                }
                
                MouseEvent(m_lastX, 
                           m_lastY, 
                           FALSE, 
                           TRUE, 
                           m_lastMouseMod & AXAEMOD_SHIFT_MASK, 
                           m_lastMouseMod & AXAEMOD_ALT_MASK, 
                           m_lastMouseMod & AXAEMOD_CTRL_MASK, 
                           m_lastButton);

                VariantInit(pVarResult);
                pVarResult->vt = VT_BOOL;
                pVarResult->boolVal = VARIANT_TRUE;
            }
        
            break;

        case DISPID_EVPROP_ONLOAD:
        case DISPID_EVMETH_ONLOAD:
            m_bAttached = TRUE;
            //THR(AttachEvents());
            m_client->OnLoad();
            if (m_pEventSink)
            {
                IGNORE_HR(m_pEventSink->InitMouse());
            }
            break;

        case DISPID_EVPROP_ONUNLOAD:
        case DISPID_EVMETH_ONUNLOAD:
            m_client->OnUnload();    
            //THR(DetachEvents());
            break;

    }
  done:
    return S_OK;
}




///////////////////////////////////////////////////////////////
//  Name: GetEventCount
// 
//  Abstract:
//    Counts the number of events in an EventString where events
//    are separated by ';' or NULL terminated.
///////////////////////////////////////////////////////////////
long CEventMgr::GetEventCount(BSTR bstrEvent)
{
    long curCount = 0;
    OLECHAR *curChar;
    
    curChar = bstrEvent;

    while (*curChar != '\0')
    {
        curChar++;
        if ((*curChar == ';') || ((*curChar == '\0') && ((*curChar - 1) != ';')))
        {
            curCount++;
        }
    }

    return curCount;
}


///////////////////////////////////////////////////////////////
//  Name: GetEventName
// 
//  Abstract:
//    This gets the event names from a string that has the format
//    EventName()  It only handles strings like 
//    ElementName.EventName().  It can also handle the OR'ing of
//    event names using ";".  So Element1.Event1();Element2.Event2();...
//    can be handled.
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::GetEventName(BSTR bstrEvent, BSTR **pElementName, BSTR **pEventName, long Count)
{
    BSTR bstrEventName;
    OLECHAR sTemp[MAXNAMELENGTH];
    OLECHAR *curChar;
    int i = 0, j = 0;
    HRESULT hr = S_OK;
    BSTR bstrTempEvent = NULL;
    BSTR bstrTempElement = NULL;

    BSTR *bstrEventList = NULL;
    BSTR *bstrElementList = NULL;

    bstrElementList = new BSTR [Count];
    if (bstrElementList == NULL)
    {
        hr = E_FAIL;
        goto done;
    }
    
    bstrEventList = new BSTR [Count];
    if (bstrEventList == NULL)
    {
        hr = E_FAIL;
        goto done;
    }
    
    ZeroMemory(pElementName, (sizeof (BSTR *) * Count));
    ZeroMemory(pEventName, (sizeof (BSTR *) * Count));

    curChar = bstrEvent;
    for (j = 0; j < Count; j++)
    {
        //get the element name
        ZeroMemory(sTemp, sizeof(OLECHAR) * MAXNAMELENGTH);
        
		i = 0;
        //step through the bstr looking for \0 or the '.' or ';'
        while (i < MAXNAMELENGTH - 1 && *curChar != '\0' && *curChar != '.' && *curChar != ';')
        {
            if (*curChar != ' ')  //need to strip out spaces.
            {
                sTemp[i] = *curChar;
            }
            i++;
            curChar++;
        }
        
        if (*curChar != '.')
        {
            hr = E_FAIL;
            goto done;
        }
		
        bstrTempElement = SysAllocString(sTemp);
        bstrElementList[j] = bstrTempElement; 

        //get the event name
        ZeroMemory(sTemp, sizeof(OLECHAR) * MAXNAMELENGTH);

        curChar++;
        i = 0;
        //step through the bstr looking for \0 or the ';'
        while (i < MAXNAMELENGTH - 1 && *curChar != ';' && *curChar != '\0')
        {
            if (*curChar != ' ')  //need to strip out spaces.
            {
                sTemp[i] = *curChar;
            }
            i++;
            curChar++;
        }
        
        if (i == MAXNAMELENGTH)
        {
            hr = E_FAIL;
            goto done;
        }
        bstrTempEvent = SysAllocString(sTemp);
        bstrEventList[j] = bstrTempEvent;

        //advance curChar to the next element or the end of the string
        if (j < Count - 1)
        {
            while (*curChar != ';' && *curChar != '\0')
            {
                curChar++;
            }
            if (*curChar == ';') 
            {
                curChar++;
            }
            if (*curChar == '\0')
            {
                goto done;
            }
        }
    }

  done:
    if (SUCCEEDED(hr))
    {
        *pElementName = bstrElementList;
        *pEventName = bstrEventList;
    }
    else //cleanup code
    {
        for (i = 0; i < j; i++)
        {
            if (bstrEventList)
            {
                SysFreeString(bstrEventList[i]);
            }
            if (bstrElementList)
            {
                SysFreeString(bstrElementList[i]);
            }
        }
        if (bstrElementList)
        {
            delete[] bstrElementList;
        }
        if (bstrEventList)
        {
            delete[] bstrEventList;
        }
    }
    return hr;   
}

///////////////////////////////////////////////////////////////
//  Name: MatchEvent
// 
//  Parameters:
//    BSTR bstrEvent            The cached event name in the format
//                              "Elementname.EventName".
//    IHTMLEventObj *pEventObj  A pointer to the event object that is
//                              passed into IDispatch::Invoke.
//
//  Abstract:
//    Determines if the event that was just hooked matches
//    the event specified in bstrEvent.
///////////////////////////////////////////////////////////////
bool CEventMgr::MatchEvent(BSTR bstrEvent, IHTMLEventObj *pEventObj, long Count)
{
    bool bMatch = FALSE;
    BSTR *bstrExpEventName = NULL; 
    BSTR *bstrExpElementName = NULL;
    BSTR bstrEventName = NULL;
    BSTR bstrElementName = NULL;
    HRESULT hr = S_OK;
    CComPtr <IHTMLEventObj2> pEventObj2;

    int i = 0;

    hr = THR(pEventObj->get_type(&bstrEventName));
    
    //hack to work around eventobject problems
    if (!bstrEventName)
    {
        hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj2, (void**)&pEventObj2));
        if (FAILED(hr))
        {
            goto done;
        }
        VARIANT vTemp;
        VariantInit(&vTemp);
        pEventObj2->getAttribute(g_szEventName, 0, &vTemp);
        SysFreeString(bstrEventName );
        bstrEventName  = SysAllocString(vTemp.bstrVal);
        SysFreeString(vTemp.bstrVal);
        VariantClear(&vTemp);
    }

    hr = THR(GetEventName(bstrEvent, &bstrExpElementName, &bstrExpEventName, Count));
    if (FAILED(hr))
    {
        goto done;
    }
    
    for (i = 0; i < Count; i++)
    {
        //check that the event names match
        if (_wcsicmp(bstrExpEventName[i] + 2, bstrEventName) == 0 || _wcsicmp(bstrExpEventName[i], bstrEventName) == 0)
        {
            //check that the Element name matches
            CComPtr <IHTMLElement> pEle;

            hr = THR(pEventObj->get_srcElement(&pEle));
            if (FAILED(hr))
            {
                goto done;
            }
         
            //get the source element name
            THR(pEle->get_id(&bstrElementName));
        
            //handle the "this" string as an element name
            if (_wcsicmp(bstrExpElementName[i], L"this") == 0)
            {
                BSTR bstrName;
                hr = THR(m_pElement->get_id(&bstrName));
                if (FAILED(hr))
                {
                    SysFreeString(bstrName);
                    goto done;
                }

                if (_wcsicmp(bstrElementName, bstrName) == 0)
                {
                    bMatch = TRUE;          
                    SysFreeString(bstrName);
                    SysFreeString(bstrElementName);
                    goto done;
                }

            }
            else if (_wcsicmp(bstrExpElementName[i], bstrElementName) == 0)
            {
                bMatch = TRUE;          
                SysFreeString(bstrElementName);
                goto done;
            }
        }
        if (bstrElementName)
        {
            SysFreeString(bstrElementName);
        }
    }

  done:
    if (bstrExpEventName)
    {
        for (i = 0; i < Count; i++)
        {
            if (bstrExpEventName)
            {
                SysFreeString(bstrExpEventName[i]);
            }
            if (bstrExpElementName)
            {
                SysFreeString(bstrExpElementName[i]);
            }
        }
        if (bstrExpEventName)
        {
            delete[] bstrExpEventName;
        }
        if (bstrExpElementName)
        {
            delete[] bstrExpElementName;
        }
    }
    return bMatch;
}

///////////////////////////////////////////////////////////////
//  Name: ReadyStateChange
// 
//  Parameters:
//      BSTR ReadyState             a string containing the 
//                                  current ready state.  Possible
//                                  values are "complete" or
//                                  "interactive".  Only "complete"
//                                  is currently used.
//
//  Abstract:
//    This method is called from the EventSink class to 
//    notify the event manager that the readystatechange
//    event has occured.
///////////////////////////////////////////////////////////////
void CEventMgr::ReadyStateChange(BSTR ReadyState)
{   
    if ( _wcsicmp( ReadyState, L"complete" ) == 0 )
	{
		m_client->OnReadyStateChange( EVTREADYSTATE_COMPLETE );
	}
	else if ( _wcsicmp( ReadyState, L"interactive") == 0 )
    {
        m_client->OnReadyStateChange( EVTREADYSTATE_INTERACTIVE );
    }
}



///////////////////////////////////////////////////////////////
//  Name: PropertyChange
// 
//  Parameters:
//      BSTR PropertyName           The name of the property
//                                  that has changed.
//
//  Abstract:
//    This method is called from the EventSink class to 
//    notify the event manager that a propertychange event 
//    has occured.
///////////////////////////////////////////////////////////////
void CEventMgr::PropertyChange(BSTR PropertyName)
{
    //////////////////////////////////////
    //UNDONE:
    // do something to notify the element
    // that the a property has changed
    //
    // QUESTION: 
    // should this look for t:propertyname,
    // t_propertyname, or just propertyname?
    //////////////////////////////////////
}

///////////////////////////////////////////////////////////////
//  Name: MouseEvent
// 
//  Parameters:
//    long x                    The current x coordinate 
//    long y                    The current y coordinate
//    VARIANT_BOOL bMove        True if this is a mouse move event
//    VARIANT_BOOL bUp          True if this is a mouse up event
//    VARIANT_BOOL bShift       True if the Shift key is down
//    VARIANT_BOOL bAlt         True if the Alt key is down
//    VARIANT_BOOL bCtrl        True if the Control key is down
//    long button               Mousebutton that triggered the
//                              event. Possible values are:
//                                  1 for left
//                                  2 for right
//                                  4 for middle
// 
//  Abstract:
//    This method is called from the EventSink class to 
//    notify the event manager that a Mouse event
//    has occured on the element.
///////////////////////////////////////////////////////////////
void CEventMgr::MouseEvent(long x, 
                           long y, 
                           VARIANT_BOOL bMove,
                           VARIANT_BOOL bUp,
                           VARIANT_BOOL bShift, 
                           VARIANT_BOOL bAlt,
                           VARIANT_BOOL bCtrl,
                           long button)
{
	HRESULT		hr;
	hr = m_client->TranslateMouseCoords( x, y, &x, &y );
	if ( FAILED(hr) ) return;
	
	ListUnknowns::iterator it;

	OLECHAR		*rgNames[] = { L"mouseEvent" };
	DISPID		dispidMouseEvent;
	DISPPARAMS	params;
	VARIANTARG	rgvargs[8];
    int			cArgs = 8;
	VARIANT		varResult;
	EXCEPINFO	excepInfo;
	UINT		iArgErr;

	int			iArg = 0;

	rgvargs[iArg++] = CComVariant( button );
	rgvargs[iArg++] = CComVariant( bCtrl );
	rgvargs[iArg++] = CComVariant( bAlt );
	rgvargs[iArg++] = CComVariant( bShift );
	rgvargs[iArg++] = CComVariant( bUp );
	rgvargs[iArg++] = CComVariant( bMove );
	rgvargs[iArg++] = CComVariant( y );
	rgvargs[iArg++] = CComVariant( x );
	
	params.rgvarg				= rgvargs;
	params.cArgs				= cArgs;
	params.rgdispidNamedArgs	= NULL;
	params.cNamedArgs			= 0;
	
	for ( it = m_listMouseEventListeners.begin();
		  it != m_listMouseEventListeners.end();
		  it++ )
	{
		CComQIPtr<IDispatch, &IID_IDispatch> pDispListener( *it );

		hr = pDispListener->GetIDsOfNames( IID_NULL,
										   rgNames,
										   1,
										   LOCALE_SYSTEM_DEFAULT,
										   &dispidMouseEvent );
		if ( FAILED(hr) ) continue;

		hr = pDispListener->Invoke( dispidMouseEvent,
									IID_NULL,
									LOCALE_SYSTEM_DEFAULT,
									DISPATCH_METHOD,
									&params,
									&varResult,
									&excepInfo,
									&iArgErr );
	}
}
    

///////////////////////////////////////////////////////////////
//  Name: KeyEvent
// 
//  Parameters:
//    VARIANT_BOOL bLostFocus   True if there was a lost focus event
//    VARIANT_BOOL bUp          True if this is a KeyUp Event
//    VARIANT_BOOL bShift       True if the Shift key is down
//    VARIANT_BOOL bAlt         True if the Alt key is down
//    VARIANT_BOOL bCtrl        True if the Control key is down
//    long KeyCode              The unicode keycode for the key
// 
//  Abstract:
//    This method is called from the EventSink class to 
//    notify the event manager that a KeyBoard event
//    has occured on the element.
///////////////////////////////////////////////////////////////
void CEventMgr::KeyEvent(VARIANT_BOOL bLostFocus,
                         VARIANT_BOOL bUp,
                         VARIANT_BOOL bShift, 
                         VARIANT_BOOL bAlt,
                         VARIANT_BOOL bCtrl,
                         long KeyCode, 
                         long RepeatCount)
{
}  

///////////////////////////////////////////////////////////////
//  Name: GetModifiers
// 
//  Parameters:
//    VARIANT_BOOL bShift       True if the Shift key is down
//    VARIANT_BOOL bAlt         True if the Alt key is down
//    VARIANT_BOOL bCtrl        True if the Control key is down
// 
//  Abstract:
///////////////////////////////////////////////////////////////
BYTE CEventMgr::GetModifiers(VARIANT_BOOL bShift, VARIANT_BOOL bCtrl, VARIANT_BOOL bAlt)
{
    BYTE mod = AXAEMOD_NONE;

    if (bShift) mod |= AXAEMOD_SHIFT_MASK ;
    if (bCtrl) mod |= AXAEMOD_CTRL_MASK ;
    if (bAlt) mod |= AXAEMOD_ALT_MASK ;

    return mod;
}

bool CEventMgr::FindUnknown( const ListUnknowns& listUnknowns, LPUNKNOWN pUnk, ListUnknowns::iterator& itFound )
{
	ListUnknowns::iterator	it;
	for ( it = listUnknowns.begin(); it != listUnknowns.end(); it++ )
	{
		if ( *it == pUnk )
		{
			itFound = it;
			return true;
		}
	}

	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\src\effect.cpp ===
//*****************************************************************************
//
// File: effect.cpp
// Author: jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Implementation of CEffectBvr object which implements
//			 the chromeffects effect DHTML behavior
//
// Modification List:
// Date		Author		Change
// 11/13/98	jeffort		Created this file
//
//*****************************************************************************
#include "headers.h"

#include "effect.h"
#include "attrib.h"
#include "dautil.h"

#undef THIS
#define THIS CEffectBvr
#define SUPER CBaseBehavior

// this number is the number we use to distinguish transform dispid's
// from our own.  If our dispid value ever goes beyond this (sheesh!!!)
// then this number needs to be incremnted
#define EFFECT_BVR_DISPID_OFFSET 0x100
#define EFFECT_CLASSID_LENGTH 36
#define EFFECT_MAX_INPUTS 2
#define EFFECT_OUTPUT L"out"

//************************************************************
// Initialize the ATL CComTypeInfoHolder helper class. This mechanism takes
// care of the type library work for our custom IDispatchEx implementation.
// This code is patterned after the templatized IDispatchImpl class, but the
// template stuff is removed because we need to extend that functionality
// to understand IDispatchEx methods and to provide some custom handling
// within the IDispatch methods as well.
//
// -- note: this static initializer line looks similar to the normal
//    inheritance line for IDispatchImpl, for example:
//
//    public IDispatchImpl<ICrEffectBvr, &IID_ICrEffectBvr, &LIBID_LiquidMotion>
//
//   especially when you consider the default template parameters of:
//
//   WORD wMajor = 1, WORD wMinor = 0.  Look at atlcom.h and atlimpl.cpp for
//   more details on how this is done inside ATL.
//
//  IID_DXTC_DISPATCH is the name of the main interface that is implemented
//  On the parent object of the CDXTContainer class.  As an example, for
//  CComFilter, this class is ICrFilter3D.  This is the interface that
//  supports IDispatch on the parent object.
//
CComTypeInfoHolder CEffectBvr::s_tihTypeInfo =
        {&IID_ICrEffectBvr, &LIBID_LiquidMotion, 1, 0, NULL, 0};

// These are used for the IPersistPropertyBag2 as it is implemented
// in the base class.  This takes an array of BSTR's, gets the
// attributes, queries this class for the variant, and copies
// the result.  The order of these defines is important

#define VAR_TYPE 0
#define VAR_CLASSID 1
#define VAR_TRANSITION 2
#define VAR_PROGID 3
#define VAR_DIRECTION 4
#define VAR_IMAGE 5

WCHAR * CEffectBvr::m_rgPropNames[] = {
                                       BEHAVIOR_PROPERTY_TYPE,
                                       BEHAVIOR_PROPERTY_CLASSID,
                                       BEHAVIOR_PROPERTY_TRANSITION,
                                       BEHAVIOR_PROPERTY_PROGID,
                                       BEHAVIOR_PROPERTY_DIRECTION,
                                       BEHAVIOR_PROPERTY_IMAGE
                                      };

//*****************************************************************************

typedef struct _EFFECTVALUE_PAIR
{
    WCHAR *wzEffectClassid;
    WCHAR *wzEffectName;
} EFFECTVALUE_PAIR;

const EFFECTVALUE_PAIR
rgEffectNames[] =
{
    {L"{16b280c8-ee70-11d1-9066-00c04fd9189d}", L"basicimage"},
    {L"{421516C1-3CF8-11D2-952A-00C04FA34F05}", L"chroma"},
    {L"{9a43a844-0831-11d1-817f-0000f87557db}", L"compositor"},
    {L"{2bc0ef29-e6ba-11d1-81dd-0000f87557db}", L"convolution"},
    {L"{c3bdf740-0b58-11d2-a484-00c04f8efb69}", L"crbarn"},
    {L"{00c429c0-0ba9-11d2-a484-00c04f8efb69}", L"crblinds"},
    {L"{7312498d-e87a-11d1-81e0-0000f87557db}", L"crblur"},
    {L"{f515306d-0156-11d2-81ea-0000f87557db}", L"cremboss"},
    {L"{f515306e-0156-11d2-81ea-0000f87557db}", L"crengrave"},
    {L"{16b280c5-ee70-11d1-9066-00c04fd9189d}", L"crfade"},
    {L"{93073c40-0ba5-11d2-a484-00c04f8efb69}", L"crinset"},
    {L"{3f69f351-0379-11d2-a484-00c04f8efb69}", L"criris"},
    {L"{424b71af-0695-11d2-a484-00c04f8efb69}", L"crradialwipe"},
    {L"{810e402f-056b-11d2-a484-00c04f8efb69}", L"crslide"},
    {L"{aca97e00-0c7d-11d2-a484-00c04f8efb69}", L"crspiral"},
    {L"{7658f2a2-0a83-11d2-a484-00c04f8efb69}", L"crstretch"},
    {L"{5ae1dae0-1461-11d2-a484-00c04f8efb69}", L"crwheel"},
    {L"{e6e73d20-0c8a-11d2-a484-00c04f8efb69}", L"crzigzag"},
    {L"{ADC6CB86-424C-11D2-952A-00C04FA34F05}", L"dropshadow"},
    {L"{623e2882-fc0e-11d1-9a77-0000f8756a10}", L"gradient"},
    {L"{4ccea634-fbe0-11d1-906a-00c04fd9189d}", L"pixelate"},
    {L"{af279b30-86eb-11d1-81bf-0000f87557db}", L"wipe"}
}; // rgEffectNames

#define SIZE_OF_EFFECT_TABLE (sizeof(rgEffectNames) / sizeof(EFFECTVALUE_PAIR))

static int
CompareEventValuePairsByName(const void *pv1, const void *pv2)
{
    return _wcsicmp(((EFFECTVALUE_PAIR*)pv1)->wzEffectName,
                    ((EFFECTVALUE_PAIR*)pv2)->wzEffectName);
} // CompareEventValuePairsByName

//*****************************************************************************

CEffectBvr::CEffectBvr() :
    m_pTransform(NULL),
    m_pSp(NULL),
    m_pHTMLDoc(NULL),
    m_pdispActor(NULL),
    m_lCookie(0)
{
    VariantInit(&m_varType);
    VariantInit(&m_varTransition);
    VariantInit(&m_varClassId);
    VariantInit(&m_varProgId);
    VariantInit(&m_varDirection);
    VariantInit(&m_varImage);
    m_clsid = CLSID_CrEffectBvr;
} // CEffectBvr

//*****************************************************************************

CEffectBvr::~CEffectBvr()
{
    ReleaseInterface(m_pTransform);
    ReleaseInterface(m_pSp);
    ReleaseInterface(m_pHTMLDoc);
    VariantClear(&m_varTransition);
    VariantClear(&m_varClassId);
    VariantClear(&m_varProgId);
    VariantClear(&m_varDirection);
    VariantClear(&m_varImage);
} // ~EffectBvr

//*****************************************************************************

HRESULT CEffectBvr::FinalConstruct()
{
    HRESULT hr = SUPER::FinalConstruct();
    if (FAILED(hr))
    {
        DPF_ERR("Error in effect behavior FinalConstruct initializing base classes");
        return hr;
    }

    return S_OK;
} // FinalConstruct

//*****************************************************************************

VARIANT *
CEffectBvr::VariantFromIndex(ULONG iIndex)
{
    DASSERT(iIndex < NUM_EFFECT_PROPS);
    switch (iIndex)
    {
    case VAR_TYPE:
        return &m_varType;
        break;
    case VAR_CLASSID:
        return &m_varClassId;
        break;
    case VAR_TRANSITION:
        return &m_varTransition;
        break;
    case VAR_PROGID:
        return &m_varProgId;
        break;
    case VAR_DIRECTION:
        return &m_varDirection;
        break;
    case VAR_IMAGE:
        return &m_varImage;
        break;
    default:
        // We should never get here
        DASSERT(false);
        return NULL;
    }
} // VariantFromIndex

//*****************************************************************************

HRESULT 
CEffectBvr::GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropNames)
{
    *pulProperties = NUM_EFFECT_PROPS;
    *pppPropNames = m_rgPropNames;
    return S_OK;
} // GetPropertyBagInfo

//*****************************************************************************

STDMETHODIMP 
CEffectBvr::Init(IElementBehaviorSite *pBehaviorSite)
{

	if (pBehaviorSite == NULL) return E_FAIL;
	
	IDispatch * pDispDoc = NULL;
	
	HRESULT hr = SUPER::Init(pBehaviorSite);
	if (FAILED(hr)) goto done;
	
	hr = pBehaviorSite->QueryInterface(IID_IServiceProvider, (LPVOID *) &m_pSp );
	if (FAILED(hr)) goto done;

	hr = GetDAStatics()->put_ClientSite( this );
	if (FAILED(hr)) goto done;


	hr = GetHTMLElement()->get_document( &pDispDoc );
	if (FAILED(hr)) goto done;

	hr = pDispDoc->QueryInterface(IID_IHTMLDocument2, (LPVOID *)&m_pHTMLDoc);
	if (FAILED(hr)) goto done;
	
  done:
	ReleaseInterface(pDispDoc);
	return hr;
} // Init

//*****************************************************************************

STDMETHODIMP 
CEffectBvr::Notify(LONG event, VARIANT *pVar)
{
		
	HRESULT hr = SUPER::Notify(event, pVar);
	CheckHR( hr, "Notify in base class failed", end);

	switch( event )
	{
	case BEHAVIOREVENT_CONTENTREADY:
		DPF_ERR("Got Content Ready");
			
		{
			hr = RequestRebuild( );
			CheckHR( hr, "Request for rebuild failed", end );
			
		}break;
    case BEHAVIOREVENT_DOCUMENTREADY:
		break;
    case BEHAVIOREVENT_APPLYSTYLE:
		DPF_ERR("Got ApplyStyle");
		break;
    case BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE:
		DPF_ERR("Got Document context change");
		break;
	default:
		DPF_ERR("Unknown event");
	}

end:
	
	return hr;

} // Notify

//*****************************************************************************

STDMETHODIMP
CEffectBvr::Detach()
{
	ReleaseInterface(m_pSp);
	ReleaseInterface(m_pHTMLDoc);

	
	if( GetDAStatics() != NULL )
		GetDAStatics()->put_ClientSite( NULL );
	
	HRESULT hr = SUPER::Detach();

	if( m_pdispActor != NULL && m_lCookie != 0 )
	{
		//remove our behavior fragment from the actor
		hr = RemoveBehaviorFromActor( m_pdispActor, m_lCookie );
		if( FAILED( hr ) )
		{

			ReleaseInterface( m_pdispActor );
			DPF_ERR( "Failed to remove behavior fragment from actor" );
			return hr;
		}

		m_lCookie = 0;
	}
	ReleaseInterface( m_pdispActor );

	return hr;
} // Detach 

//*****************************************************************************

STDMETHODIMP
CEffectBvr::put_animates(VARIANT varAnimates)
{
    return SUPER::SetAnimatesProperty(varAnimates);
} // put_animates

//*****************************************************************************

STDMETHODIMP
CEffectBvr::get_animates(VARIANT *pRetAnimates)
{
    return SUPER::GetAnimatesProperty(pRetAnimates);
} // get_animates

//*****************************************************************************

STDMETHODIMP
CEffectBvr::put_type(VARIANT varType)
{
    HRESULT hr = VariantCopy(&m_varType, &varType);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting type for element");
        return SetErrorInfo(hr);
    }

	//TODO: some more stuff here to remap dispids on the new effect
	
    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICREFFECTBVR_TYPE);
} // put_type

//*****************************************************************************

STDMETHODIMP
CEffectBvr::get_type(VARIANT *pRetType)
{
    if (pRetType == NULL)
    {
        DPF_ERR("Error in get_type: invalid pointer");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetType, &m_varType);
} // get_type

//*****************************************************************************

STDMETHODIMP
CEffectBvr::put_transition(VARIANT varTransition)
{
    HRESULT hr;
    hr = VariantCopy(&m_varTransition, &varTransition);
    if (FAILED(hr))
    {
        DPF_ERR("Error in put_transition copying variant");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICREFFECTBVR_TRANSITION);
} // put_transition

//*****************************************************************************

STDMETHODIMP
CEffectBvr::get_transition(VARIANT *pRetTransition)
{
    if (pRetTransition == NULL)
    {
        DPF_ERR("Error in put_transition, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetTransition, &m_varTransition);
} // get_transition

//*****************************************************************************

STDMETHODIMP
CEffectBvr::put_classid(VARIANT varClassId)
{
    HRESULT hr;
    hr = VariantCopy(&m_varClassId, &varClassId);
    if (FAILED(hr))
    {
        DPF_ERR("Error in put_classid copying variant");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICREFFECTBVR_CLASSID);
} // put_classid

//*****************************************************************************

STDMETHODIMP
CEffectBvr::get_classid(VARIANT *pRetClassId)
{
    if (pRetClassId == NULL)
    {
        DPF_ERR("Error in get_classid, invalid pointer");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetClassId, &m_varClassId);
} // get_classid

//*****************************************************************************

STDMETHODIMP
CEffectBvr::put_progid(VARIANT varProgId)
{
    HRESULT hr;
    hr = VariantCopy(&m_varProgId, &varProgId);
    if (FAILED(hr))
    {
        DPF_ERR("Error in put_progid copying variant");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICREFFECTBVR_PROGID);
} // put_progid

//*****************************************************************************

STDMETHODIMP
CEffectBvr::get_progid(VARIANT *pRetProgId)
{
    if (pRetProgId == NULL)
    {
        DPF_ERR("Error in get_progid, invalid pointer");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetProgId, &m_varProgId);
} // get_progid

//*****************************************************************************

STDMETHODIMP
CEffectBvr::put_direction(VARIANT varDirection)
{
    HRESULT hr;
    hr = VariantCopy(&m_varDirection, &varDirection);
    if (FAILED(hr))
    {
        DPF_ERR("Error in put_direction copying variant");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICREFFECTBVR_DIRECTION);
} // put_direction

//*****************************************************************************

STDMETHODIMP
CEffectBvr::get_direction(VARIANT *pRetDirection)
{
    if (pRetDirection == NULL)
    {
        DPF_ERR("Error in get_direction, invalid pointer");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetDirection, &m_varDirection);
} // get_direction

//*****************************************************************************

STDMETHODIMP
CEffectBvr::put_image(VARIANT varImage)
{
    HRESULT hr;
    hr = VariantCopy(&m_varImage, &varImage);
    if (FAILED(hr))
    {
        DPF_ERR("Error in put_image copying variant");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICREFFECTBVR_IMAGE);
} // put_image

//*****************************************************************************

STDMETHODIMP
CEffectBvr::get_image(VARIANT *pRetImage)
{
    if (pRetImage == NULL)
    {
        DPF_ERR("Error in get_image, invalid pointer");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetImage, &m_varImage);
} // get_image

//*****************************************************************************

HRESULT 
CEffectBvr::GetClassIdFromType(WCHAR **pwzClassId)
{
    DASSERT(pwzClassId != NULL);
    *pwzClassId = NULL;
    HRESULT hr;
    hr = CUtils::InsurePropertyVariantAsBSTR(&m_varType);
    if (FAILED(hr))
    {
        DPF_ERR("Error converting type variant to bstr");
        return SetErrorInfo(hr);
    }
    EFFECTVALUE_PAIR EffectValue;
    EffectValue.wzEffectName = m_varType.bstrVal;

    EFFECTVALUE_PAIR *pReturnedEffect = (EFFECTVALUE_PAIR *)bsearch(&EffectValue,
                                                                    rgEffectNames,
                                                                    SIZE_OF_EFFECT_TABLE,
                                                                    sizeof(EFFECTVALUE_PAIR),
                                                                    CompareEventValuePairsByName);
    if (pReturnedEffect == NULL)
    {
        DPF_ERR("Error invalid type passed into effect");
        return SetErrorInfo(E_INVALIDARG);
    }
    *pwzClassId = pReturnedEffect->wzEffectClassid;
    return S_OK;
} // GetClassIdFromType

//*****************************************************************************

HRESULT 
CEffectBvr::BuildTransform()
{
    HRESULT hr;
    WCHAR *wzClassId;
    CLSID clsidConverted = GUID_NULL;
    
    ReleaseInterface(m_pTransform);
    // If we can get a classid from the type that was set, use that, otherwise
    // use the classid
    hr = GetClassIdFromType(&wzClassId);
    if (SUCCEEDED(hr))
    {
        hr = CLSIDFromString(wzClassId, &clsidConverted);
        if (FAILED(hr))
        {
            DPF_ERR("Could not get a classid from the bstr using type");
            return SetErrorInfo(hr);
        }
    }
    else
    {
        // try and convert the progid to a string
        if (m_varProgId.vt == VT_BSTR && m_varProgId.bstrVal != NULL)
        {
            // try the conversion
            hr = CLSIDFromProgID(m_varProgId.bstrVal, &clsidConverted); 
        }
        if (FAILED(hr) && m_varClassId.vt == VT_BSTR && m_varClassId.bstrVal != NULL)
        {
            // we need to form the string into the format that CLSIDFromString takes
            // the 3 below is for '{', '}', and null termination
            WCHAR *wzTemp = m_varClassId.bstrVal;
            CUtils::SkipWhiteSpace(&wzTemp);
            WCHAR rgwcTempClsid[EFFECT_CLASSID_LENGTH + 3];
            rgwcTempClsid[0] = L'{';
            rgwcTempClsid[EFFECT_CLASSID_LENGTH + 1] = L'}';
            rgwcTempClsid[EFFECT_CLASSID_LENGTH + 2] = 0;
            wcsncpy(&(rgwcTempClsid[1]), wzTemp,  EFFECT_CLASSID_LENGTH);
            wzClassId = rgwcTempClsid;
            hr = CLSIDFromString(wzClassId, &clsidConverted);
            if (FAILED(hr))
            {
                DPF_ERR("Could not get a classid from the bstr");
                return SetErrorInfo(hr);
            }
        }
        if (FAILED(hr)) 
        {
            DPF_ERR("Error no classid found for effect");
            return SetErrorInfo(E_INVALIDARG);
        }
    }

    hr = CoCreateInstance(clsidConverted,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IDXTransform,
                          (void **)&m_pTransform);
    if (FAILED(hr))
    {
        DPF_ERR("Error creating transform");
        return SetErrorInfo(hr);
    }
    return S_OK;
} // BuildTransform

//*****************************************************************************

HRESULT 
CEffectBvr::BuildAnimationAsDABehavior()
{
	// TODO (markhal): This will go away when all behaviors talk to actor
	return S_OK;
}

STDMETHODIMP
CEffectBvr::buildBehaviorFragments( IDispatch* pActorDisp )
{
    if (m_pTransform == NULL)
        // nothing for us to do, is this an error
        // or do we return S_OK;
        return S_OK;

    HRESULT hr;

    //if our behavior fragment is already on an actor
    if( m_pdispActor != NULL && m_lCookie != 0 )
    {
        hr = RemoveBehaviorFromActor( m_pdispActor, m_lCookie );
        if( FAILED( hr ) )
        {
        	DPF_ERR("Failed to remove the behavior fragment from the actor");
        	return hr;
        }
        
        m_lCookie = 0;

        ReleaseInterface( m_pdispActor );
    }    

    // we need to determine how many inputs the transform takes
    // If there are two inputs, then we examine the transition
    // attribute to determine if the original image (from time) is the first or
    // second.  If there is one input, then we use the original image as the input,
    // otherwise we use NULL as the input.

    // First test for two inputs
    ULONG   cGuidsNeeded = 0;
    int cInputs = 0;
    // We use less than here, since the inputs to
    // the below function is an index (ie if youc all with 0, it supports 1 input)
    // So when the number equals the max, we have finished searching
    while (cInputs < EFFECT_MAX_INPUTS )
    {
        hr = m_pTransform->GetInOutInfo(FALSE, cInputs, NULL, NULL, &cGuidsNeeded, NULL);
        if (FAILED(hr))
        {
            DPF_ERR("Error testing transform for number of inputs");
            return SetErrorInfo(hr);
        }
        else if (hr == S_OK)
        {
            cInputs++;
        }
        else
        {
            DASSERT(hr == S_FALSE);
            break;
        }
    }
/*
    IHTMLElement *pAnimatedElement;
    hr = GetAnimatedParentElement(&pAnimatedElement);
    if (FAILED(hr))
    {
        DPF_ERR("Error obtaining element to animate for effect");
        return hr;
    }

    IDAImage *pbvrOriginalImage = NULL;
    IDAImage *pbvrEmptyImage = NULL;

    
    hr = GetTIMEImageBehaviorFromElement(pAnimatedElement,
                                         &pbvrOriginalImage);
    ReleaseInterface(pAnimatedElement);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting original image form HTML TIME element");
        return hr;
    }
*/
	IDAImage *pbvrOriginalImage = NULL;
	IDAImage *pbvrTransitionImage = NULL;

	hr = GetImageFromActor(pActorDisp, &pbvrOriginalImage);

	if (FAILED(hr))
	{
		DPF_ERR("Error getting original image from actor");
		return hr;
	}

    IDABehavior *rgInputs[EFFECT_MAX_INPUTS];
    IDABehavior **ppbvrInputs = rgInputs;

    // If we need two inputs, create an Empty Image
    if (cInputs > 1)
    {
        hr = CUtils::InsurePropertyVariantAsBSTR(&m_varImage);
        if (SUCCEEDED(hr))
        {
			IDAImage *pdaimgEmpty = NULL;
			IDAImportationResult *pImportationResult = NULL;

			hr = GetDAStatics()->get_EmptyImage(&pdaimgEmpty);
			if( FAILED( hr ) )
			{
				DPF_ERR("Error creating empty image");
				goto failed;
			}

            hr = GetDAStatics()->ImportImageAsync(V_BSTR(&m_varImage), pdaimgEmpty, &pImportationResult);
			if( FAILED( hr ) )
			{
				DPF_ERR("Error calling import image async");
				goto failed;
			}

			hr = pImportationResult->get_Image( &pbvrTransitionImage );
			if( FAILED( hr ) )
			{
				DPF_ERR("Error calling get_Image on the importation result");
				goto failed;
			}

failed:
			ReleaseInterface( pdaimgEmpty );
			ReleaseInterface( pImportationResult );
            if (FAILED(hr) || (pbvrTransitionImage == NULL))
            {
                hr = GetDAStatics()->get_EmptyImage(&pbvrTransitionImage);
            }
        }
        else
        {
            hr = GetDAStatics()->get_EmptyImage(&pbvrTransitionImage);
        }
        
        if (FAILED(hr))
        {
            DPF_ERR("Error creating empty image");
            ReleaseInterface(pbvrOriginalImage);
            return SetErrorInfo(hr);
        }
        // Assume for now the transition is the input
        hr = CUtils::InsurePropertyVariantAsBSTR(&m_varTransition);
        if (SUCCEEDED(hr) && (_wcsicmp(m_varTransition.bstrVal, EFFECT_OUTPUT) == 0))
        {
            rgInputs[0] = pbvrOriginalImage;
            rgInputs[1] = pbvrTransitionImage;

        }
        else
        {
            rgInputs[1] = pbvrOriginalImage;
            rgInputs[0] = pbvrTransitionImage;
        }
    }
    else if (cInputs == 1)
    {
        rgInputs[0] = pbvrOriginalImage;
    }
    else
    {
        ppbvrInputs = NULL;
    }
/*
    hr = ApplyEffectBehaviorToAnimationElement(m_pTransform,
                                               ppbvrInputs,
                                               cInputs);
*/

	IDispatch *pdispThis = NULL;
	hr = GetHTMLElement()->QueryInterface( IID_TO_PPV( IDispatch, &pdispThis ) );
	if( FAILED( hr ) )
	{
		ReleaseInterface( pbvrOriginalImage );
		ReleaseInterface( pbvrTransitionImage );

		DPF_ERR("QI for IDispatch on the element failed");
		return hr;
	}

	hr = AttachEffectToActor(pActorDisp,
							 m_pTransform,
							 ppbvrInputs,
							 cInputs,
							 pdispThis,
							 &m_lCookie);

    ReleaseInterface(pbvrOriginalImage);
    ReleaseInterface(pbvrTransitionImage);

   	ReleaseInterface( pdispThis );
   	
    if (FAILED(hr))
    {
        DPF_ERR("Error applying transform to actor");
        return hr;
    }

    m_pdispActor = pActorDisp;
    m_pdispActor->AddRef();
    
    return S_OK;
} // BuildAnimationAsDABehavior

//*****************************************************************************

STDMETHODIMP CEffectBvr::GetTypeInfoCount(/*[out]*/UINT FAR* pctinfo)
{
    // Patterned after ATL's IDispatchImpl::GetTypeInfoCount()
    if (NULL != pctinfo)
    {
        *pctinfo = 1;
        return S_OK;
    }
    else
    {
        return SetErrorInfo(E_POINTER);
    }
} // GetTypeInfoCount

//*****************************************************************************

STDMETHODIMP CEffectBvr::GetTypeInfo(/*[in]*/UINT itinfo, 
                            /*[in]*/LCID lcid, 
                            /*[out]*/ITypeInfo ** pptinfo)
{
   return s_tihTypeInfo.GetTypeInfo(itinfo, lcid, pptinfo);;
} // GetTypeInfo

//*****************************************************************************

STDMETHODIMP CEffectBvr::GetIDsOfNames(/*[in]*/REFIID riid,
                                /*[in,size_is(cNames)]*/LPOLESTR * rgszNames,
                                /*[in]*/UINT cNames,
                                /*[in]*/LCID lcid,
                                /*[out,size_is(cNames)]*/DISPID FAR* rgdispid)
{
    // Further processing to resolve our "custom DISPID" property
    // names correctly is handled in GetDispID and not directly
    // supported if the caller calls GetIDsOfNames directly, because this
    // is an IDispatch interface, and thus those properties aren't really
    // visible to IDispatch.
    return s_tihTypeInfo.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
} // GetIDsOfNames

//*****************************************************************************

STDMETHODIMP CEffectBvr::Invoke(/*[in]*/DISPID dispidMember,
                        /*[in]*/REFIID riid,
                        /*[in]*/LCID lcid,
                        /*[in]*/WORD wFlags,
                        /*[in,out]*/DISPPARAMS * pdispparams,
                        /*[out]*/VARIANT * pvarResult,
                        /*[out]*/EXCEPINFO * pexcepinfo,
                        /*[out]*/UINT * puArgErr)
{
    HRESULT hr;
    hr = s_tihTypeInfo.Invoke(static_cast<IDispatch*>(static_cast<ICrEffectBvr*>(this)), 
                              dispidMember,
                              riid, 
                              lcid, 
                              wFlags, 
                              pdispparams,
                              pvarResult, 
                              pexcepinfo, 
                              puArgErr);
    if (SUCCEEDED(hr))
        return hr;
    else
        return SetErrorInfo(hr);
} // Invoke

//*****************************************************************************

STDMETHODIMP CEffectBvr::GetDispID(/*[in]*/BSTR bstrName,
                            /*[in]*/DWORD grfdex,
                            /*[out]*/DISPID *pid)
{
    HRESULT hr;
    
    if (NULL == pid)
        return E_POINTER;
    *pid = DISPID_UNKNOWN;
    hr = DISP_E_UNKNOWNNAME;
    
    // Note: We handle the case where we get called with fdexNameEnsure,
    //   which means that we *MUST* allocate a new DISPID for this BSTR, by
    //   essentially saying "sorry."  The code will fall through and return
    //   DISP_E_UNKNOWNNAME, even though a full IDispatchEx implementation is
    //   not *supposed* to.  That flag is used to allocate a "slot" for an
    //   expando property, which this implementation currently doesn't support.

    // Note: We don't pay attention to the case sensitive flag options in
    //   grfdex, because we're not required to, and because we're wrapping
    //   an IDispatch which is case insensitive anyway.

    hr = GetIDsOfNames(IID_NULL, &bstrName, 1, LOCALE_USER_DEFAULT, pid);

    if (DISP_E_UNKNOWNNAME == hr)
    {
        // GetIDsOfNames should have set the DISPID to DISPID_UNKNOWN
        DASSERT(DISPID_UNKNOWN == *pid);
        if (m_pTransform == NULL)
        {
            DPF_ERR("GetDispID error: unknown name, no transform present");
            return SetErrorInfo(hr);
        }

        IDispatch *pDisp;
        hr = m_pTransform->QueryInterface(IID_TO_PPV(IDispatch, &pDisp));
        if (FAILED(hr))
        {
            DPF_ERR("Error QI'ing transform for IDispatch");
            return SetErrorInfo(hr);
        }
        hr = pDisp->GetIDsOfNames(IID_NULL, &bstrName, 1, LOCALE_USER_DEFAULT, pid);
        ReleaseInterface(pDisp);
        if (FAILED(hr))
        {
            DPF_ERR("Error in GetDispID, name unkown");
            return SetErrorInfo(hr);
        }
        // otherwise we got back a dispid, add in our offset
        *pid += EFFECT_BVR_DISPID_OFFSET;
    }
    return S_OK;
} // GetDispID

//*****************************************************************************

STDMETHODIMP CEffectBvr::InvokeEx(/*[in]*/DISPID dispidMember,
                        /*[in]*/LCID lcid,
                        /*[in]*/WORD wFlags,
                        /*[in]*/DISPPARAMS * pdispparams,
                        /*[in,out,unique]*/VARIANT * pvarResult,
                        /*[in,out,unique]*/EXCEPINFO * pexcepinfo,
                        /*[in,unique]*/IServiceProvider *pSrvProvider)
{
    // Check for any flags that aren't valid for Invoke but might
    // be passed to InvokeEx (for example, DISPATCH_CONSTRUCT).  If we
    // get any of those, we don't know how to handle them, so we fail the
    // call.
    if (wFlags & ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET
                    | DISPATCH_PROPERTYPUT| DISPATCH_PROPERTYPUTREF))
    {
        DPF(0, "Failing InvokeEx() call for DISPATCH_ flag that cannot be passed along to IDispatch::Invoke()");
        return SetErrorInfo(E_FAIL);
    }

    HRESULT hr;
    if (dispidMember >= EFFECT_BVR_DISPID_OFFSET)
    {
		if (m_pTransform == NULL)
		{
			DPF_ERR("InvokeEx called when transform is NULL");
			return SetErrorInfo(DISP_E_MEMBERNOTFOUND);
		}

        // we need to relay this InvokeEx to the transform
        dispidMember -= EFFECT_BVR_DISPID_OFFSET;
        IDispatch *pDisp;
        hr = m_pTransform->QueryInterface(IID_TO_PPV(IDispatch, &pDisp));
        if (FAILED(hr))
        {
            DPF_ERR("Error QI'ing transform for IDispatch");
            return SetErrorInfo(hr);
        }
        hr = pDisp->Invoke(dispidMember, 
                           IID_NULL,
                           lcid, 
                           wFlags, 
                           pdispparams, 
                           pvarResult,
                           pexcepinfo, 
                           NULL);
        ReleaseInterface(pDisp);
        dispidMember += EFFECT_BVR_DISPID_OFFSET;
        if (FAILED(hr))
        {
            DPF_ERR("Error in InvokeEx calling transform");
            return SetErrorInfo(hr);
        }    
    }
    else
    {
        hr = Invoke(dispidMember, 
                    IID_NULL,
                    lcid, 
                    wFlags, 
                    pdispparams, 
                    pvarResult,
                    pexcepinfo, 
                    NULL);
        if (FAILED(hr))
        {
            DPF_ERR("Error in InvokeEx, error calling internal Invoke");
            return hr;
        }
    }
    return S_OK;
} // InvokeEx

//*****************************************************************************

STDMETHODIMP CEffectBvr::DeleteMemberByName(/*[in]*/BSTR bstr,
                                    /*[in]*/DWORD grfdex)
{
   return SetErrorInfo(E_NOTIMPL);;
} // DeleteMemberByName

//*****************************************************************************

STDMETHODIMP CEffectBvr::DeleteMemberByDispID(/*[in]*/DISPID id)
{
   return SetErrorInfo(E_NOTIMPL);
} // DeleteMemberByDispID

//*****************************************************************************

STDMETHODIMP CEffectBvr::GetMemberProperties(/*[in]*/DISPID id,
                                    /*[in]*/DWORD grfdexFetch,
                                    /*[out]*/DWORD *pgrfdex)
{
   return SetErrorInfo(E_NOTIMPL);
} // GetMemberProperties

//*****************************************************************************

STDMETHODIMP CEffectBvr::GetMemberName(/*[in]*/DISPID id,
                              /*[out]*/BSTR *pbstrName)
{
   return E_NOTIMPL;
} // GetMemberName

//*****************************************************************************

STDMETHODIMP CEffectBvr::GetNextDispID(/*[in]*/DWORD grfdex,
                                /*[in]*/DISPID id,
                                /*[out]*/DISPID *prgid)
{
   return E_NOTIMPL;
} // GetNextDispID

//*****************************************************************************

STDMETHODIMP 
CEffectBvr::GetNameSpaceParent(/*[out]*/IUnknown **ppunk)
{
   return SetErrorInfo(E_NOTIMPL);
} // GetNameSpaceParent

//*****************************************************************************

STDMETHODIMP 
CEffectBvr::GetClassID(CLSID* pclsid)
{
    return SUPER::GetClassID(pclsid);
} // GetClassID

//*****************************************************************************

STDMETHODIMP 
CEffectBvr::InitNew(void)
{
    return SUPER::InitNew();
} // InitNew

//*****************************************************************************

STDMETHODIMP 
CEffectBvr::Load(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog)
{
    HRESULT hr;
    hr = SUPER::Load(pPropBag, pErrorLog);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling load for effect");
        return hr;
    }
    // we now need to try and build the transform
    hr = BuildTransform();
    if (FAILED(hr))
    {
        DPF_ERR("Error buiding transform");
        return hr;
    }
    DASSERT(m_pTransform != NULL);
    // we will now try and QI the transform for a IPersistPropertyBag
    IPersistPropertyBag *pIPPB;
    hr = m_pTransform->QueryInterface(IID_TO_PPV(IPersistPropertyBag, &pIPPB));
    if (SUCCEEDED(hr) && pIPPB != NULL)
    {
        // try and get a IPropertyBag from the IPRopertyBag2
        IPropertyBag *pPB;
        hr = pPropBag->QueryInterface(IID_TO_PPV(IPropertyBag, &pPB));
        if (SUCCEEDED(hr) && pPB != NULL)
        {
            hr = pIPPB->Load(pPB, pErrorLog);
            ReleaseInterface(pPB);
        }
        ReleaseInterface(pIPPB);
    }
    return S_OK;
} // Load

//*****************************************************************************

STDMETHODIMP 
CEffectBvr::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    HRESULT hr;
    hr = SUPER::Save(pPropBag, fClearDirty, fSaveAllProperties);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling save on effect");
        return hr;
    }
    if (m_pTransform != NULL)
    {
        // we will now try and QI the transform for a IPersistPropertyBag
        IPersistPropertyBag *pIPPB;
        hr = m_pTransform->QueryInterface(IID_TO_PPV(IPersistPropertyBag, &pIPPB));
        if (SUCCEEDED(hr) && pIPPB != NULL)
        {
            // try and get a IPropertyBag from the IPRopertyBag2
            IPropertyBag *pPB;
            hr = pPropBag->QueryInterface(IID_TO_PPV(IPropertyBag, &pPB));
            if (SUCCEEDED(hr) && pPB != NULL)
            {
                hr = pIPPB->Save(pPB, fClearDirty, fSaveAllProperties);
                ReleaseInterface(pPB);
            }
            ReleaseInterface(pIPPB);
        }
    }
    return S_OK;
} // Save 

//*****************************************************************************

HRESULT 
CEffectBvr::GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
{
    return FindConnectionPoint(riid, ppICP);
} // GetConnectionPoint

//
// IServiceProvider interfaces
//
STDMETHODIMP
CEffectBvr::QueryService(REFGUID guidService,
						 REFIID riid,
						 void** ppv)
{
    if (InlineIsEqualGUID(guidService, SID_SHTMLWindow))
    {
        IHTMLWindow2 *pWnd;
        HRESULT     hr;
        hr = m_pHTMLDoc->get_parentWindow(&pWnd);

        if (SUCCEEDED(hr) && (pWnd != NULL))
        {
            hr = pWnd->QueryInterface(riid, ppv);
            ReleaseInterface(pWnd);
            if (SUCCEEDED(hr))
            {
                return S_OK;
            }
        }
    }

    // Just delegate to our service provider

    return m_pSp->QueryService(guidService,
                               riid,
                               ppv);
}

//*****************************************************************************

HRESULT 
CEffectBvr::GetTIMEProgressNumber(IDANumber **ppbvrRet)
{
    DASSERT(ppbvrRet != NULL);
    *ppbvrRet = NULL;
    HRESULT hr;

    IDANumber *pbvrProgress;
    hr = SUPER::GetTIMEProgressNumber(&pbvrProgress);
    if (FAILED(hr))
    {
        DPF_ERR("Error retireving progress value from TIME");
        return hr;
    }
    
    hr = CUtils::InsurePropertyVariantAsBSTR(&m_varDirection);
    if ( SUCCEEDED(hr) && (0 == wcsicmp(m_varDirection.bstrVal, L"backwards")) )
    {
        // pbvrProgress = 1 - pbvrProgress
        IDANumber *pbvrOne;
        
        hr = CDAUtils::GetDANumber(GetDAStatics(), 1.0f, &pbvrOne);
        if (FAILED(hr))
        {
            DPF_ERR("Error creating DANumber from 1.0f");
            ReleaseInterface(pbvrProgress);
            return hr;
        }

        IDANumber *pbvrTemp;
        hr = GetDAStatics()->Sub(pbvrOne, pbvrProgress, &pbvrTemp);
        ReleaseInterface(pbvrOne);
        ReleaseInterface(pbvrProgress);
        pbvrProgress = pbvrTemp;
        pbvrTemp = NULL;
        if (FAILED(hr))
        {
            DPF_ERR("Error creating 1-progress expression");
            return hr;
        }
    }
    *ppbvrRet = pbvrProgress;
    return S_OK;
} // GetTIMEProgressNumber

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\src\elementprop.cpp ===
//*****************************************************************************
//
// Microsoft LMRT
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:        elementevent.cpp
//
// Author:          KurtJ
//
// Created:         2/14/99
//
// Abstract:        Sinks IHTMLElement events.
//
// Modifications:
// 1/14/98 KurtJ Created this file
//
//*****************************************************************************

#include "headers.h"

#include "elementprop.h"

#define LOCALTIME_NAME L"localTime"

CElementPropertyMonitor::CElementPropertyMonitor():
    m_pLocalTimeListener( NULL ),
    m_dwElementPropertyConPtCookie( 0 ),
    m_pconptElement( NULL ),
    m_pelemElement( NULL ),
    m_refCount( 0 ),
	m_dispidLocalTime( -1 ),
	m_pdispElement( NULL )
{
}

//*****************************************************************************

CElementPropertyMonitor::~CElementPropertyMonitor()
{
    if( m_pelemElement != NULL )
        Detach();
}

//*****************************************************************************
//IUnknown
//*****************************************************************************

STDMETHODIMP
CElementPropertyMonitor::QueryInterface( REFIID riid, void** ppv)
{
    if( ppv == NULL )
        return E_POINTER;

    if( riid == IID_IPropertyNotifySink )
    {
        (*ppv) = static_cast<IPropertyNotifySink*>(this);
    }
	else if( riid == IID_IUnknown )
	{
		(*ppv) = static_cast<IUnknown*>(this);
	}
    else
    {
        (*ppv) = NULL;
        return E_NOINTERFACE;
    }

    static_cast<IUnknown*>(*ppv)->AddRef();

    return S_OK;
}

//*****************************************************************************

STDMETHODIMP_(ULONG)
CElementPropertyMonitor::AddRef()
{
    m_refCount++;
    return m_refCount;
}

//*****************************************************************************

STDMETHODIMP_(ULONG)
CElementPropertyMonitor::Release()
{
    ULONG refs = --m_refCount;

    if( refs == 0 )
        delete this;

    return refs;
}

//*****************************************************************************
//IPropertyNotifySink
//*****************************************************************************


STDMETHODIMP
CElementPropertyMonitor::OnChanged( DISPID dispid )
{
	//check to see if one of the properties we are watching has changed
	if( dispid == m_dispidLocalTime && m_pLocalTimeListener != NULL)
	{
		ProcessLocalTimeChange();
	}

	return S_OK;
}

//*****************************************************************************

STDMETHODIMP
CElementPropertyMonitor::OnRequestEdit( DISPID dispid )
{
	return S_OK;
}


//*****************************************************************************
//IElementEventMonitor
//*****************************************************************************

STDMETHODIMP
CElementPropertyMonitor::SetLocalTimeListener( IElementLocalTimeListener *pListener )
{
    m_pLocalTimeListener = pListener;

    return S_OK;
}

//*****************************************************************************

STDMETHODIMP
CElementPropertyMonitor::Attach( IHTMLElement* pelemToListen )
{
    if( pelemToListen == NULL )
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    if( m_pelemElement != NULL )
    {
        DetachFromElementConPt();
        ReleaseInterface( m_pelemElement );
		ReleaseInterface( m_pdispElement );
    }
    
    //hold on to the element
    m_pelemElement = pelemToListen;
    m_pelemElement->AddRef();

	//get IDispatch off of the element to which we are attaching
	hr = m_pelemElement->QueryInterface( IID_TO_PPV( IDispatch, &m_pdispElement ) );
	CheckHR( hr, "QI for IDispatch on element failed", end );

    //attach to the element
    hr = AttachToElementConPt( );
    CheckHR( hr, "Failed to connect to the element connection point", end );

	UpdateDISPIDCache();

end:
    if( FAILED( hr ) )
    {
        ReleaseInterface( m_pelemElement );
		ReleaseInterface( m_pdispElement );
    }

    return hr;
}

//*****************************************************************************

STDMETHODIMP
CElementPropertyMonitor::Detach()
{
    HRESULT hr = S_OK;
    if( m_pelemElement != NULL )
    {
        hr = DetachFromElementConPt();
    }

	m_dispidLocalTime = -1;

    ReleaseInterface( m_pelemElement );
	ReleaseInterface( m_pdispElement );

    return hr;
}

//*****************************************************************************

STDMETHODIMP
CElementPropertyMonitor::UpdateDISPIDCache()
{
	if( m_pdispElement == NULL )
	{
		m_dispidLocalTime = -1;
		return S_OK;
	}

	LPOLESTR name = LOCALTIME_N