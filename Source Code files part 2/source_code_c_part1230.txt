   {
                    GO_BOARD(pmdev, pmb);
                    b &= DrvBitBlt(psoDst, pmb->pso, psoMask, pco, pxlo, &rclDst,
                                   pptlSrc, pptlMask, pbo, pptlBrush, rop4);
                }

            } while (bNextBoard(&rclBounds, &pmb));

            // Restore the original clip bounds:

            pco->rclBounds = rclOriginalBounds;
        }
    }

    GO_HOME(pmdev);

    return(b);
}

/******************************Public*Routine******************************\
* MulDisablePDEV
*
* Note: May be called before MulEnablePDEV successfully completed!
*
\**************************************************************************/

VOID MulDisablePDEV(DHPDEV dhpdev)
{
    MULTI_BOARD* pmb;
    MDEV*        pmdev;

    pmdev = (MDEV*) dhpdev;

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        if (pmb->ppdev != NULL)
        {
            GO_BOARD(pmdev, pmb);
            DrvDisablePDEV((DHPDEV) pmb->ppdev);
        }
    }

    GO_HOME(pmdev);

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        EngFreeMem(pmb);         // Undo 'bVeryTemporaryInitializationCode'
    }                           //   allocation

    EngFreeMem(pmdev);

}

/******************************Public*Routine******************************\
* MulDisableSurface
*
* Note: May be called before MulEnableSurface successfully completed!
*
\**************************************************************************/

VOID MulDisableSurface(DHPDEV dhpdev)
{
    MULTI_BOARD* pmb;
    MDEV*        pmdev;

    pmdev = (MDEV*) dhpdev;

    if (pmdev->pco != NULL)
        EngDeleteClip(pmdev->pco);

    EngDeleteSurface(pmdev->hsurf);

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        GO_BOARD(pmdev, pmb);

        EngUnlockSurface(pmb->pso);

        DrvDisableSurface((DHPDEV) pmb->ppdev);
    }

    GO_HOME(pmdev);
}

/******************************Public*Routine******************************\
* MulAssertMode
*
\**************************************************************************/

BOOL MulAssertMode(
DHPDEV dhpdev,
BOOL   bEnable)
{
    MDEV*         pmdev;
    MULTI_BOARD*  pmb;

    pmdev = (MDEV*) dhpdev;

    if (!bEnable)
    {
        // When switching to full-screen mode, PatBlt blackness over
        // all the inactive screens (otherwise it looks goofy when
        // the desktop is frozen on the inactive screens and the user
        // can't do anything with it):

        for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
        {
            if (pmb != pmdev->pmbHome)
            {
                GO_BOARD(pmdev, pmb);
                DrvBitBlt(pmb->pso, NULL, NULL, NULL, NULL, &pmb->rcl, NULL,
                          NULL, NULL, NULL, 0);
            }
        }
    }

    // We use the 'home' board for full-screen switching:

    GO_BOARD(pmdev, pmdev->pmbHome);
    DrvAssertMode((DHPDEV) pmdev->pmbHome->ppdev, bEnable);

    return TRUE;
}

/******************************Public*Routine******************************\
* MulMovePointer
*
\**************************************************************************/

VOID MulMovePointer(
SURFOBJ* pso,
LONG     x,
LONG     y,
RECTL*   prcl)
{
    MDEV*        pmdev;
    MULTI_BOARD* pmbPointer;
    RECTL        rclPointer;

    pmdev     = (MDEV*) pso->dhpdev;
    pmbPointer = pmdev->pmbPointer;

    if (pmbPointer != NULL)
    {
        // The most common case is when the pointer is moved to a spot
        // on the same board:

        if ((x >= pmbPointer->rcl.left)  &&
            (x <  pmbPointer->rcl.right) &&
            (y >= pmbPointer->rcl.top)   &&
            (y <  pmbPointer->rcl.bottom))
        {
            GO_BOARD(pmdev, pmbPointer);
            DrvMovePointer(pmbPointer->pso, x, y, prcl);
            GO_HOME(pmdev);

            return;
        }

        // Tell the old board to erase its cursor:

        GO_BOARD(pmdev, pmbPointer);
        DrvMovePointer(pmbPointer->pso, -1, -1, NULL);
    }

    if (x == -1)
    {
        pmdev->pmbPointer = NULL;
        GO_HOME(pmdev);

        return;
    }

    // Find the new board and tell it to draw its new cursor:

    rclPointer.left   = x;
    rclPointer.right  = x;
    rclPointer.top    = y;
    rclPointer.bottom = y;

    bFindBoard(pmdev, &rclPointer, &pmbPointer);

    GO_BOARD(pmdev, pmbPointer);
    DrvMovePointer(pmbPointer->pso, x, y, prcl);

    pmdev->pmbPointer = pmbPointer;

    GO_HOME(pmdev);
}

/******************************Public*Routine******************************\
* MulSetPointerShape
*
\**************************************************************************/

ULONG MulSetPointerShape(
SURFOBJ*  pso,
SURFOBJ*  psoMask,
SURFOBJ*  psoColor,
XLATEOBJ* pxlo,
LONG      xHot,
LONG      yHot,
LONG      x,
LONG      y,
RECTL*    prcl,
FLONG     fl)
{
    MULTI_BOARD* pmb;
    MDEV*        pmdev;
    ULONG        ulRetPrevious = (ULONG) -1;
    ULONG        ulRet;
    RECTL        rclPointer;
    MULTI_BOARD* pmbPointer;             // Board on which cursor is visible

    pmdev = (MDEV*) pso->dhpdev;

    // Find out which board that the cursor is visible on, if any:

    pmbPointer = NULL;
    if (x != 1)
    {
        rclPointer.left   = x;
        rclPointer.right  = x;
        rclPointer.top    = y;
        rclPointer.bottom = y;

        bFindBoard(pmdev, &rclPointer, &pmbPointer);
    }
    pmdev->pmbPointer = pmbPointer;

    // LATER: Fix the case for when some boards may fail the call, and others
    //        won't.

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        // We notify all boards of the new cursor shape, but only the board
        // on which the cursor is visible is told to draw it:

        GO_BOARD(pmdev, pmb);

        if (pmb == pmbPointer)
        {
            ulRet = DrvSetPointerShape(pmb->pso, psoMask, psoColor, pxlo,
                                       xHot, yHot, x, y, prcl, fl);
        }
        else
        {
            ulRet = DrvSetPointerShape(pmb->pso, psoMask, psoColor, pxlo,
                                       xHot, yHot, -1, y, NULL, fl);
        }

        if ((ulRetPrevious != (ULONG) -1) && (ulRetPrevious != ulRet))
        {
            RIP("MulSetPointerShape not all DrvSetPointerShapes same\n");
        }

        ulRetPrevious = ulRet;
    }

    GO_HOME(pmdev);

    return(ulRetPrevious);
}

/******************************Public*Routine******************************\
* MulDitherColor
*
\**************************************************************************/

ULONG MulDitherColor(
DHPDEV dhpdev,
ULONG  iMode,
ULONG  rgb,
ULONG* pul)
{
    PDEV* ppdev;
    ULONG ulRet;

    // Let the first board's driver do the dithering:

    ppdev = ((MDEV*) dhpdev)->pmb->ppdev;
    ulRet = DrvDitherColor((DHPDEV) ppdev, iMode, rgb, pul);

    return(ulRet);
}

/******************************Public*Routine******************************\
* MulSetPalette
*
\**************************************************************************/

BOOL MulSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    MULTI_BOARD* pmb;
    MDEV*        pmdev;
    BOOL         bRet = TRUE;

    // Notify all boards of the palette change:

    pmdev = (MDEV*) dhpdev;
    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        GO_BOARD(pmdev, pmb);
        bRet &= DrvSetPalette((DHPDEV) pmb->ppdev, ppalo, fl, iStart, cColors);
    }

    GO_HOME(pmdev);

    return(bRet);
}

/******************************Public*Routine******************************\
* MulCopyBits
*
\**************************************************************************/

BOOL MulCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    BOOL         bFromScreen;
    BOOL         bToScreen;
    MDEV*        pmdev;
    MULTI_BOARD* pmb;
    RECTL        rclOriginalBounds;
    BOOL         b;
    RECTL        rclBounds;
    RECTL        rclDst;

    bFromScreen = ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE));
    bToScreen   = ((psoDst != NULL) && (psoDst->iType == STYPE_DEVICE));

    // We copy the prclDst rectangle here because sometimes GDI will
    // simply point prclDst to the same rectangle in pco->rclBounds,
    // and we'll be mucking with pco->rclBounds...

    rclDst = *prclDst;

    if (bToScreen && bFromScreen)
    {
        ///////////////////////////////////////////////////////////////
        // Screen-to-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoDst->dhpdev;

        // rclBounds is the union of the source and destination rectangles:

        rclBounds.left   = min(rclDst.left, pptlSrc->x);
        rclBounds.top    = min(rclDst.top,  pptlSrc->y);
        rclBounds.right  = max(rclDst.right,
                               pptlSrc->x + (rclDst.right - rclDst.left));
        rclBounds.bottom = max(rclDst.bottom,
                               pptlSrc->y + (rclDst.bottom - rclDst.top));

        if (bFindBoard(pmdev, &rclBounds, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvCopyBits(pmb->pso, pmb->pso, pco, pxlo, &rclDst, pptlSrc);
        }
        else
        {
            return(bBitBltBetweenBoards(psoDst, psoSrc, NULL, pco, pxlo,
                                        &rclDst, pptlSrc, NULL, NULL,
                                        NULL, 0x0000cccc, &rclBounds, pmb));
        }
    }
    else if (bToScreen)
    {
        ///////////////////////////////////////////////////////////////
        // To-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoDst->dhpdev;
        if (bFindBoard(pmdev, &rclDst, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvCopyBits(pmb->pso, psoSrc, pco, pxlo, &rclDst, pptlSrc);
        }
        else
        {
            if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
            {
                // If the CLIPOBJ doesn't have at least DC_RECT complexity,
                // substitute one that does:

                pco = pmdev->pco;
            }

            rclOriginalBounds = pco->rclBounds;

            b = TRUE;
            do {
                if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
                {
                    GO_BOARD(pmdev, pmb);
                    b &= DrvCopyBits(pmb->pso, psoSrc, pco, pxlo, &rclDst,
                                     pptlSrc);
                }

            } while (bNextBoard(&rclDst, &pmb));

            // Restore the original clip bounds:

            pco->rclBounds = rclOriginalBounds;
        }
    }
    else
    {
        ///////////////////////////////////////////////////////////////
        // From-screen
        ///////////////////////////////////////////////////////////////

        // This rarely happens, so save some code space:

        return(MulBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst,
                              pptlSrc, NULL, NULL, NULL, 0x0000cccc));
    }

    GO_HOME(pmdev);

    return(b);
}

/******************************Public*Routine******************************\
* MulTextOut
*
\**************************************************************************/

BOOL MulTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlOrg,
MIX       mix)
{
    MDEV*          pmdev;
    MULTI_BOARD*   pmb;
    RECTL          rclOriginalBounds;
    BYTE           fjOriginalOptions;
    BOOL           b;
    RECTL*         prclBounds;
    FONT_CONSUMER* pfcArray;

    pmdev = (MDEV*) pso->dhpdev;

    // In keeping with our philosophy for multiple board support, we handle
    // multiple consumers of the same font at this level.  We do this by
    // monitoring pfo->pvConsumer, and the first time a board sets the
    // field, we take control of pfo->pvConsumer.  We use it to allocate
    // a pvConsumer array where we can keep track of every board's
    // individual pvConsumer.

    pfcArray = pfo->pvConsumer;

    prclBounds = (prclOpaque != NULL) ? prclOpaque : &pstro->rclBkGround;

    bFindBoard(pmdev, prclBounds, &pmb);

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        // If the CLIPOBJ doesn't have at least DC_RECT complexity,
        // substitute one that does:

        pco = pmdev->pco;
    }

    rclOriginalBounds = pco->rclBounds;
    fjOriginalOptions = pco->fjOptions;

    // OR in the OC_BANK_CLIP flag to let GDI know that we may be calling
    // EngTextOut multiple times with the same parameters (EngTextOut
    // is destructive in that it modifies that parameters passed to it,
    // unless this bit is set):

    pco->fjOptions |= OC_BANK_CLIP;

    b = TRUE;
    do {
        if (pfcArray != NULL)
            pfo->pvConsumer = pfcArray->apvc[pmb->iBoard].pvConsumer;

        // Make sure we restart the glyph enumeration if need be:

        STROBJ_vEnumStart(pstro);
        if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
        {
            GO_BOARD(pmdev, pmb);
            b &= DrvTextOut(pmb->pso, pstro, pfo, pco, prclExtra, prclOpaque,
                            pboFore, pboOpaque, pptlOrg, mix);
        }

        if (pfcArray != NULL)
        {
            // Copy the pvConsumer, in case the last DrvTextOut changed
            // it:

            pfcArray->apvc[pmb->iBoard].pvConsumer = pfo->pvConsumer;
        }
        else
        {
            if (pfo->pvConsumer != NULL)
            {
                // The board allocated a new consumer, so create our array
                // to keep track of consumers for every board:

                pfcArray = (FONT_CONSUMER*) EngAllocMem(FL_ZERO_MEMORY,
                             sizeof(FONT_CONSUMER), ALLOC_TAG);
                if (pfcArray == NULL)
                    DrvDestroyFont(pfo);
                else
                {
                    pfcArray->cConsumers = pmdev->cBoards;
                    pfcArray->apvc[pmb->iBoard].pvConsumer = pfo->pvConsumer;

                }
            }
        }
    } while (bNextBoard(prclBounds, &pmb));

    // Restore the original clip bounds:

    pco->rclBounds = rclOriginalBounds;
    pco->fjOptions = fjOriginalOptions;

    // Make sure we restore/set the font's pvConsumer:

    pfo->pvConsumer = pfcArray;

    GO_HOME(pmdev);

    return(b);
}

/******************************Public*Routine******************************\
* MulDestroyFont
*
\**************************************************************************/

VOID MulDestroyFont(FONTOBJ *pfo)
{
    FONT_CONSUMER* pfcArray;
    LONG           i;
    PVOID          pvConsumer;

    if (pfo->pvConsumer != NULL)
    {
        pfcArray = pfo->pvConsumer;
        for (i = 0; i < pfcArray->cConsumers; i++)
        {
            pvConsumer = pfcArray->apvc[i].pvConsumer;
            if (pvConsumer != NULL)
            {
                pfo->pvConsumer = pvConsumer;
                DrvDestroyFont(pfo);
            }
        }

        EngFreeMem(pfcArray);
        pfo->pvConsumer = NULL;
    }

}

/******************************Public*Routine******************************\
* MulPaint
*
\**************************************************************************/

BOOL MulPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
MIX       mix)
{
    MDEV*        pmdev;
    RECTL        rclOriginalBounds;
    MULTI_BOARD* pmb;
    BOOL         b;

    pmdev = (MDEV*) pso->dhpdev;
    if (bFindBoard(pmdev, &pco->rclBounds, &pmb))
    {
        GO_BOARD(pmdev, pmb);
        b = DrvPaint(pmb->pso, pco, pbo, pptlBrush, mix);
    }
    else
    {
        rclOriginalBounds = pco->rclBounds;

        b = TRUE;
        do {
            if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
            {
                GO_BOARD(pmdev, pmb);
                b &= DrvPaint(pmb->pso, pco, pbo, pptlBrush, mix);
            }

        } while (bNextBoard(&rclOriginalBounds, &pmb));

        // Restore the original clip bounds:

        pco->rclBounds = rclOriginalBounds;
    }

    GO_HOME(pmdev);

    return(b);
}

/******************************Public*Routine******************************\
* MulRealizeBrush
*
\**************************************************************************/

BOOL MulRealizeBrush(
BRUSHOBJ* pbo,
SURFOBJ*  psoTarget,
SURFOBJ*  psoPattern,
SURFOBJ*  psoMask,
XLATEOBJ* pxlo,
ULONG     iHatch)
{
    MDEV*        pmdev;
    BOOL         b;

    pmdev = (MDEV*) psoTarget->dhpdev;

    // DrvRealizeBrush is only ever calling from within a Drv function.
    // 'psoTarget' points to our multi-board surface, but we have to point
    // it to the surface of the board for which the DrvBitBlt call was made.

    // NOTE: If SLOWFILL_PATTERNS are enabled, we will have to do a
    //       GO_BOARD here, because our DrvRealizeBrush routine actually
    //       draws for that case.

    b = DrvRealizeBrush(pbo, pmdev->pmbCurrent->pso, psoPattern, psoMask,
                        pxlo, iHatch);

    return(b);
}

#endif // MULTI_BOARDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\disp\precomp.h ===
/******************************Module*Header*******************************\
* Module Name: precomp.h
*
* Common headers used throughout the display driver.  This entire include
* file will typically be pre-compiled.
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <windef.h>
#include <wingdi.h>
#include <winddi.h>
#include <devioctl.h>
#include <ntddvdeo.h>
#include <ioaccess.h>
#include <math.h>

#include "lines.h"
#include "driver.h"
#include "hw.h"
#include "debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\disp\palette.c ===
/******************************Module*Header*******************************\
* Module Name: palette.c
*
* Palette support.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

// Global Table defining the 20 Window default colours.  For 256 colour
// palettes the first 10 must be put at the beginning of the palette
// and the last 10 at the end of the palette.

PALETTEENTRY gapalBase[20] =
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },       // 6
    { 0xC0,0xC0,0xC0,0 },       // 7
    { 192, 220, 192, 0 },       // 8
    { 166, 202, 240, 0 },       // 9
    { 255, 251, 240, 0 },       // 10
    { 160, 160, 164, 0 },       // 11
    { 0x80,0x80,0x80,0 },       // 12
    { 0xFF,0,   0   ,0 },       // 13
    { 0,   0xFF,0   ,0 },       // 14
    { 0xFF,0xFF,0   ,0 },       // 15
    { 0   ,0,   0xFF,0 },       // 16
    { 0xFF,0,   0xFF,0 },       // 17
    { 0,   0xFF,0xFF,0 },       // 18
    { 0xFF,0xFF,0xFF,0 },       // 19
};

/******************************Public*Routine******************************\
* BOOL bInitializePalette
*
* Initializes default palette for PDEV.
*
\**************************************************************************/

BOOL bInitializePalette(
PDEV*    ppdev,
DEVINFO* pdi)
{
    PALETTEENTRY*   ppal;
    PALETTEENTRY*   ppalTmp;
    ULONG           ulLoop;
    BYTE            jRed;
    BYTE            jGre;
    BYTE            jBlu;
    HPALETTE        hpal;

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        // Allocate our palette:

        ppal = (PALETTEENTRY*)EngAllocMem(FL_ZERO_MEMORY,
                        (sizeof(PALETTEENTRY) * 256), ALLOC_TAG);
        if (ppal == NULL)
            goto ReturnFalse;

        ppdev->pPal = ppal;

        // Generate 256 (8*4*4) RGB combinations to fill the palette

        jRed = 0;
        jGre = 0;
        jBlu = 0;

        ppalTmp = ppal;

        for (ulLoop = 256; ulLoop != 0; ulLoop--)
        {
            ppalTmp->peRed   = jRed;
            ppalTmp->peGreen = jGre;
            ppalTmp->peBlue  = jBlu;
            ppalTmp->peFlags = 0;

            ppalTmp++;

            if (!(jRed += 32))
                if (!(jGre += 32))
                    jBlu += 64;
        }

        // Fill in Windows reserved colours from the WIN 3.0 DDK
        // The Window Manager reserved the first and last 10 colours for
        // painting windows borders and for non-palette managed applications.

        for (ulLoop = 0; ulLoop < 10; ulLoop++)
        {
            // First 10

            ppal[ulLoop]       = gapalBase[ulLoop];

            // Last 10

            ppal[246 + ulLoop] = gapalBase[ulLoop+10];
        }

        // Create handle for palette.

        hpal = EngCreatePalette(PAL_INDEXED, 256, (ULONG*) ppal, 0, 0, 0);
    }
    else
    {
        ASSERTDD((ppdev->iBitmapFormat == BMF_16BPP) ||
                 (ppdev->iBitmapFormat == BMF_32BPP),
                 "This case handles only 16 or 32bpp");

        hpal = EngCreatePalette(PAL_BITFIELDS, 0, NULL,
                                ppdev->flRed, ppdev->flGreen, ppdev->flBlue);
    }

    ppdev->hpalDefault = hpal;
    pdi->hpalDefault   = hpal;

    if (hpal == 0)
        goto ReturnFalse;

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bInitializePalette"));
    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vUninitializePalette
*
* Frees resources allocated by bInitializePalette.
*
* Note: In an error case, this may be called before bInitializePalette.
*
\**************************************************************************/

VOID vUninitializePalette(PDEV* ppdev)
{
    // Delete the default palette if we created one:

    if (ppdev->hpalDefault != 0)
        EngDeletePalette(ppdev->hpalDefault);

    if (ppdev->pPal != (PALETTEENTRY*) NULL)
        EngFreeMem(ppdev->pPal);
}

/******************************Public*Routine******************************\
* BOOL bEnablePalette
*
* Initialize the hardware's 8bpp palette registers.
*
\**************************************************************************/

BOOL bEnablePalette(PDEV* ppdev)
{
    BYTE        ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT pScreenClut;
    ULONG       ulReturnedDataLength;
    ULONG       cColors;
    PVIDEO_CLUTDATA pScreenClutData;

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        // Fill in pScreenClut header info:

        pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
        pScreenClut->NumEntries = 256;
        pScreenClut->FirstEntry = 0;

        // Copy colours in:

        cColors = 256;
        pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

        while(cColors--)
        {
            pScreenClutData[cColors].Red =    ppdev->pPal[cColors].peRed >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Green =  ppdev->pPal[cColors].peGreen >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Blue =   ppdev->pPal[cColors].peBlue >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Unused = 0;
        }

        // Set palette registers:

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_SET_COLOR_REGISTERS,
                             pScreenClut,
                             MAX_CLUT_SIZE,
                             NULL,
                             0,
                             &ulReturnedDataLength))
        {
            DISPDBG((0, "Failed bEnablePalette"));
            return(FALSE);
        }
    }

    DISPDBG((5, "Passed bEnablePalette"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisablePalette
*
* Undoes anything done in bEnablePalette.
*
\**************************************************************************/

VOID vDisablePalette(
PDEV*   ppdev)
{
    // Nothin' to do
}

/******************************Public*Routine******************************\
* VOID vAssertModePalette
*
* Sets/resets the palette in preparation for full-screen/graphics mode.
*
\**************************************************************************/

VOID vAssertModePalette(
PDEV*   ppdev,
BOOL    bEnable)
{
    // USER immediately calls DrvSetPalette after switching out of
    // full-screen, so we don't have to worry about resetting the
    // palette here.
}

/******************************Public*Routine******************************\
* BOOL DrvSetPalette
*
* DDI entry point for manipulating the palette.
*
\**************************************************************************/

BOOL DrvSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BYTE            ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT     pScreenClut;
    PVIDEO_CLUTDATA pScreenClutData;
    PDEV*           ppdev;

    UNREFERENCED_PARAMETER(fl);

    ppdev = (PDEV*) dhpdev;

    // Fill in pScreenClut header info:

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = (USHORT) cColors;
    pScreenClut->FirstEntry = (USHORT) iStart;

    pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

    if (cColors != PALOBJ_cGetColors(ppalo, iStart, cColors,
                                     (ULONG*) pScreenClutData))
    {
        DISPDBG((0, "DrvSetPalette failed PALOBJ_cGetColors\n"));
        return (FALSE);
    }

    // Set the high reserved byte in each palette entry to 0.
    // Do the appropriate palette shifting to fit in the DAC.

    if (ppdev->cPaletteShift)
    {
        while(cColors--)
        {
            pScreenClutData[cColors].Red >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Green >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Blue >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Unused = 0;
        }
    }
    else
    {
        while(cColors--)
        {
            pScreenClutData[cColors].Unused = 0;
        }
    }

    // Set palette registers

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_SET_COLOR_REGISTERS,
                         pScreenClut,
                         MAX_CLUT_SIZE,
                         NULL,
                         0,
                         &cColors))
    {
        DISPDBG((0, "DrvSetPalette failed EngDeviceIoControl\n"));
        return (FALSE);
    }

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\disp\pointer.c ===
/******************************Module*Header*******************************\
* Module Name: pointer.c
*
* This module contains the hardware pointer support for the display
* driver.
*
* Copyright (c) 1994-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

// This should match the miniport definition:

#define VIDEO_MODE_LOCAL_POINTER    0x08

// Look-up table for masking the right edge of the given pointer bitmap:

BYTE gajMask[] = { 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFc, 0xFE };

/******************************Public*Routine******************************\
* VOID DrvMovePointer
*
* NOTE: Because we have set GCAPS_ASYNCMOVE, this call may occur at any
*       time, even while we're executing another drawing call!
*
*       Consequently, we have to explicitly synchronize any shared
*       resources.  In our case, since we touch the CRTC register here
*       and in the banking code, we synchronize access using a critical
*       section.
*
\**************************************************************************/

VOID DrvMovePointer(
SURFOBJ*    pso,
LONG        x,
LONG        y,
RECTL*      prcl)
{
    VIDEO_POINTER_POSITION Position;
    PDEV*   ppdev;
    DWORD   returnedDataLength;

    ppdev = (PDEV*) pso->dhpdev;

    #if MULTI_BOARDS
    {
        if (x != -1)
        {
            OH* poh;

            poh = ((DSURF*) pso->dhsurf)->poh;
            x += poh->x;
            y += poh->y;
        }
    }
    #endif

    if (x == -1)
    {
        ppdev->bPointerEnabled = FALSE;
        EngDeviceIoControl(ppdev->hDriver,
                        IOCTL_VIDEO_DISABLE_POINTER,
                        NULL,
                        0,
                        NULL,
                        0,
                        &returnedDataLength);
    }
    else
    {
        Position.Column = (short) (x - ppdev->ptlHotSpot.x);
        Position.Row    = (short) (y - ppdev->ptlHotSpot.y);

        if (ppdev->PointerCapabilities.Flags & VIDEO_MODE_LOCAL_POINTER)
        {
            // This is rather dumb:

            IO_CURSOR_X(ppdev, ppdev->pjIoBase, Position.Column + CURSOR_CX);
            IO_CURSOR_Y(ppdev, ppdev->pjIoBase, Position.Row + CURSOR_CY);
        }
        else
        {
            EngDeviceIoControl(ppdev->hDriver,
                            IOCTL_VIDEO_SET_POINTER_POSITION,
                            &Position,
                            sizeof(VIDEO_POINTER_POSITION),
                            NULL,
                            0,
                            &returnedDataLength);
        }

        // Don't forget to turn on the pointer, if it was off:

        if (!ppdev->bPointerEnabled)
        {
            ppdev->bPointerEnabled = TRUE;
            EngDeviceIoControl(ppdev->hDriver,
                            IOCTL_VIDEO_ENABLE_POINTER,
                            NULL,
                            0,
                            NULL,
                            0,
                            &returnedDataLength);
        }
    }
}

/******************************Public*Routine******************************\
* VOID DrvSetPointerShape
*
* Sets the new pointer shape.
*
\**************************************************************************/

ULONG DrvSetPointerShape(
SURFOBJ*    pso,
SURFOBJ*    psoMsk,
SURFOBJ*    psoColor,
XLATEOBJ*   pxlo,
LONG        xHot,
LONG        yHot,
LONG        x,
LONG        y,
RECTL*      prcl,
FLONG       fl)
{
    VIDEO_POINTER_ATTRIBUTES* pPointerAttributes;
    PDEV*   ppdev;
    ULONG   cx;
    ULONG   cy;
    LONG    cjWhole;
    LONG    cjDst;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    LONG    lSrcDelta;
    LONG    lDstDelta;
    LONG    i;
    DWORD   returnedDataLength;

    ppdev              = (PDEV*) pso->dhpdev;
    pPointerAttributes = ppdev->pPointerAttributes;

    if (pPointerAttributes == NULL)
    {
        // There are no hardware pointer capabilities:

        return(SPS_DECLINE);
    }

    cx = psoMsk->sizlBitmap.cx;
    cy = psoMsk->sizlBitmap.cy / 2;

    if ((cx > ppdev->PointerCapabilities.MaxWidth)  ||
        (cy > ppdev->PointerCapabilities.MaxHeight) ||
        (psoColor != NULL)                          ||
        !(fl & SPS_CHANGE)                          ||
        (cx & 0x7))
    {
        goto HideAndDecline;
    }

    #if MULTI_BOARDS
    {
        if (x != -1)
        {
            OH* poh;

            poh = ((DSURF*) pso->dhsurf)->poh;
            x += poh->x;
            y += poh->y;
        }
    }
    #endif

    cjWhole   = cx / 8;

    cjDst     = pPointerAttributes->WidthInBytes * pPointerAttributes->Height;

    // Copy AND bits:

    pjSrc     = psoMsk->pvScan0;
    lSrcDelta = psoMsk->lDelta;
    pjDst     = pPointerAttributes->Pixels;
    lDstDelta = pPointerAttributes->WidthInBytes;

    memset(pjDst, -1, cjDst);               // Pad unused AND bits

    for (i = cy; i != 0; i--)
    {
        memcpy(pjDst, pjSrc, cjWhole);

        pjSrc += lSrcDelta;
        pjDst += lDstDelta;
    }

    // Copy XOR bits:

    pjDst = pPointerAttributes->Pixels + ppdev->cjXorMaskStartOffset;

    memset(pjDst, 0, cjDst);                // Pad unused XOR bits

    for (i = cy; i != 0; i--)
    {
        memcpy(pjDst, pjSrc, cjWhole);

        pjSrc += lSrcDelta;
        pjDst += lDstDelta;
    }

    // Initialize the pointer attributes:

    ppdev->ptlHotSpot.x = xHot;
    ppdev->ptlHotSpot.y = yHot;

    pPointerAttributes->Column = (short) (x - xHot);
    pPointerAttributes->Row    = (short) (y - yHot);
    pPointerAttributes->Enable = (x != -1);
    pPointerAttributes->Flags  = VIDEO_MODE_MONO_POINTER;

    if (fl & SPS_ANIMATESTART)
        pPointerAttributes->Flags |= VIDEO_MODE_ANIMATE_START;
    else if (fl & SPS_ANIMATEUPDATE)
        pPointerAttributes->Flags |= VIDEO_MODE_ANIMATE_UPDATE;

    if (ppdev->PointerCapabilities.Flags & VIDEO_MODE_LOCAL_POINTER)
    {
        // This is rather dumb:

        IO_CURSOR_X(ppdev, ppdev->pjIoBase, pPointerAttributes->Column + CURSOR_CX);
        IO_CURSOR_Y(ppdev, ppdev->pjIoBase, pPointerAttributes->Row + CURSOR_CY);
    }

    // Send the bits to the miniport:

    ppdev->bPointerEnabled = pPointerAttributes->Enable;
    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_SET_POINTER_ATTR,
                         ppdev->pPointerAttributes,
                         ppdev->cjPointerAttributes,
                         NULL,
                         0,
                         &returnedDataLength))
    {
        goto HideAndDecline;
    }

    return(SPS_ACCEPT_NOEXCLUDE);

HideAndDecline:

    DrvMovePointer(pso, -1, -1, NULL);

    return(SPS_DECLINE);
}

/******************************Public*Routine******************************\
* VOID vDisablePointer
*
\**************************************************************************/

VOID vDisablePointer(
PDEV*   ppdev)
{
    // Nothing to do, really
}

/******************************Public*Routine******************************\
* VOID vAssertModePointer
*
\**************************************************************************/

VOID vAssertModePointer(
PDEV*   ppdev,
BOOL    bEnable)
{
    // Nothing to do, really
}

/******************************Public*Routine******************************\
* BOOL bEnablePointer
*
\**************************************************************************/

BOOL bEnablePointer(
PDEV*   ppdev)
{
    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bInitializePointer
*
* Initialize pointer during driver PDEV initialization -- early enough
* so that we can affect what 'flGraphicsCaps' are passed back to GDI,
* so that we can set GCAPS_ASYNCMOVE appropriately.
*
\**************************************************************************/

BOOL bInitializePointer(
PDEV*   ppdev)
{
    VIDEO_POINTER_ATTRIBUTES*   pPointerAttributes;
    LONG    cjWidth;
    LONG    cjMaxPointer;
    DWORD   returnedDataLength;

    if (!EngDeviceIoControl(ppdev->hDriver,
                        IOCTL_VIDEO_QUERY_POINTER_CAPABILITIES,
                        NULL,
                        0,
                        &ppdev->PointerCapabilities,
                        sizeof(ppdev->PointerCapabilities),
                        &returnedDataLength))
    {
        if (ppdev->PointerCapabilities.Flags & VIDEO_MODE_MONO_POINTER)
        {
            cjWidth = (ppdev->PointerCapabilities.MaxWidth + 7) / 8;
            cjMaxPointer = 2 * cjWidth * ppdev->PointerCapabilities.MaxHeight;

            ppdev->cjXorMaskStartOffset = cjMaxPointer / 2;
            ppdev->cjPointerAttributes  = sizeof(VIDEO_POINTER_ATTRIBUTES)
                                        + cjMaxPointer;

            pPointerAttributes = (VIDEO_POINTER_ATTRIBUTES*)
                EngAllocMem(0, ppdev->cjPointerAttributes, ALLOC_TAG);

            if (pPointerAttributes != NULL)
            {
                ppdev->pPointerAttributes = pPointerAttributes;

                pPointerAttributes->WidthInBytes
                    = cjWidth;

                pPointerAttributes->Width
                    = ppdev->PointerCapabilities.MaxWidth;

                pPointerAttributes->Height
                    = ppdev->PointerCapabilities.MaxHeight;
            }
        }
    }

    // We were successful even if the miniport doesn't support a
    // hardware pointer:

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vUnitializePointer
*
* Undoes bInitializePointer.
*
\**************************************************************************/

VOID vUninitializePointer(
PDEV*   ppdev)
{
    EngFreeMem(ppdev->pPointerAttributes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\disp\thunk.c ===
/******************************Module*Header*******************************\
* Module Name: thunk.c
*
* This module exists solely for testing, to make it is easy to instrument
* all the driver's Drv calls.
*
* Note that most of this stuff will only be compiled in a checked (debug)
* build.
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

////////////////////////////////////////////////////////////////////////////

#if DBG

// This entire module is only enabled for Checked builds, or when we
// have to explicitly synchronize bitmap access ourselves.

    #define SYNCH_ENTER()
    #define SYNCH_LEAVE()

////////////////////////////////////////////////////////////////////////////

BOOL gbNull = FALSE;    // Set to TRUE with the debugger to test the speed
                        //   of NT with an inifinitely fast display driver
                        //   (actually, almost infinitely fast since we're
                        //   not hooking all the calls we could be)


DHPDEV DbgEnablePDEV(
DEVMODEW*   pDevmode,
PWSTR       pwszLogAddress,
ULONG       cPatterns,
HSURF*      ahsurfPatterns,
ULONG       cjGdiInfo,
ULONG*      pGdiInfo,
ULONG       cjDevInfo,
DEVINFO*    pDevInfo,
HDEV        hdev,
PWSTR       pwszDeviceName,
HANDLE      hDriver)
{
    DHPDEV bRet;

    SYNCH_ENTER();
    DISPDBG((5, "DrvEnablePDEV"));

    bRet = DrvEnablePDEV(
                pDevmode,
                pwszLogAddress,
                cPatterns,
                ahsurfPatterns,
                cjGdiInfo,
                pGdiInfo,
                cjDevInfo,
                pDevInfo,
                hdev,
                pwszDeviceName,
                hDriver);

    DISPDBG((6, "DrvEnablePDEV done"));
    SYNCH_LEAVE();

    return(bRet);
}

VOID DbgCompletePDEV(
DHPDEV dhpdev,
HDEV  hdev)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvCompletePDEV"));

    DrvCompletePDEV(
                dhpdev,
                hdev);

    DISPDBG((6, "DrvCompletePDEV done"));
    SYNCH_LEAVE();
}

VOID DbgDisablePDEV(DHPDEV dhpdev)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvDisable"));

    DrvDisablePDEV(dhpdev);

    DISPDBG((6, "DrvDisable done"));
    SYNCH_LEAVE();
}

HSURF DbgEnableSurface(DHPDEV dhpdev)
{
    HSURF h;

    SYNCH_ENTER();
    DISPDBG((5, "DrvEnableSurface"));

    h = DrvEnableSurface(dhpdev);

    DISPDBG((6, "DrvEnableSurface done"));
    SYNCH_LEAVE();

    return(h);
}

VOID DbgDisableSurface(DHPDEV dhpdev)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvDisableSurface"));

    DrvDisableSurface(dhpdev);

    DISPDBG((6, "DrvDisableSurface done"));
    SYNCH_LEAVE();
}

BOOL  DbgAssertMode(
DHPDEV dhpdev,
BOOL   bEnable)
{
    BOOL b;

    SYNCH_ENTER();
    DISPDBG((5, "DrvAssertMode"));

    b = DrvAssertMode(dhpdev,bEnable);

    DISPDBG((6, "DrvAssertMode done"));
    SYNCH_LEAVE();

    return (b);
}

//
// We do not SYNCH_ENTER since we have not initalized the driver.
// We just want to get the list of modes from the miniport.
//

ULONG DbgGetModes(
HANDLE    hDriver,
ULONG     cjSize,
DEVMODEW* pdm)
{
    ULONG u;

    DISPDBG((5, "DrvGetModes"));

    u = DrvGetModes(
                hDriver,
                cjSize,
                pdm);

    DISPDBG((6, "DrvGetModes done"));

    return(u);
}

VOID DbgMovePointer(SURFOBJ *pso,LONG x,LONG y,RECTL *prcl)
{
    if (gbNull)
        return;

    // Note: Because we set GCAPS_ASYNCMOVE, we don't want to do a
    //       SYNCH_ENTER/LEAVE here.

    DISPDBG((5, "DrvMovePointer"));

    DrvMovePointer(pso,x,y,prcl);

    DISPDBG((6, "DrvMovePointer done"));
}

ULONG DbgSetPointerShape(
SURFOBJ*  pso,
SURFOBJ*  psoMask,
SURFOBJ*  psoColor,
XLATEOBJ* pxlo,
LONG      xHot,
LONG      yHot,
LONG      x,
LONG      y,
RECTL*    prcl,
FLONG     fl)
{
    ULONG u;

    if (gbNull)
        return(SPS_ACCEPT_NOEXCLUDE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvSetPointerShape"));

    u = DrvSetPointerShape(
                pso,
                psoMask,
                psoColor,
                pxlo,
                xHot,
                yHot,
                x,
                y,
                prcl,
                fl);

    DISPDBG((6, "DrvSetPointerShape done"));
    SYNCH_LEAVE();

    return(u);
}

ULONG DbgDitherColor(
DHPDEV dhpdev,
ULONG  iMode,
ULONG  rgb,
ULONG* pul)
{
    ULONG u;

    if (gbNull)
        return(DCR_DRIVER);

    //
    // No need to Synchronize Dither color.
    //

    DISPDBG((5, "DrvDitherColor"));

    u = DrvDitherColor(
                dhpdev,
                iMode,
                rgb,
                pul);

    DISPDBG((6, "DrvDitherColor done"));

    return(u);
}

BOOL DbgSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvSetPalette"));

    u = DrvSetPalette(
                dhpdev,
                ppalo,
                fl,
                iStart,
                cColors);

    DISPDBG((6, "DrvSetPalette done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvCopyBits"));

    u = DrvCopyBits(
                psoDst,
                psoSrc,
                pco,
                pxlo,
                prclDst,
                pptlSrc);

    DISPDBG((6, "DrvCopyBits done"));
    SYNCH_LEAVE();

    return(u);
}


BOOL DbgBitBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvBitBlt"));

    u = DrvBitBlt(
                psoDst,
                psoSrc,
                psoMask,
                pco,
                pxlo,
                prclDst,
                pptlSrc,
                pptlMask,
                pbo,
                pptlBrush,
                rop4);

    DISPDBG((6, "DrvBitBlt done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlOrg,
MIX       mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvTextOut"));

    u = DrvTextOut(
                pso,
                pstro,
                pfo,
                pco,
                prclExtra,
                prclOpaque,
                pboFore,
                pboOpaque,
                pptlOrg,
                mix);

    DISPDBG((6, "DrvTextOut done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrushOrg,
LINEATTRS* plineattrs,
MIX        mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvStrokePath"));

    u = DrvStrokePath(
                pso,
                ppo,
                pco,
                pxo,
                pbo,
                pptlBrushOrg,
                plineattrs,
                mix);

    DISPDBG((6, "DrvStrokePath done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgFillPath(
SURFOBJ*  pso,
PATHOBJ*  ppo,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrushOrg,
MIX       mix,
FLONG     flOptions)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvFillPath"));

    u = DrvFillPath(pso,
                ppo,
                pco,
                pbo,
                pptlBrushOrg,
                mix,
                flOptions);

    DISPDBG((6, "DrvFillPath done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrushOrg,
MIX       mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvPaint"));

    u = DrvPaint(
                pso,
                pco,
                pbo,
                pptlBrushOrg,
                mix);

    DISPDBG((6, "DrvPaint done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgEscape(
SURFOBJ*    pso,
ULONG       iEsc,
ULONG       cjIn,
VOID*       pvIn,
ULONG       cjOut,
VOID*       pvOut)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    // Most escapes are not synchronized by GDI...

    DISPDBG((5, "DrvEscape"));

    u = DrvEscape(pso,
                  iEsc,
                  cjIn,
                  pvIn,
                  cjOut,
                  pvOut);

    DISPDBG((6, "DrvEscape done"));

    return(u);
}

BOOL DbgRealizeBrush(
BRUSHOBJ* pbo,
SURFOBJ*  psoTarget,
SURFOBJ*  psoPattern,
SURFOBJ*  psoMask,
XLATEOBJ* pxlo,
ULONG     iHatch)
{
    BOOL u;

    // Note: The only time DrvRealizeBrush is called by GDI is when we've
    //       called BRUSHOBJ_pvGetRbrush in the middle of a DrvBitBlt
    //       call, and GDI had to call us back.  Since we're still in the
    //       middle of DrvBitBlt, synchronization has already taken care of.
    //       For the same reason, this will never be called when 'gbNull'
    //       is TRUE, so it doesn't even make sense to check gbNull...

    DISPDBG((5, "DrvRealizeBrush"));

    u = DrvRealizeBrush(
                pbo,
                psoTarget,
                psoPattern,
                psoMask,
                pxlo,
                iHatch);

    DISPDBG((6, "DrvRealizeBrush done"));

    return(u);
}

HBITMAP DbgCreateDeviceBitmap(DHPDEV dhpdev, SIZEL sizl, ULONG iFormat)
{
    HBITMAP hbm;

    if (gbNull)                     // I would pretend to have created a
        return(FALSE);              //   bitmap when gbNull is set, by we
                                    //   would need some code to back this
                                    //   up so that the system wouldn't
                                    //   crash...

    SYNCH_ENTER();
    DISPDBG((5, "DrvCreateDeviceBitmap"));

    hbm = DrvCreateDeviceBitmap(dhpdev, sizl, iFormat);

    DISPDBG((6, "DrvCreateDeviceBitmap done"));
    SYNCH_LEAVE();

    return(hbm);
}

VOID DbgDeleteDeviceBitmap(DHSURF dhsurf)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvDeleteDeviceBitmap"));

    DrvDeleteDeviceBitmap(dhsurf);

    DISPDBG((6, "DrvDeleteDeviceBitmap done"));
    SYNCH_LEAVE();
}

VOID DbgDestroyFont(FONTOBJ* pfo)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvDestroyFont"));

    DrvDestroyFont(pfo);

    DISPDBG((6, "DrvDestroyFont done"));
    SYNCH_LEAVE();
}

BOOL DbgStretchBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMask,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMask,
ULONG               iMode)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvStretchBlt"));

    #if SYNCHRONIZEACCESS_WORKS
    {
        // Our DrvStretchBlt routine calls back to EngStretchBlt, which
        // calls back to our DrvCopyBits routine -- so we have to be
        // re-entrant for synchronization...

        SYNCH_LEAVE();
    }
    #endif // SYNCHRONIZEACCESS_WORKS

    u = DrvStretchBlt(psoDst, psoSrc, psoMask, pco, pxlo, pca, pptlHTOrg,
                      prclDst, prclSrc, pptlMask, iMode);

    #if SYNCHRONIZEACCESS_WORKS
    {
        SYNCH_ENTER();
    }
    #endif // SYNCHRONIZEACCESS_WORKS

    DISPDBG((6, "DrvStretchBlt done"));
    SYNCH_LEAVE();

    return(u);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\disp\textout.c ===
/******************************Module*Header*******************************\
* Module Name: textout.c
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vClipSolid
*
* Fills the specified rectangles with the specified colour, honouring
* the requested clipping.  No more than four rectangles should be passed in.
* Intended for drawing the areas of the opaquing rectangle that extend
* beyond the text box.  The rectangles must be in left to right, top to
* bottom order.  Assumes there is at least one rectangle in the list.
*
\**************************************************************************/

VOID vClipSolid(
PDEV*       ppdev,
LONG        crcl,
RECTL*      prcl,
ULONG       iColor,
CLIPOBJ*    pco)
{
    BOOL            bMore;              // Flag for clip enumeration
    CLIPENUM        ce;                 // Clip enumeration object
    ULONG           i;
    ULONG           j;
    RECTL           arclTmp[4];
    ULONG           crclTmp;
    RECTL*          prclTmp;
    RECTL*          prclClipTmp;
    LONG            iLastBottom;
    RECTL*          prclClip;
    RBRUSH_COLOR    rbc;

    ASSERTDD((crcl > 0) && (crcl <= 4), "Expected 1 to 4 rectangles");
    ASSERTDD((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL),
                       "Expected a non-null clip object");

    rbc.iSolidColor = iColor;
    if (pco->iDComplexity == DC_RECT)
    {
        crcl = cIntersect(&pco->rclBounds, prcl, crcl);
        if (crcl != 0)
        {
            (ppdev->pfnFillSolid)(ppdev, crcl, prcl, 0xf0f0, rbc, NULL);
        }
    }
    else // iDComplexity == DC_COMPLEX
    {
        // Bottom of last rectangle to fill

        iLastBottom = prcl[crcl - 1].bottom;

        // Initialize the clip rectangle enumeration to right-down so we can
        // take advantage of the rectangle list being right-down:

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_RIGHTDOWN, 0);

        // Scan through all the clip rectangles, looking for intersects
        // of fill areas with region rectangles:

        do {
            // Get a batch of region rectangles:

            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (VOID*)&ce);

            // Clip the rect list to each region rect:

            for (j = ce.c, prclClip = ce.arcl; j-- > 0; prclClip++)
            {
                // Since the rectangles and the region enumeration are both
                // right-down, we can zip through the region until we reach
                // the first fill rect, and are done when we've passed the
                // last fill rect.

                if (prclClip->top >= iLastBottom)
                {
                    // Past last fill rectangle; nothing left to do:

                    return;
                }

                // Do intersection tests only if we've reached the top of
                // the first rectangle to fill:

                if (prclClip->bottom > prcl->top)
                {
                    // We've reached the top Y scan of the first rect, so
                    // it's worth bothering checking for intersection.

                    // Generate a list of the rects clipped to this region
                    // rect:

                    prclTmp     = prcl;
                    prclClipTmp = arclTmp;

                    for (i = crcl, crclTmp = 0; i-- != 0; prclTmp++)
                    {
                        // Intersect fill and clip rectangles

                        if (bIntersect(prclTmp, prclClip, prclClipTmp))
                        {
                            // Add to list if anything's left to draw:

                            crclTmp++;
                            prclClipTmp++;
                        }
                    }

                    // Draw the clipped rects

                    if (crclTmp != 0)
                    {
                        (ppdev->pfnFillSolid)(ppdev, crclTmp, &arclTmp[0],
                                              0xf0f0, rbc, NULL);
                    }
                }
            }
        } while (bMore);
    }
}

/******************************Public*Routine******************************\
* VOID vIoClipText
*
\**************************************************************************/

VOID vIoClipText(
PDEV*     ppdev,
STROBJ*   pstro,
CLIPOBJ*  pco)
{
    BYTE*       pjIoBase;
    BYTE*       pjScreen;
    BOOL        bMoreGlyphs;
    ULONG       cGlyphOriginal;
    ULONG       cGlyph;
    GLYPHPOS*   pgpOriginal;
    GLYPHPOS*   pgp;
    GLYPHBITS*  pgb;
    POINTL      ptlOrigin;
    BOOL        bMore;
    CLIPENUM    ce;
    RECTL*      prclClip;
    ULONG       ulCharInc;
    LONG        cxGlyph;
    LONG        cyGlyph;
    LONG        xBias;
    LONG        cx;
    LONG        cy;
    ULONG*      pdSrc;
    ULONG*      pdDst;
    LONG        cj;
    LONG        cd;
    LONG        xLeft;
    LONG        yTop;
    LONG        xRight;
    LONG        yBottom;
    LONG        lDelta;
    LONG        i;
    BYTE*       pjSrc;

    ASSERTDD(pco != NULL, "Don't expect NULL clip objects here");

    pjIoBase = ppdev->pjIoBase;
    pjScreen = ppdev->pjScreen;

    do {
      if (pstro->pgp != NULL)
      {
        // There's only the one batch of glyphs, so save ourselves
        // a call:

        pgpOriginal    = pstro->pgp;
        cGlyphOriginal = pstro->cGlyphs;
        bMoreGlyphs    = FALSE;
      }
      else
      {
        bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
      }

      if (cGlyphOriginal > 0)
      {
        ulCharInc = pstro->ulCharInc;

        if (pco->iDComplexity == DC_RECT)
        {
            // We could call 'cEnumStart' and 'bEnum' when the clipping is
            // DC_RECT, but the last time I checked, those two calls took
            // more than 150 instructions to go through GDI.  Since
            // 'rclBounds' already contains the DC_RECT clip rectangle,
            // and since it's such a common case, we'll special case it:

            bMore    = FALSE;
            prclClip = &pco->rclBounds;
            ce.c     = 1;

            goto SingleRectangle;
        }

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do {
          bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

          for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
          {

          SingleRectangle:

            pgp         = pgpOriginal;
            cGlyph      = cGlyphOriginal;
            pgb         = pgp->pgdf->pgb;

            ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
            ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;

            pdDst       = (ULONG*) pjScreen;

            IO_WAIT_FOR_IDLE(ppdev, pjIoBase);

            // Loop through all the glyphs for this rectangle:

            while (TRUE)
            {
              cxGlyph = pgb->sizlBitmap.cx;
              cyGlyph = pgb->sizlBitmap.cy;
              pdSrc   = (ULONG*) pgb->aj;

              if ((prclClip->left   <= ptlOrigin.x) &&
                  (prclClip->top    <= ptlOrigin.y) &&
                  (prclClip->right  >= ptlOrigin.x + cxGlyph) &&
                  (prclClip->bottom >= ptlOrigin.y + cyGlyph))
              {
                //-----------------------------------------------------
                // Unclipped glyph

                IO_DEST_XY(ppdev, pjIoBase, ptlOrigin.x, ptlOrigin.y);
                IO_BITMAP_WIDTH(ppdev, pjIoBase, cxGlyph);
                IO_BITMAP_HEIGHT(ppdev, pjIoBase, cyGlyph);
                IO_BLT_CMD_0(ppdev, pjIoBase, START_BLT);

                cj = cyGlyph * ((cxGlyph + 7) >> 3);

                cd = cj >> 2;
                if (cd != 0)
                {
                  do {
                    WRITE_REGISTER_ULONG(pdDst, *pdSrc);
                    MEMORY_BARRIER();
                    pdSrc++;
                  } while (--cd != 0);
                }

                // We have to be careful we don't output any more data
                // than we're supposed to, otherwise we get garbage on
                // the screen:

                switch (cj & 3)
                {
                case 1:
                  WRITE_REGISTER_UCHAR(pdDst, *(UCHAR*) pdSrc);
                  MEMORY_BARRIER();
                  break;
                case 2:
                  WRITE_REGISTER_USHORT(pdDst, *(USHORT*) pdSrc);
                  MEMORY_BARRIER();
                  break;
                case 3:
                  WRITE_REGISTER_USHORT(pdDst, *(USHORT*) pdSrc);
                  MEMORY_BARRIER();
                  WRITE_REGISTER_UCHAR(pdDst, *((UCHAR*) pdSrc + 2));
                  MEMORY_BARRIER();
                  break;
                }

                IO_WAIT_TRANSFER_DONE(ppdev, pjIoBase);
              }
              else
              {
                //-----------------------------------------------------
                // Clipped glyph

                // Find the intersection of the glyph rectangle
                // and the clip rectangle:

                xLeft   = max(prclClip->left,   ptlOrigin.x);
                yTop    = max(prclClip->top,    ptlOrigin.y);
                xRight  = min(prclClip->right,  ptlOrigin.x + cxGlyph);
                yBottom = min(prclClip->bottom, ptlOrigin.y + cyGlyph);

                // Check for trivial rejection:

                if (((cx = xRight - xLeft) > 0) &&
                    ((cy = yBottom - yTop) > 0))
                {
                  IO_DEST_XY(ppdev, pjIoBase, xLeft, yTop);
                  IO_BITMAP_WIDTH(ppdev, pjIoBase, cx);
                  IO_BITMAP_HEIGHT(ppdev, pjIoBase, cy);

                  xBias  = (xLeft - ptlOrigin.x) & 7;
                  cx    += xBias;
                  IO_SRC_ALIGN(ppdev, pjIoBase, xBias);

                  lDelta  = (cxGlyph + 7) >> 3;
                  pjSrc   = (BYTE*) pdSrc + (yTop - ptlOrigin.y) * lDelta
                                          + ((xLeft - ptlOrigin.x) >> 3);
                  cj      = (cx + 7) >> 3;
                  lDelta -= cj;

                  IO_BLT_CMD_0(ppdev, pjIoBase, START_BLT);

                  do {
                    i = cj;
                    do {
                      WRITE_REGISTER_UCHAR((UCHAR*) pdDst, *pjSrc);
                      MEMORY_BARRIER();
                      pjSrc++;
                    } while (--i != 0);

                    pjSrc += lDelta;
                  } while (--cy != 0);

                  // Reset the alignment register in case we have more
                  // unclipped glyphs in this string:

                  IO_SRC_ALIGN(ppdev, pjIoBase, 0);

                  IO_WAIT_TRANSFER_DONE(ppdev, pjIoBase);
                }
              }

              if (--cGlyph == 0)
                break;

              // Get ready for next glyph:

              pgp++;
              pgb = pgp->pgdf->pgb;

              if (ulCharInc == 0)
              {
                ptlOrigin.x = pgp->ptl.x + pgb->ptlOrigin.x;
                ptlOrigin.y = pgp->ptl.y + pgb->ptlOrigin.y;
              }
              else
              {
                ptlOrigin.x += ulCharInc;
              }
            }
          }
        } while (bMore);
      }
    } while (bMoreGlyphs);
}

/******************************Public*Routine******************************\
* VOID vIoTextOut
*
\**************************************************************************/

VOID vIoTextOut(
PDEV*     ppdev,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque)
{
    BYTE*           pjIoBase;
    BOOL            bTextPerfectFit;
    ULONG           cGlyph;
    BOOL            bMoreGlyphs;
    GLYPHPOS*       pgp;
    GLYPHBITS*      pgb;
    LONG            cxGlyph;
    LONG            cyGlyph;
    ULONG*          pdSrc;
    ULONG*          pdDst;
    BYTE*           pjScreen;
    LONG            cj;
    LONG            cd;
    POINTL          ptlOrigin;
    LONG            ulCharInc;
    BYTE            iDComplexity;

    pjIoBase = ppdev->pjIoBase;
    pjScreen = ppdev->pjScreen;

    iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    if (prclOpaque != NULL)
    {
      ////////////////////////////////////////////////////////////
      // Opaque Initialization
      ////////////////////////////////////////////////////////////

      // If we paint the glyphs in 'opaque' mode, we may not actually
      // have to draw the opaquing rectangle up-front -- the process
      // of laying down all the glyphs will automatically cover all
      // of the pixels in the opaquing rectangle.
      //
      // The condition that must be satisfied is that the text must
      // fit 'perfectly' such that the entire background rectangle is
      // covered, and none of the glyphs overlap (if the glyphs
      // overlap, such as for italics, they have to be drawn in
      // transparent mode after the opaquing rectangle is cleared).

      bTextPerfectFit = (pstro->flAccel & (SO_ZERO_BEARINGS |
              SO_FLAG_DEFAULT_PLACEMENT | SO_MAXEXT_EQUAL_BM_SIDE |
              SO_CHAR_INC_EQUAL_BM_BASE)) ==
              (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT |
              SO_MAXEXT_EQUAL_BM_SIDE | SO_CHAR_INC_EQUAL_BM_BASE);

      if (!(bTextPerfectFit)                               ||
          (pstro->rclBkGround.top    > prclOpaque->top)    ||
          (pstro->rclBkGround.left   > prclOpaque->left)   ||
          (pstro->rclBkGround.right  < prclOpaque->right)  ||
          (pstro->rclBkGround.bottom < prclOpaque->bottom))
      {
        if (iDComplexity == DC_TRIVIAL)
        {
          IO_WAIT_FOR_IDLE(ppdev, pjIoBase);
          IO_PREG_COLOR_8(ppdev, pjIoBase, pboOpaque->iSolidColor);
          IO_CTRL_REG_1(ppdev, pjIoBase, PACKED_PIXEL_VIEW |
                                         BITS_PER_PIX_8    |
                                         ENAB_TRITON_MODE);
          IO_BLT_CMD_1(ppdev, pjIoBase, XY_SRC_ADDR |
                                        XY_DEST_ADDR);
          IO_DATAPATH_CTRL(ppdev, pjIoBase, ROPSELECT_NO_ROPS    |
                                            PIXELMASK_ONLY       |
                                            PLANARMASK_NONE_0XFF |
                                            SRC_IS_PATTERN_REGS);
          IO_BITMAP_HEIGHT(ppdev, pjIoBase, prclOpaque->bottom - prclOpaque->top);
          IO_BITMAP_WIDTH(ppdev, pjIoBase, prclOpaque->right - prclOpaque->left);
          IO_DEST_XY(ppdev, pjIoBase, prclOpaque->left, prclOpaque->top);
          IO_BLT_CMD_0(ppdev, pjIoBase, START_BLT);
        }
        else
        {
          vClipSolid(ppdev, 1, prclOpaque, pboOpaque->iSolidColor, pco);
        }
      }

      if (bTextPerfectFit)
      {
        // If we have already drawn the opaquing rectangle (because
        // is was larger than the text rectangle), we could lay down
        // the glyphs in 'transparent' mode.  But I've found the QVision
        // to be a bit faster drawing in opaque mode, so we'll stick
        // with that:

        IO_WAIT_FOR_IDLE(ppdev, pjIoBase);
        IO_CTRL_REG_1(ppdev, pjIoBase, EXPAND_TO_FG      |
                                       BITS_PER_PIX_8    |
                                       ENAB_TRITON_MODE);
        IO_BLT_CMD_1(ppdev, pjIoBase, XY_SRC_ADDR |
                                      XY_DEST_ADDR);
        IO_DATAPATH_CTRL(ppdev, pjIoBase, ROPSELECT_NO_ROPS    |
                                          PIXELMASK_ONLY       |
                                          PLANARMASK_NONE_0XFF |
                                          SRC_IS_CPU_DATA);
        IO_FG_COLOR(ppdev, pjIoBase, pboFore->iSolidColor);
        IO_BG_COLOR(ppdev, pjIoBase, pboOpaque->iSolidColor);
        IO_SRC_ALIGN(ppdev, pjIoBase, 0);

        goto SkipTransparentInitialization;
      }
    }

    ////////////////////////////////////////////////////////////
    // Transparent Initialization
    ////////////////////////////////////////////////////////////

    // Initialize the hardware for transparent text:

    IO_WAIT_FOR_IDLE(ppdev, pjIoBase);
    IO_CTRL_REG_1(ppdev, pjIoBase, EXPAND_TO_FG      |
                                   BITS_PER_PIX_8    |
                                   ENAB_TRITON_MODE);
    IO_BLT_CMD_1(ppdev, pjIoBase, XY_SRC_ADDR |
                                  XY_DEST_ADDR);
    IO_DATAPATH_CTRL(ppdev, pjIoBase, ROPSELECT_NO_ROPS      |
                                      PIXELMASK_AND_SRC_DATA |
                                      PLANARMASK_NONE_0XFF   |
                                      SRC_IS_CPU_DATA);
    IO_FG_COLOR(ppdev, pjIoBase, pboFore->iSolidColor);
    IO_SRC_ALIGN(ppdev, pjIoBase, 0);

  SkipTransparentInitialization:

    if (iDComplexity == DC_TRIVIAL)
    {
      do {
        if (pstro->pgp != NULL)
        {
          // There's only the one batch of glyphs, so save ourselves
          // a call:

          pgp         = pstro->pgp;
          cGlyph      = pstro->cGlyphs;
          bMoreGlyphs = FALSE;
        }
        else
        {
          bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
        }

        if (cGlyph > 0)
        {
          if (pstro->ulCharInc == 0)
          {
            ////////////////////////////////////////////////////////////
            // Proportional Spacing

            pdDst = (ULONG*) pjScreen;

            IO_WAIT_FOR_IDLE(ppdev, pjIoBase);

            do {
              pgb = pgp->pgdf->pgb;

              IO_DEST_XY(ppdev, pjIoBase, pgp->ptl.x + pgb->ptlOrigin.x,
                                          pgp->ptl.y + pgb->ptlOrigin.y);
              cxGlyph = pgb->sizlBitmap.cx;
              IO_BITMAP_WIDTH(ppdev, pjIoBase, cxGlyph);
              cyGlyph = pgb->sizlBitmap.cy;
              IO_BITMAP_HEIGHT(ppdev, pjIoBase, cyGlyph);
              IO_BLT_CMD_0(ppdev, pjIoBase, START_BLT);

              pdSrc = (ULONG*) pgb->aj;

              cj = cyGlyph * ((cxGlyph + 7) >> 3);

              cd = cj >> 2;
              if (cd != 0)
              {
                do {
                  WRITE_REGISTER_ULONG(pdDst, *pdSrc);
                  MEMORY_BARRIER();
                  pdSrc++;
                } while (--cd != 0);
              }

              // We have to be careful we don't output any more data
              // than we're supposed to, otherwise we get garbage on
              // the screen:

              switch (cj & 3)
              {
              case 1:
                WRITE_REGISTER_UCHAR(pdDst, *(UCHAR*) pdSrc);
                MEMORY_BARRIER();
                break;
              case 2:
                WRITE_REGISTER_USHORT(pdDst, *(USHORT*) pdSrc);
                MEMORY_BARRIER();
                break;
              case 3:
                WRITE_REGISTER_USHORT(pdDst, *(USHORT*) pdSrc);
                MEMORY_BARRIER();
                WRITE_REGISTER_UCHAR(pdDst, *((UCHAR*) pdSrc + 2));
                MEMORY_BARRIER();
                break;
              }

              IO_WAIT_TRANSFER_DONE(ppdev, pjIoBase);

            } while (pgp++, --cGlyph != 0);
          }
          else
          {
            ////////////////////////////////////////////////////////////
            // Mono Spacing

            ulCharInc   = pstro->ulCharInc;
            pgb         = pgp->pgdf->pgb;

            ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
            ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;

            pdDst       = (ULONG*) pjScreen;

            IO_WAIT_FOR_IDLE(ppdev, pjIoBase);

            do {
              pgb = pgp->pgdf->pgb;

              IO_DEST_XY(ppdev, pjIoBase, ptlOrigin.x, ptlOrigin.y);
              ptlOrigin.x += ulCharInc;

              cxGlyph = pgb->sizlBitmap.cx;
              IO_BITMAP_WIDTH(ppdev, pjIoBase, cxGlyph);
              cyGlyph = pgb->sizlBitmap.cy;
              IO_BITMAP_HEIGHT(ppdev, pjIoBase, cyGlyph);
              IO_BLT_CMD_0(ppdev, pjIoBase, START_BLT);

              pdSrc = (ULONG*) pgb->aj;

              cj = cyGlyph * ((cxGlyph + 7) >> 3);

              cd = cj >> 2;
              if (cd != 0)
              {
                do {
                  WRITE_REGISTER_ULONG(pdDst, *pdSrc);
                  MEMORY_BARRIER();
                  pdSrc++;
                } while (--cd != 0);
              }

              // We have to be careful we don't output any more data
              // than we're supposed to, otherwise we get garbage on
              // the screen:

              switch (cj & 3)
              {
              case 1:
                WRITE_REGISTER_UCHAR(pdDst, *(UCHAR*) pdSrc);
                MEMORY_BARRIER();
                break;
              case 2:
                WRITE_REGISTER_USHORT(pdDst, *(USHORT*) pdSrc);
                MEMORY_BARRIER();
                break;
              case 3:
                WRITE_REGISTER_USHORT(pdDst, *(USHORT*) pdSrc);
                MEMORY_BARRIER();
                WRITE_REGISTER_UCHAR(pdDst, *((UCHAR*) pdSrc + 2));
                MEMORY_BARRIER();
                break;
              }

              IO_WAIT_TRANSFER_DONE(ppdev, pjIoBase);

            } while (pgp++, --cGlyph != 0);
          }
        }
      } while (bMoreGlyphs);
    }
    else
    {
      // If there's clipping, call off to a function:

      vIoClipText(ppdev, pstro, pco);
    }

    IO_WAIT_FOR_IDLE(ppdev, pjIoBase);
    IO_BLT_CONFIG(ppdev, pjIoBase, RESET_BLT);
    IO_BLT_CONFIG(ppdev, pjIoBase, BLT_ENABLE);
}

/******************************Public*Routine******************************\
* VOID vMmClipText
*
\**************************************************************************/

VOID vMmClipText(
PDEV*     ppdev,
STROBJ*   pstro,
CLIPOBJ*  pco)
{
    BYTE*       pjMmBase;
    BYTE*       pjScreen;
    BOOL        bMoreGlyphs;
    ULONG       cGlyphOriginal;
    ULONG       cGlyph;
    GLYPHPOS*   pgpOriginal;
    GLYPHPOS*   pgp;
    GLYPHBITS*  pgb;
    POINTL      ptlOrigin;
    BOOL        bMore;
    CLIPENUM    ce;
    RECTL*      prclClip;
    ULONG       ulCharInc;
    LONG        cxGlyph;
    LONG        cyGlyph;
    LONG        xBias;
    LONG        cx;
    LONG        cy;
    ULONG*      pdSrc;
    ULONG*      pdDst;
    LONG        cj;
    LONG        cd;
    LONG        xLeft;
    LONG        yTop;
    LONG        xRight;
    LONG        yBottom;
    LONG        lDelta;
    LONG        i;
    BYTE*       pjSrc;

    ASSERTDD(pco != NULL, "Don't expect NULL clip objects here");

    pjMmBase = ppdev->pjMmBase;
    pjScreen = ppdev->pjScreen;

    do {
      if (pstro->pgp != NULL)
      {
        // There's only the one batch of glyphs, so save ourselves
        // a call:

        pgpOriginal    = pstro->pgp;
        cGlyphOriginal = pstro->cGlyphs;
        bMoreGlyphs    = FALSE;
      }
      else
      {
        bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
      }

      if (cGlyphOriginal > 0)
      {
        ulCharInc = pstro->ulCharInc;

        if (pco->iDComplexity == DC_RECT)
        {
            // We could call 'cEnumStart' and 'bEnum' when the clipping is
            // DC_RECT, but the last time I checked, those two calls took
            // more than 150 instructions to go through GDI.  Since
            // 'rclBounds' already contains the DC_RECT clip rectangle,
            // and since it's such a common case, we'll special case it:

            bMore    = FALSE;
            prclClip = &pco->rclBounds;
            ce.c     = 1;

            goto SingleRectangle;
        }

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do {
          bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

          for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
          {

          SingleRectangle:

            pgp         = pgpOriginal;
            cGlyph      = cGlyphOriginal;
            pgb         = pgp->pgdf->pgb;

            ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
            ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;

            pdDst       = (ULONG*) pjScreen;

            MM_WAIT_FOR_IDLE(ppdev, pjMmBase);

            // Loop through all the glyphs for this rectangle:

            while (TRUE)
            {
              cxGlyph = pgb->sizlBitmap.cx;
              cyGlyph = pgb->sizlBitmap.cy;
              pdSrc   = (ULONG*) pgb->aj;

              if ((prclClip->left   <= ptlOrigin.x) &&
                  (prclClip->top    <= ptlOrigin.y) &&
                  (prclClip->right  >= ptlOrigin.x + cxGlyph) &&
                  (prclClip->bottom >= ptlOrigin.y + cyGlyph))
              {
                //-----------------------------------------------------
                // Unclipped glyph

                MM_DEST_XY(ppdev, pjMmBase, ptlOrigin.x, ptlOrigin.y);
                MM_BITMAP_WIDTH(ppdev, pjMmBase, cxGlyph);
                MM_BITMAP_HEIGHT(ppdev, pjMmBase, cyGlyph);
                MM_BLT_CMD_0(ppdev, pjMmBase, START_BLT);

                cj = cyGlyph * ((cxGlyph + 7) >> 3);

                cd = cj >> 2;
                if (cd != 0)
                {
                  do {
                    WRITE_REGISTER_ULONG(pdDst, *pdSrc);
                    MEMORY_BARRIER();
                    pdSrc++;
                  } while (--cd != 0);
                }

                // We have to be careful we don't output any more data
                // than we're supposed to, otherwise we get garbage on
                // the screen:

                switch (cj & 3)
                {
                case 1:
                  WRITE_REGISTER_UCHAR(pdDst, *(UCHAR*) pdSrc);
                  MEMORY_BARRIER();
                  break;
                case 2:
                  WRITE_REGISTER_USHORT(pdDst, *(USHORT*) pdSrc);
                  MEMORY_BARRIER();
                  break;
                case 3:
                  WRITE_REGISTER_USHORT(pdDst, *(USHORT*) pdSrc);
                  MEMORY_BARRIER();
                  WRITE_REGISTER_UCHAR(pdDst, *((UCHAR*) pdSrc + 2));
                  MEMORY_BARRIER();
                  break;
                }

                MM_WAIT_TRANSFER_DONE(ppdev, pjMmBase);
              }
              else
              {
                //-----------------------------------------------------
                // Clipped glyph

                // Find the intersection of the glyph rectangle
                // and the clip rectangle:

                xLeft   = max(prclClip->left,   ptlOrigin.x);
                yTop    = max(prclClip->top,    ptlOrigin.y);
                xRight  = min(prclClip->right,  ptlOrigin.x + cxGlyph);
                yBottom = min(prclClip->bottom, ptlOrigin.y + cyGlyph);

                // Check for trivial rejection:

                if (((cx = xRight - xLeft) > 0) &&
                    ((cy = yBottom - yTop) > 0))
                {
                  MM_DEST_XY(ppdev, pjMmBase, xLeft, yTop);
                  MM_BITMAP_WIDTH(ppdev, pjMmBase, cx);
                  MM_BITMAP_HEIGHT(ppdev, pjMmBase, cy);

                  xBias  = (xLeft - ptlOrigin.x) & 7;
                  cx    += xBias;
                  MM_SRC_ALIGN(ppdev, pjMmBase, xBias);

                  lDelta  = (cxGlyph + 7) >> 3;
                  pjSrc   = (BYTE*) pdSrc + (yTop - ptlOrigin.y) * lDelta
                                          + ((xLeft - ptlOrigin.x) >> 3);
                  cj      = (cx + 7) >> 3;
                  lDelta -= cj;

                  MM_BLT_CMD_0(ppdev, pjMmBase, START_BLT);

                  do {
                    i = cj;
                    do {
                      WRITE_REGISTER_UCHAR((UCHAR*) pdDst, *pjSrc);
                      MEMORY_BARRIER();
                      pjSrc++;
                    } while (--i != 0);

                    pjSrc += lDelta;
                  } while (--cy != 0);

                  // Reset the alignment register in case we have more
                  // unclipped glyphs in this string:

                  MM_SRC_ALIGN(ppdev, pjMmBase, 0);

                  MM_WAIT_TRANSFER_DONE(ppdev, pjMmBase);
                }
              }

              if (--cGlyph == 0)
                break;

              // Get ready for next glyph:

              pgp++;
              pgb = pgp->pgdf->pgb;

              if (ulCharInc == 0)
              {
                ptlOrigin.x = pgp->ptl.x + pgb->ptlOrigin.x;
                ptlOrigin.y = pgp->ptl.y + pgb->ptlOrigin.y;
              }
              else
              {
                ptlOrigin.x += ulCharInc;
              }
            }
          }
        } while (bMore);
      }
    } while (bMoreGlyphs);
}

/******************************Public*Routine******************************\
* VOID vMmTextOut
*
\**************************************************************************/

VOID vMmTextOut(
PDEV*     ppdev,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque)
{
    BYTE*           pjMmBase;
    BOOL            bTextPerfectFit;
    ULONG           cGlyph;
    BOOL            bMoreGlyphs;
    GLYPHPOS*       pgp;
    GLYPHBITS*      pgb;
    LONG            cxGlyph;
    LONG            cyGlyph;
    ULONG*          pdSrc;
    ULONG*          pdDst;
    BYTE*           pjScreen;
    LONG            cj;
    LONG            cd;
    POINTL          ptlOrigin;
    LONG            ulCharInc;
    BYTE            iDComplexity;

    pjMmBase = ppdev->pjMmBase;
    pjScreen = ppdev->pjScreen;

    iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    if (prclOpaque != NULL)
    {
      ////////////////////////////////////////////////////////////
      // Opaque Initialization
      ////////////////////////////////////////////////////////////

      // If we paint the glyphs in 'opaque' mode, we may not actually
      // have to draw the opaquing rectangle up-front -- the process
      // of laying down all the glyphs will automatically cover all
      // of the pixels in the opaquing rectangle.
      //
      // The condition that must be satisfied is that the text must
      // fit 'perfectly' such that the entire background rectangle is
      // covered, and none of the glyphs overlap (if the glyphs
      // overlap, such as for italics, they have to be drawn in
      // transparent mode after the opaquing rectangle is cleared).

      bTextPerfectFit = (pstro->flAccel & (SO_ZERO_BEARINGS |
              SO_FLAG_DEFAULT_PLACEMENT | SO_MAXEXT_EQUAL_BM_SIDE |
              SO_CHAR_INC_EQUAL_BM_BASE)) ==
              (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT |
              SO_MAXEXT_EQUAL_BM_SIDE | SO_CHAR_INC_EQUAL_BM_BASE);

      if (!(bTextPerfectFit)                               ||
          (pstro->rclBkGround.top    > prclOpaque->top)    ||
          (pstro->rclBkGround.left   > prclOpaque->left)   ||
          (pstro->rclBkGround.right  < prclOpaque->right)  ||
          (pstro->rclBkGround.bottom < prclOpaque->bottom))
      {
        if (iDComplexity == DC_TRIVIAL)
        {
          MM_WAIT_FOR_IDLE(ppdev, pjMmBase);
          MM_PREG_COLOR_8(ppdev, pjMmBase, pboOpaque->iSolidColor);
          MM_CTRL_REG_1(ppdev, pjMmBase, PACKED_PIXEL_VIEW |
                                         BLOCK_WRITE       | // Note
                                         BITS_PER_PIX_8    |
                                         ENAB_TRITON_MODE);
          MM_BLT_CMD_1(ppdev, pjMmBase, XY_SRC_ADDR |
                                        XY_DEST_ADDR);
          MM_DATAPATH_CTRL(ppdev, pjMmBase, ROPSELECT_NO_ROPS    |
                                            PIXELMASK_ONLY       |
                                            PLANARMASK_NONE_0XFF |
                                            SRC_IS_PATTERN_REGS);
          MM_BITMAP_HEIGHT(ppdev, pjMmBase, prclOpaque->bottom - prclOpaque->top);
          MM_BITMAP_WIDTH(ppdev, pjMmBase, prclOpaque->right - prclOpaque->left);
          MM_DEST_XY(ppdev, pjMmBase, prclOpaque->left, prclOpaque->top);
          MM_BLT_CMD_0(ppdev, pjMmBase, START_BLT);
        }
        else
        {
          vClipSolid(ppdev, 1, prclOpaque, pboOpaque->iSolidColor, pco);
        }
      }

      if (bTextPerfectFit)
      {
        // If we have already drawn the opaquing rectangle (because
        // is was larger than the text rectangle), we could lay down
        // the glyphs in 'transparent' mode.  But I've found the QVision
        // to be a bit faster drawing in opaque mode, so we'll stick
        // with that:

        MM_WAIT_FOR_IDLE(ppdev, pjMmBase);
        MM_CTRL_REG_1(ppdev, pjMmBase, EXPAND_TO_FG      |
                                       BITS_PER_PIX_8    |
                                       ENAB_TRITON_MODE);
        MM_BLT_CMD_1(ppdev, pjMmBase, XY_SRC_ADDR |
                                      XY_DEST_ADDR);
        MM_DATAPATH_CTRL(ppdev, pjMmBase, ROPSELECT_NO_ROPS    |
                                          PIXELMASK_ONLY       |
                                          PLANARMASK_NONE_0XFF |
                                          SRC_IS_CPU_DATA);
        MM_FG_COLOR(ppdev, pjMmBase, pboFore->iSolidColor);
        MM_BG_COLOR(ppdev, pjMmBase, pboOpaque->iSolidColor);
        MM_SRC_ALIGN(ppdev, pjMmBase, 0);

        goto SkipTransparentInitialization;
      }
    }

    ////////////////////////////////////////////////////////////
    // Transparent Initialization
    ////////////////////////////////////////////////////////////

    // Initialize the hardware for transparent text:

    MM_WAIT_FOR_IDLE(ppdev, pjMmBase);
    MM_CTRL_REG_1(ppdev, pjMmBase, EXPAND_TO_FG      |
                                   BITS_PER_PIX_8    |
                                   ENAB_TRITON_MODE);
    MM_BLT_CMD_1(ppdev, pjMmBase, XY_SRC_ADDR |
                                  XY_DEST_ADDR);
    MM_DATAPATH_CTRL(ppdev, pjMmBase, ROPSELECT_NO_ROPS      |
                                      PIXELMASK_AND_SRC_DATA |
                                      PLANARMASK_NONE_0XFF   |
                                      SRC_IS_CPU_DATA);
    MM_FG_COLOR(ppdev, pjMmBase, pboFore->iSolidColor);
    MM_SRC_ALIGN(ppdev, pjMmBase, 0);

  SkipTransparentInitialization:

    if (iDComplexity == DC_TRIVIAL)
    {
      do {
        if (pstro->pgp != NULL)
        {
          // There's only the one batch of glyphs, so save ourselves
          // a call:

          pgp         = pstro->pgp;
          cGlyph      = pstro->cGlyphs;
          bMoreGlyphs = FALSE;
        }
        else
        {
          bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
        }

        if (cGlyph > 0)
        {
          if (pstro->ulCharInc == 0)
          {
            ////////////////////////////////////////////////////////////
            // Proportional Spacing

            pdDst = (ULONG*) pjScreen;

            MM_WAIT_FOR_IDLE(ppdev, pjMmBase);

            do {
              pgb = pgp->pgdf->pgb;

              MM_DEST_XY(ppdev, pjMmBase, pgp->ptl.x + pgb->ptlOrigin.x,
                                          pgp->ptl.y + pgb->ptlOrigin.y);
              cxGlyph = pgb->sizlBitmap.cx;
              MM_BITMAP_WIDTH(ppdev, pjMmBase, cxGlyph);
              cyGlyph = pgb->sizlBitmap.cy;
              MM_BITMAP_HEIGHT(ppdev, pjMmBase, cyGlyph);
              MM_BLT_CMD_0(ppdev, pjMmBase, START_BLT);

              pdSrc = (ULONG*) pgb->aj;

              cj = cyGlyph * ((cxGlyph + 7) >> 3);

              cd = cj >> 2;
              if (cd != 0)
              {
                do {
                  WRITE_REGISTER_ULONG(pdDst, *pdSrc);
                  MEMORY_BARRIER();
                  pdSrc++;
                } while (--cd != 0);
              }

              // We have to be careful we don't output any more data
              // than we're supposed to, otherwise we get garbage on
              // the screen:

              switch (cj & 3)
              {
              case 1:
                WRITE_REGISTER_UCHAR(pdDst, *(UCHAR*) pdSrc);
                MEMORY_BARRIER();
                break;
              case 2:
                WRITE_REGISTER_USHORT(pdDst, *(USHORT*) pdSrc);
                MEMORY_BARRIER();
                break;
              case 3:
                WRITE_REGISTER_USHORT(pdDst, *(USHORT*) pdSrc);
                MEMORY_BARRIER();
                WRITE_REGISTER_UCHAR(pdDst, *((UCHAR*) pdSrc + 2));
                MEMORY_BARRIER();
                break;
              }

              MM_WAIT_TRANSFER_DONE(ppdev, pjMmBase);

            } while (pgp++, --cGlyph != 0);
          }
          else
          {
            ////////////////////////////////////////////////////////////
            // Mono Spacing

            ulCharInc   = pstro->ulCharInc;
            pgb         = pgp->pgdf->pgb;

            ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
            ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;

            pdDst       = (ULONG*) pjScreen;

            MM_WAIT_FOR_IDLE(ppdev, pjMmBase);

            do {
              pgb = pgp->pgdf->pgb;

              MM_DEST_XY(ppdev, pjMmBase, ptlOrigin.x, ptlOrigin.y);
              ptlOrigin.x += ulCharInc;

              cxGlyph = pgb->sizlBitmap.cx;
              MM_BITMAP_WIDTH(ppdev, pjMmBase, cxGlyph);
              cyGlyph = pgb->sizlBitmap.cy;
              MM_BITMAP_HEIGHT(ppdev, pjMmBase, cyGlyph);
              MM_BLT_CMD_0(ppdev, pjMmBase, START_BLT);

              pdSrc = (ULONG*) pgb->aj;

              cj = cyGlyph * ((cxGlyph + 7) >> 3);

              cd = cj >> 2;
              if (cd != 0)
              {
                do {
                  WRITE_REGISTER_ULONG(pdDst, *pdSrc);
                  MEMORY_BARRIER();
                  pdSrc++;
                } while (--cd != 0);
              }

              // We have to be careful we don't output any more data
              // than we're supposed to, otherwise we get garbage on
              // the screen:

              switch (cj & 3)
              {
              case 1:
                WRITE_REGISTER_UCHAR(pdDst, *(UCHAR*) pdSrc);
                MEMORY_BARRIER();
                break;
              case 2:
                WRITE_REGISTER_USHORT(pdDst, *(USHORT*) pdSrc);
                MEMORY_BARRIER();
                break;
              case 3:
                WRITE_REGISTER_USHORT(pdDst, *(USHORT*) pdSrc);
                MEMORY_BARRIER();
                WRITE_REGISTER_UCHAR(pdDst, *((UCHAR*) pdSrc + 2));
                MEMORY_BARRIER();
                break;
              }

              MM_WAIT_TRANSFER_DONE(ppdev, pjMmBase);

            } while (pgp++, --cGlyph != 0);
          }
        }
      } while (bMoreGlyphs);
    }
    else
    {
      // If there's clipping, call off to a function:

      vMmClipText(ppdev, pstro, pco);
    }
}

/******************************Public*Routine******************************\
* BOOL DrvTextOut
*
\**************************************************************************/

BOOL DrvTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,    // If we had set GCAPS_HORIZSTRIKE, we would have
                        //   to fill these extra rectangles (it is used
                        //   largely for underlines).  It's not a big
                        //   performance win (GDI will call our DrvBitBlt
                        //   to draw the extra rectangles).
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlBrush,
MIX       mix)
{
    PDEV*           ppdev;
    DSURF*          pdsurf;
    OH*             poh;

    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf->dt != DT_DIB)
    {
      poh            = pdsurf->poh;
      ppdev          = (PDEV*) pso->dhpdev;
      ppdev->xOffset = poh->x;
      ppdev->yOffset = poh->y;

      // The DDI spec says we'll only ever get foreground and background
      // mixes of R2_COPYPEN:

      ASSERTDD(mix == 0x0d0d, "GDI should only give us a copy mix");

      ppdev->pfnTextOut(ppdev, pstro, pfo, pco, prclOpaque, pboFore, pboOpaque);
    }
    else
    {
      // We're drawing to a DFB we've converted to a DIB, so just call GDI
      // to handle it:

      return(EngTextOut(pdsurf->pso, pstro, pfo, pco, prclExtra, prclOpaque,
                        pboFore, pboOpaque, pptlBrush, mix));
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID DrvDestroyFont
*
* We're being notified that the given font is being deallocated; clean up
* anything we've stashed in the 'pvConsumer' field of the 'pfo'.
*
\**************************************************************************/

VOID DrvDestroyFont(
FONTOBJ*    pfo)
{
    // !!!

    // This call isn't hooked, so GDI will never call it.
    //
    // This merely exists as a stub function for the sample multi-screen
    // support, so that MulDestroyFont can illustrate how multiple screen
    // text supports when the driver caches glyphs.  If this driver did
    // glyph caching, we might have used the 'pvConsumer' field of the
    //  'pfo', which we would have to clean up.
}

/******************************Public*Routine******************************\
* BOOL bEnableText
*
* Performs the necessary setup for the text drawing subcomponent.
*
\**************************************************************************/

BOOL bEnableText(
PDEV*   ppdev)
{
    // Our text algorithms require no initialization.  If we were to
    // do glyph caching, we would probably want to allocate off-screen
    // memory and do a bunch of other stuff here.

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisableText
*
* Performs the necessary clean-up for the text drawing subcomponent.
*
\**************************************************************************/

VOID vDisableText(PDEV* ppdev)
{
    // Here we free any stuff allocated in 'bEnableText'.
}

/******************************Public*Routine******************************\
* VOID vAssertModeText
*
* Disables or re-enables the text drawing subcomponent in preparation for
* full-screen entry/exit.
*
\**************************************************************************/

VOID vAssertModeText(
PDEV*   ppdev,
BOOL    bEnable)
{
    // If we were to do off-screen glyph caching, we would probably want
    // to invalidate our cache here, because it will get destroyed when
    // we switch to full-screen.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\mini\ctlrasic.c ===
//---------------------------------------------------------------------------
/*++

Copyright (c) 1993  Compaq Computer Corporation

Module Name:

    ctlrasic.c

Abstract:

    This module contains the code for identification of Compaq
    Display Controller ASICS.

        Original QVision ASIC - Feb. '92
        --------------------------------
        QVision 1024 /E - 1M configuration
        QVision 1024 /I - 1M configuration
        Deskpro /i with system board QVision - 512k or 1M configuration

        Enhanced QVision ASIC - May '93
        -------------------------------
        QVision 1024 /E - 1M or 2M configuration
        QVision 1024 /I - 1M or 2M configuration
        QVision 1280 /E - 2M configuration
        QVision 1280 /I - 2M configuration


Environment:

    kernel mode only

Notes:

Revision History:
   $0006
      miked: 02/17/1994
	. took out conditional debug code to satisfy MSBHPD

   $0004
      miked: 1/26/1994
	 . Added debug print code without all the other DBG overhead

  12/1/93 Mike Duke Original module started as start for NT version of QRY
		    library.
--*/
//---------------------------------------------------------------------------

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"
#include "qvision.h"

#include "qry_nt.h"

ULONG
QRY_ControllerASICID( PUCHAR IOAddress )
/*++
   Function: QRY_ControllerASICID

   This function returns the ASIC id of Compaq Video controllers.

   Return value:
    The return value is a ULONG with bytes defined as follows:

	       3   2  1  0    (byte positions)
    ULONG ---> XX FF FF FF
	       -- -- -- --
		|  |  |	 |____ASIC ID
		|  |  |_______Extended ID
		|  |__________Second Extended ID
		|_____________Not used (will be zero)

--*/
//---------------------------------------------------------------------------
{
   ULONG ulReturn = 0L;
   UCHAR ucTemp   = 0 ;

   // unlock QVision registers
   //
   VideoPortWritePortUchar((PUCHAR)(IOAddress + GRAPH_ADDRESS_PORT),
                            0x0f);
   ucTemp = VideoPortReadPortUchar((IOAddress + \
                                    GRAPH_DATA_PORT)) & 0xf0;
   VideoPortWritePortUchar((PUCHAR)(IOAddress + GRAPH_DATA_PORT),
                            (UCHAR)(0x05 | ucTemp));
   VideoPortWritePortUchar((PUCHAR)(IOAddress + GRAPH_ADDRESS_PORT),
                            0x10);
   ucTemp = VideoPortReadPortUchar((PUCHAR)(IOAddress + GRAPH_DATA_PORT));
   VideoPortWritePortUchar((PUCHAR)(IOAddress + GRAPH_DATA_PORT),
			    (UCHAR)(0x28 | ucTemp));

   //
   // get asic id
   //
   VideoPortWritePortUchar((PUCHAR)(IOAddress + GRAPH_ADDRESS_PORT), 0x0c);

   // read in asic id
   //
   ucTemp = VideoPortReadPortUchar(IOAddress + GRAPH_DATA_PORT) ;

   ulReturn = (ULONG)ucTemp;  // save asic id

   //
   // is extended id info available ?
   //
   if (ucTemp & EXTENDED_ID_BIT) {

      VideoPortWritePortUchar((PUCHAR)(IOAddress + GRAPH_ADDRESS_PORT), 0x0d);

      //
      // read in extended id
      //
      ucTemp = VideoPortReadPortUchar(IOAddress + GRAPH_DATA_PORT) ;
      ulReturn |= ((ULONG)(ucTemp)) << 8 ;

      //
      // is second extended id info available ?
      //
      if (ucTemp & EXTENDED_ID2_BIT) {

	 VideoPortWritePortUchar((PUCHAR)(IOAddress + GRAPH_ADDRESS_PORT), 0x0e);

	 //
	 // read in second extended id
	 //
	 ucTemp = VideoPortReadPortUchar(IOAddress + GRAPH_DATA_PORT) ;
	 ulReturn |= ((ULONG)(ucTemp)) << 16 ;
	 }
      }

 return (ulReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\mini\dactype.c ===
//---------------------------------------------------------------------------
/*++

Copyright (c) 1993  Compaq Computer Corporation

Module Name:

    dactype.c

Abstract:

    This module contains the code for identification of Compaq
    Display Controller DACs


Environment:

    kernel mode only

Notes:

Revision History:
   $0006
      miked: 02/17/1994
	. took out conditional debug code to satisfy MSBHPD

   $0004
      miked: 1/26/1994
	 . Added debug print code without all the other DBG overhead

  12/1/93 Mike Duke Original module started as start for NT version of QRY
		    library.
--*/
//---------------------------------------------------------------------------

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"
#include "qvision.h"

#include "qry_nt.h"

ULONG
QRY_DACType( PUCHAR IOAddress )
/*++
   Function: QRY_DACType

   This function returns the DAC type of the current controller.  It
   should only be called to distinguish between 484 & 485.

   NOTE: THIS FUNCTION SHOULD ONLY BE CALLED IF ON A QVISION OR LATER
	 CONTROLLER.  THIS FUNCTION WILL NOT QUERY FOR EARLIER COMPAQ
	 TYPE DAC's LIKE 471 ETC.

   Return value:
    Returns one of a discrete set of values which indicates
    the type of the current display controller's DAC.  Only one of these
    values will be returned.


    The DAC types returned are:

      QRY_DAC_UNKNOWN		0	     // Unknown DAC type
      QRY_DAC_BT484		4	     // Bt484 or compatible
      QRY_DAC_BT485		5	     // Bt485 or compatible



--*/
//---------------------------------------------------------------------------
{
   ULONG ulDACType = QRY_DAC_UNKNOWN ;
   UCHAR ucID1, ucTemp ;


   //
   // get id and mask off all of the following:
   //	  - version bits (2-0)
   //	  - extended id byte
   //	  - extended id2 byte

   ucID1 = (UCHAR)(QRY_ControllerASICID( IOAddress ) & 0xf8);

   //
   // if V32 or V35 then we need to query for 485 DAC
   // otherwise assume 484 DAC
   //

   switch (ucID1) {

      case 0x70: // V32 or V35

	      ucTemp = VideoPortReadPortUchar((PUCHAR)DAC_CMD_1);
              VideoPortWritePortUchar((PUCHAR)DAC_CMD_1,
                                      (UCHAR)(ucTemp & 0x7F));

	      if (VideoPortReadPortUchar((PUCHAR)DAC_STATUS_REG) & 0x80) {

		 //
		 // Juniper type board
		 //
		 ulDACType = QRY_DAC_BT485 ;
		 // DebugPrint((1,"QRY_DACType: (Juniper) Found 485 DAC.\n"));

              }
	      else {

		 //
		 // Fir type board
		 //
		 ulDACType = QRY_DAC_BT484 ;
		 // DebugPrint((1,"QRY_DACType: (Fir) Found 484 DAC.\n"));

              }

              //
              // restore register contents
              //
              VideoPortWritePortUchar((PUCHAR)DAC_CMD_1,ucTemp);
	      break;

      case 0x30: // QVision 1024 original ASIC

	      ulDACType = QRY_DAC_BT484;
	      // DebugPrint((1,"QRY_DACType: (Orig. QVision) Assume 484 DAC.\n"));
	      break;

      default:
	 break;
      }
 return ( ulDACType );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\mini\modeqv.h ===
/*++

Copyright (c) 1992  Microsoft Corporation
Copyright (c) 1993  Compaq Computer Corporation

Module Name:

    modeqv.h

Abstract:

    This module contains the mode information to set the individual
    modes for the QVision card.  This module also contains the CRTC
    register information for a monitor set.

Environment:

    Kernel mode

Revision History:


   $0005 - MikeD - 02/08/94
	 . modified to work with build 547's new display.cpl
   $0004
      miked: 1/26/1994
	 . Added third party monitor support to force a 76Hz refresh rate

    Adrian Crisan - First version 4/4/93.

--*/

//
// Constants
//

//
// QVision register definitions
//
                                            // port in mono mode
#define ATT_INITIALIZE_PORT_MONO    INPUT_STATUS_1_MONO
                                            // Register to read to reset
                                            // Attribute Controller index/data
					    // toggle in mono mode

#define ATT_INITIALIZE_PORT_COLOR   INPUT_STATUS_1_COLOR
                                            // Register to read to reset
                                            // Attribute Controller index/data
					    // toggle in color mode
// Aries Specific register equates

#define ARIES_CTL_1 	0x63CA		    // Aries BitBlt Control Register 1
#define DAC_CMD_2	0x13C9		    // Aries DAC Command Register 2
#define OVERFLOW_REG_1	0x42		    // Aries Gfx Ctrl Overflow Reg 1
#define OVERFLOW_REG_2	0x51		    // Aries Gfx Ctrl Overflow Reg 2
#define CO_COLOR_WRITE	0x83C8		    // Aries Cursor/Overscan Write Index Reg
#define CO_COLOR_DATA	0x83c9		    // Aries Cursor/Overscan Data Reg
#define HIGH_ADDR_MAP	0x48		    // Index for High Addr Map register


//
// Graphics Miscellaneous Register     - Index 0x06
//
#define MISC_REG	      0x06	    // Graphics Miscellaneous Register
#define MISC_A0000_128K	      0x00	    // 128K video ram starting at A0000
#define MISC_A0000_64K	      0x04	    // 64K  video ram starting at A0000
#define MISC_B0000_32K	      0x08	    // 32K  video ram starting at B0000
#define MISC_B8000_32K	      0x0C	    // 32K  video ram starting at B8000

//
// Register defines for the QVClearScreen code which uses the BitBLT engin
//
#define ROPSELECT_NO_ROPS      0x00
#define PIXELMASK_ONLY	       0x00
#define PLANARMASK_NONE_0XFF   0x04
#define SRC_IS_PATTERN_REGS    0x02
#define PREG_0		       0x33CA
#define PREG_1		       0x33CB
#define PREG_2		       0x33CC
#define PREG_3		       0x33CD
#define PREG_4		       0x33CA
#define PREG_5		       0x33CB
#define PREG_6		       0x33CC
#define PREG_7		       0x33CD
#define BLT_DEST_ADDR_LO       0x63CC
#define BLT_DEST_ADDR_HI       0x63CE
#define BITMAP_WIDTH	       0x23C2
#define BITMAP_HEIGHT	       0x23C4
#define BLT_CMD_0	       0x33CE
#define BLT_CMD_1	       0x33CF
#define XY_SRC_ADDR	       0x40
#define XY_DEST_ADDR	       0x80
#define BLT_FORWARD	       0x00
#define BLT_START	       0x01
#define GLOBAL_BUSY_BIT        0x40

//
// QVision indexed register indexes.
//

#define IND_CURSOR_START        0x0A        // index in CRTC of the Cursor Start
#define IND_CURSOR_END          0x0B        //  and End registers
#define IND_CURSOR_HIGH_LOC     0x0E        // index in CRTC of the Cursor Location
#define IND_CURSOR_LOW_LOC      0x0F        //  High and Low Registers
#define IND_VSYNC_END           0x11        // index in CRTC of the Vertical Sync
                                            //  End register, which has the bit
                                                                                                         //  that protects/unprotects CRTC
                                                                                                         //  index registers 0-7
#define IND_READ_MAP            0x04        // index of Read Map reg in Graph Ctlr
#define IND_BIT_MASK            0x08        // index of Bit Mask reg in Graph Ctlr
#define IND_SYNC_RESET          0x00        // index of Sync Reset reg in Seq
#define IND_MEMORY_MODE         0x04        // index of Memory Mode reg in Seq

#define START_SYNC_RESET_VALUE  0x01        // value for Sync Reset reg to start
                                            //  synchronous reset
#define END_SYNC_RESET_VALUE    0x03        // value for Sync Reset reg to end

#define MEMORY_MAP_BASE 0x23c6              // Juniper memory map base register
#define CTRL_REG_2      0x23c7              // Juniper control register 2
#define CTRL_REG_3      0x63cb              // Juniper control register 3
//
//  Global Variables
//

//
//  Mode commands for inidividual modes.
//
#define VALID_MODE   0x01                   // monitor supports mode index
#define INVALID_MODE 0x00                   // monitor does not support mode index


//////////////////////////////////////////////////////////////
//    Mode index 0
//    Color text mode 3+, 720x400, 9x16 char cell (VGA)
//    BIOS mode: 0x03
//////////////////////////////////////////////////////////////
#define QV_TEXT_720x400x4_INDEX  0

USHORT QV_TEXT_720x400x4[] = {

   OW,                                      // start sync reset
   SEQ_ADDRESS_PORT,
   IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8),

   OWM,
   SEQ_ADDRESS_PORT,
   4,
   0x0001,0x0302,0x0003,0x0204,             // program up sequencer

   //
   // Set the Miscellaneous Output register to establish color/mono addressing
   // and select clocks and sync polarities.
   // Synchronous reset must be in effect while this register is being set,
   // because it contains clock control bits.
   //
   OB,                                      // output a byte
   MISC_OUTPUT_REG_WRITE_PORT,              // at this address
   0x67,                                    // with this value


   OW,
   GRAPH_ADDRESS_PORT,
   0x0e06,

   OW,                                      // End sync reset
   SEQ_ADDRESS_PORT,
   IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

   OW,                                      // unlock extended registers
   GRAPH_ADDRESS_PORT,
   0x050f,

   OW,                                      // enable BitBlt engine
   GRAPH_ADDRESS_PORT,                      // and disable IRQ 9
   0x2810,

   QVNEW+ARIES,                             // make sure this is an aries mode

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   DAC_CMD_0,                               // 83c6
   0x01,
   0x00,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   DAC_CMD_1,
   0x01,
   0x00,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   DAC_CMD_2,
   0x01,
   0x20,

   OW,
   CRTC_ADDRESS_PORT_COLOR,
   0x0511,

   //
   // Set all 25 CRT Controller registers.
   //
   METAOUT+INDXOUT,                         // program crtc registers
   CRTC_ADDRESS_PORT_COLOR,
   VGA_NUM_CRTC_PORTS,                      // count
   0,                                       // start index
   0x5F,0x4f,0x50,0x82,
   0x55,0x81,0xbf,0x1f,
   0x00,0x4f,0x0d,0x0e,
   0x00,0x00,0x00,0x00,
   0x9c,0xBe,0x8f,0x28,
   0x1f,0x96,0xb9,0xa3,
   0xFF,

   IB,                                      // prepare atc for writing
   INPUT_STATUS_1_COLOR,

   METAOUT+ATCOUT,                          //
   ATT_ADDRESS_PORT,                        // port
   VGA_NUM_ATTRIB_CONT_PORTS,               // count
   0,                                       // start index
   0x0,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
   0x04,0x0,0x0F,0x08,0x0,

   METAOUT+INDXOUT,                         //
   GRAPH_ADDRESS_PORT,                      // port
   VGA_NUM_GRAPH_CONT_PORTS,                // count
   0,                                       // start index
   0x00,0x0,0x0,0x0,0x0,0x10,0x0e,0x0,0xFF,

   OB,
   DAC_PIXEL_MASK_PORT,
   0xFF,

   IB,                                      // prepare atc for writing
   INPUT_STATUS_1_COLOR,

   OB,                                      // turn video on.
   ATT_ADDRESS_PORT,
   VIDEO_ENABLE,

   EOD

}; // QV_TEXT_720x400x4

//////////////////////////////////////////////////////////////
//    Mode index 1
//    Color text mode 3, 640x350, 8x14 char cell (EGA)
//    BIOS mode:0x10
//////////////////////////////////////////////////////////////
#define QV_TEXT_640x350x4_INDEX  1

USHORT QV_TEXT_640x350x4[] = {
   OW,                                     // start sync reset
   SEQ_ADDRESS_PORT,
   IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8),

   OWM,
   SEQ_ADDRESS_PORT,
   4,
   0x0101,0x0302,0x0003,0x0204,            // program up sequencer

   OB,
   MISC_OUTPUT_REG_WRITE_PORT,
   0xA3,

   OW,
   GRAPH_ADDRESS_PORT,
   0x0e06,

   OW,                                     // end sync reset
   SEQ_ADDRESS_PORT,
   IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

   OW,                                      // unlock extended registers
   GRAPH_ADDRESS_PORT,
   0x050f,

   OW,                                      // enable BitBlt engine
   GRAPH_ADDRESS_PORT,                      // and disable IRQ 9
   0x2810,

   QVNEW+ARIES,                             // make sure this is an aries mode

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   DAC_CMD_0,                               // 83c6
   0x01,
   0x00,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   DAC_CMD_1,
   0x01,
   0x00,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   DAC_CMD_2,
   0x01,
   0x20,

   OW,
   CRTC_ADDRESS_PORT_COLOR,
   0x0511,

   METAOUT+INDXOUT,                        // program crtc registers
   CRTC_ADDRESS_PORT_COLOR,
   VGA_NUM_CRTC_PORTS,                     // count
   0,                                      // start index
   0x5F,0x4f,0x50,0x82,
   0x55,0x81,0xbf,0x1f,
   0x00,0x4d,0x0b,0x0c,
   0x00,0x00,0x00,0x00,
   0x83,0xB5,0x5d,0x28,
   0x1f,0x63,0xba,0xa3,
   0xFF,

   IB,                                     // prepare atc for writing
   INPUT_STATUS_1_COLOR,

   METAOUT+ATCOUT,                         //
   ATT_ADDRESS_PORT,                       // port
   VGA_NUM_ATTRIB_CONT_PORTS,              // count
   0,                                      // start index
   0x00,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
   0x00,0x00,0x0F,0x00,0x00,

   METAOUT+INDXOUT,                        //
   GRAPH_ADDRESS_PORT,                     // port
   VGA_NUM_GRAPH_CONT_PORTS,               // count
   0,                                      // start index
   0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,0x0FF,

   OB,
   DAC_PIXEL_MASK_PORT,
   0xFF,

   IB,                                     // prepare atc for writing
   INPUT_STATUS_1_COLOR,

   OB,                                     // turn video on.
   ATT_ADDRESS_PORT,
   VIDEO_ENABLE,

   EOD
}; // QV_TEXT_640x350x4


//////////////////////////////////////////////////////////////
//    Mode index 2
//    Standard VGA Color graphics, 640x480x4 - 16 colors
//    BIOS mode: 0x12
//////////////////////////////////////////////////////////////
#define QV_TEXT_640x480x4_INDEX   2

USHORT QV_TEXT_640x480x4[] = {
   OW,                                      // start sync reset
   SEQ_ADDRESS_PORT,
   IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8),

   OWM,
   SEQ_ADDRESS_PORT,
   4,
   0x0101,0x0f02,0x0003,0x0604,             // program up sequencer


   OB,
   MISC_OUTPUT_REG_WRITE_PORT,
   0xe3,

   OW,                                      //{ SetGraphCmd,{ "\x05", 0x06, 1 } },
   GRAPH_ADDRESS_PORT,
   0x0506,

   OW,                                      // End Sync reset
   SEQ_ADDRESS_PORT,
   IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

   OW,                                      // unlock extended registers
   GRAPH_ADDRESS_PORT,
   0x050f,

   OW,                                      // enable BitBlt engine
   GRAPH_ADDRESS_PORT,                      // and disable IRQ 9
   0x2810,

   QVNEW+ARIES,                             // make sure this is an aries mode

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   DAC_CMD_0,                               // 83c6
   0x01,
   0x00,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   DAC_CMD_1,
   0x01,
   0x00,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   DAC_CMD_2,
   0x01,
   0x20,

   OW,
   CRTC_ADDRESS_PORT_COLOR,
   0x0511,

   METAOUT+INDXOUT,                         // program crtc registers
   CRTC_ADDRESS_PORT_COLOR,
   VGA_NUM_CRTC_PORTS,                      // count
   0,                                       // start index
   0x5F,0x4F,0x50,0x82,
   0x54,0x80,0x0B,0x3E,
   0x00,0x40,0x00,0x00,
   0x00,0x00,0x00,0x00,
   0xEA,0xBC,0xDF,0x28,
   0x00,0xE7,0x04,0xE3,
   0xFF,

   IB,                                      // prepare atc for writing
   INPUT_STATUS_1_COLOR,

   METAOUT+ATCOUT,                          //
   ATT_ADDRESS_PORT,                        // port
   VGA_NUM_ATTRIB_CONT_PORTS,               // count
   0,                                       // start index
   0x00,0x01,0x02,0x03,0x04,
   0x05,0x14,0x07,0x38,0x39,
   0x3A,0x3B,0x3C,0x3D,0x3E,
   0x3F,0x01,0x00,0x0F,0x00,0x00,

   METAOUT+INDXOUT,                         //
   GRAPH_ADDRESS_PORT,                      // port
   VGA_NUM_GRAPH_CONT_PORTS,                // count
   0,                                       // start index
   0x00,0x0,0x0,0x0,0x0,0x0,0x05,0x0F,0x0FF,

   OB,
   DAC_PIXEL_MASK_PORT,
   0xFF,

   IB,                                      // prepare atc for writing
   INPUT_STATUS_1_COLOR,

   OB,                                      // turn video on.
   ATT_ADDRESS_PORT,
   VIDEO_ENABLE,

   EOD

}; // QV_TEXT_640x480x4

//////////////////////////////////////////////////////////////
//    Mode index 3
//    VGA Color graphics, 640x480x8 - 256 colors
//    BIOS mode: 0x32
//////////////////////////////////////////////////////////////
#define QV_640x480x8_INDEX    3

USHORT QV_640x480x8[] = {
   QVNEW+SETRAM,                                // set aries videoram

   OW,                                          // unlock extended registers
   GRAPH_ADDRESS_PORT,
   0x050f,

   OW,                                          // start sync reset
   SEQ_ADDRESS_PORT,
   IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8),

   OWM,
   SEQ_ADDRESS_PORT,
   4,
   0x0101,0xff02,0x0003,0x0e04,                 // program up sequencer


   OW,                                  // set seq memory register 4 to 0x0e
   SEQ_ADDRESS_PORT,
   0x0e04,

   OB,                                          // FIX VGA BUG
   SEQ_ADDRESS_PORT,
   0x07,

   IB,
   MISC_OUTPUT_REG_WRITE_OFFSET,

   OW,                                          // END FIX VGA BUG
   CRTC_ADDRESS_COLOR_OFFSET,
   0x013f,

   OW,                                          // end synch reset
   SEQ_ADDRESS_PORT,
   IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

   OW,                                          // unlock extended registers
   GRAPH_ADDRESS_PORT,
   0x050f,

   OW,                                          // Set AVGA mode
   GRAPH_ADDRESS_PORT,                          // 3ce
   0x0140,

   OW,                                      // set pixel write mask reg to ff
   SEQ_ADDRESS_PORT,                        // 3c4
   0xFF02,                                  // enable 256 colors again

   OW,                                      // enable BitBlt engine
   GRAPH_ADDRESS_PORT,                      // and disable IRQ 9
   0x2810,

   QVCMD+BYTE2PORT,                         // enable 8BPP Aries Mode
   ARIES_CTL_1,
   0x01,
   0x03,

   QVNEW+ARIES,                             // make sure this is an aries mode

   QVCMD+SETMISCOUT,                        // set MISC OUT registers based
                                            // on monitor type

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   DAC_CMD_0,
   0x01,
   0x00,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   DAC_CMD_1,
   0x01,
   0x40,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   DAC_CMD_2,
   0x01,
   0x20,

   OW,                                      // unlock the CRTC registers
   CRTC_ADDRESS_PORT_COLOR,
   0x0011,

   QVCMD+SETMONCRTC,                        // Set monitor specific CRTC registers

   QVCMD+SETMONOVFLW,                       // Set monitor specific overflow register

   OW,                                      // write 0 to Overflow_reg_1
   GRAPH_ADDRESS_PORT,                      // register (index 42)
   0x0042,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   CO_COLOR_WRITE,
   0x01,
   0x00,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   CO_COLOR_DATA,
   0x01,
   0x00,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   CO_COLOR_DATA,
   0x01,
   0x00,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   CO_COLOR_DATA,
   0x01,
   0x00,


   IB,                                      // prepare atc for writing
   INPUT_STATUS_1_COLOR,

   METAOUT+ATCOUT,                          //
   ATT_ADDRESS_PORT,                        // port
   VGA_NUM_ATTRIB_CONT_PORTS,               // count
   0,                                       // start index
   0x00,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
   0x41,0x00,0x0F,0x00,0x00,


   OWM,                                     // program the graphics controller
   GRAPH_ADDRESS_PORT,
   VGA_NUM_GRAPH_CONT_PORTS,
   0x0000, 0x0001, 0x0002, 0x0003,
   0x0004, 0x0005, 0x0506, 0x0f07,
   0xFF08,

   OB,
   DAC_PIXEL_MASK_PORT,
   0xFF,

   IB,                                      // prepare atc for writing
   INPUT_STATUS_1_COLOR,

   OB,                                      // turn video on.
   ATT_ADDRESS_PORT,
   VIDEO_ENABLE,

   EOD
}; // QV_640x480x8

//////////////////////////////////////////////////////////////
//    Mode index 4
//    SVGA color graphics, 800x600x8 - 256 colors
//    BIOS Mode: 0x34.
//////////////////////////////////////////////////////////////
#define QV_800x600x8_INDEX    4

USHORT QV_800x600x8[] = {
   QVNEW+SETRAM,                            // set aries videoram

   OW,                                      // unlock extended registers
   GRAPH_ADDRESS_PORT,
   0x050f,

   OW,                                      // start synch reset
   SEQ_ADDRESS_PORT,
   IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8),

   OWM,
   SEQ_ADDRESS_PORT,
   4,
   0x0101,0xff02,0x0003,0x0e04,             // program up sequencer

   OW,                                      // set seq memory register 4 to 0x0e
   SEQ_ADDRESS_PORT,
   0x0e04,

   OB,                                      // FIX VGA BUG
   SEQ_ADDRESS_PORT,
   0x07,

   IB,
   MISC_OUTPUT_REG_WRITE_OFFSET,

   OW,                                      // END FIX VGA BUG
   CRTC_ADDRESS_COLOR_OFFSET,
   0x013f,

   OW,                                      // End sync reset
   SEQ_ADDRESS_PORT,
   IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

   OW,                                      // unlock extended registers
   GRAPH_ADDRESS_PORT,
   0x050f,

   OW,                                      // Set AVGA mode
   GRAPH_ADDRESS_PORT,                      // 3ce
   0x0140,

   OW,                                      // set pixel write mask reg to ff
   SEQ_ADDRESS_PORT,                        // 3c4
   0xFF02,

   OW,                                      // enable BitBlt engine
   GRAPH_ADDRESS_PORT,                      // and disable IRQ 9
   0x2810,

   QVCMD+BYTE2PORT,                         // enable 8BPP Aries Mode
   ARIES_CTL_1,
   0x01,
   0x03,

   QVNEW+ARIES,                             // make sure this is an aries mode

   QVCMD+SETMISCOUT,                        // set MISC OUT registers based
                                            // on monitor type

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   DAC_CMD_0,
   0x01,
   0x00,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   DAC_CMD_1,
   0x01,
   0x40,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   DAC_CMD_2,
   0x01,
   0x20,

   OW,                                      // unlock the CRTC registers
   CRTC_ADDRESS_PORT_COLOR,
   0x0011,

   QVCMD+SETMONCRTC,                        // Set monitor specific CRTC registers

   QVCMD+SETMONOVFLW,                       // Set monitor specific overflow register

   OW,                                      // write 0 to Overflow_reg_1
   GRAPH_ADDRESS_PORT,                      // register (index 42)
   0x0042,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   CO_COLOR_WRITE,
   0x01,
   0x00,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   CO_COLOR_DATA,
   0x01,
   0x00,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   CO_COLOR_DATA,
   0x01,
   0x00,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   CO_COLOR_DATA,
   0x01,
   0x00,


   IB,                                      // prepare atc for writing
   INPUT_STATUS_1_COLOR,

   METAOUT+ATCOUT,                          //
   ATT_ADDRESS_PORT,                        // port
   VGA_NUM_ATTRIB_CONT_PORTS,               // count
   0,                                       // start index
   0x00,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
   0x41,0x00,0x0F,0x00,0x00,


   OWM,                                     // program the graphics controller
   GRAPH_ADDRESS_PORT,
   VGA_NUM_GRAPH_CONT_PORTS,
   0x0000, 0x0001, 0x0002, 0x0003,
   0x0004, 0x0005, 0x0506, 0x0F07,
   0xFF08,

   OB,
   DAC_PIXEL_MASK_PORT,
   0xFF,

   IB,                                      // prepare atc for writing
   INPUT_STATUS_1_COLOR,

   OB,                                      // turn video on.
   ATT_ADDRESS_PORT,
   VIDEO_ENABLE,

   EOD
}; // QV_800x600x8


//////////////////////////////////////////////////////////////
//    Mode index 5
//    SVGA color graphics, 1024x768x8 - 256 colors
//    BIOS mode:0x38
//////////////////////////////////////////////////////////////
#define QV_1024x768x8_INDEX   5

USHORT QV_1024x768x8[] = {
   QVNEW+SETRAM,                            // set aries videoram

   OW,                                      // unlock extended registers
   GRAPH_ADDRESS_PORT,
   0x050f,

   OW,                                      // start synch reset
   SEQ_ADDRESS_PORT,
   IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8),

   OWM,
   SEQ_ADDRESS_PORT,
   4,
   0x0101,0xff02,0x0003,0x0e04,             // program up sequencer

   OW,                                      // set seq memory register 4 to 0x0e
   SEQ_ADDRESS_PORT,
   0x0e04,

   OB,                                      // FIX VGA BUG
   SEQ_ADDRESS_PORT,
   0x07,

   IB,
   MISC_OUTPUT_REG_WRITE_OFFSET,

   OW,                                      // END FIX VGA BUG
   CRTC_ADDRESS_COLOR_OFFSET,
   0x013f,

   OW,                                      // end synch reset
   SEQ_ADDRESS_PORT,
   IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

   OW,                                      // unlock extended registers
   GRAPH_ADDRESS_PORT,
   0x050f,

   OW,                                      // Set AVGA mode
   GRAPH_ADDRESS_PORT,                      // 3ce
   0x0140,

   OW,                                      // set pixel write mask reg to ff
   SEQ_ADDRESS_PORT,                        // 3c4
   0xFF02,

   OW,                                      // enable BitBlt engine
   GRAPH_ADDRESS_PORT,                      // and disable IRQ 9
   0x2810,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   ARIES_CTL_1,                             // 63ca
   0x01,
   0x03,

   QVNEW+ARIES,                             // make sure this is an aries mode

   QVCMD+SETMISCOUT,                        // set MISC_OUT register according
                                            // to the connected monitor.

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   DAC_CMD_0,                               // 83c6
   0x01,
   0x00,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   DAC_CMD_1,                               // 13c8
   0x01,
   0x40,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   DAC_CMD_2,                               // 13c9
   0x01,
   0x20,

   OW,                                      // unlock the CRTC registers
   CRTC_ADDRESS_PORT_COLOR,
   0x0011,

   QVCMD+SETMONCRTC,                        // Set monitor specific CRTC registers

   QVCMD+SETMONOVFLW,                       // Set monitor specific overflow register

   OW,                                      // Set the Overflow_reg_1
   GRAPH_ADDRESS_PORT,
   0x0042,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   CO_COLOR_WRITE,                          // 83c8
   0x01,
   0x00,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   CO_COLOR_DATA,                           // 83c9
   0x01,
   0x00,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   CO_COLOR_DATA,                           // 83c9
   0x01,
   0x00,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   CO_COLOR_DATA,                           // 83c9
   0x01,
   0x00,


   IB,                                      // prepare atc for writing
   INPUT_STATUS_1_COLOR,

   METAOUT+ATCOUT,                          //
   ATT_ADDRESS_PORT,                        // port
   VGA_NUM_ATTRIB_CONT_PORTS,               // count
   0,                                       // start index
   0x00,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
   0x41,0x00,0x0F,0x00,0x00,


   OWM,                                     // program the graphics controller
   GRAPH_ADDRESS_PORT,
   VGA_NUM_GRAPH_CONT_PORTS,
   0x0000, 0x0001, 0x0002, 0x0003,
   0x0004, 0x0005, 0x0506, 0x0F07,
   0xFF08,

   OB,
   DAC_PIXEL_MASK_PORT,
   0xFF,

   IB,                                      // prepare atc for writing
   INPUT_STATUS_1_COLOR,

   OB,                                      // turn video on.
   ATT_ADDRESS_PORT,
   VIDEO_ENABLE,

   EOD
}; // QV_1024x768x8


//////////////////////////////////////////////////////////////
//    Mode index 6
//    SVGA color graphics, 1280x1024x8 - 256 colors
//    BIOS mode:0x3A
//////////////////////////////////////////////////////////////
#define QV_1280x1024x8_INDEX   6

USHORT QV_1280x1024x8[] = {
   QVNEW+SETRAM,                            // set aries videoram

   OW,                                      // unlock extended registers
   GRAPH_ADDRESS_PORT,
   0x050f,

   OW,                                      // start synch reset
   SEQ_ADDRESS_PORT,
   IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8),

   OWM,
   SEQ_ADDRESS_PORT,
   4,
   0x0101,0xff02,0x0003,0x0e04,             // program up sequencer

   OW,                                      // set seq memory register 4 to 0x0e
   SEQ_ADDRESS_PORT,
   0x0e04,

   OB,                                      // FIX VGA BUG
   SEQ_ADDRESS_PORT,
   0x07,

   IB,
   MISC_OUTPUT_REG_WRITE_OFFSET,

   OW,                                      // END FIX VGA BUG
   CRTC_ADDRESS_COLOR_OFFSET,
   0x013f,

   OW,                                      // end synch reset
   SEQ_ADDRESS_PORT,
   IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

   OW,                                      // unlock extended registers
   GRAPH_ADDRESS_PORT,
   0x050f,

   OW,                                      // Set ORION mode
   GRAPH_ADDRESS_PORT,                      // 3ce
   0x0140,

   OW,                                      // set pixel write mask reg to ff
   SEQ_ADDRESS_PORT,                        // 3c4
   0xFF02,

   OW,                                      // enable BitBlt engine
   GRAPH_ADDRESS_PORT,                      // and disable IRQ 9
   0x2810,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   ARIES_CTL_1,                             // 63ca
   0x01,
   0x03,

   QVNEW+V32,                               // Set board in V32 mode

   QVCMD+SETMISCOUT,                        // set MISC_OUT register according
                                            // to the connected monitor.

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   DAC_CMD_0,                               // 83c6
   0x01,
   0x80,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   DAC_CMD_1,                               // 13c8
   0x01,
   0x40,

   // VidalL 04/25/93
   //
   // IMPORTANT: DAC Command register 2 should really be included in the
   // =========  CRTC parameters because of the following:
   //            Qvision 200 monitors (at 76Hz) require the use of pixel
   //            clock 2, which means value 30.  However, the 68Hz
   //            and 60Hz timings require pixel clock 1, which means
   //            value 20.  So, when 60 and 68Hz timings are used, default
   //            to value 20.  But if a Qvision monitor is being used
   //            (CPQ MON), then must changed this value to 30 !!!
   //            Otherwise, the screen will NOT sync in 1280 resolution
   //
   //            DAC_CMD_2 is set by the QVNEW+V32 command. It must NOT
   //            be set later in this stream !!! Otherwise, 1280 may
   //            may not sync on the monitor.
   //
   // VidalL 04/25/93

//   QVCMD+BYTE2PORT,                         // setup DAC control registers
//   DAC_CMD_2,                               // 13c9
//   0x01,
//   0x30  or  0x20,


   QVCMD+BYTE2PORT,                         // setup DAC control registers
   DAC_STATUS_REG,                          // 13c6
   0x01,
   0x08,

   OW,                                      // unlock the CRTC registers
   CRTC_ADDRESS_PORT_COLOR,
   0x0011,

   QVCMD+SETMONCRTC,                        // Set monitor specific CRTC registers

   QVCMD+SETMONOVFLW,                       // Set monitor specific overflow register

   OW,                                      // Set the Overflow_reg_1
   GRAPH_ADDRESS_PORT,
   0x0142,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   CO_COLOR_WRITE,                          // 83c8
   0x01,
   0x00,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   CO_COLOR_DATA,                           // 83c9
   0x01,
   0x00,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   CO_COLOR_DATA,                           // 83c9
   0x01,
   0x00,

   QVCMD+BYTE2PORT,                         // setup DAC control registers
   CO_COLOR_DATA,                           // 83c9
   0x01,
   0x00,


   IB,                                      // prepare atc for writing
   INPUT_STATUS_1_COLOR,

   METAOUT+ATCOUT,                          //
   ATT_ADDRESS_PORT,                        // port
   VGA_NUM_ATTRIB_CONT_PORTS,               // count
   0,                                       // start index
   0x00,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
   0x41,0x00,0x0F,0x00,0x00,


   OWM,                                     // program the graphics controller
   GRAPH_ADDRESS_PORT,
   VGA_NUM_GRAPH_CONT_PORTS,
   0x0000, 0x0001, 0x0002, 0x0003,
   0x0004, 0x0005, 0x0506, 0x0F07,
   0xFF08,

   OB,
   DAC_PIXEL_MASK_PORT,
   0xFF,

   IB,                                      // prepare atc for writing
   INPUT_STATUS_1_COLOR,

   OB,                                      // turn video on.
   ATT_ADDRESS_PORT,
   VIDEO_ENABLE,

   EOD
}; // QV_1280x1024x8


//
//
//    The MonData is an array of bytes of the following format:
//    MONCLASS, ModeIndex, Validity, MiscOut, Overflow,
//    25 CRT register values.
//
//      MONCLASS  = The monitor type from the structure
//      ModeIndex = index of the mode (look above)
//      Validity  = 1 if this MONCLASS supports mode.
//      MiscOut   = Misc Out register value for this mode.
//      Overflow  = Overflow 2 register value for this mode.
//      The rest are register values for consecutive CRT registers.
//
//    If the mode is INVALID_MODE then the CRT registers are
//    not put in the array.  This will allow us to move
//    quickly through an array which contains many invalid modes.
//    We know that if the mode is VALID_MODE, we will have 25
//    register values after the Validity value for that mode.
//
//    An INVALID_MODE does not necessarily mean that the
//    particular mode index is not support on the monitor.
//    It only means that for that particular mode we do not
//    have to program the CRTC registers.
//
//
//$DEL$//USHORT usMonData[] = {
//$DEL$//   Monitor_Vga, QV_TEXT_720x400x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_Vga, QV_TEXT_640x350x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_Vga, QV_TEXT_640x480x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_Vga, QV_640x480x8_INDEX, VALID_MODE, 0xef, 0x08,
//$DEL$//      0x5f, 0x4f, 0x50, 0x81, 0x53, 0x9f, 0x0b, 0x3e, 0x00, 0x40,
//$DEL$//      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xea, 0xbc, 0xdf, 0x80,
//$DEL$//      0x00, 0xe5, 0x03, 0xe3, 0xff,
//$DEL$//   Monitor_Vga, QV_800x600x8_INDEX, INVALID_MODE,
//$DEL$//   Monitor_Vga, QV_1024x768x8_INDEX, INVALID_MODE,
//$DEL$//   Monitor_Vga, QV_1280x1024x8_INDEX, INVALID_MODE,
//$DEL$//
//$DEL$//   Monitor_AG1024, QV_TEXT_720x400x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_AG1024, QV_TEXT_640x350x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_AG1024, QV_TEXT_640x480x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_AG1024, QV_640x480x8_INDEX, VALID_MODE, 0xef, 0x08,
//$DEL$//      0x5f, 0x4f, 0x50, 0x81, 0x53, 0x9f, 0x0b, 0x3e, 0x00, 0x40,
//$DEL$//      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xea, 0xbc, 0xdf, 0x80,
//$DEL$//      0x00, 0xe5, 0x03, 0xe3, 0xff,
//$DEL$//   Monitor_AG1024, QV_800x600x8_INDEX, INVALID_MODE,
//$DEL$//   Monitor_AG1024, QV_1024x768x8_INDEX, VALID_MODE, 0x2b, 0x00,
//$DEL$//      0xa9, 0x7f, 0x7f, 0x0a, 0x87, 0x9f, 0x2e, 0xf5, 0x00, 0x60,
//$DEL$//      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xba, 0xff, 0x80,
//$DEL$//      0x00, 0xff, 0x2c, 0xe3, 0xff,
//$DEL$//   Monitor_AG1024, QV_1280x1024x8_INDEX, INVALID_MODE,
//$DEL$//
//$DEL$//   Monitor_Qvision, QV_TEXT_720x400x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_Qvision, QV_TEXT_640x350x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_Qvision, QV_TEXT_640x480x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_Qvision, QV_640x480x8_INDEX, VALID_MODE, 0xef, 0x08,
//$DEL$//      0x5f, 0x4f, 0x50, 0x81, 0x53, 0x9f, 0x0b, 0x3e, 0x00, 0x40,
//$DEL$//      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xea, 0xbc, 0xdf, 0x80,
//$DEL$//      0x00, 0xe5, 0x03, 0xe3, 0xff,
//$DEL$//   Monitor_Qvision, QV_800x600x8_INDEX, VALID_MODE, 0x23, 0x20,
//$DEL$//      0x8b, 0x63, 0x66, 0x8b, 0x6d, 0x1d, 0xe9, 0xf0, 0x00, 0x60,
//$DEL$//      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0xba, 0x57, 0x80,
//$DEL$//      0x00, 0x6e, 0xd1, 0xe3, 0xff,
//$DEL$//   Monitor_Qvision, QV_1024x768x8_INDEX, VALID_MODE, 0x2b, 0x00,
//$DEL$//      0x9e, 0x7f, 0x7f, 0x81, 0x83, 0x93, 0x1e, 0xf1, 0x00, 0x60,
//$DEL$//      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xb3, 0xff, 0x80,
//$DEL$//      0x00, 0xff, 0x1e, 0xe3, 0xff,
//$DEL$//   Monitor_Qvision, QV_1280x1024x8_INDEX, INVALID_MODE,
//$DEL$//
//$DEL$//   Monitor_1280, QV_TEXT_720x400x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_1280, QV_TEXT_640x350x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_1280, QV_TEXT_640x480x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_1280, QV_640x480x8_INDEX, VALID_MODE, 0xf3, 0x28,
//$DEL$//      0x69, 0x4f, 0x55, 0x86, 0x58, 0x80, 0x56, 0xb2, 0x00, 0x60,
//$DEL$//      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0xb3, 0xdf, 0x80,
//$DEL$//      0x00, 0x01, 0x32, 0xe3, 0xff,
//$DEL$//   Monitor_1280, QV_800x600x8_INDEX, VALID_MODE, 0x23, 0x20,
//$DEL$//      0x8b, 0x63, 0x66, 0x8b, 0x6d, 0x1d, 0xe9, 0xf0, 0x00, 0x60,
//$DEL$//      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0xba, 0x57, 0x80,
//$DEL$//      0x00, 0x6e, 0xd1, 0xe3, 0xff,
//$DEL$//   Monitor_1280, QV_1024x768x8_INDEX, VALID_MODE, 0x2b, 0x00,
//$DEL$//      0x9e, 0x7f, 0x7f, 0x81, 0x83, 0x93, 0x1e, 0xf1, 0x00, 0x60,
//$DEL$//      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xb3, 0xff, 0x80,
//$DEL$//      0x00, 0xff, 0x1e, 0xe3, 0xff,
//$DEL$//   Monitor_1280, QV_1280x1024x8_INDEX, VALID_MODE, 0x27, 0xe8,
//$DEL$//      0xca, 0x9f, 0x9f, 0x8d, 0xa6, 0x1a, 0x24, 0x5a, 0x00, 0x60,
//$DEL$//      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xb5, 0xff, 0x00,
//$DEL$//      0x00, 0xff, 0x24, 0xe3, 0xff,
//$DEL$//
//$DEL$//   Monitor_SVGA, QV_TEXT_720x400x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_SVGA, QV_TEXT_640x350x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_SVGA, QV_TEXT_640x480x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_SVGA, QV_640x480x8_INDEX, VALID_MODE, 0xef, 0x08,
//$DEL$//      0x5f, 0x4f, 0x50, 0x81, 0x53, 0x9f, 0x0b, 0x3e, 0x00, 0x40,
//$DEL$//      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xea, 0xbc, 0xdf, 0x80,
//$DEL$//      0x00, 0xe5, 0x03, 0xe3, 0xff,
//$DEL$//   Monitor_SVGA, QV_800x600x8_INDEX, VALID_MODE, 0xf3, 0x20,
//$DEL$//      0x7f, 0x63, 0x64, 0x80, 0x68, 0x19, 0x73, 0xf0, 0x00, 0x60,
//$DEL$//      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0xbc, 0x57, 0x80,
//$DEL$//      0x00, 0x58, 0x72, 0xe3, 0xff,
//$DEL$//   Monitor_SVGA, QV_1024x768x8_INDEX, INVALID_MODE,
//$DEL$//   Monitor_SVGA, QV_1280x1024x8_INDEX, INVALID_MODE,
//$DEL$//
//$DEL$//   Monitor_60Hz, QV_TEXT_720x400x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_60Hz, QV_TEXT_640x350x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_60Hz, QV_TEXT_640x480x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_60Hz, QV_640x480x8_INDEX, VALID_MODE, 0xef, 0x08,
//$DEL$//      0x5f, 0x4f, 0x50, 0x81, 0x53, 0x9f, 0x0b, 0x3e, 0x00, 0x40,
//$DEL$//      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xea, 0xbc, 0xdf, 0x80,
//$DEL$//      0x00, 0xe5, 0x03, 0xe3, 0xff,
//$DEL$//   Monitor_60Hz, QV_800x600x8_INDEX, VALID_MODE, 0xf3, 0x20,
//$DEL$//      0x7f, 0x63, 0x64, 0x80, 0x68, 0x19, 0x73, 0xf0, 0x00, 0x60,
//$DEL$//      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0xbc, 0x57, 0x80,
//$DEL$//      0x00, 0x58, 0x72, 0xe3, 0xff,
//$DEL$//   Monitor_60Hz, QV_1024x768x8_INDEX, VALID_MODE, 0xe3, 0x00,
//$DEL$//      0x9b, 0x7f, 0x7f, 0x9e, 0x87, 0x17, 0x31, 0xf5, 0x00, 0x60,
//$DEL$//      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0xb4, 0xff, 0x80,
//$DEL$//      0x00, 0xff, 0x31, 0xe3, 0xff,
//$DEL$//   Monitor_60Hz, QV_1280x1024x8_INDEX, VALID_MODE, 0x23, 0xc8,
//$DEL$//      0xed, 0x9f, 0x9f, 0x10, 0xae, 0x90, 0x2a, 0x5a, 0x00, 0x60,
//$DEL$//      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xb7, 0xff, 0x00,
//$DEL$//      0x00, 0xff, 0x2a, 0xe3, 0xff,
//$DEL$//
//$DEL$//   Monitor_66Hz, QV_TEXT_720x400x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_66Hz, QV_TEXT_640x350x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_66Hz, QV_TEXT_640x480x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_66Hz, QV_640x480x8_INDEX, INVALID_MODE,
//$DEL$//   Monitor_66Hz, QV_800x600x8_INDEX, INVALID_MODE,
//$DEL$//   Monitor_66Hz, QV_1024x768x8_INDEX, VALID_MODE, 0x2b, 0x00,
//$DEL$//      0xa9, 0x7f, 0x7f, 0x0a, 0x87, 0x9f, 0x2e, 0xf5, 0x00, 0x60,
//$DEL$//      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xba, 0xff, 0x80,
//$DEL$//      0x00, 0xff, 0x2c, 0xe3, 0xff,
//$DEL$//   Monitor_66Hz, QV_1280x1024x8_INDEX, INVALID_MODE,
//$DEL$//
//$DEL$//   Monitor_68Hz, QV_TEXT_720x400x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_68Hz, QV_TEXT_640x350x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_68Hz, QV_TEXT_640x480x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_68Hz, QV_640x480x8_INDEX, INVALID_MODE,
//$DEL$//   Monitor_68Hz, QV_800x600x8_INDEX, INVALID_MODE,
//$DEL$//   Monitor_68Hz, QV_1024x768x8_INDEX, INVALID_MODE,
//$DEL$//   Monitor_68Hz, QV_1280x1024x8_INDEX, VALID_MODE, 0x23, 0xe8,
//$DEL$//      0xcf, 0x9f, 0x9f, 0x12, 0xa4, 0x19, 0x2e, 0x5a, 0x00, 0x60,
//$DEL$//      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xbb, 0xff, 0x00,
//$DEL$//      0x00, 0xff, 0x2e, 0xe3, 0xff,
//$DEL$//
//$DEL$//   Monitor_72Hz, QV_TEXT_720x400x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_72Hz, QV_TEXT_640x350x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_72Hz, QV_TEXT_640x480x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_72Hz, QV_640x480x8_INDEX, INVALID_MODE,
//$DEL$//   Monitor_72Hz, QV_800x600x8_INDEX, VALID_MODE, 0x23, 0x20,
//$DEL$//      0x8b, 0x63, 0x66, 0x8b, 0x6d, 0x1d, 0xe9, 0xf0, 0x00, 0x60,
//$DEL$//      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0xba, 0x57, 0x80,
//$DEL$//      0x00, 0x6e, 0xd1, 0xe3, 0xff,
//$DEL$//   Monitor_72Hz, QV_1024x768x8_INDEX, VALID_MODE, 0x2b, 0x00,
//$DEL$//      0x9e, 0x7f, 0x7f, 0x81, 0x83, 0x93, 0x1e, 0xf1, 0x00, 0x60,
//$DEL$//      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xb3, 0xff, 0x80,
//$DEL$//      0x00, 0xff, 0x1e, 0xe3, 0xff,
//$DEL$//   Monitor_72Hz, QV_1280x1024x8_INDEX, INVALID_MODE,
//$DEL$//
//$DEL$//   Monitor_75Hz, QV_TEXT_720x400x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_75Hz, QV_TEXT_640x350x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_75Hz, QV_TEXT_640x480x4_INDEX, INVALID_MODE,
//$DEL$//   Monitor_75Hz, QV_640x480x8_INDEX, INVALID_MODE,
//$DEL$//   Monitor_75Hz, QV_800x600x8_INDEX, INVALID_MODE,
//$DEL$//   Monitor_75Hz, QV_1024x768x8_INDEX, VALID_MODE, 0x2b, 0x00,
//$DEL$//      0x97, 0x7f, 0x7f, 0x9a, 0x82, 0x0f, 0x1f, 0xf1, 0x00, 0x60,
//$DEL$//      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xb4, 0xff, 0x80,
//$DEL$//      0x00, 0xfe, 0x1f, 0xe3, 0x00,
//$DEL$//
//$DEL$//   // Monitor_75Hz, QV_1280x1024x8_INDEX, INVALID_MODE,
//$DEL$//
//$DEL$//   //
//$DEL$//   // $0004 ************  miked 1/26/1994 *****************************
//$DEL$//   //
//$DEL$//   //Added third party monitor support to force a 76Hz refresh rate
//$DEL$//   //using the same timings as the QV200 timings.
//$DEL$//   //
//$DEL$//   //Note: The MonClass entry for 75Hz was used, because it was available
//$DEL$//   //	    and much less overhead than adding a new level to the array
//$DEL$//   //	    of monitor timings; so even though the "Monitor_75Hz" is used
//$DEL$//   //	    here, it really maps to 76Hz.
//$DEL$//   //
//$DEL$//   //	***************************************************************
//$DEL$//   Monitor_75Hz, QV_1280x1024x8_INDEX, VALID_MODE, 0x27, 0xe8,
//$DEL$//      0xca, 0x9f, 0x9f, 0x8d, 0xa6, 0x1a, 0x24, 0x5a, 0x00, 0x60,
//$DEL$//      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xb5, 0xff, 0x00,
//$DEL$//      0x00, 0xff, 0x24, 0xe3, 0xff,
//$DEL$//}; // usMonData

//
// $0005 - MikeD - 02/08/94
//  Daytona - new monitor data structure array
//

MONTYPE MonData[] = {
   //
   // Monitor_Vga
   //
   QV_TEXT_720x400x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_TEXT_640x350x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_TEXT_640x480x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_640x480x8_INDEX, VALID_MODE, 0xef, 0x08,
      0x5f, 0x4f, 0x50, 0x81, 0x53, 0x9f, 0x0b, 0x3e, 0x00, 0x40,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xea, 0xbc, 0xdf, 0x80,
      0x00, 0xe5, 0x03, 0xe3, 0xff,
   QV_800x600x8_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_1024x768x8_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_1280x1024x8_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,

   //
   // Monitor_AG1024
   //
   QV_TEXT_720x400x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_TEXT_640x350x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_TEXT_640x480x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_640x480x8_INDEX, VALID_MODE, 0xef, 0x08,
      0x5f, 0x4f, 0x50, 0x81, 0x53, 0x9f, 0x0b, 0x3e, 0x00, 0x40,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xea, 0xbc, 0xdf, 0x80,
      0x00, 0xe5, 0x03, 0xe3, 0xff,
   QV_800x600x8_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_1024x768x8_INDEX, VALID_MODE, 0x2b, 0x00,
      0xa9, 0x7f, 0x7f, 0x0a, 0x87, 0x9f, 0x2e, 0xf5, 0x00, 0x60,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xba, 0xff, 0x80,
      0x00, 0xff, 0x2c, 0xe3, 0xff,
   QV_1280x1024x8_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,

   //
   // Monitor_Qvision
   //
   QV_TEXT_720x400x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_TEXT_640x350x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_TEXT_640x480x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_640x480x8_INDEX, VALID_MODE, 0xef, 0x08,
      0x5f, 0x4f, 0x50, 0x81, 0x53, 0x9f, 0x0b, 0x3e, 0x00, 0x40,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xea, 0xbc, 0xdf, 0x80,
      0x00, 0xe5, 0x03, 0xe3, 0xff,
   QV_800x600x8_INDEX, VALID_MODE, 0x23, 0x20,
      0x8b, 0x63, 0x66, 0x8b, 0x6d, 0x1d, 0xe9, 0xf0, 0x00, 0x60,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0xba, 0x57, 0x80,
      0x00, 0x6e, 0xd1, 0xe3, 0xff,
   QV_1024x768x8_INDEX, VALID_MODE, 0x2b, 0x00,
      0x9e, 0x7f, 0x7f, 0x81, 0x83, 0x93, 0x1e, 0xf1, 0x00, 0x60,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xb3, 0xff, 0x80,
      0x00, 0xff, 0x1e, 0xe3, 0xff,
   QV_1280x1024x8_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,

   //
   // Monitor_1280
   //
   QV_TEXT_720x400x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_TEXT_640x350x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_TEXT_640x480x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_640x480x8_INDEX, VALID_MODE, 0xf3, 0x28,
      0x69, 0x4f, 0x55, 0x86, 0x58, 0x80, 0x56, 0xb2, 0x00, 0x60,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0xb3, 0xdf, 0x80,
      0x00, 0x01, 0x32, 0xe3, 0xff,
   QV_800x600x8_INDEX, VALID_MODE, 0x23, 0x20,
      0x8b, 0x63, 0x66, 0x8b, 0x6d, 0x1d, 0xe9, 0xf0, 0x00, 0x60,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0xba, 0x57, 0x80,
      0x00, 0x6e, 0xd1, 0xe3, 0xff,
   QV_1024x768x8_INDEX, VALID_MODE, 0x2b, 0x00,
      0x9e, 0x7f, 0x7f, 0x81, 0x83, 0x93, 0x1e, 0xf1, 0x00, 0x60,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xb3, 0xff, 0x80,
      0x00, 0xff, 0x1e, 0xe3, 0xff,
   QV_1280x1024x8_INDEX, VALID_MODE, 0x27, 0xe8,
      0xca, 0x9f, 0x9f, 0x8d, 0xa6, 0x1a, 0x24, 0x5a, 0x00, 0x60,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xb5, 0xff, 0x00,
      0x00, 0xff, 0x24, 0xe3, 0xff,

   //
   // Monitor_SVGA
   //
   QV_TEXT_720x400x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_TEXT_640x350x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_TEXT_640x480x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_640x480x8_INDEX, VALID_MODE, 0xef, 0x08,
      0x5f, 0x4f, 0x50, 0x81, 0x53, 0x9f, 0x0b, 0x3e, 0x00, 0x40,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xea, 0xbc, 0xdf, 0x80,
      0x00, 0xe5, 0x03, 0xe3, 0xff,
   QV_800x600x8_INDEX, VALID_MODE, 0xf3, 0x20,
      0x7f, 0x63, 0x64, 0x80, 0x68, 0x19, 0x73, 0xf0, 0x00, 0x60,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0xbc, 0x57, 0x80,
      0x00, 0x58, 0x72, 0xe3, 0xff,
   QV_1024x768x8_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_1280x1024x8_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,

   //
   // Monitor_60Hz
   //
   QV_TEXT_720x400x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_TEXT_640x350x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_TEXT_640x480x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_640x480x8_INDEX, VALID_MODE, 0xef, 0x08,
      0x5f, 0x4f, 0x50, 0x81, 0x53, 0x9f, 0x0b, 0x3e, 0x00, 0x40,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xea, 0xbc, 0xdf, 0x80,
      0x00, 0xe5, 0x03, 0xe3, 0xff,
   QV_800x600x8_INDEX, VALID_MODE, 0xf3, 0x20,
      0x7f, 0x63, 0x64, 0x80, 0x68, 0x19, 0x73, 0xf0, 0x00, 0x60,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0xbc, 0x57, 0x80,
      0x00, 0x58, 0x72, 0xe3, 0xff,
   QV_1024x768x8_INDEX, VALID_MODE, 0xe3, 0x00,
      0x9b, 0x7f, 0x7f, 0x9e, 0x87, 0x17, 0x31, 0xf5, 0x00, 0x60,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0xb4, 0xff, 0x80,
      0x00, 0xff, 0x31, 0xe3, 0xff,
   QV_1280x1024x8_INDEX, VALID_MODE, 0x23, 0xc8,
      0xed, 0x9f, 0x9f, 0x10, 0xae, 0x90, 0x2a, 0x5a, 0x00, 0x60,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xb7, 0xff, 0x00,
      0x00, 0xff, 0x2a, 0xe3, 0xff,

   //
   // Monitor_66Hz
   //
   QV_TEXT_720x400x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_TEXT_640x350x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_TEXT_640x480x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_640x480x8_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_800x600x8_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_1024x768x8_INDEX, VALID_MODE, 0x2b, 0x00,
      0xa9, 0x7f, 0x7f, 0x0a, 0x87, 0x9f, 0x2e, 0xf5, 0x00, 0x60,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xba, 0xff, 0x80,
      0x00, 0xff, 0x2c, 0xe3, 0xff,
   QV_1280x1024x8_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,

   //
   // Monitor_68Hz
   //
   QV_TEXT_720x400x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_TEXT_640x350x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_TEXT_640x480x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_640x480x8_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_800x600x8_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_1024x768x8_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_1280x1024x8_INDEX, VALID_MODE, 0x23, 0xe8,
      0xcf, 0x9f, 0x9f, 0x12, 0xa4, 0x19, 0x2e, 0x5a, 0x00, 0x60,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xbb, 0xff, 0x00,
      0x00, 0xff, 0x2e, 0xe3, 0xff,

   //
   // Monitor_72Hz
   //
   QV_TEXT_720x400x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_TEXT_640x350x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_TEXT_640x480x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_640x480x8_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_800x600x8_INDEX, VALID_MODE, 0x23, 0x20,
      0x8b, 0x63, 0x66, 0x8b, 0x6d, 0x1d, 0xe9, 0xf0, 0x00, 0x60,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0xba, 0x57, 0x80,
      0x00, 0x6e, 0xd1, 0xe3, 0xff,
   QV_1024x768x8_INDEX, VALID_MODE, 0x2b, 0x00,
      0x9e, 0x7f, 0x7f, 0x81, 0x83, 0x93, 0x1e, 0xf1, 0x00, 0x60,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xb3, 0xff, 0x80,
      0x00, 0xff, 0x1e, 0xe3, 0xff,
   QV_1280x1024x8_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,

   //
   // Monitor_75Hz
   //
   QV_TEXT_720x400x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_TEXT_640x350x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_TEXT_640x480x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_640x480x8_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_800x600x8_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_1024x768x8_INDEX, VALID_MODE, 0x2b, 0x00,
      0x97, 0x7f, 0x7f, 0x9a, 0x82, 0x0f, 0x1f, 0xf1, 0x00, 0x60,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xb4, 0xff, 0x80,
      0x00, 0xfe, 0x1f, 0xe3, 0x00,
   QV_1280x1024x8_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,

   //
   // Monitor_76Hz
   //
   QV_TEXT_720x400x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_TEXT_640x350x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_TEXT_640x480x4_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_640x480x8_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_800x600x8_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_1024x768x8_INDEX, INVALID_MODE, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
   QV_1280x1024x8_INDEX, VALID_MODE, 0x27, 0xe8,
      0xca, 0x9f, 0x9f, 0x8d, 0xa6, 0x1a, 0x24, 0x5a, 0x00, 0x60,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xb5, 0xff, 0x00,
      0x00, 0xff, 0x24, 0xe3, 0xff,
}; // MonData

//
//    This array contains a set of boolean values with the
//    following properties.
//    If a monitor supports a specified mode, the value
//    is TRUE.  If the monitor does not support the mode,
//    the value is FALSE.
//    +++++++++++++++++++++++++++++++++++++
//    ++++++++++++++ IMPORTANT ++++++++++++
//    +++++++++++++++++++++++++++++++++++++
//    The NUM_VIDEO_MODES value must be hardcoded because
//    a non constant value cannot be the index of an
//    array.
//    This value must be changed when new modes are added.
//    Currently, the QVISION BIOS does not support 800x600x8 so
//    we set these modes to be invalid if INT10 is chosen
//    as the initialization avenue.
//
#define NUM_VIDEO_MODES    7    // must be hardcoded for the fValidMode array.

BOOLEAN fValidMode[NUM_MONITOR_CLASSES][NUM_VIDEO_MODES] = {

//////////////////////////////////////////////////////////////
//  Monitor_Vga
//////////////////////////////////////////////////////////////
   TRUE,                                    // text 640x350 (EGA)
   TRUE,                                    // text 640x480 (VGA)
   TRUE,                                    // text 720x400 (VGA)
   TRUE,                                    // 640x480x8
#ifdef INIT_INT10                           // The Qvision hardware does not
   FALSE,                                   // support 800x600x8 in BIOS
#else                                       // so we always set this mode
   FALSE,                                   // to be invalid. (for now)
#endif
   FALSE,                                   // 1024x768x8
   FALSE,                                   // 1280x1024x8
//////////////////////////////////////////////////////////////
//  Monitor_AG1024
//////////////////////////////////////////////////////////////
   TRUE,                                    // text 640x350 (EGA)
   TRUE,                                    // text 640x480 (VGA)
   TRUE,                                    // text 720x400 (VGA)
   TRUE,                                    // 640x480x8
#ifdef INIT_INT10                           // The Qvision hardware does not
   FALSE,                                   // support 800x600x8 in BIOS
#else                                       // so we always set this mode
   FALSE,                                   // to be invalid. (for now)
#endif
   TRUE,                                    // 1024x768x8
   FALSE,                                   // 1280x1024x8
//////////////////////////////////////////////////////////////
//  Monitor_Qvision
//////////////////////////////////////////////////////////////
   TRUE,                                    // text 640x350 (EGA)
   TRUE,                                    // text 640x480 (VGA)
   TRUE,                                    // text 720x400 (VGA)
   TRUE,                                    // 640x480x8
#ifdef INIT_INT10                           // The Qvision hardware does not
   FALSE,                                   // support 800x600x8 in BIOS
#else                                       // so we always set this mode
   TRUE,                                    // to be invalid. (for now)
#endif
   TRUE,                                    // 1024x768x8
   FALSE,                                   // 1280x1024x8
//////////////////////////////////////////////////////////////
//  Monitor_1280
//////////////////////////////////////////////////////////////
   TRUE,                                    // text 640x350 (EGA)
   TRUE,                                    // text 640x480 (VGA)
   TRUE,                                    // text 720x400 (VGA)
   TRUE,                                    // 640x480x8
#ifdef INIT_INT10                           // The Qvision hardware does not
   FALSE,                                   // support 800x600x8 in BIOS
#else                                       // so we always set this mode
   TRUE,                                    // to be invalid. (for now)
#endif
   TRUE,                                    // 1024x768x8
   TRUE,                                    // 1280x1024x8
//////////////////////////////////////////////////////////////
//  Monitor_SVGA
//////////////////////////////////////////////////////////////
   TRUE,                                    // text 640x350 (EGA)
   TRUE,                                    // text 640x480 (VGA)
   TRUE,                                    // text 720x400 (VGA)
   TRUE,                                    // 640x480x8
#ifdef INIT_INT10                           // The Qvision hardware does not
   FALSE,                                   // support 800x600x8 in BIOS
#else                                       // so we always set this mode
   TRUE,                                    // to be invalid. (for now)
#endif
   FALSE,                                   // 1024x768x8
   FALSE,                                   // 1280x1024x8
//////////////////////////////////////////////////////////////
//    Monitor_60Hz
//////////////////////////////////////////////////////////////
   TRUE,                                    // text 640x350 (EGA)
   TRUE,                                    // text 640x480 (VGA)
   TRUE,                                    // text 720x400 (VGA)
   TRUE,                                    // 640x480x8
#ifdef INIT_INT10                           // The Qvision hardware does not
   FALSE,                                   // support 800x600x8 in BIOS
#else                                       // so we always set this mode
   TRUE,                                    // to be invalid. (for now)
#endif
   TRUE,                                    // 1024x768x8
   TRUE,                                    // 1280x1024x8
//////////////////////////////////////////////////////////////
//  Monitor_66Hz
//////////////////////////////////////////////////////////////
   TRUE,                                    // text 640x350 (EGA)
   TRUE,                                    // text 640x480 (VGA)
   TRUE,                                    // text 720x400 (VGA)
   FALSE,                                   // 640x480x8
#ifdef INIT_INT10                           // The Qvision hardware does not
   FALSE,                                   // support 800x600x8 in BIOS
#else                                       // so we always set this mode
   FALSE,                                   // to be invalid. (for now)
#endif
   TRUE,                                    // 1024x768x8
   FALSE,                                   // 1280x1024x8
//////////////////////////////////////////////////////////////
//    Monitor_68Hz
//////////////////////////////////////////////////////////////
   TRUE,                                    // text 640x350 (EGA)
   TRUE,                                    // text 640x480 (VGA)
   TRUE,                                    // text 720x400 (VGA)
   FALSE,                                   // 640x480x8
#ifdef INIT_INT10                           // The Qvision hardware does not
   FALSE,                                   // support 800x600x8 in BIOS
#else                                       // so we always set this mode
   FALSE,                                   // to be invalid. (for now)
#endif
   FALSE,                                   // 1024x768x8
   TRUE,                                    // 1280x1024x8
//////////////////////////////////////////////////////////////
//  Monitor_72Hz
//////////////////////////////////////////////////////////////
   TRUE,                                    // text 640x350 (EGA)
   TRUE,                                    // text 640x480 (VGA)
   TRUE,                                    // text 720x400 (VGA)
   FALSE,                                   // 640x480x8
#ifdef INIT_INT10                           // The Qvision hardware does not
   FALSE,                                   // support 800x600x8 in BIOS
#else                                       // so we always set this mode
   TRUE,                                    // to be invalid. (for now)
#endif
   TRUE,                                    // 1024x768x8
   FALSE,                                   // 1280x1024x8
//////////////////////////////////////////////////////////////
//    Monitor_75Hz
//////////////////////////////////////////////////////////////
   TRUE,                                    // text 640x350 (EGA)
   TRUE,                                    // text 640x480 (VGA)
   TRUE,                                    // text 720x400 (VGA)
   FALSE,                                   // 640x480x8
#ifdef INIT_INT10                           // The Qvision hardware does not
   FALSE,                                   // support 800x600x8 in BIOS
#else                                       // so we always set this mode
   FALSE,                                   // to be invalid. (for now)
#endif
   TRUE,				    // 1024x768x8
   FALSE,				    // 1280x1024x8
//////////////////////////////////////////////////////////////
//    Monitor_76Hz
//////////////////////////////////////////////////////////////
   TRUE,                                    // text 640x350 (EGA)
   TRUE,                                    // text 640x480 (VGA)
   TRUE,                                    // text 720x400 (VGA)
   FALSE,                                   // 640x480x8
#ifdef INIT_INT10                           // The Qvision hardware does not
   FALSE,                                   // support 800x600x8 in BIOS
#else                                       // so we always set this mode
   FALSE,                                   // to be invalid. (for now)
#endif
   FALSE,				    // 1024x768x8
   TRUE					    // 1280x1024x8

}; // fValidMode


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\mini\modeset.c ===
/*++

Copyright (c) 1992  Microsoft Corporation
Copyright (c) 1993  Compaq Computer Corporation

Module Name:

    modeset.c

Abstract:

    This is the modeset code for the QVision miniport driver.

Environment:

    kernel mode only

Notes:


Revision History:
   $0007
      MikeD: 06/17/1994
        . fixed switch statement in VgaSetMode() to set proper full-screen
            mode (problem found in Japanese NT)
   $0006
      miked: 02/17/1994
        . took out conditional debug code to satisfy MSBHPD
   $0005 - MikeD - 02/08/94
         . modified to work with build 547's new display.cpl

   $0004
      miked: 1/26/1994
         . Added debug print code without all the other DBG overhead
         . Added third party monitor support to force a 76Hz refresh rate



--*/
#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"
#include "qvision.h"
#include "modeset.h"


VOID
VgaZeroVideoMemory(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );


VOID
SetQVisionBanking(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG BankNumber
    );

//---------------------------------------------------------------------------
VP_STATUS
VgaInterpretCmdStream(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUSHORT pusCmdStream
    )

/*++

Routine Description:

    Interprets the appropriate command array to set up VGA registers for the
    requested mode. Typically used to set the VGA into a particular mode by
    programming all of the registers

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    pusCmdStream - array of commands to be interpreted.

Return Value:

    The status of the operation (can only fail on a bad command); TRUE for
    success, FALSE for failure.

--*/

{
    ULONG ulCmd;                            /* OP code for the Cmd stream */
    ULONG ulPort;                           /* address port for the command */
    UCHAR jValue;                           /* byte value to use in operation */
    USHORT usValue;                         /* word value to use in operation */
    ULONG culCount;                         /* number of values in the command */
    ULONG ulIndex;                          /* index to start from in the indexed command */
    ULONG ulBase;                           /* base */
//    PUSHORT pusTempMonData;                /* temporary CRTCData pointer */
//    ULONG ulEndOfMonData;                 // address of the end of the MonData array

    ULONG resIndex, monIndex;               // indexes into MonData
    PMONRES pMonRes;                        // pointer to MONRES

    VideoDebugPrint((1, "QVision.sys: VgaInterpretCmdStream - ENTRY.\n"));

    if (pusCmdStream == NULL) {

        VideoDebugPrint((1, "\tInvalid pusCmdStream\n"));
        return TRUE;
    }

    ulBase = (ULONG)HwDeviceExtension->IOAddress;

    //
    // Now set the adapter to the desired mode.
    //

    while ((ulCmd = *pusCmdStream++) != EOD) {

        //
        // Determine major command type
        //

        switch (ulCmd & 0xF0) {

            //
            // Basic input/output command
            //

            case INOUT:
               VideoDebugPrint((2,"\tINOUT - "));

                //
                // Determine type of inout instruction
                //

                if (!(ulCmd & IO)) {

                    //
                    // Out instruction. Single or multiple outs?
                    //

                    if (!(ulCmd & MULTI)) {
                        VideoDebugPrint((2,"SINGLE OUT - "));

                        //
                        // Single out. Byte or word out?
                        //

                        if (!(ulCmd & BW)) {
                           VideoDebugPrint((2,"BYTE\n"));

                            //
                            // Single byte out
                            //

                            ulPort = *pusCmdStream++;
                            jValue = (UCHAR) *pusCmdStream++;
                            VideoPortWritePortUchar((PUCHAR)(ulBase+ulPort),
                                    jValue);

                            if (ulPort == MISC_OUTPUT_REG_WRITE_PORT) {

                                //
                                // $0006 - MikeD - 03/04/94
                                //  Begin: add 10 millisecond delay after r/w
                                //         of 3c2
                                //
                                //         10000microsecs = 10ms
                                //
                                // I know I should not stall more than 50, but
                                // there is no other way around this...

                                VideoPortStallExecution( 10000 );
                            }

                        } else {

                           VideoDebugPrint((2,"WORD\n"));

                            //
                            // Single word out
                            //

                            ulPort = *pusCmdStream++;
                            usValue = *pusCmdStream++;
                            VideoPortWritePortUshort((PUSHORT)(ulBase+ulPort),
                                    usValue);

                        }

                    } else {
                        VideoDebugPrint((2,"MULTIPLE OUTS - "));

                        //
                        // Output a string of values
                        // Byte or word outs?
                        //

                        if (!(ulCmd & BW)) {
                            VideoDebugPrint((2,"BYTES\n"));

                            //
                            // String byte outs. Do in a loop; can't use
                            // VideoPortWritePortBufferUchar because the data
                            // is in USHORT form
                            //

                            ulPort = ulBase + *pusCmdStream++;
                            culCount = *pusCmdStream++;

                            while (culCount--) {
                                jValue = (UCHAR) *pusCmdStream++;
                                VideoPortWritePortUchar((PUCHAR)ulPort,
                                        jValue);

                            }

                        } else {
                            VideoDebugPrint((2,"WORDS\n"));

                            //
                            // String word outs
                            //

                            ulPort = *pusCmdStream++;
                            culCount = *pusCmdStream++;
                            VideoPortWritePortBufferUshort((PUSHORT)
                                    (ulBase + ulPort), pusCmdStream, culCount);
                            pusCmdStream += culCount;

                        }
                    }

                } else {
                    VideoDebugPrint((2,"SINGLE IN - "));

                    // In instruction
                    //
                    // Currently, string in instructions aren't supported; all
                    // in instructions are handled as single-byte ins
                    //
                    // Byte or word in?
                    //

                    if (!(ulCmd & BW)) {
                        VideoDebugPrint((2,"BYTE\n"));

                        //
                        // Single byte in
                        //

                        ulPort = *pusCmdStream++;
                        jValue = VideoPortReadPortUchar((PUCHAR)ulBase+ulPort);

                    } else {
                        VideoDebugPrint((2,"WORD\n"));

                        //
                        // Single word in
                        //

                        ulPort = *pusCmdStream++;
                        usValue = VideoPortReadPortUshort((PUSHORT)
                                (ulBase+ulPort));

                    }

                }

                break;

            //
            // Higher-level input/output commands
            //

            case METAOUT:
                VideoDebugPrint((2,"\tMETAOUT - "));

                //
                // Determine type of metaout command, based on minor
                // command field
                //
                switch (ulCmd & 0x0F) {

                    //
                    // Indexed outs
                    //

                    case INDXOUT:
                        VideoDebugPrint((2,"INDXOUT\n"));

                        ulPort = ulBase + *pusCmdStream++;
                        culCount = *pusCmdStream++;
                        ulIndex = *pusCmdStream++;

                        while (culCount--) {

                            usValue = (USHORT) (ulIndex +
                                      (((ULONG)(*pusCmdStream++)) << 8));
                            VideoPortWritePortUshort((PUSHORT)ulPort, usValue);

                            ulIndex++;

                        }

                        break;

                    //
                    // Masked out (read, AND, XOR, write)
                    //

                    case MASKOUT:
                        VideoDebugPrint((2,"MASKOUT\n"));

                        ulPort = *pusCmdStream++;
                        jValue = VideoPortReadPortUchar((PUCHAR)ulBase+ulPort);
                        jValue &= *pusCmdStream++;
                        jValue ^= *pusCmdStream++;
                        VideoPortWritePortUchar((PUCHAR)ulBase + ulPort,
                                jValue);
                        break;

                    //
                    // Attribute Controller out
                    //

                    case ATCOUT:
                        VideoDebugPrint((2,"ATCOUT\n"));

                        ulPort = ulBase + *pusCmdStream++;
                        culCount = *pusCmdStream++;
                        ulIndex = *pusCmdStream++;

                        while (culCount--) {

                            // Write Attribute Controller index
                            VideoPortWritePortUchar((PUCHAR)ulPort,
                                    (UCHAR)ulIndex);

                            // Write Attribute Controller data
                            jValue = (UCHAR) *pusCmdStream++;
                            VideoPortWritePortUchar((PUCHAR)ulPort, jValue);

                            ulIndex++;

                        }

                        break;


                    default:

                        return FALSE;

                }


                break;

            //
            // NOP
            //

            case NCMD:
                VideoDebugPrint((2,"\tNCMD\n"));

                break;

            case QVCMD:
                VideoDebugPrint((2,"\tQVCMDS - "));

                switch (ulCmd & 0x0F) {

                //
                // Set the CRTC registers based on the monitor which is currently
                // attached to the QVision card.
                // HwDeviceExtension->ModeIndex contains current mode index.
                // HwDeviceExtension->VideoHardware.MonClass = current monitor.
                //

                  case SETMONCRTC:

                     VideoDebugPrint((2,"SETMONCRTC\n"));
                     ulPort = ulBase + CRTC_ADDRESS_PORT_COLOR;

                     // $0005 - MikeD - 02/08/94
                     // Begin:-
                     //
                     // implemented direct indexing...
                     //

                     // get resolution index from requested mode
                     resIndex =
                        ModesVGA[HwDeviceExtension->ModeIndex].ulResIndex;

                     // get monitor index from monitor class
                     monIndex =
                        HwDeviceExtension->VideoHardware.MonClass;

                     // set direct pointer to specific MONRES element
                     // for clarity
                     pMonRes = &MonData[monIndex].MonitorResolution[resIndex];

                     //
                     // set CRTC registers if necessary
                     //
                     if (pMonRes->bRegsPresent) {

                        for (ulIndex = 0; ulIndex < 25; ulIndex++) {
                            usValue = (USHORT) (ulIndex +
                                      (ULONG) (pMonRes->crtRegisters[ulIndex] << 8));
                            VideoPortWritePortUshort((PUSHORT)ulPort, usValue);
                            }
                        }
                     //
                     // $0005 - MikeD - 02/08/94
                     // End:
                     //

                     break;


                  //
                  // Set the Overflow2 register based on the monitor
                  // which is currently attached to the QVision card.
                  //

                  case SETMONOVFLW:

                     VideoDebugPrint((2,"SETMONOVFLW\n"));

                     ulPort = ulBase + GRAPH_ADDRESS_PORT;
                     ulIndex = OVERFLOW_REG_2;

                     // $0005 - MikeD - 02/08/94
                     // Begin:
                     //
                     // implemented direct indexing...
                     //

                     // get resolution index from requested mode
                     resIndex =
                        ModesVGA[HwDeviceExtension->ModeIndex].ulResIndex;

                     // get monitor index from monitor class
                     monIndex =
                        HwDeviceExtension->VideoHardware.MonClass;

                     // set direct pointer to specific MONRES element
                     // for clarity
                     pMonRes = &MonData[monIndex].MonitorResolution[resIndex];

                     //
                     // set Overflow register if necessary
                     //
                     if (pMonRes->bRegsPresent) {

                         usValue = (USHORT) (ulIndex +
                                   (ULONG) (pMonRes->Overflow << 8));
                         VideoPortWritePortUshort((PUSHORT)ulPort, usValue);
                        }
                     //
                     // $0005 - MikeD - 02/08/94
                     // End:
                     //
                     break;


                  //
                  //  Set the Misc out register based on the monitor which
                  //  is currently attached to the QVision card.
                  //

                  case SETMISCOUT:

                     VideoDebugPrint((2,"SETMISCOUT\n"));
                     ulPort = ulBase + MISC_OUTPUT_REG_WRITE_PORT;

                     // $0005 - MikeD - 02/08/94
                     // Begin:
                     //
                     // implemented direct indexing...
                     //

                     // get resolution index from requested mode
                     resIndex =
                        ModesVGA[HwDeviceExtension->ModeIndex].ulResIndex;

                     // get monitor index from monitor class
                     monIndex =
                        HwDeviceExtension->VideoHardware.MonClass;

                     // set direct pointer to specific MONRES element
                     // for clarity
                     pMonRes = &MonData[monIndex].MonitorResolution[resIndex];

                     //
                     // set Misc OUT register if necessary
                     //
                     if (pMonRes->bRegsPresent) {

                         VideoPortWritePortUshort(
                                (PUSHORT)ulPort,
                                pMonRes->MiscOut);
                         //
                         // $0006 - MikeD - 03/04/94
                         //      Begin: add 10 millisecond delay after r/w
                         //             of 3c2
                         //
                         //         10000microsecs = 10ms
                         //
                         // I know I should not stall more than 50, but
                         // there is no other way around this...

                         VideoPortStallExecution( 10000 );

                     }

                     //
                     // $0005 - MikeD - 02/08/94
                     // End:
                     //
                     break;

                  //
                  // None of the above; error
                  //

                  //
                  //  Write directly to the port provided.  This is used for
                  //  writing to extended registers or to registers which are
                  //  not based on the IOAddress.
                  //  This can be used to write many bytes to a port if
                  //  it is auto-incremented.
                  //

                  case BYTE2PORT:
                     VideoDebugPrint((2,"BYTE2PORT\n"));
                     ulPort = *pusCmdStream++;
                     culCount = *pusCmdStream++;

                     while (culCount--) {
                        jValue = (UCHAR) *pusCmdStream++;
                        VideoPortWritePortUchar((PUCHAR)ulPort,
                                 jValue);

                     } // switch minor
                     break;

               } // switch major
                break;

            //
            //  This command initializes the ARIES memory before
            //  the adapter is configured.
            //

            case QVNEW:
               switch (ulCmd & 0x0F) {

                  //
                  //  We know that this is an ARIES mode.  The command set
                  //  before this command unlocked the extended registers by
                  //  writing a 0x05 to 3CF.0F and a 0x28 to 3CF.10.
                  //  We need to make sure that if we are on a Juniper
                  //  we set single clock, 1024 pitch, and we disable the
                  //  advanced Juniper modes.
                  //  We also disable the Juniper extended register decode.
                  //  After we do that, we must make sure that we unlock the
                  //  Aries extended registers for safety.  I don't know
                  //  if they are being locked by disabling the Juniper regs.
                  //

                  case ARIES:

                     VideoDebugPrint((2,"\t ARIES_MODE\n"));
                     if ((HwDeviceExtension->VideoHardware.AdapterType == JuniperIsa) ||
                         (HwDeviceExtension->VideoHardware.AdapterType == JuniperEisa))
                        {
                        VideoPortWritePortUchar((PUCHAR)ARIES_CTL_1,  // 1 pixel = 1 byte
                                                0x03);
                        VideoPortWritePortUchar((PUCHAR)CTRL_REG_2,  // ORION-12 register access
                                                0x10);
                        VideoPortWritePortUchar((PUCHAR)CTRL_REG_3,  // 1024 pixel pitch
                                                0x05);               // 1MB memory decode

                        jValue = VideoPortReadPortUchar((PUCHAR)DAC_CMD_1);
                        VideoPortWritePortUchar((PUCHAR)DAC_CMD_1,
                                                (UCHAR)(jValue | 0x80));
                        VideoPortWritePortUchar((PUCHAR)(HwDeviceExtension->IOAddress +
                                                         DAC_ADDRESS_WRITE_PORT),
                                                (UCHAR)(DAC_CMD_3_INDEX));

                        VideoPortWritePortUchar((PUCHAR)DAC_STATUS_REG,
                                                (UCHAR)(VideoPortReadPortUchar((PUCHAR)DAC_STATUS_REG) &
                                                      ~DBL_CLK));

                        VideoPortWritePortUchar((PUCHAR)CTRL_REG_2,  // disable ext Juniper regs
                                                0x00);

                        jValue = VideoPortReadPortUchar((PUCHAR)DAC_CMD_0);  // disable 485 modes.
                        VideoPortWritePortUchar((PUCHAR)DAC_CMD_0,
                                                (UCHAR)(jValue & 0x7F));
                        VideoPortWritePortUshort((PUSHORT)GRAPH_ADDRESS_PORT,  // unlock ext. regs
                                                0x050f);
                        VideoPortWritePortUshort((PUSHORT)GRAPH_ADDRESS_PORT,  // enable BitBlt
                                                0x2810);
                     } // if
                     break;
                  //
                  //  We know that his is a V32 mode.  In this case
                  //  make sure that the clock is doubled, the pitch
                  //  is 2048 and the Juniper extended registers are accessible.
                  //
                  case V32:
                    VideoDebugPrint((2,"\t JUNIPER_MODE\n"));

                    // VidalL 04/25/93
                    //
                    // IMPORTANT:
                    // ==========
                    // The AQUILLA monitor REQUIRES pixel clock 2 (value 30h)
                    // The 60Hz and 68Hz timings require pixel clock 1
                    // (value 20h). If this value is not set correctly for
                    // the correct monitor, then the 1280 screen WILL NOT
                    //  SYNC !!!!!  So, determine the correct value here below.
                    //

                    // if (HwDeviceExtension->VideoHardware.MonClass==Monitor_1280)
                    //     VideoPortWritePortUchar((PUCHAR)DAC_CMD_2, 0x30);
                    // else
                    //     VideoPortWritePortUchar((PUCHAR)DAC_CMD_2, 0x20);
                    //
                    //
/*** $0004 ************  miked 1/26/1994 *****************************
***
***  Added third party monitor support to force a 76Hz refresh rate
***  using the same timings as the QV200 timings.
***
***  Note: A new MonClass entry for 76Hz was used,
***             See modeqv.h.
***
***********************************************************************/

                    if (HwDeviceExtension->VideoHardware.MonClass==Monitor_1280 ||
                        HwDeviceExtension->VideoHardware.MonClass==Monitor_76Hz)
                           VideoPortWritePortUchar((PUCHAR)DAC_CMD_2, 0x30);
                    else
                           VideoPortWritePortUchar((PUCHAR)DAC_CMD_2, 0x20);

/***********************************************************************/

                     VideoPortWritePortUchar((PUCHAR)ARIES_CTL_1,  // 1 pixel = 1 byte
                                             0x03);
                     VideoPortWritePortUchar((PUCHAR)CTRL_REG_2,  // ORION-12 register access
                                             0x10);
                     VideoPortWritePortUchar((PUCHAR)CTRL_REG_3,  // 2048 pixel pitch
                                             0x09);               // 2MB memory decode

                     jValue = VideoPortReadPortUchar((PUCHAR)DAC_CMD_0);

                     VideoPortWritePortUchar((PUCHAR)DAC_CMD_0,
                                             (UCHAR)(jValue | 0x80));
                     VideoPortWritePortUchar((PUCHAR)(HwDeviceExtension->IOAddress +
                                                      DAC_ADDRESS_WRITE_PORT),

                                             (UCHAR)(DAC_CMD_3_INDEX));
                     VideoPortWritePortUchar((PUCHAR)DAC_STATUS_REG,
                                             (UCHAR)(VideoPortReadPortUchar((PUCHAR)DAC_STATUS_REG) |
                                                   DBL_CLK));
                     VideoPortWritePortUshort((PUSHORT)GRAPH_ADDRESS_PORT,  // unlock ext. regs
                                             0x050f);
                     VideoPortWritePortUshort((PUSHORT)GRAPH_ADDRESS_PORT,  // enable BitBlt
                                             0x2810);
                     break;

                  //
                  // For future V35 enhancements.
                  //

                  case V35:

                     break;

                  case SETRAM:

                     VideoDebugPrint((2,"SETRAM\n"));

                     VideoPortReadPortUchar((PUCHAR)0x03BA);
                     VideoPortReadPortUchar((PUCHAR)0x03DA);

                     VideoPortReadPortUchar((PUCHAR)(ulBase + ATT_ADDRESS_PORT));

                     VideoPortWritePortUchar((PUCHAR)(ulBase + DAC_PIXEL_MASK_PORT), 0x00);


                     // start sync reset for the sequencer
                     VideoPortWritePortUchar((PUCHAR)(ulBase + SEQ_ADDRESS_PORT),
                                             IND_SYNC_RESET);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + SEQ_DATA_PORT),
                                             START_SYNC_RESET_VALUE);

                     // set clock mode register 1 to 3c5.01 = 0x21 (turn off video and 8bit pixel
                     VideoPortWritePortUchar((PUCHAR)(ulBase + SEQ_ADDRESS_PORT),
                                             0x01);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + SEQ_DATA_PORT),
                                             0x21);

                     // set sequencer memory mode register 4 to 3c5.04 = 0x0e
                     VideoPortWritePortUchar((PUCHAR)(ulBase + SEQ_ADDRESS_PORT),
                                             IND_MEMORY_MODE);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + SEQ_DATA_PORT),
                                             0x0e);

                     // end sync reset for the sequencer
                     VideoPortWritePortUchar((PUCHAR)(ulBase + SEQ_ADDRESS_PORT),
                                             IND_SYNC_RESET);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + SEQ_DATA_PORT),
                                             END_SYNC_RESET_VALUE);

                     // unlock graphics registers 3cf.0f = 0x05
                     VideoPortWritePortUchar((PUCHAR)(ulBase + GRAPH_ADDRESS_PORT),
                                             0x0f);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + GRAPH_DATA_PORT),
                                             0x05);

                     // set aavga mode 3cf.40 = 0x01
                     VideoPortWritePortUchar((PUCHAR)(ulBase + GRAPH_ADDRESS_PORT),
                                             0x40);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + GRAPH_DATA_PORT),
                                             0x01);

                     // set sequencer memory pixel write mask register 2 to 3c5.02 = 0xff
                     VideoPortWritePortUchar((PUCHAR)(ulBase + SEQ_ADDRESS_PORT),
                                             0x02);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + SEQ_DATA_PORT),
                                             0xff);

                     // unlock BITBLT registers 3cf.10 = 0x28;
                     VideoPortWritePortUchar((PUCHAR)(ulBase + GRAPH_ADDRESS_PORT),
                                             0x10);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + GRAPH_DATA_PORT),
                                             0x28);

                     // control register 1 63ca = 0x03
                     VideoPortWritePortUchar((PUCHAR)ARIES_CTL_1, 0x03);

                     // misc output register 3c2 = 0x27
                     VideoPortWritePortUchar((PUCHAR)((PUCHAR)ulBase + MISC_OUTPUT_REG_WRITE_PORT),
                                             0x27);

                     //
                     // $0006 - MikeD - 03/04/94
                     // Begin: add 10 millisecond delay after r/w
                     //        of 3c2
                     //
                     //         10000microsecs = 10ms
                     //
                     // I know I should not stall more than 50, but
                     // there is no other way around this...

                     VideoPortStallExecution( 10000 );

                     // set high address registers
                     //
                     // adrianc 4/7/1993
                     //   We are starting off with Banking so we do not set
                     //   the HIGH ADDRESS register yet.
                     //
                     //$DEL$//  VideoPortWritePortUchar((PUCHAR)GRAPH_ADDRESS_PORT, HIGH_ADDR_MAP);
                     //$DEL$//  VideoPortWritePortUchar((PUCHAR)GRAPH_DATA_PORT, (UCHAR)((HwDeviceExtension->PhysicalSaveAddress >> 20) & 0x0FF));
                     //$DEL$//  VideoPortWritePortUchar((PUCHAR)GRAPH_ADDRESS_PORT, HIGH_ADDR_MAP+1);
                     //$DEL$//  VideoPortWritePortUchar((PUCHAR)GRAPH_DATA_PORT, (UCHAR)((HwDeviceExtension->PhysicalSaveAddress >> 28) & 0x0FF));
                     //

                     // set DAC registers
                     VideoPortWritePortUchar((PUCHAR)DAC_CMD_0, 0x00);
                     VideoPortWritePortUchar((PUCHAR)DAC_CMD_1, 0x40);
                     VideoPortWritePortUchar((PUCHAR)DAC_CMD_2, 0x20);

                     // unlock ctrc registers
                          VideoPortWritePortUchar((PUCHAR)((PUCHAR)ulBase + CRTC_ADDRESS_PORT_MONO + COLOR_ADJUSTMENT),
                                             (UCHAR)0x11);
                          VideoPortWritePortUchar((PUCHAR)((PUCHAR)ulBase + CRTC_DATA_PORT_MONO + COLOR_ADJUSTMENT),
                                                   0x00);

                     // set crtc registers
                     { UCHAR *crtc_values = "\xA1\x7F\x7F\x84\x85\x9B\x2E\xF5\x0\x60\x0\x0\x0\x0\x0\x0\x7\x8B\xFF\x80\x0\xFF\x2E\xE3\xFF";

                             for(culCount=0; culCount <= 0x18 ; culCount++, crtc_values++) {
                                VideoPortWritePortUchar((PUCHAR)((PUCHAR)ulBase + CRTC_ADDRESS_PORT_MONO + COLOR_ADJUSTMENT),
                                                   (UCHAR)culCount);
                                VideoPortWritePortUchar((PUCHAR)((PUCHAR)ulBase + CRTC_DATA_PORT_MONO + COLOR_ADJUSTMENT),
                                                   *crtc_values);
                             }
                     }

                     // setup crt overflow regs
                     VideoPortWritePortUchar((PUCHAR)(ulBase + GRAPH_ADDRESS_PORT),
                                             OVERFLOW_REG_1);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + GRAPH_DATA_PORT),
                                             0x00);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + GRAPH_ADDRESS_PORT),
                                             OVERFLOW_REG_2);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + GRAPH_DATA_PORT),
                                             0x00);

                     // setup overscan color registers
                     VideoPortWritePortUchar((PUCHAR)CO_COLOR_WRITE, 0x00);
                     for (culCount=0; culCount<3; culCount++) {
                             VideoPortWritePortUchar((PUCHAR)CO_COLOR_DATA, 0x00);
                     }

                     // setup attribute controller
                     VideoPortReadPortUchar((PUCHAR)0x3da); // reset the latch

                     for (culCount=0; culCount < 0x10; culCount++) {
                             VideoPortWritePortUchar((PUCHAR)((PUCHAR)ulBase + ATT_ADDRESS_PORT),
                                                (UCHAR)culCount);
                             VideoPortWritePortUchar((PUCHAR)((PUCHAR)ulBase + ATT_DATA_WRITE_PORT),
                                                (UCHAR)culCount);
                     }
                     VideoPortWritePortUchar((PUCHAR)(ulBase + ATT_ADDRESS_PORT), 0x10);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + ATT_DATA_WRITE_PORT),0x41);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + ATT_ADDRESS_PORT),0x11);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + ATT_DATA_WRITE_PORT),0x00);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + ATT_ADDRESS_PORT), 0x12);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + ATT_DATA_WRITE_PORT), 0x0f);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + ATT_ADDRESS_PORT), 0x13);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + ATT_DATA_WRITE_PORT), 0x00);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + ATT_ADDRESS_PORT), 0x14);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + ATT_DATA_WRITE_PORT), 0x00);

                     // setup graphics register
                     for (culCount=0; culCount < 0x06; culCount++) {
                        VideoPortWritePortUchar((PUCHAR)(ulBase + GRAPH_ADDRESS_PORT),
                                                (UCHAR)culCount);
                        VideoPortWritePortUchar((PUCHAR)(ulBase + GRAPH_DATA_PORT),
                                                0x00);
                     }
                     VideoPortWritePortUchar((PUCHAR)(ulBase + GRAPH_ADDRESS_PORT),
                                             0x06);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + GRAPH_DATA_PORT),
                                             0x05);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + GRAPH_ADDRESS_PORT),
                                             0x07);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + GRAPH_DATA_PORT),
                                             0x0f);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + GRAPH_ADDRESS_PORT),
                                             0x08);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + GRAPH_DATA_PORT),
                                             0xff);

                     {                            /* FIX VGA BUG */
                        USHORT Port = (USHORT)(ulBase + CRTC_ADDRESS_PORT_MONO);

                        VideoPortWritePortUchar((PUCHAR)0x03C4, 0x07);

                        if (VideoPortReadPortUchar((PUCHAR)(ulBase + MISC_OUTPUT_REG_READ_PORT)) & 0x01) {

                            Port += COLOR_ADJUSTMENT;
                            //
                            // $0006 - MikeD - 03/04/94
                            //   Begin: add 10 millisecond delay after r/w
                            //          of 3c2
                            //
                            //         10000microsecs = 10ms
                            //
                            // I know I should not stall more than 50, but
                            // there is no other way around this...

                            VideoPortStallExecution( 10000 );
                        }

                        VideoPortWritePortUchar((PUCHAR)Port,
                                                0x3F);

                        VideoPortWritePortUchar((PUCHAR)Port + 1,
                                                0x01);

                     }

                     // Enable BitBlt and disable IRQ 9
                     VideoPortWritePortUchar((PUCHAR)(ulBase + GRAPH_ADDRESS_PORT),
                                             0x10);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + GRAPH_DATA_PORT),
                                             0x68);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + GRAPH_DATA_PORT),
                                             0x28);

                     VideoPortWritePortUchar((PUCHAR)(ulBase + GRAPH_ADDRESS_PORT),
                                             0x5a);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + GRAPH_DATA_PORT),
                                             0x6);

                     // reset the Pattern registers
                     VideoPortWritePortUchar((PUCHAR)PREG_0, 0);
                     VideoPortWritePortUchar((PUCHAR)PREG_1, 0);
                     VideoPortWritePortUchar((PUCHAR)PREG_2, 0);
                     VideoPortWritePortUchar((PUCHAR)PREG_3, 0);
                     VideoPortWritePortUchar((PUCHAR)PREG_4, 0);
                     VideoPortWritePortUchar((PUCHAR)PREG_5, 0);
                     VideoPortWritePortUchar((PUCHAR)PREG_6, 0);
                     VideoPortWritePortUchar((PUCHAR)PREG_7, 0);

                     // Reset the BitBlt registers
                     VideoPortWritePortUchar((PUCHAR)BLT_DEST_ADDR_LO, 0);
                     VideoPortWritePortUchar((PUCHAR)BLT_DEST_ADDR_HI, 0);
                     VideoPortWritePortUshort((PUSHORT)BITMAP_WIDTH, 0x400);
                     VideoPortWritePortUshort((PUSHORT)BITMAP_HEIGHT, 0x3ff);
                     VideoPortWritePortUchar((PUCHAR)BLT_CMD_1, 0xc0);
                     VideoPortWritePortUchar((PUCHAR)BLT_CMD_0, 0x01);

                     VideoPortReadPortUchar((PUCHAR)ARIES_CTL_1);

                     // Enable BitBlt and disable IRQ 9
                     VideoPortWritePortUchar((PUCHAR)(ulBase + GRAPH_ADDRESS_PORT),
                                             0x10);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + GRAPH_DATA_PORT),
                                             0x68);
                     VideoPortWritePortUchar((PUCHAR)(ulBase + GRAPH_DATA_PORT),
                                             0x28);

                     break;
               } // switch

               break;

            //
            // Unknown command; error
            //

            default:
                VideoDebugPrint((2,"\tdefault\n"));
                return FALSE;

        }

    }

    VideoDebugPrint((1, "QVision.sys: VgaInterpretCmdStream - EXIT.\n"));
    return TRUE;

} // end VgaInterpretCmdStream()

//---------------------------------------------------------------------------
VP_STATUS
VgaSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize
    )

/*++

Routine Description:

    This routine sets the vga into the requested mode.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    Mode - Pointer to the structure containing the information about the
        font to be set.

    ModeSize - Length of the input buffer supplied by the user.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    ERROR_INVALID_PARAMETER if the mode number is invalid.

    NO_ERROR if the operation completed successfully.

--*/

{

    PVIDEOMODE pRequestedMode;
    PUSHORT pusCmdStream;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    UCHAR ucTemp;                           // temporary register storage
    UCHAR temp;
    UCHAR dummy;
    UCHAR bIsColor;


    VideoDebugPrint((1,"QVision.sys: VgaSetMode - ENTRY.\n"));
    VideoDebugPrint((1,"\tRequested Mode = 0x%x\n",Mode->RequestedMode));

#ifdef QV_DBG
    DbgBreakPoint();
#endif

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (ModeSize < sizeof(VIDEO_MODE)) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Blank the screen prior to clearing video memory
    //

    VideoPortWritePortUchar((PUCHAR)(HwDeviceExtension->IOAddress +
                            SEQ_ADDRESS_PORT), (UCHAR) 0x01);

    ucTemp = VideoPortReadPortUchar((PUCHAR) HwDeviceExtension->IOAddress +
                                     SEQ_DATA_PORT);

    VideoPortWritePortUchar((PUCHAR)(HwDeviceExtension->IOAddress +
                            SEQ_DATA_PORT), (UCHAR)(ucTemp | (UCHAR) 0x20));

    //
    // Extract the clear memory bit.
    //

    if (Mode->RequestedMode & VIDEO_MODE_NO_ZERO_MEMORY) {

        Mode->RequestedMode &= ~VIDEO_MODE_NO_ZERO_MEMORY;

    }
    else {

        VgaZeroVideoMemory(HwDeviceExtension);

    }

    //
    // Check to see if we are requesting a valid mode
    //

    if ( (Mode->RequestedMode >= NumVideoModes) ||
         (!ModesVGA[Mode->RequestedMode].ValidMode) ) {

        VideoDebugPrint((1,"\tERROR_INVALID_PARAMETER.\n"));
        return ERROR_INVALID_PARAMETER;

    }

    pRequestedMode = &ModesVGA[Mode->RequestedMode];

    //
    // Store the new mode value.
    //

    HwDeviceExtension->CurrentMode = pRequestedMode;
    HwDeviceExtension->ModeIndex = Mode->RequestedMode;

    //
    // $0005 - MikeD - 02/08/94
    // Begin:
    //   Daytona - MikeD - 02/09/94 need to set MonClass based on requested
    //   refresh rate.
    //
    HwDeviceExtension->VideoHardware.lFrequency = pRequestedMode->ulRefreshRate;
    GetMonClass(HwDeviceExtension);
    //
    // End:
    //   Daytona - MikeD - 02/09/94
    //


    //
    // Select proper command array for adapter type
    //

#ifdef INIT_INT10
    {

    VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

    biosArguments.Eax = pRequestedMode->usInt10ModeNum;
    VideoPortInt10(HwDeviceExtension, &biosArguments);
    }
#else

    /***********************************************************************
    ***   There appears to be a problem with some application            ***
    ***   which reset the first 16 palette registers.                    ***
    ***   Since the palette is not reset when going to and               ***
    ***   from text modes by doing a set mode (instead of                ***
    ***   the hardware save restore), some colors might not              ***
    ***   appear as expected in the text modes.  The bios                ***
    ***   calls seem to reload the palette so Andre Vachon               ***
    ***   suggested that we implement an Int10 mode set for the          ***
    ***   text modes.                                                    ***
    ***   To accomplish this, we need to hard code the first             ***
    ***   three modes in modeset.h in the following switch.              ***
    ***   If more text modes are added to modeset.h, their               ***
    ***   index must be added to this switch statement.                  ***
    ***********************************************************************/
    VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
    //
    // $0007 - MikeD - 06/17/94
    //  Must key off of ulResIndex instead of Mode->RequestedMode since its
    //  not a one-to-one relationship anymore.  The Mode->RequestedMode now
    //  acts as an index into ModesVGA[] and therefore the index used for
    //  each monitor refresh (i.e. QV_TEXT_720x400x4_INDEX) is duplicated
    //  across each like mode (with different refresh rates).  This was
    //  found in Japanese NT because when the vdm requests full-screen, it
    //  is a different mode than when the U.S. NT requests a full-screen.
    //
    //  OLD WAY ===> switch (Mode->RequestedMode) {
    switch (pRequestedMode->ulResIndex) {
       case 0:                               // 720x400
                 /***********************************************************************
          ***   Prepare the card for the VGA mode 3+ instead of the CGA mode 3 ***
                 ***********************************************************************/
         biosArguments.Eax = 0x1202;              // Select Scan line number
          biosArguments.Ebx = 0x0030;             // to be 400 scan lines
          VideoPortInt10(HwDeviceExtension, &biosArguments);

                 /***********************************************************************
          ***   Set the video mode to BIOS mode 3.                             ***
                 ***********************************************************************/
                 VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
          biosArguments.Eax = 0x03;          // bios mode 0x03
          VideoPortInt10(HwDeviceExtension, &biosArguments);
          break;
       case 1:                               // 640x350
                 /***********************************************************************
          ***   Prepare the card for the EGA mode 3* instead of the CGA mode 3 ***
                 ***********************************************************************/
         biosArguments.Eax = 0x1201;              // Select Scan line number
          biosArguments.Ebx = 0x0030;             // to be 350 scan lines
          VideoPortInt10(HwDeviceExtension, &biosArguments);

                 /***********************************************************************
          ***   Set the video mode to BIOS mode 3.                             ***
                 ***********************************************************************/
                 VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
          biosArguments.Eax = 0x03;          // bios mode 0x03
          VideoPortInt10(HwDeviceExtension, &biosArguments);
          break;
       case 2:                               // 640x480x4
          biosArguments.Eax = 0x12;          // bios mode 0x12
          VideoPortInt10(HwDeviceExtension, &biosArguments);
          break;

       default:                              // all graphics modes are
                                             // handled by the default case
          pusCmdStream = pRequestedMode->CmdStrings.QVCmdStrings;
          VgaInterpretCmdStream(HwDeviceExtension, pusCmdStream);
          break;
    } // switch

    //
    // Fix to get 640x350 text mode
    //

    if (!(pRequestedMode->fbType & VIDEO_MODE_GRAPHICS)) {

        //
        // Fix to make sure we always set the colors in text mode to be
        // intensity, and not flashing
        // For this zero out the Mode Control Regsiter bit 3 (index 0x10
        // of the Attribute controller).
        //

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                MISC_OUTPUT_REG_READ_PORT) & 0x01) {

            bIsColor = TRUE;

            //
            // $0006 - MikeD - 03/04/94
            //      Begin: add 10 millisecond delay after r/w
            //             of 3c2
            //
            //         10000microsecs = 10ms
            //
            // I know I should not stall more than 50, but
            // there is no other way around this...

            VideoPortStallExecution( 10000 );

        } else {

            bIsColor = FALSE;

        }

        if (bIsColor) {

            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    INPUT_STATUS_1_COLOR);
        } else {

            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    INPUT_STATUS_1_MONO);
        } // else

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT, (0x10 | VIDEO_ENABLE));
        temp = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                ATT_DATA_READ_PORT);

        temp &= 0xF7;

        if (bIsColor) {

            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    INPUT_STATUS_1_COLOR);
        } else {

            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    INPUT_STATUS_1_MONO);
        } // else

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT, (0x10 | VIDEO_ENABLE));
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_DATA_WRITE_PORT, temp);
    } // if
#endif

    //
    // Support 256 color modes by stretching the scan lines.
    //

    //
    // Update the location of the physical frame buffer within video memory.
    //

    HwDeviceExtension->PhysicalFrameLength =
            MemoryMaps[pRequestedMode->MemMap].MaxSize;

    HwDeviceExtension->PhysicalFrameBase.LowPart =
            MemoryMaps[pRequestedMode->MemMap].Start;

    //
    // Enable memory-mapped I/O if required
    //

    if ((Mode->RequestedMode != DEFAULT_MODE) &&
        (HwDeviceExtension->PhysicalMemoryMappedLength != 0)) {

        VideoPortWritePortUchar((PUCHAR) CTRL_REG_2, 0x10);

        VideoPortWritePortUchar((PUCHAR) MEMORY_MAP_BASE,
            (UCHAR) (HwDeviceExtension->PhysicalMemoryMappedBase.LowPart / 4096 - 0x80));

        VideoPortWritePortUchar((PUCHAR) CTRL_REG_2, 0x11);
    }


    //
    // Set the graphic cursor fg color (white)
    //

    VideoPortWritePortUchar( (PUCHAR) CURSOR_COLOR_WRITE, CURSOR_COLOR_2);
    VideoPortWritePortUchar( (PUCHAR) CURSOR_COLOR_DATA,  0xff);
    VideoPortWritePortUchar( (PUCHAR) CURSOR_COLOR_DATA,  0xff);
    VideoPortWritePortUchar( (PUCHAR) CURSOR_COLOR_DATA,  0xff);

    //
    // Set the graphic cursor bg color (black)
    //

    VideoPortWritePortUchar( (PUCHAR) CURSOR_COLOR_WRITE, CURSOR_COLOR_1);
    VideoPortWritePortUchar( (PUCHAR) CURSOR_COLOR_DATA,  0x00);
    VideoPortWritePortUchar( (PUCHAR) CURSOR_COLOR_DATA,  0x00);
    VideoPortWritePortUchar( (PUCHAR) CURSOR_COLOR_DATA,  0x00);


    VideoDebugPrint((1,"QVision.sys: VgaSetMode - EXIT.\n"));
    return NO_ERROR;

} //end VgaSetMode()

//---------------------------------------------------------------------------
VP_STATUS
VgaQueryAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns the list of all available available modes on the
    card.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ModeInformation - Pointer to the output buffer supplied by the user.
        This is where the list of all valid modes is stored.

    ModeInformationSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
        for the data being returned.

    NO_ERROR if the operation completed successfully.

--*/

{
    PVIDEO_MODE_INFORMATION videoModes = ModeInformation;
    ULONG i;

    VideoDebugPrint((1,"QVision.sys: VgaQueryAvailableModes - ENTRY.\n"));

    //
    // Find out the size of the data to be put in the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (ModeInformationSize < (*OutputSize =
                 HwDeviceExtension->NumAvailableModes *
            sizeof(VIDEO_MODE_INFORMATION)) ) {

        VideoDebugPrint((1,"\tERROR_INSUFFICIENT_BUFFER.\n"));
        VideoDebugPrint((1,"QVision.sys: VgaQueryAvailableModes - EXIT.\n"));
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // For each mode supported by the card, store the mode characteristics
    // in the output buffer.
    //

    for (i = 0; i < NumVideoModes; i++) {

      //
      // $0005 - MikeD - 02/08/94
      // Daytona support
      //

        VideoDebugPrint((2,"\tVideoMode = 0x%x (%ldHz) ",i,
           ModesVGA[i].ulRefreshRate));


        //
        // If we have enough memory to support the mode, set all videoModes
        // values according to the data in the mode table.
        //

        if (ModesVGA[i].ValidMode) {

            VideoDebugPrint((2," - VALID MODE"));
            videoModes->Length          = sizeof(VIDEO_MODE_INFORMATION);
            videoModes->ModeIndex       = i;
            videoModes->VisScreenWidth  = ModesVGA[i].hres;
            videoModes->ScreenStride    = ModesVGA[i].wbytes;
            videoModes->VisScreenHeight = ModesVGA[i].vres;
            videoModes->NumberOfPlanes  = ModesVGA[i].numPlanes;
            videoModes->BitsPerPlane    = ModesVGA[i].bitsPerPlane;
            videoModes->Frequency       = ModesVGA[i].ulRefreshRate;
            videoModes->XMillimeter     = 320;  // temporary hardcoded constant
            videoModes->YMillimeter     = 240;  // temporary hardcoded constant

            switch (videoModes->BitsPerPlane) {

                case 4:

                    VideoDebugPrint((2," - 4BPP\n"));
                    videoModes->NumberRedBits     = 6;
                    videoModes->NumberGreenBits   = 6;
                    videoModes->NumberBlueBits    = 6;
                    videoModes->RedMask           = 0;
                    videoModes->GreenMask         = 0;
                    videoModes->BlueMask          = 0;
                    videoModes->AttributeFlags   = ModesVGA[i].fbType |
                       VIDEO_MODE_PALETTE_DRIVEN | VIDEO_MODE_MANAGED_PALETTE;
                    break;

                case 8:

                    VideoDebugPrint((2," - 8BPP\n"));
                    videoModes->NumberRedBits     = 6;
                    videoModes->NumberGreenBits   = 6;
                    videoModes->NumberBlueBits    = 6;
                    videoModes->RedMask           = 0;
                    videoModes->GreenMask         = 0;
                    videoModes->BlueMask          = 0;
                    videoModes->AttributeFlags = ModesVGA[i].fbType |
                    VIDEO_MODE_PALETTE_DRIVEN | VIDEO_MODE_MANAGED_PALETTE;
                    break;

                case 16:

                    VideoDebugPrint((2," - 16BPP\n"));
                    if ((HwDeviceExtension->VideoHardware.AdapterType != AriesEisa) &&
                       (HwDeviceExtension->VideoHardware.AdapterType != AriesIsa)) {
                       videoModes->ScreenStride = 2048;
                    } // if

                    //  NOTE: hard coded to 5:5:5 color format
                    videoModes->NumberRedBits     = 5;
                    videoModes->NumberGreenBits   = 5;
                    videoModes->NumberBlueBits    = 5;
                    videoModes->RedMask           = 0x7C00;
                    videoModes->GreenMask         = 0x03E0;
                    videoModes->BlueMask          = 0x001F;
                    videoModes->AttributeFlags    = ModesVGA[i].fbType;
                    break;

                case 32:

                        VideoDebugPrint((2," - 32BPP\n"));
                    if ((HwDeviceExtension->VideoHardware.AdapterType != AriesEisa) &&
                       (HwDeviceExtension->VideoHardware.AdapterType != AriesIsa)) {
                       videoModes->ScreenStride = 2048;
                    } // if

                    videoModes->NumberRedBits     = 8;
                    videoModes->NumberGreenBits   = 8;
                    videoModes->NumberBlueBits    = 8;
                    videoModes->RedMask           = 0x000000ff;
                    videoModes->GreenMask         = 0x0000ff00;
                    videoModes->BlueMask          = 0x00ff0000;
                    videoModes->AttributeFlags    = ModesVGA[i].fbType;
                    break;

                default:

                    VideoDebugPrint((2," - default\n"));
                    videoModes->NumberRedBits    = 6;
                    videoModes->NumberGreenBits  = 6;
                    videoModes->NumberBlueBits   = 6;
                    videoModes->RedMask          = 0;
                    videoModes->GreenMask        = 0;
                    videoModes->BlueMask         = 0;
                    videoModes->AttributeFlags   = ModesVGA[i].fbType |
                      VIDEO_MODE_PALETTE_DRIVEN | VIDEO_MODE_MANAGED_PALETTE;
                    break;

            }     // switch

        videoModes++; // next mode

        } // end if

#ifdef QV_DBG

      else {

         VideoDebugPrint((2," - INVALID MODE\n"));

      } // else

#endif

    } // end for i


    VideoDebugPrint((1,"QVision.sys: VgaQueryAvailableModes - EXIT.\n"));
    return NO_ERROR;


} // end VgaGetAvailableModes()

//---------------------------------------------------------------------------
VP_STATUS
VgaQueryNumberOfAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns the number of available modes for this particular
    video card.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    NumModes - Pointer to the output buffer supplied by the user. This is
        where the number of modes is stored.

    NumModesSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
        for the data being returned.

    NO_ERROR if the operation completed successfully.

--*/

{
    USHORT i;

    VideoDebugPrint((1,"QVision.sys: VgaQueryNumberOfAvailableModes - ENTRY.\n"));

    //
    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (NumModesSize < (*OutputSize = sizeof(VIDEO_NUM_MODES)) ) {

        VideoDebugPrint((1,"QVision.sys: VgaQueryNumberOfAvailableModes - EXIT.\n"));
        return ERROR_INSUFFICIENT_BUFFER;

    }

    HwDeviceExtension->NumAvailableModes = 0; // init the number avail modes
                                                 // for the current configuration
    for (i = 0; i < NumVideoModes; i++) {

        //
        //  First find out if we have enough memory for the
        //  mode we are checking.
        //  We also need to check if the current monitor supports
        //  the current mode.
        //  If both conditions are TRUE then this mode is valid.
        //  We need to make sure that if this is the 1280 mode and
        //  we have 2MB of RAM, the card is a Juniper and not a
        //  FIR with a twig.  FIR does not support 1280 modes.
        //

        // if ((HwDeviceExtension->InstalledVmem >= ModesVGA[i].VmemRequired) &&
        //          (fValidMode[HwDeviceExtension->VideoHardware.MonClass][i])) {

        //
        // $0005 - MikeD - 02/08/94
        //  Daytona changes.

        if (HwDeviceExtension->InstalledVmem >= ModesVGA[i].VmemRequired) {

            if (ModesVGA[i].hres < 1280) {
                VideoDebugPrint((2,"\tVALID VideoMode = 0x%x\n",i));
                ModesVGA[i].ValidMode = TRUE;
                HwDeviceExtension->NumAvailableModes++;
            } // if

            else if ((HwDeviceExtension->VideoHardware.AdapterType >= JuniperEisa) ||
                     (HwDeviceExtension->VideoHardware.AdapterType >= JuniperIsa)) {

                VideoDebugPrint((2,"\tVALID VideoMode = 0x%x\n",i));
                ModesVGA[i].ValidMode = TRUE;
                HwDeviceExtension->NumAvailableModes++;

            } // else

        } // if

    } // for

    //
    // Store the number of modes into the buffer.
    //

    NumModes->NumModes = HwDeviceExtension->NumAvailableModes;
    NumModes->ModeInformationLength = sizeof(VIDEO_MODE_INFORMATION);

    VideoDebugPrint((2,"\tNumModes = 0x%x\n",NumModes->NumModes));

    VideoDebugPrint((1,"QVision.sys: VgaQueryNumberOfAvailableModes - EXIT.\n"));
    return NO_ERROR;


} // end VgaGetNumberOfAvailableModes()

//---------------------------------------------------------------------------
VP_STATUS
VgaQueryCurrentMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns a description of the current video mode.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ModeInformation - Pointer to the output buffer supplied by the user.
        This is where the current mode information is stored.

    ModeInformationSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
        for the data being returned.

    NO_ERROR if the operation completed successfully.

--*/

{
    VideoDebugPrint((1,"QVision.sys: VgaQueryCurrentMode - ENTRY.\n"));

    //
    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (ModeInformationSize < (*OutputSize = sizeof(VIDEO_MODE_INFORMATION))) {

       VideoDebugPrint((1,"QVision.sys: VgaQueryCurrentMode - EXIT.\n"));
       return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Store the characteristics of the current mode into the buffer.
    //

    ModeInformation->Length = sizeof(VIDEO_MODE_INFORMATION);
    ModeInformation->ModeIndex         = HwDeviceExtension->ModeIndex;
    ModeInformation->VisScreenWidth    = HwDeviceExtension->CurrentMode->hres;
    ModeInformation->ScreenStride      = HwDeviceExtension->CurrentMode->wbytes;
    ModeInformation->VisScreenHeight   = HwDeviceExtension->CurrentMode->vres;
    ModeInformation->NumberOfPlanes    = HwDeviceExtension->CurrentMode->numPlanes;
    ModeInformation->BitsPerPlane      = HwDeviceExtension->CurrentMode->bitsPerPlane;
    ModeInformation->Frequency         = HwDeviceExtension->VideoHardware.lFrequency;
    ModeInformation->XMillimeter       = 320; // temporary hardcoded constant
    ModeInformation->YMillimeter       = 240; // temporary hardcoded constant
    ModeInformation->NumberRedBits     = 6;
    ModeInformation->NumberGreenBits   = 6;
    ModeInformation->NumberBlueBits    = 6;
    ModeInformation->RedMask           = 0;
    ModeInformation->GreenMask         = 0;
    ModeInformation->BlueMask          = 0;
    ModeInformation->AttributeFlags    = HwDeviceExtension->CurrentMode->fbType |
                VIDEO_MODE_PALETTE_DRIVEN | VIDEO_MODE_MANAGED_PALETTE;

    VideoDebugPrint((1,"QVision.sys: VgaQueryCurrentMode - EXIT.\n"));
    return NO_ERROR;

} // end VgaQueryCurrentMode()


//---------------------------------------------------------------------------
VOID
VgaZeroVideoMemory(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine zeros the first 256K on the VGA.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.


Return Value:

    None.

--*/
{
   UCHAR temp;
   ULONG i;
   ULONG max;

   VideoDebugPrint((1,"QVision.sys: VgaZeroVideoMemory - ENTRY.\n"));

   //
   // Map font buffer at A0000
   //

   VgaInterpretCmdStream(HwDeviceExtension, EnableA000Data);

   //
   // Enable all planes.
   //
   VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
           IND_MAP_MASK);

   temp = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
           SEQ_DATA_PORT) | (UCHAR)0x0F;

   VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
           temp);

   //
   // Zero the memory for all pages.
   //
   //
   max = 4;                                 // for QVision we assume 4 banks

   for (i = 0; i < max; i++) {

     SetQVisionBanking(HwDeviceExtension,i);// setup next 256k bank
     VideoPortZeroMemory(HwDeviceExtension->VideoMemoryAddress,
           0xFFFF);

     } // end for
   SetQVisionBanking(HwDeviceExtension,0);  // reset the banks

   VgaInterpretCmdStream(HwDeviceExtension, DisableA000Color);

   VideoDebugPrint((1,"QVision.sys: VgaZeroVideoMemory - EXIT.\n"));
}

//---------------------------------------------------------------------------
VOID
SetQVisionBanking(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG BankNumber
    )
/*++

Routine Description:

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    BankNumber - the 64k bank number to set in 1RW mode(we will set this mode).

Return Value:

    vmem256k, vmem512k, or vmem1Meg ONLY ( these are defined in cirrus.h).

--*/
{

    VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
         GRAPH_ADDRESS_PORT), 0x030d);

    VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
         GRAPH_ADDRESS_PORT), (USHORT)(0x000e + (BankNumber << (8+4))) );



} // SetQVisionBanking()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\mini\cmdcnst.h ===
/*++

Copyright (c) 1992  Microsoft Corporation
Copyright (c) 1993  Compaq Computer Corporation

Module Name:

    cmdcnst.h

Abstract:

    This is the command string interpreter definitions

Environment:

    kernel mode only

Notes:

Revision History:


--*/

//--------------------------------------------------------------------------
//   Definition of the set/clear mode command language.
//
//   Each command is composed of a major portion and a minor portion.
//   The major portion of a command can be found in the most significant
//   nibble of a command byte, while the minor portion is in the least
//   significant portion of a command byte.
//
//   maj  minor      Description
//   ---- -----      --------------------------------------------
//   00              End of data
//
//   10              in and out type commands as described by flags
//        flags:
//
//        xxxx
//        ||||
//        |||+-------- unused
//        ||+--------- 0/1 single/multiple values to output (in's are always 
//        |+---------- 0/1 8/16 bit operation                  single)
//        +----------- 0/1 out/in instruction
//
//       Outs
//       ----------------------------------------------
//       0           reg:W val:B
//       2           reg:W cnt:W val1:B val2:B...valN:B
//       4           reg:W val:W
//       6           reg:W cnt:W val1:W val2:W...valN:W
//
//       Ins
//       ----------------------------------------------
//       8           reg:W
//       a           reg:W cnt:W
//       c           reg:W
//       e           reg:W cnt:W
//
//   20              Special purpose outs
//       00          do indexed outs for seq, crtc, and gdc
//                   indexreg:W cnt:B startindex:B val1:B val2:B...valN:B
//       01          do indexed outs for atc
//                   index-data_reg:W cnt:B startindex:B val1:B val2:B...valN:B
//       02          do masked outs
//                   indexreg:W andmask:B xormask:B
//
//   F0              Nop
//
//---------------------------------------------------------------------------

// some useful equates - major commands

#define EOD     0x000                       // end of data
#define INOUT   0x010                       // do ins or outs
#define METAOUT 0x020                       // do special types of outs
#define NCMD    0x0f0                       // Nop command
//
//   QVision specific commands.
//
#define QVCMD   0x040                       // QVision specific commands
#define QVNEW   0x080                       // QVision set ARIES RAM


// flags for INOUT major command

//#define UNUSED    0x01                      // reserved
#define MULTI   0x02                        // multiple or single outs
#define BW      0x04                        // byte/word size of operation
#define IO      0x08                        // out/in instruction

// minor commands for metout

#define INDXOUT      0x00                   // do indexed outs
#define ATCOUT       0x01                   // do indexed outs for atc
#define MASKOUT      0x02                   // do masked outs using and-xor masks

//
//   QVision specific commands.  QVCMD Major code
//

#define SETMONCRTC   0x01                   // set monitor dependent CRTC registers
#define SETMONOVFLW  0x02                   // set monitor dependent Overflow2 registers
#define SETMISCOUT   0x04                   // set monitor dependent Misc registers
#define BYTE2PORT    0x08                   // write one or more bytes to a specific address

#define SETRAM       0x01                   // Initialize QVision RAM
#define ARIES        0x02                   // Aries specific stuff
#define V32          0x04                   // Check for V32 and set the
                                            // V32 specific registers
#define V35          0x08                   // V35 Check for V35 stuff


// composite inout type commands

#define OB      (INOUT)                     // output 8 bit value
#define OBM     (INOUT+MULTI)               // output multiple bytes
#define OW      (INOUT+BW)                  // output single word value
#define OWM     (INOUT+BW+MULTI)            // output multiple words

#define IB      (INOUT+IO)                  // input byte
#define IBM     (INOUT+IO+MULTI)            // input multiple bytes
#define IW      (INOUT+IO+BW)               // input word
#define IWM     (INOUT+IO+BW+MULTI)         // input multiple words

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\mini\ctlrtype.c ===
//---------------------------------------------------------------------------
/*++

Copyright (c) 1993  Compaq Computer Corporation

Module Name:

    ctlrtype.c

Abstract:

    This module contains the code for identification of Compaq
    Display Controller type


Environment:

    kernel mode only

Notes:

Revision History:
   $0009
      adrianc: 02/17/1995
         - Added support for the V64 ASIC controller
   $0006
      miked: 02/17/1994
	. took out conditional debug code to satisfy MSBHPD

   $0004
      miked: 1/26/1994
	 . Added debug print code without all the other DBG overhead

  12/1/93 Mike Duke Original module started as start for NT version of QRY
		    library.
--*/
//---------------------------------------------------------------------------

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"
#include "qvision.h"

#include "qry_nt.h"


ULONG
QRY_ControllerType( PUCHAR IOAddress )
/*++
   Function: QRY_ControllerType

   This function returns the type of the current controller.

   Return value:
    Returns one of a discrete set of values which indicates
    the type of the current display controller.  Only one of these
    values will be returned.

    THIS FUNCTION ASSUMES VGA OR BETTER!

    The controller types returned are:

      QRY_CONTROLLER_UNKNOWN	   0	      // Unknown controller
      QRY_CONTROLLER_VGA	      4       // VGA-compatible controller
      QRY_CONTROLLER_IVGS	      5       // IVGS controller
      QRY_CONTROLLER_EVGS	      6       // EVGS controller
      QRY_CONTROLLER_AVGA	      7       // AVGA controller
      QRY_CONTROLLER_QUASAR0	   8       // Quasar rev 0 controller
      QRY_CONTROLLER_VEGAS	      9       // Quasar/Vegas controller
      QRY_CONTROLLER_MADONNA	   10      // Madonna controller
      QRY_CONTROLLER_VICTORY	   11      // Victory controller
      QRY_CONTROLLER_V32	      12      // V32 controller
      QRY_CONTROLLER_V35	      13      // V35 controller
      QRY_CONTROLLER_V64         14      // V64 controller


--*/
//---------------------------------------------------------------------------
{
   ULONG ulASIC = 0L, ulReturn = 0L;
   UCHAR ucID1, ucID2, ucID3 ;

   ulASIC = QRY_ControllerASICID( IOAddress );

   ucID1 = (UCHAR)(ulASIC & 0xff);
   ucID2 = (UCHAR)((ulASIC & 0xff00) >> 8);
   ucID3 = (UCHAR)((ulASIC & 0xff0000) >> 16);

   // DebugPrint((1,"QRY_ControllerType()\n\tulASIC:0x%lx ID1:0x%x ID2:0x%x ID3:0x%x\n",
   //		  ulASIC,ucID1,ucID2,ucID3));

   //
   // mask off version bits on id1 (bits 2 thru 0)
   //
   ucID1 &= 0xf8;
   
/*** $0009 ***********  adrianc 2/17/1995 ******************************
***   I added support for the V64 ASIC.                              ***
***********************************************************************/
   switch (ucID1) {

      case 0x08: // VGA/VGC
         ulReturn = QRY_CONTROLLER_VGA;
         break;

      case 0x18: // XccelVGA
         ulReturn = QRY_CONTROLLER_IVGS;
         break;

      case 0x28: // AVGA
         ulReturn = QRY_CONTROLLER_AVGA;
         break;

      case 0x80: // AVGA Flat panel
         ulReturn = QRY_CONTROLLER_VEGAS;
         break;

      case 0x88: // MADONNA
         ulReturn = QRY_CONTROLLER_MADONNA;
         break;

      case 0x30: // VICTORY
         ulReturn = QRY_CONTROLLER_VICTORY;
         break;

      case 0x70: // V32 or later
         if (ucID2 == 0x00) {  // if all bits clear in ID2, then V32
	         ulReturn = QRY_CONTROLLER_V32;
	      }
   	   else {
            if (ucID2 & 0x02){ // bit 1 indicates V64
               ulReturn = QRY_CONTROLLER_V64;
            }
            else if (ucID2 & 0x01) {  // bit 0 indicates V35
	            ulReturn = QRY_CONTROLLER_V35;
            }
	         else {
	            ulReturn = QRY_CONTROLLER_UNKNOWN;
	         }
	      }
	      break;

      default:
         ulReturn = QRY_CONTROLLER_UNKNOWN;
         break;
      }


 return (ulReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\mini\modeset.h ===
/*++

Copyright (c) 1992  Microsoft Corporation
Copyright (c) 1993  Compaq Computer Corporation

Module Name:

    Modeset.h

Abstract:

    This module contains all the global data used by the Compaq QVision
    miniport driver.

Environment:

    Kernel mode

Revision History:



--*/
//---------------------------------------------------------------------------
//
// only one banking variable must be defined
//
#if TWO_32K_BANKS
#if ONE_64K_BANK
#error !!ERROR: two types of banking defined!
#endif
#elif ONE_64K_BANK
#else
#error !!ERROR: banking type must be defined!
#endif

//---------------------------------------------------------------------------

#include "cmdcnst.h"
#include "modeqv.h"

//---------------------------------------------------------------------------
//
// Memory map table -
//
// These memory maps are used to save and restore the physical video buffer.
//

//
// Memory map table definition
//

typedef struct {
    ULONG   MaxSize;                        // Maximum addressable size of memory
    ULONG   Start;                          // Start address of display memory
} MEMORYMAPS;

MEMORYMAPS MemoryMaps[] = {

//               length      start
//               ------      -----
    {           0x08000,    0xB0000},       // all mono text modes (7)
    {           0x08000,    0xB8000},       // all color text modes (0, 1, 2, 3,
    {           0x20000,    0xA0000},       // all VGA graphics modes
    {           0x100000,   0xE00000},      // QVision linear frame buffer
                                            //     (not yet implemented)
};

//
// Video mode table - contains information and commands for initializing each
// mode. These entries must correspond with those in VIDEO_MODE_VGA. The first
// entry is commented; the rest follow the same format, but are not so
// heavily commented.
//

//
// The currently supported QVISION modes are only supported for
// for non-interlaced monitors.
//

VIDEOMODE ModesVGA[] = {
//////////////////////////////////////////////////////////////
//    Mode index 0
//    Color test mode 3, 720x400, 9x16 char cell (VGA)
//    BIOS mode: 0x03
//    Refresh rate: Hardware default
//////////////////////////////////////////////////////////////
{
  VIDEO_MODE_COLOR,  // flags that this mode is a color mode, but not graphics
  4,                 // four planes
  1,                 // one bit of colour per plane
  80, 25,            // 80x25 text resolution
  720, 400,          // 720x400 pixels on screen
  160, 0x10000,      // 160 bytes per scan line, 64K of CPU-addressable bitmap
  NoBanking,         // no banking supported or needed in this mode
  MemMap_CGA,        // the memory mapping is the standard CGA memory mapping
                     //  of 32K at B8000
  vmem256k,          // video memory required to run mode
  FALSE,             // ModeValid default is always ok
#ifdef INIT_INT10
   {0x03},
#else
  {QV_TEXT_720x400x4},
#endif
 //
 // $0005 - MikeD - 02/08/94
 // Daytona support added value for ulRefreshRate and index for QVCMDS
 //
 USE_HARDWARE_DEFAULT,			   // refresh rate
 QV_TEXT_720x400x4_INDEX
},


//////////////////////////////////////////////////////////////
//    Mode index 1
//    Color text mode 3, 640x350, 8x14 char cell (EGA)
//    BIOS mode:0x10
//    Refresh rate: Hardware default
//////////////////////////////////////////////////////////////
{  VIDEO_MODE_COLOR,    // flags that this mode is a color mode, but not graphics
  4,                    // four planes
  1,                    // one bit of colour per plane
  80, 25,               // 80x25 text resolution
  640, 350,             // 640x350 pixels on screen
  160, 0x10000,         // 160 bytes per scan line, 64K of CPU-addressable bitmap
  NoBanking,            // no banking supported or needed in this mode
  MemMap_CGA,           // the memory mapping is the standard CGA memory mapping
                        //  of 32K at B8000
  vmem256k,             // video memory required to run mode
  FALSE,                // ModeValid default is always ok
#ifdef INIT_INT10
  {0x10},
#else
  {QV_TEXT_640x350x4},
#endif
 //
 // $0005 - MikeD - 02/08/94
 // Daytona support added value for ulRefreshRate and index for QVCMDS
 //
 USE_HARDWARE_DEFAULT,			   // refresh rate
 QV_TEXT_640x350x4_INDEX
},

//////////////////////////////////////////////////////////////
//    Mode index 2
//    Standard VGA Color graphics, 640x480x4 - 16 colors
//    BIOS mode: 0x12
//    Refresh rate: Hardware default
//////////////////////////////////////////////////////////////
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 80, 30,
  640, 480, 80, 0x10000, NoBanking, MemMap_VGA,
  vmem256k,             // video memory required to run mode
  FALSE,                // ModeValid default is always ok
#ifdef INIT_INT10
  {0x12},
#else
  {QV_TEXT_640x480x4},
#endif
 //
 // $0005 - MikeD - 02/08/94
 // Daytona support added value for ulRefreshRate and index for QVCMDS
 //
 USE_HARDWARE_DEFAULT,		    // refresh rate
 QV_TEXT_640x480x4_INDEX
},

//////////////////////////////////////////////////////////////
//    Mode index 3
//    Standard VGA Color graphics, 640x480x4 - 16 colors
//    BIOS mode: 0x12
//    Refresh rate: 60Hz
//////////////////////////////////////////////////////////////
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 80, 30,
  640, 480, 80, 0x10000, NoBanking, MemMap_VGA,
  vmem256k,             // video memory required to run mode
  FALSE,                // ModeValid default is always ok
#ifdef INIT_INT10
  {0x12},
#else
  {QV_TEXT_640x480x4},
#endif
 //
 // $0005 - MikeD - 02/08/94
 // Daytona support added value for ulRefreshRate and index for QVCMDS
 //
 60,			   // refresh rate
 QV_TEXT_640x480x4_INDEX
},

//////////////////////////////////////////////////////////////
//    Mode index 4
//    VGA Color graphics, 640x480x8 - 256 colors
//    BIOS mode: 0x32
//    Refresh rate: Hardware default
//////////////////////////////////////////////////////////////
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 1024, 0x80000, NormalBanking, MemMap_VGA,
  vmem512k,             // video memory required to run mode
  FALSE,                // ModeValid default is always ok
#ifdef INIT_INT10
  {0x32},
#else
  {QV_640x480x8},
#endif
 //
 // $0005 - MikeD - 02/08/94
 // Daytona support added value for ulRefreshRate and index for QVCMDS
 //
 USE_HARDWARE_DEFAULT,			 // refresh rate
 QV_640x480x8_INDEX
},

//////////////////////////////////////////////////////////////
//    Mode index 5
//    VGA Color graphics, 640x480x8 - 256 colors
//    BIOS mode: 0x32
//    Refresh rate: 60Hz
//////////////////////////////////////////////////////////////
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 1024, 0x80000, NormalBanking, MemMap_VGA,
  vmem512k,             // video memory required to run mode
  FALSE,                // ModeValid default is always ok
#ifdef INIT_INT10
  {0x32},
#else
  {QV_640x480x8},
#endif
 //
 // $0005 - MikeD - 02/08/94
 // Daytona support added value for ulRefreshRate and index for QVCMDS
 //
 60,			 // refresh rate
 QV_640x480x8_INDEX
},

//////////////////////////////////////////////////////////////
//    Mode index 6
//    SVGA color graphics, 800x600x8 - 256 colors
//    BIOS Mode: 0x34.
//    Refresh rate: Hardware default
//////////////////////////////////////////////////////////////
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 100, 37,
  800, 600, 1024, 0x100000, NormalBanking, MemMap_VGA,
  vmem1Meg,             // video memory required to run mode
  FALSE,                // ModeValid default is always ok
#ifdef INIT_INT10
  {0x34},               // mode is not supported by BIOS
#else  
  {QV_800x600x8},
#endif
 //
 // $0005 - MikeD - 02/08/94
 // Daytona support added value for ulRefreshRate and index for QVCMDS
 //
 USE_HARDWARE_DEFAULT,			 // refresh rate
 QV_800x600x8_INDEX
},

//////////////////////////////////////////////////////////////
//    Mode index 7
//    SVGA color graphics, 800x600x8 - 256 colors
//    BIOS Mode: 0x34.
//    Refresh rate: 60Hz
//////////////////////////////////////////////////////////////
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 100, 37,
  800, 600, 1024, 0x100000, NormalBanking, MemMap_VGA,
  vmem1Meg,             // video memory required to run mode
  FALSE,                // ModeValid default is always ok
#ifdef INIT_INT10
  {0x34},               // mode is not supported by BIOS
#else  
  {QV_800x600x8},
#endif
 //
 // $0005 - MikeD - 02/08/94
 // Daytona support added value for ulRefreshRate and index for QVCMDS
 //
 60,			 // refresh rate
 QV_800x600x8_INDEX
},

//////////////////////////////////////////////////////////////
//    Mode index 8
//    SVGA color graphics, 800x600x8 - 256 colors
//    BIOS Mode: 0x34.
//    Refresh rate: 72Hz
//////////////////////////////////////////////////////////////
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 100, 37,
  800, 600, 1024, 0x100000, NormalBanking, MemMap_VGA,
  vmem1Meg,             // video memory required to run mode
  FALSE,                // ModeValid default is always ok
#ifdef INIT_INT10
  {0x34},               // mode is not supported by BIOS
#else  
  {QV_800x600x8},
#endif
 //
 // $0005 - MikeD - 02/08/94
 // Daytona support added value for ulRefreshRate and index for QVCMDS
 //
 72,			 // refresh rate
 QV_800x600x8_INDEX
},

//////////////////////////////////////////////////////////////
//    Mode index 9
//    SVGA color graphics, 1024x768x8 - 256 colors
//    BIOS mode:0x38
//    Refresh rate: Hardware default
//////////////////////////////////////////////////////////////
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 128, 48,
  1024, 768, 1024, 0x100000, NormalBanking, MemMap_VGA,
  vmem1Meg,             // video memory required to run mode
  FALSE,                // ModeValid default is always ok
#ifdef INIT_INT10
   {0x38},
#else
  {QV_1024x768x8},
#endif
 //
 // $0005 - MikeD - 02/08/94
 // Daytona support added value for ulRefreshRate and index for QVCMDS
 //
 USE_HARDWARE_DEFAULT,			 // refresh rate
 QV_1024x768x8_INDEX
},

//////////////////////////////////////////////////////////////
//    Mode index 10
//    SVGA color graphics, 1024x768x8 - 256 colors
//    BIOS mode:0x38
//    Refresh rate: 60Hz
//////////////////////////////////////////////////////////////
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 128, 48,
  1024, 768, 1024, 0x100000, NormalBanking, MemMap_VGA,
  vmem1Meg,             // video memory required to run mode
  FALSE,                // ModeValid default is always ok
#ifdef INIT_INT10
   {0x38},
#else
  {QV_1024x768x8},
#endif
 //
 // $0005 - MikeD - 02/08/94
 // Daytona support added value for ulRefreshRate and index for QVCMDS
 //
 60,			 // refresh rate
 QV_1024x768x8_INDEX
},

//////////////////////////////////////////////////////////////
//    Mode index 11
//    SVGA color graphics, 1024x768x8 - 256 colors
//    BIOS mode:0x38
//    Refresh rate: 66Hz
//////////////////////////////////////////////////////////////
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 128, 48,
  1024, 768, 1024, 0x100000, NormalBanking, MemMap_VGA,
  vmem1Meg,             // video memory required to run mode
  FALSE,                // ModeValid default is always ok
#ifdef INIT_INT10
   {0x38},
#else
  {QV_1024x768x8},
#endif
 //
 // $0005 - MikeD - 02/08/94
 // Daytona support added value for ulRefreshRate and index for QVCMDS
 //
 66,			 // refresh rate
 QV_1024x768x8_INDEX
},

//////////////////////////////////////////////////////////////
//    Mode index 12
//    SVGA color graphics, 1024x768x8 - 256 colors
//    BIOS mode:0x38
//    Refresh rate: 72Hz
//////////////////////////////////////////////////////////////
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 128, 48,
  1024, 768, 1024, 0x100000, NormalBanking, MemMap_VGA,
  vmem1Meg,             // video memory required to run mode
  FALSE,                // ModeValid default is always ok
#ifdef INIT_INT10
   {0x38},
#else
  {QV_1024x768x8},
#endif
 //
 // $0005 - MikeD - 02/08/94
 // Daytona support added value for ulRefreshRate and index for QVCMDS
 //
 72,			 // refresh rate
 QV_1024x768x8_INDEX
},

//////////////////////////////////////////////////////////////
//    Mode index 13
//    SVGA color graphics, 1024x768x8 - 256 colors
//    BIOS mode:0x38
//    Refresh rate: 75Hz
//////////////////////////////////////////////////////////////
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 128, 48,
  1024, 768, 1024, 0x100000, NormalBanking, MemMap_VGA,
  vmem1Meg,             // video memory required to run mode
  FALSE,                // ModeValid default is always ok
#ifdef INIT_INT10
   {0x38},
#else
  {QV_1024x768x8},
#endif
 //
 // $0005 - MikeD - 02/08/94
 // Daytona support added value for ulRefreshRate and index for QVCMDS
 //
 75,			 // refresh rate
 QV_1024x768x8_INDEX
},

//////////////////////////////////////////////////////////////
//    Mode index 14
//    SVGA color graphics, 1280x1024x8 - 256 colors
//    BIOS mode: 3A
//    Refresh rate: Hardware default
//////////////////////////////////////////////////////////////
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 128, 48,
  1280, 1024, 2048, 0x200000, NormalBanking, MemMap_VGA,
  vmem2Meg,             // video memory required to run mode
  FALSE,                // ModeValid default is always ok
#ifdef INIT_INT10
   {0x3A},
#else
  {QV_1280x1024x8},
#endif
 //
 // $0005 - MikeD - 02/08/94
 // Daytona support added value for ulRefreshRate and index for QVCMDS
 //
 USE_HARDWARE_DEFAULT,			 // refresh rate
 QV_1280x1024x8_INDEX
},

//////////////////////////////////////////////////////////////
//    Mode index 15
//    SVGA color graphics, 1280x1024x8 - 256 colors
//    BIOS mode: 3A
//    Refresh rate: 60Hz
//////////////////////////////////////////////////////////////
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 128, 48,
  1280, 1024, 2048, 0x200000, NormalBanking, MemMap_VGA,
  vmem2Meg,             // video memory required to run mode
  FALSE,                // ModeValid default is always ok
#ifdef INIT_INT10
   {0x3A},
#else
  {QV_1280x1024x8},
#endif
 //
 // $0005 - MikeD - 02/08/94
 // Daytona support added value for ulRefreshRate and index for QVCMDS
 //
 60,			 // refresh rate
 QV_1280x1024x8_INDEX
},

//////////////////////////////////////////////////////////////
//    Mode index 16
//    SVGA color graphics, 1280x1024x8 - 256 colors
//    BIOS mode: 3A
//    Refresh rate: 68Hz
//////////////////////////////////////////////////////////////
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 128, 48,
  1280, 1024, 2048, 0x200000, NormalBanking, MemMap_VGA,
  vmem2Meg,             // video memory required to run mode
  FALSE,                // ModeValid default is always ok
#ifdef INIT_INT10
   {0x3A},
#else
  {QV_1280x1024x8},
#endif
 //
 // $0005 - MikeD - 02/08/94
 // Daytona support added value for ulRefreshRate and index for QVCMDS
 //
 68,			 // refresh rate
 QV_1280x1024x8_INDEX
},

//////////////////////////////////////////////////////////////
//    Mode index 17
//    SVGA color graphics, 1280x1024x8 - 256 colors
//    BIOS mode: 3A
//    Refresh rate: 75Hz
//////////////////////////////////////////////////////////////
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 128, 48,
  1280, 1024, 2048, 0x200000, NormalBanking, MemMap_VGA,
  vmem2Meg,             // video memory required to run mode
  FALSE,                // ModeValid default is always ok
#ifdef INIT_INT10
   {0x3A},
#else
  {QV_1280x1024x8},
#endif
 //
 // $0005 - MikeD - 02/08/94
 // Daytona support added value for ulRefreshRate and index for QVCMDS
 //
 76,			 // refresh rate
 QV_1280x1024x8_INDEX
},

}; // ModesVGA


ULONG NumVideoModes = sizeof(ModesVGA) / sizeof(VIDEOMODE);


//
//
// Data used to set the Graphics and Sequence Controllers to put the
// VGA into a planar state at A0000 for 64K, with plane 2 enabled for
// reads and writes, so that a font can be loaded, and to disable that mode.
//

// Settings to enable planar mode with plane 2 enabled.
//

USHORT EnableA000Data[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    1,
    0x0100,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0204,             // Read Map = plane 2
    0x0005,             // Graphics Mode = read mode 0, write mode 0
    0x0406,             // Graphics Miscellaneous register = A0000 for 64K, not odd/even,
                        //  graphics mode
    OWM,
    SEQ_ADDRESS_PORT,
    3,
    0x0402,             // Map Mask = write to plane 2 only
    0x0404,             // Memory Mode = not odd/even, not full memory, graphics mode
    0x0300,             // end sync reset
    EOD
};

//
// Settings to disable the font-loading planar mode.
//

USHORT DisableA000Color[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    1,
    0x0100,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0004, 0x1005, 0x0E06,

    OWM,
    SEQ_ADDRESS_PORT,
    3,
    0x0302, 0x0204, 0x0300,  // end sync reset
    EOD

};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\mini\qvision.h ===
/*++

Copyright (c) 1992  Microsoft Corporation
Copyright (c) 1993  Compaq Computer Corporation

Module Name:

    qvision.h

Abstract:

    This module contains the definitions for the code that implements the
    Compaq QVision VGA device driver.

Environment:

    Kernel mode

Revision History:

    $0003
      miked: 12/14/1993
         Added ioctl CPQ_IOCTL_VIDEO_INFO to give asic info and more
         back to the hardware accelerated port driver. Also added min macro.
         Added #include of qry_nt.h to get access to structure
         VIDEO_CHIP_INFO (added to device extension).

--*/

//
// $0003 miked 12/14/1993 - Added #include "qry_nt.h"
//
#include "qry_nt.h"

//
//  QVision memory save/restore request flag
//

#define QV_SAVE_FRAME_BUFFER    1
#define QV_RESTORE_FRAME_BUFFER 0

//
// Banking ifdefs to enable banking
// the banking type MUST match the type in clhard.asm
//

#define ONE_64K_BANK             0
#define TWO_32K_BANKS            1
#define MULTIPLE_REFRESH_TABLES  0

//
// Base address of VGA memory range.  Also used as base address of VGA
// memory when loading a font, which is done with the VGA mapped at A0000.
//

#define MEM_VGA      0xA0000
#define MEM_VGA_SIZE 0x20000

//
// Port definitions for filling the ACCSES_RANGES structure in the miniport
// information, defines the range of I/O ports the VGA spans.
// There is a break in the IO ports - a few ports are used for the parallel
// port. Those cannot be defined in the ACCESS_RANGE, but are still mapped
// so all VGA ports are in one address range.
//


#define VGA_BASE_IO_PORT        0x000003B0
#define VGA_START_BREAK_PORT    0x000003BB
#define VGA_END_BREAK_PORT      0x000003C0
#define VGA_MAX_IO_PORT         0x000003DF

// adrianc 4/15/1993
//
// We need to reserve many small ranges instead
// of one large range so that we don't conflict with
// any other driver which needs some of the registers
// we are not using.
//

#define QV_START_EXT_PORT_1   0x000013C0    // extended register access
#define QV_END_EXT_PORT_1     0x000013D0    // ranges reserved by the
#define QV_START_EXT_PORT_2   0x000023C0    // Qvision miniport driver
#define QV_END_EXT_PORT_2     0x000023D0
#define QV_START_EXT_PORT_3   0x000033C0
#define QV_END_EXT_PORT_3     0x000033D0
#define QV_START_EXT_PORT_4   0x000046E0
#define QV_END_EXT_PORT_4     0x000046F0
#define QV_START_EXT_PORT_5   0x000053C0
#define QV_END_EXT_PORT_5     0x000053D0
#define QV_START_EXT_PORT_6   0x000063C0
#define QV_END_EXT_PORT_6     0x000063D0
#define QV_START_EXT_PORT_7   0x000073C0
#define QV_END_EXT_PORT_7     0x000073D0
#define QV_START_EXT_PORT_8   0x000083C0
#define QV_END_EXT_PORT_8     0x000083D0
#define QV_START_EXT_PORT_9   0x000093C0
#define QV_END_EXT_PORT_9     0x000093D0


//
// Maximum size of the hardware mouse pointer.
//

#define POINTER_MAX_HEIGHT 32               // QVision can handle a
#define POINTER_MAX_WIDTH  32               // 32x32x2 hardware pointer
#define POINTER_COLOR_NUM  2
#define POINTER_PLANE_SIZE   32*32*2        // 2K bytes for cursor data

//
// VGA port-related definitions.
//

//
// VGA register definitions - offsets from VGA_BASE_IO_ADDRESS
//
                                            // ports in monochrome mode
#define CRTC_ADDRESS_PORT_MONO      0x0004  // CRT Controller Address and
#define CRTC_DATA_PORT_MONO         0x0005  // Data registers in mono mode
#define FEAT_CTRL_WRITE_PORT_MONO   0x000A  // Feature Control write port
                                            // in mono mode
#define INPUT_STATUS_1_MONO         0x000A  // Input Status 1 register read
                                            // port in mono mode
#define ATT_INITIALIZE_PORT_MONO    INPUT_STATUS_1_MONO
                                            // Register to read to reset
                                            // Attribute Controller index/data
#define ATT_ADDRESS_PORT            0x0010  // Attribute Controller Address and
#define ATT_DATA_WRITE_PORT         0x0010  // Data registers share one port
                                            // for writes, but only Address is
                                            // readable at 0x010
#define ATT_DATA_READ_PORT          0x0011  // Attribute Controller Data reg is
                                            // readable here
#define MISC_OUTPUT_REG_WRITE_PORT  0x0012  // Miscellaneous Output reg write
                                            // port
#define INPUT_STATUS_0_PORT         0x0012  // Input Status 0 register read
                                            // port
#define VIDEO_SUBSYSTEM_ENABLE_PORT 0x0013  // Bit 0 enables/disables the
                                            // entire VGA subsystem
#define SEQ_ADDRESS_PORT            0x0014  // Sequence Controller Address and
#define SEQ_DATA_PORT               0x0015  // Data registers
#define DAC_PIXEL_MASK_PORT         0x0016  // DAC pixel mask reg
#define DAC_ADDRESS_READ_PORT       0x0017  // DAC register read index reg,
                                            // write-only
#define DAC_STATE_PORT              0x0017  // DAC state (read/write),
                                            // read-only
#define DAC_ADDRESS_WRITE_PORT      0x0018  // DAC register write index reg
#define DAC_DATA_REG_PORT           0x0019  // DAC data transfer reg
#define FEAT_CTRL_READ_PORT         0x001A  // Feature Control read port
#define MISC_OUTPUT_REG_READ_PORT   0x001C  // Miscellaneous Output reg read
                                            // port
#define GRAPH_ADDRESS_PORT          0x001E  // Graphics Controller Address
#define GRAPH_DATA_PORT             0x001F  // and Data registers

                                            // ports in color mode
#define CRTC_ADDRESS_PORT_COLOR     0x0024  // CRT Controller Address and
#define CRTC_DATA_PORT_COLOR        0x0025  // Data registers in color mode
#define FEAT_CTRL_WRITE_PORT_COLOR  0x002A  // Feature Control write port
#define INPUT_STATUS_1_COLOR        0x002A  // Input Status 1 register read
                                            // port in color mode
#define ATT_INITIALIZE_PORT_COLOR   INPUT_STATUS_1_COLOR
                                            // Register to read to reset
                                            // Attribute Controller index/data
                                            // toggle in color mode
//
// Offsets in HardwareStateHeader->PortValue[] of save areas for non-indexed
// VGA registers.
//

#define CRTC_ADDRESS_MONO_OFFSET      0x04
#define FEAT_CTRL_WRITE_MONO_OFFSET   0x0A
#define ATT_ADDRESS_OFFSET            0x10
#define MISC_OUTPUT_REG_WRITE_OFFSET  0x12
#define VIDEO_SUBSYSTEM_ENABLE_OFFSET 0x13
#define SEQ_ADDRESS_OFFSET            0x14
#define DAC_PIXEL_MASK_OFFSET         0x16
#define DAC_STATE_OFFSET              0x17
#define DAC_ADDRESS_WRITE_OFFSET      0x18
#define GRAPH_ADDRESS_OFFSET          0x1E
#define CRTC_ADDRESS_COLOR_OFFSET     0x24
#define FEAT_CTRL_WRITE_COLOR_OFFSET  0x2A
                                                                                                                  // toggle in color mode
//
// VGA indexed register indexes.
//
                                            //
#define IND_CURSOR_START        0x0A        // index in CRTC of the Cursor Start
#define IND_CURSOR_END          0x0B        //  and End registers
#define IND_CURSOR_HIGH_LOC     0x0E        // index in CRTC of the Cursor Location
#define IND_CURSOR_LOW_LOC      0x0F        //  High and Low Registers
#define IND_VSYNC_END           0x11        // index in CRTC of the Vertical Sync
                                            //  End register, which has the bit
                                            //  that protects/unprotects CRTC
                                            //  index registers 0-7
#define IND_SET_RESET_ENABLE    0x01        // index of Set/Reset Enable reg in GC
#define IND_DATA_ROTATE         0x03        // index of Data Rotate reg in GC
#define IND_READ_MAP            0x04        // index of Read Map reg in Graph Ctlr
#define IND_GRAPH_MODE          0x05        // index of Mode reg in Graph Ctlr
#define IND_GRAPH_MISC          0x06        // index of Misc reg in Graph Ctlr
#define IND_BIT_MASK            0x08        // index of Bit Mask reg in Graph Ctlr
#define IND_SYNC_RESET          0x00        // index of Sync Reset reg in Seq
#define IND_MAP_MASK            0x02        // index of Map Mask in Sequencer
#define IND_MEMORY_MODE         0x04        // index of Memory Mode reg in Seq
#define IND_CRTC_PROTECT        0x11        // index of reg containing regs 0-7 in
                                            //  CRTC
#define START_SYNC_RESET_VALUE  0x01        // value for Sync Reset reg to start
                                            //  synchronous reset
#define END_SYNC_RESET_VALUE    0x03        // value for Sync Reset reg to end
                                            //  synchronous reset
#define COLOR_ADJUSTMENT        0x20        /*  */
//
// Number of each type of indexed register in a standard VGA, used by
// validator and state save/restore functions.
//
// Note: VDMs currently only support basic VGAs only.
//

#define VGA_NUM_SEQUENCER_PORTS     5
#define VGA_NUM_CRTC_PORTS         25
#define VGA_NUM_GRAPH_CONT_PORTS    9
#define VGA_NUM_ATTRIB_CONT_PORTS  21
#define VGA_NUM_DAC_ENTRIES       256

//
// Indices to start save/restore in extension registers:
//


#define QV_GRAPH_EXT_START          0x0b  // qv specific extended gra indices
#define QV_GRAPH_EXT_END            0x6b

#define EXT_NUM_MAIN_13C6        4
#define EXT_NUM_MAIN_23CX        16
#define EXT_NUM_MAIN_33CX        20
#define EXT_NUM_MAIN_46E8        1
#define EXT_NUM_MAIN_63CX        16
#define EXT_NUM_MAIN_83CX        16
#define EXT_NUM_MAIN_93CX        4
#define EXT_NUM_MAIN_REGISTERS   EXT_NUM_MAIN_13C6 +   \
                                 EXT_NUM_MAIN_23CX +   \
                                 EXT_NUM_MAIN_33CX +   \
                                 EXT_NUM_MAIN_46E8 +   \
                                 EXT_NUM_MAIN_63CX +   \
                                 EXT_NUM_MAIN_83CX +   \
                                 EXT_NUM_MAIN_93CX

//
// Number of each type of extended indexed register.
//
#ifdef  QV_EXTENDED_SAVE
#define EXT_NUM_GRAPH_CONT_PORTS   (QV_GRAPH_EXT_END - QV_GRAPH_EXT_START + 1)
#else
#define EXT_NUM_GRAPH_CONT_PORTS    0
#endif

#define EXT_NUM_SEQUENCER_PORTS     0
#define EXT_NUM_CRTC_PORTS          EXT_NUM_MAIN_REGISTERS
#define EXT_NUM_ATTRIB_CONT_PORTS   0
#define EXT_NUM_DAC_ENTRIES         4

//
// Values for Attribute Controller Index register to turn video off
// and on, by setting bit 5 to 0 (off) or 1 (on).
//

#define VIDEO_DISABLE 0
#define VIDEO_ENABLE  0x20

// Masks to keep only the significant bits of the Graphics Controller and
// Sequencer Address registers. Masking is necessary because some VGAs, such
// as S3-based ones, don't return unused bits set to 0, and some SVGAs use
// these bits if extensions are enabled.
//

#define GRAPH_ADDR_MASK 0x0F
#define SEQ_ADDR_MASK   0x07

//
// Mask used to toggle Chain4 bit in the Sequencer's Memory Mode register.
//

#define CHAIN4_MASK 0x08

//
// Value written to the Read Map register when identifying the existence of
// a VGA in VgaInitialize. This value must be different from the final test
// value written to the Bit Mask in that routine.
//

#define READ_MAP_TEST_SETTING 0x03

//
// Default text mode setting for various registers, used to restore their
// states if VGA detection fails after they've been modified.
//

#define MEMORY_MODE_TEXT_DEFAULT 0x02
#define BIT_MASK_DEFAULT 0xFF
#define READ_MAP_DEFAULT 0x00


//
// Palette-related info.
//

//
// Highest valid DAC color register index.
//

#define VIDEO_MAX_COLOR_REGISTER  0xFF

//
// Highest valid palette register index
//

#define VIDEO_MAX_PALETTE_REGISTER 0x0F

//
//  QVision specific register values.
//
#define DAC_CMD_0             0x83c6
#define DAC_CMD_1             0x13c8
#define DAC_CMD_2             0x13C9        // QVision DAC Command Register 2
#define DAC_RAM_MEM           0x13c7        // DAC hardware pointer bitmap RAM

#define DAC_PTR_Y_HIGH        0x93c7        // hardware pointer coordinates
#define DAC_PTR_Y_LOW         0x93c6
#define DAC_PTR_X_HIGH        0x93c9
#define DAC_PTR_X_LOW         0x93c8
#define DAC_RAM_INDEX         0x3c7

#define DAC_STATUS_REG        0x13c6        // DAC status register
#define DAC_CMD_3_INDEX       0x01          // DAC Cmd register 3 index for
                                            // ORION. (write it to 13c8)
#define DBL_CLK               0x08          // double clock for 1280 modes

#define   CURSOR_ENABLE      0x02
#define   CURSOR_DISABLE     0x00

#define CURSOR_WRITE        0x3C8     // HW Cursor registers - ecr
#define CURSOR_READ         0x3C7
#define   CURSOR_PLANE_0     0x00
#define   CURSOR_PLANE_1     0x80
#define CURSOR_DATA        0x13C7
#define CURSOR_COLOR_READ  0x83C7
#define CURSOR_COLOR_WRITE 0x83C8
#define CURSOR_COLOR_DATA  0x83C9
#define   OVERSCAN_COLOR     0x00
#define   CURSOR_COLOR_1     0x01
#define   CURSOR_COLOR_2     0x02
#define   CURSOR_COLOR_3     0x03
#define CURSOR_X           0x93C8     // 16-bit register
#define CURSOR_Y           0x93C6     // 16-bit register
#define   CURSOR_CX            32     // h/w pointer width
#define   CURSOR_CY            32     // h/w pointer height


//
// Indices for type of memory mapping; used in ModesVGA[], must match
// MemoryMap[].
//

typedef enum _VIDEO_MEMORY_MAP {
    MemMap_Mono,
    MemMap_CGA,
    MemMap_VGA,
    MemMap_Flat
} VIDEO_MEMORY_MAP, *PVIDEO_MEMORY_MAP;

//
// For a mode, the type of banking supported. Controls the information
// returned in VIDEO_BANK_SELECT. PlanarHCBanking includes NormalBanking.
//

typedef enum _BANK_TYPE {
    NoBanking = 0,
    NormalBanking,
    PlanarHCBanking
} BANK_TYPE, *PBANK_TYPE;


typedef enum {
    vmem256k = 0,
    vmem512k,
    vmem1Meg,
    vmem2Meg
} VMEM_SIZE, *PVMEM_SIZE;

typedef struct {                            // This can be extended later
   PUSHORT QVCmdStrings;                    // to include sveral options
 } CLCMD, *PCLCMD;


//  adrianc 4/5/1993
//
//  QVision definitions.
//
typedef enum _AdapterTypes
{
   NotAries = 0,
   AriesIsa,                                // QVision/I
   AriesEisa,                               // QVision/E
   FirEisa,                                 // FIR EISA card
   FirIsa,                                  // FIR ISA card
   JuniperEisa,                             // JUNIPER EISA card
   JuniperIsa,                              // JUNIPER ISA card
   NUM_ADAPTER_TYPES                        // number of supported adapters
} ADAPTERTYPE, *PADAPTERTYPE;

typedef enum _MonClass
{
   Monitor_Vga = 0,                         // COMPAQ VGA monitor       = 0
   Monitor_AG1024,                          // COMPAQ AG1024 monitor    = 1
   Monitor_Qvision,                         // COMPAQ QVISION monitor   = 2
   Monitor_1280,                            // COMPAQ 1280 monitor      = 3
   Monitor_SVGA,                            // COMPAQ SVGA monitor      = 4
   Monitor_60Hz,                            // 60Hz VRefresh rate       = 6
   Monitor_66Hz,                            // 66Hz VRefresh rate       = 7
   Monitor_68Hz,                            // 68Hz VRefresh rate       = 8
   Monitor_72Hz,                            // 72Hz VRefresh rate       = 9
   Monitor_75Hz,                            // 75Hz VRefresh rate       = A
   Monitor_76Hz,                            // 76Hz VRefresh rate       = B
   NUM_MONITOR_CLASSES,
   Monitor_Third_Party=99,

} MONCLASS, *PMONCLASS;

//
// $0005 - MikeD - 02/08/94
// Begin...
// new struct for monitor data...
//
typedef struct {

    USHORT CommandIndex;     // index into mode command table
    USHORT bRegsPresent;     // boolean 1=program the crtc, 0=do not program
    USHORT MiscOut;          // Misc Out register value for this mode.
    USHORT Overflow;         // Overflow 2 register value for this mode.
    USHORT crtRegisters[25]; // array of CRT register values

    } MONRES, *PMONRES;

   //
   // MAX_RESOLUTIONS corresponds to a count of all "WWWxHHHxD_INDEX" type
   // command indexes, for example QV_TEXT_720x400x4_INDEX and
   // QV_1280x1024x8_INDEX, etc.
   //

#define MAX_RESOLUTIONS  7

typedef struct {

    MONRES MonitorResolution[ MAX_RESOLUTIONS ];

   } MONTYPE, *PMONTYPE;

//
// Default refresh rate for the video applet.
//

#define USE_HARDWARE_DEFAULT  1

//
// $0005 - MikeD - 02/08/94
// End...
//


//
// Structure used to describe each video mode in ModesVGA[].
//

typedef struct {
   USHORT  fbType;              // color or monochrome, text or graphics, via
                                //  VIDEO_MODE_COLOR and VIDEO_MODE_GRAPHICS
   USHORT  numPlanes;           // # of video memory planes
   USHORT  bitsPerPlane;        // # of bits of color in each plane
   SHORT   col;                 // # of text columns across screen with default font
   SHORT   row;                 // # of text rows down screen with default font
   USHORT  hres;                // # of pixels across screen
   USHORT  vres;                // # of scan lines down screen
   USHORT  wbytes;              // # of bytes from start of one scan line to start of next
   ULONG   sbytes;              // total size of addressable display memory in bytes
   BANK_TYPE banktype;          // NoBanking, NormalBanking, PlanarHCBanking
   VIDEO_MEMORY_MAP   MemMap;   // index from VIDEO_MEMORY_MAP of memory
                                //  mapping used by this mode
   VMEM_SIZE  VmemRequired;     // video memory required for this mode
   BOOLEAN    ValidMode;        // TRUE if mode valid, FALSE if not

//
// the mode will be TRUE if there is enough video memory to support the
// mode, and the display type(it could be a panel), will support the mode.
// PANELS only support 640x480 for now.
//
#ifdef INIT_INT10
   USHORT usInt10ModeNum;
#else
    CLCMD CmdStrings;           // pointer to array of register-setting commands to
#endif

  //
  // $0005 - MikeD - 02/08/94
  //
  //  This ulong was added to keep the refresh rates for each video
  //  mode.  This information is returned in VgaQueryAvailableModes.
  //  Also, ulResIndex was added as an index into the QVCMDS for each mode.
  //
  ULONG ulRefreshRate;
  ULONG ulResIndex;          // QV_TEXT_720x400x4_INDEX, etc.

} VIDEOMODE, *PVIDEOMODE;

//
// Mode into which to put the VGA before starting a VDM, so it's a plain
// vanilla VGA.  (This is the mode's index in ModesVGA[], currently standard
// 80x25 text mode.)
//

#define DEFAULT_MODE 0


//
// Info used by the Validator functions and save/restore code.
// Structure used to trap register accesses that must be done atomically.
//

#define VGA_MAX_VALIDATOR_DATA       100

#define VGA_VALIDATOR_UCHAR_ACCESS   1
#define VGA_VALIDATOR_USHORT_ACCESS  2
#define VGA_VALIDATOR_ULONG_ACCESS   3

typedef struct _VGA_VALIDATOR_DATA {
   ULONG Port;
   UCHAR AccessType;
   ULONG Data;
} VGA_VALIDATOR_DATA, *PVGA_VALIDATOR_DATA;

//
// Number of bytes to save in each plane for VGA modes,
// entire frame buffer size for QVision modes.
//
#define VGA_PLANE_SIZE          0x10000
#define QV_FRAME_BUFFER_SIZE    0x40000

//
// These constants determine the offsets within the
// VIDEO_HARDWARE_STATE_HEADER structure that are used to save and
// restore the VGA's state.
//

#define VGA_HARDWARE_STATE_SIZE sizeof(VIDEO_HARDWARE_STATE_HEADER)

#define VGA_BASIC_SEQUENCER_OFFSET  (VGA_HARDWARE_STATE_SIZE + 0)
#define VGA_BASIC_CRTC_OFFSET       (VGA_BASIC_SEQUENCER_OFFSET +   \
                                    VGA_NUM_SEQUENCER_PORTS)
#define VGA_BASIC_GRAPH_CONT_OFFSET (VGA_BASIC_CRTC_OFFSET +        \
                                    VGA_NUM_CRTC_PORTS)
#define VGA_BASIC_ATTRIB_CONT_OFFSET (VGA_BASIC_GRAPH_CONT_OFFSET + \
                                    VGA_NUM_GRAPH_CONT_PORTS)
#define VGA_BASIC_DAC_OFFSET        (VGA_BASIC_ATTRIB_CONT_OFFSET + \
                                    VGA_NUM_ATTRIB_CONT_PORTS)
#define VGA_BASIC_LATCHES_OFFSET    (VGA_BASIC_DAC_OFFSET +         \
                                    (3 * VGA_NUM_DAC_ENTRIES))

#define VGA_EXT_SEQUENCER_OFFSET    (VGA_BASIC_LATCHES_OFFSET + 4)
#define VGA_EXT_CRTC_OFFSET         (VGA_EXT_SEQUENCER_OFFSET +     \
                                    EXT_NUM_SEQUENCER_PORTS)
//
// Establish save buffer offsets for QVision extended registers
// within the VGA_EXT_CRTC range
//
#define EXT_MAIN_REG_13C6           0
#define EXT_MAIN_REG_23CX           EXT_MAIN_REG_13C6 + EXT_NUM_MAIN_13C6
#define EXT_MAIN_REG_33CX           EXT_MAIN_REG_23CX + EXT_NUM_MAIN_23CX
#define EXT_MAIN_REG_46E8           EXT_MAIN_REG_33CX + EXT_NUM_MAIN_33CX
#define EXT_MAIN_REG_63CX           EXT_MAIN_REG_46E8 + EXT_NUM_MAIN_46E8
#define EXT_MAIN_REG_83CX           EXT_MAIN_REG_63CX + EXT_NUM_MAIN_63CX
#define EXT_MAIN_REG_93CX           EXT_MAIN_REG_83CX + EXT_NUM_MAIN_83CX

#define VGA_EXT_GRAPH_CONT_OFFSET   (VGA_EXT_CRTC_OFFSET +          \
                                    EXT_NUM_CRTC_PORTS)
#define VGA_EXT_ATTRIB_CONT_OFFSET  (VGA_EXT_GRAPH_CONT_OFFSET +    \
                                    EXT_NUM_GRAPH_CONT_PORTS)
#define VGA_EXT_DAC_OFFSET          (VGA_EXT_ATTRIB_CONT_OFFSET +   \
                                    EXT_NUM_ATTRIB_CONT_PORTS)

#define VGA_VALIDATOR_OFFSET (VGA_EXT_DAC_OFFSET + 4 * EXT_NUM_DAC_ENTRIES)

#define VGA_VALIDATOR_AREA_SIZE  sizeof (ULONG) + (VGA_MAX_VALIDATOR_DATA * \
                                 sizeof (VGA_VALIDATOR_DATA)) +             \
                                 sizeof (ULONG) +                           \
                                 sizeof (ULONG) +                           \
                                 sizeof (PVIDEO_ACCESS_RANGE)

#define VGA_MISC_DATA_AREA_OFFSET VGA_VALIDATOR_OFFSET + VGA_VALIDATOR_AREA_SIZE

#define VGA_MISC_DATA_AREA_SIZE  0

#define VGA_PLANE_0_OFFSET          VGA_MISC_DATA_AREA_OFFSET + \
                                    VGA_MISC_DATA_AREA_SIZE
#define QV_FRAME_BUFFER_OFFSET      VGA_PLANE_0_OFFSET

#define VGA_PLANE_1_OFFSET VGA_PLANE_0_OFFSET + VGA_PLANE_SIZE
#define VGA_PLANE_2_OFFSET VGA_PLANE_1_OFFSET + VGA_PLANE_SIZE
#define VGA_PLANE_3_OFFSET VGA_PLANE_2_OFFSET + VGA_PLANE_SIZE

//
// Space needed to store all state data.
//
#ifdef  QV_EXTENDED_SAVE
#define QV_TOTAL_STATE_SIZE QV_FRAME_BUFFER_OFFSET + QV_FRAME_BUFFER_SIZE
#else
#define VGA_TOTAL_STATE_SIZE VGA_PLANE_3_OFFSET + VGA_PLANE_SIZE
#endif

//
// Device extension for the driver object.  This data is only used
// locally, so this structure can be added to as needed.
//

typedef struct _HW_DEVICE_EXTENSION {

    PUCHAR  IOAddress;                      // base I/O address of VGA ports
    PUCHAR  VideoMemoryAddress;             // base virtual memory address of VGA memory
    ULONG   NumAvailableModes;              // number of available modes this session

    ULONG   ModeIndex;                      // index of current mode in ModesVGA[]
    PVIDEOMODE  CurrentMode;                // pointer to VIDEOMODE structure for
                                            // current mode

    USHORT  FontPelColumns;                 // Width of the font in pels
    USHORT  FontPelRows;                    // height of the font in pels

    VIDEO_CURSOR_POSITION CursorPosition;   // current cursor position


    UCHAR CursorEnable;                     // whether cursor is enabled or not
    UCHAR CursorTopScanLine;                // Cursor Start register setting (top scan)
    UCHAR CursorBottomScanLine;             // Cursor End register setting (bottom scan)
                                            // add HW cursor data here
    PHYSICAL_ADDRESS PhysicalVideoMemoryBase; // physical memory address and
    ULONG PhysicalVideoMemoryLength;        // length of display memory
    PHYSICAL_ADDRESS PhysicalMemoryMappedBase;// physical memory-mapped address and
    ULONG PhysicalMemoryMappedLength;       // length of memory-mapped block
                                            // (zero when don't use MM I/O)
    PHYSICAL_ADDRESS PhysicalFrameBase;     // physical memory address and
    ULONG PhysicalFrameLength;              // length of display memory for the
                                            // current mode.
    VMEM_SIZE  InstalledVmem;               // minimum memory needed by current mode

    //  adrianc 4/4/1993
    //
    //  Replaced chipType fields with the VideoHardware structure.
    //
    struct _VIDEO_HARDWARE {
      ADAPTERTYPE AdapterType;              // controller type
      MONCLASS    MonClass;                 // monitor class
      ULONG       ulEisaID;                 // Controller EISA ID
      ULONG       ulHighAddress;            // high address register contents
      BOOLEAN     fBankSwitched;            // TRUE if card is bankswitched
      LONG        lFrequency;               // vertical refresh rate of the monitor
                                            // -1 = not initialized from registry
                                            // 0  = COMPAQ monitor
                                            // XX = Third Party Monitor frequency
    } VideoHardware;

    //
    // $0003
    // 12/14/93 MikeD - Added for passing info to hardware accelerated DLL
    //
    VIDEO_CHIP_INFO VideoChipInfo;


    //
    // These 4 fields must be at the end of the device extension and must be
    // kept in this order since this data will be copied to and from the save
    // state buffer that is passed to and from the VDM.
    //

    ULONG TrappedValidatorCount;            // number of entries in the Trapped
                                            // validator data Array.
    VGA_VALIDATOR_DATA TrappedValidatorData[VGA_MAX_VALIDATOR_DATA];
                                            // Data trapped by the validator routines
                                            // but not yet played back into the VGA
                                            // register.

    ULONG SequencerAddressValue;            // Determines if the Sequencer Address Port
                                            // is currently selecting the SyncReset data
                                            // register.

    ULONG CurrentNumVdmAccessRanges;        // Number of access ranges in
                                            // the access range array pointed
                                            // to by the next field
    PVIDEO_ACCESS_RANGE CurrentVdmAccessRange; // Access range currently
                                            // associated to the VDM
    ULONG DacCmd2;                          // Current contents of DacCmd2
                                            // register.

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

//
// Hardware pointer information.
//

#define PTR_HEIGHT          32          // height of hardware pointer in scans
#define PTR_WIDTH           4           // width of hardware pointer in bytes
#define PTR_WIDTH_IN_PIXELS 32          // width of hardware pointer in pixels


#define VIDEO_MODE_LOCAL_POINTER 0x08   // pointer moves done in display driver


//
// Function prototypes.
//

//
// Entry points for the VGA validator. Used in VgaEmulatorAccessEntries[].
//

VP_STATUS
VgaValidatorUcharEntry (
    ULONG Context,
    ULONG Port,
    UCHAR AccessMode,
    PUCHAR Data
    );

VP_STATUS
VgaValidatorUshortEntry (
    ULONG Context,
    ULONG Port,
    UCHAR AccessMode,
    PUSHORT Data
    );

VP_STATUS
VgaValidatorUlongEntry (
    ULONG Context,
    ULONG Port,
    UCHAR AccessMode,
    PULONG Data
    );

BOOLEAN
VgaPlaybackValidatorData (
    PVOID Context
    );

VP_STATUS
GetMonClass (
    PHW_DEVICE_EXTENSION pHwDeviceExtension);


extern VOID DbgBreakPoint(VOID);

//
// Bank switch code start and end labels, define in HARDWARE.ASM
//
// Different versions based on current mode
//

extern VIDEO_ACCESS_RANGE QVisionAccessRange[];

extern UCHAR QV4kAddrBankSwitchStart;
extern UCHAR QV4kAddrBankSwitchEnd;
extern UCHAR QV4kAddrPlanarHCBankSwitchStart;
extern UCHAR QV4kAddrPlanarHCBankSwitchEnd;
extern UCHAR QV4kAddrEnablePlanarHCStart;
extern UCHAR QV4kAddrEnablePlanarHCEnd;
extern UCHAR QV4kAddrDisablePlanarHCStart;
extern UCHAR QV4kAddrDisablePlanarHCEnd;

extern UCHAR QV16kAddrBankSwitchStart;
extern UCHAR QV16kAddrBankSwitchEnd;
extern UCHAR QV16kAddrPlanarHCBankSwitchStart;
extern UCHAR QV16kAddrPlanarHCBankSwitchEnd;
extern UCHAR QV16kAddrEnablePlanarHCStart;
extern UCHAR QV16kAddrEnablePlanarHCEnd;
extern UCHAR QV16kAddrDisablePlanarHCStart;
extern UCHAR QV16kAddrDisablePlanarHCEnd;

//
// Vga init scripts for font loading
//

extern USHORT EnableA000Data[];
extern USHORT DisableA000Color[];

//
// Mode Information
//

extern ULONG NumVideoModes;
extern VIDEOMODE ModesVGA[];

//
// Extended graphics index registers
//

extern UCHAR extGraIndRegs[];
extern UCHAR extV32GraIndRegs[];


//  adrianc 4/4/1993
//
//  EISA IDs for the COMPAQ Video cards.
//

#define EISA_ID_AVGA          0x0130110E
#define EISA_ID_QVISION_E     0x1130110E    // EISA Qvision board
#define EISA_ID_QVISION_I     0x2130110E    // ISA Qvision board
#define EISA_ID_FIR_E         0x1131110E    // EISA FIR board
#define EISA_ID_FIR_I         0x2131110E    // ISA FIR board
#define EISA_ID_JUNIPER_E     0x1231110E    // EISA JUNIPER board
#define EISA_ID_JUNIPER_I     0x2231110E    // ISA JUNIPER board

//
//  QVision register definitions
//

#define DATAPATH_CONTROL      0x5a
#define ROPSELECT_NO_ROPS     0x00
#define PIXELMASK_ONLY        0x00
#define PLANARMASK_NONE_0XFF  0x04
#define SRC_IS_PATTERN_REGS   0x02
#define PREG_0                0x33CA
#define PREG_1                0x33CB
#define PREG_2                0x33CC
#define PREG_3                0x33CD
#define PREG_4                0x33CA
#define PREG_5                0x33CB
#define PREG_6                0x33CC
#define PREG_7                0x33CD
#define ARIES_CTL_1           0x63CA
#define BLT_DEST_ADDR_LO      0x63CC
#define BLT_DEST_ADDR_HI      0x63CE
#define BITMAP_WIDTH          0x23C2
#define BITMAP_HEIGHT         0x23C4
#define BLT_CMD_0             0x33CE
#define BLT_CMD_1             0x33CF
#define XY_SRC_ADDR           0x40
#define XY_DEST_ADDR          0x80
#define BLT_FORWARD           0x00
#define BLT_START             0x01
#define GLOBAL_BUSY_BIT       0x40

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\mini\qv_data.h ===
/*++

Copyright (c) 1992  Microsoft Corporation
Copyright (c) 1993  Compaq Computer Corporation

Module Name:

    qv_data.h

Abstract:

    This module contains all the global data used by the QVision miniport
    driver.

Environment:

    Kernel mode

Revision History:



--*/

//
//  Extended graphics index registers supported by standard QVision
//  Note: this array must be terminated with 0x00.
//

UCHAR extGraIndRegs[] = {
    0x0b,0x0c,0x0f,0x10,
    0x40,0x41,0x42,0x43,
    0x44,0x45,0x46,0x48,
    0x49,0x50,0x51,0x52,
    0x53,0x54,0x58,0x59,
    0x5a,0x60,0x61,0x62,
    0x63,0x64,0x65,0x66,
    0x67,0x68,0x69,0x6a,
    0x6b,0x00
    };

//
//  Additional extended graphics index registers
//  supported by enhanced QVision. Note: this array
//  must be terminated with 0x00.
//
UCHAR extV32GraIndRegs[] = {
    0x0d,0x11,0x55,0x56,
    0x57,0x00
    };

//
// This structure describes to which ports access is required.
//
#define NUM_QVISION_ACCESS_RANGES  12

VIDEO_ACCESS_RANGE QVisionAccessRange[] = {
{
    VGA_BASE_IO_PORT, 0x00000000,           // 64-bit linear base address
                                            // of range
    VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1, // # of ports
    1,                                      // range is in I/O space
    1,                                      // range should be visible
    0                                       // range should be shareable
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    1,
    0
},
{
    QV_START_EXT_PORT_1, 0x00000000,
    QV_END_EXT_PORT_1 - QV_START_EXT_PORT_1 + 1,
    1,
    1,
    0
},
{
    QV_START_EXT_PORT_2, 0x00000000,
    QV_END_EXT_PORT_2 - QV_START_EXT_PORT_2 + 1,
    1,
    1,
    0
},
{
    QV_START_EXT_PORT_3, 0x00000000,
    QV_END_EXT_PORT_3 - QV_START_EXT_PORT_3 + 1,
    1,
    1,
    0
},
{
    QV_START_EXT_PORT_4, 0x00000000,
    QV_END_EXT_PORT_4 - QV_START_EXT_PORT_4 + 1,
    1,
    1,
    0
},
{
    QV_START_EXT_PORT_5, 0x00000000,
    QV_END_EXT_PORT_5 - QV_START_EXT_PORT_5 + 1,
    1,
    1,
    0
},
{
    QV_START_EXT_PORT_6, 0x00000000,
    QV_END_EXT_PORT_6 - QV_START_EXT_PORT_6 + 1,
    1,
    1,
    0
},
{
    QV_START_EXT_PORT_7, 0x00000000,
    QV_END_EXT_PORT_7 - QV_START_EXT_PORT_7 + 1,
    1,
    1,
    0
},
{
    QV_START_EXT_PORT_8, 0x00000000,
    QV_END_EXT_PORT_8 - QV_START_EXT_PORT_8 + 1,
    1,
    1,
    0
},
{
    QV_START_EXT_PORT_9, 0x00000000,
    QV_END_EXT_PORT_9 - QV_START_EXT_PORT_9 + 1,
    1,
    1,
    0
},
{
    0x000A0000, 0x00000000,
    0x00020000,
    0,
    1,
    0
}
};


//
// Validator Port list.
// This structure describes all the ports that must be hooked out of the V86
// emulator when a DOS app goes to full-screen mode.
// The structure determines to which routine the data read or written to a
// specific port should be sent.
//

#define QV_NUM_EMULATOR_ACCESS_ENTRIES     33

EMULATOR_ACCESS_ENTRY QVisionEmulatorAccessEntries[] = {
    //
    // Traps for byte OUTs.
    //

    {
        VGA_BASE_IO_PORT,                   // range start I/O address
        VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1,  // range length
        Uchar,                              // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUcharEntry       // routine to which to trap
    },
    {
        VGA_END_BREAK_PORT,
        VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
        Uchar,                              // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUcharEntry       // routine to which to trap
    },
    {
        QV_START_EXT_PORT_1,
        QV_END_EXT_PORT_1 - QV_START_EXT_PORT_1 + 1,
        Uchar,                              // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUcharEntry       // routine to which to trap
    },
    {
        QV_START_EXT_PORT_2,
        QV_END_EXT_PORT_2 - QV_START_EXT_PORT_2 + 1,
        Uchar,                              // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUcharEntry       // routine to which to trap
    },
    {
        QV_START_EXT_PORT_3,
        QV_END_EXT_PORT_3 - QV_START_EXT_PORT_3 + 1,
        Uchar,                              // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUcharEntry       // routine to which to trap
    },
    {
        QV_START_EXT_PORT_4,
        QV_END_EXT_PORT_4 - QV_START_EXT_PORT_4 + 1,
        Uchar,                              // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUcharEntry       // routine to which to trap
    },
    {
        QV_START_EXT_PORT_5,
        QV_END_EXT_PORT_5 - QV_START_EXT_PORT_5 + 1,
        Uchar,                              // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUcharEntry       // routine to which to trap
    },
    {
        QV_START_EXT_PORT_6,
        QV_END_EXT_PORT_6 - QV_START_EXT_PORT_6 + 1,
        Uchar,                              // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUcharEntry       // routine to which to trap
    },
    {
        QV_START_EXT_PORT_7,
        QV_END_EXT_PORT_7 - QV_START_EXT_PORT_7 + 1,
        Uchar,                              // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUcharEntry       // routine to which to trap
    },
    {
        QV_START_EXT_PORT_8,
        QV_END_EXT_PORT_8 - QV_START_EXT_PORT_8 + 1,
        Uchar,                              // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUcharEntry       // routine to which to trap
    },
    {
        QV_START_EXT_PORT_9,
        QV_END_EXT_PORT_9 - QV_START_EXT_PORT_9 + 1,
        Uchar,                              // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUcharEntry       // routine to which to trap
    },

    //
    // Traps for word OUTs.
    //

    {
        VGA_BASE_IO_PORT,                   // range start I/O address
        (VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1)/2,  // range length
        Ushort,                             // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUshortEntry      // routine to which to trap
    },
    {
        VGA_END_BREAK_PORT,
        (VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1)/2,
        Ushort,                             // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUshortEntry      // routine to which to trap
    },
    {
        QV_START_EXT_PORT_1,
        (QV_END_EXT_PORT_1 - QV_START_EXT_PORT_1 + 1)/2,
        Ushort,                             // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUshortEntry      // routine to which to trap
    },
    {
        QV_START_EXT_PORT_2,
        (QV_END_EXT_PORT_2 - QV_START_EXT_PORT_2 + 1)/2,
        Ushort,                             // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUshortEntry      // routine to which to trap
    },
    {
        QV_START_EXT_PORT_3,
        (QV_END_EXT_PORT_3 - QV_START_EXT_PORT_3 + 1)/2,
        Ushort,                             // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUshortEntry      // routine to which to trap
    },
    {
        QV_START_EXT_PORT_4,
        (QV_END_EXT_PORT_4 - QV_START_EXT_PORT_4 + 1)/2,
        Ushort,                             // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUshortEntry      // routine to which to trap
    },
    {
        QV_START_EXT_PORT_5,
        (QV_END_EXT_PORT_5 - QV_START_EXT_PORT_5 + 1)/2,
        Ushort,                             // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUshortEntry      // routine to which to trap
    },
    {
        QV_START_EXT_PORT_6,
        (QV_END_EXT_PORT_6 - QV_START_EXT_PORT_6 + 1)/2,
        Ushort,                             // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUshortEntry      // routine to which to trap
    },
    {
        QV_START_EXT_PORT_7,
        (QV_END_EXT_PORT_7 - QV_START_EXT_PORT_7 + 1)/2,
        Ushort,                             // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUshortEntry      // routine to which to trap
    },
    {
        QV_START_EXT_PORT_8,
        (QV_END_EXT_PORT_8 - QV_START_EXT_PORT_8 + 1)/2,
        Ushort,                             // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUshortEntry      // routine to which to trap
    },
    {
        QV_START_EXT_PORT_9,
        (QV_END_EXT_PORT_9 - QV_START_EXT_PORT_9 + 1)/2,
        Ushort,                             // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUshortEntry      // routine to which to trap
    },

    //
    // Traps for dword OUTs.
    //

    {
        VGA_BASE_IO_PORT,                   // range start I/O address
        (VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1)/4,  // range length
        Ulong,                              // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUlongEntry       // routine to which to trap
    },
    {
        VGA_END_BREAK_PORT,
        (VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1)/4,
        Ulong,                              // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUlongEntry       // routine to which to trap
    },
    {
        QV_START_EXT_PORT_1,
        (QV_END_EXT_PORT_1 - QV_START_EXT_PORT_1 + 1)/4,
        Ulong,                              // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUlongEntry       // routine to which to trap
    },
    {
        QV_START_EXT_PORT_2,
        (QV_END_EXT_PORT_2 - QV_START_EXT_PORT_2 + 1)/4,
        Ulong,                              // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUlongEntry       // routine to which to trap
    },
    {
        QV_START_EXT_PORT_3,
        (QV_END_EXT_PORT_3 - QV_START_EXT_PORT_3 + 1)/4,
        Ulong,                              // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUlongEntry       // routine to which to trap
    },
    {
        QV_START_EXT_PORT_4,
        (QV_END_EXT_PORT_4 - QV_START_EXT_PORT_4 + 1)/4,
        Ulong,                              // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUlongEntry       // routine to which to trap
    },
    {
        QV_START_EXT_PORT_5,
        (QV_END_EXT_PORT_5 - QV_START_EXT_PORT_5 + 1)/4,
        Ulong,                              // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUlongEntry       // routine to which to trap
    },
    {
        QV_START_EXT_PORT_6,
        (QV_END_EXT_PORT_6 - QV_START_EXT_PORT_6 + 1)/4,
        Ulong,                              // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUlongEntry       // routine to which to trap
    },
    {
        QV_START_EXT_PORT_7,
        (QV_END_EXT_PORT_7 - QV_START_EXT_PORT_7 + 1)/4,
        Ulong,                              // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUlongEntry       // routine to which to trap
    },
    {
        QV_START_EXT_PORT_8,
        (QV_END_EXT_PORT_8 - QV_START_EXT_PORT_8 + 1)/4,
        Ulong,                              // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUlongEntry       // routine to which to trap
    },
    {
        QV_START_EXT_PORT_9,
        (QV_END_EXT_PORT_9 - QV_START_EXT_PORT_9 + 1)/4,
        Ulong,                              // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                              // does not support string accesses
        (PVOID)VgaValidatorUlongEntry       // routine to which to trap
    }

}; // QVisionEmulatorAccessEntries


//
// Used to trap only the sequncer and the misc output registers
//

#define NUM_MINIMAL_QVISION_VALIDATOR_ACCESS_RANGE 4

VIDEO_ACCESS_RANGE MinimalQVisionValidatorAccessRange[] = {
{
    VGA_BASE_IO_PORT, 0x00000000,
    VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1,
    1,
    1,        // <- enable range IOPM so that it is not trapped.
    0
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    1,
    0
},
{
    VGA_BASE_IO_PORT + MISC_OUTPUT_REG_WRITE_PORT, 0x00000000,
    0x00000001,
    1,
    0,
    0
},
{
    VGA_BASE_IO_PORT + SEQ_ADDRESS_PORT, 0x00000000,
    0x00000002,
    1,
    0,
    0
}
};

//
// Used to trap all registers
//

#define NUM_FULL_QVISION_VALIDATOR_ACCESS_RANGE 11

VIDEO_ACCESS_RANGE FullQVisionValidatorAccessRange[] = {
{
    VGA_BASE_IO_PORT, 0x00000000,           // 64-bit linear base address
                                            // of range
    VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1, // # of ports
    1,                                      // range is in I/O space
    0,                                      // range should be visible
    0                                       // range should be shareable
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    0,
    0
},
{
    QV_START_EXT_PORT_1, 0x00000000,
    QV_END_EXT_PORT_1 - QV_START_EXT_PORT_1 + 1,
    1,
    0,
    0
},
{
    QV_START_EXT_PORT_2, 0x00000000,
    QV_END_EXT_PORT_2 - QV_START_EXT_PORT_2 + 1,
    1,
    0,
    0
},
{
    QV_START_EXT_PORT_3, 0x00000000,
    QV_END_EXT_PORT_3 - QV_START_EXT_PORT_3 + 1,
    1,
    0,
    0
},
{
    QV_START_EXT_PORT_4, 0x00000000,
    QV_END_EXT_PORT_4 - QV_START_EXT_PORT_4 + 1,
    1,
    0,
    0
},
{
    QV_START_EXT_PORT_5, 0x00000000,
    QV_END_EXT_PORT_5 - QV_START_EXT_PORT_5 + 1,
    1,
    0,
    0
},
{
    QV_START_EXT_PORT_6, 0x00000000,
    QV_END_EXT_PORT_6 - QV_START_EXT_PORT_6 + 1,
    1,
    0,
    0
},
{
    QV_START_EXT_PORT_7, 0x00000000,
    QV_END_EXT_PORT_7 - QV_START_EXT_PORT_7 + 1,
    1,
    0,
    0
},
{
    QV_START_EXT_PORT_8, 0x00000000,
    QV_END_EXT_PORT_8 - QV_START_EXT_PORT_8 + 1,
    1,
    0,
    0
},
{
    QV_START_EXT_PORT_9, 0x00000000,
    QV_END_EXT_PORT_9 - QV_START_EXT_PORT_9 + 1,
    1,
    0,
    0
},
   
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\mini\qry_nt.h ===
//---------------------------------------------------------------------------
/*++

Copyright (c) 1993  Compaq Computer Corporation

Module Name:

    qry_nt.h

Abstract:

    This is the header file for Compaq QRY calls


Notes:

Revision History:
   date    who				   description
  ------- --------- -----------------------------------------------------------
  12/1/93 Mike Duke Original module started as start for NT version of QRY
		    library.

   $0006
      miked: 2/17/1994
	removed member ulRcSize from VIDEO_CHIP_INFO

   $0004
      miked: 1/26/1994
	 Added member ulRcSize to VIDEO_CHIP_INFO for getting the resource
	 size from the registry.  Also revved the VIDEO_CHIP_INFO_VERSION
--*/
//---------------------------------------------------------------------------


#ifndef _QRY_NT_INCLUDED_
#define _QRY_NT_INCLUDED_

#define EXTENDED_ID_BIT   1<<6
#define EXTENDED_ID2_BIT  1<<7
/***********************
* QRY_ControllerType() *
***********************/
#define QRY_CONTROLLER_UNKNOWN          0       /* Unknown controller        */
#define QRY_CONTROLLER_MDA              1       /* MDA compatible controller */
#define QRY_CONTROLLER_CGA              2       /* CGA compatible controller */
#define QRY_CONTROLLER_EGA              3       /* EGA compatible controller */
#define QRY_CONTROLLER_VGA              4       /* VGA-compatible controller */
#define QRY_CONTROLLER_IVGS             5       /* IVGS controller           */
#define QRY_CONTROLLER_EVGS             6       /* EVGS controller           */
#define QRY_CONTROLLER_AVGA             7       /* AVGA controller           */
#define QRY_CONTROLLER_QUASAR0          8       /* Quasar rev 0 controller   */
#define QRY_CONTROLLER_VEGAS            9       /* Quasar/Vegas controller   */
#define QRY_CONTROLLER_MADONNA          10      /* Madonna controller        */
#define QRY_CONTROLLER_VICTORY          11      /* Victory controller        */
#define QRY_CONTROLLER_V32              12      /* V32 controller            */
#define QRY_CONTROLLER_V35              13      /* V35 controller            */
#define QRY_CONTROLLER_V64              14      /* V64 controller            */

/****************
* QRY_DACType() *
****************/
#define QRY_DAC_UNKNOWN                 0       /* Unknown DAC type          */
#define QRY_DAC_BT471                   1       /* Bt471 (VGA/IVGS)          */
#define QRY_DAC_BT477                   2       /* Bt477 (Stardust)          */
#define QRY_DAC_MADONNA                 3       /* Madonna ASIC type DAC     */
#define QRY_DAC_BT476                   QRY_DAC_MADONNA
#define QRY_DAC_BT484                   4       /* Bt484 or compatible       */
#define QRY_DAC_BT485                   5       /* Bt485 or compatible       */


//
// Publishable QVision names...
//
#define TRITON                L"QVGA G32E00"    // Victory
#define ORION                 L"QVGA G32E02"    // V32
#define ARIEL                 L"QVGA G32P04"    // V35
#define OBERON                L"QVGA G64P10"    // V64
#define KENOBEE               L"QVGA G64PV20"   // W64
#define MUSTANG               L"QVGA G64PV21"   // Slayer

#define QV_NEW                L"QVGA New"       // Generic Future QVision

//
// prototypes
//
ULONG
QRY_ControllerASICID(
   PUCHAR IOAddress
   );
ULONG
QRY_ControllerType(
   PUCHAR IOAddress
   );
ULONG
QRY_DACType(
   PUCHAR IOAddress
   );

//
// The following structure is used to pass information back to the port
// driver when the hwinfo ioctl is executed. This information is determined
// at init time.  See QRY_NT.H for controller types & DAC types
//  * qvision or better assumed *
//
// !*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!
//
//  IF THIS STRUCTURE CHANGES, IT IS VERY IMPORTANT TO ALSO CHANGE THE
//  MATCHING STRUCTURE THAT IS INCLUDED BY THE DISPLAY DRIVER QV256.DLL
//  THE VIDEO_CHIP_INFO_VERSION STRUCTURE IS MIRRORED IN THE i386 DIRECTORY
//  OF THE QV256 DRIVER IN A FILE CALLED DRIVER.INC.
//
// !*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!

#define VIDEO_CHIP_INFO_VERSION   1	    // current version of this struct

typedef struct _VIDEO_CHIP_INFO {

    ULONG   ulStructLen;		    // sizeof this structure
    ULONG   ulStructVer;		    // Version of this structure
    ULONG   ulAsicID;			    // asic id
    ULONG   ulExtendedID;		    // extended asic id
    ULONG   ulExtendedID2;		    // second extended id
    ULONG   ulControllerType;		    // controller type
    ULONG   ulDACType;			    // DAC Type
    ULONG   ulVRAMPresent;		    // amount of VRAM present

    } VIDEO_CHIP_INFO, *PVIDEO_CHIP_INFO;


//
//   define ioctl for port driver to use to call into miniport
//
#define CPQ_IOCTL_VIDEO_INFO \
	CTL_CODE(FILE_DEVICE_VIDEO,2096,METHOD_BUFFERED,FILE_ANY_ACCESS)



#endif
//
//	   end of qry_nt.h
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\framebuf\disp\color.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: color.c
*
* This algorithm for color dithering is patent pending and its use is
* restricted to Microsoft products and drivers for Microsoft products.
* Use in non-Microsoft products or in drivers for non-Microsoft product is
* prohibited without written permission from Microsoft.
*
* The patent application is the primary reference for the operation of the
* color dithering code.
*
* Note that in the comments and variable names, "vertex" means "vertex of
* either the inner (half intensity) or outer (full intensity) color cube."
* Vertices map to colors 0-6 and 248-255 of the Windows standard (required)
* 256-color palette, where vertices 0-6 and 248 are the vertices of the inner
* color cube, and 0 plus 249-255 are the vertices of the full color cube.
* Vertex 7 is 75% gray; this could be used in the dither, but that would break
* apps that depend on the exact Windows 3.1 dithering. This code is Window 3.1
* compatible.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

/**************************************************************************\
* This function takes a value from 0 - 255 and uses it to create an
* 8x8 pile of bits in the form of a 1BPP bitmap.  It can also take an
* RGB value and make an 8x8 bitmap.  These can then be used as brushes
* to simulate color unavaible on the device.
*
* For monochrome the basic algorithm is equivalent to turning on bits
* in the 8x8 array according to the following order:
*
*  00 32 08 40 02 34 10 42
*  48 16 56 24 50 18 58 26
*  12 44 04 36 14 46 06 38
*  60 28 52 20 62 30 54 22
*  03 35 11 43 01 33 09 41
*  51 19 59 27 49 17 57 25
*  15 47 07 39 13 45 05 37
*  63 31 55 23 61 29 53 21
*
* Reference: A Survey of Techniques for the Display of Continous
*            Tone Pictures on Bilevel Displays,;
*            Jarvis, Judice, & Ninke;
*            COMPUTER GRAPHICS AND IMAGE PROCESSING 5, pp 13-40, (1976)
\**************************************************************************/

#define SWAP_RB 0x00000004
#define SWAP_GB 0x00000002
#define SWAP_RG 0x00000001

#define SWAPTHEM(a,b) (ulTemp = a, a = b, b = ulTemp)

// PATTERNSIZE is the number of pixels in a dither pattern.
#define PATTERNSIZE 64

typedef union _PAL_ULONG {
    PALETTEENTRY pal;
    ULONG ul;
} PAL_ULONG;

typedef struct _VERTEX_DATA {
    ULONG ulCount;  // # of pixels in this vertex
    ULONG ulVertex; // vertex #
} VERTEX_DATA;

// Tells which row to turn a pel on in when dithering for monochrome bitmaps.
static BYTE ajByte[] = {
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7,
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7
};

// The array of monochrome bits used for monc
static BYTE ajBits[] = {
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80
};

// Translates vertices back to the original subspace. Each row is a subspace,
// as encoded in ulSymmetry, and each column is a vertex between 0 and 15.
BYTE jSwapSubSpace[8*16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 14, 13, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15,
    0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
};

// Converts a nibble value in the range 0-15 to a dword value containing the
// nibble value packed 8 times.
ULONG ulNibbleToDwordWithConvert[16] = {
    0x00000000,
    0x01010101,
    0x02020202,
    0x03030303,
    0x04040404,
    0x05050505,
    0x06060606,
    0xF8F8F8F8,
    0x07070707,
    0xF9F9F9F9,
    0xFAFAFAFA,
    0xFBFBFBFB,
    0xFCFCFCFC,
    0xFDFDFDFD,
    0xFEFEFEFE,
    0xFFFFFFFF
};

// Specifies where in the dither pattern colors should be placed in order
// of increasing intensity.
ULONG aulDitherOrder[] = {
  0, 36,  4, 32, 18, 54, 22, 50,
  2, 38,  6, 34, 16, 52, 20, 48,
  9, 45, 13, 41, 27, 63, 31, 59,
 11, 47, 15, 43, 25, 61, 29, 57,
  1, 37,  5, 33, 19, 55, 23, 51,
  3, 39,  7, 35, 17, 53, 21, 49,
  8, 44, 12, 40, 26, 62, 30, 58,
 10, 46, 14, 42, 24, 60, 28, 56,
};

// Array to convert to 256 color from 16 color. Maps from index that represents
// a 16-color vertex (color) to value that specifies the color index in the
// 256-color palette.

BYTE ajConvert[] =
{
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    248,
    7,
    249,
    250,
    251,
    252,
    253,
    254,
    255
};

/******************************Public*Routine******************************\
* DrvDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA colors
*
\**************************************************************************/

ULONG DrvDitherColor(
IN  DHPDEV dhpdev,
IN  ULONG  iMode,
IN  ULONG  rgb,
OUT ULONG *pul)
{
    ULONG   ulGrey, ulRed, ulGre, ulBlu, ulSymmetry;
    ULONG   ulRedTemp, ulGreenTemp, ulBlueTemp, ulTemp;
    VERTEX_DATA vVertexData[4];
    VERTEX_DATA *pvVertexData;
    VERTEX_DATA *pvVertexDataEnd;
    ULONG  *pulDitherOrder;
    ULONG   ulNumPixels;
    BYTE    jColor;
    ULONG   ulColor;
    VERTEX_DATA *pvMaxVertex;
    ULONG   ulVertex0Temp, ulVertex1Temp, ulVertex2Temp, ulVertex3Temp;
    BYTE   *pjDither = (BYTE *)pul;

    // Figure out if we need a full color dither or only a monochrome dither
    if (iMode != DM_MONOCHROME) {

        // Full color dither

        // Split the color into red, green, and blue components
        ulRedTemp   = ((PAL_ULONG *)&rgb)->pal.peRed;
        ulGreenTemp   = ((PAL_ULONG *)&rgb)->pal.peGreen;
        ulBlueTemp   = ((PAL_ULONG *)&rgb)->pal.peBlue;

        // Sort the RGB so that the point is transformed into subspace 0, and
        // keep track of the swaps in ulSymmetry so we can unravel it again
        // later.  We want r >= g >= b (subspace 0).
        ulSymmetry = 0;
        if (ulBlueTemp > ulRedTemp) {
            SWAPTHEM(ulBlueTemp,ulRedTemp);
            ulSymmetry = SWAP_RB;
        }

        if (ulBlueTemp > ulGreenTemp) {
            SWAPTHEM(ulBlueTemp,ulGreenTemp);
            ulSymmetry |= SWAP_GB;
        }

        if (ulGreenTemp > ulRedTemp) {
            SWAPTHEM(ulGreenTemp,ulRedTemp);
            ulSymmetry |= SWAP_RG;
        }

        ulSymmetry <<= 4;   // for lookup purposes

        // Scale the values from 0-255 to 0-64. Note that the scaling is not
        // symmetric at the ends; this is done to match Windows 3.1 dithering
        ulRed = (ulRedTemp + 1) >> 2;
        ulGre = (ulGreenTemp + 1) >> 2;
        ulBlu = (ulBlueTemp + 1) >> 2;

        // Compute the subsubspace within subspace 0 in which the point lies,
        // then calculate the # of pixels to dither in the colors that are the
        // four vertexes of the tetrahedron bounding the color we're emulating.
        // Only vertices with more than zero pixels are stored, and the
        // vertices are stored in order of increasing intensity, saving us the
        // need to sort them later
        if ((ulRedTemp + ulGreenTemp) > 256) {
            // Subsubspace 2 or 3
            if ((ulRedTemp + ulBlueTemp) > 256) {
                // Subsubspace 3
                // Calculate the number of pixels per vertex, still in
                // subsubspace 3, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 3 is:
                // 7, 9, 0x0B, 0x0F
                pvVertexData = vVertexData;
                if ((ulVertex0Temp = (64 - ulRed) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
                ulVertex2Temp = ulGre - ulBlu;
                ulVertex3Temp = (ulRed - 64) + ulBlu;
                if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
                }
                if (ulVertex2Temp != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0F];
                }
            } else {
                // Subsubspace 2
                // Calculate the number of pixels per vertex, still in
                // subsubspace 2, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 2 is:
                // 3, 7, 9, 0x0B
                pvVertexData = vVertexData;
                ulVertex1Temp = ulBlu << 1;
                ulVertex2Temp = ulRed - ulGre;
                ulVertex3Temp = (ulRed - 32) + (ulGre - 32);
                if ((ulVertex0Temp = ((PATTERNSIZE - ulVertex1Temp) -
                            ulVertex2Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
                }
                if (ulVertex1Temp != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
                if (ulVertex2Temp != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
                }
            }
        } else {
            // Subsubspace 0 or 1
            if (ulRedTemp > 128) {
                // Subsubspace 1
                // Calculate the number of pixels per vertex, still in
                // subsubspace 1, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 1 is:
                // 1, 3, 7, 9
                pvVertexData = vVertexData;
                if ((ulVertex0Temp = ((32 - ulGre) + (32 - ulRed)) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
                }
                ulVertex2Temp = ulBlu << 1;
                ulVertex3Temp = (ulRed - 32) << 1;
                if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
                }
                if (ulVertex2Temp != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
                }
            } else {
                // Subsubspace 0
                // Calculate the number of pixels per vertex, still in
                // subsubspace 0, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 0 is:
                // 0, 1, 3, 7
                pvVertexData = vVertexData;
                if ((ulVertex0Temp = (32 - ulRed) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x00];
                }
                if ((ulVertex1Temp = (ulRed - ulGre) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
                }
                ulVertex3Temp = ulBlu << 1;
                if ((ulVertex2Temp = ((PATTERNSIZE - ulVertex0Temp) -
                        ulVertex1Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
            }
        }

        // Now that we have found the bounding vertices and the number of
        // pixels to dither for each vertex, we can create the dither pattern

        // Handle 1, 2, and 3 & 4 vertices per dither separately
        ulTemp = (ULONG)(pvVertexData - vVertexData);    // # of vertices with more than
                                                // zero pixels
        if (ulTemp > 2) {

            // There are 3 or 4 vertices in this dither

            if (ulTemp == 3) {

                // There are 3 vertices in this dither

                // Find the vertex with the most pixels, and fill the whole
                // destination bitmap with that vertex's color, which is faster
                // than dithering it
                if (vVertexData[1].ulCount >= vVertexData[2].ulCount) {
                    pvMaxVertex = &vVertexData[1];
                    ulTemp = vVertexData[1].ulCount;
                } else {
                    pvMaxVertex = &vVertexData[2];
                    ulTemp = vVertexData[2].ulCount;
                }

            } else {

                // There are 4 vertices in this dither

                // Find the vertex with the most pixels, and fill the whole
                // destination bitmap with that vertex's color, which is faster
                // than dithering it
                if (vVertexData[2].ulCount >= vVertexData[3].ulCount) {
                    pvMaxVertex = &vVertexData[2];
                    ulTemp = vVertexData[2].ulCount;
                } else {
                    pvMaxVertex = &vVertexData[3];
                    ulTemp = vVertexData[3].ulCount;
                }
            }

            if (vVertexData[1].ulCount > ulTemp) {
                pvMaxVertex = &vVertexData[1];
                ulTemp = vVertexData[1].ulCount;
            }
            if (vVertexData[0].ulCount > ulTemp) {
                pvMaxVertex = &vVertexData[0];
            }

            pvVertexDataEnd = pvVertexData;

            // Prepare a dword version of the most common vertex number (color)
            ulColor = ulNibbleToDwordWithConvert[pvMaxVertex->ulVertex];

            // Mark that the vertex we're about to do doesn't need to be done
            // later
            pvMaxVertex->ulVertex = 0xFF;

            // Block fill the dither pattern with the more common vertex
            *pul = ulColor;
            *(pul+1) = ulColor;
            *(pul+2) = ulColor;
            *(pul+3) = ulColor;
            *(pul+4) = ulColor;
            *(pul+5) = ulColor;
            *(pul+6) = ulColor;
            *(pul+7) = ulColor;
            *(pul+8) = ulColor;
            *(pul+9) = ulColor;
            *(pul+10) = ulColor;
            *(pul+11) = ulColor;
            *(pul+12) = ulColor;
            *(pul+13) = ulColor;
            *(pul+14) = ulColor;
            *(pul+15) = ulColor;

            // Now dither all the remaining vertices in order 0->2 or 0->3
            // (in order of increasing intensity)
            pulDitherOrder = aulDitherOrder;
            pvVertexData = vVertexData;
            do {
                if (pvVertexData->ulVertex == 0xFF) {
                    // This is the max vertex, which we already did, but we
                    // have to account for it in the dither order
                    pulDitherOrder += pvVertexData->ulCount;
                } else {
                    jColor = ajConvert[pvVertexData->ulVertex];
                    ulNumPixels = pvVertexData->ulCount;
                    switch (ulNumPixels & 3) {
                        case 3:
                            pjDither[*(pulDitherOrder+2)] = jColor;
                        case 2:
                            pjDither[*(pulDitherOrder+1)] = jColor;
                        case 1:
                            pjDither[*(pulDitherOrder+0)] = jColor;
                            pulDitherOrder += ulNumPixels & 3;
                        case 0:
                            break;
                    }
                    if ((ulNumPixels >>= 2) != 0) {
                        do {
                            pjDither[*pulDitherOrder] = jColor;
                            pjDither[*(pulDitherOrder+1)] = jColor;
                            pjDither[*(pulDitherOrder+2)] = jColor;
                            pjDither[*(pulDitherOrder+3)] = jColor;
                            pulDitherOrder += 4;
                        } while (--ulNumPixels);
                    }
                }
            } while (++pvVertexData < pvVertexDataEnd);

        } else if (ulTemp == 2) {

            // There are exactly two vertices with more than zero pixels; fill
            // in the dither array as follows: block fill with vertex with more
            // points first, then dither in the other vertex
            if (vVertexData[0].ulCount >= vVertexData[1].ulCount) {
                // There are no more vertex 1 than vertex 0 pixels, so do
                // the block fill with vertex 0
                ulColor = ulNibbleToDwordWithConvert[vVertexData[0].ulVertex];
                // Do the dither with vertex 1
                jColor = ajConvert[vVertexData[1].ulVertex];
                ulNumPixels = vVertexData[1].ulCount;
                // Set where to start dithering with vertex 1 (vertex 0 is
                // lower intensity, so its pixels come first in the dither
                // order)
                pulDitherOrder = aulDitherOrder + vVertexData[0].ulCount;
            } else {
                // There are more vertex 1 pixels, so do the block fill
                // with vertex 1
                ulColor = ulNibbleToDwordWithConvert[vVertexData[1].ulVertex];
                // Do the dither with vertex 0
                jColor = ajConvert[vVertexData[0].ulVertex];
                ulNumPixels = vVertexData[0].ulCount;
                // Set where to start dithering with vertex 0 (vertex 0 is
                // lower intensity, so its pixels come first in the dither
                // order)
                pulDitherOrder = aulDitherOrder;
            }

            // Block fill the dither pattern with the more common vertex
            *pul = ulColor;
            *(pul+1) = ulColor;
            *(pul+2) = ulColor;
            *(pul+3) = ulColor;
            *(pul+4) = ulColor;
            *(pul+5) = ulColor;
            *(pul+6) = ulColor;
            *(pul+7) = ulColor;
            *(pul+8) = ulColor;
            *(pul+9) = ulColor;
            *(pul+10) = ulColor;
            *(pul+11) = ulColor;
            *(pul+12) = ulColor;
            *(pul+13) = ulColor;
            *(pul+14) = ulColor;
            *(pul+15) = ulColor;

            // Dither in the less common vertex
            switch (ulNumPixels & 3) {
                case 3:
                    pjDither[*(pulDitherOrder+2)] = jColor;
                case 2:
                    pjDither[*(pulDitherOrder+1)] = jColor;
                case 1:
                    pjDither[*(pulDitherOrder+0)] = jColor;
                    pulDitherOrder += ulNumPixels & 3;
                case 0:
                    break;
            }
            if ((ulNumPixels >>= 2) != 0) {
                do {
                    pjDither[*pulDitherOrder] = jColor;
                    pjDither[*(pulDitherOrder+1)] = jColor;
                    pjDither[*(pulDitherOrder+2)] = jColor;
                    pjDither[*(pulDitherOrder+3)] = jColor;
                    pulDitherOrder += 4;
                } while (--ulNumPixels);
            }

        } else {

            // There is only one vertex in this dither

            // No sorting or dithering is needed for just one color; we can
            // just generate the final DIB directly
            ulColor = ulNibbleToDwordWithConvert[vVertexData[0].ulVertex];
            *pul = ulColor;
            *(pul+1) = ulColor;
            *(pul+2) = ulColor;
            *(pul+3) = ulColor;
            *(pul+4) = ulColor;
            *(pul+5) = ulColor;
            *(pul+6) = ulColor;
            *(pul+7) = ulColor;
            *(pul+8) = ulColor;
            *(pul+9) = ulColor;
            *(pul+10) = ulColor;
            *(pul+11) = ulColor;
            *(pul+12) = ulColor;
            *(pul+13) = ulColor;
            *(pul+14) = ulColor;
            *(pul+15) = ulColor;
        }

    } else {

        // For monochrome we will only use the Intensity (grey level)
        RtlFillMemory((PVOID) pul, PATTERNSIZE/2, 0);  // zero the dither bits

        ulRed   = (ULONG) ((PALETTEENTRY *) &rgb)->peRed;
        ulGre = (ULONG) ((PALETTEENTRY *) &rgb)->peGreen;
        ulBlu  = (ULONG) ((PALETTEENTRY *) &rgb)->peBlue;

        // I = .30R + .59G + .11B
        // For convience the following ratios are used:
        //
        //  77/256 = 30.08%
        // 151/256 = 58.98%
        //  28/256 = 10.94%

        ulGrey  = (((ulRed * 77) + (ulGre * 151) + (ulBlu * 28)) >> 8) & 255;

        // Convert the RGBI from 0-255 to 0-64 notation.

        ulGrey = (ulGrey + 1) >> 2;

        while(ulGrey) {
            ulGrey--;
            pul[ajByte[ulGrey]] |= ((ULONG) ajBits[ulGrey]);
        }
    }

    return(DCR_DRIVER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\mini\i386\qvhard.asm ===
title  "QVision ASM routines"
;

;++
;
; Copyright (c) 1992  Microsoft Corporation
; Copyright (c) 1993  Compaq Computer Corporation
;
; Module Name:
;
;     qvhard.asm
;
; Abstract:
;
;     This module implements the bank switching code for the QVision
;     1024 and 1280 boards.  Normal banking is implemented for both
;     the original QVision modes and the extended 1280 modes.  For
;     QVIsion modes the addressing granularity is 4k.  For Orion
;     extended modes, the addressing granularity is 16k.
;
;     Only code for two 32k banks is implemented.  HC Planar banking
;     is not implemented.
;
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;;
;
;
;--

.386p
        .xlist
include callconv.inc
        .list

;----------------------------------------------------------------------------
;
; QVision banking control ports.
;
GRAPHICS_ADDRESS_PORT equ   03ceh       ;banking control here

QV_BANKING_INDEX_PORT_0 equ 45h         ;banking page register 0
QV_BANKING_INDEX_PORT_1 equ 46h         ;banking page register 1
QV_BANKING_WINDOW_SIZE  equ 06h         ;banking window size

SEQ_ADDRESS_PORT equ        03C4h       ;Sequencer Address register
IND_MEMORY_MODE  equ        04h         ;Memory Mode reg. index in Sequencer
CHAIN4_MASK      equ        08h         ;Chain4 bit in Memory Mode register

;----------------------------------------------------------------------------

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING
;
;
;    Input:
;          EAX = desired read bank mapping
;          EDX = desired write bank mapping
;
;    Note: values must be correct, with no stray bits set; no error
;       checking is performed.
;
        public _QV4kAddrBankSwitchStart         ; used for Aries modes
        public _QV4kAddrBankSwitchEnd
        public _QV4kAddrPlanarHCBankSwitchStart
        public _QV4kAddrPlanarHCBankSwitchEnd
        public _QV4kAddrEnablePlanarHCStart
        public _QV4kAddrEnablePlanarHCEnd
        public _QV4kAddrDisablePlanarHCStart
        public _QV4kAddrDisablePlanarHCEnd

        public _QV16kAddrBankSwitchStart        ; used for Orion modes
        public _QV16kAddrBankSwitchEnd
        public _QV16kAddrPlanarHCBankSwitchStart
        public _QV16kAddrPlanarHCBankSwitchEnd
        public _QV16kAddrEnablePlanarHCStart
        public _QV16kAddrEnablePlanarHCEnd
        public _QV16kAddrDisablePlanarHCStart
        public _QV16kAddrDisablePlanarHCEnd

        align 4

;----------------------------------------------------------------------------
;
;   _QV4kAddrBankSwitchStart()
;
;
;       This function converts the 32k page numbers provided by the
;       caller into the required format for the QVision page registers
;       then maps the 2 32k pages.  This function assumes that 4k page
;       addressing granularity is used by the page registers.
;
;
;
;       EAX = bank number to map to bank 1
;       EDX = bank number to map to bank 2
;
;
;
;
;
;----------------------------------------------------------------------------

_QV4kAddrBankSwitchStart proc               ; start of bank switch code
_QV4kAddrPlanarHCBankSwitchStart:           ; start of planar HC bank switch code,
                                            ; which is the same code as normal
                                            ; bank switching
;
;   The VGA256 .dll passes us 32k bank numbers - we need
;   to convert these values to 4k page numbers for Aries modes.
;
        shl     eax,3                       ; assume Aries 4k page
        shl     edx,3                       ;      resolution

;!!!! NOTE: The October 1992 release NT VGA driver assumes that the Graphics
;           index is not changed by the bank switch code.  We save it on the
;           stack (and save the write bank value in the high order of edx)
;           and restore it at the end of the routine.  If the NT VGA driver
;           changes so that it is the index need not be preserved, this code
;           could be simplified (and speeded up!)

        rol     edx,16                      ; save bank 0 write value
        mov     ah,al                       ; save bank 1 write value
        mov     dx,GRAPHICS_ADDRESS_PORT    ; banking control port
        in      al,dx                       ; save graphics
        push    eax                         ;       index register

        mov     al,QV_BANKING_INDEX_PORT_0  ; select the READ bank
        out     dx,ax                       ; write out READ bank and value

        rol     edx,16                      ; restore data to original format
        mov     ah,dl                       ; get WRITE bank value

        mov     al,QV_BANKING_INDEX_PORT_1  ;
        mov     dx,GRAPHICS_ADDRESS_PORT    ; banking control port
        out     dx,ax                       ; select the WRITE bank

        pop     eax                         ; restore the original
        out     dx,al                       ;   graphics register index
        ret

_QV4kAddrBankSwitchEnd:
_QV4kAddrPlanarHCBankSwitchEnd:

        align 4
_QV4kAddrEnablePlanarHCStart:
        mov     dx,SEQ_ADDRESS_PORT
        in      al,dx
        push    eax                     ;preserve the state of the Seq Address
        mov     al,IND_MEMORY_MODE
        out     dx,al                   ;point to the Memory Mode register
        inc     edx
        in      al,dx                   ;get the state of the Memory Mode reg
        and     al,NOT CHAIN4_MASK      ;turn off Chain4 to make memory planar
        out     dx,al
        dec     edx
        pop     eax
        out     dx,al                   ;restore the original Seq Address

ERA1_INDEX            equ 0A1h

        mov     dx,GRAPHICS_ADDRESS_PORT
        in      al,dx
        push    eax                     ;preserve the Graphics Index
        mov     al,ERA1_INDEX
        out     dx,al                   ;point to ERA1
        inc     edx
        in      al,dx                   ; get ERA1
        and     al,not 30h              ; turn off the shift bits
        out     dx,al
        dec     edx
        pop     eax
        out     dx,al                   ;restore the original Graphics Index
        ret

_QV4kAddrEnablePlanarHCEnd:

        align 4
_QV4kAddrDisablePlanarHCStart:
        mov     dx,SEQ_ADDRESS_PORT
        in      al,dx
        push    eax                     ;preserve the state of the Seq Address
        mov     al,IND_MEMORY_MODE
        out     dx,al                   ;point to the Memory Mode register
        inc     edx
        in      al,dx                   ;get the state of the Memory Mode reg
        or      al,CHAIN4_MASK          ;turn on Chain4 to make memory linear
        out     dx,al
        dec     edx
        pop     eax
        out     dx,al                   ;restore the original Seq Address

        mov     dx,GRAPHICS_ADDRESS_PORT
        in      al,dx
        push    eax                     ;preserve the Graphics Index
        mov     al,ERA1_INDEX
        out     dx,al                   ;point to ERA1
        inc     edx
        in      al,dx                   ; get ERA1
        and     al,not 30h
        or      al,20h
        out     dx,al
        dec     edx
        pop     eax
        out     dx,al                   ;restore the original Graphics Index
        ret

_QV4kAddrDisablePlanarHCEnd:

_QV4kAddrBankSwitchStart endp


;----------------------------------------------------------------------------
;
;   _QV16kAddrBankSwitchStart()
;
;
;       This function converts the 32k page numbers provided by the
;       caller into the required format for the QVision page registers
;       then maps the 2 32k pages.  This function assumes that 16k page
;       addressing granularity is used by the page registers.
;
;
;       EAX = bank number to map to bank 1
;       EDX = bank number to map to bank 2
;
;
;----------------------------------------------------------------------------


_QV16kAddrBankSwitchStart proc              ; start of bank switch code
_QV16kAddrPlanarHCBankSwitchStart:          ; start of planar HC bank switch code,
                                            ; which is the same code as normal
                                            ; bank switching
;
;   The VGA256 .dll passes us 32k bank numbers - we need
;   to convert these values to 16k page values for Orion modes.
;
        shl    eax,1                        ; assume Orion 16k address
        shl    edx,1                        ;      resolution

;!!!! NOTE: The October 1992 release NT VGA driver assumes that the Graphics
;           index is not changed by the bank switch code.  We save it on the
;           stack (and save the write bank value in the high order of edx)
;           and restore it at the end of the routine.  If the NT VGA driver
;           changes so that it is the index need not be preserved, this code
;           could be simplified (and speeded up!)

        rol     edx,16                      ; save bank 0 write value
        mov     ah,al                       ; save bank 1 write value
        mov     dx,GRAPHICS_ADDRESS_PORT    ; banking control port
        in      al,dx                       ; save graphics
        push    eax                         ;       index register

        mov     al,QV_BANKING_INDEX_PORT_0  ; select the READ bank
        out     dx,ax                       ; write out READ bank and value

        rol     edx,16                      ; restore data to original format
        mov     ah,dl                       ; get WRITE bank value

        mov     al,QV_BANKING_INDEX_PORT_1  ;
        mov     dx,GRAPHICS_ADDRESS_PORT    ; banking control port
        out     dx,ax                       ; select the WRITE bank

        pop     eax                         ; restore the original
        out     dx,al                       ;  graphics register index
        ret

_QV16kAddrBankSwitchEnd:
_QV16kAddrPlanarHCBankSwitchEnd:


        align 4
_QV16kAddrEnablePlanarHCStart:
        mov     dx,SEQ_ADDRESS_PORT
        in      al,dx
        push    eax                     ;preserve the state of the Seq Address
        mov     al,IND_MEMORY_MODE
        out     dx,al                   ;point to the Memory Mode register
        inc     edx
        in      al,dx                   ;get the state of the Memory Mode reg
        and     al,NOT CHAIN4_MASK      ;turn off Chain4 to make memory planar
        out     dx,al
        dec     edx
        pop     eax
        out     dx,al                   ;restore the original Seq Address

ERA1_INDEX            equ 0A1h

        mov     dx,GRAPHICS_ADDRESS_PORT
        in      al,dx
        push    eax                     ;preserve the Graphics Index
        mov     al,ERA1_INDEX
        out     dx,al                   ;point to ERA1
        inc     edx
        in      al,dx                   ; get ERA1
        and     al,not 30h              ; turn off the shift bits
        out     dx,al
        dec     edx
        pop     eax
        out     dx,al                   ;restore the original Graphics Index
        ret

_QV16kAddrEnablePlanarHCEnd:

        align 4
_QV16kAddrDisablePlanarHCStart:
        mov     dx,SEQ_ADDRESS_PORT
        in      al,dx
        push    eax                     ;preserve the state of the Seq Address
        mov     al,IND_MEMORY_MODE
        out     dx,al                   ;point to the Memory Mode register
        inc     edx
        in      al,dx                   ;get the state of the Memory Mode reg
        or      al,CHAIN4_MASK          ;turn on Chain4 to make memory linear
        out     dx,al
        dec     edx
        pop     eax
        out     dx,al                   ;restore the original Seq Address

        mov     dx,GRAPHICS_ADDRESS_PORT
        in      al,dx
        push    eax                     ;preserve the Graphics Index
        mov     al,ERA1_INDEX
        out     dx,al                   ;point to ERA1
        inc     edx
        in      al,dx                   ; get ERA1
        and     al,not 30h
        or      al,20h
        out     dx,al
        dec     edx
        pop     eax
        out     dx,al                   ;restore the original Graphics Index
        ret

_QV16kAddrDisablePlanarHCEnd:

_QV16kAddrBankSwitchStart endp

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\framebuf\disp\debug.h ===
/***************************************************************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: debug.h
*
* Commonly used debugging macros.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\***************************************************************************/


#if DBG

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

#define DISPDBG(arg) DebugPrint arg
#define RIP(x) { DebugPrint(0, x); EngDebugBreak();}

#else

#define DISPDBG(arg)
#define RIP(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\framebuf\disp\debug.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: debug.c
*
* debug helpers routine
*
* Copyright (c) 1992-1998 Microsoft Corporation
*
\**************************************************************************/

#include "driver.h"

#if DBG

ULONG DebugLevel = 0;

/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive debug print
 *      routine.
 *      If the specified debug level for the print statement is lower or equal
 *      to the current debug level, the message will be printed.
 *
 *   Arguments:
 *
 *      DebugPrintLevel - Specifies at which debugging level the string should
 *          be printed
 *
 *      DebugMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

{

    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel)
    {
        EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
    }

    va_end(ap);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\mini\qvision.c ===
//---------------------------------------------------------------------------
/*++

Copyright (c) 1992  Microsoft Corporation
Copyright (c) 1993  Compaq Computer Corporation

Module Name:

    qvision.c

Abstract:

    This is the miniport driver for the Compaq QVision family of VGA's.
    QVision adapters supported by this miniport include:

        Original QVision ASIC - Feb. '92
        --------------------------------
        QVision 1024 /E - 1M configuration
        QVision 1024 /I - 1M configuration
        Deskpro /i with system board QVision - 512k or 1M configuration

        Enhanced QVision ASIC - May '93
        -------------------------------
        QVision 1024 /E - 1M or 2M configuration
        QVision 1024 /I - 1M or 2M configuration
        QVision 1280 /E - 2M configuration
        QVision 1280 /I - 2M configuration

    The miniport supports all Compaq monitors and will automatically
    configure the QVision adapter to drive the monitor at the
    maximum refresh rate supported by the monitor at the user
    selected resolution.

    Additionally, a number of user selectable alternate refresh rates
    are provided for compatibility with third party monitors.

Environment:

    kernel mode only

Notes:

Revision History:
   $0011
      adrianc: 02/17/95
         - Fix for RAID# 3292
   $0010
      adrianc: 02/17/95
         - I added the capability for the miniport to add the
           controller, ASIC and DAC information into the registry.
   $0008
      adrianc: 02/17/1995
        - Because the DAC CMD2 register can change when a mode is set,
        - it needs to be read again to get the correct value.
   $0006
      miked: 02/17/1994
        . took out conditional debug code to satisfy MSBHPD
        . took out reading of the resource size that is passed to the
          QV256.DLL in CPQ_IOCTL_VIDEO_INFO (to satisfy MSBHPD)

   $0005
      miked: 02/08/1994
         . modified to work with build 547's new display.cpl

   $0004
      miked: 1/26/1994
         . Added debug print code without all the other DBG overhead
         . Added third party monitor support to force a 76Hz refresh rate
         . Fixed problem with CPQ_IOCTL_VIDEO_INFO not setting the
           RequestPacket->StatusBlock->Information properly
         . Added Ability to get the resource size from the registry,
           "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\
            qv\Device0\DefaultSettings.RcSize" is REG_DWORD 0x60 or 0x78

   $0003
      miked: 12/14/1993
         Added ioctl CPQ_IOCTL_VIDEO_INFO to give asic info and more
         back to the hardware accelerated DLL. Also added "min" macro.
   $0002
      adrianc: 12/9/1993
         Removed the NVRAM check for EISA and ISA cards in
         EISA systems.
         To support new COMPAQ systems and cards, we removed the
         EISA support from this module.  The EISA support was
         written for framebuffers.  The current driver does not
         support framebuffers.
   $0001
      adrianc: 09/08/93
         I changed the value which is sent to the GRAPH_DATA_PORT
         from 0C to 2C.

--*/
//---------------------------------------------------------------------------

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"
#include "qvision.h"
#include "qv_data.h"
#include "qvlog.h"


/***********************************************************************/


//
// $0003 miked 12/14/1993 - Added MIN macro
//
#ifndef min
#define min(a,b)        (((a) < (b)) ? (a) : (b))
#endif


//---------------------------------------------------------------------------
//
// Function declarations
//
// Functions that start with 'VGA' are entry points for the OS port driver.
//

VP_STATUS
VgaFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

BOOLEAN
VgaInitialize(
    PVOID HwDeviceExtension
    );

BOOLEAN
VgaStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

//
// Private function prototypes.
//

VP_STATUS
VgaQueryAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    );

VP_STATUS
VgaQueryNumberOfAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    PULONG OutputSize
    );

VP_STATUS
VgaQueryCurrentMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    );

VP_STATUS
VgaSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize
    );

VP_STATUS
VgaLoadAndSetFont(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_LOAD_FONT_INFORMATION FontInformation,
    ULONG FontInformationSize
    );

VP_STATUS
VgaQueryCursorPosition(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_POSITION CursorPosition,
    ULONG CursorPositionSize,
    PULONG OutputSize
    );

VP_STATUS
VgaSetCursorPosition(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_POSITION CursorPosition,
    ULONG CursorPositionSize
    );

VP_STATUS
VgaQueryCursorAttributes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG CursorAttributesSize,
    PULONG OutputSize
    );

VP_STATUS
VgaSetCursorAttributes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG CursorAttributesSize
    );

BOOLEAN
VgaIsPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
VgaInterpretCmdStream(
    PVOID HwDeviceExtension,
    PUSHORT pusCmdStream
    );

VP_STATUS
VgaSetPaletteReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_PALETTE_DATA PaletteBuffer,
    ULONG PaletteBufferSize
    );

VP_STATUS
VgaSetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    );

VP_STATUS
VgaRestoreHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize
    );

VP_STATUS
VgaSaveHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize,
    PULONG OutputSize
    );

VP_STATUS
VgaGetBankSelectCode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_BANK_SELECT BankSelect,
    ULONG BankSelectSize,
    PULONG OutputSize
    );

// driver local functions

//VP_STATUS
//GetMonClass (
//    PHW_DEVICE_EXTENSION pHwDeviceExtension);

VP_STATUS
VgaGetRegistryParametersCallback(
    PHW_DEVICE_EXTENSION pHwDeviceExtension,
    PVOID pvContext,
    PWSTR pwstrValueName,
    PVOID pvValueData,
    ULONG ulValueLength);

VP_STATUS
VgaGetDeviceDataCallback (
    PVOID pHwDeviceExtension,
    PVOID Context,
    VIDEO_DEVICE_DATA_TYPE DeviceDataType,
    PVOID Identifier,
    ULONG IdentiferLength,
    PVOID ConfigurationData,
    ULONG ConfigurationDataLength,
    PVOID ComponentInformation,
    ULONG ComponentInformationLength);

VOID
VgaStandardRegsRestore(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE_HEADER hardwareStateHeader
    );

VOID
QVLocalRestoreHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE_HEADER hardwareStateHeader
    );


VOID
QVLocalSaveHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE_HEADER hardwareStateHeader
    );

VOID
QVLockExtRegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
QVUnlockExtRegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
QVSaveRestoreVideoMemory(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE_HEADER hardwareStateHeader,
    UCHAR ucFlag
    );
//
// New entry points added for NT 5.0.
//

#if (_WIN32_WINNT >= 500)

//
// Routine to set a desired DPMS power management state.
//
VP_STATUS
QvSetPower50(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT pVideoPowerMgmt
    );

//
// Routine to retrieve possible DPMS power management states.
//
VP_STATUS
QvGetPower50(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT pVideoPowerMgmt
    );

//
// Routine to retrieve the Enhanced Display ID structure via DDC
//
ULONG
QvGetVideoChildDescriptor(
    PVOID HwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pvChildDescriptor,
    PULONG pHwId,
    PULONG pUnused
    );
#endif  // _WIN32_WINNT >= 500



//---------------------------------------------------------------------------
ULONG
DriverEntry(
    PVOID Context1,
    PVOID Context2
    )

/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    Context1 - First context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

    Context2 - Second context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

Return Value:

    Status from VideoPortInitialize()

--*/

{

    VIDEO_HW_INITIALIZATION_DATA hwInitData;
    ULONG status;
    ULONG initializationStatus;

    //
    // Zero out structure.
    //

    VideoDebugPrint((1,"QVision.sys: DriverEntry ==> set videodebuglevel.\n"));

    VideoPortZeroMemory(&hwInitData, sizeof(VIDEO_HW_INITIALIZATION_DATA));

    //
    // Specify sizes of structure and extension.
    //

    hwInitData.HwInitDataSize = sizeof(VIDEO_HW_INITIALIZATION_DATA);

    //
    // Set entry points.
    //

    hwInitData.HwFindAdapter = VgaFindAdapter;
    hwInitData.HwInitialize = VgaInitialize;
    hwInitData.HwInterrupt = NULL;
    hwInitData.HwStartIO = VgaStartIO;

#if (_WIN32_WINNT >= 500)

    //
    // Set new entry points added for NT 5.0.
    //

    hwInitData.HwSetPowerState           = QvSetPower50;
    hwInitData.HwGetPowerState           = QvGetPower50;
    hwInitData.HwGetVideoChildDescriptor = QvGetVideoChildDescriptor;

    //
    // Declare the legacy resources
    //

    hwInitData.HwLegacyResourceList      = QVisionAccessRange;
    hwInitData.HwLegacyResourceCount     = NUM_QVISION_ACCESS_RANGES;


#endif // _WIN32_WINNT >= 500

    //
    // Determine the size we require for the device extension.
    //

    hwInitData.HwDeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);

    //
    // Always start with parameters for device0 in this case.
    // We can leave it like this since we know we will only ever find one
    // VGA type adapter in a machine.
    //

//    hwInitData.StartingDeviceNumber = 0;

    //
    // Once all the relevant information has been stored, call the video
    // port driver to do the initialization.
    // For this device we will repeat this call three times, for ISA, EISA
    // and MCA.
    // We will return the minimum of all return values.
    //

    hwInitData.AdapterInterfaceType = Isa;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    hwInitData.AdapterInterfaceType = Eisa;

    status = VideoPortInitialize(Context1,
                                 Context2,
                                 &hwInitData,
                                 NULL);

    if (initializationStatus > status) {
        initializationStatus = status;
    }

    return initializationStatus;

} // end DriverEntry()

//---------------------------------------------------------------------------
VP_STATUS
VgaFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    )

/*++

Routine Description:

    This routine is called to determine if the adapter for this driver
    is present in the system.
    If it is present, the function fills out some information describing
    the adapter.

Arguments:

    HwDeviceExtension - Supplies the miniport driver's adapter storage. This
        storage is initialized to zero before this call.

    HwContext - Supplies the context value which was passed to
        VideoPortInitialize(). Must be NULL for PnP drivers.

    ArgumentString - Supplies a NULL terminated ASCII string. This string
        originates from the user.

    ConfigInfo - Returns the configuration information structure which is
        filled by the miniport driver. This structure is initialized with
        any known configuration information (such as SystemIoBusNumber) by
        the port driver. Where possible, drivers should have one set of
        defaults which do not require any supplied configuration information.

    Again - Indicates if the miniport driver wants the port driver to call
        its VIDEO_HW_FIND_ADAPTER function again with a new device extension
        and the same config info. This is used by the miniport drivers which
        can search for several adapters on a bus.

Return Value:

    This routine must return:

    NO_ERROR - Indicates a host adapter was found and the
        configuration information was successfully determined.

    ERROR_INVALID_PARAMETER - Indicates an adapter was found but there was an
        error obtaining the configuration information. If possible an error
        should be logged.

    ERROR_DEV_NOT_EXIST - Indicates no host adapter was found for the
        supplied configuration information.

--*/

{

    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VP_STATUS status;
    ULONG ulTempMemBankNum;             // number of memory banks on card
    ULONG ulNumQVisionAccessRanges;

    IO_RESOURCE_DESCRIPTOR ioResource = {
        IO_RESOURCE_PREFERRED,
        CmResourceTypePort,
        CmResourceShareDeviceExclusive,
        0,
        CM_RESOURCE_PORT_IO,
        0,
        { 0x1000, 0x1000, 0xA00000, 0xFFFFF}
    };                                  // 4k-aligned 4k block between 640k
                                        // and 1mb

    VideoDebugPrint((1,"QVision.sys: VgaFindAdapter.\n"));

    //
    // Make sure the size of the structure is at least as large as what we
    // are expecting (check version of the config info structure).
    //

    if (ConfigInfo->Length < sizeof(VIDEO_PORT_CONFIG_INFO)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // No interrupt information is necessary.
    //

    //
    // Check to see if there is a hardware resource conflict.
    //

    ulNumQVisionAccessRanges = NUM_QVISION_ACCESS_RANGES;

    status = VideoPortVerifyAccessRanges(HwDeviceExtension,
                                         ulNumQVisionAccessRanges,
                                         QVisionAccessRange);

    if (status != NO_ERROR) {

        return status;

    }

    //
    // Get logical IO port addresses.
    //

    VideoDebugPrint((3,"\tVGAFindAdapter - preparing to get IOAddress\n"));

    if ( (hwDeviceExtension->IOAddress =
              VideoPortGetDeviceBase(hwDeviceExtension,
                                     QVisionAccessRange->RangeStart,
                                     QVisionAccessRange->RangeLength,
                                     TRUE)) == NULL) {

        VideoDebugPrint((2, "\tFail to get I/O address\n"));

        return ERROR_INVALID_PARAMETER;

    }

    VideoDebugPrint((3,"\tVGAFindAdapter - got IO address %d\n",
                    hwDeviceExtension->IOAddress));

    //
    // Determine whether a VGA (and QVision card) is present.
    //

    if (!VgaIsPresent(hwDeviceExtension)) {

      VideoDebugPrint((1,"\tVGA is not present.\n"));
      return ERROR_DEV_NOT_EXIST;

    }

    //
    // Get the monitor refresh rate.  We need to find out if the
    // user selected a COMPAQ monitor or a third party monitor with
    // a specific frequency.
    // If the lFrequency value remains 0, this means that the user
    // wants the monitor to be auto detected.
    //

    hwDeviceExtension->VideoHardware.lFrequency = 0;

    if (VideoPortGetRegistryParameters(hwDeviceExtension,
                                       L"DefaultSettings.VRefresh",
                                       FALSE,
                                       VgaGetRegistryParametersCallback,
                                       NULL) != NO_ERROR) {

       //VideoPortLogError(hwDeviceExtension,
       //                  NULL,
       //                  QVERROR_REGISTRY_INFO_NOT_FOUND,
       //                  __LINE__);

       VideoDebugPrint((1,"\tDefaultSettings.VRefresh is not in the registry.\n"));

       //
       // MikeD: 2/18/94
       //
       // if not found in registry, assume CPQ MON
       //
       hwDeviceExtension->VideoHardware.lFrequency = 0;

       //       return ERROR_DEV_NOT_EXIST;

       }
    // else  {

       GetMonClass(hwDeviceExtension);

    // }


    //
    // Pass a pointer to the emulator range we are using.
    //

    ConfigInfo->NumEmulatorAccessEntries = QV_NUM_EMULATOR_ACCESS_ENTRIES;
    ConfigInfo->EmulatorAccessEntries = QVisionEmulatorAccessEntries;
    ConfigInfo->EmulatorAccessEntriesContext = (ULONG) hwDeviceExtension;

    ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart = MEM_VGA;
    ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0x00000000;
    ConfigInfo->VdmPhysicalVideoMemoryLength = MEM_VGA_SIZE;

    //
    // Minimum size of the buffer required to store the hardware state
    // information returned by IOCTL_VIDEO_SAVE_HARDWARE_STATE.
    //
#ifdef QV_EXTENDED_SAVE
    ConfigInfo->HardwareStateSize = QV_TOTAL_STATE_SIZE;
#else
    ConfigInfo->HardwareStateSize = VGA_TOTAL_STATE_SIZE;
#endif


    //
    // Video memory information - Set defaults for VGA
    //

    hwDeviceExtension->PhysicalVideoMemoryBase.HighPart = 0x00000000;
    hwDeviceExtension->PhysicalVideoMemoryBase.LowPart = MEM_VGA;
    hwDeviceExtension->PhysicalVideoMemoryLength = MEM_VGA_SIZE;

    //
    //    Get the number of available 256KB memory modules
    //    which are on the card.
    //
    //    00000 = 1MB
    //    00001 = 256KB
    //    00010 = 512KB
    //    00011 = 768KB
    //    00100 = 1MB
    //    01000 = 2MB
    //

    VideoPortWritePortUchar(hwDeviceExtension->IOAddress+
                            GRAPH_ADDRESS_PORT, 0x0f);
    VideoPortWritePortUchar(hwDeviceExtension->IOAddress+
                            GRAPH_DATA_PORT, 0x05);
    VideoPortWritePortUchar(hwDeviceExtension->IOAddress+
                            GRAPH_ADDRESS_PORT, 0x54);
    ulTempMemBankNum=
        (ULONG) VideoPortReadPortUchar(hwDeviceExtension->IOAddress+
                                       GRAPH_DATA_PORT);

    //
    // Set memory size fields based QVision memory size determined
    // above.  Could be 2M, 1M, or 512k.
    //

    switch (ulTempMemBankNum) {
        case 0x08:                        // 2 MB
            VideoDebugPrint((2,"\t 2MB RAM\n"));
            hwDeviceExtension->InstalledVmem = vmem2Meg;
            hwDeviceExtension->PhysicalVideoMemoryLength = 0x200000;
            break;

        case 0x00:                        // On the QVision card 0x00 = 1 MB
        case 0x04:                        // On the newer cards 0x001xx = 1MB
            VideoDebugPrint((2,"\t 1MB RAM\n"));
            hwDeviceExtension->InstalledVmem = vmem1Meg;
            hwDeviceExtension->PhysicalVideoMemoryLength = 0x100000;
            break;

        case 0x02:                        // 512 KB
            VideoDebugPrint((2,"\t 512KB RAM\n"));
            hwDeviceExtension->InstalledVmem = vmem512k;
            hwDeviceExtension->PhysicalVideoMemoryLength = 0x80000;
            break;

        default:                          // QVision supports 512 minimum
            VideoDebugPrint((1,"\tUnknown Memory size.\n"));

        break;
    }

/*** $0003 ************  miked 12/14/1993 *****************************
***
***  Save off the amount of Video RAM for CPQ_IOCTL_VIDEO_INFO
***
***********************************************************************/

    hwDeviceExtension->VideoChipInfo.ulVRAMPresent =
                  hwDeviceExtension->PhysicalVideoMemoryLength;

/***********************************************************************/

    hwDeviceExtension->PhysicalMemoryMappedBase.HighPart = 0;
    hwDeviceExtension->PhysicalMemoryMappedBase.LowPart = 0;
    hwDeviceExtension->PhysicalMemoryMappedLength = 0;

    //
    // If running on an 'Orion' or newer chip, reserve 4k of space in the
    // low-memory area for the memory-mapped I/O control registers.
    // This check for 'v32' ASICs with Bt485 DACs seems to work...
    //

    if ((hwDeviceExtension->VideoChipInfo.ulControllerType >= QRY_CONTROLLER_V32) &&
        (hwDeviceExtension->VideoChipInfo.ulDACType == QRY_DAC_BT485)) {

        //
        // For now, since the below 'VideoPortGetAccessRanges' call doesn't
        // work, always place the 4k memory-mapped I/O block in the second
        // half of the 128k space we've already reserved for the frame
        // buffer memory aperture.  Since our banking only uses the first
        // 64k area of this space, we won't run into any conflicts by placing
        // the I/O block in the second 64k area.
        //

        hwDeviceExtension->PhysicalMemoryMappedBase.HighPart = 0;
        hwDeviceExtension->PhysicalMemoryMappedBase.LowPart = 0x000B0000;
        hwDeviceExtension->PhysicalMemoryMappedLength = 0x00001000;

        #if 0 // !!! This doesn't work for now

            //
            // We're running on an orion-compatible QVision, so it can do
            // memory-mapped I/O.  Locate a 4k-aligned 4k block between 640k
            // and 1mb for our memory-mapped I/O window.
            //
            // Note that this call didn't work in this way on build 807.
            //

            status = VideoPortGetAccessRanges(hwDeviceExtension,
                                              1,
                                              &ioResource,
                                              1,
                                              &QVisionAccessRange[NUM_QVISION_ACCESS_RANGES],
                                              NULL,
                                              NULL,
                                              NULL);

            if (status != NO_ERROR)
            {
                VideoDebugPrint((1, "relocatable IO resouces failed with status %08lx\n", status));
            }
            else
            {
                //
                // Merge the range in to the rest of the ACCESS_RANGES claimed
                // by the driver
                //

                ulNumQVisionAccessRanges++;

                hwDeviceExtension->PhysicalMemoryMappedBase
                    = QVisionAccessRange[NUM_QVISION_ACCESS_RANGES].RangeStart;
                hwDeviceExtension->PhysicalMemoryMappedLength
                    = QVisionAccessRange[NUM_QVISION_ACCESS_RANGES].RangeLength;
            }

            //
            // Report the resources over again, since VideoPortGetAccessRanges
            // wiped them all out:
            //

            status = VideoPortVerifyAccessRanges(HwDeviceExtension,
                                                 ulNumQVisionAccessRanges,
                                                 QVisionAccessRange);

            if (status != NO_ERROR) {

                return status;

            }

        #endif

    }

    //
    // Map the video memory into the system virtual address space so we can
    // clear it out and use it for save and restore.
    //

    if ( (hwDeviceExtension->VideoMemoryAddress =
              VideoPortGetDeviceBase(hwDeviceExtension,
                                    hwDeviceExtension->PhysicalVideoMemoryBase,
                                    hwDeviceExtension->PhysicalVideoMemoryLength, FALSE)) == NULL) {

        VideoDebugPrint((1, "\tFail to get memory address\n"));

        return ERROR_INVALID_PARAMETER;

    }


    //
    //    The QVision card must have at least 1/2MB of RAM to
    //    support the minimum mode provided in this driver.
    //

    if (hwDeviceExtension->InstalledVmem < vmem512k) {
              VideoDebugPrint((1,"\tNot enough video memory\n"));
              return ERROR_INVALID_PARAMETER;
    }

    //
    // At this point, we have a card. so write out the memory size to the
    // registry.
    //
/*** $0011 ***********  adrianc 2/17/1995 ******************************
***   This is a fix for RAID# 3292 - 0 MemorySize.                   ***
***********************************************************************/
    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"HardwareInformation.MemorySize",
                                   &hwDeviceExtension->PhysicalVideoMemoryLength,
                                   sizeof(ULONG));

    //
    // Indicate we do not wish to be called again for another initialization.
    //

    *Again = 0;

    //
    // Indicate a successful completion status.
    //

    return NO_ERROR;

} // VgaFindAdapter()

//---------------------------------------------------------------------------
BOOLEAN
VgaInitialize(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine does one time initialization of the device.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

Return Value:

    None.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    //
    // set up the default cursor position and type.
    //

    VideoDebugPrint((1,"QVision.sys: VgaInitialize.\n"));

    hwDeviceExtension->CursorPosition.Column = 0;
    hwDeviceExtension->CursorPosition.Row    = 0;
    hwDeviceExtension->CursorTopScanLine     = 0;
    hwDeviceExtension->CursorBottomScanLine  = 31;
    hwDeviceExtension->CursorEnable          = TRUE;


    return TRUE;

} // VgaInitialize()

//---------------------------------------------------------------------------
BOOLEAN
VgaStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )

/*++

Routine Description:

    This routine is the main execution routine for the miniport driver. It
    accepts a Video Request Packet, performs the request, and then returns
    with the appropriate status.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

    RequestPacket - Pointer to the video request packet. This structure
        contains all the parameters passed to the VideoIoControl function.

Return Value:

    This routine will return error codes from the various support routines
    and will also return ERROR_INSUFFICIENT_BUFFER for incorrectly sized
    buffers and ERROR_INVALID_FUNCTION for unsupported functions.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VP_STATUS status;
    VIDEO_MODE videoMode;
    PVIDEO_MEMORY_INFORMATION memoryInformation;
    ULONG inIoSpace;
    PVIDEO_PUBLIC_ACCESS_RANGES portAccess;
    ULONG physicalMemoryMappedLength;
    PVIDEO_MEMORY mappedMemory;

    VideoDebugPrint((1, "QVision.sys: VgaStartIO.\n"));

    //
    //  Unlock the extended QVision registers.
    //

    QVUnlockExtRegs(hwDeviceExtension);


    //
    // Switch on the IoContolCode in the RequestPacket. It indicates which
    // function must be performed by the driver.
    //

    switch (RequestPacket->IoControlCode) {

      case IOCTL_VIDEO_MAP_VIDEO_MEMORY:

        VideoDebugPrint((2, "\tMapVideoMemory\n"));

        if ( (RequestPacket->OutputBufferLength <
              (RequestPacket->StatusBlock->Information =
                                     sizeof(VIDEO_MEMORY_INFORMATION))) ||
             (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) ) {

            status = ERROR_INSUFFICIENT_BUFFER;
        }

        memoryInformation = RequestPacket->OutputBuffer;

        memoryInformation->VideoRamBase = ((PVIDEO_MEMORY)
                (RequestPacket->InputBuffer))->RequestedVirtualAddress;

        memoryInformation->VideoRamLength =
                hwDeviceExtension->PhysicalVideoMemoryLength;

        inIoSpace = 0;

        status = VideoPortMapMemory(hwDeviceExtension,
                                    hwDeviceExtension->PhysicalVideoMemoryBase,
                                    &(memoryInformation->VideoRamLength),
                                    &inIoSpace,
                                    &(memoryInformation->VideoRamBase));

        memoryInformation->FrameBufferBase =
            ((PUCHAR) (memoryInformation->VideoRamBase)) +
            (hwDeviceExtension->PhysicalFrameBase.LowPart -
            hwDeviceExtension->PhysicalVideoMemoryBase.LowPart);

        memoryInformation->FrameBufferLength =
            hwDeviceExtension->PhysicalFrameLength;

        break;

    case IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES:

        VideoDebugPrint((2, "\tQueryPublicAccessRanges\n"));

        if ( RequestPacket->OutputBufferLength <
              (RequestPacket->StatusBlock->Information =
                                     sizeof(VIDEO_PUBLIC_ACCESS_RANGES)) ) {

            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        portAccess = RequestPacket->OutputBuffer;

        portAccess->VirtualAddress = NULL;

        status = NO_ERROR;

        if (hwDeviceExtension->PhysicalMemoryMappedLength != 0) {

            inIoSpace = 0;

            physicalMemoryMappedLength = hwDeviceExtension->PhysicalMemoryMappedLength;

            status = VideoPortMapMemory(hwDeviceExtension,
                                        hwDeviceExtension->PhysicalMemoryMappedBase,
                                        &physicalMemoryMappedLength,
                                        &inIoSpace,
                                        &(portAccess->VirtualAddress));
        }

        break;

    case IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES:

        VideoDebugPrint((2, "\tFreePublicAccessRanges\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) {

            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        status = NO_ERROR;

        mappedMemory = RequestPacket->InputBuffer;

        if (mappedMemory->RequestedVirtualAddress != NULL) {

            status = VideoPortUnmapMemory(hwDeviceExtension,
                                          mappedMemory->
                                               RequestedVirtualAddress,
                                          0);
        }

        break;

    case IOCTL_VIDEO_UNMAP_VIDEO_MEMORY:

        VideoDebugPrint((2, "\tUnMapVideoMemory\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) {

            status = ERROR_INSUFFICIENT_BUFFER;
        }

        status = VideoPortUnmapMemory(hwDeviceExtension,
                                      ((PVIDEO_MEMORY)
                                       (RequestPacket->InputBuffer))->
                                           RequestedVirtualAddress,
                                      0);

        break;


    case IOCTL_VIDEO_QUERY_AVAIL_MODES:

        VideoDebugPrint((2, "\tQueryAvailableModes\n"));

        status = VgaQueryAvailableModes(HwDeviceExtension,
                                        (PVIDEO_MODE_INFORMATION)
                                            RequestPacket->OutputBuffer,
                                        RequestPacket->OutputBufferLength,
                                        &RequestPacket->StatusBlock->Information);

        break;


    case IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES:

        VideoDebugPrint((2, "\tQueryNumAvailableModes\n"));

        status = VgaQueryNumberOfAvailableModes(HwDeviceExtension,
                                                (PVIDEO_NUM_MODES)
                                                    RequestPacket->OutputBuffer,
                                                RequestPacket->OutputBufferLength,
                                                &RequestPacket->StatusBlock->Information);

        break;


    case IOCTL_VIDEO_QUERY_CURRENT_MODE:

        VideoDebugPrint((2, "\tQueryCurrentMode\n"));

        status = VgaQueryCurrentMode(HwDeviceExtension,
                                     (PVIDEO_MODE_INFORMATION) RequestPacket->OutputBuffer,
                                     RequestPacket->OutputBufferLength,
                                     &RequestPacket->StatusBlock->Information);

        break;


    case IOCTL_VIDEO_SET_CURRENT_MODE:

        VideoDebugPrint((2, "\tSetCurrentModes\n"));

        status = VgaSetMode(HwDeviceExtension,
                              (PVIDEO_MODE) RequestPacket->InputBuffer,
                              RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_RESET_DEVICE:

        VideoDebugPrint((2, "\tReset Device\n"));

        videoMode.RequestedMode = DEFAULT_MODE;

        status = VgaSetMode(HwDeviceExtension,
                                 (PVIDEO_MODE) &videoMode,
                                 sizeof(videoMode));

        break;


    case IOCTL_VIDEO_LOAD_AND_SET_FONT:

        VideoDebugPrint((2, "\tLoadAndSetFont\n"));

        status = VgaLoadAndSetFont(HwDeviceExtension,
                                   (PVIDEO_LOAD_FONT_INFORMATION) RequestPacket->InputBuffer,
                                   RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_QUERY_CURSOR_POSITION:

        VideoDebugPrint((2, "\tQueryCursorPosition\n"));

        status = VgaQueryCursorPosition(HwDeviceExtension,
                                        (PVIDEO_CURSOR_POSITION) RequestPacket->OutputBuffer,
                                        RequestPacket->OutputBufferLength,
                                        &RequestPacket->StatusBlock->Information);

        break;


    case IOCTL_VIDEO_SET_CURSOR_POSITION:

        VideoDebugPrint((2, "\tSetCursorPosition\n"));

        status = VgaSetCursorPosition(HwDeviceExtension,
                                      (PVIDEO_CURSOR_POSITION)
                                          RequestPacket->InputBuffer,
                                      RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_QUERY_CURSOR_ATTR:

        VideoDebugPrint((2, "\tQueryCursorAttributes\n"));

        status = VgaQueryCursorAttributes(HwDeviceExtension,
                                          (PVIDEO_CURSOR_ATTRIBUTES) RequestPacket->OutputBuffer,
                                          RequestPacket->OutputBufferLength,
                                          &RequestPacket->StatusBlock->Information);

        break;


    case IOCTL_VIDEO_SET_CURSOR_ATTR:

        VideoDebugPrint((2, "\tSetCursorAttributes\n"));

        status = VgaSetCursorAttributes(HwDeviceExtension,
                                        (PVIDEO_CURSOR_ATTRIBUTES) RequestPacket->InputBuffer,
                                        RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_SET_PALETTE_REGISTERS:

        VideoDebugPrint((2, "\tSetPaletteRegs\n"));

        status = VgaSetPaletteReg(HwDeviceExtension,
                                  (PVIDEO_PALETTE_DATA) RequestPacket->InputBuffer,
                                  RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_SET_COLOR_REGISTERS:

        VideoDebugPrint((2, "\tSetColorRegs\n"));

        status = VgaSetColorLookup(HwDeviceExtension,
                                   (PVIDEO_CLUT) RequestPacket->InputBuffer,
                                   RequestPacket->InputBufferLength);

        break;

    case IOCTL_VIDEO_RESTORE_HARDWARE_STATE:

        VideoDebugPrint((2, "\tRestoreHardwareState\n"));

           // error out until hardware save/restore fully implemented
           // be sure to install as NOT vga compatible

           status = VgaRestoreHardwareState(HwDeviceExtension,
                                         (PVIDEO_HARDWARE_STATE) RequestPacket->InputBuffer,
                                         RequestPacket->InputBufferLength);
        break;


    case IOCTL_VIDEO_SAVE_HARDWARE_STATE:

        VideoDebugPrint((2, "\tSaveHardwareState\n"));

        // error out until hardware save/restore fully implemented
        // be sure to install as NOT vga compatible

        status = VgaSaveHardwareState(HwDeviceExtension,
                                      (PVIDEO_HARDWARE_STATE) RequestPacket->OutputBuffer,
                                      RequestPacket->OutputBufferLength,
                                      &RequestPacket->StatusBlock->Information);

        break;

    case IOCTL_VIDEO_GET_BANK_SELECT_CODE:

        VideoDebugPrint((2, "\tGetBankSelectCode\n"));

        status = VgaGetBankSelectCode(HwDeviceExtension,
                                        (PVIDEO_BANK_SELECT) RequestPacket->OutputBuffer,
                                        RequestPacket->OutputBufferLength,
                                        &RequestPacket->StatusBlock->Information);

        break;

    case IOCTL_VIDEO_ENABLE_VDM:

        VideoDebugPrint((2, "VgaStartIO - EnableVDM\n"));

        hwDeviceExtension->TrappedValidatorCount = 0;
        hwDeviceExtension->SequencerAddressValue = 0;

        hwDeviceExtension->CurrentNumVdmAccessRanges =
            NUM_MINIMAL_QVISION_VALIDATOR_ACCESS_RANGE;
        hwDeviceExtension->CurrentVdmAccessRange =
            MinimalQVisionValidatorAccessRange;

        VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                         hwDeviceExtension->CurrentNumVdmAccessRanges,
                                         hwDeviceExtension->CurrentVdmAccessRange);

        status = NO_ERROR;

        break;

    case IOCTL_VIDEO_QUERY_POINTER_CAPABILITIES:

        VideoDebugPrint((2, "QVStartIO - QueryPointerCapabilities\n"));

        if (RequestPacket->OutputBufferLength <
            (RequestPacket->StatusBlock->Information =
                                    sizeof(VIDEO_POINTER_CAPABILITIES))) {

            status = ERROR_INSUFFICIENT_BUFFER;

        } else {

            VIDEO_POINTER_CAPABILITIES *PointerCaps;

            PointerCaps = (VIDEO_POINTER_CAPABILITIES *) RequestPacket->OutputBuffer;

            //
            // The hardware pointer works in all modes, and requires no
            // part of off-screen memory.
            //

            PointerCaps->Flags = VIDEO_MODE_MONO_POINTER |
                                 VIDEO_MODE_ASYNC_POINTER |
                                 VIDEO_MODE_LOCAL_POINTER;

            PointerCaps->MaxWidth = PTR_WIDTH_IN_PIXELS;
            PointerCaps->MaxHeight = PTR_HEIGHT;
            PointerCaps->HWPtrBitmapStart = (ULONG) -1;
            PointerCaps->HWPtrBitmapEnd = (ULONG) -1;

            //
            // Read the current status of the DacCmd2 register:
            //

            hwDeviceExtension->DacCmd2 = VideoPortReadPortUchar((PUCHAR)DAC_CMD_2) & 0xFC;

            status = NO_ERROR;
        }

        break;

    case IOCTL_VIDEO_ENABLE_POINTER:

        VideoDebugPrint((2, "QVStartIO - EnablePointer\n"));

/*** $0008 ***********  adrianc 2/17/1995 ******************************
***   Because the DAC CMD2 register can change when a mode is set,   ***
***   it needs to be read again to get the correct value.            ***
***********************************************************************/

        //
        // Read the current status of the DacCmd2 register:
        //

        hwDeviceExtension->DacCmd2 = VideoPortReadPortUchar((PUCHAR)DAC_CMD_2) & 0xFC;

        VideoPortWritePortUchar((PUCHAR) DAC_CMD_2,
                                (UCHAR) (hwDeviceExtension->DacCmd2 | CURSOR_ENABLE));

        status = NO_ERROR;

        break;

    case IOCTL_VIDEO_DISABLE_POINTER:

        VideoDebugPrint((2, "QVStartIO - DisablePointer\n"));

/*** $0008 ***********  adrianc 2/17/1995 ******************************
***   Because the DAC CMD2 register can change when a mode is set,   ***
***   it needs to be read again to get the correct value.            ***
***********************************************************************/

        //
        // Read the current status of the DacCmd2 register:
        //

        hwDeviceExtension->DacCmd2 = VideoPortReadPortUchar((PUCHAR)DAC_CMD_2) & 0xFC;

        VideoPortWritePortUchar((PUCHAR) DAC_CMD_2,
                                (UCHAR) hwDeviceExtension->DacCmd2);

        status = NO_ERROR;

        break;

    case IOCTL_VIDEO_SET_POINTER_POSITION:

        VideoDebugPrint((2, "QVStartIO - SetPointerPosition\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_POINTER_POSITION)) {

            status = ERROR_INSUFFICIENT_BUFFER;

        } else {

            VIDEO_POINTER_POSITION *pPointerPosition;

            pPointerPosition = (VIDEO_POINTER_POSITION *) RequestPacket->InputBuffer;

            //
            // The QVision's HW pointer coordinate system is upper-left =
            // (31, 31), lower-right = (0, 0).  Thus, we must always bias
            // the pointer.  As a result, the pointer position register will
            // never go negative.
            //

            VideoPortWritePortUshort((PUSHORT) CURSOR_X,
                                     (USHORT) (pPointerPosition->Column + CURSOR_CX));
            VideoPortWritePortUshort((PUSHORT) CURSOR_Y,
                                     (USHORT) (pPointerPosition->Row + CURSOR_CY));

            status = NO_ERROR;

        }

        break;

    case IOCTL_VIDEO_SET_POINTER_ATTR:

        VideoDebugPrint((2, "QVStartIO - SetPointerAttr\n"));

/*** $0008 ***********  adrianc 2/17/1995 ******************************
***   Because the DAC CMD2 register can change when a mode is set,   ***
***   it needs to be read again to get the correct value.            ***
***********************************************************************/

        //
        // Read the current status of the DacCmd2 register:
        //

        hwDeviceExtension->DacCmd2 = VideoPortReadPortUchar((PUCHAR)DAC_CMD_2) & 0xFC;

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_POINTER_ATTRIBUTES)) {

            status = ERROR_INSUFFICIENT_BUFFER;

        } else {

            VIDEO_POINTER_ATTRIBUTES *pPointerAttributes;
            LONG                      i;
            LONG                      j;
            UCHAR*                    pPointerBits;

            pPointerAttributes = (VIDEO_POINTER_ATTRIBUTES *) RequestPacket->InputBuffer;

            //
            // We have to turn off the hardware pointer while we down-load
            // the new shape, otherwise we get sparkles on the screen.
            //

            VideoPortWritePortUchar((PUCHAR) DAC_CMD_2,
                                    (UCHAR) hwDeviceExtension->DacCmd2);

            VideoPortWritePortUchar((PUCHAR) CURSOR_WRITE,
                                      CURSOR_PLANE_0);

            //
            // Download XOR mask:
            //

            pPointerBits = pPointerAttributes->Pixels + (PTR_WIDTH * PTR_HEIGHT);
            for (i = 0; i < PTR_HEIGHT; i++) {

                for (j = 0; j < PTR_WIDTH; j++) {

                    VideoPortWritePortUchar((PUCHAR) CURSOR_DATA,
                                            (UCHAR) *pPointerBits++);
                }
            }

            //
            // Download AND mask:
            //

            pPointerBits = pPointerAttributes->Pixels;
            for (i = 0; i < PTR_HEIGHT; i++) {

                for (j = 0; j < PTR_WIDTH; j++) {

                    VideoPortWritePortUchar((PUCHAR) CURSOR_DATA,
                                            (UCHAR) *pPointerBits++);
                }
            }

            //
            // Set the new position:
            //

            VideoPortWritePortUshort((PUSHORT) CURSOR_X,
                                     (USHORT) (pPointerAttributes->Column + CURSOR_CX));
            VideoPortWritePortUshort((PUSHORT) CURSOR_Y,
                                     (USHORT) (pPointerAttributes->Row + CURSOR_CY));

            //
            // Enable or disable pointer:
            //

            if (pPointerAttributes->Enable) {

                VideoPortWritePortUchar((PUCHAR) DAC_CMD_2,
                                        (UCHAR) (hwDeviceExtension->DacCmd2 | CURSOR_ENABLE));

            }

            status = NO_ERROR;

        }

        break;

/*** $0003 ************  miked 12/14/1993 *****************************
***
***  Added ioctl CPQ_IOCTL_VIDEO_INFO to provide info back to the
***  hardware accelerated DLL.
***
***********************************************************************/
    case CPQ_IOCTL_VIDEO_INFO:
       {
       PVIDEO_CHIP_INFO pinChipInfo =
            (PVIDEO_CHIP_INFO)RequestPacket->InputBuffer;

       PVIDEO_CHIP_INFO poutChipInfo =
            (PVIDEO_CHIP_INFO)RequestPacket->OutputBuffer;

       ULONG ulCopySize;

       VideoDebugPrint((1,"\nQVision.Sys: CPQ_IOCTL_VIDEO_INFO...\n"));
       VideoDebugPrint((1,"\tpinChipInfo->ulStructVer:0x%lx, VIDEO_CHIP_INFO_VERSION:0x%lx\n",
                             pinChipInfo->ulStructVer,
                             VIDEO_CHIP_INFO_VERSION
                       ));

       if (pinChipInfo->ulStructVer != VIDEO_CHIP_INFO_VERSION) {
          VideoDebugPrint((1,"\tVIDEO_CHIP_INFO Version mismatch...\n"));
          }


       //
       // determine how much to copy from my buf (dont want to
       // copy more than user has passed up)
       //
       ulCopySize = min( RequestPacket->OutputBufferLength,
                    sizeof(VIDEO_CHIP_INFO)
                  );
       //
       // subtract off version & size, we do not want to overwrite
       // these fields in the user's buffer.
       //

       ulCopySize -= sizeof(hwDeviceExtension->VideoChipInfo.ulStructVer) +
                        sizeof(hwDeviceExtension->VideoChipInfo.ulStructLen);

       if (ulCopySize > 0) {
          VideoPortMoveMemory(&poutChipInfo->ulAsicID,
                        &hwDeviceExtension->VideoChipInfo.ulAsicID,
                        ulCopySize);
          //
          // we must set StatusBlock->Information to the amount of memory
          // to copy back to the user's buffer...intuitive isn't it!
          //
          RequestPacket->StatusBlock->Information =
                 sizeof(VIDEO_CHIP_INFO);
          //
          // display the information in our private buffer now
          //
          VideoDebugPrint((1,"\tulStructVer:0x%lx\n",
                       hwDeviceExtension->VideoChipInfo.ulStructVer));
          VideoDebugPrint((1,"\tulStructLen:0x%lx\n",
                       hwDeviceExtension->VideoChipInfo.ulStructLen));
          VideoDebugPrint((1,"\tulAsicID:0x%lx\n",
                       hwDeviceExtension->VideoChipInfo.ulAsicID));
          VideoDebugPrint((1,"\tulExtendedID:0x%lx\n",
                       hwDeviceExtension->VideoChipInfo.ulExtendedID));
          VideoDebugPrint((1,"\tulExtendedID2:0x%lx\n",
                       hwDeviceExtension->VideoChipInfo.ulExtendedID2));
          VideoDebugPrint((1,"\tulControllerType:0x%lx\n",
                       hwDeviceExtension->VideoChipInfo.ulControllerType));
          VideoDebugPrint((1,"\tulDACType:0x%lx\n",
                       hwDeviceExtension->VideoChipInfo.ulDACType));
          VideoDebugPrint((1,"\tulVRAMPresent:0x%lx\n",
                       hwDeviceExtension->VideoChipInfo.ulVRAMPresent));

          status = NO_ERROR;
          }
       else
          status = ERROR_INSUFFICIENT_BUFFER;
       }
       break;
    //
    // end $0003: miked - new ioctl
    //
/***********************************************************************/

    //
    // if we get here, an invalid IoControlCode was specified.
    //

    default:

         VideoDebugPrint((1,"\tFell through vga startIO routine - invalid command\n"));
         VideoDebugPrint((1,"\tRequest IoControl = %x\n",RequestPacket->IoControlCode));

         status = ERROR_INVALID_FUNCTION;

         break;

    }

    RequestPacket->StatusBlock->Status = status;

    return TRUE;

} // VgaStartIO()

//---------------------------------------------------------------------------
//
// private routines
//

VP_STATUS
VgaLoadAndSetFont(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_LOAD_FONT_INFORMATION FontInformation,
    ULONG FontInformationSize
    )

/*++

Routine Description:

    Takes a buffer containing a user-defined font and loads it into the
    VGA soft font memory and programs the VGA to the appropriate character
    cell size.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    FontInformation - Pointer to the structure containing the information
        about the loadable ROM font to be set.

    FontInformationSize - Length of the input buffer supplied by the user.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data.

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    PUCHAR destination;
    PUCHAR source;
    USHORT width;
    ULONG i;

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        return ERROR_INVALID_PARAMETER;

    }

    VideoDebugPrint((1,"QVision.sys: VgaLoadAndSetFont.\n"));

    //
    // Check if the size of the data in the input buffer is large enough
    // and that it contains all the data.
    //

    if ( (FontInformationSize < sizeof(VIDEO_LOAD_FONT_INFORMATION)) ||
         (FontInformationSize < sizeof(VIDEO_LOAD_FONT_INFORMATION) +
                        sizeof(UCHAR) * (FontInformation->FontSize - 1)) ) {

        VideoDebugPrint((1,"\tERROR_INSUFFICIENT_BUFFER\n"));
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check for the width and height of the font
    //

    if ( ((FontInformation->WidthInPixels != 8) &&
          (FontInformation->WidthInPixels != 9)) ||
         (FontInformation->HeightInPixels > 32) ) {

        VideoDebugPrint((1,"\tERROR_INVALID_PARAMETER\n"));
        return ERROR_INVALID_PARAMETER;

    }

    //
    // Check the size of the font buffer is the right size for the size
    // font being passed down.
    //

    if (FontInformation->FontSize < FontInformation->HeightInPixels * 256 *
                                    sizeof(UCHAR) ) {

        VideoDebugPrint((1,"\tERROR_INSUFFICIENT_BUFFER\n"));
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Since the font parameters are valid, store the parameters in the
    // device extension and load the font.
    //

    HwDeviceExtension->FontPelRows = FontInformation->HeightInPixels;
    HwDeviceExtension->FontPelColumns = FontInformation->WidthInPixels;

    HwDeviceExtension->CurrentMode->row =
        HwDeviceExtension->CurrentMode->vres / HwDeviceExtension->FontPelRows;

    width =
      HwDeviceExtension->CurrentMode->hres / HwDeviceExtension->FontPelColumns;

    if (width < (USHORT)HwDeviceExtension->CurrentMode->col) {

        HwDeviceExtension->CurrentMode->col = width;

    }

    source = &(FontInformation->Font[0]);

    //
    // Set up the destination and source pointers for the font
    //

    destination = (PUCHAR)HwDeviceExtension->VideoMemoryAddress;

    //
    // Map font buffer at A0000
    //

    VgaInterpretCmdStream(HwDeviceExtension, EnableA000Data);

    //
    // Move the font to its destination
    //

    for (i = 1; i <= 256; i++) {

        VideoPortWriteRegisterBufferUchar(destination,
                                          source,
                                          FontInformation->HeightInPixels);

        destination += 32;
        source += FontInformation->HeightInPixels;

    }

    VgaInterpretCmdStream(HwDeviceExtension, DisableA000Color);

    //
    // Restore to a text mode.
    //

    //
    // Set Height of font.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, 0x9);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR,
            (UCHAR)(FontInformation->HeightInPixels - 1));

    //
    // Set Width of font.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, 0x12);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR,
            (UCHAR)(((USHORT)FontInformation->HeightInPixels *
            (USHORT)HwDeviceExtension->CurrentMode->row) - 1));

    i = HwDeviceExtension->CurrentMode->vres /
        HwDeviceExtension->CurrentMode->row;

    //
    // Set Cursor End
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, 0xb);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR, (UCHAR)--i);

    //
    // Set Cursor Statr
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, 0xa);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR, (UCHAR)--i);

    return NO_ERROR;

} //end VgaLoadAndSetFont()

//---------------------------------------------------------------------------
VP_STATUS
VgaQueryCursorPosition(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_POSITION CursorPosition,
    ULONG CursorPositionSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns the row and column of the cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    CursorPosition - Pointer to the output buffer supplied by the user. This
        is where the cursor position is stored.

    CursorPositionSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - output buffer not large enough to return
        any useful data

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    VideoDebugPrint((1,"QVision.sys: VgaQueryCursorPosition.\n"));

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        *OutputSize = 0;
        return ERROR_INVALID_PARAMETER;

    }


    //
    // If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (CursorPositionSize < (*OutputSize = sizeof(VIDEO_CURSOR_POSITION)) ) {

        *OutputSize = 0;
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Store the postition of the cursor into the buffer.
    //

    CursorPosition->Column = HwDeviceExtension->CursorPosition.Column;
    CursorPosition->Row = HwDeviceExtension->CursorPosition.Row;

    return NO_ERROR;

} // end VgaQueryCursorPosition()

//---------------------------------------------------------------------------
VP_STATUS
VgaSetCursorPosition(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_POSITION CursorPosition,
    ULONG CursorPositionSize
    )

/*++

Routine Description:

    This routine verifies that the requested cursor position is within
    the row and column bounds of the current mode and font. If valid, then
    it sets the row and column of the cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    CursorPosition - Pointer to the structure containing the cursor position.

    CursorPositionSize - Length of the input buffer supplied by the user.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    USHORT position;

    VideoDebugPrint((1,"QVision.sys: VgaSetCursorPosition. - ENTRY\n"));

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        return ERROR_INVALID_PARAMETER;

    }


    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (CursorPositionSize < sizeof(VIDEO_CURSOR_POSITION)) {

            return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check if the new values for the cursor positions are in the valid
    // bounds for the screen.
    //

    if ((CursorPosition->Column >= HwDeviceExtension->CurrentMode->col) ||
        (CursorPosition->Row >= HwDeviceExtension->CurrentMode->row)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Store these new values in the device extension so we can use them in
    // a QUERY.
    //

    HwDeviceExtension->CursorPosition.Column = CursorPosition->Column;
    HwDeviceExtension->CursorPosition.Row = CursorPosition->Row;

    //
    // Calculate the position on the screen at which the cursor must be
    // be displayed
    //

    position = (USHORT) (HwDeviceExtension->CurrentMode->col *
                         CursorPosition->Row + CursorPosition->Column);


    //
    // Address Cursor Location Low Register in CRT Controller Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, IND_CURSOR_LOW_LOC);

    //
    // Set Cursor Location Low Register
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR, (UCHAR) (position & 0x00FF));

    //
    // Address Cursor Location High Register in CRT Controller Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, IND_CURSOR_HIGH_LOC);

    //
    // Set Cursor Location High Register
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR, (UCHAR) (position >> 8));

    VideoDebugPrint((1,"QVision.sys: VgaSetCursorPosition. - EXIT\n"));

    return NO_ERROR;

} // end VgaSetCursorPosition()

//---------------------------------------------------------------------------
VP_STATUS
VgaQueryCursorAttributes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG CursorAttributesSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns information about the height and visibility of the
    cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    CursorAttributes - Pointer to the output buffer supplied by the user.
        This is where the cursor type is stored.

    CursorAttributesSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - output buffer not large enough to return
        any useful data

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    VideoDebugPrint((1,"QVision.sys: VgaQueryCursorAttributes.\n"));

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        *OutputSize = 0;
        return ERROR_INVALID_PARAMETER;

    }


    //
    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (CursorAttributesSize < (*OutputSize =
            sizeof(VIDEO_CURSOR_ATTRIBUTES)) ) {

        *OutputSize = 0;
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Store the cursor information into the buffer.
    //

    CursorAttributes->Height = (USHORT) HwDeviceExtension->CursorTopScanLine;
    CursorAttributes->Width = (USHORT) HwDeviceExtension->CursorBottomScanLine;
    CursorAttributes->Enable = HwDeviceExtension->CursorEnable;

    return NO_ERROR;

} // end VgaQueryCursorAttributes()

//---------------------------------------------------------------------------
VP_STATUS
VgaSetCursorAttributes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG CursorAttributesSize
    )

/*++

Routine Description:

    This routine verifies that the requested cursor height is within the
    bounds of the character cell. If valid, then it sets the new
    visibility and height of the cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    CursorType - Pointer to the structure containing the cursor information.

    CursorTypeSize - Length of the input buffer supplied by the user.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    UCHAR cursorLine;

    VideoDebugPrint((1,"QVision.sys: VgaSetCursorAttributes.\n"));

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (CursorAttributesSize < sizeof(VIDEO_CURSOR_ATTRIBUTES)) {

            return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check if the new values for the cursor type are in the valid range.
    //

    if ((CursorAttributes->Height >= HwDeviceExtension->FontPelRows) ||
        (CursorAttributes->Width > 31)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Store the cursor information in the device extension so we can use
    // them in a QUERY.
    //

    HwDeviceExtension->CursorTopScanLine = (UCHAR) CursorAttributes->Height;
    HwDeviceExtension->CursorBottomScanLine = (UCHAR) CursorAttributes->Width;
    HwDeviceExtension->CursorEnable = CursorAttributes->Enable;

    //
    // Address Cursor Start Register in CRT Controller Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                CRTC_ADDRESS_PORT_COLOR,
                            IND_CURSOR_START);

    //
    // Set Cursor Start Register by writting to CRTCtl Data Register
    // Preserve the high three bits of this register.
    //
    // Only the Five low bits are used for the cursor height.
    // Bit 5 is cursor enable, bit 6 and 7 preserved.
    //

    cursorLine = (UCHAR) CursorAttributes->Height & 0x1F;

    cursorLine |= VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
        CRTC_DATA_PORT_COLOR) & 0xC0;

    if (!CursorAttributes->Enable) {

        cursorLine |= 0x20; // Flip cursor off bit

    }

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + CRTC_DATA_PORT_COLOR,
                            cursorLine);

    //
    // Address Cursor End Register in CRT Controller Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                CRTC_ADDRESS_PORT_COLOR,
                            IND_CURSOR_END);

    //
    // Set Cursor End Register. Preserve the high three bits of this
    // register.
    //

    cursorLine =
        (CursorAttributes->Width < (USHORT)(HwDeviceExtension->FontPelRows - 1)) ?
        CursorAttributes->Width : (HwDeviceExtension->FontPelRows - 1);

    cursorLine &= 0x1f;

    cursorLine |= VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR) & 0xE0;

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + CRTC_DATA_PORT_COLOR,
                            cursorLine);

    return NO_ERROR;

} // end VgaSetCursorAttributes()

//---------------------------------------------------------------------------
BOOLEAN
VgaIsPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine returns TRUE if a VGA is present. Determining whether a VGA
    is present is a two-step process. First, this routine walks bits through
    the Bit Mask register, to establish that there are readable indexed
    registers (EGAs normally don't have readable registers, and other adapters
    are unlikely to have indexed registers). This test is done first because
    it's a non-destructive EGA rejection test (correctly rejects EGAs, but
    doesn't potentially mess up the screen or the accessibility of display
    memory). Normally, this would be an adequate test, but some EGAs have
    readable registers, so next, we check for the existence of the Chain4 bit
    in the Memory Mode register; this bit doesn't exist in EGAs. It's
    conceivable that there are EGAs with readable registers and a register bit
    where Chain4 is stored, although I don't know of any; if a better test yet
    is needed, memory could be written to in Chain4 mode, and then examined
    plane by plane in non-Chain4 mode to make sure the Chain4 bit did what it's
    supposed to do. However, the current test should be adequate to eliminate
    just about all EGAs, and 100% of everything else.

    If this function fails to find a VGA, it attempts to undo any damage it
    may have inadvertently done while testing. The underlying assumption for
    the damage control is that if there's any non-VGA adapter at the tested
    ports, it's an EGA or an enhanced EGA, because: a) I don't know of any
    other adapters that use 3C4/5 or 3CE/F, and b), if there are other
    adapters, I certainly don't know how to restore their original states. So
    all error recovery is oriented toward putting an EGA back in a writable
    state, so that error messages are visible. The EGA's state on entry is
    assumed to be text mode, so the Memory Mode register is restored to the
    default state for text mode.

    If a VGA is found, the VGA is returned to its original state after
    testing is finished.

Arguments:

    None.

Return Value:

    TRUE if a VGA is present, FALSE if not.

--*/

{
    UCHAR originalGCAddr;
    UCHAR originalSCAddr;
    UCHAR originalBitMask;
    UCHAR originalReadMap;
    UCHAR originalMemoryMode;
    UCHAR originalRotateVal;
    UCHAR testMask;
    BOOLEAN returnStatus;
    ULONG ulASIC;
    PWSTR pwszChip, pwszDAC, pwszAdapterString;
    ULONG cbChip, cbDAC, cbAdapterString;


    VideoDebugPrint((1,"QVision.sys: VgaIsPresent.\n"));

    //
    // Remember the original state of the Graphics Controller Address register.
    //

    originalGCAddr = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT);

    //
    // Write the Read Map register with a known state so we can verify
    // that it isn't changed after we fool with the Bit Mask. This ensures
    // that we're dealing with indexed registers, since both the Read Map and
    // the Bit Mask are addressed at GRAPH_DATA_PORT.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);

    //
    // If we can't read back the Graphics Address register setting we just
    // performed, it's not readable and this isn't a VGA.
    //

    if ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
        GRAPH_ADDRESS_PORT) & GRAPH_ADDR_MASK) != IND_READ_MAP) {

        return FALSE;
    }

    //
    // Set the Read Map register to a known state.
    //

    originalReadMap = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, READ_MAP_TEST_SETTING);

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT) != READ_MAP_TEST_SETTING) {

        //
        // The Read Map setting we just performed can't be read back; not a
        // VGA. Restore the default Read Map state.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, READ_MAP_DEFAULT);

        return FALSE;
    }

    //
    // Remember the original setting of the Bit Mask register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_BIT_MASK);
    if ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT) & GRAPH_ADDR_MASK) != IND_BIT_MASK) {

        //
        // The Graphics Address register setting we just made can't be read
        // back; not a VGA. Restore the default Read Map state.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT, IND_READ_MAP);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, READ_MAP_DEFAULT);

        return FALSE;
    }

    originalBitMask = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT);

    //
    // Set up the initial test mask we'll write to and read from the Bit Mask.
    //

    testMask = 0xBB;

    do {

        //
        // Write the test mask to the Bit Mask.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, testMask);

        //
        // Make sure the Bit Mask remembered the value.
        //

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_DATA_PORT) != testMask) {

            //
            // The Bit Mask is not properly writable and readable; not a VGA.
            // Restore the Bit Mask and Read Map to their default states.
            //

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_DATA_PORT, BIT_MASK_DEFAULT);
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_ADDRESS_PORT, IND_READ_MAP);
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_DATA_PORT, READ_MAP_DEFAULT);

            return FALSE;
        }

        //
        // Cycle the mask for next time.
        //

        testMask >>= 1;

    } while (testMask != 0);

    //
    // There's something readable at GRAPH_DATA_PORT; now switch back and
    // make sure that the Read Map register hasn't changed, to verify that
    // we're dealing with indexed registers.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);
    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT) != READ_MAP_TEST_SETTING) {

        //
        // The Read Map is not properly writable and readable; not a VGA.
        // Restore the Bit Mask and Read Map to their default states, in case
        // this is an EGA, so subsequent writes to the screen aren't garbled.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, READ_MAP_DEFAULT);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT, IND_BIT_MASK);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, BIT_MASK_DEFAULT);

        return FALSE;
    }

    //
    // We've pretty surely verified the existence of the Bit Mask register.
    // Put the Graphics Controller back to the original state.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, originalReadMap);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_BIT_MASK);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, originalBitMask);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, originalGCAddr);

    //
    // Now, check for the existence of the Chain4 bit.
    //

    //
    // Remember the original states of the Sequencer Address and Memory Mode
    // registers.
    //

    originalSCAddr = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    if ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT) & SEQ_ADDR_MASK) != IND_MEMORY_MODE) {

        //
        // Couldn't read back the Sequencer Address register setting we just
        // performed.
        //

        return FALSE;
    }
    originalMemoryMode = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT);

    //
    // Toggle the Chain4 bit and read back the result. This must be done during
    // sync reset, since we're changing the chaining state.
    //

    //
    // Begin sync reset.
    //

    VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
             SEQ_ADDRESS_PORT),
             (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Toggle the Chain4 bit.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT, (UCHAR)(originalMemoryMode ^ CHAIN4_MASK));

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT) != (UCHAR) (originalMemoryMode ^ CHAIN4_MASK)) {

        //
        // Chain4 bit not there; not a VGA.
        // Set text mode default for Memory Mode register.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, MEMORY_MODE_TEXT_DEFAULT);
        //
        // End sync reset.
        //

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT),
                (IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));

        returnStatus = FALSE;

    } else {

        //
        // It's a VGA.
        //

        //
        // Restore the original Memory Mode setting.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, originalMemoryMode);

        //
        // End sync reset.
        //

        VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT),
                (USHORT)(IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));

        //
        // Restore the original Sequencer Address setting.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT, originalSCAddr);

        returnStatus = TRUE;
    }

    //---------------------------------------------------------------
    //    This is where the QVision specific code starts.
    //    We will be looking for the QVision card.
    //    We will search for the QVision card only if we detected a
    //    VGA card.  If the VGA card is not detected, there is no
    //    reason to search for the QVision card.
    //---------------------------------------------------------------

    if (returnStatus) {

/*** $0003 ************  miked 12/14/1993 *****************************
***
***  Initialize VideoChipInfo Structure in device extension
***
***********************************************************************/
        VideoPortZeroMemory(&HwDeviceExtension->VideoChipInfo,
                        sizeof(VIDEO_CHIP_INFO));
        HwDeviceExtension->VideoChipInfo.ulStructVer = VIDEO_CHIP_INFO_VERSION;
        HwDeviceExtension->VideoChipInfo.ulStructLen = sizeof(VIDEO_CHIP_INFO);

/*** end: $0003 ************    miked 12/14/1993 **********************/

        //
        // Unlock QVision extended registers
        //

        QVUnlockExtRegs(HwDeviceExtension);


        //
        // First, is it Compaq?  Is 3cf.10 valid?
        //

        //
        // $0001
        // adrianc: 09/08/93
        // I changed the value which is sent to the GRAPH_DATA_PORT
        // from 0C to 2C.  The value 0C enabled the IRQ 2/9 so for a
        // very small period of time, the controller had the IRQ2/9
        // enabled.  Any disk controller which was set at IRQ 2/9 would
        // hang the system because the QVision controller would set
        // IRQ 2/9 and none of the loaded drivers would handle it.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress+
                                GRAPH_ADDRESS_PORT, 0x10);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress+
                                GRAPH_DATA_PORT, 0x2C);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress+
                                GRAPH_ADDRESS_PORT, 0x00);
        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress+
                                      GRAPH_DATA_PORT) == 0x2C) {

           VideoPortWritePortUchar(HwDeviceExtension->IOAddress+
                                   GRAPH_DATA_PORT, 0x00);
           returnStatus = FALSE;
        }

        //
        //  Is 3cf.03 (lower 3 bits) the same as 53c8
        //  (53c8 because of 0x0c to 3cf.10
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress+
                                GRAPH_ADDRESS_PORT, 0x03);

        //
        // save what was originally at GRAPH_ADDRESS_PORT
        //

        originalRotateVal = VideoPortReadPortUchar(HwDeviceExtension->IOAddress+
                                GRAPH_DATA_PORT);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress+
                                GRAPH_DATA_PORT, 0x03);

        VideoPortWritePortUchar((PUCHAR)0x53C8, 0x00);

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress+
                                   GRAPH_DATA_PORT) == 0x03)
        {
            //
            // restore what was originally at GRAPH_ADDRESS_PORT
            // so that V7 and ATI cards will work ok

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress+
                                    GRAPH_DATA_PORT, originalRotateVal);
            returnStatus = FALSE;
        }

        //
        //  We know its at least Compaq better than VGA,
        //  let's see if it is QVision
        //

/*** $0003 ************  miked 12/14/1993 *****************************
***
***  Added query of hardware to fill in struct that is used later in
***  new ioctl CPQ_IOCTL_VIDEO_INFO
***
***********************************************************************/
        ulASIC = QRY_ControllerASICID( HwDeviceExtension->IOAddress );

        HwDeviceExtension->VideoChipInfo.ulAsicID = ulASIC & 0xff;
        HwDeviceExtension->VideoChipInfo.ulExtendedID =
                           ((ulASIC & 0xff00) >> 8);
        HwDeviceExtension->VideoChipInfo.ulExtendedID2 =
                           ((ulASIC & 0xff0000) >> 16);

        HwDeviceExtension->VideoChipInfo.ulControllerType =
                  QRY_ControllerType( HwDeviceExtension->IOAddress );
        HwDeviceExtension->VideoChipInfo.ulDACType =
                  QRY_DACType( HwDeviceExtension->IOAddress );

        switch (HwDeviceExtension->VideoChipInfo.ulControllerType)
           {

           case QRY_CONTROLLER_V32:
           case QRY_CONTROLLER_V35:         // QVision 1280/1024 - new ASIC
           case QRY_CONTROLLER_V64:

              //
              //    We need to set bit 7 of the DAC_CMD_1 registers to 0
              //    so that we can access the DAC_STATUS_REG (13c6).
              //    After we enable the DAC_STATUS_REG, we read it.
              //    If bit 7 of the DAC_STATUS_REG is 1, this means
              //    that the DAC is at least a 485, which means that it
              //    supports 1280 mode.  It the bit is 0, the DAC is
              //    probably a 484 and it only supports 1024.
              //    When we are done detecting the correct card, restore
              //    the DAC_CMD_1 register to its original value.
              //    If we find the correct chip but we are not on an
              //    EISA system, the EISA IDs for Juniper and Fir will not
              //    match the ID in the HwDeviceExtension.  In this case we
              //    default to the ISA cards for safety.  The ISA cards will
              //    work fine in the EISA system but the EISA cards will
              //    not work in the ISA systems.
              //

              //    12/2/93 - some of the above description is done in the
              //    QRY_DACType() function.
              //
              if (HwDeviceExtension->VideoChipInfo.ulDACType ==
                  QRY_DAC_BT485 )
                 {
                 VideoDebugPrint((2,"\tJUNIPER.\n"));
                 if (HwDeviceExtension->VideoHardware.ulEisaID == EISA_ID_JUNIPER_E)
                    HwDeviceExtension->VideoHardware.AdapterType = JuniperEisa;
                 else if (HwDeviceExtension->VideoHardware.ulEisaID == EISA_ID_JUNIPER_I)
                    HwDeviceExtension->VideoHardware.AdapterType = JuniperIsa;
                 else
                    HwDeviceExtension->VideoHardware.AdapterType = JuniperIsa;
                 }
              else {
                 VideoDebugPrint((2,"\tFIR.\n"));
                 if (HwDeviceExtension->VideoHardware.ulEisaID == EISA_ID_FIR_E)
                    HwDeviceExtension->VideoHardware.AdapterType = FirEisa;
                 else if (HwDeviceExtension->VideoHardware.ulEisaID == EISA_ID_FIR_I)
                    HwDeviceExtension->VideoHardware.AdapterType = FirIsa;
                 else
                    HwDeviceExtension->VideoHardware.AdapterType = FirIsa;
                 }

              returnStatus = TRUE;
              break;

           case QRY_CONTROLLER_VICTORY:      // QVision 1024 original ASIC

              VideoDebugPrint((2,"\tQVISION.\n"));
              if (HwDeviceExtension->VideoHardware.ulEisaID == EISA_ID_QVISION_E)
                 HwDeviceExtension->VideoHardware.AdapterType = AriesEisa;
              else if (HwDeviceExtension->VideoHardware.ulEisaID == EISA_ID_QVISION_I)
                 HwDeviceExtension->VideoHardware.AdapterType = AriesIsa;
              else
                 HwDeviceExtension->VideoHardware.AdapterType = AriesIsa;
              returnStatus = TRUE;
              break;

           default:                         // we should not get here

              HwDeviceExtension->VideoHardware.AdapterType = NotAries;
              returnStatus=FALSE;
              break;
        }

/*** $0010 ***********  adrianc 2/17/1995 ******************************
***   Write the controller and ASIC information to the registry.     ***
***********************************************************************/
       switch (HwDeviceExtension->VideoChipInfo.ulControllerType)
         {
           case QRY_CONTROLLER_V32:
               if (HwDeviceExtension->VideoChipInfo.ulDACType == QRY_DAC_BT484)
                 {
                     pwszAdapterString = L"QVision 1024 Enhanced";
                     cbAdapterString = sizeof(L"QVision 1024 Enhanced");
                 } // if
               else
                 {
                     pwszAdapterString = L"QVision 1280";
                     cbAdapterString = sizeof(L"QVision 1280");
                 } // else
               break;

           case QRY_CONTROLLER_V35:         // QVision 1280/1024 - new ASIC
               pwszAdapterString = L"QVision 1280";
               cbAdapterString = sizeof(L"QVision 1280");
               break;
           case QRY_CONTROLLER_V64:
               pwszAdapterString = L"QVision 1280/P";
               cbAdapterString = sizeof(L"QVision 1280/P");
               break;
           default:
               pwszAdapterString = QV_NEW;
               cbAdapterString = sizeof(QV_NEW);
            break;
         } // switch

      VideoPortSetRegistryParameters(HwDeviceExtension,
                                     L"HardwareInformation.AdapterString",
                                     pwszAdapterString,
                                     cbAdapterString);

      switch (HwDeviceExtension->VideoChipInfo.ulDACType)
         {
         case QRY_DAC_BT471:
                 pwszDAC = L"Brooktree Bt471";
                 cbDAC   = sizeof(L"Brooktree Bt471");
                 break;
         case QRY_DAC_BT477:
                 pwszDAC = L"Brooktree Bt477";
                 cbDAC   = sizeof(L"Brooktree Bt477");
                 break;
         case QRY_DAC_BT476:
                 pwszDAC = L"Brooktree Bt476";
                 cbDAC   = sizeof(L"Brooktree Bt476");
                 break;
         case QRY_DAC_BT484:
                 pwszDAC = L"Brooktree Bt484";
                 cbDAC   = sizeof(L"Brooktree Bt484");
                 break;
         case QRY_DAC_BT485:
                 pwszDAC = L"Brooktree Bt485";
                 cbDAC   = sizeof(L"Brooktree Bt485");
                 break;

         case QRY_DAC_UNKNOWN:
         default:
                 pwszDAC = L"Unknown";
                 cbDAC   = sizeof(L"Unknown");
                 break;
         } // switch

      switch (HwDeviceExtension->VideoChipInfo.ulControllerType)
         {
         case QRY_CONTROLLER_VICTORY:
            pwszChip = TRITON;
            cbChip = sizeof(TRITON);
            break;
         case QRY_CONTROLLER_V32:
            pwszChip = ORION;
            cbChip = sizeof(ORION);
            break;
         case QRY_CONTROLLER_V35:
            pwszChip = ARIEL;
            cbChip = sizeof(ARIEL);
            break;
         case QRY_CONTROLLER_V64:
            pwszChip = OBERON;
            cbChip = sizeof(OBERON);
            break;
         default:
            pwszChip = QV_NEW;
            cbChip = sizeof(QV_NEW);
            break;
         } // switch


      VideoPortSetRegistryParameters(HwDeviceExtension,
                                  L"HardwareInformation.ChipType",
                                  pwszChip,
                                  cbChip);

      VideoPortSetRegistryParameters(HwDeviceExtension,
                                     L"HardwareInformation.DacType",
                                     pwszDAC,
                                     cbDAC);

//*** END $0010 *********************************************************

    }

    return returnStatus;

} // VgaIsPresent()

//---------------------------------------------------------------------------
VP_STATUS
VgaSetPaletteReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_PALETTE_DATA PaletteBuffer,
    ULONG PaletteBufferSize
    )

/*++

Routine Description:

    This routine sets a specified portion of the EGA (not DAC) palette
    registers.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    PaletteBuffer - Pointer to the structure containing the palette data.

    PaletteBufferSize - Length of the input buffer supplied by the user.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data.

    ERROR_INVALID_PARAMETER - invalid palette size.

--*/

{
    USHORT i;

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    VideoDebugPrint((1,"QVision.sys: VgaSetPaletteRegs.\n"));

    if ((PaletteBufferSize) < (sizeof(VIDEO_PALETTE_DATA)) ||
        (PaletteBufferSize < (sizeof(VIDEO_PALETTE_DATA) +
                (sizeof(USHORT) * (PaletteBuffer->NumEntries -1)) ))) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check to see if the parameters are valid.
    //

    if ( (PaletteBuffer->FirstEntry > VIDEO_MAX_COLOR_REGISTER ) ||
         (PaletteBuffer->NumEntries == 0) ||
         (PaletteBuffer->FirstEntry + PaletteBuffer->NumEntries >
             VIDEO_MAX_PALETTE_REGISTER + 1 ) ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Reset ATC to index mode
    //

    VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                           ATT_INITIALIZE_PORT_COLOR);

    //
    // Blast out our palette values.
    //

    for (i = 0; i < PaletteBuffer->NumEntries; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ATT_ADDRESS_PORT,
                                (UCHAR)(i+PaletteBuffer->FirstEntry));

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    ATT_DATA_WRITE_PORT,
                                (UCHAR)PaletteBuffer->Colors[i]);
    }

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ATT_ADDRESS_PORT,
                            VIDEO_ENABLE);

    return NO_ERROR;

} // end VgaSetPaletteReg()


//---------------------------------------------------------------------------
VP_STATUS
VgaSetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    )

/*++

Routine Description:

    This routine sets a specified portion of the DAC color lookup table
    settings.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ClutBufferSize - Length of the input buffer supplied by the user.

    ClutBuffer - Pointer to the structure containing the color lookup table.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data.

    ERROR_INVALID_PARAMETER - invalid clut size.

--*/

{
    ULONG i;

    VideoDebugPrint((1,"QVision.sys: VgaSetColorLookup.\n"));

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if ( (ClutBufferSize < sizeof(VIDEO_CLUT) - sizeof(ULONG)) ||
         (ClutBufferSize < sizeof(VIDEO_CLUT) +
                     (sizeof(ULONG) * (ClutBuffer->NumEntries - 1)) ) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check to see if the parameters are valid.
    //

    if ( (ClutBuffer->NumEntries == 0) ||
         (ClutBuffer->FirstEntry > VIDEO_MAX_COLOR_REGISTER) ||
         (ClutBuffer->FirstEntry + ClutBuffer->NumEntries >
             VIDEO_MAX_COLOR_REGISTER + 1) ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    //  Set CLUT registers directly on the hardware
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_ADDRESS_WRITE_PORT,
                            (UCHAR) ClutBuffer->FirstEntry);

    for (i = 0; i < ClutBuffer->NumEntries; i++) {

        VideoPortWritePortBufferUchar((PUCHAR)HwDeviceExtension->IOAddress +
                                          DAC_DATA_REG_PORT,
                                      &(ClutBuffer->LookupTable[i].RgbArray.Red),
                                          0x03);

    }

    return NO_ERROR;

} // end VgaSetColorLookup()

//---------------------------------------------------------------------------
VP_STATUS
VgaRestoreHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize
    )

/*++

Routine Description:

    Restores all registers and memory of the VGA.

    Note: HardwareState points to the actual buffer from which the state
    is to be restored. This buffer will always be big enough (we specified
    the required size at DriverEntry).

    Note: The offset in the hardware state header from which each general
    register is restored is the offset of the write address of that register
    from the base I/O address of the VGA.


Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    HardwareState - Pointer to a structure from which the saved state is to be
        restored (actually only info about and a pointer to the actual save
        buffer).

    HardwareStateSize - Length of the input buffer supplied by the user.
        (Actually only the size of the HardwareState structure, not the
        buffer it points to from which the state is actually restored. The
        pointed-to buffer is assumed to be big enough.)

Return Value:

    NO_ERROR - restore performed successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough to provide data

--*/

{
    PVIDEO_HARDWARE_STATE_HEADER hardwareStateHeader;
    ULONG  i;
    UCHAR  dummy;
    PUCHAR pScreen;
    PUCHAR pucLatch;
    PULONG pulBuffer;
    PUCHAR port;
    PUCHAR portValueDAC;
    ULONG  bIsColor=TRUE;


    VideoDebugPrint((1,"QVision.sys: VgaRestoreHardwareState - ENTRY\n"));

    //
    // Check if the size of the data in the input buffer is large enough.
    //
#ifdef QV_EXTENDED_SAVE
    if ((HardwareStateSize < sizeof(VIDEO_HARDWARE_STATE)) ||
        (HardwareState->StateLength < QV_TOTAL_STATE_SIZE)) {
#else
    if ((HardwareStateSize < sizeof(VIDEO_HARDWARE_STATE)) ||
        (HardwareState->StateLength < VGA_TOTAL_STATE_SIZE)) {
#endif
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Point to the buffer where the restore data is actually stored.
    //


    hardwareStateHeader = HardwareState->StateHeader;

    VideoDebugPrint((1,"RESTOREHARDWARE Entry ==> Checking EXT values...\n"));
    VideoDebugPrint((1,"\thardwareStateHeader->ExtendedSequencerOffset = %lx\n", hardwareStateHeader->ExtendedSequencerOffset ));
    VideoDebugPrint((1,"\thardwareStateHeader->ExtendedCrtContOffset = %lx\n", hardwareStateHeader->ExtendedCrtContOffset ));
    VideoDebugPrint((1,"\thardwareStateHeader->ExtendedGraphContOffset = %lx\n", hardwareStateHeader->ExtendedGraphContOffset ));
    VideoDebugPrint((1,"\thardwareStateHeader->ExtendedAttribContOffset = %lx\n", hardwareStateHeader->ExtendedAttribContOffset ));
    VideoDebugPrint((1,"\thardwareStateHeader->ExtendedDacOffset = %lx\n", hardwareStateHeader->ExtendedDacOffset ));


    //
    // Make sure the offsets are in the structure ...
    //
    if ((hardwareStateHeader->BasicSequencerOffset + VGA_NUM_SEQUENCER_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicCrtContOffset + VGA_NUM_CRTC_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicGraphContOffset + VGA_NUM_GRAPH_CONT_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicAttribContOffset + VGA_NUM_ATTRIB_CONT_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicDacOffset + (3 * VGA_NUM_DAC_ENTRIES) >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicLatchesOffset + 4 >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedSequencerOffset + EXT_NUM_SEQUENCER_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedCrtContOffset + EXT_NUM_CRTC_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedGraphContOffset + EXT_NUM_GRAPH_CONT_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedAttribContOffset + EXT_NUM_ATTRIB_CONT_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedDacOffset + (4 * EXT_NUM_DAC_ENTRIES) >
            HardwareState->StateLength) ||

        //
        // Only check the validator state offset if there is unemulated data.
        //

        ((hardwareStateHeader->VGAStateFlags & VIDEO_STATE_UNEMULATED_VGA_STATE) &&
            (hardwareStateHeader->ExtendedValidatorStateOffset + VGA_VALIDATOR_AREA_SIZE >
            HardwareState->StateLength)) ||

        (hardwareStateHeader->ExtendedMiscDataOffset + VGA_MISC_DATA_AREA_OFFSET >
            HardwareState->StateLength) ||

        (hardwareStateHeader->Plane1Offset + hardwareStateHeader->PlaneLength >
            HardwareState->StateLength) ||

        (hardwareStateHeader->Plane2Offset + hardwareStateHeader->PlaneLength >
            HardwareState->StateLength) ||

        (hardwareStateHeader->Plane3Offset + hardwareStateHeader->PlaneLength >
            HardwareState->StateLength) ||

        (hardwareStateHeader->Plane4Offset + hardwareStateHeader->PlaneLength >
            HardwareState->StateLength) ||

        (hardwareStateHeader->DIBOffset +
            hardwareStateHeader->DIBBitsPerPixel / 8 *
            hardwareStateHeader->DIBXResolution *
            hardwareStateHeader->DIBYResolution  > HardwareState->StateLength) ||

        (hardwareStateHeader->DIBXlatOffset + hardwareStateHeader->DIBXlatLength >
            HardwareState->StateLength)  ||

        //
        //  Make sure we have a properly initialized state header
        //  structure.  These fields should be initialized to valid
        //  offsets for all VGAs including QVision.  If not, then the
        //  VgaSaveHardwareState() function has not been called.
        //

        (hardwareStateHeader->BasicSequencerOffset == 0x0000) ||

        (hardwareStateHeader->BasicCrtContOffset == 0x0000) ||

        (hardwareStateHeader->BasicGraphContOffset == 0x0000) ||

        (hardwareStateHeader->BasicAttribContOffset == 0x0000) ||

        (hardwareStateHeader->BasicDacOffset == 0x0000) ||

        (hardwareStateHeader->BasicLatchesOffset == 0x0000)) {

        return ERROR_INVALID_PARAMETER;

    }

#ifdef  QV_EXTENDED_SAVE
    //
    // Make sure QVision BLT and Line engines are idle before we proceed
    // to modify register states.
    //

    QVUnlockExtRegs(HwDeviceExtension);

    while (VideoPortReadPortUchar((PUCHAR) ARIES_CTL_1) & GLOBAL_BUSY_BIT)
        ;
#endif

    //
    // Turn off the screen to avoid flickering. The screen will turn back on
    // when we restore the DAC state at the end of this routine.
    //
    // Wait for the leading edge of vertical sync, to blank the screen cleanly.
    //

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            MISC_OUTPUT_REG_READ_PORT) & 0x01) {
        port = INPUT_STATUS_1_COLOR + HwDeviceExtension->IOAddress;
    } else {
        port = INPUT_STATUS_1_MONO + HwDeviceExtension->IOAddress;
    }


//    while (VideoPortReadPortUchar(port) & 0x08)
//            ;   // wait for not vertical sync

//    while (!(VideoPortReadPortUchar(port) & 0x08))
//            ;   // wait for vertical sync

    //
    // Set DAC register 0 to display black.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_ADDRESS_WRITE_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);

    // Set the DAC mask register to force DAC register 0 to display all the
    // time (this is the register we just set to display black). From now on,
    // nothing but black will show up on the screen.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_PIXEL_MASK_PORT, 0);

#ifdef  QV_EXTENDED_SAVE

    VideoDebugPrint((1,"\tDoing QVisionLocalRestoreHardwareState.\n"));

    //
    // Restore the QVision extended registers
    //
    if ((hardwareStateHeader->ExtendedGraphContOffset == 0x0000) ||

        (hardwareStateHeader->ExtendedCrtContOffset == 0x0000) ||

        (hardwareStateHeader->ExtendedDacOffset == 0x0000))

         ;
    else

        QVLocalRestoreHardwareState(HwDeviceExtension, hardwareStateHeader);

#endif

    //
    // Restore the standard VGA registers both before and after
    // restoring the frame buffer.
    //

    VgaStandardRegsRestore(HwDeviceExtension,hardwareStateHeader);

    //
    // Restore the latches and the contents of display memory.
    //
    // Set up the VGA's hardware to allow us to copy to each plane in turn.
    //
    // Begin sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Turn off Chain mode and map display memory at A0000 for 64K.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_GRAPH_MISC);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, (UCHAR) ((VideoPortReadPortUchar(
            HwDeviceExtension->IOAddress + GRAPH_DATA_PORT) & 0xF1) | 0x04));

    //
    // Turn off Chain4 mode and odd/even.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT) & 0xF3) | 0x04));

    //
    // End sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT), (USHORT) (IND_SYNC_RESET +
            (END_SYNC_RESET_VALUE << 8)));

    //
    // Set the write mode to 0, the read mode to 0, and turn off odd/even.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_GRAPH_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT) & 0xE4) | 0x00));

    //
    // Set the Bit Mask to 0xFF to allow all CPU bits through.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), (USHORT) (IND_BIT_MASK + (0xFF << 8)));

    //
    // Set the Data Rotation and Logical Function fields to 0 to allow CPU
    // data through unmodified.
    //

    VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), (USHORT) (IND_DATA_ROTATE + (0 << 8)));

    //
    // Set Set/Reset Enable to 0 to select CPU data for all planes.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), (USHORT) (IND_SET_RESET_ENABLE + (0 << 8)));

    //
    // Point the Sequencer Index to the Map Mask register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
             SEQ_ADDRESS_PORT, IND_MAP_MASK);

    //
    // Restore the latches.
    //
    // Point to the saved data for the first latch.
    //

    pucLatch = ((PUCHAR) (hardwareStateHeader)) +
            hardwareStateHeader->BasicLatchesOffset;

    //
    // Point to first byte of display memory.
    //

    VideoDebugPrint((1, "\tVgaRestoreHardware - restore frame buffer\n"));

    pScreen = (PUCHAR) HwDeviceExtension->VideoMemoryAddress;

    //
    // Write the contents to be restored to each of the four latches in turn.
    //

    for (i = 0; i < 4; i++) {

        //
        // Set the Map Mask to select the plane we want to restore next.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, (UCHAR)(1<<i));
        //
        // Write this plane's latch.
        //

        //
        // 05/17/94 - MikeD - The following line *must* be commented out
        // to work around a critical error that is happening on ProLiant
        // 2000 systems with a QVision controller.  The problem is that
        // immediately following this loop, the dummy read to set the
        // latches causes an NMI and the QVision board to lock up. This
        // is only happening on ProLiant 2000/4000 systems.  The problem
        // with this work-around is that the plane latches are not restored
        // properly, however this is probably better than a system crash
        // For more information, refer to Compaq PET # 41959

        VideoPortWriteRegisterUchar(pScreen, *pucLatch++);

    }

    //
    // Read the latched data into the latches, and the latches are set.
    //

    dummy = VideoPortReadRegisterUchar(pScreen);

//#ifdef QV_EXTENDED_SAVE
//    //
//    // Restore QVision frame buffer memory - this code not implemented
//    //
//    VideoDebugPrint((3,"\tDoing QVision restore video memory.\n"));
//
//    QVSaveRestoreVideoMemory(HwDeviceExtension, hardwareStateHeader,
//                             QV_RESTORE_FRAME_BUFFER);
//
//#else
    //
    // Point to the offset of the saved data for the first plane.
    //
    VideoDebugPrint((1,"\tDoing standard restore video memory\n"));

    pulBuffer = &(hardwareStateHeader->Plane1Offset);


    //
    // Restore each of the four planes in turn.
    //

    for (i = 0; i < 4; i++) {
        VideoDebugPrint((1,"\tPlane %d offset = %lx  video memory\n"));

        //
        // Set the Map Mask to select the plane we want to restore next.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, (UCHAR)(1<<i));

        //
        // Restore this plane from the buffer.
        //

        VideoPortMoveMemory((PUCHAR) HwDeviceExtension->VideoMemoryAddress,
                           ((PUCHAR) (hardwareStateHeader)) + *pulBuffer,
                           hardwareStateHeader->PlaneLength);

        pulBuffer++;

    }
// #endif


    //
    // Restore the standard VGA registers.
    //

    VgaStandardRegsRestore(HwDeviceExtension,hardwareStateHeader);

    //
    // If we have some unemulated data, put it back into the buffer
    //

    if (hardwareStateHeader->VGAStateFlags & VIDEO_STATE_UNEMULATED_VGA_STATE) {

        if (!hardwareStateHeader->ExtendedValidatorStateOffset) {

            return ERROR_INVALID_PARAMETER;

        }

        //
        // Get the right offset in the struct and save all the data associated
        // with the trapped validator data.
        //

        VideoPortMoveMemory(&(HwDeviceExtension->TrappedValidatorCount),
                            ((PUCHAR) (hardwareStateHeader)) +
                                hardwareStateHeader->ExtendedValidatorStateOffset,
                            VGA_VALIDATOR_AREA_SIZE);

        //
        // Check to see if this is an appropriate access range.
        // We are trapping - so we must have the trapping access range enabled.
        //

        if (((HwDeviceExtension->CurrentVdmAccessRange != FullQVisionValidatorAccessRange) ||
             (HwDeviceExtension->CurrentNumVdmAccessRanges != NUM_FULL_QVISION_VALIDATOR_ACCESS_RANGE)) &&
            ((HwDeviceExtension->CurrentVdmAccessRange != MinimalQVisionValidatorAccessRange) ||
             (HwDeviceExtension->CurrentNumVdmAccessRanges != NUM_MINIMAL_QVISION_VALIDATOR_ACCESS_RANGE))) {

            return ERROR_INVALID_PARAMETER;

        }

    } else {

        HwDeviceExtension->TrappedValidatorCount = 0;
        HwDeviceExtension->SequencerAddressValue = 0;

        HwDeviceExtension->CurrentNumVdmAccessRanges =
            NUM_MINIMAL_QVISION_VALIDATOR_ACCESS_RANGE;
        HwDeviceExtension->CurrentVdmAccessRange =
            MinimalQVisionValidatorAccessRange;

    }

    VideoPortSetTrappedEmulatorPorts(HwDeviceExtension,
                                     HwDeviceExtension->CurrentNumVdmAccessRanges,
                                     HwDeviceExtension->CurrentVdmAccessRange);

    //
    // Restore DAC registers 1 through 255. We'll do register 0, the DAC Mask,
    // and the index registers later.
    //
    // Wait for the leading edge of vertical sync, so we can read out the DAC
    // registers without causing sparkles on the screen.
    //

    if (bIsColor) {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_COLOR;
    } else {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_MONO;
    }

//    while (VideoPortReadPortUchar(port) & 0x08)
//            ;   // wait for not vertical sync

//    while (!(VideoPortReadPortUchar(port) & 0x08))
//            ;   // wait for vertical sync

    //
    // Set the Write Index to one, to write to DAC register 1 first (we'll do
    // register 0 later), then read out the 255 DAC registers other than
    // register 0. Each successive three writes set Red, Green, and Blue
    // components for that register, then the index autoincrements.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_ADDRESS_WRITE_PORT, 1);
    VideoPortWritePortBufferUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicDacOffset + 3,
            (VGA_NUM_DAC_ENTRIES - 1) * 3);


    //
    // Restore the Feature Control register.
    //

    if (bIsColor) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                FEAT_CTRL_WRITE_PORT_COLOR,
                hardwareStateHeader->PortValue[FEAT_CTRL_WRITE_PORT_COLOR]);

    } else {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                FEAT_CTRL_WRITE_PORT_MONO,
                hardwareStateHeader->PortValue[FEAT_CTRL_WRITE_PORT_MONO]);

    }

    //
    // Restore the Sequencer Index.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT,
            hardwareStateHeader->PortValue[SEQ_ADDRESS_PORT]);

    //
    // Restore the CRT Controller Index.
    //

    if (bIsColor) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_COLOR,
                hardwareStateHeader->PortValue[CRTC_ADDRESS_PORT_COLOR]);

    } else {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_MONO,
                hardwareStateHeader->PortValue[CRTC_ADDRESS_PORT_MONO]);

    }


    //
    // Restore the Graphics Controller Index.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT,
            hardwareStateHeader->PortValue[GRAPH_ADDRESS_PORT]);


    //
    // Restore the Attribute Controller Index and index/data toggle state.
    //

    if (bIsColor) {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_COLOR;
    } else {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_MONO;
    }

    VideoPortReadPortUchar(port);  // reset the toggle to Index state

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            ATT_ADDRESS_PORT,  // restore the AC Index
            hardwareStateHeader->PortValue[ATT_ADDRESS_PORT]);

    //
    // If the toggle should be in Data state, we're all set. If it should be in
    // Index state, reset it to that condition.
    //

    if (hardwareStateHeader->AttribIndexDataState == 0) {

        //
        // Reset the toggle to Index state.
        //

        VideoPortReadPortUchar(port);

    }


    //
    // Restore DAC register 0 and the DAC Mask, to unblank the screen.
    //

    portValueDAC = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicDacOffset;

    //
    // Restore the DAC Mask register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_PIXEL_MASK_PORT,
            hardwareStateHeader->PortValue[DAC_PIXEL_MASK_PORT]);

    //
    // Restore DAC register 0.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_ADDRESS_WRITE_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, *portValueDAC++);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, *portValueDAC++);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, *portValueDAC++);


    //
    // Restore the read/write state and the current index of the DAC.
    //
    // See whether the Read or Write Index was written to most recently.
    // (The upper nibble stored at DAC_STATE_PORT is the # of reads/writes
    // for the current index.)
    //

    if ((hardwareStateHeader->PortValue[DAC_STATE_PORT] & 0x0F) == 3) {

        //
        // The DAC Read Index was written to last. Restore the DAC by setting
        // up to read from the saved index - 1, because the way the Read
        // Index works is that it autoincrements after reading, so you actually
        // end up reading the data for the index you read at the DAC Write
        // Mask register - 1.
        //
        // Set the Read Index to the index we read, minus 1, accounting for
        // wrap from 255 back to 0. The DAC hardware immediately reads this
        // register into a temporary buffer, then adds 1 to the index.
        //

        if (hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT] == 0) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_READ_PORT, 255);

        } else {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_READ_PORT, (UCHAR)
                    (hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT] -
                    1));

        }

        //
        // Now read the hardware however many times are required to get to
        // the partial read state we saved.
        //

        for (i = hardwareStateHeader->PortValue[DAC_STATE_PORT] >> 4;
                i > 0; i--) {

            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_DATA_REG_PORT);

        }

    } else {

        //
        // The DAC Write Index was written to last. Set the Write Index to the
        // index value we read out of the DAC. Then, if a partial write
        // (partway through an RGB triplet) was in place, write the partial
        // values, which we obtained by writing them to the current DAC
        // register. This DAC register will be wrong until the write is
        // completed, but at least the values will be right once the write is
        // finished, and most importantly we won't have messed up the sequence
        // of RGB writes (which can be as long as 768 in a row).
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                DAC_ADDRESS_WRITE_PORT,
                hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT]);

        //
        // Now write to the hardware however many times are required to get to
        // the partial write state we saved (if any).
        //
        // Point to the saved value for the DAC register that was in the
        // process of being written to; we wrote the partial value out, so now
        // we can restore it.
        //

        portValueDAC = (PUCHAR) hardwareStateHeader +
                hardwareStateHeader->BasicDacOffset +
                (hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT] * 3);

        for (i = hardwareStateHeader->PortValue[DAC_STATE_PORT] >> 4;
                i > 0; i--) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_DATA_REG_PORT, *portValueDAC++);

        }

    }
    VideoDebugPrint((1,"QVision.sys: VgaRestoreHardwareState - EXIT\n"));

    VideoDebugPrint((1,"RESTOREHARDWARE Exit ==> Checking EXT values...\n"));
    VideoDebugPrint((1,"\thardwareStateHeader->ExtendedSequencerOffset = %lx\n", hardwareStateHeader->ExtendedSequencerOffset ));
    VideoDebugPrint((1,"\thardwareStateHeader->ExtendedCrtContOffset = %lx\n", hardwareStateHeader->ExtendedCrtContOffset ));
    VideoDebugPrint((1,"\thardwareStateHeader->ExtendedGraphContOffset = %lx\n", hardwareStateHeader->ExtendedGraphContOffset ));
    VideoDebugPrint((1,"\thardwareStateHeader->ExtendedAttribContOffset = %lx\n", hardwareStateHeader->ExtendedAttribContOffset ));
    VideoDebugPrint((1,"\thardwareStateHeader->ExtendedDacOffset = %lx\n", hardwareStateHeader->ExtendedDacOffset ));

    return NO_ERROR;

} // end VgaRestoreHardwareState()

//---------------------------------------------------------------------------
VP_STATUS
VgaSaveHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    Saves all registers and memory of the VGA.

    Note: HardwareState points to the actual buffer in which the state
    is saved. This buffer will always be big enough (we specified
    the required size at DriverEntry).

    Note: This routine leaves registers in any state it cares to, except
    that it will not mess with any of the CRT or Sequencer parameters that
    might make the monitor unhappy. It leaves the screen blanked by setting
    the DAC Mask and DAC register 0 to all zero values. The next video
    operation we expect after this is a mode set to take us back to Win32.

    Note: The offset in the hardware state header in which each general
    register is saved is the offset of the write address of that register from
    the base I/O address of the VGA.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    HardwareState - Pointer to a structure in which the saved state will be
        returned (actually only info about and a pointer to the actual save
        buffer).

    HardwareStateSize - Length of the output buffer supplied by the user.
        (Actually only the size of the HardwareState structure, not the
        buffer it points to where the state is actually saved. The pointed-
        to buffer is assumed to be big enough.)

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data returned in the buffer.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - output buffer not large enough to return
        any useful data

--*/

{
    PVIDEO_HARDWARE_STATE_HEADER hardwareStateHeader;
    PUCHAR port;
    PUCHAR pScreen;
    PUCHAR portValue;
    PUCHAR portValueDAC;
    PUCHAR bufferPointer;
    ULONG  i;
    UCHAR  dummy, originalACIndex, originalACData;
    UCHAR  ucCRTC03;
    ULONG  bIsColor;

    VideoDebugPrint((1,"QVision.sys: VgaSaveHardwareState - ENTRY\n"));

    //
    // See if the buffer is big enough to hold the hardware state structure.
    // (This is only the HardwareState structure itself, not the buffer it
    // points to.)
    //

    if (HardwareStateSize < sizeof(VIDEO_HARDWARE_STATE) ) {

        *OutputSize = 0;  // nothing returned
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Amount of data we're going to return in the output buffer.
    // (The VIDEO_HARDWARE_STATE in the output buffer points to the actual
    // buffer in which the state is stored, which is assumed to be large
    // enough.)
    //

    *OutputSize = sizeof(VIDEO_HARDWARE_STATE);

    //
    // Indicate the size of the full state save info.
    //

#ifdef  QV_EXTENDED_SAVE
    HardwareState->StateLength = QV_TOTAL_STATE_SIZE;
#else
    HardwareState->StateLength = VGA_TOTAL_STATE_SIZE;
#endif

    //
    // hardwareStateHeader is a structure of offsets at the start of the
    // actual save area that indicates the locations in which various VGA
    // register and memory components are saved.
    //

    hardwareStateHeader = HardwareState->StateHeader;

    //
    // Zero out the structure.
    //

    VideoPortZeroMemory(hardwareStateHeader, sizeof(VIDEO_HARDWARE_STATE_HEADER));

    //
    // Set the Length field, which is basically a version ID.
    //

    hardwareStateHeader->Length = sizeof(VIDEO_HARDWARE_STATE_HEADER);

    //
    // Set the basic register offsets properly.
    //

    hardwareStateHeader->BasicSequencerOffset = VGA_BASIC_SEQUENCER_OFFSET;
    hardwareStateHeader->BasicCrtContOffset = VGA_BASIC_CRTC_OFFSET;
    hardwareStateHeader->BasicGraphContOffset = VGA_BASIC_GRAPH_CONT_OFFSET;
    hardwareStateHeader->BasicAttribContOffset = VGA_BASIC_ATTRIB_CONT_OFFSET;
    hardwareStateHeader->BasicDacOffset = VGA_BASIC_DAC_OFFSET;
    hardwareStateHeader->BasicLatchesOffset = VGA_BASIC_LATCHES_OFFSET;

    //
    // Set the extended register offsets properly.
    //
    // All QVision misc. extended registers are kept
    // in the extended crt regs save area
    //
    hardwareStateHeader->ExtendedSequencerOffset = VGA_EXT_SEQUENCER_OFFSET;
    hardwareStateHeader->ExtendedCrtContOffset = VGA_EXT_CRTC_OFFSET;
    hardwareStateHeader->ExtendedGraphContOffset = VGA_EXT_GRAPH_CONT_OFFSET;
    hardwareStateHeader->ExtendedAttribContOffset = VGA_EXT_ATTRIB_CONT_OFFSET;
    hardwareStateHeader->ExtendedDacOffset = VGA_EXT_DAC_OFFSET;


    VideoDebugPrint((1,"SAVEHARDWARE Entry ==> Initializing EXT values...\n"));
    VideoDebugPrint((1,"\thardwareStateHeader->ExtendedSequencerOffset = %lx\n", hardwareStateHeader->ExtendedSequencerOffset ));
    VideoDebugPrint((1,"\thardwareStateHeader->ExtendedCrtContOffset = %lx\n", hardwareStateHeader->ExtendedCrtContOffset ));
    VideoDebugPrint((1,"\thardwareStateHeader->ExtendedGraphContOffset = %lx\n", hardwareStateHeader->ExtendedGraphContOffset ));
    VideoDebugPrint((1,"\thardwareStateHeader->ExtendedAttribContOffset = %lx\n", hardwareStateHeader->ExtendedAttribContOffset ));
    VideoDebugPrint((1,"\thardwareStateHeader->ExtendedGraphContOffset = %lx\n", hardwareStateHeader->ExtendedDacOffset ));


    //
    // Force the video subsystem enable state to enabled.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            VIDEO_SUBSYSTEM_ENABLE_PORT, 1);

#ifdef  QV_EXTENDED_SAVE

    //
    // Make sure QVision BLT and Line engines are idle before we proceed
    // to modify register states.
    //

    QVUnlockExtRegs(HwDeviceExtension);

    while (VideoPortReadPortUchar((PUCHAR) ARIES_CTL_1) & GLOBAL_BUSY_BIT)
        ;

#endif

    //
    // Figure out if color/mono switchable registers are at 3BX or 3DX.
    // At the same time, save the state of the Miscellaneous Output register
    // which is read from 3CC but written at 3C2.
    //

    if ((hardwareStateHeader->PortValue[MISC_OUTPUT_REG_WRITE_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    MISC_OUTPUT_REG_READ_PORT))
            & 0x01) {
        bIsColor = TRUE;
    } else {
        bIsColor = FALSE;
    }

    // $0007 - MikeD - 04/21/94
    //  Begin: add 10 millisecond delay after r/w
    //         of 3c2
    //
    //         10000microsecs = 10ms
    //
    // I know I should not stall more than 50, but
    // there is no other way around this...

    VideoPortStallExecution( 10000 );

    //
    // Save the DAC state first, so we can set the DAC to blank the screen
    // so nothing after this shows up at all.
    //
    // Save the DAC Mask register.
    //

    hardwareStateHeader->PortValue[DAC_PIXEL_MASK_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_PIXEL_MASK_PORT);

    //
    // Save the DAC Index register. Note that there is actually only one DAC
    // Index register, which functions as either the Read Index or the Write
    // Index as needed.
    //

    hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_WRITE_PORT);

    //
    // Save the DAC read/write state. We determine if the DAC has been written
    // to or read from at the current index 0, 1, or 2 times (the application
    // is in the middle of reading or writing a DAC register triplet if the
    // count is 1 or 2), and save enough info so we can restore things
    // properly. The only hole is if the application writes to the Write Index,
    // then reads from instead of writes to the Data register, or vice-versa,
    // or if they do a partial read write, then never finish it.
    // This is fairly ridiculous behavior, however, and anyway there's nothing
    // we can do about it.
    //

    hardwareStateHeader->PortValue[DAC_STATE_PORT] =
             VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_STATE_PORT);

    if (hardwareStateHeader->PortValue[DAC_STATE_PORT] == 3) {

        //
        // The DAC Read Index was written to last. Figure out how many reads
        // have been done from the current index. We'll restart this on restore
        // by setting the Read Index to the current index - 1 (the read index
        // is one greater than the index being read), then doing the proper
        // number of reads.
        //
        // Read the Data register once, and see if the index changes.
        //

        dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                DAC_DATA_REG_PORT);

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_WRITE_PORT) !=
                hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT]) {

            //
            // The DAC Index changed, so two reads had already been done from
            // the current index. Store the count "2" in the upper nibble of
            // the read/write state field.
            //

            hardwareStateHeader->PortValue[DAC_STATE_PORT] |= 0x20;

        } else {

            //
            // Read the Data register again, and see if the index changes.
            //

            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_DATA_REG_PORT);

            if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        DAC_ADDRESS_WRITE_PORT) !=
                    hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT]) {

                //
                // The DAC Index changed, so one read had already been done
                // from the current index. Store the count "1" in the upper
                // nibble of the read/write state field.
                //

                hardwareStateHeader->PortValue[DAC_STATE_PORT] |= 0x10;
            }

            //
            // If neither 2 nor 1 reads had been done from the current index,
            // then 0 reads were done, and we're all set, since the upper
            // nibble of the read/write state field is already 0.
            //

        }

    } else {

        //
        // The DAC Write Index was written to last. Figure out how many writes
        // have been done to the current index. We'll restart this on restore
        // by setting the Write Index to the proper index, then doing the
        // proper number of writes. When we do the DAC register save, we'll
        // read out the value that gets written (if there was a partial write
        // in progress), so we can restore the proper data later. This will
        // cause this current DAC location to be briefly wrong in the 1- and
        // 2-bytes-written case (until the app finishes the write), but that's
        // better than having the wrong DAC values written for good.
        //
        // Write the Data register once, and see if the index changes.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                DAC_DATA_REG_PORT, 0);

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_WRITE_PORT) !=
                hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT]) {

            //
            // The DAC Index changed, so two writes had already been done to
            // the current index. Store the count "2" in the upper nibble of
            // the read/write state field.
            //

            hardwareStateHeader->PortValue[DAC_STATE_PORT] |= 0x20;

        } else {

            //
            // Write the Data register again, and see if the index changes.
            //

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_DATA_REG_PORT, 0);

            if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        DAC_ADDRESS_WRITE_PORT) !=
                    hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT]) {

                //
                // The DAC Index changed, so one write had already been done
                // to the current index. Store the count "1" in the upper
                // nibble of the read/write state field.
                //

                hardwareStateHeader->PortValue[DAC_STATE_PORT] |= 0x10;
            }

            //
            // If neither 2 nor 1 writes had been done to the current index,
            // then 0 writes were done, and we're all set.
            //

        }

    }


    //
    // Now, read out the 256 18-bit DAC palette registers (256 RGB triplets),
    // and blank the screen.
    //

    portValueDAC = (PUCHAR) hardwareStateHeader + VGA_BASIC_DAC_OFFSET;

    //
    // Read out DAC register 0, so we can set it to black.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                DAC_ADDRESS_READ_PORT, 0);
    *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT);
    *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT);
    *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT);

    //
    // Set DAC register 0 to display black.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_ADDRESS_WRITE_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);

    //
    // Set the DAC mask register to force DAC register 0 to display all the
    // time (this is the register we just set to display black). From now on,
    // nothing but black will show up on the screen.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_PIXEL_MASK_PORT, 0);

    //
    // Wait until we've gotten the Attribute Controller toggle state to save
    // the rest of the DAC registers, so we can wait for vertical sync.
    //


    //
    // Read out the Attribute Controller Index state, and deduce the Index/Data
    // toggle state at the same time.
    //
    // Save the state of the Attribute Controller, both Index and Data,
    // so we can test in which state the toggle currently is.
    //

    originalACIndex = hardwareStateHeader->PortValue[ATT_ADDRESS_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    ATT_ADDRESS_PORT);
    originalACData = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            ATT_DATA_READ_PORT);

#ifdef QV_EXTENDED_SAVE

    VideoDebugPrint((3,"\tDoing QVLocalSaveHardwareState\n"));

    //
    // Since some of the QVision extended registers are cleared
    // by a sync reset, save all extended regs now before the
    // syc reset.
    //

    QVLocalSaveHardwareState(HwDeviceExtension, hardwareStateHeader);

#endif


    //
    // Sequencer Index.
    //

    hardwareStateHeader->PortValue[SEQ_ADDRESS_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    SEQ_ADDRESS_PORT);

    //
    // Begin sync reset, just in case this is an SVGA and the currently
    // indexed Attribute Controller register controls clocking stuff (a
    // normal VGA won't require this).
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Now, write a different Index setting to the Attribute Controller, and
    // see if the Index changes.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            ATT_ADDRESS_PORT, (UCHAR) (originalACIndex ^ 0x10));

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT) == originalACIndex) {

        //
        // The Index didn't change, so the toggle was in the Data state.
        //

        hardwareStateHeader->AttribIndexDataState = 1;

        //
        // Restore the original Data state; we just corrupted it, and we need
        // to read it out later; also, it may glitch the screen if not
        // corrected. The toggle is already in the Index state.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT, originalACIndex);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_DATA_WRITE_PORT, originalACData);

    } else {

        //
        // The Index did change, so the toggle was in the Index state.
        // No need to restore anything, because the Data register didn't
        // change, and we've already read out the Index register.
        //

        hardwareStateHeader->AttribIndexDataState = 0;

    }

    //
    // End sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));


    //
    // Save the rest of the DAC registers.
    //
    // Wait for the leading edge of vertical sync, so we can read out the DAC
    // registers without causing sparkles on the screen.
    //

    if (bIsColor) {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_COLOR;
    } else {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_MONO;
    }

//    while (VideoPortReadPortUchar(port) & 0x08)
//            ;   // wait for not vertical sync

//    while (!(VideoPortReadPortUchar(port) & 0x08))
//            ;   // wait for vertical sync

    //
    // Set the Read Index to one, to read DAC register 1 first (we already read
    // register 0), then read out the other 255 DAC registers. Each successive
    // three reads get Red, Green, and Blue components for that register, then
    // the index autoincrements.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_ADDRESS_READ_PORT, 1);

    VideoPortReadPortBufferUchar((PUCHAR) HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, portValueDAC, (VGA_NUM_DAC_ENTRIES - 1) * 3);


    //
    // The Feature Control register is read from 3CA but written at 3BA/3DA.
    //

    if (bIsColor) {

        hardwareStateHeader->PortValue[FEAT_CTRL_WRITE_PORT_COLOR] =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        FEAT_CTRL_READ_PORT);

    } else {

        hardwareStateHeader->PortValue[FEAT_CTRL_WRITE_PORT_MONO] =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        FEAT_CTRL_READ_PORT);

    }


    //
    // CRT Controller Index.
    //

    if (bIsColor) {

        hardwareStateHeader->PortValue[CRTC_ADDRESS_PORT_COLOR] =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        CRTC_ADDRESS_PORT_COLOR);

    } else {

        hardwareStateHeader->PortValue[CRTC_ADDRESS_PORT_MONO] =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        CRTC_ADDRESS_PORT_MONO);

    }


    //
    // Graphics Controller Index.
    //

    hardwareStateHeader->PortValue[GRAPH_ADDRESS_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_ADDRESS_PORT);


    //
    // Sequencer indexed registers.
    //

    portValue = ((PUCHAR) hardwareStateHeader) + VGA_BASIC_SEQUENCER_OFFSET;

    for (i = 0; i < VGA_NUM_SEQUENCER_PORTS; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT, (UCHAR) i);
        *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT);

    }

    //
    // CRT Controller indexed registers.
    //

    //
    // Remember the state of CRTC register 3, then force bit 7
    // to 1 so we will read back the Vertical Retrace start and
    // end registers rather than the light pen info.
    //

    if (bIsColor) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_COLOR, 3);
        ucCRTC03 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        CRTC_DATA_PORT_COLOR);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    CRTC_DATA_PORT_COLOR, (UCHAR) (ucCRTC03 | 0x80));
    } else {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_MONO, 3);
        ucCRTC03 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        CRTC_DATA_PORT_MONO);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_DATA_PORT_MONO, (UCHAR) (ucCRTC03 | 0x80));
    }

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_CRTC_OFFSET;

    for (i = 0; i < VGA_NUM_CRTC_PORTS; i++) {

        if (bIsColor) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_COLOR, (UCHAR) i);
            *portValue++ =
                    VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                            CRTC_DATA_PORT_COLOR);
        }
        else {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_MONO, (UCHAR) i);
            *portValue++ =
                    VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                            CRTC_DATA_PORT_MONO);
        }

    }

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_CRTC_OFFSET;
    portValue[3] = ucCRTC03;


    //
    // Graphics Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_GRAPH_CONT_OFFSET;

    for (i = 0; i < VGA_NUM_GRAPH_CONT_PORTS; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT, (UCHAR) i);
        *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT);

    }

    //
    // Attribute Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_ATTRIB_CONT_OFFSET;

    //
    // For each indexed AC register, reset the flip-flop for reading the
    // attribute register, then write the desired index to the AC Index,
    // then read the value of the indexed register from the AC Data register.
    //

    for (i = 0; i < VGA_NUM_ATTRIB_CONT_PORTS; i++) {

        if (bIsColor) {
            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    INPUT_STATUS_1_COLOR);
        } else {
            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    INPUT_STATUS_1_MONO);
        }

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT, (UCHAR) i);
        *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                ATT_DATA_READ_PORT);

    }

    //
    // Save the latches. This destroys one byte of display memory in each
    // plane, which is unfortunate but unavoidable. Chips that provide
    // a way to read back the latches can avoid this problem.
    //
    // Set up the VGA's hardware so we can write the latches, then read them
    // back.
    //

    //
    // Begin sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Set the Miscellaneous register to make sure we can access video RAM.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            MISC_OUTPUT_REG_WRITE_PORT, (UCHAR)(
            hardwareStateHeader->PortValue[MISC_OUTPUT_REG_WRITE_PORT] |
            0x02));

    // $0007 - MikeD - 04/21/94
    //  Begin: add 10 millisecond delay after r/w
    //         of 3c2
    //
    //         10000microsecs = 10ms
    //
    // I know I should not stall more than 50, but
    // there is no other way around this...

    VideoPortStallExecution( 10000 );

    //
    // Turn off Chain mode and map display memory at A0000 for 64K.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_GRAPH_MISC);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT) & 0xF1) | 0x04));

    //
    // Turn off Chain4 mode and odd/even.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT) & 0xF3) | 0x04));

    //
    // End sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));

    //
    // Set the Map Mask to write to all planes.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT), (USHORT) (IND_MAP_MASK + (0x0F << 8)));

    //
    // Set the write mode to 0, the read mode to 0, and turn off odd/even.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_GRAPH_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT) & 0xE4) | 0x01));

    //
    // Point to the last byte of display memory.
    //

    pScreen = (PUCHAR) HwDeviceExtension->VideoMemoryAddress +
            VGA_PLANE_SIZE - 1;

    //
    // Write the latches to the last byte of display memory.
    //

    VideoPortWriteRegisterUchar(pScreen, 0);

    //
    // Cycle through the four planes, reading the latch data from each plane.
    //

    //
    // Point the Graphics Controller Index to the Read Map register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_LATCHES_OFFSET;

    for (i=0; i<4; i++) {

        //
        // Set the Read Map for the current plane.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, (UCHAR) i);

        //
        // Read the latched data we've written to memory.
        //

        *portValue++ = VideoPortReadRegisterUchar(pScreen);

    }

    //
    // Set the VDM flags
    // We are a standard VGA, and then check if we have unemulated state.
    //

    hardwareStateHeader->VGAStateFlags = 0;

    if (HwDeviceExtension->TrappedValidatorCount) {

        hardwareStateHeader->VGAStateFlags |= VIDEO_STATE_UNEMULATED_VGA_STATE;

        //
        // Save the VDM Emulator data
        // No need to save the state of the seuencer port register for our
        // emulated data since it may change when we come back. It will be
        // recomputed.
        //

        hardwareStateHeader->ExtendedValidatorStateOffset = VGA_VALIDATOR_OFFSET;

        VideoPortMoveMemory(((PUCHAR) (hardwareStateHeader)) +
                                hardwareStateHeader->ExtendedValidatorStateOffset,
                            &(HwDeviceExtension->TrappedValidatorCount),
                            VGA_VALIDATOR_AREA_SIZE);

    } else {

        hardwareStateHeader->ExtendedValidatorStateOffset = 0;

    }

    //
    // Set the size of each plane.
    //

    hardwareStateHeader->PlaneLength = VGA_PLANE_SIZE;

    //
    // Store all the offsets for the planes in the structure.
    //

    hardwareStateHeader->Plane1Offset = VGA_PLANE_0_OFFSET;
    hardwareStateHeader->Plane2Offset = VGA_PLANE_1_OFFSET;
    hardwareStateHeader->Plane3Offset = VGA_PLANE_2_OFFSET;
    hardwareStateHeader->Plane4Offset = VGA_PLANE_3_OFFSET;

    //
    // Now copy the contents of video VRAM into the buffer.
    //

    //
    // Must implement this function to enable DOS apps to run in
    // QVision extended modes.  This will save the entire contents
    // of the 1M or 2M QVision frame buffer.
    //
// #ifdef QV_EXTENDED_SAVE
//
//  VideoDebugPrint((3,"\tDoing QVSaveRestoreVideoMemory\n"));
//  #ifdef QV_DBG
//  DbgBreakPoint();
//  #endif
//
//  QVSaveRestoreVideoMemory(HwDeviceExtension, hardwareStateHeader,
//                             QV_SAVE_FRAME_BUFFER);

// #else

    //
    // The VGA hardware is already set up so that video memory is readable;
    // we already turned off Chain mode, mapped in at A0000, turned off Chain4,
    // turned off odd/even, and set read mode 0 when we saved the latches.
    //
    // Point the Graphics Controller Index to the Read Map register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);

    //
    // Point to the save area for the first plane.
    //

    bufferPointer = ((PUCHAR) (hardwareStateHeader)) +
                     hardwareStateHeader->Plane1Offset;

    //
    // Save the four planes consecutively.
    //

    for (i = 0; i < 4; i++) {

        //
        // Set the Read Map to select the plane we want to save next.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, (UCHAR) i);

        //
        // Copy this plane into the buffer.
        //

        VideoPortMoveMemory(bufferPointer,
                           (PUCHAR) HwDeviceExtension->VideoMemoryAddress,
                           VGA_PLANE_SIZE);
        //
        // Point to the next plane's save area.
        //

        bufferPointer += VGA_PLANE_SIZE;
    }

// #endif


    VideoDebugPrint((1,"SAVEHARDWARE Exit ==> Checking EXT values...\n"));
    VideoDebugPrint((1,"\thardwareStateHeader->ExtendedSequencerOffset = %lx\n", hardwareStateHeader->ExtendedSequencerOffset ));
    VideoDebugPrint((1,"\thardwareStateHeader->ExtendedCrtContOffset = %lx\n", hardwareStateHeader->ExtendedCrtContOffset ));
    VideoDebugPrint((1,"\thardwareStateHeader->ExtendedGraphContOffset = %lx\n", hardwareStateHeader->ExtendedGraphContOffset ));
    VideoDebugPrint((1,"\thardwareStateHeader->ExtendedAttribContOffset = %lx\n", hardwareStateHeader->ExtendedAttribContOffset ));
    VideoDebugPrint((1,"\thardwareStateHeader->ExtendedGraphContOffset = %lx\n", hardwareStateHeader->ExtendedDacOffset ));
    return NO_ERROR;

} // end VgaSaveHardwareState()

//---------------------------------------------------------------------------
VP_STATUS
VgaGetBankSelectCode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_BANK_SELECT BankSelect,
    ULONG BankSelectSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    Returns information needed in order for caller to implement bank
         management.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    BankSelect - Pointer to a VIDEO_BANK_SELECT structure in which the bank
             select data will be returned (output buffer).

    BankSelectSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a variable in which to return the actual size of
        the data returned in the output buffer.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_MORE_DATA - output buffer not large enough to hold all info (but
        Size is returned, so caller can tell how large a buffer to allocate)

    ERROR_INSUFFICIENT_BUFFER - output buffer not large enough to return
        any useful data

    ERROR_INVALID_PARAMETER - invalid video mode selection

--*/

{

/***********************************************************************
***   Since the QVision driver does not support PLANAR_HC            ***
***   modes, all variables which were needed for that                ***
***   mode have been removed.                                        ***
***********************************************************************/
    ULONG codeSize;
    PUCHAR pCodeDest;
    PUCHAR pCodeBank;

    ULONG AdapterType = HwDeviceExtension->VideoHardware.AdapterType;
    PVIDEOMODE pMode = HwDeviceExtension->CurrentMode;

    VideoDebugPrint((1,"QVision.sys: VgaGetBankSelectCode.\n"));

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // The minimum passed buffer size is a VIDEO_BANK_SELECT
    // structure, so that we can return the required size; we can't do
    // anything if we don't have at least that much buffer.
    //

    if (BankSelectSize < sizeof(VIDEO_BANK_SELECT)) {

            return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Determine the banking type, and set whether any banking is actually
    // supported in this mode.
    //

    BankSelect->BankingFlags = 0;
    codeSize = 0;
    pCodeBank = NULL;

    switch(pMode->banktype) {

      case NoBanking:

         VideoDebugPrint((2,"\tNoBanking\n"));
         BankSelect->BankingType = VideoNotBanked;
         BankSelect->Granularity = 0;

         break;

      case PlanarHCBanking:

        VideoDebugPrint((2, "Unsupported planarHC banking\n"));

        //
        // Fall through to NormalBanking...
        //


      case NormalBanking:

        VideoDebugPrint((2,"\tNormalBanking\n"));

        //
        // QVisions support two 32K read/write banks.
        //

        BankSelect->BankingType = VideoBanked2RW;

        //
        //  This will need to change to make the granularity
        //  decision at runtime if we ever implement the
        //  capability to do 64k vs. 32k windows based on
        //  128k video address availability
        //

        BankSelect->Granularity = 0x8000;

        //
        // Return a pointer to the appropriate bank switch code based on
        // the current mode.
        //
        // Aries modes map at 4k address resolution, Orion modes
        // use 16k address resolution.  Address resolution defined
        // in this context refers to the address granularity that
        // can be assigned to a window.  This should not be confused
        // with the window granularity defined in the HW device
        // context.
        //
        // Ex. QVision can have 2, 32k bank windows that support mapping
        // a starting address at a 4k boundary for Aries modes but
        // when running in Orion modes, these same 2, 32k bank windows
        // will support mapping a starting address at a 16k boundary.
        //

        if ((HwDeviceExtension->CurrentMode->hres >= 1280) ||
            (HwDeviceExtension->PhysicalMemoryMappedLength != 0)) {
            VideoDebugPrint((2,"\t 16K banks\n"));

            codeSize = ((ULONG)&QV16kAddrBankSwitchEnd) -
                      ((ULONG)&QV16kAddrBankSwitchStart);

            pCodeBank = &QV16kAddrBankSwitchStart;
        }
        else {
            VideoDebugPrint((2,"\t 4K banks\n"));

            codeSize =  ((ULONG)&QV4kAddrBankSwitchEnd) -
                        ((ULONG)&QV4kAddrPlanarHCBankSwitchStart);

            pCodeBank = &QV4kAddrPlanarHCBankSwitchStart;

        }


        break;
    }

    //
    // Size of banking info.
    //

    BankSelect->Size = sizeof(VIDEO_BANK_SELECT) + codeSize;

    //
    // This serves an a ID for the version of the structure we're using.
    //

    BankSelect->Length = sizeof(VIDEO_BANK_SELECT);

    //
    // If the buffer isn't big enough to hold all info, just return
    // ERROR_MORE_DATA; Size is already set.
    //

    if (BankSelectSize < BankSelect->Size ) {

        //
        // We're returning only the VIDEO_BANK_SELECT structure.
        //

        *OutputSize = sizeof(VIDEO_BANK_SELECT);
        return ERROR_MORE_DATA;
    }

    //
    // There's room enough for everything, so fill in all fields in
    // VIDEO_BANK_SELECT. (All fields are always returned; the caller can
    // just choose to ignore them, based on BankingFlags and BankingType.)
    //

    BankSelect->BitmapWidthInBytes = pMode->wbytes;
    BankSelect->BitmapSize = pMode->sbytes;

    //
    // Copy all banking code into the output buffer.
    //

    pCodeDest = (PUCHAR)BankSelect + sizeof(VIDEO_BANK_SELECT);

    if (pCodeBank != NULL) {

        BankSelect->CodeOffset = pCodeDest - (PUCHAR)BankSelect;

        VideoPortMoveMemory(pCodeDest,
                            pCodeBank,
                            codeSize);

        pCodeDest += codeSize;
    }

    //
    // Number of bytes we're returning is the full banking info size.
    //

    *OutputSize = BankSelect->Size;

    return NO_ERROR;

} // end VgaGetBankSelectCode()

//---------------------------------------------------------------------------
VP_STATUS
VgaValidatorUcharEntry(
    ULONG Context,
    ULONG Port,
    UCHAR AccessMode,
    PUCHAR Data
    )

/*++

Routine Description:

    Entry point into the validator for byte I/O operations.

    The entry point will be called whenever a byte operation was performed
    by a DOS application on one of the specified Video ports. The kernel
    emulator will forward these requests.

Arguments:

    Context - Context value that is passed to each call made to the validator
        function. This is the value the miniport driver specified in the
        MiniportConfigInfo->EmulatorAccessEntriesContext.

    Port - Port on which the operation is to be performed.

    AccessMode - Determines if it is a read or write operation.

    Data - Pointer to a variable containing the data to be written or a
        variable into which the read data should be stored.

Return Value:

    NO_ERROR.

--*/

{

    PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION) Context;
    ULONG endEmulation;
    UCHAR temp;


    VideoDebugPrint((1,"QVision.sys: VgaValidatorUcharEntry.\n"));

    Port -= VGA_BASE_IO_PORT;

    if (hwDeviceExtension->TrappedValidatorCount) {

        //
        // If we are processing a WRITE instruction, then store it in the
        // playback buffer. If the buffer is full, then play it back right
        // away, end sync reset and reinitialize the buffer with a sync
        // reset instruction.
        //
        // If we have a READ, we must flush the buffer (which has the side
        // effect of starting SyncReset), perform the read operation, stop
        // sync reset, and put back a sync reset instruction in the buffer
        // so we can go on appropriately
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscellaneous register is always 0.
            // If it is 1 it could select a non-existent clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                *Data &= 0xF7;

            }

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Port = Port;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].AccessType = VGA_VALIDATOR_UCHAR_ACCESS;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Data = *Data;

            hwDeviceExtension->TrappedValidatorCount++;

            //
            // Check to see if this instruction was ending sync reset.
            // If it did, we must flush the buffer and reset the trapped
            // IO ports to the minimal set.
            //

            if ( (Port == SEQ_DATA_PORT) &&
                 ((*Data & END_SYNC_RESET_VALUE) == END_SYNC_RESET_VALUE) &&
                 (hwDeviceExtension->SequencerAddressValue == IND_SYNC_RESET)) {

                endEmulation = 1;

            } else {

                //
                // If we are accessing the seq address port, keep track of the
                // data value
                //

                if (Port == SEQ_ADDRESS_PORT) {

                    hwDeviceExtension->SequencerAddressValue = *Data;

                }

                //
                // If the buffer is not full, then just return right away.
                //

                if (hwDeviceExtension->TrappedValidatorCount <
                       VGA_MAX_VALIDATOR_DATA -1) {

                    return NO_ERROR;

                }

                endEmulation = 0;
            }
        }

        //
        // We are either in a READ path or a WRITE path that caused a
        // a full buffer. So flush the buffer either way.
        //
        // To do this put an END_SYNC_RESET at the end since we want to make
        // the buffer is ended sync reset ended.
        //

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].AccessType = VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Data = (USHORT) (IND_SYNC_RESET +
                                          (END_SYNC_RESET_VALUE << 8));

        hwDeviceExtension->TrappedValidatorCount++;

        VideoPortSynchronizeExecution(hwDeviceExtension,
                                      VpHighPriority,
                                      (PMINIPORT_SYNCHRONIZE_ROUTINE)
                                          VgaPlaybackValidatorData,
                                      hwDeviceExtension);

        //
        // Write back the real value of the sequencer address port.
        //

        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                    SEQ_ADDRESS_PORT,
                                (UCHAR) hwDeviceExtension->SequencerAddressValue);

        //
        // If we are in a READ path, read the data
        //

        if (AccessMode & EMULATOR_READ_ACCESS) {

            *Data = VideoPortReadPortUchar(hwDeviceExtension->IOAddress + Port);

            endEmulation = 0;

        }

        //
        // If we are ending emulation, reset trapping to the minimal amount
        // and exit.
        //

        if (endEmulation) {

            VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                             NUM_MINIMAL_QVISION_VALIDATOR_ACCESS_RANGE,
                                             MinimalQVisionValidatorAccessRange);

            return NO_ERROR;

        }

        //
        // For both cases, put back a START_SYNC_RESET in the buffer.
        //

        hwDeviceExtension->TrappedValidatorCount = 1;

        hwDeviceExtension->TrappedValidatorData[0].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[0].AccessType =
                VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[0].Data =
                (ULONG) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8));

    } else {

        //
        // Nothing trapped.
        // Lets check is the IO is trying to do something that would require
        // us to stop trapping
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscelaneous register is always 0.
            // If it is 1 it could select a non-existant clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                temp = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                                  SEQ_ADDRESS_PORT);

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (START_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress + Port,
                                         (UCHAR) (*Data & 0xF7) );

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (END_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                            SEQ_ADDRESS_PORT,
                                        temp);

                return NO_ERROR;

            }

            //
            // If we get an access to the sequencer register, start trapping.
            //

            if ( (Port == SEQ_DATA_PORT) &&
                 ((*Data & END_SYNC_RESET_VALUE) != END_SYNC_RESET_VALUE) &&
                 (VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                         SEQ_ADDRESS_PORT) == IND_SYNC_RESET)) {

                VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                                 NUM_FULL_QVISION_VALIDATOR_ACCESS_RANGE,
                                                 FullQVisionValidatorAccessRange);

                hwDeviceExtension->TrappedValidatorCount = 1;
                hwDeviceExtension->TrappedValidatorData[0].Port = Port;
                hwDeviceExtension->TrappedValidatorData[0].AccessType =
                    VGA_VALIDATOR_UCHAR_ACCESS;

                hwDeviceExtension->TrappedValidatorData[0].Data = *Data;

                //
                // Start keeping track of the state of the sequencer port.
                //

                hwDeviceExtension->SequencerAddressValue = IND_SYNC_RESET;

            } else {

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress + Port,
                                        *Data);

            }

        } else {

            *Data = VideoPortReadPortUchar(hwDeviceExtension->IOAddress + Port);

        }
    }

    return NO_ERROR;

} // end VgaValidatorUcharEntry()

//---------------------------------------------------------------------------
VP_STATUS
VgaValidatorUshortEntry(
    ULONG Context,
    ULONG Port,
    UCHAR AccessMode,
    PUSHORT Data
    )

/*++

Routine Description:

    Entry point into the validator for word I/O operations.

    The entry point will be called whenever a byte operation was performed
    by a DOS application on one of the specified Video ports. The kernel
    emulator will forward these requests.

Arguments:

    Context - Context value that is passed to each call made to the validator
        function. This is the value the miniport driver specified in the
        MiniportConfigInfo->EmulatorAccessEntriesContext.

    Port - Port on which the operation is to be performed.

    AccessMode - Determines if it is a read or write operation.

    Data - Pointer to a variable containing the data to be written or a
        variable into which the read data should be stored.

Return Value:

    NO_ERROR.

--*/

{

    PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION) Context;
    ULONG endEmulation;
    UCHAR temp;

    VideoDebugPrint((1,"QVision.sys: VgaValidatorUshortEntry.\n"));

    Port -= VGA_BASE_IO_PORT;

    if (hwDeviceExtension->TrappedValidatorCount) {

        //
        // If we are processing a WRITE instruction, then store it in the
        // playback buffer. If the buffer is full, then play it back right
        // away, end sync reset and reinitialize the buffer with a sync
        // reset instruction.
        //
        // If we have a READ, we must flush the buffer (which has the side
        // effect of starting SyncReset), perform the read operation, stop
        // sync reset, and put back a sync reset instruction in the buffer
        // so we can go on appropriately
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscellaneous register is always 0.
            // If it is 1 it could select a non-existent clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                *Data &= 0xFFF7;

            }

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Port = Port;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].AccessType = VGA_VALIDATOR_USHORT_ACCESS;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Data = *Data;

            hwDeviceExtension->TrappedValidatorCount++;

            //
            // Check to see if this instruction was ending sync reset.
            // If it did, we must flush the buffer and reset the trapped
            // IO ports to the minimal set.
            //

            if (Port == SEQ_ADDRESS_PORT) {

                //
                // If we are accessing the seq address port, keep track of its
                // value
                //

                hwDeviceExtension->SequencerAddressValue = (*Data & 0xFF);

            }

            if ((Port == SEQ_ADDRESS_PORT) &&
                ( ((*Data >> 8) & END_SYNC_RESET_VALUE) ==
                   END_SYNC_RESET_VALUE) &&
                (hwDeviceExtension->SequencerAddressValue == IND_SYNC_RESET)) {

                endEmulation = 1;

            } else {

                //
                // If the buffer is not full, then just return right away.
                //

                if (hwDeviceExtension->TrappedValidatorCount <
                       VGA_MAX_VALIDATOR_DATA - 1) {

                    return NO_ERROR;

                }

                endEmulation = 0;
            }
        }

        //
        // We are either in a READ path or a WRITE path that caused a
        // a full buffer. So flush the buffer either way.
        //
        // To do this put an END_SYNC_RESET at the end since we want to make
        // the buffer is ended sync reset ended.
        //

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].AccessType = VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Data = (USHORT) (IND_SYNC_RESET +
                                          (END_SYNC_RESET_VALUE << 8));

        hwDeviceExtension->TrappedValidatorCount++;

        VideoPortSynchronizeExecution(hwDeviceExtension,
                                      VpHighPriority,
                                      (PMINIPORT_SYNCHRONIZE_ROUTINE)
                                          VgaPlaybackValidatorData,
                                      hwDeviceExtension);

        //
        // Write back the real value of the sequencer address port.
        //

        VideoPortWritePortUchar((PUCHAR) (hwDeviceExtension->IOAddress +
                                    SEQ_ADDRESS_PORT),
                                (UCHAR) hwDeviceExtension->SequencerAddressValue);

        //
        // If we are in a READ path, read the data
        //

        if (AccessMode & EMULATOR_READ_ACCESS) {

            *Data = VideoPortReadPortUshort((PUSHORT)(hwDeviceExtension->IOAddress
                                                + Port));

            endEmulation = 0;

        }

        //
        // If we are ending emulation, reset trapping to the minimal amount
        // and exit.
        //

        if (endEmulation) {

            VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                             NUM_MINIMAL_QVISION_VALIDATOR_ACCESS_RANGE,
                                             MinimalQVisionValidatorAccessRange);

            return NO_ERROR;

        }

        //
        // For both cases, put back a START_SYNC_RESET in the buffer.
        //

        hwDeviceExtension->TrappedValidatorCount = 1;

        hwDeviceExtension->TrappedValidatorData[0].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[0].AccessType =
                VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[0].Data =
                (ULONG) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8));

    } else {

        //
        // Nothing trapped.
        // Lets check is the IO is trying to do something that would require
        // us to stop trapping
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscelaneous register is always 0.
            // If it is 1 it could select a non-existant clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                temp = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                                  SEQ_ADDRESS_PORT);

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (START_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             (ULONG)Port),
                                         (USHORT) (*Data & 0xFFF7) );

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (END_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                                        temp);

                return NO_ERROR;

            }

            if ( (Port == SEQ_ADDRESS_PORT) &&
                 (((*Data>> 8) & END_SYNC_RESET_VALUE) != END_SYNC_RESET_VALUE) &&
                 ((*Data & 0xFF) == IND_SYNC_RESET)) {

                VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                                 NUM_FULL_QVISION_VALIDATOR_ACCESS_RANGE,
                                                 FullQVisionValidatorAccessRange);

                hwDeviceExtension->TrappedValidatorCount = 1;
                hwDeviceExtension->TrappedValidatorData[0].Port = Port;
                hwDeviceExtension->TrappedValidatorData[0].AccessType =
                    VGA_VALIDATOR_USHORT_ACCESS;

                hwDeviceExtension->TrappedValidatorData[0].Data = *Data;

                //
                // Start keeping track of the state of the sequencer port.
                //

                hwDeviceExtension->SequencerAddressValue = IND_SYNC_RESET;

            } else {

                VideoPortWritePortUshort((PUSHORT)(hwDeviceExtension->IOAddress +
                                             Port),
                                         *Data);

            }

        } else {

            *Data = VideoPortReadPortUshort((PUSHORT)(hwDeviceExtension->IOAddress +
                                            Port));

        }
    }

    return NO_ERROR;

} // end VgaValidatorUshortEntry()

//---------------------------------------------------------------------------
VP_STATUS
VgaValidatorUlongEntry(
    ULONG Context,
    ULONG Port,
    UCHAR AccessMode,
    PULONG Data
    )

/*++

Routine Description:

    Entry point into the validator for dword I/O operations.

    The entry point will be called whenever a byte operation was performed
    by a DOS application on one of the specified Video ports. The kernel
    emulator will forward these requests.

Arguments:

    Context - Context value that is passed to each call made to the validator
        function. This is the value the miniport driver specified in the
        MiniportConfigInfo->EmulatorAccessEntriesContext.

    Port - Port on which the operation is to be performed.

    AccessMode - Determines if it is a read or write operation.

    Data - Pointer to a variable containing the data to be written or a
        variable into which the read data should be stored.

Return Value:

    NO_ERROR.

--*/

{

    PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION) Context;
    ULONG endEmulation;
    UCHAR temp;

    VideoDebugPrint((1,"QVision.sys: VgaValidatorUlongEntry.\n"));

    Port -= VGA_BASE_IO_PORT;

    if (hwDeviceExtension->TrappedValidatorCount) {

        //
        // If we are processing a WRITE instruction, then store it in the
        // playback buffer. If the buffer is full, then play it back right
        // away, end sync reset and reinitialize the buffer with a sync
        // reset instruction.
        //
        // If we have a READ, we must flush the buffer (which has the side
        // effect of starting SyncReset), perform the read operation, stop
        // sync reset, and put back a sync reset instruction in the buffer
        // so we can go on appropriately
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscellaneous register is always 0.
            // If it is 1 it could select a non-existent clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                *Data &= 0xFFFFFFF7;

            }

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Port = Port;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].AccessType = VGA_VALIDATOR_ULONG_ACCESS;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Data = *Data;

            hwDeviceExtension->TrappedValidatorCount++;

            //
            // Check to see if this instruction was ending sync reset.
            // If it did, we must flush the buffer and reset the trapped
            // IO ports to the minimal set.
            //

            if (Port == SEQ_ADDRESS_PORT) {

                //
                // If we are accessing the seq address port, keep track of its
                // value
                //

                hwDeviceExtension->SequencerAddressValue = (*Data & 0xFF);

            }

            if ((Port == SEQ_ADDRESS_PORT) &&
                ( ((*Data >> 8) & END_SYNC_RESET_VALUE) ==
                   END_SYNC_RESET_VALUE) &&
                (hwDeviceExtension->SequencerAddressValue == IND_SYNC_RESET)) {

                endEmulation = 1;

            } else {

                //
                // If the buffer is not full, then just return right away.
                //

                if (hwDeviceExtension->TrappedValidatorCount <
                       VGA_MAX_VALIDATOR_DATA - 1) {

                    return NO_ERROR;

                }

                endEmulation = 0;
            }
        }

        //
        // We are either in a READ path or a WRITE path that caused a
        // a full buffer. So flush the buffer either way.
        //
        // To do this put an END_SYNC_RESET at the end since we want to make
        // the buffer is ended sync reset ended.
        //

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].AccessType = VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Data = (USHORT) (IND_SYNC_RESET +
                                          (END_SYNC_RESET_VALUE << 8));

        hwDeviceExtension->TrappedValidatorCount++;

        VideoPortSynchronizeExecution(hwDeviceExtension,
                                      VpHighPriority,
                                      (PMINIPORT_SYNCHRONIZE_ROUTINE)
                                          VgaPlaybackValidatorData,
                                      hwDeviceExtension);

        //
        // Write back the real value of the sequencer address port.
        //

        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                    SEQ_ADDRESS_PORT,
                                (UCHAR) hwDeviceExtension->SequencerAddressValue);

        //
        // If we are in a READ path, read the data
        //

        if (AccessMode & EMULATOR_READ_ACCESS) {

            *Data = VideoPortReadPortUlong((PULONG) (hwDeviceExtension->IOAddress +
                                               Port));

            endEmulation = 0;

        }

        //
        // If we are ending emulation, reset trapping to the minimal amount
        // and exit.
        //

        if (endEmulation) {

            VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                             NUM_MINIMAL_QVISION_VALIDATOR_ACCESS_RANGE,
                                             MinimalQVisionValidatorAccessRange);

            return NO_ERROR;

        }

        //
        // For both cases, put back a START_SYNC_RESET in the buffer.
        //

        hwDeviceExtension->TrappedValidatorCount = 1;

        hwDeviceExtension->TrappedValidatorData[0].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[0].AccessType =
                VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[0].Data =
                (ULONG) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8));

    } else {

        //
        // Nothing trapped.
        // Lets check is the IO is trying to do something that would require
        // us to stop trapping
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscelaneous register is always 0.
            // If it is 1 it could select a non-existant clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                temp = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                                  SEQ_ADDRESS_PORT);

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (START_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUlong((PULONG) (hwDeviceExtension->IOAddress +
                                             Port),
                                         (ULONG) (*Data & 0xFFFFFFF7) );

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (END_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                                        temp);

                return NO_ERROR;

            }

            if ( (Port == SEQ_ADDRESS_PORT) &&
                 (((*Data>> 8) & END_SYNC_RESET_VALUE) != END_SYNC_RESET_VALUE) &&
                 ((*Data & 0xFF) == IND_SYNC_RESET)) {

                VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                                 NUM_FULL_QVISION_VALIDATOR_ACCESS_RANGE,
                                                 FullQVisionValidatorAccessRange);

                hwDeviceExtension->TrappedValidatorCount = 1;
                hwDeviceExtension->TrappedValidatorData[0].Port = Port;
                hwDeviceExtension->TrappedValidatorData[0].AccessType =
                    VGA_VALIDATOR_ULONG_ACCESS;

                hwDeviceExtension->TrappedValidatorData[0].Data = *Data;

                //
                // Start keeping track of the state of the sequencer port.
                //

                hwDeviceExtension->SequencerAddressValue = IND_SYNC_RESET;

            } else {

                VideoPortWritePortUlong((PULONG) (hwDeviceExtension->IOAddress +
                                            Port),
                                        *Data);

            }

        } else {

            *Data = VideoPortReadPortUlong((PULONG) (hwDeviceExtension->IOAddress +
                                           Port));

        }

    }

    return NO_ERROR;

} // end VgaValidatorUlongEntry()

//---------------------------------------------------------------------------
BOOLEAN
VgaPlaybackValidatorData(
    PVOID Context
    )

/*++

Routine Description:

    Performs all the DOS apps IO port accesses that were trapped by the
    validator. Only IO accesses that can be processed are WRITEs

    The number of outstanding IO access in deviceExtension is set to
    zero as a side effect.

    This function must be called via a call to VideoPortSynchronizeRoutine.

Arguments:

    Context - Context parameter passed to the synchronized routine.
        Must be a pointer to the miniport driver's device extension.

Return Value:

    TRUE.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = Context;
    ULONG ioBaseAddress = (ULONG) hwDeviceExtension->IOAddress;
    UCHAR i;
    PVGA_VALIDATOR_DATA validatorData = hwDeviceExtension->TrappedValidatorData;

    VideoDebugPrint((1,"QVision.sys: VgaPlaybackValidatorData.\n"));

    //
    // Loop through the array of data and do instructions one by one.
    //

    for (i = 0; i < hwDeviceExtension->TrappedValidatorCount;
         i++, validatorData++) {

        //
        // Calculate base address first
        //

        ioBaseAddress = (ULONG)hwDeviceExtension->IOAddress +
                            validatorData->Port;


        //
        // This is a write operation. We will automatically stop when the
        // buffer is empty.
        //

        switch (validatorData->AccessType) {

        case VGA_VALIDATOR_UCHAR_ACCESS :

            VideoPortWritePortUchar((PUCHAR)ioBaseAddress,
                                    (UCHAR) validatorData->Data);

            break;

        case VGA_VALIDATOR_USHORT_ACCESS :

            VideoPortWritePortUshort((PUSHORT)ioBaseAddress,
                                     (USHORT) validatorData->Data);

            break;

        case VGA_VALIDATOR_ULONG_ACCESS :

            VideoPortWritePortUlong((PULONG)ioBaseAddress,
                                    (ULONG) validatorData->Data);

            break;

        default:

            VideoDebugPrint((0, "InvalidValidatorAccessType\n" ));

        }
    }

    hwDeviceExtension->TrappedValidatorCount = 0;

    return TRUE;

} // end VgaPlaybackValidatorData()

//---------------------------------------------------------------------------
VP_STATUS
VgaGetRegistryParametersCallback(
    PHW_DEVICE_EXTENSION pHwDeviceExtension,
    PVOID pvContext,
    PWSTR pwstrValueName,
    PVOID pvValueData,
    ULONG ulValueLength)

/*++

Routine Description:

    This function is called when the parameters searched
    for is found in the registry.  In our case, we
    try to get the VRefresh rate from the QVision entry.
    The function is called by VideoGetRegistryParameters.

Arguments:

    pHwDeviceExtension - pointer to the HW_DEVICE_EXTENSION structure.

    pvContext - pointer to a context which is passed to the driver.

    pwstrValueName - pointer to the parameter name string.

    pvValueData - pointer to the actual value found.

    ulValueLength - length of the value (for strings)

Return Value:

     VP_STATUS

--*/

{
   VideoDebugPrint((1,"QVision.sys: QVGetRegistryParametersCallback - \n"));

   pHwDeviceExtension->VideoHardware.lFrequency = (LONG)(*((PLONG)pvValueData));

   VideoDebugPrint((2,"\tFrequency = %x\n",
                    pHwDeviceExtension->VideoHardware.lFrequency));
   return NO_ERROR;
} // VgaGetRegistryParametersCallback()

//---------------------------------------------------------------------------
VP_STATUS
GetMonClass (
    PHW_DEVICE_EXTENSION pHwDeviceExtension)

/*++

Routine Description:

    This function returns the class of Compaq monitor attached to the
    QVision card.


Arguments:

    pHwDeviceExtension - pointer to the HW_DEVICE_EXTENSION structure.


Return Value:

    Monitor Class

--*/

{

    UCHAR   pjMonId;                        /* BIOS ID for the monitor */

    VideoDebugPrint((1,"QVision.sys: GetMonClass \n"));

    //
    //  If the frequency in the HwDeviceExtension is non-negative, it
    //  means that the registry was read and that we already have the
    //  correct value.  If the Frequency in the registry is non-zero,
    //  it means that someone selected the QVISION card with Third Party
    //  Monitors.  In this case, select a Third Party monitor
    //  automatically.  Make sure that we have the CRTC values for that
    //  mode (screen resolution) for the third party monitors.
    //
    //  If the user mucks with the registry and we do not support a
    //  particular mode for the third party monitors then default to
    //  standard VGA.
    //

    VideoDebugPrint((2,"\tFrequency = %x\n",
                    pHwDeviceExtension->VideoHardware.lFrequency));

    if (pHwDeviceExtension->VideoHardware.lFrequency > USE_HARDWARE_DEFAULT) {

        switch (pHwDeviceExtension->VideoHardware.lFrequency) {

               case 60:                              // 60Hz monitor
                  VideoDebugPrint((2,"\t60Hz refresh rate monitor.\n"));
                  pHwDeviceExtension->VideoHardware.MonClass = Monitor_60Hz;
                  break;

               case 66:                              // 66Hz monitor
                  VideoDebugPrint((2,"\t66Hz refresh rate monitor.\n"));
                  pHwDeviceExtension->VideoHardware.MonClass = Monitor_66Hz;
                  break;

               case 68:                              // 68Hz monitor
                  VideoDebugPrint((2,"\t68Hz refresh rate monitor.\n"));
                  pHwDeviceExtension->VideoHardware.MonClass = Monitor_68Hz;
                  break;

               case 72:                              // 72Hz monitor
                  VideoDebugPrint((2,"\t72Hz refresh rate monitor.\n"));
                  pHwDeviceExtension->VideoHardware.MonClass = Monitor_72Hz;
                  break;

               case 75:                              // 75Hz monitor
                  VideoDebugPrint((2,"\t75Hz refresh rate monitor.\n"));
                  pHwDeviceExtension->VideoHardware.MonClass = Monitor_75Hz;
                  break;

               case 76:                              // 76Hz monitor
                  VideoDebugPrint((2,"\t76Hz refresh rate monitor.\n"));
                  pHwDeviceExtension->VideoHardware.MonClass = Monitor_76Hz;
                  break;

               default:                              // default to 60Hz
                  VideoDebugPrint((2,"\t60Hz refresh rate monitor.\n"));
                  pHwDeviceExtension->VideoHardware.MonClass = Monitor_60Hz;
                  break;

        } // switch

        return NO_ERROR;

    } // if

    //
    // The user specified that a COMPAQ monitor is attached to the
    // QVISION card.  Detect the monitor type.
    //

    // unlock extended graphics regs
    VideoPortWritePortUchar(pHwDeviceExtension->IOAddress+
                                GRAPH_ADDRESS_PORT, 0x0F);
    VideoPortWritePortUchar(pHwDeviceExtension->IOAddress+
                           GRAPH_DATA_PORT, 0x05);

    // get monitor ID
    VideoPortWritePortUchar(pHwDeviceExtension->IOAddress+
                           GRAPH_ADDRESS_PORT, 0x50);
    pjMonId = (VideoPortReadPortUchar(pHwDeviceExtension->IOAddress+
                                      GRAPH_DATA_PORT) & 0x78) >> 3;


    //
    // Is the detected monitor a third party monitor ?
    // If we get here, this means that the user selected a
    // COMPAQ monitor even though he/she has a Third Party
    // Monitor connected to the QVision card.
    // In this case, we set the monitor in a default
    // Third party mode.
    //

    if (VideoPortReadPortUchar(pHwDeviceExtension->IOAddress+
                               GRAPH_DATA_PORT) & 0x80) {

      VideoDebugPrint((2,"\tThird Party Monitor ID %x - default to 60Hz\n", pjMonId));
      pHwDeviceExtension->VideoHardware.MonClass =
         Monitor_60Hz;              // Y: monitor class = monitor ID
    }

    else

        switch (pjMonId) {          // N: either CPQ or unknown monitor

            case 0x2:
                VideoDebugPrint((2,"\tAG1024 Monitor\n"));
                pHwDeviceExtension->VideoHardware.MonClass = Monitor_AG1024;
                break;

            case 0x3:
                VideoDebugPrint((2,"\t1024 Monitor, ID %x\n", pjMonId));
                pHwDeviceExtension->VideoHardware.MonClass = Monitor_Qvision;
                break;

            case 0x4:
                VideoDebugPrint((2,"\t1280 Monitor, ID %x\n", pjMonId));
                pHwDeviceExtension->VideoHardware.MonClass = Monitor_1280;
                break;

            case 0x5:
                VideoDebugPrint((2,"\tSVGA Monitor\n"));
                pHwDeviceExtension->VideoHardware.MonClass = Monitor_SVGA;
                break;

            case 0x6:
                VideoDebugPrint((2,"\tQVISION Monitor, ID %x\n", pjMonId));
                pHwDeviceExtension->VideoHardware.MonClass = Monitor_Qvision;
                break;

            case 0xE:
            case 0xD:
                VideoDebugPrint((2,"\tVGA Monitor, ID %x\n", pjMonId));
                pHwDeviceExtension->VideoHardware.MonClass = Monitor_Vga;
                break;

            case 0xA: // NOTE: 0xA and 0xB are ibm monitors, they work with
            case 0xB: // third party values but flicker a little.
            case 0xF:
                VideoDebugPrint((2,"\tDefault Third Party Monitor ID %x\n", pjMonId));

            default:
                VideoDebugPrint((2,"\tdefault %x - 60Hz\n", pjMonId));
                pHwDeviceExtension->VideoHardware.MonClass = Monitor_60Hz;
                break;

        } // switch


    VideoDebugPrint((1,"QVision.sys: GetMonClass EXIT\n"));
    return NO_ERROR;


}  // GetMonClass()



//---------------------------------------------------------------------------
VOID
QVLocalRestoreHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE_HEADER hardwareStateHeader
    )

/*++

Routine Description:

    Restores the QVision hardware extended registers state.  All QVision
    extended registers are restored here so the VgaRestoreHardwareState
    routine can be left as generic as possible.


Arguments:

    HwDeviceExtension   - Pointer to device extension.

    hardwareStateHeader - Pointer to a structure in which the saved
                          state will be saved.


Return Value:

    VOID

--*/
{

    PUCHAR port;
    PUCHAR indexPort;
    PUCHAR portValue;
    UCHAR  i, j;


    //
    // Restore the extended registers for QVision.
    //
    VideoDebugPrint((1,"\tQVLocalRestoreHardwareState entry - \n"));

    //
    // Unlock the QVision extended registers
    //

    QVUnlockExtRegs(HwDeviceExtension);


    //
    // Restore Overscan Color and 3 Cursor Colors registers from
    // the extended DAC registers save area
    //

    portValue = (PUCHAR) hardwareStateHeader + \
                         hardwareStateHeader->ExtendedDacOffset;

    indexPort = (PUCHAR) 0x83C8;
    port = (PUCHAR) 0x83C9;

    //
    // Overscan Color
    //
    VideoPortWritePortUchar(indexPort, 0);

    for (j = 0; j < 3; j++, portValue++) {
        VideoPortWritePortUchar(port, *portValue);
    }


    //
    // Cursor Color 1
    //
    VideoPortWritePortUchar(indexPort, 1);

    for (j = 0; j < 3; j++, portValue++) {
           VideoPortWritePortUchar(port, *portValue);
    }


    //
    // Cursor Color 2
    //
    VideoPortWritePortUchar(indexPort, 2);

    for (j = 0; j < 3; j++, portValue++) {
           VideoPortWritePortUchar(port, *portValue);
    }


    //
    // Cursor Color 3
    //
    VideoPortWritePortUchar(indexPort, 3);

    for (j = 0; j < 3; j++, portValue++) {
           VideoPortWritePortUchar(port, *portValue);
    }


    //
    // VDAC Status/Command registers
    //
    portValue = (PUCHAR) hardwareStateHeader +   \
                         hardwareStateHeader->ExtendedCrtContOffset + \
                         EXT_MAIN_REG_13C6;

    port = (PUCHAR) 0x13C6;

    for (i=0; i < EXT_NUM_MAIN_13C6; i++, portValue++) {
           VideoPortWritePortUchar(port+i,*portValue);
    }


    //
    // BLT Registers
    //
    portValue = (PUCHAR) hardwareStateHeader +  \
                         hardwareStateHeader->ExtendedCrtContOffset + \
                         EXT_MAIN_REG_23CX;

    port = (PUCHAR) 0x23C0;

    for (i=0; i < EXT_NUM_MAIN_23CX; i++, portValue++) {
           VideoPortWritePortUchar(port+i,*portValue);
    }


    //
    // BLT and Extended Graphics Registers - write first 10 regs
    // starting at 33CX then handle pattern regs as special case.
    //
    portValue = (PUCHAR) hardwareStateHeader + \
                         hardwareStateHeader->ExtendedCrtContOffset + \
                         EXT_MAIN_REG_33CX;

    port = (PUCHAR) 0x33C0;

    for (i=0; i < 10; i++, portValue++) {
           VideoPortWritePortUchar(port+i,*portValue);
    }


    //
    // Write the 8 BLT pattern registers - must handle as special case
    // since there are two pattern registers mapped at each of
    // 4 IO addresses - toggle the select bit (5) at 0x33CF to write
    // both regs for a given address.
    //

    port = (PUCHAR) 0x33CA;
    for (i=0; i < 4; i++, portValue++) {
           VideoPortWritePortUchar(port+i,*portValue);
    }


    //
    //  Restore the last two registers in the 0x33CX range
    //
    //  portValue is currently set to:
    //
    //             hardwareStateHeader +
    //             hardwareStateHeader->ExtendedCrtContOffset +
    //             EXT_MAIN_REGS_33CX
    //             EXT_NUM_MAIN_33CX - 2
    //

    port = (PUCHAR) 0x33CE;
    VideoPortWritePortUchar(port++, *portValue);
    portValue++;
    VideoPortWritePortUchar(port, *portValue);


    //
    // Compaq Control Register
    //

    portValue = (PUCHAR) hardwareStateHeader +  \
                         hardwareStateHeader->ExtendedCrtContOffset + \
                         EXT_MAIN_REG_46E8;

    VideoPortWritePortUchar((PUCHAR) 0x46E8, *portValue);
    portValue++;


    //
    // Line Draw Engine, BLT, Extended Control, & Extended CRTC Registers
    //

    portValue = (PUCHAR) hardwareStateHeader + \
                         hardwareStateHeader->ExtendedCrtContOffset + \
                         EXT_MAIN_REG_63CX;

    port = (PUCHAR) 0x63C0;

    for (i=0; i < EXT_NUM_MAIN_63CX; i++, portValue++) {
           VideoPortWritePortUchar(port+i,*portValue);
    }


    //
    // Line Draw Engine, Extended Control, & Extended DAC Registers
    //

    portValue = (PUCHAR) hardwareStateHeader + \
                         hardwareStateHeader->ExtendedCrtContOffset + \
                         EXT_MAIN_REG_83CX;

    port = (PUCHAR) 0x83C0;

    for (i=0; i < EXT_NUM_MAIN_83CX; i++, portValue++) {
           VideoPortWritePortUchar(port+i,*portValue);
    }


    //
    // Extended DAC Cursor Location Registers
    //
    portValue = (PUCHAR) hardwareStateHeader + \
                         hardwareStateHeader->ExtendedCrtContOffset + \
                         EXT_MAIN_REG_93CX;

    port = (PUCHAR) 0x93C6;

    for (i=0; i < EXT_NUM_MAIN_93CX; i++, portValue++) {
           VideoPortWritePortUchar(port+i,*portValue);
    }

    //
    // Extended Graphics Ports.
    //

    portValue = ((PUCHAR) hardwareStateHeader) + \
                hardwareStateHeader->ExtendedGraphContOffset;

    port = (PUCHAR) 0x3CE;
    indexPort = (PUCHAR) 0x3CF;

    for (i=0; extGraIndRegs[i] != 0; i++) {
        VideoPortWritePortUchar(port, extGraIndRegs[i]);
        VideoPortWritePortUchar(indexPort, *(portValue + i));
    }

    for (j=0; extV32GraIndRegs[j] != 0; i++, j++) {
        VideoPortWritePortUchar(port, extV32GraIndRegs[j] );
        VideoPortWritePortUchar(indexPort, *(portValue + i));
    }


}   // QVLocalRestoreHardwareState()

//---------------------------------------------------------------------------
VOID
QVLocalSaveHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE_HEADER hardwareStateHeader
    )

/*++

Routine Description:

    Saves the QVision hardware extended registers state.  All QVision
    extended registers are saved here so the VgaSaveHardwareState routine
    can be left as generic as possible.


Arguments:

    HwDeviceExtension   - Pointer to device extension.

    hardwareStateHeader - Pointer to a structure in which the saved
                          state will be saved.

Return Value:

        VOID

--*/
{

    PUCHAR port;                    // io register
    PUCHAR indexPort;               // io index register
    PUCHAR portValue;               // offset into save state buffer
    UCHAR  i, j, dummy;


    //
    // Begin storing all of the extended registers for QVision.
    //

    //
    // Unlock the QVision extended registers.
    //

    QVUnlockExtRegs(HwDeviceExtension);

    //
    // Extended Graphics Ports.  QVision has holes in the range of
    // indexed registers from 3CF.8 to 3CF.6B so only save and restore
    // valid indexes.  Note: these regs will not be saved in order
    // and must be restored using the same logic as below.
    //

    hardwareStateHeader->ExtendedGraphContOffset = VGA_EXT_GRAPH_CONT_OFFSET;
    portValue = (PUCHAR) hardwareStateHeader + \
                        hardwareStateHeader->ExtendedGraphContOffset;

    port = (PUCHAR) 0x3CE;
    indexPort = (PUCHAR) 0x3CF;

    for (i=0; extGraIndRegs[i] != 0; i++) {
        VideoPortWritePortUchar(port, extGraIndRegs[i] );
           *(portValue + i) = VideoPortReadPortUchar(indexPort);
    }

    for (j=0; extV32GraIndRegs[j] != 0; i++, j++) {
        VideoPortWritePortUchar(port, extV32GraIndRegs[j] );
           *(portValue + i) = VideoPortReadPortUchar(indexPort);
    }

    //
    // VDAC Status/Command Registers
    //
    portValue = (PUCHAR) hardwareStateHeader + \
                hardwareStateHeader->ExtendedCrtContOffset + \
                EXT_MAIN_REG_13C6;

    port = (PUCHAR) 0x13C6;

    for (i=0; i < EXT_NUM_MAIN_13C6; i++, portValue++)
        *portValue= VideoPortReadPortUchar(port+i);

    //
    // BLT Registers
    //
    portValue = (PUCHAR) hardwareStateHeader + \
                         hardwareStateHeader->ExtendedCrtContOffset + \
                         EXT_MAIN_REG_23CX;

    port = (PUCHAR) 0x23C0;

    for (i=0; i < EXT_NUM_MAIN_23CX; i++, portValue++)
        *portValue= VideoPortReadPortUchar(port+i);


    //
    // BLT and Extended Graphics Registers - read first 10 33CX regs
    //  then handle pattern regs as a special case.
    //
    portValue = (PUCHAR) hardwareStateHeader + \
                         hardwareStateHeader->ExtendedCrtContOffset + \
                         EXT_MAIN_REG_33CX;

    port = (PUCHAR) 0x33C0;

    for (i=0; i < 10; i++, portValue++)
        *portValue= VideoPortReadPortUchar(port+i);


    //
    // Read the 8 blt pattern registers - must handle as special case
    // since there are two pattern registers mapped at each of
    // 4 IO addresses - toggle the select bit (5) at 33CF to read both
    // registers for a given address.
    //
    // portValue = offset of EXT_MAIN_REG_33CX + 10
    //

    port = (PUCHAR) 0x33CA;
    for (i=0; i < 4; i++, portValue++) {

        dummy = VideoPortReadPortUchar((PUCHAR)BLT_CMD_1);
        VideoPortWritePortUchar((PUCHAR)BLT_CMD_1, (UCHAR)(dummy | 0x20));
       *portValue = VideoPortReadPortUchar(port+i);
        portValue++;

        VideoPortWritePortUchar((PUCHAR)BLT_CMD_1, (UCHAR)(dummy & 0xdf));
       *portValue = VideoPortReadPortUchar(port+i);
    }


    //
    //  Save remaining 0x33CX registers
    //
    //  portValue is currently set to:
    //
    //              hardwareStateHeader +
    //              hardwareStateHeader->ExtendedCrtContOffset  +
    //              EXT_MAIN_REG_33C +
    //              EXT_NUM_MAIN_33CX - 2
    //

    port = (PUCHAR) 0x33CE;
   *portValue = VideoPortReadPortUchar(port++);
    portValue++;
   *portValue = VideoPortReadPortUchar(port);


    //
    // VGA Control Register.
    //

    portValue  = (PUCHAR) hardwareStateHeader +
                          hardwareStateHeader->ExtendedCrtContOffset + \
                          EXT_MAIN_REG_46E8;

   *portValue  = VideoPortReadPortUchar((PUCHAR) 0x46E8);
    portValue++;


    //
    // Line Draw Engine, BLT, Extended Control, & Extended CRTC Registers.
    //

    portValue = (PUCHAR) hardwareStateHeader +
                         hardwareStateHeader->ExtendedCrtContOffset + \
                         EXT_MAIN_REG_63CX;

    port = (PUCHAR) 0x63C0;

    for (i=0; i < EXT_NUM_MAIN_63CX; i++, portValue++) {
        *portValue = VideoPortReadPortUchar(port+i);

    }


    //
    // Line Draw Engine, Extended Control, & Extended DAC Registers.
    //

    portValue = (PUCHAR) hardwareStateHeader +
                         hardwareStateHeader->ExtendedCrtContOffset + \
                         EXT_MAIN_REG_83CX;

    port = (PUCHAR) 0x83C0;

    for (i=0; i < EXT_NUM_MAIN_83CX; i++, portValue++) {
        *portValue= VideoPortReadPortUchar(port+i);
    }


    //
    // Extended Cursor Control Registers.
    //

    portValue = (PUCHAR) hardwareStateHeader +
                         hardwareStateHeader->ExtendedCrtContOffset + \
                         EXT_MAIN_REG_93CX;

    port = (PUCHAR) 0x93C6;

    for (i=0; i < EXT_NUM_MAIN_93CX; i++, portValue++)
        *portValue= VideoPortReadPortUchar(port+i);


    //
    // Save the extended DAC registers.
    //
    // The extended DAC registers are used for the cursor color ram and
    // the overscan color ram.  There are a total of 4 RGB values
    // to be saved - total space required is 12 bytes.
    //

    portValue = (PUCHAR) hardwareStateHeader + \
                         hardwareStateHeader->ExtendedDacOffset;

    //
    // Setup index port for Overscan Color then read RGB value.
    //

    indexPort = (PUCHAR) 0x83c7;
    VideoPortWritePortUchar(indexPort, 0);

    port = (PUCHAR) 0x83C9;

    for (j = 0; j < 3; j++)
        *(portValue++) = VideoPortReadPortUchar(port);


    //
    // Setup index port for Cursor Color 1 then read RGB value.
    //

    indexPort = (PUCHAR) 0x83c7;
    VideoPortWritePortUchar(indexPort, 1);

    port = (PUCHAR) 0x83C9;

    for (j = 0; j < 3; j++)
        *(portValue++) = VideoPortReadPortUchar(port);


    //
    // Setup index port for Cursor Color 2 then read RGB value.
    //

    indexPort = (PUCHAR) 0x83c7;
    VideoPortWritePortUchar(indexPort, 2);

    port = (PUCHAR) 0x83C9;

    for (j = 0; j < 3; j++)
        *(portValue++) = VideoPortReadPortUchar(port);


    //
    // Setup index port for Cursor Color 3 then read RGB value.
    //

    indexPort = (PUCHAR) 0x83c7;
    VideoPortWritePortUchar(indexPort, 3);

    port = (PUCHAR) 0x83C9;

    for (j = 0; j < 3; j++)
        *(portValue++) = VideoPortReadPortUchar(port);

    //*tbd
    // Need to save cursor RAM plane data - eventually.
    //

}   // QVLocalSaveHardwareState

//---------------------------------------------------------------------------
VOID
QVSaveRestoreVideoMemory(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE_HEADER hardwareStateHeader,
    UCHAR ucFlag
    )

/*++

Routine Description:

    This routine saves the video frame buffer for extended QVision modes.
    Standard save code in VgaSaveHardwareState() will be used for
    standard VGA modes.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    hardwareStateHeader -

    ucFlag  - QV_SAVE_FRAME_BUFFER = 1 means save the frame buffer
              else, restore the frame buffer

Return Value:

    None.

--*/
{
    UCHAR   temp;
    UCHAR   ucSavedPg;                      // saved page register value
    UCHAR   ucPgMultiplier;                 // page value shift amount
    USHORT  usBankCount;                    // number of 32k banks to move
    ULONG   ulFrameSize;                    // size of video frame buffer
    ULONG   ulPgSize;                       // size of banked page
    PULONG  pulBuffer;                      // pointer to save buffer
    ULONG   i;

    VideoDebugPrint((1,"QVision.sys: QVSaveRestoreVideoMemory - ENTRY.\n"));

    //
    //   Set QVision for packed pixel operation and enable 256 color
    //   extended modes by writing to QVision control register 0.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + GRAPH_ADDRESS_PORT,
                            (UCHAR) 0x40);

    temp = VideoPortReadPortUchar(HwDeviceExtension->IOAddress + \
                                  GRAPH_DATA_PORT) & 0xfd;

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + GRAPH_DATA_PORT,
                            (UCHAR) (temp | 0x01));


    //
    //   Set the QVision datapath control register (3cf.5a)
    //   to no ROP and CPU data.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress + \
                 GRAPH_ADDRESS_PORT), ((USHORT) DATAPATH_CONTROL) + 0x0000 );

    //
    //   Clear the QVision control register 1 (63ca) data path
    //   expand control bits to force packed pixel mode.
    //

    temp = VideoPortReadPortUchar((PUCHAR) 0x63CA);
    VideoPortWritePortUchar((PUCHAR) 0x63CA, (UCHAR) (temp & 0xe7));

    //
    //  Establish frame buffer size, banked window size, and address
    //  granularity
    //

    ulFrameSize = HwDeviceExtension->PhysicalVideoMemoryLength;
    ulPgSize  = 0x8000;               // use only 32k windows

    //
    //  Establish the page value multiplier.  See comments in bankSelect
    //  code for differences in addressing granularity on different QVisions.
    //
    switch (HwDeviceExtension->VideoHardware.AdapterType) {

        case JuniperEisa:
        case JuniperIsa:
        case FirEisa:
        case FirIsa:
            ucPgMultiplier = 1;
            break;

        case AriesEisa:
        case AriesIsa:
            ucPgMultiplier = 3;
            break;

        default:
            VideoDebugPrint((2,"\tQVSaveVideoMemory - ERROR, wrong adapter type.\n"));
    }

    //
    //   Establish number of banks to read
    //

    usBankCount = (USHORT) (ulFrameSize / ulPgSize);

    //
    //   Get and save the current page register 0 (3cf.45) value.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + GRAPH_ADDRESS_PORT,
                            0x45);

    ucSavedPg = VideoPortReadPortUchar(HwDeviceExtension->IOAddress + \
                                       GRAPH_DATA_PORT);

    //
    //  Set page register 0 (3cf.45) to starting value and save the
    //  entire frame buffer to the hardwareSaveState buffer.
    //

    pulBuffer = &(hardwareStateHeader->Plane1Offset);

    for (i=0; i < usBankCount; i ++) {

        //
        // map the first 32k block (adjusting for addressing granularity!)
        //

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress + \
        GRAPH_ADDRESS_PORT), (USHORT) (0x0045 + (i << (8 + ucPgMultiplier))) );

        //
        // save the 32k block of video memory - move test outside loop
        // and establish src/dst ptrs for better performance
        //

        if (ucFlag == QV_SAVE_FRAME_BUFFER) {
            VideoPortMoveMemory((PUCHAR) HwDeviceExtension->VideoMemoryAddress,
                               ((PUCHAR) hardwareStateHeader) + *pulBuffer,
                                ulPgSize);
        }
        else {
            VideoPortMoveMemory(((PUCHAR) hardwareStateHeader) + *pulBuffer,
                                (PUCHAR) HwDeviceExtension->VideoMemoryAddress,
                                ulPgSize);
        }
        *pulBuffer =+ ulPgSize;

    }

    VideoDebugPrint((1,"QVision.sys: QVSaveVideoMemory - EXIT.\n"));

}

//---------------------------------------------------------------------------
VOID
QVUnlockExtRegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine unlocks the extended QVision registers and sets
    up access to all BLT and DAC regs not at 3CX.  Use this function
    call when unlocking isn't performance critical.  Otherwise, do the
    unlock in-line.

    Unlock extended registers by setting 3CF.0F to 5 and bit 3
    of 3CF.10 to 1.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

Return Value:

    None.

--*/
{
    UCHAR ucTemp;

    VideoPortWritePortUchar((PUCHAR)(HwDeviceExtension->IOAddress + GRAPH_ADDRESS_PORT),
                            0x0f);
    ucTemp = VideoPortReadPortUchar((HwDeviceExtension->IOAddress + \
                                    GRAPH_DATA_PORT)) & 0xf0;
    VideoPortWritePortUchar((PUCHAR)(HwDeviceExtension->IOAddress + GRAPH_DATA_PORT),
                            (UCHAR)(0x05 | ucTemp));
    VideoPortWritePortUchar((PUCHAR)(HwDeviceExtension->IOAddress + GRAPH_ADDRESS_PORT),
                            0x10);
    ucTemp = VideoPortReadPortUchar((PUCHAR)(HwDeviceExtension->IOAddress + GRAPH_DATA_PORT));
    VideoPortWritePortUchar((PUCHAR)(HwDeviceExtension->IOAddress + GRAPH_DATA_PORT),
                            (UCHAR)(0x28 | ucTemp));

}

//---------------------------------------------------------------------------
VOID
QVLockExtRegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine locks the extended QVision registers and blocks
    access to all BLT and DAC regs not at 3CX.  Use this function call
    when locking isn't performance critical.  Otherwise, do the lock
    in-line.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.


Return Value:

    None.

--*/
{
    UCHAR ucTemp;

    VideoPortWritePortUchar((PUCHAR)(HwDeviceExtension->IOAddress + GRAPH_ADDRESS_PORT),
                            0x0f);
    ucTemp = VideoPortReadPortUchar((HwDeviceExtension->IOAddress + GRAPH_DATA_PORT));
    VideoPortWritePortUchar((PUCHAR)(HwDeviceExtension->IOAddress + GRAPH_DATA_PORT),
                            (UCHAR)(0x0f | ucTemp));
    VideoPortWritePortUchar((PUCHAR)(HwDeviceExtension->IOAddress + GRAPH_ADDRESS_PORT),
                            0x10);
    ucTemp = VideoPortReadPortUchar((PUCHAR)(HwDeviceExtension->IOAddress + GRAPH_DATA_PORT));
    VideoPortWritePortUchar((PUCHAR)(HwDeviceExtension->IOAddress + GRAPH_DATA_PORT),
                            (UCHAR)(0xf7 & ucTemp));

}

//---------------------------------------------------------------------------
VOID
VgaStandardRegsRestore(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE_HEADER hardwareStateHeader
    )

/*++

Routine Description:

    This routine restores the standard VGA controller registers.
    This code was pulled from VgaRestoreVideoHardware and implemented
    as a function call because it will need to be executed more than
    once for QVision hardware.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

    hardwareStateHeader - Pointer to a structure from which the saved state
        is to be restored.


Return Value:

    None.

--*/
{

    ULONG  i;
    UCHAR  dummy;
    PUCHAR portValue;
    ULONG  bIsColor;

    //
    // Set the critical registers (clock and timing states) during sync reset.
    //
    // Begin sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT), (USHORT) (IND_SYNC_RESET +
            (START_SYNC_RESET_VALUE << 8)));

    //
    // Restore the Miscellaneous Output register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            MISC_OUTPUT_REG_WRITE_PORT,
            (UCHAR) (hardwareStateHeader->PortValue[MISC_OUTPUT_REG_WRITE_PORT] & 0xF7));

    //
    // Restore all Sequencer registers except the Sync Reset register, which
    // is always not in reset (except when we send out a batched sync reset
    // register set, but that can't be interrupted, so we know we're never in
    // sync reset at save/restore time).
    //

    portValue = ((PUCHAR) hardwareStateHeader) +
            hardwareStateHeader->BasicSequencerOffset + 1;

    for (i = 1; i < VGA_NUM_SEQUENCER_PORTS; i++) {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT), (USHORT) (i + ((*portValue++) << 8)) );

    }

    //
    // Restore the Graphics Controller Miscellaneous register, which contains
    // the Chain bit.
    //

    portValue = ((PUCHAR) hardwareStateHeader) +
                hardwareStateHeader->BasicGraphContOffset + IND_GRAPH_MISC;

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), (USHORT)(IND_GRAPH_MISC + (*portValue << 8)));

    //
    // End sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT), (USHORT) (IND_SYNC_RESET +
            (END_SYNC_RESET_VALUE << 8)));

    //
    // Figure out if color/mono switchable registers are at 3BX or 3DX.
    // At the same time, save the state of the Miscellaneous Output register
    // which is read from 3CC but written at 3C2.
    //

    if (hardwareStateHeader->PortValue[MISC_OUTPUT_REG_WRITE_PORT] & 0x01) {
        bIsColor = TRUE;
    } else {
        bIsColor = FALSE;
    }


    //
    // Restore the CRT Controller indexed registers.
    //
    // Unlock CRTC registers 0-7.
    //

    portValue = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicCrtContOffset;

    if (bIsColor) {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_COLOR), (USHORT) (IND_CRTC_PROTECT +
                (((*(portValue + IND_CRTC_PROTECT)) & 0x7F) << 8)));

    } else {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_MONO), (USHORT) (IND_CRTC_PROTECT +
                (((*(portValue + IND_CRTC_PROTECT)) & 0x7F) << 8)));

    }


    //
    // Now restore the CRTC registers.
    //

    for (i = 0; i < VGA_NUM_CRTC_PORTS; i++) {

        if (bIsColor) {

            VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_COLOR),
                    (USHORT) (i + ((*portValue++) << 8)));

        } else {

            VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_MONO),
                    (USHORT) (i + ((*portValue++) << 8)));

        }

    }


    //
    // Restore the Graphics Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicGraphContOffset;

    for (i = 0; i < VGA_NUM_GRAPH_CONT_PORTS; i++) {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT), (USHORT) (i + ((*portValue++) << 8)));

    }


    //
    // Restore the Attribute Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicAttribContOffset;

    //
    // Reset the AC index/data toggle, then blast out all the register
    // settings.
    //

    if (bIsColor) {
        dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                INPUT_STATUS_1_COLOR);
    } else {
        dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                INPUT_STATUS_1_MONO);
    }

    for (i = 0; i < VGA_NUM_ATTRIB_CONT_PORTS; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT, (UCHAR) i);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_DATA_WRITE_PORT, *portValue++);

    }

}  // end of VgaStandardRegsRestore()


#if (_WIN32_WINNT >= 500)

//
// Routine to set a desired DPMS power management state.
//
VP_STATUS
QvSetPower50(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT pVideoPowerMgmt
    )
{
    if ((pVideoPowerMgmt->PowerState == VideoPowerOn) ||
        (pVideoPowerMgmt->PowerState == VideoPowerHibernate)) {

        return NO_ERROR;

    } else {

        return ERROR_INVALID_FUNCTION;
    }
}

//
// Routine to retrieve possible DPMS power management states.
//

VP_STATUS
QvGetPower50(
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT pVideoPowerMgmt
    )
{
    if ((pVideoPowerMgmt->PowerState == VideoPowerOn) ||
        (pVideoPowerMgmt->PowerState == VideoPowerHibernate)) {

        return NO_ERROR;

    } else {

        return ERROR_INVALID_FUNCTION;
    }
}


//
// Routine to retrieve the Enhanced Display ID structure via DDC
//
ULONG
QvGetVideoChildDescriptor(
    PVOID HwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pvChildDescriptor,
    PULONG pHwId,
    PULONG pUnused
    )
{
    PHW_DEVICE_EXTENSION pHwDeviceExtension = HwDeviceExtension;
    ULONG                Status;

    ASSERT(pHwDeviceExtension != NULL && pMoreChildren != NULL);

    VideoDebugPrint((2, "Qv.SYS QvGetVideoChildDescriptor: *** Entry point ***\n"));

    //
    // Determine if the graphics adapter in the system supports
    // DDC2 (our miniport only supports DDC2, not DDC1). This has
    // the side effect (assuming both monitor and card support
    // DDC2) of switching the monitor from DDC1 mode (repeated
    // "blind" broadcast of EDID clocked by the vertical sync
    // signal) to DDC2 mode (query/response not using any of the
    // normal video lines - can transfer information rapidly
    // without first disrupting the screen by switching into
    // a pseudo-mode with a high vertical sync frequency).
    //
    // Since we must support hot-plugging of monitors, and our
    // routine to obtain the EDID structure via DDC2 assumes that
    // the monitor is in DDC2 mode, we must make this test each
    // time this entry point is called.
    //

    switch (ChildEnumInfo->ChildIndex) {
    case 0:

        //
        // Case 0 is used to enumerate devices found by the ACPI firmware.
        //
        // Since we do not support ACPI devices yet, we must return failure.
        //

        Status = ERROR_NO_MORE_DEVICES;
        break;

    case 1:
        //
        // We do not support monitor enumeration
        //

        Status = ERROR_NO_MORE_DEVICES;
        break;

    case DISPLAY_ADAPTER_HW_ID:
        {

        PUSHORT     pPnpDeviceDescription = NULL;
        ULONG       stringSize = sizeof(L"*PNPXXXX");


        //
        // Special ID to handle return legacy PnP IDs for root enumerated
        // devices.
        //

        *pChildType = VideoChip;
        *pHwId      = DISPLAY_ADAPTER_HW_ID;

        //
        //  Figure out which card type and set pPnpDeviceDescription at
        //  associated string.
        //

        switch (pHwDeviceExtension->VideoChipInfo.ulControllerType) {

            case QRY_CONTROLLER_VICTORY:

                if (pHwDeviceExtension->VideoHardware.AdapterType == AriesIsa)
                    pPnpDeviceDescription = L"*PNP0910"; //1024/I

                else if (pHwDeviceExtension->VideoHardware.AdapterType == AriesEisa)
                    pPnpDeviceDescription = L"*CPQ3011"; // 1024/E
                else
                    {
                    VideoDebugPrint((1, "qv.sys controller type:%x\n",
                                     pHwDeviceExtension->VideoChipInfo.ulControllerType));
                    VideoDebugPrint((1, "qv.sys adapter type:%x\n",
                                     pHwDeviceExtension->VideoHardware.AdapterType));
                    }

                break;

            case QRY_CONTROLLER_V32:

                if (pHwDeviceExtension->VideoChipInfo.ulDACType != QRY_DAC_BT484) {

                    if (pHwDeviceExtension->VideoHardware.ulEisaID == EISA_ID_QVISION_E)
                        pPnpDeviceDescription = L"*CPQ3112"; // 1280E

                    else if (pHwDeviceExtension->VideoHardware.ulEisaID == EISA_ID_QVISION_I)
                        pPnpDeviceDescription = L"*CPQ3122"; // 1280I
                    else
                        {
                        VideoDebugPrint((1, "qv.sys controller type:%x\n",
                                         pHwDeviceExtension->VideoChipInfo.ulControllerType));
                        VideoDebugPrint((1, "qv.sys adapter type:%x\n",
                                         pHwDeviceExtension->VideoHardware.AdapterType));
                        }

                } else {

                    if (pHwDeviceExtension->VideoHardware.ulEisaID == EISA_ID_QVISION_I)
                        pPnpDeviceDescription = L"*PNP0910"; //1024/I
                    else
                        pPnpDeviceDescription = L"*CPQ3011"; // 1024/E
                }

                break;

            case QRY_CONTROLLER_V35:

                if (pHwDeviceExtension->VideoHardware.ulEisaID == EISA_ID_QVISION_E)
                    pPnpDeviceDescription = L"*CPQ3112"; // 1280E

                else if (pHwDeviceExtension->VideoHardware.ulEisaID == EISA_ID_QVISION_I)
                    pPnpDeviceDescription = L"*CPQ3122"; // 1280I

                else
                    {
                    VideoDebugPrint((1, "qv.sys controller type:%x\n",
                                     pHwDeviceExtension->VideoChipInfo.ulControllerType));
                    VideoDebugPrint((1, "qv.sys adapter type:%x\n",
                                     pHwDeviceExtension->VideoHardware.AdapterType));
                    }
                break;

            case QRY_CONTROLLER_V64:
                //is pci.
                break;

            default:
                VideoDebugPrint((1, "qv.sys controller type:%x\n",
                                 pHwDeviceExtension->VideoChipInfo.ulControllerType));
                break;

        } // switch

        //
        //  Now just copy the string into memory provided.
        //

        if (pPnpDeviceDescription)
            memcpy(pvChildDescriptor, pPnpDeviceDescription, stringSize);

        Status = ERROR_MORE_DATA;
        break;
        }

    default:

        Status = ERROR_NO_MORE_DEVICES;
        break;
    }


    return Status;
}

#endif  // _WIN32_WINNT >= 500


   // end of qvision.c module
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\framebuf\disp\driver.h ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: driver.h
*
* contains prototypes for the frame buffer driver.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\**************************************************************************/

#include "stddef.h"
#include <stdarg.h>
#include "windef.h"
#include "wingdi.h"
#include "winddi.h"
#include "devioctl.h"
#include "ntddvdeo.h"
#include "debug.h"

typedef struct  _PDEV
{
    HANDLE  hDriver;                    // Handle to \Device\Screen
    HDEV    hdevEng;                    // Engine's handle to PDEV
    HSURF   hsurfEng;                   // Engine's handle to surface
    HPALETTE hpalDefault;               // Handle to the default palette for device.
    PBYTE   pjScreen;                   // This is pointer to base screen address
    ULONG   cxScreen;                   // Visible screen width
    ULONG   cyScreen;                   // Visible screen height
    POINTL  ptlOrg;                     // Where this display is anchored in
                                        //   the virtual desktop.
    ULONG   ulMode;                     // Mode the mini-port driver is in.
    LONG    lDeltaScreen;               // Distance from one scan to the next.
    ULONG   cScreenSize;                // size of video memory, including
                                        // offscreen memory.
    PVOID   pOffscreenList;             // linked list of DCI offscreen surfaces.
    FLONG   flRed;                      // For bitfields device, Red Mask
    FLONG   flGreen;                    // For bitfields device, Green Mask
    FLONG   flBlue;                     // For bitfields device, Blue Mask
    ULONG   cPaletteShift;              // number of bits the 8-8-8 palette must
                                        // be shifted by to fit in the hardware
                                        // palette.
    ULONG   ulBitCount;                 // # of bits per pel 8,16,24,32 are only supported.
    POINTL  ptlHotSpot;                 // adjustment for pointer hot spot
    VIDEO_POINTER_CAPABILITIES PointerCapabilities; // HW pointer abilities
    PVIDEO_POINTER_ATTRIBUTES pPointerAttributes; // hardware pointer attributes
    DWORD   cjPointerAttributes;        // Size of buffer allocated
    BOOL    fHwCursorActive;            // Are we currently using the hw cursor
    PALETTEENTRY *pPal;                 // If this is pal managed, this is the pal
    BOOL    bSupportDCI;                // Does the miniport support DCI?
    FLONG   flHooks;
} PDEV, *PPDEV;

DWORD getAvailableModes(HANDLE, PVIDEO_MODE_INFORMATION *, DWORD *);
BOOL bInitPDEV(PPDEV, PDEVMODEW, GDIINFO *, DEVINFO *);
BOOL bInitSURF(PPDEV, BOOL);
BOOL bInitPaletteInfo(PPDEV, DEVINFO *);
BOOL bInitPointer(PPDEV, DEVINFO *);
BOOL bInit256ColorPalette(PPDEV);
VOID vDisablePalette(PPDEV);
VOID vDisableSURF(PPDEV);

#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * 256))

//
// Determines the size of the DriverExtra information in the DEVMODE
// structure passed to and from the display driver.
//

#define DRIVER_EXTRA_SIZE 0

#define DLL_NAME                L"framebuf"   // Name of the DLL in UNICODE
#define STANDARD_DEBUG_PREFIX   "FRAMEBUF: "  // All debug output is prefixed
#define ALLOC_TAG               'bfDD'        // Four byte tag (characters in
                                              // reverse order) used for memory
                                              // allocations
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\framebuf\disp\palette.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: palette.c
*
* Palette support.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

// Global Table defining the 20 Window Default Colors.        For 256 color
// palettes the first 10 must be put at the beginning of the palette
// and the last 10 at the end of the palette.

const PALETTEENTRY BASEPALETTE[20] =
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },       // 6
    { 0xC0,0xC0,0xC0,0 },       // 7
    { 192, 220, 192, 0 },       // 8
    { 166, 202, 240, 0 },       // 9
    { 255, 251, 240, 0 },       // 10
    { 160, 160, 164, 0 },       // 11
    { 0x80,0x80,0x80,0 },       // 12
    { 0xFF,0,   0   ,0 },       // 13
    { 0,   0xFF,0   ,0 },       // 14
    { 0xFF,0xFF,0   ,0 },       // 15
    { 0   ,0,   0xFF,0 },       // 16
    { 0xFF,0,   0xFF,0 },       // 17
    { 0,   0xFF,0xFF,0 },       // 18
    { 0xFF,0xFF,0xFF,0 },       // 19
};

BOOL bInitDefaultPalette(PPDEV ppdev, DEVINFO *pDevInfo);

/******************************Public*Routine******************************\
* bInitPaletteInfo
*
* Initializes the palette information for this PDEV.
*
* Called by DrvEnablePDEV.
*
\**************************************************************************/

BOOL bInitPaletteInfo(PPDEV ppdev, DEVINFO *pDevInfo)
{
    if (!bInitDefaultPalette(ppdev, pDevInfo))
        return(FALSE);

    return(TRUE);
}

/******************************Public*Routine******************************\
* vDisablePalette
*
* Frees resources allocated by bInitPaletteInfo.
*
\**************************************************************************/

VOID vDisablePalette(PPDEV ppdev)
{
// Delete the default palette if we created one.

    if (ppdev->hpalDefault)
    {
        EngDeletePalette(ppdev->hpalDefault);
        ppdev->hpalDefault = (HPALETTE) 0;
    }

    if (ppdev->pPal != (PPALETTEENTRY)NULL)
        EngFreeMem((PVOID)ppdev->pPal);
}

/******************************Public*Routine******************************\
* bInitDefaultPalette
*
* Initializes default palette for PDEV.
*
\**************************************************************************/

BOOL bInitDefaultPalette(PPDEV ppdev, DEVINFO *pDevInfo)
{
    if (ppdev->ulBitCount == 8)
    {
        ULONG ulLoop;
        BYTE jRed,jGre,jBlu;

        //
        // Allocate our palette
        //

        ppdev->pPal = (PPALETTEENTRY)EngAllocMem(0, sizeof(PALETTEENTRY) * 256,
                                                 ALLOC_TAG);

        if ((ppdev->pPal) == NULL) {
            RIP("DISP bInitDefaultPalette() failed EngAllocMem\n");
            return(FALSE);
        }

        //
        // Generate 256 (8*4*4) RGB combinations to fill the palette
        //

        jRed = jGre = jBlu = 0;

        for (ulLoop = 0; ulLoop < 256; ulLoop++)
        {
            ppdev->pPal[ulLoop].peRed   = jRed;
            ppdev->pPal[ulLoop].peGreen = jGre;
            ppdev->pPal[ulLoop].peBlue  = jBlu;
            ppdev->pPal[ulLoop].peFlags = (BYTE)0;

            if (!(jRed += 32))
            if (!(jGre += 32))
            jBlu += 64;
        }

        //
        // Fill in Windows Reserved Colors from the WIN 3.0 DDK
        // The Window Manager reserved the first and last 10 colors for
        // painting windows borders and for non-palette managed applications.
        //

        for (ulLoop = 0; ulLoop < 10; ulLoop++)
        {
            //
            // First 10
            //

            ppdev->pPal[ulLoop] = BASEPALETTE[ulLoop];

            //
            // Last 10
            //

            ppdev->pPal[246 + ulLoop] = BASEPALETTE[ulLoop+10];
        }

        //
        // Create handle for palette.
        //

        ppdev->hpalDefault =
        pDevInfo->hpalDefault = EngCreatePalette(PAL_INDEXED,
                                                   256,
                                                   (PULONG) ppdev->pPal,
                                                   0,0,0);

        if (ppdev->hpalDefault == (HPALETTE) 0)
        {
            RIP("DISP bInitDefaultPalette failed EngCreatePalette\n");
            EngFreeMem(ppdev->pPal);
            return(FALSE);
        }

        //
        // Initialize the hardware with the initial palette.
        //

        return(TRUE);

    } else {

        ppdev->hpalDefault =
        pDevInfo->hpalDefault = EngCreatePalette(PAL_BITFIELDS,
                                                   0,(PULONG) NULL,
                                                   ppdev->flRed,
                                                   ppdev->flGreen,
                                                   ppdev->flBlue);

        if (ppdev->hpalDefault == (HPALETTE) 0)
        {
            RIP("DISP bInitDefaultPalette failed EngCreatePalette\n");
            return(FALSE);
        }
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* bInit256ColorPalette
*
* Initialize the hardware's palette registers.
*
\**************************************************************************/

BOOL bInit256ColorPalette(PPDEV ppdev)
{
    BYTE        ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT pScreenClut;
    ULONG       ulReturnedDataLength;
    ULONG       cColors;
    PVIDEO_CLUTDATA pScreenClutData;

    if (ppdev->ulBitCount == 8)
    {
        //
        // Fill in pScreenClut header info:
        //

        pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
        pScreenClut->NumEntries = 256;
        pScreenClut->FirstEntry = 0;

        //
        // Copy colours in:
        //

        cColors = 256;
        pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

        while(cColors--)
        {
            pScreenClutData[cColors].Red =    ppdev->pPal[cColors].peRed >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Green =  ppdev->pPal[cColors].peGreen >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Blue =   ppdev->pPal[cColors].peBlue >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Unused = 0;
        }

        //
        // Set palette registers:
        //

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SET_COLOR_REGISTERS,
                               pScreenClut,
                               MAX_CLUT_SIZE,
                               NULL,
                               0,
                               &ulReturnedDataLength))
        {
            DISPDBG((0, "Failed bEnablePalette"));
            return(FALSE);
        }
    }

    DISPDBG((5, "Passed bEnablePalette"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* DrvSetPalette
*
* DDI entry point for manipulating the palette.
*
\**************************************************************************/

BOOL DrvSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BYTE            ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT     pScreenClut;
    PVIDEO_CLUTDATA pScreenClutData;
    PDEV*           ppdev;

    UNREFERENCED_PARAMETER(fl);

    ppdev = (PDEV*) dhpdev;

    //
    // Fill in pScreenClut header info:
    //

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = (USHORT) cColors;
    pScreenClut->FirstEntry = (USHORT) iStart;

    pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

    if (cColors != PALOBJ_cGetColors(ppalo, iStart, cColors,
                                     (ULONG*) pScreenClutData))
    {
        DISPDBG((0, "DrvSetPalette failed PALOBJ_cGetColors\n"));
        return (FALSE);
    }

    //
    // Set the high reserved byte in each palette entry to 0.
    // Do the appropriate palette shifting to fit in the DAC.
    //

    if (ppdev->cPaletteShift)
    {
        while(cColors--)
        {
            pScreenClutData[cColors].Red >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Green >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Blue >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Unused = 0;
        }
    }
    else
    {
        while(cColors--)
        {
            pScreenClutData[cColors].Unused = 0;
        }
    }

    //
    // Set palette registers
    //

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_SET_COLOR_REGISTERS,
                           pScreenClut,
                           MAX_CLUT_SIZE,
                           NULL,
                           0,
                           &cColors))
    {
        DISPDBG((0, "DrvSetPalette failed EngDeviceIoControl\n"));
        return (FALSE);
    }

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\framebuf\disp\pointer.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: pointer.c                                                   *
*                                                                          *
* This module contains the hardware Pointer support for the framebuffer    *
*                                                                          *
* Copyright (c) 1992-1998 Microsoft Corporation                            *
\**************************************************************************/

#include "driver.h"

BOOL bCopyColorPointer(
PPDEV ppdev,
SURFOBJ *psoMask,
SURFOBJ *psoColor,
XLATEOBJ *pxlo);

BOOL bCopyMonoPointer(
PPDEV ppdev,
SURFOBJ *psoMask);

BOOL bSetHardwarePointerShape(
SURFOBJ  *pso,
SURFOBJ  *psoMask,
SURFOBJ  *psoColor,
XLATEOBJ *pxlo,
LONG      x,
LONG      y,
FLONG     fl);

/******************************Public*Routine******************************\
* DrvMovePointer
*
* Moves the hardware pointer to a new position.
*
\**************************************************************************/

VOID DrvMovePointer
(
    SURFOBJ *pso,
    LONG     x,
    LONG     y,
    RECTL   *prcl
)
{
    PPDEV ppdev = (PPDEV) pso->dhpdev;
    DWORD returnedDataLength;
    VIDEO_POINTER_POSITION NewPointerPosition;

    // We don't use the exclusion rectangle because we only support
    // hardware Pointers. If we were doing our own Pointer simulations
    // we would want to update prcl so that the engine would call us
    // to exclude out pointer before drawing to the pixels in prcl.

    UNREFERENCED_PARAMETER(prcl);

    // Convert the pointer's position from relative to absolute
    // coordinates (this is only significant for multiple board
    // support).

    x -= ppdev->ptlOrg.x;
    y -= ppdev->ptlOrg.y;

    // If x is -1 after the offset then take down the cursor.

    if (x == -1)
    {
        //
        // A new position of (-1,-1) means hide the pointer.
        //

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_DISABLE_POINTER,
                               NULL,
                               0,
                               NULL,
                               0,
                               &returnedDataLength))
        {
            //
            // Not the end of the world, print warning in checked build.
            //

            DISPDBG((1, "DISP vMoveHardwarePointer failed IOCTL_VIDEO_DISABLE_POINTER\n"));
        }
    }
    else
    {
        NewPointerPosition.Column = (SHORT) x - (SHORT) (ppdev->ptlHotSpot.x);
        NewPointerPosition.Row    = (SHORT) y - (SHORT) (ppdev->ptlHotSpot.y);

        //
        // Call miniport driver to move Pointer.
        //

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SET_POINTER_POSITION,
                               &NewPointerPosition,
                               sizeof(VIDEO_POINTER_POSITION),
                               NULL,
                               0,
                               &returnedDataLength))
        {
            //
            // Not the end of the world, print warning in checked build.
            //

            DISPDBG((1, "DISP vMoveHardwarePointer failed IOCTL_VIDEO_SET_POINTER_POSITION\n"));
        }
    }
}

/******************************Public*Routine******************************\
* DrvSetPointerShape
*
* Sets the new pointer shape.
*
\**************************************************************************/

ULONG DrvSetPointerShape
(
    SURFOBJ  *pso,
    SURFOBJ  *psoMask,
    SURFOBJ  *psoColor,
    XLATEOBJ *pxlo,
    LONG      xHot,
    LONG      yHot,
    LONG      x,
    LONG      y,
    RECTL    *prcl,
    FLONG     fl
)
{
    PPDEV   ppdev = (PPDEV) pso->dhpdev;
    DWORD   returnedDataLength;

    // We don't use the exclusion rectangle because we only support
    // hardware Pointers. If we were doing our own Pointer simulations
    // we would want to update prcl so that the engine would call us
    // to exclude out pointer before drawing to the pixels in prcl.
    UNREFERENCED_PARAMETER(prcl);

    if (ppdev->pPointerAttributes == (PVIDEO_POINTER_ATTRIBUTES) NULL)
    {
        // Mini-port has no hardware Pointer support.
        return(SPS_ERROR);
    }

    // See if we are being asked to hide the pointer

    if (psoMask == (SURFOBJ *) NULL)
    {
        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_DISABLE_POINTER,
                               NULL,
                               0,
                               NULL,
                               0,
                               &returnedDataLength))
        {
            //
            // It should never be possible to fail.
            // Message supplied for debugging.
            //

            DISPDBG((1, "DISP bSetHardwarePointerShape failed IOCTL_VIDEO_DISABLE_POINTER\n"));
        }

        return(TRUE);
    }

    ppdev->ptlHotSpot.x = xHot;
    ppdev->ptlHotSpot.y = yHot;

    if (!bSetHardwarePointerShape(pso,psoMask,psoColor,pxlo,x,y,fl))
    {
            if (ppdev->fHwCursorActive) {
                ppdev->fHwCursorActive = FALSE;

                if (EngDeviceIoControl(ppdev->hDriver,
                                       IOCTL_VIDEO_DISABLE_POINTER,
                                       NULL,
                                       0,
                                       NULL,
                                       0,
                                       &returnedDataLength)) {

                    DISPDBG((1, "DISP bSetHardwarePointerShape failed IOCTL_VIDEO_DISABLE_POINTER\n"));
                }
            }

            //
            // Mini-port declines to realize this Pointer
            //

            return(SPS_DECLINE);
    }
    else
    {
        ppdev->fHwCursorActive = TRUE;
    }

    return(SPS_ACCEPT_NOEXCLUDE);
}

/******************************Public*Routine******************************\
* bSetHardwarePointerShape
*
* Changes the shape of the Hardware Pointer.
*
* Returns: True if successful, False if Pointer shape can't be hardware.
*
\**************************************************************************/

BOOL bSetHardwarePointerShape(
SURFOBJ  *pso,
SURFOBJ  *psoMask,
SURFOBJ  *psoColor,
XLATEOBJ *pxlo,
LONG      x,
LONG      y,
FLONG     fl)
{
    PPDEV     ppdev = (PPDEV) pso->dhpdev;
    PVIDEO_POINTER_ATTRIBUTES pPointerAttributes = ppdev->pPointerAttributes;
    DWORD     returnedDataLength;

    if (psoColor != (SURFOBJ *) NULL)
    {
        if ((ppdev->PointerCapabilities.Flags & VIDEO_MODE_COLOR_POINTER) &&
                bCopyColorPointer(ppdev, psoMask, psoColor, pxlo))
        {
            pPointerAttributes->Flags |= VIDEO_MODE_COLOR_POINTER;
        } else {
            return(FALSE);
        }

    } else {

        if ((ppdev->PointerCapabilities.Flags & VIDEO_MODE_MONO_POINTER) &&
                bCopyMonoPointer(ppdev, psoMask))
        {
            pPointerAttributes->Flags |= VIDEO_MODE_MONO_POINTER;
        } else {
            return(FALSE);
        }
    }

    //
    // Initialize Pointer attributes and position
    //

    pPointerAttributes->Enable = 1;

    //
    // if x,y = -1,-1 then pass them directly to the miniport so that
    // the cursor will be disabled

    pPointerAttributes->Column = (SHORT)(x);
    pPointerAttributes->Row    = (SHORT)(y);

    if ((x != -1) || (y != -1)) {
        pPointerAttributes->Column -= (SHORT)(ppdev->ptlHotSpot.x);
        pPointerAttributes->Row    -= (SHORT)(ppdev->ptlHotSpot.y);
    }

    //
    // set animate flags
    //

    if (fl & SPS_ANIMATESTART) {
        pPointerAttributes->Flags |= VIDEO_MODE_ANIMATE_START;
    } else if (fl & SPS_ANIMATEUPDATE) {
        pPointerAttributes->Flags |= VIDEO_MODE_ANIMATE_UPDATE;
    }

    //
    // Set the new Pointer shape.
    //

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_SET_POINTER_ATTR,
                           pPointerAttributes,
                           ppdev->cjPointerAttributes,
                           NULL,
                           0,
                           &returnedDataLength)) {

        DISPDBG((1, "DISP:Failed IOCTL_VIDEO_SET_POINTER_ATTR call\n"));
        return(FALSE);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* bCopyMonoPointer
*
* Copies two monochrome masks into a buffer of the maximum size handled by the
* miniport, with any extra bits set to 0.  The masks are converted to topdown
* form if they aren't already.  Returns TRUE if we can handle this pointer in
* hardware, FALSE if not.
*
\**************************************************************************/

BOOL bCopyMonoPointer(
    PPDEV    ppdev,
    SURFOBJ *pso)
{
    ULONG cy;
    PBYTE pjSrcAnd, pjSrcXor;
    LONG  lDeltaSrc, lDeltaDst;
    LONG  lSrcWidthInBytes;
    ULONG cxSrc = pso->sizlBitmap.cx;
    ULONG cySrc = pso->sizlBitmap.cy;
    ULONG cxSrcBytes;
    PVIDEO_POINTER_ATTRIBUTES pPointerAttributes = ppdev->pPointerAttributes;
    PBYTE pjDstAnd = pPointerAttributes->Pixels;
    PBYTE pjDstXor = pPointerAttributes->Pixels;

    // Make sure the new pointer isn't too big to handle
    // (*2 because both masks are in there)
    if ((cxSrc > ppdev->PointerCapabilities.MaxWidth) ||
        (cySrc > (ppdev->PointerCapabilities.MaxHeight * 2)))
    {
        return(FALSE);
    }

    pjDstXor += ((ppdev->PointerCapabilities.MaxWidth + 7) / 8) *
            ppdev->pPointerAttributes->Height;

    // set the desk and mask to 0xff
    RtlFillMemory(pjDstAnd, ppdev->pPointerAttributes->WidthInBytes *
            ppdev->pPointerAttributes->Height, 0xFF);

    // Zero the dest XOR mask
    RtlZeroMemory(pjDstXor, ppdev->pPointerAttributes->WidthInBytes *
            ppdev->pPointerAttributes->Height);

    cxSrcBytes = (cxSrc + 7) / 8;

    if ((lDeltaSrc = pso->lDelta) < 0)
    {
        lSrcWidthInBytes = -lDeltaSrc;
    } else {
        lSrcWidthInBytes = lDeltaSrc;
    }

    pjSrcAnd = (PBYTE) pso->pvBits;

    // If the incoming pointer bitmap is bottomup, we'll flip it to topdown to
    // save the miniport some work
    if (!(pso->fjBitmap & BMF_TOPDOWN))
    {
        // Copy from the bottom
        pjSrcAnd += lSrcWidthInBytes * (cySrc - 1);
    }

    // Height of just AND mask
    cySrc = cySrc / 2;

    // Point to XOR mask
    pjSrcXor = pjSrcAnd + (cySrc * lDeltaSrc);

    // Offset from end of one dest scan to start of next
    lDeltaDst = ppdev->pPointerAttributes->WidthInBytes;

    for (cy = 0; cy < cySrc; ++cy)
    {
        RtlCopyMemory(pjDstAnd, pjSrcAnd, cxSrcBytes);
        RtlCopyMemory(pjDstXor, pjSrcXor, cxSrcBytes);

        // Point to next source and dest scans
        pjSrcAnd += lDeltaSrc;
        pjSrcXor += lDeltaSrc;
        pjDstAnd += lDeltaDst;
        pjDstXor += lDeltaDst;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* bCopyColorPointer
*
* Copies the mono and color masks into the buffer of maximum size
* handled by the miniport with any extra bits set to 0. Color translation
* is handled at this time. The masks are converted to topdown form if they
* aren't already.  Returns TRUE if we can handle this pointer in  hardware,
* FALSE if not.
*
\**************************************************************************/
BOOL bCopyColorPointer(
PPDEV ppdev,
SURFOBJ *psoMask,
SURFOBJ *psoColor,
XLATEOBJ *pxlo)
{
    return(FALSE);
}


/******************************Public*Routine******************************\
* bInitPointer
*
* Initialize the Pointer attributes.
*
\**************************************************************************/

BOOL bInitPointer(PPDEV ppdev, DEVINFO *pdevinfo)
{
    DWORD    returnedDataLength;

    ppdev->pPointerAttributes = (PVIDEO_POINTER_ATTRIBUTES) NULL;
    ppdev->cjPointerAttributes = 0; // initialized in screen.c

    //
    // Ask the miniport whether it provides pointer support.
    //

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_QUERY_POINTER_CAPABILITIES,
                           &ppdev->ulMode,
                           sizeof(PVIDEO_MODE),
                           &ppdev->PointerCapabilities,
                           sizeof(ppdev->PointerCapabilities),
                           &returnedDataLength))
    {
         return(FALSE);
    }

    //
    // If neither mono nor color hardware pointer is supported, there's no
    // hardware pointer support and we're done.
    //

    if ((!(ppdev->PointerCapabilities.Flags & VIDEO_MODE_MONO_POINTER)) &&
        (!(ppdev->PointerCapabilities.Flags & VIDEO_MODE_COLOR_POINTER)))
    {
        return(TRUE);
    }

    //
    // Note: The buffer itself is allocated after we set the
    // mode. At that time we know the pixel depth and we can
    // allocate the correct size for the color pointer if supported.
    //

    //
    // Set the asynchronous support status (async means miniport is capable of
    // drawing the Pointer at any time, with no interference with any ongoing
    // drawing operation)
    //

    if (ppdev->PointerCapabilities.Flags & VIDEO_MODE_ASYNC_POINTER)
    {
       pdevinfo->flGraphicsCaps |= GCAPS_ASYNCMOVE;
    }
    else
    {
       pdevinfo->flGraphicsCaps &= ~GCAPS_ASYNCMOVE;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\framebuf\disp\enable.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: enable.c
*
* This module contains the functions that enable and disable the
* driver, the pdev, and the surface.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

// The driver function table with all function index/address pairs

static DRVFN gadrvfn[] =
{
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface      },
    {   INDEX_DrvOffset,                (PFN) DrvOffset             },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode         },
    {   INDEX_DrvSetPalette,            (PFN) DrvSetPalette         },
    {   INDEX_DrvMovePointer,           (PFN) DrvMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) DrvSetPointerShape    },
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor        },
    {   INDEX_DrvSynchronize,           (PFN) DrvSynchronize        },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes           }
};

// Define the functions you want to hook for 8/16/24/32 pel formats

#define HOOKS_BMF8BPP 0

#define HOOKS_BMF16BPP 0

#define HOOKS_BMF24BPP 0

#define HOOKS_BMF32BPP 0

/******************************Public*Routine******************************\
* DrvEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
\**************************************************************************/

BOOL DrvEnableDriver(
ULONG iEngineVersion,
ULONG cj,
PDRVENABLEDATA pded)
{
// Engine Version is passed down so future drivers can support previous
// engine versions.  A next generation driver can support both the old
// and new engine conventions if told what version of engine it is
// working with.  For the first version the driver does nothing with it.

    iEngineVersion;

// Fill in as much as we can.

    if (cj >= sizeof(DRVENABLEDATA))
        pded->pdrvfn = gadrvfn;

    if (cj >= (sizeof(ULONG) * 2))
        pded->c = sizeof(gadrvfn) / sizeof(DRVFN);

// DDI version this driver was targeted for is passed back to engine.
// Future graphic's engine may break calls down to old driver format.

    if (cj >= sizeof(ULONG))
        pded->iDriverVersion = DDI_DRIVER_VERSION_NT4;

    return(TRUE);
}

/******************************Public*Routine******************************\
* DrvEnablePDEV
*
* DDI function, Enables the Physical Device.
*
* Return Value: device handle to pdev.
*
\**************************************************************************/

DHPDEV DrvEnablePDEV(
DEVMODEW   *pDevmode,       // Pointer to DEVMODE
PWSTR       pwszLogAddress, // Logical address
ULONG       cPatterns,      // number of patterns
HSURF      *ahsurfPatterns, // return standard patterns
ULONG       cjGdiInfo,      // Length of memory pointed to by pGdiInfo
ULONG      *pGdiInfo,       // Pointer to GdiInfo structure
ULONG       cjDevInfo,      // Length of following PDEVINFO structure
DEVINFO    *pDevInfo,       // physical device information structure
HDEV        hdev,           // HDEV, used for callbacks
PWSTR       pwszDeviceName, // DeviceName - not used
HANDLE      hDriver)        // Handle to base driver
{
    GDIINFO GdiInfo;
    DEVINFO DevInfo;
    PPDEV   ppdev = (PPDEV) NULL;

    UNREFERENCED_PARAMETER(pwszLogAddress);
    UNREFERENCED_PARAMETER(pwszDeviceName);

    // Allocate a physical device structure.

    ppdev = (PPDEV) EngAllocMem(0, sizeof(PDEV), ALLOC_TAG);

    if (ppdev == (PPDEV) NULL)
    {
        RIP("DISP DrvEnablePDEV failed EngAllocMem\n");
        return((DHPDEV) 0);
    }

    memset(ppdev, 0, sizeof(PDEV));

    // Save the screen handle in the PDEV.

    ppdev->hDriver = hDriver;

    // Get the current screen mode information.  Set up device caps and devinfo.

    if (!bInitPDEV(ppdev, pDevmode, &GdiInfo, &DevInfo))
    {
        DISPDBG((0,"DISP DrvEnablePDEV failed\n"));
        goto error_free;
    }

    // Initialize the cursor information.

    if (!bInitPointer(ppdev, &DevInfo))
    {
        // Not a fatal error...
        DISPDBG((0, "DrvEnablePDEV failed bInitPointer\n"));
    }

    // Initialize palette information.

    if (!bInitPaletteInfo(ppdev, &DevInfo))
    {
        RIP("DrvEnablePDEV failed bInitPalette\n");
        goto error_free;
    }

    // Copy the devinfo into the engine buffer.

    memcpy(pDevInfo, &DevInfo, min(sizeof(DEVINFO), cjDevInfo));

    // Set the pdevCaps with GdiInfo we have prepared to the list of caps for this
    // pdev.

    memcpy(pGdiInfo, &GdiInfo, min(cjGdiInfo, sizeof(GDIINFO)));

    return((DHPDEV) ppdev);

    // Error case for failure.
error_free:
    EngFreeMem(ppdev);
    return((DHPDEV) 0);
}

/******************************Public*Routine******************************\
* DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV  hdev)
{
    ((PPDEV) dhpdev)->hdevEng = hdev;
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
\**************************************************************************/

VOID DrvDisablePDEV(
DHPDEV dhpdev)
{
    vDisablePalette((PPDEV) dhpdev);
    EngFreeMem(dhpdev);
}

/******************************Public*Routine******************************\
* VOID DrvOffset
*
* DescriptionText
*
\**************************************************************************/

BOOL DrvOffset(
SURFOBJ*    pso,
LONG        x,
LONG        y,
FLONG       flReserved)
{
    PDEV*   ppdev = (PDEV*) pso->dhpdev;

    // Add back last offset that we subtracted.  I could combine the next
    // two statements, but I thought this was more clear.  It's not
    // performance critical anyway.

    ppdev->pjScreen += ((ppdev->ptlOrg.y * ppdev->lDeltaScreen) +
                        (ppdev->ptlOrg.x * ((ppdev->ulBitCount+1) >> 3)));

    // Subtract out new offset

    ppdev->pjScreen -= ((y * ppdev->lDeltaScreen) +
                        (x * ((ppdev->ulBitCount+1) >> 3)));

    ppdev->ptlOrg.x = x;
    ppdev->ptlOrg.y = y;

    return(TRUE);
}

/******************************Public*Routine******************************\
* DrvEnableSurface
*
* Enable the surface for the device.  Hook the calls this driver supports.
*
* Return: Handle to the surface if successful, 0 for failure.
*
\**************************************************************************/

HSURF DrvEnableSurface(
DHPDEV dhpdev)
{
    PPDEV ppdev;
    HSURF hsurf;
    SIZEL sizl;
    ULONG ulBitmapType;
    FLONG flHooks;

    // Create engine bitmap around frame buffer.

    ppdev = (PPDEV) dhpdev;

    ppdev->ptlOrg.x = 0;
    ppdev->ptlOrg.y = 0;

    if (!bInitSURF(ppdev, TRUE))
    {
        DISPDBG((0, "DISP DrvEnableSurface failed bInitSURF\n"));
        return(FALSE);
    }

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    if (ppdev->ulBitCount == 8)
    {
        if (!bInit256ColorPalette(ppdev)) {
            RIP("DISP DrvEnableSurface failed to init the 8bpp palette\n");
            return(FALSE);
        }
        ulBitmapType = BMF_8BPP;
        flHooks = HOOKS_BMF8BPP;
    }
    else if (ppdev->ulBitCount == 16)
    {
        ulBitmapType = BMF_16BPP;
        flHooks = HOOKS_BMF16BPP;
    }
    else if (ppdev->ulBitCount == 24)
    {
        ulBitmapType = BMF_24BPP;
        flHooks = HOOKS_BMF24BPP;
    }
    else
    {
        ulBitmapType = BMF_32BPP;
        flHooks = HOOKS_BMF32BPP;
    }

    ppdev->flHooks = flHooks;

    hsurf = (HSURF)EngCreateDeviceSurface((DHSURF)ppdev, 
                                           sizl,
                                           ulBitmapType);

    if (hsurf == (HSURF) 0)
    {
        RIP("DISP DrvEnableSurface failed EngCreateDeviceSurface\n");
        return(FALSE);
    }

    if ( !EngModifySurface(hsurf,
                           ppdev->hdevEng,
                           ppdev->flHooks | HOOK_SYNCHRONIZE,
                           MS_NOTSYSTEMMEMORY,
                           (DHSURF)ppdev,
                           ppdev->pjScreen,
                           ppdev->lDeltaScreen,
                           NULL))
    {
        RIP("DISP DrvEnableSurface failed EngModifySurface\n");
        return(FALSE);
    }

    ppdev->hsurfEng = hsurf;

    return(hsurf);
}

/******************************Public*Routine******************************\
* DrvDisableSurface
*
* Free resources allocated by DrvEnableSurface.  Release the surface.
*
\**************************************************************************/

VOID DrvDisableSurface(
DHPDEV dhpdev)
{
    EngDeleteSurface(((PPDEV) dhpdev)->hsurfEng);
    vDisableSURF((PPDEV) dhpdev);
    ((PPDEV) dhpdev)->hsurfEng = (HSURF) 0;
}

/******************************Public*Routine******************************\
* DrvAssertMode
*
* This asks the device to reset itself to the mode of the pdev passed in.
*
\**************************************************************************/

BOOL DrvAssertMode(
DHPDEV dhpdev,
BOOL bEnable)
{
    PPDEV   ppdev = (PPDEV) dhpdev;
    ULONG   ulReturn;
    PBYTE   pjScreen;

    if (bEnable)
    {

        //
        // The screen must be reenabled, reinitialize the device to clean state.
        //

        pjScreen = ppdev->pjScreen;

        if (!bInitSURF(ppdev, TRUE))
        {
            RIP("DISP DrvAssertMode failed bInitSURF\n");
            return (FALSE);
        }

        if (pjScreen != ppdev->pjScreen) {

            if ( !EngModifySurface(ppdev->hsurfEng,
                                   ppdev->hdevEng,
                                   ppdev->flHooks | HOOK_SYNCHRONIZE,
                                   MS_NOTSYSTEMMEMORY,
                                   (DHSURF)ppdev,
                                   ppdev->pjScreen,
                                   ppdev->lDeltaScreen,
                                   NULL))
            {
                RIP("DISP DrvAssertMode failed EngModifySurface\n");
                return (FALSE);
            }
        }

        return (TRUE);
    }
    else
    {
        //
        // We must give up the display.
        // Call the kernel driver to reset the device to a known state.
        //

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_RESET_DEVICE,
                               NULL,
                               0,
                               NULL,
                               0,
                               &ulReturn))
        {
            RIP("DISP DrvAssertMode failed IOCTL");
            return FALSE;
        }
        else
        {
            return TRUE;
        }
    }
}

/******************************Public*Routine******************************\
* DrvGetModes
*
* Returns the list of available modes for the device.
*
\**************************************************************************/

ULONG DrvGetModes(
HANDLE hDriver,
ULONG cjSize,
DEVMODEW *pdm)

{

    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation, pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;

    DISPDBG((3, "DrvGetModes\n"));

    cModes = getAvailableModes(hDriver,
                               (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
                               &cbModeSize);

    if (cModes == 0)
    {
        DISPDBG((0, "DrvGetModes failed to get mode information"));
        return 0;
    }

    if (pdm == NULL)
    {
        cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
        //
        // Now copy the information for the supported modes back into the output
        // buffer
        //

        cbOutputSize = 0;

        pVideoTemp = pVideoModeInformation;

        do
        {
            if (pVideoTemp->Length != 0)
            {
                if (cOutputModes == 0)
                {
                    break;
                }

                //
                // Zero the entire structure to start off with.
                //

                memset(pdm, 0, sizeof(DEVMODEW));

                //
                // Set the name of the device to the name of the DLL.
                //

                memcpy(pdm->dmDeviceName, DLL_NAME, sizeof(DLL_NAME));

                pdm->dmSpecVersion      = DM_SPECVERSION;
                pdm->dmDriverVersion    = DM_SPECVERSION;
                pdm->dmSize             = sizeof(DEVMODEW);
                pdm->dmDriverExtra      = DRIVER_EXTRA_SIZE;

                pdm->dmBitsPerPel       = pVideoTemp->NumberOfPlanes *
                                          pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth        = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight       = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;
                pdm->dmDisplayFlags     = 0;

                pdm->dmFields           = DM_BITSPERPEL       |
                                          DM_PELSWIDTH        |
                                          DM_PELSHEIGHT       |
                                          DM_DISPLAYFREQUENCY |
                                          DM_DISPLAYFLAGS     ;

                //
                // Go to the next DEVMODE entry in the buffer.
                //

                cOutputModes--;

                pdm = (LPDEVMODEW) ( ((ULONG_PTR)pdm) + sizeof(DEVMODEW)
                                                     + DRIVER_EXTRA_SIZE);

                cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

            }

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                (((PUCHAR)pVideoTemp) + cbModeSize);

        } while (--cModes);
    }

    EngFreeMem(pVideoModeInformation);

    return cbOutputSize;

}

VOID DrvSynchronize(
IN DHPDEV dhpdev,
IN RECTL *prcl)
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\fsvga\drawscrn.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    drawscrn.c

Abstract:

    This is the console fullscreen driver for the VGA card.

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "fsvga.h"

#define COMMON_LVB_MASK (COMMON_LVB_GRID_HORIZONTAL |  \
                         COMMON_LVB_GRID_LVERTICAL  |  \
                         COMMON_LVB_GRID_RVERTICAL  |  \
                         COMMON_LVB_REVERSE_VIDEO   |  \
                         COMMON_LVB_UNDERSCORE      )

/* ----- Macros -----*/
/*++
    Macro Description:
        This Macro calcurate a scan line in graphics buffer.

    Arguments:
        WindowY        - Coord to Y.
        FontSizeY      - Font size of Y.

    Return Value:
        Returen to graphics buffer offset.
--*/
#define CalcGRAMScanLine(WindowY,FontSizeY) \
    (WindowY * FontSizeY)

/*++
    Macro Description:
        This Macro calcurate a graphics buffer offset.

    Arguments:
        WindowSize - Coord of window size.
        DeviceExtension - Pointer to the miniport driver's device extension.

    Return Value:
        Returen to graphics buffer offset.
--*/
#define CalcGRAMOffs(WindowSize,ScreenIfno,EmulateInfo) \
    (EmulateInfo->StartAddress + \
     CalcGRAMSize(WindowSize,ScreenInfo,EmulateInfo) \
    )

/*++
    Macro Description:
        This Macro gets the byte per one scan line.

    Arguments:
        EmulateInfo - Pointer to screen emualte information structure.

    Return Value:
        Byte pre line number.
--*/
#define GetBytePerLine(HardwareScroll) \
    ((HardwareScroll & OFFSET_128_TO_NEXT_SLICE) ? \
     (1024 / 8) : \
     (640 / 8) \
    )



ULONG
CalcGRAMSize(
    IN COORD WindowSize,
    IN PFSVIDEO_SCREEN_INFORMATION ScreenInfo,
    IN PEMULATE_BUFFER_INFORMATION EmulateInfo
    )

/*++

Routine Description:

    This Macro calcurate a graphics buffer size.

Arguments:

    WindowSize - Coord of window size.

    DeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    Returen to graphics buffer offset.

--*/

{
    return WindowSize.X +
           CalcGRAMScanLine(WindowSize.Y, ScreenInfo->FontSize.Y) *
           EmulateInfo->BytePerLine;
}


PUCHAR
CalcGRAMAddress(
    IN COORD WindowSize,
    IN PFSVIDEO_MODE_INFORMATION VideoModeInfo,
    IN PFSVIDEO_SCREEN_INFORMATION ScreenInfo,
    IN PEMULATE_BUFFER_INFORMATION EmulateInfo
    )

/*++

Routine Description:

    This routine calcurate a graphics buffer address.

Arguments:

    WindowSize - Coord of window size.

    DeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    Returen to graphics buffer address.

--*/
{
    PUCHAR BufPtr = (PUCHAR)VideoModeInfo->VideoMemory.FrameBufferBase;

    BufPtr += CalcGRAMOffs(WindowSize, ScreenInfo, EmulateInfo);
    if ((ULONG)(BufPtr -
                (PUCHAR)VideoModeInfo->VideoMemory.FrameBufferBase)
           >= EmulateInfo->LimitGRAM)
        return (BufPtr - EmulateInfo->LimitGRAM);
    else
        return BufPtr;
}


#ifdef LATER_HIGH_SPPED_VRAM_ACCESS  // kazum
BOOLEAN
IsGRAMRowOver(
    PUCHAR BufPtr,
    BOOLEAN fDbcs,
    IN PFSVIDEO_MODE_INFORMATION VideoModeInfo,
    IN PEMULATE_BUFFER_INFORMATION EmulateInfo
    )

/*++

Routine Description:

    This Routine check ROW overflow as GRAM limit line.

Arguments:

    BufPtr - Pointer to graphics buffer.

    fDbcs - Flag of DBCS(true) or SBCS(false).

Return Value:
    TRUE:  if font box is overflow as GRAMlimit line.
    FALSE: not overflow.

--*/

{
    if (fDbcs)
    {
        if ((ULONG)(BufPtr + 1 +
                    EmulateInfo->DeltaNextFontRow -
                    (PUCHAR)VideoModeInfo->VideoMemory.FrameBufferBase)
             >= EmulateInfo->LimitGRAM)
            return TRUE;
        else
            return FALSE;
    }
    else
    {
        if ((ULONG)(BufPtr +
                    EmulateInfo->DeltaNextFontRow -
                    (PUCHAR)VideoModeInfo->VideoMemory.FrameBufferBase)
             >= EmulateInfo->LimitGRAM)
            return TRUE;
        else
            return FALSE;
    }
}
#endif // LATER_HIGH_SPPED_VRAM_ACCESS  // kazum

PUCHAR
NextGRAMRow(
    PUCHAR BufPtr,
    IN PFSVIDEO_MODE_INFORMATION VideoModeInfo,
    IN PEMULATE_BUFFER_INFORMATION EmulateInfo
    )

/*++

Routine Description:
    This Routine add next row a graphics buffer address.

Arguments:

    BufPtr - Pointer to graphics buffer.

Return Value:

    Returen to graphics buffer address.

--*/

{
    if ((ULONG)(BufPtr +
                EmulateInfo->BytePerLine -
                (PUCHAR)VideoModeInfo->VideoMemory.FrameBufferBase)
           >= EmulateInfo->LimitGRAM)
        return (BufPtr +
                EmulateInfo->BytePerLine -
                EmulateInfo->LimitGRAM);
    else
        return (BufPtr + EmulateInfo->BytePerLine);
}

VOID
memcpyGRAM(
    IN PCHAR TargetPtr,
    IN PCHAR SourcePtr,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine is a memory copy for byte order.

Arguments:

    TargetPtr - Pointer to target graphics buffer.

    SourcePtr - Pointer to source graphics buffer.

    Length - Fill length.

Return Value:

--*/

{
    while (Length--)
        *TargetPtr++ = *SourcePtr++;
}

VOID
memcpyGRAMOver(
    IN PCHAR TargetPtr,
    IN PCHAR SourcePtr,
    IN ULONG Length,
    IN PUCHAR FrameBufPtr,
    IN PEMULATE_BUFFER_INFORMATION EmulateInfo
    )

/*++

Routine Description:

    This routine move a graphics buffer.

Arguments:

    TargetPtr - Pointer to target graphics buffer.

    SourcePtr - Pointer to source graphics buffer.

    Length - Fill length.

Return Value:

--*/

{
    ULONG tmpLen;

    if ((ULONG)(SourcePtr + Length - FrameBufPtr) >= EmulateInfo->LimitGRAM) {
        tmpLen = EmulateInfo->LimitGRAM - (SourcePtr - FrameBufPtr);
        memcpyGRAM(TargetPtr, SourcePtr, tmpLen);
        TargetPtr += tmpLen;
        Length -= tmpLen;
        SourcePtr = FrameBufPtr;
    }

    if ((ULONG)(TargetPtr + Length - FrameBufPtr) >= EmulateInfo->LimitGRAM) {
        tmpLen = EmulateInfo->LimitGRAM - (TargetPtr - FrameBufPtr);
        memcpyGRAM(TargetPtr, SourcePtr, tmpLen);
        SourcePtr += tmpLen;
        Length -= tmpLen;
        TargetPtr = FrameBufPtr;
    }

    if (Length) {
        memcpyGRAM(TargetPtr, SourcePtr, Length);
    }
}

VOID
MoveGRAM(
    IN PCHAR TargetPtr,
    IN PCHAR SourcePtr,
    IN ULONG Length,
    IN PUCHAR FrameBufPtr,
    IN PFSVGA_RESOURCE_INFORMATION ResourceInfo,
    IN PEMULATE_BUFFER_INFORMATION EmulateInfo
    )

/*++

Routine Description:

    This routine move a graphics buffer.

Arguments:

    TargetPtr - Pointer to target graphics buffer.

    SourcePtr - Pointer to source graphics buffer.

    Length - Fill length.

Return Value:

    none.

--*/
{
    PCHAR tmpSrc;
    PCHAR tmpTrg;
    ULONG tmpLen;

    //
    // Set copy mode of graphics register
    //

    SetGRAMCopyMode(ResourceInfo->PortList);

    if ((ULONG)(SourcePtr + Length - FrameBufPtr) >= EmulateInfo->LimitGRAM ||
        (ULONG)(TargetPtr + Length - FrameBufPtr) >= EmulateInfo->LimitGRAM    ) {
        if (SourcePtr > TargetPtr) {
            memcpyGRAMOver(TargetPtr,SourcePtr,Length,FrameBufPtr,EmulateInfo);
        }
        else if ((ULONG)(TargetPtr - SourcePtr) >= Length) {
            memcpyGRAMOver(TargetPtr,SourcePtr,Length,FrameBufPtr,EmulateInfo);
        }
        else {
            if ((ULONG)(SourcePtr + Length - FrameBufPtr) >= EmulateInfo->LimitGRAM) {
                tmpLen = SourcePtr + Length - FrameBufPtr - EmulateInfo->LimitGRAM;
                tmpTrg = TargetPtr + Length - tmpLen - EmulateInfo->LimitGRAM;
                memcpyGRAM(tmpTrg, FrameBufPtr, tmpLen);
                Length -= tmpLen;
            }
            if ((ULONG)(TargetPtr + Length - FrameBufPtr) >= EmulateInfo->LimitGRAM) {
                tmpLen = TargetPtr + Length - FrameBufPtr - EmulateInfo->LimitGRAM;
                tmpSrc = SourcePtr + Length - tmpLen;
                memcpyGRAM(FrameBufPtr, tmpSrc, tmpLen);
                Length -= tmpLen;
            }
            if (Length) {
                memcpyGRAM(TargetPtr, SourcePtr, Length);
            }
        }
    }
    else {
        memcpyGRAM(TargetPtr, SourcePtr, Length);
    }

    SetGRAMWriteMode(ResourceInfo->PortList);
}


NTSTATUS
FsgVgaInitializeHWFlags(
    PDEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    This routine initialize the hardware scrolls flag and any values.

Arguments:

    EmulateInfo - Pointer to screen emulate information structure.

Return Value:

--*/

{
    ULONG Index;

    GetHardwareScrollReg(DeviceExtension->Resource.PortList,
                         &DeviceExtension->EmulateInfo);
    DeviceExtension->EmulateInfo.BytePerLine =
        (USHORT)GetBytePerLine(Globals.Configuration.HardwareScroll);
    DeviceExtension->EmulateInfo.MaxScanLine =
        (USHORT)CalcGRAMScanLine(DeviceExtension->ScreenAndFont.ScreenSize.Y,
                               DeviceExtension->ScreenAndFont.FontSize.Y);
    DeviceExtension->EmulateInfo.DeltaNextFontRow =
        DeviceExtension->EmulateInfo.BytePerLine * DeviceExtension->ScreenAndFont.FontSize.Y;

    if (Globals.Configuration.HardwareScroll & USE_LINE_COMPARE) {
        DeviceExtension->EmulateInfo.LimitGRAM =
            DeviceExtension->EmulateInfo.MaxScanLine * DeviceExtension->EmulateInfo.BytePerLine;
    }
    else {
        DeviceExtension->EmulateInfo.LimitGRAM = LIMIT_64K;
    }

    DeviceExtension->EmulateInfo.ColorFg = (UCHAR)-1;
    DeviceExtension->EmulateInfo.ColorBg = (UCHAR)-1;

    DeviceExtension->EmulateInfo.CursorAttributes.Enable = 0;
    DeviceExtension->EmulateInfo.ShowCursor = FALSE;

    SetGRAMWriteMode(DeviceExtension->Resource.PortList);

    return STATUS_SUCCESS;
}

NTSTATUS
FsgCopyFrameBuffer(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_COPY_FRAME_BUFFER CopyFrameBuffer,
    ULONG inputBufferLength
    )

/*++

Routine Description:

    This routine copy the frame buffer.

Arguments:

    DeviceExtension - Pointer to the miniport driver's device extension.

    CopyFrameBuffer - Pointer to the structure containing the information about the copy frame buffer.

    inputBufferLength - Length of the input buffer supplied by the user.

Return Value:

    STATUS_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    STATUS_SUCCESS if the operation completed successfully.

--*/

{
    PUCHAR SourcePtr, TargetPtr;

    FsgInvertCursor(DeviceExtension,FALSE);

    SourcePtr = CalcGRAMAddress (CopyFrameBuffer->SrcScreen.Position,
                                 &DeviceExtension->CurrentMode,
                                 &DeviceExtension->ScreenAndFont,
                                 &DeviceExtension->EmulateInfo);
    TargetPtr = CalcGRAMAddress (CopyFrameBuffer->DestScreen.Position,
                                 &DeviceExtension->CurrentMode,
                                 &DeviceExtension->ScreenAndFont,
                                 &DeviceExtension->EmulateInfo);
    MoveGRAM (TargetPtr,
              SourcePtr,
              CopyFrameBuffer->SrcScreen.nNumberOfChars *
                  DeviceExtension->ScreenAndFont.FontSize.Y,
              DeviceExtension->CurrentMode.VideoMemory.FrameBufferBase,
              &DeviceExtension->Resource,
              &DeviceExtension->EmulateInfo
             );

    FsgInvertCursor(DeviceExtension,TRUE);

    return STATUS_SUCCESS;
}

NTSTATUS
FsgWriteToFrameBuffer(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_WRITE_TO_FRAME_BUFFER WriteFrameBuffer,
    ULONG inputBufferLength
    )

/*++

Routine Description:

    This routine write the frame buffer.

Arguments:

    DeviceExtension - Pointer to the miniport driver's device extension.

    WriteFrameBuffer - Pointer to the structure containing the information about the write frame buffer.

    inputBufferLength - Length of the input buffer supplied by the user.

Return Value:

    STATUS_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    STATUS_SUCCESS if the operation completed successfully.

--*/

{
    PCHAR_IMAGE_INFO pCharInfoUni = WriteFrameBuffer->SrcBuffer;
    PUCHAR TargetPtr;
    COORD Position = WriteFrameBuffer->DestScreen.Position;
    ULONG Length = WriteFrameBuffer->DestScreen.nNumberOfChars;
    COORD FontSize1 = DeviceExtension->ScreenAndFont.FontSize;
    COORD FontSize2;
    PVOID pCapBuffer = NULL;
    ULONG cCapBuffer = 0;
    BOOLEAN  fDbcs = FALSE;
    NTSTATUS Status;

    FsgInvertCursor(DeviceExtension,FALSE);

    DeviceExtension->EmulateInfo.ColorFg = (UCHAR)-1;
    DeviceExtension->EmulateInfo.ColorBg = (UCHAR)-1;

    FontSize2 = FontSize1;
    FontSize2.X *= 2;
    cCapBuffer = CalcBitmapBufferSize(FontSize2,BYTE_ALIGN);
    pCapBuffer = ExAllocatePool(PagedPool, cCapBuffer);

    while (Length--)
    {
        if (pCharInfoUni->FontImageInfo.ImageBits != NULL)
        {
            try
            {
                fDbcs = (BOOLEAN)(!!(pCharInfoUni->CharInfo.Attributes & COMMON_LVB_SBCSDBCS));
                AlignCopyMemory((PVOID)pCapBuffer,                    // pDestBits
                                BYTE_ALIGN,                           // dwDestAlign
                                pCharInfoUni->FontImageInfo.ImageBits,// pSrcBits
                                WORD_ALIGN,                           // dwSrcAlign
                                fDbcs ? FontSize2 : FontSize1);

                TargetPtr = CalcGRAMAddress (Position,
                                             &DeviceExtension->CurrentMode,
                                             &DeviceExtension->ScreenAndFont,
                                             &DeviceExtension->EmulateInfo);
                if (fDbcs)
                {
                    if (Length)
                    {
                        FsgWriteToScreen(TargetPtr, pCapBuffer, 2, fDbcs,
                                         pCharInfoUni->CharInfo.Attributes,
                                         (pCharInfoUni+1)->CharInfo.Attributes,
                                         DeviceExtension);
                    }
                    else
                    {
                        FsgWriteToScreen(TargetPtr, pCapBuffer, 2, FALSE,
                                         pCharInfoUni->CharInfo.Attributes,
                                         (USHORT)-1,
                                         DeviceExtension);
                    }
                }
                else
                {
                    FsgWriteToScreen(TargetPtr, pCapBuffer, 1, fDbcs,
                                     pCharInfoUni->CharInfo.Attributes,
                                     (USHORT)-1,
                                     DeviceExtension);
                }

            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
            }

        }

        if (fDbcs && Length)
        {
            Length--;
            Position.X += 2;
            pCharInfoUni += 2;
        }
        else
        {
            Position.X++;
            pCharInfoUni++;
        }
    }

    FsgInvertCursor(DeviceExtension,TRUE);

    if (pCapBuffer != NULL)
        ExFreePool(pCapBuffer);

    return STATUS_SUCCESS;
}

NTSTATUS
FsgReverseMousePointer(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_REVERSE_MOUSE_POINTER MouseBuffer,
    ULONG inputBufferLength
    )

/*++

Routine Description:

    This routine reverse the frame buffer for mouse pointer.

Arguments:

    DeviceExtension - Pointer to the miniport driver's device extension.

    MouseBuffer - Pointer to the structure containing the information about the mouse frame buffer.

    inputBufferLength - Length of the input buffer supplied by the user.

Return Value:

    STATUS_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    STATUS_SUCCESS if the operation completed successfully.

--*/

{

    PUCHAR CurFrameBufPtr;
    COORD  CursorPosition;
    COORD  FontSize;
    SHORT  i;
    BOOLEAN   fOneMore = FALSE;

    FsgInvertCursor(DeviceExtension,FALSE);

    FontSize = DeviceExtension->ScreenAndFont.FontSize;

    CursorPosition.X = MouseBuffer->Screen.Position.X;
    CursorPosition.Y = MouseBuffer->Screen.Position.Y;
    if ( (0 <= CursorPosition.X &&
               CursorPosition.X < MouseBuffer->Screen.ScreenSize.X) &&
         (0 <= CursorPosition.Y &&
               CursorPosition.Y < MouseBuffer->Screen.ScreenSize.Y)    )
    {
        switch (MouseBuffer->dwType)
        {
            case CHAR_TYPE_LEADING:
                if (CursorPosition.X != MouseBuffer->Screen.ScreenSize.X-1)
                {
                    fOneMore = TRUE;
                }
                break;
            case CHAR_TYPE_TRAILING:
                if (CursorPosition.X != 0)
                {
                    fOneMore = TRUE;
                    CursorPosition.X--;
                }
                break;
        }

        CurFrameBufPtr = CalcGRAMAddress (CursorPosition,
                                          &DeviceExtension->CurrentMode,
                                          &DeviceExtension->ScreenAndFont,
                                          &DeviceExtension->EmulateInfo);

        //
        // Set invert mode of graphics register
        //
        SetGRAMInvertMode(DeviceExtension->Resource.PortList);

        /*
         * CursorAttributes.Width is bottom scan lines.
         */
        for (i=0 ; i < FontSize.Y; i++)
        {
            AccessGRAM_AND(CurFrameBufPtr, (UCHAR)-1);
            if (fOneMore)
                AccessGRAM_AND(CurFrameBufPtr+1, (UCHAR)-1);
            CurFrameBufPtr = NextGRAMRow(CurFrameBufPtr,
                                         &DeviceExtension->CurrentMode,
                                         &DeviceExtension->EmulateInfo);
        }

        SetGRAMWriteMode(DeviceExtension->Resource.PortList);
    }

    FsgInvertCursor(DeviceExtension,TRUE);

    return STATUS_SUCCESS;
}

NTSTATUS
FsgInvertCursor(
    PDEVICE_EXTENSION DeviceExtension,
    BOOLEAN Invert
    )

/*++

Routine Description:

    This routine inverts the cursor.

Arguments:

    DeviceExtension - Pointer to the miniport driver's device extension.

    Invert - 

Return Value:

    STATUS_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    STATUS_SUCCESS if the operation completed successfully.

--*/

{
    PUCHAR CurFrameBufPtr;
    COORD  CursorPosition;
    COORD  FontSize;
    SHORT  i;
    SHORT  TopScanLine;
    BOOLEAN   fOneMore = FALSE;

    if (DeviceExtension->EmulateInfo.ShowCursor == Invert)
        return STATUS_SUCCESS;

    DeviceExtension->EmulateInfo.ShowCursor = Invert;

    if (!(DeviceExtension->EmulateInfo.CursorAttributes.Enable))
        return STATUS_SUCCESS;

    FontSize = DeviceExtension->ScreenAndFont.FontSize;
    if (DeviceExtension->ScreenAndFont.ScreenSize.Y > 25)
    {
        TopScanLine = ((DeviceExtension->EmulateInfo.CursorAttributes.Height + 8) * 100 / 8) - 100;
    }
    else
    {
        TopScanLine = ((DeviceExtension->EmulateInfo.CursorAttributes.Height + 16) * 100 / 16) - 100;
    }
    TopScanLine = (FontSize.Y * TopScanLine) / 100;

    CursorPosition.X = DeviceExtension->EmulateInfo.CursorPosition.Coord.Column;
    CursorPosition.Y = DeviceExtension->EmulateInfo.CursorPosition.Coord.Row;
    if ( (0 <= CursorPosition.X &&
               CursorPosition.X < DeviceExtension->ScreenAndFont.ScreenSize.X) &&
         (0 <= CursorPosition.Y &&
               CursorPosition.Y < DeviceExtension->ScreenAndFont.ScreenSize.Y)    )
    {
        switch (DeviceExtension->EmulateInfo.CursorPosition.dwType)
        {
            case CHAR_TYPE_LEADING:
                if (CursorPosition.X != DeviceExtension->ScreenAndFont.ScreenSize.X-1)
                {
                    fOneMore = TRUE;
                }
                break;
            case CHAR_TYPE_TRAILING:
                if (CursorPosition.X != 0)
                {
                    fOneMore = TRUE;
                    CursorPosition.X--;
                }
                break;
        }

        CurFrameBufPtr = CalcGRAMAddress (CursorPosition,
                                          &DeviceExtension->CurrentMode,
                                          &DeviceExtension->ScreenAndFont,
                                          &DeviceExtension->EmulateInfo);

        /*
         * CursorAttributes.Height is top scan lines.
         */
        for (i = 0; i < TopScanLine; i++)
        {
            CurFrameBufPtr = NextGRAMRow(CurFrameBufPtr,
                                         &DeviceExtension->CurrentMode,
                                         &DeviceExtension->EmulateInfo);
        }

        //
        // Set invert mode of graphics register
        //
        SetGRAMInvertMode(DeviceExtension->Resource.PortList);

        /*
         * CursorAttributes.Width is bottom scan lines.
         */
        for ( ; i < FontSize.Y; i++)
        {
            AccessGRAM_AND(CurFrameBufPtr, (UCHAR)-1);
            if (fOneMore) {
                AccessGRAM_AND(CurFrameBufPtr+1, (UCHAR)-1);
            }
            CurFrameBufPtr = NextGRAMRow(CurFrameBufPtr,
                                         &DeviceExtension->CurrentMode,
                                         &DeviceExtension->EmulateInfo);
        }

        SetGRAMWriteMode(DeviceExtension->Resource.PortList);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FsgWriteToScreen(
    PUCHAR FrameBuffer,
    PUCHAR BitmapBuffer,
    ULONG cjBytes,
    BOOLEAN fDbcs,
    USHORT Attributes1,
    USHORT Attributes2,
    PDEVICE_EXTENSION DeviceExtension
    )
{
    USHORT  Index;
    PCHAR CurFrameBufPtrTmp;
    PCHAR CurFrameBufPtr2nd;
    PUSHORT CurFrameBufPtrWord;
    PUCHAR BitmapBufferTmp;

#ifdef LATER_HIGH_SPPED_VRAM_ACCESS  // kazum
    if (! IsGRAMRowOver(FrameBuffer,fDBCS,DeviceExtension)) {
        if (!fDbcs) {
            if (cjBytes == 2)
                BitmapBuffer++;
            (*WriteGramInfo->pfnWriteFontToByteGRAM)(WriteGramInfo);
        }
        else if (cjBytes == 2 && fDBCS) {
            if (DeviceExtension->Configuration.EmulationMode & ENABLE_WORD_WRITE_VRAM) {
                (*WriteGramInfo->pfnWriteFontToFirstWordGRAM)(WriteGramInfo);
            }
            else {
               (*WriteGramInfo->pfnWriteFontToWordGRAM)(WriteGramInfo);
            }
        }
    }
    else
#endif // LATER_HIGH_SPPED_VRAM_ACCESS  // kazum
    try
    {
        set_opaque_bkgnd_proc(DeviceExtension->Resource.PortList,
                              &DeviceExtension->EmulateInfo,
                              FrameBuffer,Attributes1);

        if (!fDbcs) {
            CurFrameBufPtrTmp = FrameBuffer;
            if (cjBytes == 2)
                BitmapBuffer++;
            for (Index=0; Index < DeviceExtension->ScreenAndFont.FontSize.Y; Index++) {
                *CurFrameBufPtrTmp = *BitmapBuffer;
                BitmapBuffer += cjBytes;
                CurFrameBufPtrTmp=NextGRAMRow(CurFrameBufPtrTmp,
                                              &DeviceExtension->CurrentMode,
                                              &DeviceExtension->EmulateInfo);
            }
        }
        else if (cjBytes == 2 && fDbcs) {
            if ((Globals.Configuration.EmulationMode & ENABLE_WORD_WRITE_VRAM) &&
                !((ULONG)FrameBuffer & 1) &&
                (Attributes2 != -1) &&
                (Attributes1 == Attributes2)
               ) {
                CurFrameBufPtrWord = (PUSHORT)FrameBuffer;
                for (Index=0; Index < DeviceExtension->ScreenAndFont.FontSize.Y; Index++) {
                    *CurFrameBufPtrWord = *((PUSHORT)BitmapBuffer);
                    BitmapBuffer += cjBytes;
                    CurFrameBufPtrWord=(PUSHORT)NextGRAMRow((PCHAR)CurFrameBufPtrWord,
                                                            &DeviceExtension->CurrentMode,
                                                            &DeviceExtension->EmulateInfo);
                }
            }
            else {
                CurFrameBufPtrTmp = FrameBuffer;
                CurFrameBufPtr2nd = FrameBuffer + 1;
                BitmapBufferTmp = BitmapBuffer + 1;
                for (Index=0; Index < DeviceExtension->ScreenAndFont.FontSize.Y; Index++) {
                    *CurFrameBufPtrTmp = *BitmapBuffer;
                    BitmapBuffer += cjBytes;
                    CurFrameBufPtrTmp=NextGRAMRow(CurFrameBufPtrTmp,
                                                  &DeviceExtension->CurrentMode,
                                                  &DeviceExtension->EmulateInfo);
                }
                if (Attributes2 != -1 &&
                    Attributes1 != Attributes2) {
                    set_opaque_bkgnd_proc(DeviceExtension->Resource.PortList,
                                          &DeviceExtension->EmulateInfo,
                                          FrameBuffer,Attributes2);
                }
                for (Index=0; Index < DeviceExtension->ScreenAndFont.FontSize.Y; Index++) {
                    *CurFrameBufPtr2nd = *BitmapBufferTmp;
                    BitmapBufferTmp += cjBytes;
                    CurFrameBufPtr2nd=NextGRAMRow(CurFrameBufPtr2nd,
                                                  &DeviceExtension->CurrentMode,
                                                  &DeviceExtension->EmulateInfo);
                }
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
    }

    if (Attributes1 & COMMON_LVB_MASK)
    {
        FsgWriteToScreenCommonLVB(FrameBuffer,
                                  Attributes1,
                                  DeviceExtension);
    }
    if ((Attributes2 != (USHORT)-1) && (Attributes2 & COMMON_LVB_MASK))
    {
        FsgWriteToScreenCommonLVB(FrameBuffer+1,
                                  Attributes2,
                                  DeviceExtension);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FsgWriteToScreenCommonLVB(
    PUCHAR FrameBuffer,
    USHORT Attributes,
    PDEVICE_EXTENSION DeviceExtension
    )
{
    USHORT Index;
    PUCHAR CurFrameBufPtrTmp;

    try
    {
        if (Attributes & COMMON_LVB_UNDERSCORE)
        {
            set_opaque_bkgnd_proc(DeviceExtension->Resource.PortList,
                                  &DeviceExtension->EmulateInfo,
                                  FrameBuffer,Attributes);
            CurFrameBufPtrTmp = FrameBuffer;
            for (Index=0; Index < DeviceExtension->ScreenAndFont.FontSize.Y - 1; Index++) {
                CurFrameBufPtrTmp=NextGRAMRow(CurFrameBufPtrTmp,
                                              &DeviceExtension->CurrentMode,
                                              &DeviceExtension->EmulateInfo);
            }
            *CurFrameBufPtrTmp = 0xff;
        }

        if (Attributes & COMMON_LVB_GRID_HORIZONTAL)
        {
            ColorSetDirect(DeviceExtension->Resource.PortList,
                           FrameBuffer,
                           FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED,
                           0);
            *FrameBuffer = 0xff;
        }

        if ( (Attributes & COMMON_LVB_GRID_LVERTICAL) ||
             (Attributes & COMMON_LVB_GRID_RVERTICAL)   )
        {
            UCHAR mask = ((Attributes & COMMON_LVB_GRID_LVERTICAL) ? 0x80 : 0) +
                         ((Attributes & COMMON_LVB_GRID_RVERTICAL) ? 0x01 : 0);
            ColorSetGridMask(DeviceExtension->Resource.PortList,
                             mask
                            );
            CurFrameBufPtrTmp = FrameBuffer;
            for (Index=0; Index < DeviceExtension->ScreenAndFont.FontSize.Y; Index++) {
                AccessGRAM_RW(CurFrameBufPtrTmp, mask);
                CurFrameBufPtrTmp=NextGRAMRow(CurFrameBufPtrTmp,
                                              &DeviceExtension->CurrentMode,
                                              &DeviceExtension->EmulateInfo);
            }

            SetGRAMWriteMode(DeviceExtension->Resource.PortList);
        }

        DeviceExtension->EmulateInfo.ColorFg = (UCHAR)-1;
        DeviceExtension->EmulateInfo.ColorBg = (UCHAR)-1;

    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return STATUS_SUCCESS;
}

#pragma optimize("",off)
    /*
     * because, frame buffer memory access is need by write/read.
     */
UCHAR
AccessGRAM_WR(
    PUCHAR FrameBuffer,
    UCHAR  write
    )
{
    *FrameBuffer = write;
    return *FrameBuffer;
}

UCHAR
AccessGRAM_RW(
    PUCHAR FrameBuffer,
    UCHAR  write
    )
{
    UCHAR tmp;
    tmp = *FrameBuffer;
    *FrameBuffer = write;
    return tmp;
}

UCHAR
AccessGRAM_AND(
    PUCHAR FrameBuffer,
    UCHAR  write
    )
{
    return *FrameBuffer &= write;
}
#pragma optimize("",on)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\framebuf\disp\screen.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: screen.c
*
* Initializes the GDIINFO and DEVINFO structures for DrvEnablePDEV.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,CLIP_STROKE_PRECIS,PROOF_QUALITY,VARIABLE_PITCH | FF_DONTCARE,L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,CLIP_STROKE_PRECIS,PROOF_QUALITY,FIXED_PITCH | FF_DONTCARE, L"Courier"}

// This is the basic devinfo for a default driver.  This is used as a base and customized based
// on information passed back from the miniport driver.

const DEVINFO gDevInfoFrameBuffer = {
    ( GCAPS_OPAQUERECT
    | GCAPS_MONO_DITHER
                   ), /* Graphics capabilities         */
    SYSTM_LOGFONT,    /* Default font description */
    HELVE_LOGFONT,    /* ANSI variable font description   */
    COURI_LOGFONT,    /* ANSI fixed font description          */
    0,                /* Count of device fonts          */
    0,                /* Preferred DIB format          */
    8,                /* Width of color dither          */
    8,                /* Height of color dither   */
    0                 /* Default palette to use for this device */
};

/******************************Public*Routine******************************\
* bInitSURF
*
* Enables the surface.        Maps the frame buffer into memory.
*
\**************************************************************************/

BOOL bInitSURF(PPDEV ppdev, BOOL bFirst)
{
    DWORD returnedDataLength;
    DWORD MaxWidth, MaxHeight;
    VIDEO_MEMORY videoMemory;
    VIDEO_MEMORY_INFORMATION videoMemoryInformation;
    ULONG RemappingNeeded = 0;  

    //
    // Set the current mode into the hardware.
    //

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_SET_CURRENT_MODE,
                           &(ppdev->ulMode),
                           sizeof(ULONG),
                           &RemappingNeeded,
                           sizeof(ULONG),
                           &returnedDataLength))
    {
        DISPDBG((1, "DISP bInitSURF failed IOCTL_SET_MODE\n"));
        return(FALSE);
    }

    //
    // If this is the first time we enable the surface we need to map in the
    // memory also.
    //

    if (bFirst || RemappingNeeded)
    {
        videoMemory.RequestedVirtualAddress = NULL;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                               &videoMemory,
                               sizeof(VIDEO_MEMORY),
                               &videoMemoryInformation,
                               sizeof(VIDEO_MEMORY_INFORMATION),
                               &returnedDataLength))
        {
            DISPDBG((1, "DISP bInitSURF failed IOCTL_VIDEO_MAP\n"));
            return(FALSE);
        }

        ppdev->pjScreen = (PBYTE)(videoMemoryInformation.FrameBufferBase);

        if (videoMemoryInformation.FrameBufferBase !=
            videoMemoryInformation.VideoRamBase)
        {
            RIP("VideoRamBase does not correspond to FrameBufferBase\n");
        }

        //
        // Make sure we can access this video memory
        //

        *(PULONG)(ppdev->pjScreen) = 0xaa55aa55;

        if (*(PULONG)(ppdev->pjScreen) != 0xaa55aa55) {

            DISPDBG((1, "Frame buffer memory is not accessible.\n"));
            return(FALSE);
        }

        ppdev->cScreenSize = videoMemoryInformation.VideoRamLength;

        //
        // Initialize the head of the offscreen list to NULL.
        //

        ppdev->pOffscreenList = NULL;

        // It's a hardware pointer; set up pointer attributes.

        MaxHeight = ppdev->PointerCapabilities.MaxHeight;

        // Allocate space for two DIBs (data/mask) for the pointer. If this
        // device supports a color Pointer, we will allocate a larger bitmap.
        // If this is a color bitmap we allocate for the largest possible
        // bitmap because we have no idea of what the pixel depth might be.

        // Width rounded up to nearest byte multiple

        if (!(ppdev->PointerCapabilities.Flags & VIDEO_MODE_COLOR_POINTER))
        {
            MaxWidth = (ppdev->PointerCapabilities.MaxWidth + 7) / 8;
        }
        else
        {
            MaxWidth = ppdev->PointerCapabilities.MaxWidth * sizeof(DWORD);
        }

        ppdev->cjPointerAttributes =
                sizeof(VIDEO_POINTER_ATTRIBUTES) +
                ((sizeof(UCHAR) * MaxWidth * MaxHeight) * 2);

        ppdev->pPointerAttributes = (PVIDEO_POINTER_ATTRIBUTES)
                EngAllocMem(0, ppdev->cjPointerAttributes, ALLOC_TAG);

        if (ppdev->pPointerAttributes == NULL) {

            DISPDBG((0, "bInitPointer EngAllocMem failed\n"));
            return(FALSE);
        }

        ppdev->pPointerAttributes->Flags = ppdev->PointerCapabilities.Flags;
        ppdev->pPointerAttributes->WidthInBytes = MaxWidth;
        ppdev->pPointerAttributes->Width = ppdev->PointerCapabilities.MaxWidth;
        ppdev->pPointerAttributes->Height = MaxHeight;
        ppdev->pPointerAttributes->Column = 0;
        ppdev->pPointerAttributes->Row = 0;
        ppdev->pPointerAttributes->Enable = 0;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* vDisableSURF
*
* Disable the surface. Un-Maps the frame in memory.
*
\**************************************************************************/

VOID vDisableSURF(PPDEV ppdev)
{
    DWORD returnedDataLength;
    VIDEO_MEMORY videoMemory;

    videoMemory.RequestedVirtualAddress = (PVOID) ppdev->pjScreen;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
                           &videoMemory,
                           sizeof(VIDEO_MEMORY),
                           NULL,
                           0,
                           &returnedDataLength))
    {
        RIP("DISP vDisableSURF failed IOCTL_VIDEO_UNMAP\n");
    }
}


/******************************Public*Routine******************************\
* bInitPDEV
*
* Determine the mode we should be in based on the DEVMODE passed in.
* Query mini-port to get information needed to fill in the DevInfo and the
* GdiInfo .
*
\**************************************************************************/

BOOL bInitPDEV(
PPDEV ppdev,
DEVMODEW *pDevMode,
GDIINFO *pGdiInfo,
DEVINFO *pDevInfo)
{
    ULONG cModes;
    PVIDEO_MODE_INFORMATION pVideoBuffer, pVideoModeSelected, pVideoTemp;
    VIDEO_COLOR_CAPABILITIES colorCapabilities;
    ULONG ulTemp;
    BOOL bSelectDefault;
    ULONG cbModeSize;

    //
    // calls the miniport to get mode information.
    //

    cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize);

    if (cModes == 0)
    {
        return(FALSE);
    }

    //
    // Now see if the requested mode has a match in that table.
    //

    pVideoModeSelected = NULL;
    pVideoTemp = pVideoBuffer;

    if ((pDevMode->dmPelsWidth        == 0) &&
        (pDevMode->dmPelsHeight       == 0) &&
        (pDevMode->dmBitsPerPel       == 0) &&
        (pDevMode->dmDisplayFrequency == 0))
    {
        DISPDBG((2, "Default mode requested"));
        bSelectDefault = TRUE;
    }
    else
    {
        DISPDBG((2, "Requested mode...\n"));
        DISPDBG((2, "   Screen width  -- %li\n", pDevMode->dmPelsWidth));
        DISPDBG((2, "   Screen height -- %li\n", pDevMode->dmPelsHeight));
        DISPDBG((2, "   Bits per pel  -- %li\n", pDevMode->dmBitsPerPel));
        DISPDBG((2, "   Frequency     -- %li\n", pDevMode->dmDisplayFrequency));

        bSelectDefault = FALSE;
    }

    while (cModes--)
    {
        if (pVideoTemp->Length != 0)
        {
            if (bSelectDefault ||
                ((pVideoTemp->VisScreenWidth  == pDevMode->dmPelsWidth) &&
                 (pVideoTemp->VisScreenHeight == pDevMode->dmPelsHeight) &&
                 (pVideoTemp->BitsPerPlane *
                  pVideoTemp->NumberOfPlanes  == pDevMode->dmBitsPerPel) &&
                 (pVideoTemp->Frequency  == pDevMode->dmDisplayFrequency)))
            {
                pVideoModeSelected = pVideoTemp;
                DISPDBG((3, "Found a match\n")) ;
                break;
            }
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + cbModeSize);
    }

    //
    // If no mode has been found, return an error
    //

    if (pVideoModeSelected == NULL)
    {
        EngFreeMem(pVideoBuffer);
        DISPDBG((0,"DISP bInitPDEV failed - no valid modes\n"));
        return(FALSE);
    }

    //
    // Fill in the GDIINFO data structure with the information returned from
    // the kernel driver.
    //

    ppdev->ulMode = pVideoModeSelected->ModeIndex;
    ppdev->cxScreen = pVideoModeSelected->VisScreenWidth;
    ppdev->cyScreen = pVideoModeSelected->VisScreenHeight;
    ppdev->ulBitCount = pVideoModeSelected->BitsPerPlane *
                        pVideoModeSelected->NumberOfPlanes;
    ppdev->lDeltaScreen = pVideoModeSelected->ScreenStride;

    ppdev->flRed = pVideoModeSelected->RedMask;
    ppdev->flGreen = pVideoModeSelected->GreenMask;
    ppdev->flBlue = pVideoModeSelected->BlueMask;


    pGdiInfo->ulVersion    = GDI_DRIVER_VERSION;
    pGdiInfo->ulTechnology = DT_RASDISPLAY;
    pGdiInfo->ulHorzSize   = pVideoModeSelected->XMillimeter;
    pGdiInfo->ulVertSize   = pVideoModeSelected->YMillimeter;

    pGdiInfo->ulHorzRes        = ppdev->cxScreen;
    pGdiInfo->ulVertRes        = ppdev->cyScreen;
    pGdiInfo->ulPanningHorzRes = ppdev->cxScreen;
    pGdiInfo->ulPanningVertRes = ppdev->cyScreen;
    pGdiInfo->cBitsPixel       = pVideoModeSelected->BitsPerPlane;
    pGdiInfo->cPlanes          = pVideoModeSelected->NumberOfPlanes;
    pGdiInfo->ulVRefresh       = pVideoModeSelected->Frequency;
    pGdiInfo->ulBltAlignment   = 1;     // We don't have accelerated screen-
                                        //   to-screen blts, and any
                                        //   window alignment is okay

    pGdiInfo->ulLogPixelsX = pDevMode->dmLogPixels;
    pGdiInfo->ulLogPixelsY = pDevMode->dmLogPixels;

#ifdef MIPS
    if (ppdev->ulBitCount == 8)
        pGdiInfo->flTextCaps = (TC_RA_ABLE | TC_SCROLLBLT);
    else
#endif
    pGdiInfo->flTextCaps = TC_RA_ABLE;

    pGdiInfo->flRaster = 0;           // flRaster is reserved by DDI

    pGdiInfo->ulDACRed   = pVideoModeSelected->NumberRedBits;
    pGdiInfo->ulDACGreen = pVideoModeSelected->NumberGreenBits;
    pGdiInfo->ulDACBlue  = pVideoModeSelected->NumberBlueBits;

    pGdiInfo->ulAspectX    = 0x24;    // One-to-one aspect ratio
    pGdiInfo->ulAspectY    = 0x24;
    pGdiInfo->ulAspectXY   = 0x33;

    pGdiInfo->xStyleStep   = 1;       // A style unit is 3 pels
    pGdiInfo->yStyleStep   = 1;
    pGdiInfo->denStyleStep = 3;

    pGdiInfo->ptlPhysOffset.x = 0;
    pGdiInfo->ptlPhysOffset.y = 0;
    pGdiInfo->szlPhysSize.cx  = 0;
    pGdiInfo->szlPhysSize.cy  = 0;

    // RGB and CMY color info.

    //
    // try to get it from the miniport.
    // if the miniport doesn ot support this feature, use defaults.
    //

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_QUERY_COLOR_CAPABILITIES,
                           NULL,
                           0,
                           &colorCapabilities,
                           sizeof(VIDEO_COLOR_CAPABILITIES),
                           &ulTemp))
    {

        DISPDBG((2, "getcolorCapabilities failed \n"));

        pGdiInfo->ciDevice.Red.x = 6700;
        pGdiInfo->ciDevice.Red.y = 3300;
        pGdiInfo->ciDevice.Red.Y = 0;
        pGdiInfo->ciDevice.Green.x = 2100;
        pGdiInfo->ciDevice.Green.y = 7100;
        pGdiInfo->ciDevice.Green.Y = 0;
        pGdiInfo->ciDevice.Blue.x = 1400;
        pGdiInfo->ciDevice.Blue.y = 800;
        pGdiInfo->ciDevice.Blue.Y = 0;
        pGdiInfo->ciDevice.AlignmentWhite.x = 3127;
        pGdiInfo->ciDevice.AlignmentWhite.y = 3290;
        pGdiInfo->ciDevice.AlignmentWhite.Y = 0;

        pGdiInfo->ciDevice.RedGamma = 20000;
        pGdiInfo->ciDevice.GreenGamma = 20000;
        pGdiInfo->ciDevice.BlueGamma = 20000;

    }
    else
    {
        pGdiInfo->ciDevice.Red.x = colorCapabilities.RedChromaticity_x;
        pGdiInfo->ciDevice.Red.y = colorCapabilities.RedChromaticity_y;
        pGdiInfo->ciDevice.Red.Y = 0;
        pGdiInfo->ciDevice.Green.x = colorCapabilities.GreenChromaticity_x;
        pGdiInfo->ciDevice.Green.y = colorCapabilities.GreenChromaticity_y;
        pGdiInfo->ciDevice.Green.Y = 0;
        pGdiInfo->ciDevice.Blue.x = colorCapabilities.BlueChromaticity_x;
        pGdiInfo->ciDevice.Blue.y = colorCapabilities.BlueChromaticity_y;
        pGdiInfo->ciDevice.Blue.Y = 0;
        pGdiInfo->ciDevice.AlignmentWhite.x = colorCapabilities.WhiteChromaticity_x;
        pGdiInfo->ciDevice.AlignmentWhite.y = colorCapabilities.WhiteChromaticity_y;
        pGdiInfo->ciDevice.AlignmentWhite.Y = colorCapabilities.WhiteChromaticity_Y;

        // if we have a color device store the three color gamma values,
        // otherwise store the unique gamma value in all three.

        if (colorCapabilities.AttributeFlags & VIDEO_DEVICE_COLOR)
        {
            pGdiInfo->ciDevice.RedGamma = colorCapabilities.RedGamma;
            pGdiInfo->ciDevice.GreenGamma = colorCapabilities.GreenGamma;
            pGdiInfo->ciDevice.BlueGamma = colorCapabilities.BlueGamma;
        }
        else
        {
            pGdiInfo->ciDevice.RedGamma = colorCapabilities.WhiteGamma;
            pGdiInfo->ciDevice.GreenGamma = colorCapabilities.WhiteGamma;
            pGdiInfo->ciDevice.BlueGamma = colorCapabilities.WhiteGamma;
        }

    };

    pGdiInfo->ciDevice.Cyan.x = 0;
    pGdiInfo->ciDevice.Cyan.y = 0;
    pGdiInfo->ciDevice.Cyan.Y = 0;
    pGdiInfo->ciDevice.Magenta.x = 0;
    pGdiInfo->ciDevice.Magenta.y = 0;
    pGdiInfo->ciDevice.Magenta.Y = 0;
    pGdiInfo->ciDevice.Yellow.x = 0;
    pGdiInfo->ciDevice.Yellow.y = 0;
    pGdiInfo->ciDevice.Yellow.Y = 0;

    // No dye correction for raster displays.

    pGdiInfo->ciDevice.MagentaInCyanDye = 0;
    pGdiInfo->ciDevice.YellowInCyanDye = 0;
    pGdiInfo->ciDevice.CyanInMagentaDye = 0;
    pGdiInfo->ciDevice.YellowInMagentaDye = 0;
    pGdiInfo->ciDevice.CyanInYellowDye = 0;
    pGdiInfo->ciDevice.MagentaInYellowDye = 0;

    pGdiInfo->ulDevicePelsDPI = 0;   // For printers only
    pGdiInfo->ulPrimaryOrder = PRIMARY_ORDER_CBA;

    // Note: this should be modified later to take into account the size
    // of the display and the resolution.

    pGdiInfo->ulHTPatternSize = HT_PATSIZE_4x4_M;

    pGdiInfo->flHTFlags = HT_FLAG_ADDITIVE_PRIMS;

    // Fill in the basic devinfo structure

    *pDevInfo = gDevInfoFrameBuffer;

    // Fill in the rest of the devinfo and GdiInfo structures.

    if (ppdev->ulBitCount == 8)
    {
        // It is Palette Managed.

        pGdiInfo->ulNumColors = 20;
        pGdiInfo->ulNumPalReg = 1 << ppdev->ulBitCount;

        pDevInfo->flGraphicsCaps |= (GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);

        pGdiInfo->ulHTOutputFormat = HT_FORMAT_8BPP;
        pDevInfo->iDitherFormat = BMF_8BPP;

        // Assuming palette is orthogonal - all colors are same size.

        ppdev->cPaletteShift   = 8 - pGdiInfo->ulDACRed;
    }
    else
    {
        pGdiInfo->ulNumColors = (ULONG) (-1);
        pGdiInfo->ulNumPalReg = 0;

        if (ppdev->ulBitCount == 16)
        {
            pGdiInfo->ulHTOutputFormat = HT_FORMAT_16BPP;
            pDevInfo->iDitherFormat = BMF_16BPP;
        }
        else if (ppdev->ulBitCount == 24)
        {
            pGdiInfo->ulHTOutputFormat = HT_FORMAT_24BPP;
            pDevInfo->iDitherFormat = BMF_24BPP;
        }
        else
        {
            pGdiInfo->ulHTOutputFormat = HT_FORMAT_32BPP;
            pDevInfo->iDitherFormat = BMF_32BPP;
        }
    }

    EngFreeMem(pVideoBuffer);

    return(TRUE);
}


/******************************Public*Routine******************************\
* getAvailableModes
*
* Calls the miniport to get the list of modes supported by the kernel driver,
* and returns the list of modes supported by the diplay driver among those
*
* returns the number of entries in the videomode buffer.
* 0 means no modes are supported by the miniport or that an error occured.
*
* NOTE: the buffer must be freed up by the caller.
*
\**************************************************************************/

DWORD getAvailableModes(
HANDLE hDriver,
PVIDEO_MODE_INFORMATION *modeInformation,
DWORD *cbModeSize)
{
    ULONG ulTemp;
    VIDEO_NUM_MODES modes;
    PVIDEO_MODE_INFORMATION pVideoTemp;

    //
    // Get the number of modes supported by the mini-port
    //

    if (EngDeviceIoControl(hDriver,
                           IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
                           NULL,
                           0,
                           &modes,
                           sizeof(VIDEO_NUM_MODES),
                           &ulTemp))
    {
        DISPDBG((0, "getAvailableModes failed VIDEO_QUERY_NUM_AVAIL_MODES\n"));
        return(0);
    }

    *cbModeSize = modes.ModeInformationLength;

    //
    // Allocate the buffer for the mini-port to write the modes in.
    //

    *modeInformation = (PVIDEO_MODE_INFORMATION)
                        EngAllocMem(0, modes.NumModes *
                                    modes.ModeInformationLength, ALLOC_TAG);

    if (*modeInformation == (PVIDEO_MODE_INFORMATION) NULL)
    {
        DISPDBG((0, "getAvailableModes failed EngAllocMem\n"));

        return 0;
    }

    //
    // Ask the mini-port to fill in the available modes.
    //

    if (EngDeviceIoControl(hDriver,
                           IOCTL_VIDEO_QUERY_AVAIL_MODES,
                           NULL,
                           0,
                           *modeInformation,
                           modes.NumModes * modes.ModeInformationLength,
                           &ulTemp))
    {

        DISPDBG((0, "getAvailableModes failed VIDEO_QUERY_AVAIL_MODES\n"));

        EngFreeMem(*modeInformation);
        *modeInformation = (PVIDEO_MODE_INFORMATION) NULL;

        return(0);
    }

    //
    // Now see which of these modes are supported by the display driver.
    // As an internal mechanism, set the length to 0 for the modes we
    // DO NOT support.
    //

    ulTemp = modes.NumModes;
    pVideoTemp = *modeInformation;

    //
    // Mode is rejected if it is not one plane, or not graphics, or is not
    // one of 8, 16 or 32 bits per pel.
    //

    while (ulTemp--)
    {
        if ((pVideoTemp->NumberOfPlanes != 1 ) ||
            !(pVideoTemp->AttributeFlags & VIDEO_MODE_GRAPHICS) ||
             (pVideoTemp->AttributeFlags & VIDEO_MODE_BANKED) ||
            ((pVideoTemp->BitsPerPlane != 8) &&
             (pVideoTemp->BitsPerPlane != 16) &&
             (pVideoTemp->BitsPerPlane != 24) &&
             (pVideoTemp->BitsPerPlane != 32)))
        {
            pVideoTemp->Length = 0;
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + modes.ModeInformationLength);
    }

    return modes.NumModes;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\fsvga\fsvga.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    fsvga.c

Abstract:

    This is the console fullscreen driver for the VGA card.

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "fsvga.h"

//
// Use the alloc_text pragma to specify the driver initialization routines
// (they can be paged out).
//

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(INIT,FsVgaQueryDevice)
#pragma alloc_text(INIT,FsVgaPeripheralCallout)
#pragma alloc_text(INIT,FsVgaServiceParameters)
#endif


GLOBALS Globals;


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the Unicode name of the registry path
        for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG uniqueErrorValue;
    NTSTATUS errorCode = STATUS_SUCCESS;
    ULONG dumpCount = 0;
    ULONG dumpData[DUMP_COUNT];

    FsVgaPrint((1,
                "\n\nFSVGA-FSVGAInitialize: enter\n"));

    //
    // Zero-initialize various structures.
    //
    RtlZeroMemory(&Globals, sizeof(GLOBALS));

    Globals.FsVgaDebug = DEFAULT_DEBUG_LEVEL;

    //
    // Query the device resource information for this driver.
    //
    FsVgaQueryDevice(&Globals.Resource);

    if (!(Globals.Resource.HardwarePresent & FSVGA_HARDWARE_PRESENT)) {
        //
        // There is neither a Full Screen Video attached.  Free
        // resources and return with unsuccessful status.
        //

        FsVgaPrint((1,
                    "FSVGA-FsVgaInitialize: No Full Screen Video attached.\n"));
        status = STATUS_NO_SUCH_DEVICE;
        errorCode = FSVGA_NO_SUCH_DEVICE;
        uniqueErrorValue = FSVGA_ERROR_VALUE_BASE + 4;
        goto FsVgaInitializeExit;

    }
    else
    {
        //
        // Need to ensure that the registry path is null-terminated.
        // Allocate pool to hold a null-terminated copy of the path.
        //

        Globals.RegistryPath.Length = RegistryPath->Length;
        Globals.RegistryPath.MaximumLength = RegistryPath->Length
                                           + sizeof (UNICODE_NULL);

        Globals.RegistryPath.Buffer = ExAllocatePool(
                                          NonPagedPool,
                                          Globals.RegistryPath.MaximumLength);

        if (!Globals.RegistryPath.Buffer) {
            FsVgaPrint((
                1,
                "FSVGA-FsVgaInitialize: Couldn't allocate pool for registry path\n"
                ));

            status = STATUS_UNSUCCESSFUL;
            errorCode = FSVGA_INSUFFICIENT_RESOURCES;
            uniqueErrorValue = FSVGA_ERROR_VALUE_BASE + 2;
            dumpData[0] = 0;
            dumpCount = 1;
            goto FsVgaInitializeExit;

        }

        RtlMoveMemory(Globals.RegistryPath.Buffer,
                      RegistryPath->Buffer,
                      RegistryPath->Length);
        Globals.RegistryPath.Buffer [RegistryPath->Length / sizeof (WCHAR)] = L'\0';

        //
        // Get the service parameters (e.g., user-configurable number
        // of resends, polling iterations, etc.).
        //

        FsVgaServiceParameters(&Globals.Configuration,
                               &Globals.RegistryPath);
    }

    //
    // Once initialization is finished, load the device map information
    // into the registry so that setup can determine which full screen
    // port are active.
    //

    if (Globals.Resource.HardwarePresent & FSVGA_HARDWARE_PRESENT) {

        status = RtlWriteRegistryValue(RTL_REGISTRY_DEVICEMAP,
                                       L"FullScreenVideo",
                                       DD_FULLSCREEN_VIDEO_DEVICE_NAME,
                                       REG_SZ,
                                       Globals.RegistryPath.Buffer,
                                       Globals.RegistryPath.Length);

        if (!NT_SUCCESS(status))
        {
            FsVgaPrint((1,
                       "FSVGA-FSVGAInitialize: Could not store keyboard name in DeviceMap\n"));
            errorCode = FSVGA_NO_DEVICEMAP_CREATED;
            uniqueErrorValue = FSVGA_ERROR_VALUE_BASE + 90;
            dumpCount = 0;
            goto FsVgaInitializeExit;
        }
        else
        {
            FsVgaPrint((1,
                       "FSVGA-FSVGAInitialize: Stored pointer name in DeviceMap\n"));
        }
    }

    ASSERT(status == STATUS_SUCCESS);

    //
    // Set up the device driver entry points.
    //
    DriverObject->MajorFunction[IRP_MJ_CREATE]         = FsVgaOpenCloseDispatch;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = FsVgaOpenCloseDispatch;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = FsVgaDeviceControl;

    DriverObject->DriverUnload                         = FsVgaDriverUnload;
    DriverObject->DriverExtension->AddDevice           = FsVgaAddDevice;
    DriverObject->MajorFunction[IRP_MJ_PNP]            = FsVgaDevicePnp;
    DriverObject->MajorFunction[IRP_MJ_POWER]          = FsVgaDevicePower;

FsVgaInitializeExit:

    if (errorCode != STATUS_SUCCESS)
    {
        //
        // Log an error/warning message.
        //
        FsVgaLogError(DriverObject,
                      errorCode,
                      uniqueErrorValue,
                      status,
                      dumpData,
                      dumpCount
                     );
    }

    FsVgaPrint((1,
                "FSVGA-FsVgaInitialize: exit\n"));

    return(status);
}

VOID
FsVgaQueryDevice(
    IN PFSVGA_RESOURCE_INFORMATION Resource
    )

/*++

Routine Description:

    This routine retrieves the resource information for the video.

Arguments:

    Resource - Pointer to the resource information.

Return Value:

--*/
{
    INTERFACE_TYPE interfaceType;
    ULONG i;

    for (i = 0; i < MaximumInterfaceType; i++)
    {

        //
        // Get the registry information for this device.
        //

        interfaceType = i;
        IoQueryDeviceDescription(&interfaceType,      // Bus type
                                 NULL,                // Bus number
                                 NULL,                // Controller type
                                 NULL,                // Controller number
                                 NULL,                // Peripheral type
                                 NULL,                // Peripheral number
                                 FsVgaPeripheralCallout,
                                 (PVOID) Resource);

        if (Resource->HardwarePresent & FSVGA_HARDWARE_PRESENT)
        {
            break;
        }
        else
        {
            FsVgaPrint((1,
                        "FSVGA-FsVgaConfiguration: IoQueryDeviceDescription for bus type %d failed\n",
                        interfaceType));
        }
    }
}

NTSTATUS
FsVgaPeripheralCallout(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    )

/*++

Routine Description:

    This is the callout routine sent as a parameter to
    IoQueryDeviceDescription.  It grabs the Display controller
    configuration information.

Arguments:

    Context - Context parameter that was passed in by the routine
        that called IoQueryDeviceDescription.

    PathName - The full pathname for the registry key.

    BusType - Bus interface type (Isa, Eisa, Mca, etc.).

    BusNumber - The bus sub-key (0, 1, etc.).

    BusInformation - Pointer to the array of pointers to the full value
        information for the bus.

    ControllerType - The controller type (should be DisplayController).

    ControllerNumber - The controller sub-key (0, 1, etc.).

    ControllerInformation - Pointer to the array of pointers to the full
        value information for the controller key.

    PeripheralType - The peripheral type (should be MonitorPeripheral).

    PeripheralNumber - The peripheral sub-key.

    PeripheralInformation - Pointer to the array of pointers to the full
        value information for the peripheral key.


Return Value:

    None.  If successful, will have the following side-effects:

        - Sets DeviceObject->DeviceExtension->HardwarePresent.
        - Sets configuration fields in
          DeviceObject->DeviceExtension->Configuration.

--*/

{
    PFSVGA_RESOURCE_INFORMATION resource;
    NTSTATUS status = STATUS_SUCCESS;

    FsVgaPrint((1,
                "FSVGA-FsVgaPeripheralCallout: Path @ 0x%x, Bus Type 0x%x, Bus Number 0x%x\n",
                PathName, BusType, BusNumber));
    FsVgaPrint((1,
                "    Controller Type 0x%x, Controller Number 0x%x, Controller info @ 0x%x\n",
                ControllerType, ControllerNumber, ControllerInformation));
    FsVgaPrint((1,
                "    Peripheral Type 0x%x, Peripheral Number 0x%x, Peripheral info @ 0x%x\n",
                PeripheralType, PeripheralNumber, PeripheralInformation));

    //
    // If we already have the configuration information for the
    // keyboard peripheral, or if the peripheral identifier is missing,
    // just return.
    //

    resource = (PFSVGA_RESOURCE_INFORMATION) Context;
    if (resource->HardwarePresent & FSVGA_HARDWARE_PRESENT)
    {
        return (status);
    }


    resource->HardwarePresent |= FSVGA_HARDWARE_PRESENT;

#ifdef RESOURCE_REQUIREMENTS
    //
    // Get the bus information.
    //

    resource->InterfaceType = BusType;
    resource->BusNumber     = BusNumber;
#endif

    return(status);
}

#ifdef RESOURCE_REQUIREMENTS
NTSTATUS
FsVgaQueryAperture(
    OUT PIO_RESOURCE_LIST *pApertureRequirements
//    OUT PFSVGA_RESOURCE_INFORMATION Resource
    )

/*++

Routine Description:

    Queries the possible FsVga settings.

Arguments:

    ApertureRequirements - returns the possible FsVga settings

Return Value:

    NTSTATUS

--*/

{
    PIO_RESOURCE_LIST Requirements;
    ULONG PortLength;
    ULONG RangeStart;
    ULONG i;

    Requirements = ExAllocatePool(PagedPool,
                                  sizeof(IO_RESOURCE_LIST) + (MaximumPortCount-1) * sizeof(IO_RESOURCE_DESCRIPTOR));
    if (Requirements == NULL) {
        FsVgaPrint((1,
                    "FSVGA-FsVgaQueryAperture: Could not allocate resource list\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Requirements->Version  =
    Requirements->Revision = 1;
    Requirements->Count    = MaximumPortCount;
    for (i = 0; i < MaximumPortCount; i++) {
        Requirements->Descriptors[i].Option           = IO_RESOURCE_PREFERRED;
        Requirements->Descriptors[i].Type             = CmResourceTypePort;
        Requirements->Descriptors[i].ShareDisposition = CmResourceShareShared;
        Requirements->Descriptors[i].Flags            = CM_RESOURCE_PORT_IO;
        switch (i) {
            case CRTCAddressPortColor:
                PortLength = 1;
                RangeStart = VGA_BASE_IO_PORT + CRTC_ADDRESS_PORT_COLOR;
                break;
            case CRTCDataPortColor:
                PortLength = 1;
                RangeStart = VGA_BASE_IO_PORT + CRTC_DATA_PORT_COLOR;
                break;
            case GRAPHAddressPort:
                PortLength = 2;
                RangeStart = VGA_BASE_IO_PORT + GRAPH_ADDRESS_PORT;
                break;
            case SEQAddressPort:
                PortLength = 2;
                RangeStart = VGA_BASE_IO_PORT + SEQ_ADDRESS_PORT;
                break;
        }
        Requirements->Descriptors[i].u.Port.MinimumAddress.QuadPart = RangeStart;
        Requirements->Descriptors[i].u.Port.MaximumAddress.QuadPart = RangeStart +
                                                                      (PortLength - 1);
        Requirements->Descriptors[i].u.Port.Alignment               = 1;
        Requirements->Descriptors[i].u.Port.Length                  = PortLength;

    }

    *pApertureRequirements = Requirements;

    return STATUS_SUCCESS;
}
#endif

NTSTATUS
FsVgaCreateResource(
    IN PFSVGA_CONFIGURATION_INFORMATION configuration,
    OUT PCM_PARTIAL_RESOURCE_LIST *pResourceList
    )

/*++

Routine Description:

    Create the possible FsVga resousrce settings.

Arguments:

    ResourceList - returns the possible FsVga settings

Return Value:

    NTSTATUS

--*/

{
    PCM_PARTIAL_RESOURCE_LIST Requirements;
    ULONG PortLength;
    ULONG RangeStart;
    ULONG i;
    USHORT IOPort = configuration->IOPort;

    Requirements = ExAllocatePool(PagedPool,
                                  sizeof(CM_PARTIAL_RESOURCE_LIST) + (MaximumPortCount-1) * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));
    if (Requirements == NULL) {
        FsVgaPrint((1,
                    "FSVGA-FsVgaCreateResoursce: Could not allocate resource list\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Requirements->Version  =
    Requirements->Revision = 1;
    Requirements->Count    = MaximumPortCount;
    for (i = 0; i < MaximumPortCount; i++) {
        Requirements->PartialDescriptors[i].Type             = CmResourceTypePort;
        Requirements->PartialDescriptors[i].ShareDisposition = CmResourceShareShared;
        Requirements->PartialDescriptors[i].Flags            = CM_RESOURCE_PORT_IO;
        switch (i) {
            case CRTCAddressPortColor:
                PortLength = 1;
                RangeStart = IOPort + CRTC_ADDRESS_PORT_COLOR;
                break;
            case CRTCDataPortColor:
                PortLength = 1;
                RangeStart = IOPort + CRTC_DATA_PORT_COLOR;
                break;
            case GRAPHAddressPort:
                PortLength = 2;
                RangeStart = IOPort + GRAPH_ADDRESS_PORT;
                break;
            case SEQAddressPort:
                PortLength = 2;
                RangeStart = IOPort + SEQ_ADDRESS_PORT;
                break;
        }
        Requirements->PartialDescriptors[i].u.Port.Start.QuadPart = RangeStart;
        Requirements->PartialDescriptors[i].u.Port.Length         = PortLength;

    }

    *pResourceList = Requirements;

    return STATUS_SUCCESS;
}

VOID
FsVgaServiceParameters(
    IN PFSVGA_CONFIGURATION_INFORMATION configuration,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine retrieves this driver's service parameters information
    from the registry.

Arguments:

    configuration - Pointer to the configuration information.

    RegistryPath - Pointer to the null-terminated Unicode name of the
        registry path for this driver.

Return Value:

--*/

{
    UNICODE_STRING parametersPath;
    PWSTR path;
    PRTL_QUERY_REGISTRY_TABLE parameters = NULL;
    USHORT queriesPlusOne = 5;
    NTSTATUS status = STATUS_SUCCESS;
#define PARAMETER_MAX 256
    ULONG EmulationMode;
    ULONG HardwareCursor;
    ULONG HardwareScroll;
    ULONG IOPort;
    USHORT defaultEmulationMode = 0;
    USHORT defaultHardwareCursor = NO_HARDWARE_CURSOR;
    USHORT defaultHardwareScroll = NO_HARDWARE_SCROLL;
    USHORT defaultIOPort         = VGA_BASE_IO_PORT;

    parametersPath.Buffer = NULL;

    //
    // Registry path is already null-terminated, so just use it.
    //

    path = RegistryPath->Buffer;

    //
    // Allocate the Rtl query table.
    //

    parameters = ExAllocatePool(PagedPool,
                                sizeof(RTL_QUERY_REGISTRY_TABLE) * queriesPlusOne);
    if (!parameters)
    {
        FsVgaPrint((1,
                    "FSVGA-FsVgaServiceParameters: Couldn't allocate table for Rtl query to parameters for %ws\n",
                    path));
        status = STATUS_UNSUCCESSFUL;
    }
    else
    {
        RtlZeroMemory(parameters,
                      sizeof(RTL_QUERY_REGISTRY_TABLE) * queriesPlusOne);

        //
        // Form a path to this driver's Parameters subkey.
        //

        RtlInitUnicodeString(&parametersPath,
                             NULL);

        parametersPath.MaximumLength = RegistryPath->Length +
                                       sizeof(L"\\Parameters");
        parametersPath.Buffer = ExAllocatePool(PagedPool,
                                               parametersPath.MaximumLength);
        if (!parametersPath.Buffer)
        {
            FsVgaPrint((1,
                        "FSVGA-FsVgaServiceParameters: Couldn't allocate string for path to parameters for %ws\n",
                        path));
            status = STATUS_UNSUCCESSFUL;
        }
    }

    if (NT_SUCCESS(status))
    {
        //
        // Form the parameters path.
        //
        RtlZeroMemory(parametersPath.Buffer,
                      parametersPath.MaximumLength);
        RtlAppendUnicodeToString(&parametersPath,
                                 path);
        RtlAppendUnicodeToString(&parametersPath,
                                 L"\\Parameters");

        FsVgaPrint((1,
                    "FsVga-FsVgaServiceParameters: parameters path is %ws\n",
                    parametersPath.Buffer));

        //
        // Gather all of the "user specified" information from
        // the registry.
        //
        parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[0].Name = L"ConsoleFullScreen.EmulationMode";
        parameters[0].EntryContext = &EmulationMode;
        parameters[0].DefaultType = REG_DWORD;
        parameters[0].DefaultData = &defaultEmulationMode;
        parameters[0].DefaultLength = sizeof(USHORT);

        parameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[1].Name = L"ConsoleFullScreen.HardwareCursor";
        parameters[1].EntryContext = &HardwareCursor;
        parameters[1].DefaultType = REG_DWORD;
        parameters[1].DefaultData = &defaultHardwareCursor;
        parameters[1].DefaultLength = sizeof(USHORT);

        parameters[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[2].Name = L"ConsoleFullScreen.HardwareScroll";
        parameters[2].EntryContext = &HardwareScroll;
        parameters[2].DefaultType = REG_DWORD;
        parameters[2].DefaultData = &defaultHardwareScroll;
        parameters[2].DefaultLength = sizeof(USHORT);

        parameters[3].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[3].Name = L"IO Port";
        parameters[3].EntryContext = &IOPort;
        parameters[3].DefaultType = REG_DWORD;
        parameters[3].DefaultData = &defaultIOPort;
        parameters[3].DefaultLength = sizeof(USHORT);

        status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                        parametersPath.Buffer,
                                        parameters,
                                        NULL,
                                        NULL);
        if (!NT_SUCCESS(status))
        {
            FsVgaPrint((1,
                        "FsVga-FsVgaServiceParameters: RtlQueryRegistryValues failed with 0x%x\n",
                        status));
        }
    }

    if (!NT_SUCCESS(status))
    {
        //
        // Go ahead and assign driver defaults.
        //
        configuration->EmulationMode = defaultEmulationMode;
        configuration->HardwareCursor = defaultHardwareCursor;
        configuration->HardwareScroll = defaultHardwareScroll;
        configuration->IOPort         = defaultIOPort;
    }
    else
    {
        configuration->EmulationMode = (USHORT)EmulationMode;
        configuration->HardwareCursor = (USHORT)HardwareCursor;
        configuration->HardwareScroll = (USHORT)HardwareScroll;
        configuration->IOPort         = (USHORT)IOPort;
    }

    FsVgaPrint((1,
                "FsVga-FsVgaServiceParameters: Emulation Mode = %d\n",
                configuration->EmulationMode));

    FsVgaPrint((1,
                "FsVga-FsVgaServiceParameters: Hardware Cursor = %d\n",
                configuration->HardwareCursor));

    FsVgaPrint((1,
                "FsVga-FsVgaServiceParameters: Hardware Scroll = %d\n",
                configuration->HardwareScroll));

    FsVgaPrint((1,
                "FsVga-FsVgaServiceParameters: IO Port = %x\n",
                configuration->IOPort));

    //
    // Free the allocated memory before returning.
    //

    if (parametersPath.Buffer)
        ExFreePool(parametersPath.Buffer);
    if (parameters)
        ExFreePool(parameters);
}

NTSTATUS
FsVgaOpenCloseDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for create/open and close requests.
    These requests complete successfully.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    UNREFERENCED_PARAMETER(DeviceObject);

    FsVgaPrint((3,"FSVGA-FsVgaOpenCloseDispatch: enter\n"));

    PAGED_CODE();

    //
    // Complete the request with successful status.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    FsVgaPrint((3,"FSVGA-FsVgaOpenCloseDispatch: exit\n"));

    return(STATUS_SUCCESS);

}

NTSTATUS
FsVgaDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for device control requests.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION irpSp;
    PVOID ioBuffer;
    ULONG inputBufferLength;
    ULONG outputBufferLength;
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS status = STATUS_SUCCESS;

    FsVgaPrint((2,"FSVGA-FsVgaDeviceControl: enter\n"));

    PAGED_CODE();

    //
    // Get a pointer to the device extension.
    //

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Initialize the returned Information field.
    //

    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the input/output buffer and it's length
    //

    ioBuffer = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength = irpSp->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Case on the device control subfunction that is being performed by the
    // requestor.
    //

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode)
    {
        case IOCTL_FSVIDEO_COPY_FRAME_BUFFER:
            FsVgaPrint((2, "FsVgaDeviceControl - CopyFrameBuffer\n"));
            status = FsVgaCopyFrameBuffer(deviceExtension,
                                          (PFSVIDEO_COPY_FRAME_BUFFER) ioBuffer,
                                          inputBufferLength);
            break;

        case IOCTL_FSVIDEO_WRITE_TO_FRAME_BUFFER:
            FsVgaPrint((2, "FsVgaDeviceControl - WriteToFrameBuffer\n"));
            status = FsVgaWriteToFrameBuffer(deviceExtension,
                                             (PFSVIDEO_WRITE_TO_FRAME_BUFFER) ioBuffer,
                                             inputBufferLength);
            break;

        case IOCTL_FSVIDEO_REVERSE_MOUSE_POINTER:
            FsVgaPrint((2, "FsVgaDeviceControl - ReverseMousePointer\n"));
            status = FsVgaReverseMousePointer(deviceExtension,
                                              (PFSVIDEO_REVERSE_MOUSE_POINTER) ioBuffer,
                                              inputBufferLength);
            break;

        case IOCTL_FSVIDEO_SET_CURRENT_MODE:
            FsVgaPrint((2, "FsVgaDeviceControl - SetCurrentModes\n"));
            status = FsVgaSetMode(deviceExtension,
                                  (PFSVIDEO_MODE_INFORMATION) ioBuffer,
                                  inputBufferLength);
            break;

        case IOCTL_FSVIDEO_SET_SCREEN_INFORMATION:
            FsVgaPrint((2, "FsVgaDeviceControl - SetScreenInformation\n"));
            status = FsVgaSetScreenInformation(deviceExtension,
                                               (PFSVIDEO_SCREEN_INFORMATION) ioBuffer,
                                               inputBufferLength);
            break;

        case IOCTL_FSVIDEO_SET_CURSOR_POSITION:
            FsVgaPrint((2, "FsVgaDeviceControl - SetCursorPosition\n"));
            status = FsVgaSetCursorPosition(deviceExtension,
                                            (PFSVIDEO_CURSOR_POSITION) ioBuffer,
                                            inputBufferLength);
            break;

        case IOCTL_VIDEO_SET_CURSOR_ATTR:
            FsVgaPrint((2, "FsVgaDeviceControl - SetCursorAttribute\n"));
            status = FsVgaSetCursorAttribute(deviceExtension,
                                             (PVIDEO_CURSOR_ATTRIBUTES) ioBuffer,
                                             inputBufferLength);
            break;

        default:
            FsVgaPrint((1,
                        "FSVGA-FsVgaDeviceControl: INVALID REQUEST (0x%x)\n",
                        irpSp->Parameters.DeviceIoControl.IoControlCode));

            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    FsVgaPrint((2,"FSVGA-FsVgaDeviceControl: exit\n"));

    return(status);
}

NTSTATUS
FsVgaCopyFrameBuffer(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_COPY_FRAME_BUFFER CopyFrameBuffer,
    ULONG inputBufferLength
    )

/*++

Routine Description:

    This routine copy the frame buffer.

Arguments:

    DeviceExtension - Pointer to the miniport driver's device extension.

    CopyFrameBuffer - Pointer to the structure containing the information about the copy frame buffer.

    inputBufferLength - Length of the input buffer supplied by the user.

Return Value:

    STATUS_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    STATUS_SUCCESS if the operation completed successfully.

--*/

{
    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (inputBufferLength < sizeof(FSVIDEO_COPY_FRAME_BUFFER)) {
        return STATUS_INVALID_BUFFER_SIZE;
    }

    if (CopyFrameBuffer->SrcScreen.nNumberOfChars != CopyFrameBuffer->DestScreen.nNumberOfChars) {
        return STATUS_INVALID_PARAMETER;
    }

    if (! (DeviceExtension->CurrentMode.VideoMode.AttributeFlags & VIDEO_MODE_GRAPHICS))
    {
        /*
         * This is the TEXT frame buffer.
         */

        ULONG OffsSrc;
        ULONG OffsDest;
        PUCHAR pFrameBuf = DeviceExtension->CurrentMode.VideoMemory.FrameBufferBase;
        COORD ScreenSize ;
        COORD SrcScrnSize ;
        COORD SrcScrnPos ;
        COORD DstScrnSize ;
        COORD DstScrnPos ;

        ScreenSize = DeviceExtension->ScreenAndFont.ScreenSize ;
        SrcScrnSize = CopyFrameBuffer->SrcScreen.ScreenSize ;
        DstScrnSize = CopyFrameBuffer->DestScreen.ScreenSize ;
        SrcScrnPos = CopyFrameBuffer->SrcScreen.Position ;
        DstScrnPos = CopyFrameBuffer->DestScreen.Position ;

        if ((SrcScrnPos.X  > ScreenSize.X) ||
            (SrcScrnPos.Y  > ScreenSize.Y) ||
            (SrcScrnSize.X > ScreenSize.X) ||
            (DstScrnPos.X  > ScreenSize.X) ||
            (DstScrnPos.Y  > ScreenSize.Y) ||
            (DstScrnSize.X > ScreenSize.X) ||
            (SrcScrnPos.Y * SrcScrnSize.X + SrcScrnPos.X + CopyFrameBuffer->SrcScreen.nNumberOfChars 
                                                                   > (ULONG)ScreenSize.X * ScreenSize.Y) ||
            (DstScrnPos.Y * DstScrnSize.X + DstScrnPos.X + CopyFrameBuffer->DestScreen.nNumberOfChars 
                                                                   > (ULONG)ScreenSize.X * ScreenSize.Y)
              )
        {
            return STATUS_INVALID_BUFFER_SIZE;
        }

        OffsSrc = SCREEN_BUFFER_POINTER(CopyFrameBuffer->SrcScreen.Position.X,
                                        CopyFrameBuffer->SrcScreen.Position.Y,
                                        CopyFrameBuffer->SrcScreen.ScreenSize.X,
                                        sizeof(VGA_CHAR));

        OffsDest = SCREEN_BUFFER_POINTER(CopyFrameBuffer->DestScreen.Position.X,
                                         CopyFrameBuffer->DestScreen.Position.Y,
                                         CopyFrameBuffer->DestScreen.ScreenSize.X,
                                         sizeof(VGA_CHAR));

        RtlMoveMemory(pFrameBuf + OffsDest,
                      pFrameBuf + OffsSrc,
                      CopyFrameBuffer->SrcScreen.nNumberOfChars * sizeof(VGA_CHAR));
    }
    else
    {
        /*
         * This is the GRAPHICS frame buffer.
         */
        return FsgCopyFrameBuffer(DeviceExtension,
                                  CopyFrameBuffer,
                                  inputBufferLength);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FsVgaWriteToFrameBuffer(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_WRITE_TO_FRAME_BUFFER WriteFrameBuffer,
    ULONG inputBufferLength
    )

/*++

Routine Description:

    This routine write the frame buffer.

Arguments:

    DeviceExtension - Pointer to the miniport driver's device extension.

    WriteFrameBuffer - Pointer to the structure containing the information about the write frame buffer.

    inputBufferLength - Length of the input buffer supplied by the user.

Return Value:

    STATUS_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    STATUS_SUCCESS if the operation completed successfully.

--*/

{
    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (inputBufferLength < sizeof(FSVIDEO_WRITE_TO_FRAME_BUFFER)) {
        FsVgaPrint((1, "FsVgaWriteToFrameBuffer: Fail of STATUS_INVALID_BUFFER_SIZE\n"));
        return STATUS_INVALID_BUFFER_SIZE;
    }

    if (WriteFrameBuffer->DestScreen.Position.X < 0 ||
        WriteFrameBuffer->DestScreen.Position.X > DeviceExtension->ScreenAndFont.ScreenSize.X ||
        (SHORT)(WriteFrameBuffer->DestScreen.Position.X +
                WriteFrameBuffer->DestScreen.nNumberOfChars)
                                                > DeviceExtension->ScreenAndFont.ScreenSize.X ||
        WriteFrameBuffer->DestScreen.Position.Y < 0 ||
        WriteFrameBuffer->DestScreen.Position.Y > DeviceExtension->ScreenAndFont.ScreenSize.Y) {

        FsVgaPrint((1, "FsVgaWriteToFrameBuffer: Fail of STATUS_INVALID_BUFFER_SIZE\n"));

        return STATUS_INVALID_BUFFER_SIZE;
    }

    if (! (DeviceExtension->CurrentMode.VideoMode.AttributeFlags & VIDEO_MODE_GRAPHICS))
    {
        /*
         * This is the TEXT frame buffer.
         */

        ULONG Offs;
        PUCHAR pFrameBuf = DeviceExtension->CurrentMode.VideoMemory.FrameBufferBase;
        PCHAR_IMAGE_INFO pCharInfoUni = WriteFrameBuffer->SrcBuffer;
        PCHAR_IMAGE_INFO pCharInfoAsc;
        ULONG Length = WriteFrameBuffer->DestScreen.nNumberOfChars;
        PVOID pCapBuffer = NULL;
        ULONG cCapBuffer = 0;

        Offs = SCREEN_BUFFER_POINTER(WriteFrameBuffer->DestScreen.Position.X,
                                     WriteFrameBuffer->DestScreen.Position.Y,
                                     WriteFrameBuffer->DestScreen.ScreenSize.X,
                                     sizeof(VGA_CHAR));

        cCapBuffer = Length * sizeof(CHAR_IMAGE_INFO);
        pCapBuffer = ExAllocatePool(PagedPool, cCapBuffer);

        if (!pCapBuffer) {
            ULONG dumpData[DUMP_COUNT];

            FsVgaPrint((1,
                        "FSVGA-FsVgaWriteToFrameBuffer: Could not allocate resource list\n"));
            //
            // Log an error.
            //
            dumpData[0] = cCapBuffer;
            FsVgaLogError(DeviceExtension->DeviceObject,
                          FSVGA_INSUFFICIENT_RESOURCES,
                          FSVGA_ERROR_VALUE_BASE + 200,
                          STATUS_INSUFFICIENT_RESOURCES,
                          dumpData,
                          1
                         );
            return STATUS_UNSUCCESSFUL;
        }

        TranslateOutputToOem(pCapBuffer, pCharInfoUni, Length);

        pCharInfoAsc = pCapBuffer;
        pFrameBuf += Offs;
        while (Length--)
        {
            *pFrameBuf++ = pCharInfoAsc->CharInfo.Char.AsciiChar;
            *pFrameBuf++ = (UCHAR) (pCharInfoAsc->CharInfo.Attributes);
            pCharInfoAsc++;
        }

        ExFreePool(pCapBuffer);
    }
    else
    {
        /*
         * This is the GRAPHICS frame buffer.
         */
        return FsgWriteToFrameBuffer(DeviceExtension,
                                     WriteFrameBuffer,
                                     inputBufferLength);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FsVgaReverseMousePointer(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_REVERSE_MOUSE_POINTER MouseBuffer,
    ULONG inputBufferLength
    )

/*++

Routine Description:

    This routine reverse the frame buffer for mouse pointer.

Arguments:

    DeviceExtension - Pointer to the miniport driver's device extension.

    MouseBuffer - Pointer to the structure containing the information about the mouse frame buffer.

    inputBufferLength - Length of the input buffer supplied by the user.

Return Value:

    STATUS_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    STATUS_SUCCESS if the operation completed successfully.

--*/

{
    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (inputBufferLength < sizeof(FSVIDEO_REVERSE_MOUSE_POINTER)) {
        return STATUS_INVALID_BUFFER_SIZE;
    }

    if (! (DeviceExtension->CurrentMode.VideoMode.AttributeFlags & VIDEO_MODE_GRAPHICS))
    {
        /*
         * This is the TEXT frame buffer.
         */

        ULONG Offs;
        PUCHAR pFrameBuf = DeviceExtension->CurrentMode.VideoMemory.FrameBufferBase;
        UCHAR Attribute;

        Offs = SCREEN_BUFFER_POINTER(MouseBuffer->Screen.Position.X,
                                     MouseBuffer->Screen.Position.Y,
                                     MouseBuffer->Screen.ScreenSize.X,
                                     sizeof(VGA_CHAR));
        pFrameBuf += Offs;

        Attribute =  (*(pFrameBuf + 1) & 0xF0) >> 4;
        Attribute |= (*(pFrameBuf + 1) & 0x0F) << 4;
        *(pFrameBuf + 1) = Attribute;
    }
    else
    {
        /*
         * This is the GRAPHICS frame buffer.
         */
        return FsgReverseMousePointer(DeviceExtension,
                                      MouseBuffer,
                                      inputBufferLength);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FsVgaSetMode(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_MODE_INFORMATION ModeInformation,
    ULONG inputBufferLength
    )

/*++

Routine Description:

    This routine sets the current video information.

Arguments:

    DeviceExtension - Pointer to the miniport driver's device extension.

    ModeInformation - Pointer to the structure containing the information about the
                      full screen video.

    inputBufferLength - Length of the input buffer supplied by the user.

Return Value:

    STATUS_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    STATUS_SUCCESS if the operation completed successfully.

--*/

{
    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (inputBufferLength < sizeof(FSVIDEO_MODE_INFORMATION)) {
        return STATUS_INVALID_BUFFER_SIZE;
    }

    DeviceExtension->CurrentMode = *ModeInformation;

    FsVgaPrint((3, "FsVgaSetMode: Video Mode:\n"));
    FsVgaPrint((3, "    ModeIndex = %x\n", DeviceExtension->CurrentMode.VideoMode.ModeIndex));
    FsVgaPrint((3, "    VisScreenWidth = %d\n", DeviceExtension->CurrentMode.VideoMode.VisScreenWidth));
    FsVgaPrint((3, "    VisScreenHeight = %d\n", DeviceExtension->CurrentMode.VideoMode.VisScreenHeight));
    FsVgaPrint((3, "    NumberOfPlanes = %d\n", DeviceExtension->CurrentMode.VideoMode.NumberOfPlanes));
    FsVgaPrint((3, "    BitsPerPlane = %d\n", DeviceExtension->CurrentMode.VideoMode.BitsPerPlane));

    FsVgaPrint((3, "FsVgaSetMode: Video Memory:\n"));
    FsVgaPrint((3, "    VideoRamBase = %x\n", DeviceExtension->CurrentMode.VideoMemory.VideoRamBase));
    FsVgaPrint((3, "    VideoRamLength = %x\n", DeviceExtension->CurrentMode.VideoMemory.VideoRamLength));
    FsVgaPrint((3, "    FrameBufferBase = %x\n", DeviceExtension->CurrentMode.VideoMemory.FrameBufferBase));
    FsVgaPrint((3, "    FrameBufferLength = %x\n", DeviceExtension->CurrentMode.VideoMemory.FrameBufferLength));

    return STATUS_SUCCESS;
}

NTSTATUS
FsVgaSetScreenInformation(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_SCREEN_INFORMATION ScreenInformation,
    ULONG inputBufferLength
    )

/*++

Routine Description:

    This routine sets the screen and font information.

Arguments:

    DeviceExtension - Pointer to the miniport driver's device extension.

    ScreenInformation - Pointer to the structure containing the information about the
                        screen anf font.

    inputBufferLength - Length of the input buffer supplied by the user.

Return Value:

    STATUS_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    STATUS_SUCCESS if the operation completed successfully.

--*/

{
    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (inputBufferLength < sizeof(FSVIDEO_SCREEN_INFORMATION)) {
        return STATUS_INVALID_BUFFER_SIZE;
    }

    DeviceExtension->ScreenAndFont = *ScreenInformation;

    FsVgaPrint((3, "FsVgaSetScreenInformation:\n"));
    FsVgaPrint((3, "    ScreenSize.X = %d, Y = %d\n",
                   DeviceExtension->ScreenAndFont.ScreenSize.X,
                   DeviceExtension->ScreenAndFont.ScreenSize.Y));
    FsVgaPrint((3, "    FontSize.X = %d, Y = %d\n",
                   DeviceExtension->ScreenAndFont.FontSize.X,
                   DeviceExtension->ScreenAndFont.FontSize.Y));

    FsgVgaInitializeHWFlags(DeviceExtension);

    return STATUS_SUCCESS;
}

NTSTATUS
FsVgaSetCursorPosition(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_CURSOR_POSITION CursorPosition,
    ULONG inputBufferLength
    )

/*++

Routine Description:

    This routine sets the cursor position.

Arguments:

    DeviceExtension - Pointer to the miniport driver's device extension.

    CursorPosition - Pointer to the structure containing the information about the
                     cursor position.

    inputBufferLength - Length of the input buffer supplied by the user.

Return Value:

    STATUS_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    STATUS_SUCCESS if the operation completed successfully.

--*/

{
    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (inputBufferLength < sizeof(VIDEO_CURSOR_POSITION)) {
        return STATUS_INVALID_BUFFER_SIZE;
    }

    if (DeviceExtension->CurrentMode.VideoMode.AttributeFlags & VIDEO_MODE_GRAPHICS)
    {
        FsgInvertCursor(DeviceExtension,FALSE);
    }

    DeviceExtension->EmulateInfo.CursorPosition = *CursorPosition;

    if (DeviceExtension->CurrentMode.VideoMode.AttributeFlags & VIDEO_MODE_GRAPHICS)
    {
        FsgInvertCursor(DeviceExtension,TRUE);
        return STATUS_SUCCESS;
    }
    else
    {
        /*
         * If current video mode is a TEXT MODE.
         * FSVGA.SYS didn't handling hardware cursor
         * because I don't know device of VGA.SYS or others.
         *
         * In this case, by returns STATUS_UNSUCCESSFUL, caller 
         * do DeviceIoControl to VGA miniport driver.
         */
        return STATUS_UNSUCCESSFUL;
    }
}


NTSTATUS
FsVgaSetCursorAttribute(
    PDEVICE_EXTENSION DeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG inputBufferLength
    )

/*++

Routine Description:

    This routine sets the cursor attributes.

Arguments:

    DeviceExtension - Pointer to the miniport driver's device extension.

    CursorAttributes - Pointer to the structure containing the information about the
                       cursor attributes.

    inputBufferLength - Length of the input buffer supplied by the user.

Return Value:

    STATUS_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    STATUS_SUCCESS if the operation completed successfully.

--*/

{
    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (inputBufferLength < sizeof(VIDEO_CURSOR_ATTRIBUTES)) {
        return STATUS_INVALID_BUFFER_SIZE;
    }

    if (DeviceExtension->CurrentMode.VideoMode.AttributeFlags & VIDEO_MODE_GRAPHICS)
    {
        FsgInvertCursor(DeviceExtension,FALSE);
    }

    DeviceExtension->EmulateInfo.CursorAttributes = *CursorAttributes;

    if (DeviceExtension->CurrentMode.VideoMode.AttributeFlags & VIDEO_MODE_GRAPHICS)
    {
        FsgInvertCursor(DeviceExtension,TRUE);
        return STATUS_SUCCESS;
    }
    else
    {
        /*
         * If current video mode is a TEXT MODE.
         * FSVGA.SYS didn't handling hardware cursor
         * because I don't know device of VGA.SYS or others.
         *
         * In this case, by returns STATUS_UNSUCCESSFUL, caller 
         * do DeviceIoControl to VGA miniport driver.
         */
        return STATUS_UNSUCCESSFUL;
    }
}

VOID
FsVgaLogError(
    IN PVOID Object,
    IN NTSTATUS ErrorCode,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN PULONG DumpData,
    IN ULONG DumpCount
    )

/*++

Routine Description:

    This routine contains common code to write an error log entry.  It is
    called from other routines, especially FsVgaInitialize, to avoid
    duplication of code.  Note that some routines continue to have their
    own error logging code (especially in the case where the error logging
    can be localized and/or the routine has more data because there is
    and IRP).

Arguments:

    Object - Pointer to the device or driver object.

    ErrorCode - The error code for the error log packet.

    UniqueErrorValue - The unique error value for the error log packet.

    FinalStatus - The final status of the operation for the error log packet.

    DumpData - Pointer to an array of dump data for the error log packet.

    DumpCount - The number of entries in the dump data array.


Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    ULONG i;

    errorLogEntry = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(
                (PVOID) Object,
                (UCHAR) (sizeof(IO_ERROR_LOG_PACKET)
                         + (DumpCount * sizeof(ULONG)))
                );

    if (errorLogEntry != NULL) {

        errorLogEntry->ErrorCode = ErrorCode;
        errorLogEntry->DumpDataSize = (USHORT) (DumpCount * sizeof(ULONG));
        errorLogEntry->SequenceNumber = 0;
        errorLogEntry->MajorFunctionCode = 0;
        errorLogEntry->IoControlCode = 0;
        errorLogEntry->RetryCount = 0;
        errorLogEntry->UniqueErrorValue = UniqueErrorValue;
        errorLogEntry->FinalStatus = FinalStatus;
        for (i = 0; i < DumpCount; i++)
            errorLogEntry->DumpData[i] = DumpData[i];

        IoWriteErrorLogEntry(errorLogEntry);
    }
}


#if DBG
VOID
FsVgaDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print routine.

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None.

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= Globals.FsVgaDebug) {

        char buffer[128];

        (VOID) vsprintf(buffer, DebugMessage, ap);

        DbgPrint(buffer);
    }

    va_end(ap);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\fsvga\foncache.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    foncache.c

Abstract:

    This is the console fullscreen driver for the VGA card.

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "fsvga.h"



#define ADD_IMAGE     1
#define REPLACE_IMAGE 2


#define CALC_BITMAP_BITS_FOR_X( FontSizeX, dwAlign ) \
    ( ( ( FontSizeX * BITMAP_BITS_PIXEL + (dwAlign-1) ) & ~(dwAlign-1)) >> BITMAP_ARRAY_BYTE )



ULONG
CalcBitmapBufferSize(
    IN COORD FontSize,
    IN ULONG dwAlign
    )
{
    ULONG uiCount;

    uiCount = CALC_BITMAP_BITS_FOR_X(FontSize.X,
                                     (dwAlign==BYTE_ALIGN ? BITMAP_BITS_BYTE_ALIGN : BITMAP_BITS_WORD_ALIGN));
    uiCount = uiCount * BITMAP_PLANES * FontSize.Y;
    return uiCount;
}


VOID
AlignCopyMemory(
    OUT PUCHAR pDestBits,
    IN ULONG  dwDestAlign,
    IN PUCHAR pSrcBits,
    IN ULONG  dwSrcAlign,
    IN COORD  FontSize
    )
{
    ULONG dwDestBufferSize;
    COORD coord;

    try
    {

        if (dwDestAlign == dwSrcAlign) {
            dwDestBufferSize = CalcBitmapBufferSize(FontSize, dwDestAlign);
            RtlCopyMemory(pDestBits, pSrcBits, dwDestBufferSize);
            return;
        }

        switch (dwDestAlign) {
            default:
            case WORD_ALIGN:
                switch (dwSrcAlign) {
                    default:
                    //
                    // pDest = WORD, pSrc = WORD
                    //
                    case WORD_ALIGN:
                        dwDestBufferSize = CalcBitmapBufferSize(FontSize, dwDestAlign);
                        RtlCopyMemory(pDestBits, pSrcBits, dwDestBufferSize);
                        break;
                    //
                    // pDest = WORD, pSrc = BYTE
                    //
                    case BYTE_ALIGN:
                        dwDestBufferSize = CalcBitmapBufferSize(FontSize, dwDestAlign);
                        if (((FontSize.X % BITMAP_BITS_BYTE_ALIGN) == 0) &&
                            ((FontSize.X % BITMAP_BITS_WORD_ALIGN) == 0)   ) {
                            RtlCopyMemory(pDestBits, pSrcBits, dwDestBufferSize);
                        }
                        else {
                            RtlZeroMemory(pDestBits, dwDestBufferSize);
                            for (coord.Y=0; coord.Y < FontSize.Y; coord.Y++) {
                                for (coord.X=0;
                                     coord.X < CALC_BITMAP_BITS_FOR_X(FontSize.X, BITMAP_BITS_BYTE_ALIGN);
                                     coord.X++) {
                                    *pDestBits++ = *pSrcBits++;
                                }
                                if (CALC_BITMAP_BITS_FOR_X(FontSize.X, BITMAP_BITS_BYTE_ALIGN) & 1)
                                    pDestBits++;
                            }
                        }
                        break;
                }
                break;
            case BYTE_ALIGN:
                switch (dwSrcAlign) {
                    //
                    // pDest = BYTE, pSrc = BYTE
                    //
                    case BYTE_ALIGN:
                        dwDestBufferSize = CalcBitmapBufferSize(FontSize, dwDestAlign);
                        RtlCopyMemory(pDestBits, pSrcBits, dwDestBufferSize);
                        break;
                    default:
                    //
                    // pDest = BYTE, pSrc = WORD
                    //
                    case WORD_ALIGN:
                        dwDestBufferSize = CalcBitmapBufferSize(FontSize, dwDestAlign);
                        if (((FontSize.X % BITMAP_BITS_BYTE_ALIGN) == 0) &&
                            ((FontSize.X % BITMAP_BITS_WORD_ALIGN) == 0)   ) {
                            RtlCopyMemory(pDestBits, pSrcBits, dwDestBufferSize);
                        }
                        else {
                            RtlZeroMemory(pDestBits, dwDestBufferSize);
                            for (coord.Y=0; coord.Y < FontSize.Y; coord.Y++) {
                                for (coord.X=0;
                                     coord.X < CALC_BITMAP_BITS_FOR_X(FontSize.X, BITMAP_BITS_BYTE_ALIGN);
                                     coord.X++) {
                                    *pDestBits++ = *pSrcBits++;
                                }
                                if (CALC_BITMAP_BITS_FOR_X(FontSize.X, BITMAP_BITS_BYTE_ALIGN) & 1)
                                    pSrcBits++;
                            }
                        }
                        break;
                }
                break;
        }

    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\fsvga\misc.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    misc.c

Abstract:

    This is the console fullscreen driver for the VGA card.

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "fsvga.h"


int
ConvertOutputToOem(
    IN LPWSTR Source,
    IN int SourceLength,    // in chars
    OUT LPSTR Target,
    IN int TargetLength     // in chars
    )
/*
    Converts SourceLength Unicode characters from Source into
    not more than TargetLength Codepage characters at Target.
    Returns the number characters put in Target. (0 if failure)

    [ntcon\server\misc.c]
*/

{
    NTSTATUS Status;
    int Length;
    UNICODE_STRING SourceUni;
    ANSI_STRING TargetAns;
    CHAR AnsBuf[256];

    SourceUni.MaximumLength =
    SourceUni.Length = SourceLength * sizeof(WCHAR);
    SourceUni.Buffer = Source;

    TargetAns.Length = 0;
    TargetAns.MaximumLength = sizeof(AnsBuf);
    TargetAns.Buffer = AnsBuf;

    // Can do this in place
    Status = RtlUnicodeStringToAnsiString(&TargetAns,
                                          &SourceUni,
                                          FALSE);
    if (NT_SUCCESS(Status)) {
        Length = strlen(AnsBuf);
        if (Length <= TargetLength) {
            RtlMoveMemory(Target, AnsBuf, Length);
            return Length;
        }
        else {
            return 0;
        }
    } else {
        return 0;
    }
}

/***************************************************************************\
* TranslateOutputToOem
*
* routine to translate console PCHAR_INFO to the ASCII from Unicode
*
* [ntcon\server\fe\direct2.c]
\***************************************************************************/
NTSTATUS
TranslateOutputToOem(
    OUT PCHAR_IMAGE_INFO OutputBuffer,
    IN  PCHAR_IMAGE_INFO InputBuffer,
    IN  ULONG Length
    )
{
    CHAR AsciiDbcs[2];
    ULONG NumBytes;

    while (Length--)
    {
        if (InputBuffer->CharInfo.Attributes & COMMON_LVB_LEADING_BYTE)
        {
            if (Length >= 2)    // Safe DBCS in buffer ?
            {
                Length--;
                NumBytes = sizeof(AsciiDbcs);
                NumBytes = ConvertOutputToOem(&InputBuffer->CharInfo.Char.UnicodeChar,
                                              1,
                                              &AsciiDbcs[0],
                                              NumBytes);
                OutputBuffer->CharInfo.Char.AsciiChar = AsciiDbcs[0];
                OutputBuffer->CharInfo.Attributes = InputBuffer->CharInfo.Attributes;
                OutputBuffer++;
                InputBuffer++;
                OutputBuffer->CharInfo.Char.AsciiChar = AsciiDbcs[1];
                OutputBuffer->CharInfo.Attributes = InputBuffer->CharInfo.Attributes;
                OutputBuffer++;
                InputBuffer++;
            }
            else
            {
                OutputBuffer->CharInfo.Char.AsciiChar = ' ';
                OutputBuffer->CharInfo.Attributes = InputBuffer->CharInfo.Attributes & ~COMMON_LVB_SBCSDBCS;
                OutputBuffer++;
                InputBuffer++;
            }
        }
        else if (! (InputBuffer->CharInfo.Attributes & COMMON_LVB_SBCSDBCS))
        {
            ConvertOutputToOem(&InputBuffer->CharInfo.Char.UnicodeChar,
                               1,
                               &OutputBuffer->CharInfo.Char.AsciiChar,
                               1);
            OutputBuffer->CharInfo.Attributes = InputBuffer->CharInfo.Attributes;
            OutputBuffer++;
            InputBuffer++;
        }
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\fsvga\fsvga.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    fsvga.h

Abstract:

    This is the console fullscreen driver for the VGA card.

Environment:

    kernel mode only

Notes:

Revision History:

--*/


#ifndef _FSVGA_
#define _FSVGA_

#include "stdarg.h"
#include "stdio.h"

#include "ntddk.h"
#include "ntddvdeo.h"
#include "vga.h"

#include "fsvgalog.h"

#define FSVGA_POOL_TAG 'gVsF'
#undef ExAllocatePool
#define ExAllocatePool(Type, Bytes) ExAllocatePoolWithTag(Type, Bytes, FSVGA_POOL_TAG)

//
// Define the default number of elements in the class input data queue.
//
#define DUMP_COUNT 4
#define DEFAULT_DEBUG_LEVEL 0

//
// Define the i8042 controller input/output ports.
//

typedef enum _VGA_IO_PORT_TYPE {
    CRTCAddressPortColor = 0,
    CRTCDataPortColor,
    GRAPHAddressPort,
    SEQAddressPort,
    MaximumPortCount
} VGA_IO_PORT_TYPE;

typedef struct _PORT_LIST {
    PVOID   Port;
    ULONG   Length;
    BOOLEAN MapRegistersRequired;
} PORT_LIST, *PPORT_LIST;

//
// FSVGA configuration information.
//

typedef struct _FSVGA_CONFIGURATION_INFORMATION {

    USHORT    EmulationMode;
        #define ENABLE_WORD_WRITE_VRAM   0x01

    USHORT    HardwareCursor;
        #define NO_HARDWARE_CURSOR          0
        #define HARDWARE_CURSOR          0x01

    USHORT    HardwareScroll;
        #define NO_HARDWARE_SCROLL          0
        #define HARDWARE_SCROLL          0x01
        #define USE_LINE_COMPARE         0x02
        #define OFFSET_128_TO_NEXT_SLICE 0x04

    USHORT    IOPort;

} FSVGA_CONFIGURATION_INFORMATION, *PFSVGA_CONFIGURATION_INFORMATION;

//
// FSVGA resource information.
//

typedef struct _FSVGA_RESOURCE_INFORMATION {

    //
    // Indicate which hardware is actually present (display).
    //

    ULONG HardwarePresent;

#ifdef RESOURCE_REQUIREMENTS
    //
    // Bus interface type.
    //

    INTERFACE_TYPE InterfaceType;

    //
    // Bus Number.
    //

    ULONG BusNumber;
#endif

    //
    // The mapped addresses for this device's registers.
    //

    PORT_LIST PortList[MaximumPortCount];

} FSVGA_RESOURCE_INFORMATION, *PFSVGA_RESOURCE_INFORMATION;

//
// EMULATE_BUFFER_INFORMATION structure
//
typedef struct _EMULATE_BUFFER_INFORMATION {
    //
    // Hardware scroll
    //
    USHORT StartAddress;
    USHORT LineCompare;
    USHORT PrevLineCompare;
    USHORT BytePerLine;
    USHORT MaxScanLine;
    ULONG LimitGRAM;
        #define LIMIT_64K 0x10000L
    USHORT DeltaNextFontRow;
    //
    // Color Attributes for last access.
    //
    UCHAR ColorFg;
    UCHAR ColorBg;
    //
    // Cursor position and attributes for last access.
    VIDEO_CURSOR_ATTRIBUTES CursorAttributes;
    FSVIDEO_CURSOR_POSITION CursorPosition;
    BOOLEAN ShowCursor;
} EMULATE_BUFFER_INFORMATION, *PEMULATE_BUFFER_INFORMATION;

//
// Port device extension.
//

typedef struct _DEVICE_EXTENSION {

    //
    // Pointer to the device object.
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // Next lower driver in same stack.
    //

    PDEVICE_OBJECT LowerDeviceObject;

    //
    // Use count on this device.
    //

    LONG usage;

    //
    // Set when okay to remove this device.
    //

    KEVENT evRemove;

    //
    // TRUE if we're trying to remove this device.
    //

    BOOLEAN removing;

    //
    // TRUE if device has been started.
    //

    BOOLEAN started;

    //
    // Port resource information.
    //

    FSVGA_RESOURCE_INFORMATION Resource;

    //
    // FSVIDEO_MODE_INFORMATION structure for the current mode
    //
    FSVIDEO_MODE_INFORMATION CurrentMode;

    //
    // FSVIDEO_SCREEN_INFORMATION structure
    //
    FSVIDEO_SCREEN_INFORMATION ScreenAndFont;

    //
    // EMULATE_BUFFER_INFORMATION structure
    //
    EMULATE_BUFFER_INFORMATION EmulateInfo;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// Global shared data
//

typedef struct _GLOBALS {
    //
    // Declare the global debug flag for this driver.
    //
    ULONG               FsVgaDebug;

    //
    // A list of the registry path to the service parameters.
    //
    UNICODE_STRING      RegistryPath;

    //
    // Port configuration information.
    //
    FSVGA_CONFIGURATION_INFORMATION Configuration;

    //
    // Resource list and size
    //
    FSVGA_RESOURCE_INFORMATION      Resource;

} GLOBALS, *PGLOBALS;

extern GLOBALS Globals;


//
// Define the base values for the error log packet's UniqueErrorValue field.
//

#define FSVGA_ERROR_VALUE_BASE        1000

//
// Defines for DeviceExtension->HardwarePresent.
//

#define FSVGA_HARDWARE_PRESENT  1


//
// Function prototypes.
//


//
// fsvga.c
//
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
FsVgaQueryDevice(
    IN PFSVGA_RESOURCE_INFORMATION Resource
    );

NTSTATUS
FsVgaPeripheralCallout(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );

#ifdef RESOURCE_REQUIREMENTS
NTSTATUS
FsVgaQueryAperture(
    OUT PIO_RESOURCE_LIST *pApertureRequirements
    );
#endif

NTSTATUS
FsVgaCreateResource(
    IN PFSVGA_CONFIGURATION_INFORMATION configuration,
    OUT PCM_PARTIAL_RESOURCE_LIST *pResourceList
    );

VOID
FsVgaServiceParameters(
    IN PFSVGA_CONFIGURATION_INFORMATION configuration,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
FsVgaOpenCloseDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FsVgaDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FsVgaCopyFrameBuffer(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_COPY_FRAME_BUFFER CopyFrameBuffer,
    ULONG inputBufferLength
    );

NTSTATUS
FsVgaWriteToFrameBuffer(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_WRITE_TO_FRAME_BUFFER WriteFrameBuffer,
    ULONG inputBufferLength
    );

NTSTATUS
FsVgaReverseMousePointer(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_REVERSE_MOUSE_POINTER MouseBuffer,
    ULONG inputBufferLength
    );

NTSTATUS
FsVgaSetMode(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_MODE_INFORMATION ModeInformation,
    ULONG inputBufferLength
    );

NTSTATUS
FsVgaSetScreenInformation(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_SCREEN_INFORMATION ScreenInformation,
    ULONG inputBufferLength
    );

NTSTATUS
FsVgaSetCursorPosition(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_CURSOR_POSITION CursorPosition,
    ULONG inputBufferLength
    );

NTSTATUS
FsVgaSetCursorAttribute(
    PDEVICE_EXTENSION DeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG inputBufferLength
    );

VOID
FsVgaLogError(
    IN PVOID Object,
    IN NTSTATUS ErrorCode,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN PULONG DumpData,
    IN ULONG DumpCount
    );

#if DBG
VOID
FsVgaDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

extern ULONG FsVgaDebug;
#define FsVgaPrint(x) FsVgaDebugPrint x
#else
#define FsVgaPrint(x)
#endif

//
// drawscrn.c
//
ULONG
CalcGRAMSize(
    IN COORD WindowSize,
    IN PFSVIDEO_SCREEN_INFORMATION ScreenInfo,
    IN PEMULATE_BUFFER_INFORMATION EmulateInfo
    );

PUCHAR
CalcGRAMAddress(
    IN COORD WindowSize,
    IN PFSVIDEO_MODE_INFORMATION VideoModeInfo,
    IN PFSVIDEO_SCREEN_INFORMATION ScreenInfo,
    IN PEMULATE_BUFFER_INFORMATION EmulateInfo
    );

#ifdef LATER_HIGH_SPPED_VRAM_ACCESS  // kazum
BOOLEAN
IsGRAMRowOver(
    PUCHAR BufPtr,
    BOOLEAN fDbcs,
    IN PFSVIDEO_MODE_INFORMATION VideoModeInfo,
    IN PEMULATE_BUFFER_INFORMATION EmulateInfo
    );
#endif // LATER_HIGH_SPPED_VRAM_ACCESS  // kazum

PUCHAR
NextGRAMRow(
    PUCHAR BufPtr,
    IN PFSVIDEO_MODE_INFORMATION VideoModeInfo,
    IN PEMULATE_BUFFER_INFORMATION EmulateInfo
    );

VOID
memcpyGRAM(
    IN PCHAR TargetPtr,
    IN PCHAR SourcePtr,
    IN ULONG Length
    );

VOID
memcpyGRAMOver(
    IN PCHAR TargetPtr,
    IN PCHAR SourcePtr,
    IN ULONG Length,
    IN PUCHAR FrameBufPtr,
    IN PEMULATE_BUFFER_INFORMATION EmulateInfo
    );

VOID
MoveGRAM(
    IN PCHAR TargetPtr,
    IN PCHAR SourcePtr,
    IN ULONG Length,
    IN PUCHAR FrameBufPtr,
    IN PFSVGA_RESOURCE_INFORMATION ResourceInfo,
    IN PEMULATE_BUFFER_INFORMATION EmulateInfo
    );

NTSTATUS
FsgVgaInitializeHWFlags(
    PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
FsgCopyFrameBuffer(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_COPY_FRAME_BUFFER CopyFrameBuffer,
    ULONG inputBufferLength
    );

NTSTATUS
FsgWriteToFrameBuffer(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_WRITE_TO_FRAME_BUFFER WriteFrameBuffer,
    ULONG inputBufferLength
    );

NTSTATUS
FsgReverseMousePointer(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_REVERSE_MOUSE_POINTER MouseBuffer,
    ULONG inputBufferLength
    );

NTSTATUS
FsgInvertCursor(
    PDEVICE_EXTENSION DeviceExtension,
    BOOLEAN Invert
    );

NTSTATUS
FsgWriteToScreen(
    PUCHAR FrameBuffer,
    PUCHAR BitmapBuffer,
    ULONG cjBytes,
    BOOLEAN fDbcs,
    USHORT Attributes1,
    USHORT Attributes2,
    PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
FsgWriteToScreenCommonLVB(
    PUCHAR FrameBuffer,
    USHORT Attributes,
    PDEVICE_EXTENSION DeviceExtension
    );

UCHAR
AccessGRAM_WR(
    PUCHAR FrameBuffer,
    UCHAR  write
    );

UCHAR
AccessGRAM_RW(
    PUCHAR FrameBuffer,
    UCHAR  write
    );

UCHAR
AccessGRAM_AND(
    PUCHAR FrameBuffer,
    UCHAR  write
    );

//
// foncache.c
//
ULONG
CalcBitmapBufferSize(
    IN COORD FontSize,
    IN ULONG dwAlign
    );

VOID
AlignCopyMemory(
    OUT PUCHAR pDestBits,
    IN ULONG dwDestAlign,
    IN PUCHAR pSrcBits,
    IN ULONG dwSrcAlign,
    IN COORD FontSize
    );

//
// misc.c
//
int
ConvertOutputToOem(
    IN LPWSTR Source,
    IN int SourceLength,    // in chars
    OUT LPSTR Target,
    IN int TargetLength     // in chars
    );

NTSTATUS
TranslateOutputToOem(
    OUT PCHAR_IMAGE_INFO OutputBuffer,
    IN  PCHAR_IMAGE_INFO InputBuffer,
    IN  ULONG Length
    );

//
// port.c
//
VOID
GetHardwareScrollReg(
    PPORT_LIST PortList,
    PEMULATE_BUFFER_INFORMATION EmulateInfo
    );

VOID
SetGRAMWriteMode(
    PPORT_LIST PortList
    );

VOID
SetGRAMCopyMode(
    PPORT_LIST PortList
    );

VOID
SetGRAMInvertMode(
    PPORT_LIST PortList
    );

VOID
set_opaque_bkgnd_proc(
    PPORT_LIST PortList,
    PEMULATE_BUFFER_INFORMATION EmulateInfo,
    PUCHAR FrameBuffer,
    USHORT Attributes
    );

VOID
ColorSetGridMask(
    PPORT_LIST PortList,
    UCHAR BitMask
    );

VOID
ColorSetDirect(
    PPORT_LIST PortList,
    PUCHAR FrameBuffer,
    UCHAR ColorFg,
    UCHAR ColorBg
    );

//
// pnp.c
//
VOID
FsVgaDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
FsVgaAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT pdo
    );

NTSTATUS
FsVgaDevicePnp(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    );

NTSTATUS
FsVgaDefaultPnpHandler(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    );

NTSTATUS
FsVgaPnpRemoveDevice(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    );

NTSTATUS
FsVgaPnpStartDevice(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    );

NTSTATUS
FsVgaPnpStopDevice(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    );

#ifdef RESOURCE_REQUIREMENTS
NTSTATUS
FsVgaFilterResourceRequirements(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    );
#endif

NTSTATUS
FsVgaDevicePower(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    );

NTSTATUS 
FsVgaDefaultPowerHandler(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    );

NTSTATUS
CompleteRequest(
    IN PIRP Irp,
    IN NTSTATUS status,
    IN ULONG info
    );

NTSTATUS
ForwardAndWait(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    );

NTSTATUS
OnRequestComplete(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp,
    IN PKEVENT pev
    );

VOID
RemoveDevice(
    IN PDEVICE_OBJECT fdo
    );

BOOLEAN
LockDevice(
    IN PDEVICE_EXTENSION pdx
    );

VOID
UnlockDevice(
    IN PDEVICE_EXTENSION pdx
    );

NTSTATUS
StartDevice(
    IN PDEVICE_OBJECT fdo,
    IN PCM_PARTIAL_RESOURCE_LIST list
    );

VOID
StopDevice(
    IN PDEVICE_OBJECT fdo
    );

#endif // _FSVGA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\fsvga\pnp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    This module contains general PnP and Power code for the console fullscreen driver.

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "fsvga.h"

VOID
FsVgaDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine called when this driver is about to be unloaded. In
    previous versions of NT, this function would have gone through the list of
    DEV)CEOBJECTS belonging to this driver in order to delete each one. That
    function now happens (if it needs to) in response to IRP_MN_REMOVE_DEVICE
    PnP IRP's.

++*/

{
    FsVgaPrint((2,"FSVGA-FsVgaDriverUnload:\n"));

    ExFreePool(Globals.RegistryPath.Buffer);
}

NTSTATUS
FsVgaAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT pdo
    )

/*++

Routine Description:

    This routine called when the Configuration Manager detects (or gets told about
    via the New Hardware Wizard) a new device for which this module is the driver.
    Its main purpose is to create a functional device object (FDO) and to layer the
    FDO into the stack of device objects.

++*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_OBJECT fdo;
    PDEVICE_EXTENSION pdx;

    UNICODE_STRING DeviceName;

    ULONG uniqueErrorValue;
    NTSTATUS errorCode = STATUS_SUCCESS;
    ULONG dumpCount = 0;
    ULONG dumpData[DUMP_COUNT];

    FsVgaPrint((2,"FSVGA-FsVgaAddDevice: enter\n"));

    //
    // Create a functional device object to represent the hardware we're managing.
    //
    RtlInitUnicodeString(&DeviceName, DD_FULLSCREEN_VIDEO_DEVICE_NAME);

    status = IoCreateDevice(DriverObject,
                            sizeof(DEVICE_EXTENSION),
                            &DeviceName,
                            FILE_DEVICE_FULLSCREEN_VIDEO,
                            0,
                            TRUE,
                            &fdo);
    if (!NT_SUCCESS(status)) {
        FsVgaPrint((1,
                    "FSVGA-FsVgaAddDevice: Couldn't create device object\n"));
        status = STATUS_UNSUCCESSFUL;
        errorCode = FSVGA_INSUFFICIENT_RESOURCES;
        uniqueErrorValue = FSVGA_ERROR_VALUE_BASE + 2;
        dumpData[0] = 0;
        dumpCount = 1;
        goto FsVgaAddDeviceExit;
    }

    pdx = (PDEVICE_EXTENSION)fdo->DeviceExtension;
    pdx->DeviceObject = fdo;
    pdx->usage = 1;            // locked until RemoveDevice
    KeInitializeEvent(&pdx->evRemove, NotificationEvent, FALSE); // set when use count drops to zero

    //
    // Since we must pass PNP requests down to the next device object in the chain
    // (namely the physical device object created by the bus enumerator), we have
    // to remember what that device is. That's why we defined the LowerDeviceObject
    // member in our deviceextension.
    //
    pdx->LowerDeviceObject = IoAttachDeviceToDeviceStack(fdo, pdo);

    //
    // Monolithic kernel-mode drivers usually create device objects during DriverEntry,
    // and the I/O manager automatically clears the INITIALIZING flag. Since we're
    // creating the object later (namely in response to PnP START_DEVICE request),
    // we need to clear the flag manually.
    //
    fdo->Flags &= ~DO_DEVICE_INITIALIZING;

FsVgaAddDeviceExit:

    if (errorCode != STATUS_SUCCESS)
    {
        //
        // Log an error/warning message.
        //
        FsVgaLogError((fdo == NULL) ? (PVOID) DriverObject : (PVOID) fdo,
                      errorCode,
                      uniqueErrorValue,
                      status,
                      dumpData,
                      dumpCount
                     );
    }

    FsVgaPrint((2,"FSVGA-FsVgaAddDevice: exit\n"));

    return status;
}

NTSTATUS
FsVgaDevicePnp(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine uses the IRP's minor function code to dispatch a handler
    function (like HandleStartDevice for IRP_MN_START_DEVICE) that actually
    handles the request. It calls DefaultPnpHandler for requests that we don't
    specifically need to handle.

++*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION stack;
    UCHAR MinorFunction;

    if (!LockDevice((PDEVICE_EXTENSION)fdo->DeviceExtension)) {
        return CompleteRequest(Irp, STATUS_DELETE_PENDING, 0);
    }

    stack = IoGetCurrentIrpStackLocation(Irp);
    ASSERT(stack->MajorFunction == IRP_MJ_PNP);

    switch (MinorFunction = stack->MinorFunction) {
        case IRP_MN_START_DEVICE:
            status = FsVgaPnpStartDevice(fdo, Irp);
            break;
        case IRP_MN_REMOVE_DEVICE:
            status = FsVgaPnpRemoveDevice(fdo, Irp);
            break;
        case IRP_MN_STOP_DEVICE:
            status = FsVgaPnpStopDevice(fdo, Irp);
            break;
#ifdef RESOURCE_REQUIREMENTS
        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            status = FsVgaFilterResourceRequirements(fdo, Irp);
            break;
#endif
        default:
            FsVgaPrint((2,"FSVGA-FsVgaDevicePnp: MinorFunction:%x\n",stack->MinorFunction));
            status = FsVgaDefaultPnpHandler(fdo, Irp);
            break;
    }

    if (MinorFunction != IRP_MN_REMOVE_DEVICE) {
        UnlockDevice((PDEVICE_EXTENSION)fdo->DeviceExtension);
    }

    return status;
}

NTSTATUS
FsVgaDefaultPnpHandler(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function sends the request down to the next lower layer and
    returns whatever status that generates.

++*/

{
    PDEVICE_EXTENSION pdx;

    IoSkipCurrentIrpStackLocation(Irp);
    pdx = (PDEVICE_EXTENSION)fdo->DeviceExtension;

    return IoCallDriver(pdx->LowerDeviceObject, Irp);
}

NTSTATUS
FsVgaPnpRemoveDevice(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine calls StopDevice to shut the device down, DefaultPnpHandler
    to pass the request down the stack, and RemoveDevice to cleanup the FDO.

++*/

{
    NTSTATUS status;
    PDEVICE_EXTENSION pdx;

    FsVgaPrint((2,"FSVGA-FsVgaPnpRemoveDevice: enter\n"));

    //
    // Wait for any pending I/O operations to complete
    //
    pdx = (PDEVICE_EXTENSION)fdo->DeviceExtension;
    pdx->removing = TRUE;
    UnlockDevice(pdx);        // once for LockDevice at start of dispatch
    UnlockDevice(pdx);        // once for initialization during AddDevice
    KeWaitForSingleObject(&pdx->evRemove, Executive, KernelMode, FALSE, NULL);

    //
    // Do any processing required for *us* to remove the device. This
    // would include completing any outstanding requests, etc.
    //
    StopDevice(fdo);

    //
    // Let lower-level drivers handle this request. Ignore whatever
    // result eventuates.
    //
    status = FsVgaDefaultPnpHandler(fdo, Irp);

    //
    // Remove the device object
    //
    RemoveDevice(fdo);

    FsVgaPrint((2,"FSVGA-FsVgaPnpRemoveDevice: exit\n"));

    return status;
}

NTSTATUS
FsVgaPnpStartDevice(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine calls ForwardAndWait to pass the IRP down the stack and
    StartDevice to configure the device and this driver. Then it completes the
    IRP.

++*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION stack;

    FsVgaPrint((2,"FSVGA-FsVgaPnpStartDevice: enter\n"));

    //
    // First let all lower-level drivers handle this request. In this particular
    // sample, the only lower-level driver should be the physical device created
    // by the bus driver, but there could theoretically be any number of intervening
    // bus filter devices. Those drivers may need to do some setup at this point
    // in time before they'll be ready to handle non-PnP IRP's.
    //
    status = ForwardAndWait(fdo, Irp);
    if (!NT_SUCCESS(status)) {
        return CompleteRequest(Irp, status, Irp->IoStatus.Information);
    }

    stack = IoGetCurrentIrpStackLocation(Irp);

#if DBG
    {
        VOID ShowResources(IN PCM_PARTIAL_RESOURCE_LIST list);

        if (stack->Parameters.StartDevice.AllocatedResources != NULL) {
            KdPrint(("  Resources:\n"));
            ShowResources(&stack->Parameters.StartDevice.AllocatedResources->List[0].PartialResourceList);
        }

        if (stack->Parameters.StartDevice.AllocatedResourcesTranslated != NULL) {
            KdPrint(("  Translated Resources:\n"));
            ShowResources(&stack->Parameters.StartDevice.AllocatedResourcesTranslated->List[0].PartialResourceList);
        }
    }
#endif // DBG

    if (stack->Parameters.StartDevice.AllocatedResourcesTranslated != NULL) {
        status = StartDevice(fdo,
                             &stack->Parameters.StartDevice.AllocatedResourcesTranslated->List[0].PartialResourceList);
    }
    else {
        PCM_PARTIAL_RESOURCE_LIST list;

        FsVgaPrint((1,
                    "FSVGA-FsVgaPnpStartDevice: AllocatedResourcesTranslated is NULL\n" \
                    "*\n* Create hardware depended IO port list.\n*\n"
                  ));

        //
        // Create the current FsVga resource.
        //
        status = FsVgaCreateResource(&Globals.Configuration,&list);
        if (!NT_SUCCESS(status)) {
            return CompleteRequest(Irp, status, Irp->IoStatus.Information);
        }

#if DBG
        {
            VOID ShowResources(IN PCM_PARTIAL_RESOURCE_LIST list);

            if (list != NULL) {
                KdPrint(("  Resources:\n"));
                ShowResources(list);
            }
        }
#endif // DBG

        status = StartDevice(fdo, list);
    }

    FsVgaPrint((2,"FSVGA-FsVgaPnpStartDevice: exit\n"));

    return CompleteRequest(Irp, status, 0);
}

NTSTATUS
FsVgaPnpStopDevice(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    We will sometimes, but not always, get a STOP_DEVICE before getting a
    REMOVE_DEVICE.

++*/

{
    NTSTATUS status;

    FsVgaPrint((2,"FSVGA-FsVgaPnpStopDevice: enter\n"));

    status = FsVgaDefaultPnpHandler(fdo, Irp);
    StopDevice(fdo);

    FsVgaPrint((2,"FSVGA-FsVgaPnpStopDevice: exit\n"));

    return status;
}


#ifdef RESOURCE_REQUIREMENTS
NTSTATUS
FsVgaFilterResourceRequirements(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    Completion routine for IRP_MN_QUERY_RESOURCE_REQUIREMENTS. This adds on the
    FsVga resource requirements.

Arguments:

    fdo - Supplies the device object

    Irp - Supplies the IRP_MN_QUERY_RESOURCE_REQUIREMENTS Irp

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS status;
    PIO_RESOURCE_REQUIREMENTS_LIST OldRequirements = NULL;
    ULONG NewSize;
    PIO_RESOURCE_REQUIREMENTS_LIST NewRequirements = NULL;
    PIO_RESOURCE_LIST ApertureRequirements = NULL;
    PIO_STACK_LOCATION stack;

    ULONG uniqueErrorValue;
    NTSTATUS errorCode = STATUS_SUCCESS;
    ULONG dumpCount = 0;
    ULONG dumpData[DUMP_COUNT];

    FsVgaPrint((2,"FSVGA-FsVgaFilterResourceRequirements: enter\n"));

    stack = IoGetCurrentIrpStackLocation(Irp);

    OldRequirements = stack->Parameters.FilterResourceRequirements.IoResourceRequirementList;
    if (OldRequirements == NULL) {
        //
        // PNP helpfully passes us a NULL pointer instead of an empty resource list
        // when the bridge is disabled. In this case we will ignore this irp and not
        // add on our requirements since they are not going to be used anyway.
        //
        FsVgaPrint((3,"FSVGA-FsVgaFilterResourceRequirements: OldRequirements is NULL\n"));
    }

    //
    // Get the current FsVga aperture.
    //
    status = FsVgaQueryAperture(&ApertureRequirements);  /* , &Globals.Resource); */
    if (!NT_SUCCESS(status)) {
        status = STATUS_UNSUCCESSFUL;
        errorCode = FSVGA_INSUFFICIENT_RESOURCES;
        uniqueErrorValue = FSVGA_ERROR_VALUE_BASE + 2;
        dumpData[0] = 0;
        dumpCount = 1;
        goto FsVgaFilterResourceRequirementsExit;
    }

    //
    // We will add IO_RESOURCE_DESCRIPTORs to each alternative.
    //
    // Following this is the requirements returned from FsVgaQueryAperture. These
    // get marked as alternatives.
    //
    if (OldRequirements) {
        NewSize = OldRequirements->ListSize +
              ApertureRequirements->Count * OldRequirements->AlternativeLists * sizeof(IO_RESOURCE_DESCRIPTOR);
    }
    else {
        NewSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) +
              (ApertureRequirements->Count - 1) * sizeof(IO_RESOURCE_DESCRIPTOR);
    }

    NewRequirements = ExAllocatePool(PagedPool, NewSize);
    if (NewRequirements == NULL) {
        status = STATUS_UNSUCCESSFUL;
        errorCode = FSVGA_INSUFFICIENT_RESOURCES;
        uniqueErrorValue = FSVGA_ERROR_VALUE_BASE + 2;
        dumpData[0] = 0;
        dumpCount = 1;
        goto FsVgaFilterResourceRequirementsExit;
    }

    RtlZeroMemory(NewRequirements, NewSize);

    NewRequirements->ListSize         = NewSize;
    if (OldRequirements) {
        NewRequirements->InterfaceType    = OldRequirements->InterfaceType;
        NewRequirements->BusNumber        = OldRequirements->BusNumber;
        NewRequirements->SlotNumber       = OldRequirements->SlotNumber;
        NewRequirements->AlternativeLists = OldRequirements->AlternativeLists;
    }
    else {
        NewRequirements->InterfaceType    = Globals.Resource.InterfaceType;
        NewRequirements->BusNumber        = Globals.Resource.BusNumber;
        NewRequirements->SlotNumber       = 0;
        NewRequirements->AlternativeLists = 1;
    }

    //
    // Append our requirement to each alternative resource list.
    //
    if (OldRequirements) {
        PIO_RESOURCE_LIST OldResourceList;
        PIO_RESOURCE_LIST NewResourceList;
        ULONG Alternative;

        OldResourceList = &OldRequirements->List[0];
        NewResourceList = &NewRequirements->List[0];

        for (Alternative = 0; Alternative < OldRequirements->AlternativeLists; Alternative++) {
            PIO_RESOURCE_DESCRIPTOR Descriptor;
            ULONG i;

            //
            // Copy the old resource list into the new one.
            //
            NewResourceList->Version  = OldResourceList->Version;
            NewResourceList->Revision = OldResourceList->Revision;
            NewResourceList->Count    = OldResourceList->Count + ApertureRequirements->Count;
            RtlCopyMemory(&NewResourceList->Descriptors[0],
                          &OldResourceList->Descriptors[0],
                          OldResourceList->Count * sizeof(IO_RESOURCE_DESCRIPTOR));

            Descriptor = &NewResourceList->Descriptors[OldResourceList->Count];

            //
            // Append the alternatives
            //
            for (i = 0; i < ApertureRequirements->Count; i++) {
                //
                // Make sure this descriptor makes sense
                //
                ASSERT(ApertureRequirements->Descriptors[i].Flags == (CM_RESOURCE_PORT_IO));
                ASSERT(ApertureRequirements->Descriptors[i].Type  == CmResourceTypePort);
                ASSERT(ApertureRequirements->Descriptors[i].ShareDisposition == CmResourceShareShared);

                *Descriptor = ApertureRequirements->Descriptors[i];
                Descriptor->Option = IO_RESOURCE_ALTERNATIVE;

                ++Descriptor;
            }

            //
            // Advance to next resource list
            //
            NewResourceList = (PIO_RESOURCE_LIST)(NewResourceList->Descriptors + NewResourceList->Count);
            OldResourceList = (PIO_RESOURCE_LIST)(OldResourceList->Descriptors + OldResourceList->Count);
        }
    }
    else {
        PIO_RESOURCE_LIST NewResourceList;

        NewResourceList = &NewRequirements->List[0];
        NewResourceList->Version  = 1;
        NewResourceList->Revision = 1;
        NewResourceList->Count    = ApertureRequirements->Count;

        RtlCopyMemory(&NewResourceList->Descriptors[0],
                      &ApertureRequirements->Descriptors[0],
                      ApertureRequirements->Count * sizeof(IO_RESOURCE_DESCRIPTOR));
    }

    stack->Parameters.FilterResourceRequirements.IoResourceRequirementList = NewRequirements;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = (ULONG_PTR)NewRequirements;

FsVgaFilterResourceRequirementsExit:

    if (errorCode != STATUS_SUCCESS)
    {
        //
        // Log an error/warning message.
        //
        FsVgaLogError(fdo,
                      errorCode,
                      uniqueErrorValue,
                      status,
                      dumpData,
                      dumpCount
                     );
    }

    if (NT_SUCCESS(status)) {
        status = FsVgaDefaultPnpHandler(fdo, Irp);
    }
    else {
        status = CompleteRequest(Irp, status, 0);
    }

    if (OldRequirements)
        ExFreePool(OldRequirements);
    if (ApertureRequirements)
        ExFreePool(ApertureRequirements);

    FsVgaPrint((2,"FSVGA-FsVgaFilterResourceRequirements: exit (status=%x)\n", status));

    return status;
}
#endif


NTSTATUS
FsVgaDevicePower(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine uses the IRP's minor function code to dispatch a handler
    function (such as HandleSetPower for IRP_MN_SET_POWER). It calls DefaultPowerHandler
    for any function we don't specifically need to handle.

++*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION stack;

    if (!LockDevice((PDEVICE_EXTENSION)fdo->DeviceExtension)) {
        return CompleteRequest(Irp, STATUS_DELETE_PENDING, 0);
    }

    stack = IoGetCurrentIrpStackLocation(Irp);
    ASSERT(stack->MajorFunction = IRP_MJ_POWER);

    switch (stack->MinorFunction) {
        default:
            status = FsVgaDefaultPowerHandler(fdo, Irp);
            break;
    }

    UnlockDevice((PDEVICE_EXTENSION)fdo->DeviceExtension);
    return status;
}

NTSTATUS 
FsVgaDefaultPowerHandler(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function forwards a POWER IRP to the next driver using the
    special PoCallDriver function

++*/

{
    PDEVICE_EXTENSION pdx;

    FsVgaPrint((2,"FSVGA-FsVgaDefaultPowerHandler: enter\n"));

    PoStartNextPowerIrp(Irp);        // must be done while we own the IRP
    IoSkipCurrentIrpStackLocation(Irp);
    pdx = (PDEVICE_EXTENSION)fdo->DeviceExtension;

    FsVgaPrint((2,"FSVGA-FsVgaDefaultPowerHandler: exit\n"));

    return PoCallDriver(pdx->LowerDeviceObject, Irp);
}

NTSTATUS
CompleteRequest(
    IN PIRP Irp,
    IN NTSTATUS status,
    IN ULONG info
    )

/*++

Routine Description:

++*/

{
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = info;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

NTSTATUS
ForwardAndWait(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    The processor must be at PASSIVE IRQL because this function initializes
    and waits for non-zero time on a kernel event object.
    The only purpose of this routine in this particular driver is to pass down
    IRP_MN_START_DEVICE requests and wait for the PDO to handle them.

++*/

{
    KEVENT event;
    NTSTATUS status;
    PDEVICE_EXTENSION pdx;

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    // Initialize a kernel event object to use in waiting for the lower-level
    // driver to finish processing the object. It's a little known fact that the
    // kernel stack *can* be paged, but only while someone is waiting in user mode
    // for an event to finish. Since neither we nor a completion routine can be in
    // the forbidden state, it's okay to put the event object on the stack.

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp, (PIO_COMPLETION_ROUTINE)OnRequestComplete,
                           (PVOID)&event, TRUE, TRUE, TRUE);

    pdx = (PDEVICE_EXTENSION)fdo->DeviceExtension;
    status = IoCallDriver(pdx->LowerDeviceObject, Irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }

    return status;
}

NTSTATUS
OnRequestComplete(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp,
    IN PKEVENT pev
    )

/*++

Routine Description:

    This is the completion routine used for requests forwarded by ForwardAndWait. It
    sets the event object and thereby awakens ForwardAndWait.
    Note that it's *not* necessary for this particular completion routine to test
    the PendingReturned flag in the IRP and then call IoMarkIrpPending. You do that in many
    completion routines because the dispatch routine can't know soon enough that the
    lower layer has returned STATUS_PENDING. In our case, we're never going to pass a
    STATUS_PENDING back up the driver chain, so we don't need to worry about this.

++*/

{
    KeSetEvent(pev, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
RemoveDevice(
    IN PDEVICE_OBJECT fdo
    )

/*++

Routine Description:

    Whereas AddDevice gets called by the I/O manager directly, this
    function is called in response to a PnP request with the minor function code
    of IRP_MN_REMOVE_DEVICE.

++*/

{
    NTSTATUS status;
    PDEVICE_EXTENSION pdx;

    pdx = (PDEVICE_EXTENSION)fdo->DeviceExtension;
    if (pdx->LowerDeviceObject) {
        IoDetachDevice(pdx->LowerDeviceObject);
    }

    IoDeleteDevice(fdo);
}

BOOLEAN
LockDevice(
    IN PDEVICE_EXTENSION pdx
    )

/*++

Routine Description:

    A FALSE return value indicates that we're in the process of deleting
    the device object, so all new requests should be failed

++*/

{
    LONG usage;

    //
    // Increment use count on our device object
    //
    usage = InterlockedIncrement(&pdx->usage);

    //
    // AddDevice initialized the use count to 1, so it ought to be bigger than
    // one now. HandleRemoveDevice sets the "removing" flag and decrements the
    // use count, possibly to zero. So if we find a use count of "1" now, we
    // should also find the "removing" flag set.
    //
    ASSERT(usage > 1 || pdx->removing);

    //
    // If device is about to be removed, restore the use count and return FALSE.
    // If we're in a race with HandleRemoveDevice (maybe running on another CPU),
    // the sequence we've followed is guaranteed to avoid a mistaken deletion of
    // the device object. If we test "removing" after HandleRemoveDevice sets it,
    // we'll restore the use count and return FALSE. In the meantime, if
    // HandleRemoveDevice decremented the count to 0 before we did our increment,
    // its thread will have set the remove event. Otherwise, we'll decrement to 0
    // and set the event. Either way, HandleRemoveDevice will wake up to finish
    // removing the device, and we'll return FALSE to our caller.
    //
    // If, on the other hand, we test "removing" before HandleRemoveDevice sets it,
    // we'll have already incremented the use count past 1 and will return TRUE.
    // Our caller will eventually call UnlockDevice, which will decrement the use
    // count and might set the event HandleRemoveDevice is waiting on at that point.
    //
    if (pdx->removing) {
        if (InterlockedDecrement(&pdx->usage) == 0) {
                KeSetEvent(&pdx->evRemove, 0, FALSE);
        }
        return FALSE;
    }

    return TRUE;
}

VOID
UnlockDevice(
    IN PDEVICE_EXTENSION pdx
    )

/*++

Routine Description:

    If the use count drops to zero, set the evRemove event because we're
    about to remove this device object.

++*/

{
    LONG usage;

    usage = InterlockedDecrement(&pdx->usage);
    ASSERT(usage >= 0);
    if (usage == 0) {
        ASSERT(pdx->removing);    // HandleRemoveDevice should already have set this
        KeSetEvent(&pdx->evRemove, 0, FALSE);
    }
}

NTSTATUS
StartDevice(
    IN PDEVICE_OBJECT fdo,
    IN PCM_PARTIAL_RESOURCE_LIST list
    )

/*++

Routine Description:

    This function is called by the dispatch routine for IRP_MN_START_DEVICE
    in order to determine the configuration for the device and to prepare the driver
    and the device for subsequent operation.

++*/

{
    NTSTATUS status;
    PDEVICE_EXTENSION pdx;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR resource;
    ULONG i;

    FsVgaPrint((2,"FSVGA-StartDevice: enter\n"));

    pdx = (PDEVICE_EXTENSION)fdo->DeviceExtension;

    ASSERT(!pdx->started);

    RtlZeroMemory(&pdx->Resource.PortList, sizeof(pdx->Resource.PortList));

    // Identify the I/O resources we're supposed to use. In previous versions
    // of NT, this required nearly heroic efforts that were highly bus dependent.

    resource = list->PartialDescriptors;

    for (i = 0; i < list->Count; ++i, ++resource) {
        ULONG port;

        switch (resource->Type) {
            case CmResourceTypePort:
                switch (resource->u.Port.Start.QuadPart) {
                    case VGA_BASE_IO_PORT + CRTC_ADDRESS_PORT_COLOR:
                        port = CRTCAddressPortColor; break;
                    case VGA_BASE_IO_PORT + CRTC_DATA_PORT_COLOR:
                        port = CRTCDataPortColor;    break;
                    case VGA_BASE_IO_PORT + GRAPH_ADDRESS_PORT:
                        port = GRAPHAddressPort;     break;
                    case  VGA_BASE_IO_PORT + SEQ_ADDRESS_PORT:
                        port = SEQAddressPort;       break;
                    default:
                        port = -1;
                        FsVgaPrint((1,"FSVGA-StartDevice: CmResourceTypePort: Unknown port address %x\n", resource->u.Port.Start.LowPart));
                        break;
                }
                if (port != -1) {
                    if (resource->Flags & CM_RESOURCE_PORT_IO) {
                        pdx->Resource.PortList[port].Port =
                            (PUCHAR)resource->u.Port.Start.LowPart;
                        pdx->Resource.PortList[port].MapRegistersRequired = FALSE;
                    }
                    else {
                        pdx->Resource.PortList[port].Port =
                            (PUCHAR)MmMapIoSpace(resource->u.Port.Start,
                                                 resource->u.Port.Length,
                                                 MmNonCached);
                        pdx->Resource.PortList[port].Length = resource->u.Port.Length;
                        pdx->Resource.PortList[port].MapRegistersRequired = TRUE;
                    }
                }
                break;
            default:
                FsVgaPrint((1,"FSVGA-StartDevice: Unknown resource type %x\n", resource->Type));
                break;
        }
    }

    pdx->started = TRUE;

    FsVgaPrint((2,"FSVGA-StartDevice: exit\n"));

    return STATUS_SUCCESS;
}

VOID
StopDevice(
    IN PDEVICE_OBJECT fdo
    )

/*++

Routine Description:

    This function is called by the dispatch routine for IRP_MN_STOP_DEVICE
    in order to undo everything that was done inside StartDevice.

++*/

{
    ULONG i;
    PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION)fdo->DeviceExtension;

    if (!pdx->started)
        return;

    pdx->started = FALSE;

    for (i=0; i < MaximumPortCount; i++) {
        if (pdx->Resource.PortList[i].MapRegistersRequired) {
            MmUnmapIoSpace(pdx->Resource.PortList[i].Port,
                           pdx->Resource.PortList[i].Length);
        }
    }
}

#if DBG

// @func List PnP resources assigned to our device
// @parm List of resource descriptors to display
// @comm Used only in the checked build of the driver

#define arraysize(p) (sizeof(p)/sizeof((p)[0]))

VOID ShowResources(IN PCM_PARTIAL_RESOURCE_LIST list)
        {                                                       // ShowResources
        PCM_PARTIAL_RESOURCE_DESCRIPTOR resource;
        ULONG nres;
        ULONG i;

        if (list == NULL)
            return;

        resource = list->PartialDescriptors;
        if (resource == NULL)
            return;

        nres = list->Count;

        for (i = 0; i < nres; ++i, ++resource)
                {                                               // for each resource
                ULONG type = resource->Type;

                static char* name[] = {
                        "CmResourceTypeNull",
                        "CmResourceTypePort",
                        "CmResourceTypeInterrupt",
                        "CmResourceTypeMemory",
                        "CmResourceTypeDma",
                        "CmResourceTypeDeviceSpecific",
                        "CmResourceTypeBusNumber",
                        "CmResourceTypeDevicePrivate",
                        "CmResourceTypeAssignedResource",
                        "CmResourceTypeSubAllocateFrom",
                        };

                KdPrint(("    type %s", type < arraysize(name) ? name[type] : "unknown"));

                switch (type)
                        {                                       // select on resource type
                case CmResourceTypePort:
                case CmResourceTypeMemory:
                        KdPrint((" start %8X%8.8lX length %X\n",
                                resource->u.Port.Start.HighPart, resource->u.Port.Start.LowPart,
                                resource->u.Port.Length));
                        break;

                case CmResourceTypeInterrupt:
                        KdPrint(("  level %X, vector %X, affinity %X\n",
                                resource->u.Interrupt.Level, resource->u.Interrupt.Vector,
                                resource->u.Interrupt.Affinity));
                        break;

                case CmResourceTypeDma:
                        KdPrint(("  channel %d, port %X\n",
                                resource->u.Dma.Channel, resource->u.Dma.Port));
                        }                                       // select on resource type
                }                                               // for each resource
        }                                                       // ShowResources

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\fsvga\port.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    port.c

Abstract:

    This is the console fullscreen driver for the VGA card.

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "fsvga.h"

#define MAKEWORD(a, b) (USHORT)((((USHORT)a) & 0xFF) | ((((USHORT)(b)) << 8) & 0xFF00))

VOID
GetHardwareScrollReg(
    PPORT_LIST PortList,
    PEMULATE_BUFFER_INFORMATION EmulateInfo
    )

/*++

Routine Description:

    This routine gets the hardware scrolls register value.

Arguments:

Return Value:

--*/

{
    UCHAR low;
    UCHAR high;
    UCHAR mid;

    WRITE_PORT_UCHAR(PortList[CRTCAddressPortColor].Port,
                      IND_START_ADRS_L);
    low = READ_PORT_UCHAR(PortList[CRTCDataPortColor].Port);

    WRITE_PORT_UCHAR(PortList[CRTCAddressPortColor].Port,
                      IND_START_ADRS_H);
    high = READ_PORT_UCHAR(PortList[CRTCDataPortColor].Port);

    EmulateInfo->StartAddress = MAKEWORD(low, high);

    WRITE_PORT_UCHAR(PortList[CRTCAddressPortColor].Port,
                      IND_LINE_COMPARE);
    low = READ_PORT_UCHAR(PortList[CRTCDataPortColor].Port);

    WRITE_PORT_UCHAR(PortList[CRTCAddressPortColor].Port,
                      IND_LINE_COMPARE8);
    mid = READ_PORT_UCHAR(PortList[CRTCDataPortColor].Port);
    mid = (mid >> 4) & 1;

    WRITE_PORT_UCHAR(PortList[CRTCAddressPortColor].Port,
                      IND_LINE_COMPARE9);
    high = READ_PORT_UCHAR(PortList[CRTCDataPortColor].Port);
    high = (high >> 5) & 2;

    high |= mid;
    EmulateInfo->LineCompare = MAKEWORD(low, high);
}

VOID
SetGRAMWriteMode(
    PPORT_LIST PortList
    )

/*++

Routine Description:

    This routine sets the write mode of graphics register.

Arguments:

Return Value:

--*/

{
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_GRAPH_MODE, M_PROC_WRITE+M_DATA_READ));

    //
    // Set up to write data without interacting with the latches.
    //
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_DATA_ROTATE, DR_SET));

    //
    // Enable all the available EGA planes.
    //
    WRITE_PORT_USHORT(PortList[SEQAddressPort].Port,
                      MAKEWORD(IND_MAP_MASK, GRAPH_ADDR_MASK));
    //
    // Use all pixel positions.
    //
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_BIT_MASK, BIT_MASK_DEFAULT));

}

VOID
SetGRAMCopyMode(
    PPORT_LIST PortList
    )

/*++

Routine Description:

    This routine sets the copy mode of graphics register.

Arguments:

Return Value:

--*/

{
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_GRAPH_MODE, M_LATCH_WRITE+M_COLOR_READ));

    //
    // Set up to write data without interacting with the latches.
    //
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_DATA_ROTATE, DR_SET));

    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_COLOR_DONT_CARE, 0));
}

VOID
SetGRAMInvertMode(
    PPORT_LIST PortList
    )

/*++

Routine Description:

    This routine sets the invert mode of graphics register.

Arguments:

Return Value:

--*/

{
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_GRAPH_MODE, M_AND_WRITE+M_COLOR_READ));

    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_DATA_ROTATE, DR_XOR));

    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_BIT_MASK, BIT_MASK_DEFAULT));

    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_COLOR_DONT_CARE, 0));

    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_SET_RESET, 0xff));
}

VOID
set_opaque_bkgnd_proc(
    PPORT_LIST PortList,
    PEMULATE_BUFFER_INFORMATION EmulateInfo,
    PUCHAR FrameBuffer,
    USHORT Attributes
    )

/*++

set_opaque_bkgnd

  Set the VGA registers for drawing a full screen byte with opaque
  font and opaque background.

Created.

--*/

{
    UCHAR ColorFg = Attributes & 0x0f;
    UCHAR ColorBg = (Attributes & 0xf0) >> 4;

    if (Attributes & COMMON_LVB_REVERSE_VIDEO)
    {
        Attributes = ColorBg;
        ColorBg = ColorFg;
        ColorFg = (UCHAR)Attributes;
    }

    if (EmulateInfo->ColorFg == ColorFg &&
        EmulateInfo->ColorBg == ColorBg)
        return;

    EmulateInfo->ColorFg = ColorFg;
    EmulateInfo->ColorBg = ColorBg;

    ColorSetDirect(PortList, FrameBuffer, ColorFg, ColorBg);
}

VOID
ColorSetGridMask(
    PPORT_LIST PortList,
    UCHAR BitMask
    )
{

    //
    // That color is used for all planes.
    //
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_SET_RESET_ENABLE, GRAPH_ADDR_MASK));

    //
    // Change the Set/Reset register to be all set.
    //
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_SET_RESET, 0x07));

    //
    // Use specified pixel positions.
    //
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_BIT_MASK, BitMask));

    //
    // Set up to write data without interacting with the latches.
    //
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_DATA_ROTATE, DR_SET));
}

VOID
ColorSetDirect(
    PPORT_LIST PortList,
    PUCHAR FrameBuffer,
    UCHAR ColorFg,
    UCHAR ColorBg
    )

/*++

ColorSetDirect

  Set the VGA registers for drawing a full screen byte with opaque
  font and opaque background.

Created.

--*/

{
    //
    // Set up to write data without interacting with the latches.
    //
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_DATA_ROTATE, DR_SET));

    //
    // Put the background color in the Set/Reset register.
    //
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_SET_RESET, ColorBg));

    //
    // That color is used for all planes.
    //
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_SET_RESET_ENABLE, GRAPH_ADDR_MASK));

    //
    // This gets our background color into the latches.
    //
    AccessGRAM_WR(FrameBuffer, GRAPH_ADDR_MASK);

    //
    // Change the Set/Reset register to be all zeroes.
    //
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_SET_RESET, 0));

    //
    // The Set/Reset enable register now flags where the foreground/background colors are the same.
    //
    ColorFg = ~(ColorFg ^ ColorBg);
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_SET_RESET_ENABLE, ColorFg));

    //
    // Color differences will be xor'd with the latches.
    //
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_DATA_ROTATE, DR_XOR));


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\fsvga\driver\makefile.inc ===
fsvgalog.h fsvgalog.rc msg00001.bin: ..\fsvgalog.mc
    mc fsvgalog.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\fsvga\sources.inc ===
TARGETNAME=fsvga
TARGETPATH=obj
TARGETTYPE=DRIVER

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

INCLUDES=$(DDK_INC_PATH)

SOURCES=

i386_SOURCES=..\fsvga.rc   \
             ..\fsvga.c    \
             ..\drawscrn.c \
             ..\foncache.c \
             ..\misc.c     \
             ..\port.c     \
             ..\pnp.c      \
             ..\fsvgalog.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\fsvga\vga.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    vga.h

Abstract:

    This module contains the definitions for the code that implements the
    VGA device driver.

Author:

Environment:

    Kernel mode

Revision History:


--*/




//
// Base address of VGA memory range.  Also used as base address of VGA
// memory when loading a font, which is done with the VGA mapped at A0000.
//

#define MEM_VGA      0xA0000
#define MEM_VGA_SIZE 0x20000

//
// Index in the access range sturture for video memory
// !!! This must match the VgaAccessRange structure    !!!
// !!! Memory is in the structure, index 2 (3rd entry) !!!

#define VGA_MEMORY  2


//
// VGA port-related definitions.
//
//
// Port definitions for filling the ACCSES_RANGES structure in the miniport
// information, defines the range of I/O ports the VGA spans.
// There is a break in the IO ports - a few ports are used for the parallel
// port. Those cannot be defined in the ACCESS_RANGE, but are still mapped
// so all VGA ports are in one address range.
//

#define VGA_BASE_IO_PORT      0x000003B0
#define VGA_START_BREAK_PORT  0x000003BB
#define VGA_END_BREAK_PORT    0x000003C0
#define VGA_MAX_IO_PORT       0x000003DF

//
// VGA register definitions
//
                                            // ports in monochrome mode
#define CRTC_ADDRESS_PORT_MONO      0x0004  // CRT Controller Address and
#define CRTC_DATA_PORT_MONO         0x0005  // Data registers in mono mode
#define FEAT_CTRL_WRITE_PORT_MONO   0x000A  // Feature Control write port
                                            // in mono mode
#define INPUT_STATUS_1_MONO         0x000A  // Input Status 1 register read
                                            // port in mono mode
#define ATT_INITIALIZE_PORT_MONO    INPUT_STATUS_1_MONO
                                            // Register to read to reset
                                            // Attribute Controller index/data

#define ATT_ADDRESS_PORT            0x0010  // Attribute Controller Address and
#define ATT_DATA_WRITE_PORT         0x0010  // Data registers share one port
                                            // for writes, but only Address is
                                            // readable at 0x3C0
#define ATT_DATA_READ_PORT          0x0011  // Attribute Controller Data reg is
                                            // readable here
#define MISC_OUTPUT_REG_WRITE_PORT  0x0012  // Miscellaneous Output reg write
                                            // port
#define INPUT_STATUS_0_PORT         0x0012  // Input Status 0 register read
                                            // port
#define VIDEO_SUBSYSTEM_ENABLE_PORT 0x0013  // Bit 0 enables/disables the
                                            // entire VGA subsystem
#define SEQ_ADDRESS_PORT            0x0014  // Sequence Controller Address and
#define SEQ_DATA_PORT               0x0015  // Data registers
#define DAC_PIXEL_MASK_PORT         0x0016  // DAC pixel mask reg
#define DAC_ADDRESS_READ_PORT       0x0017  // DAC register read index reg,
                                            // write-only
#define DAC_STATE_PORT              0x0017  // DAC state (read/write),
                                            // read-only
#define DAC_ADDRESS_WRITE_PORT      0x0018  // DAC register write index reg
#define DAC_DATA_REG_PORT           0x0019  // DAC data transfer reg
#define FEAT_CTRL_READ_PORT         0x001A  // Feature Control read port
#define MISC_OUTPUT_REG_READ_PORT   0x001C  // Miscellaneous Output reg read
                                            // port
#define GRAPH_ADDRESS_PORT          0x001E  // Graphics Controller Address
#define GRAPH_DATA_PORT             0x001F  // and Data registers

#define CRTC_ADDRESS_PORT_COLOR     0x0024  // CRT Controller Address and
#define CRTC_DATA_PORT_COLOR        0x0025  // Data registers in color mode
#define FEAT_CTRL_WRITE_PORT_COLOR  0x002A  // Feature Control write port
#define INPUT_STATUS_1_COLOR        0x002A  // Input Status 1 register read
                                            // port in color mode
#define ATT_INITIALIZE_PORT_COLOR   INPUT_STATUS_1_COLOR
                                            // Register to read to reset
                                            // Attribute Controller index/data
                                            // toggle in color mode


//
// VGA indexed register indexes.
//

#define IND_CURSOR_START        0x0A    // index in CRTC of the Cursor Start
#define IND_CURSOR_END          0x0B    //  and End registers
#define IND_CURSOR_HIGH_LOC     0x0E    // index in CRTC of the Cursor Location
#define IND_CURSOR_LOW_LOC      0x0F    //  High and Low Registers
#define IND_VSYNC_END           0x11    // index in CRTC of the Vertical Sync
                                        //  End register, which has the bit
                                        //  that protects/unprotects CRTC
                                        //  index registers 0-7
#define IND_SET_RESET_ENABLE    0x01    // index of Set/Reset Enable reg in GC
#define IND_DATA_ROTATE         0x03    // index of Data Rotate reg in GC
#define IND_READ_MAP            0x04    // index of Read Map reg in Graph Ctlr
#define IND_GRAPH_MODE          0x05    // index of Mode reg in Graph Ctlr
#define IND_GRAPH_MISC          0x06    // index of Misc reg in Graph Ctlr
#define IND_BIT_MASK            0x08    // index of Bit Mask reg in Graph Ctlr
#define IND_SYNC_RESET          0x00    // index of Sync Reset reg in Seq
#define IND_MAP_MASK            0x02    // index of Map Mask in Sequencer
#define IND_MEMORY_MODE         0x04    // index of Memory Mode reg in Seq
#define IND_CRTC_PROTECT        0x11    // index of reg containing regs 0-7 in
                                        //  CRTC
#define IND_START_ADRS_H        0x0C    // index in CRTC of Start Address (high)
#define IND_START_ADRS_L        0x0D    // index in CRTC of Start Address (low)
#define IND_LINE_COMPARE        0x18    // index in CRTC of Line Compare (bit7-0)
#define IND_LINE_COMPARE8       0x07    // index in CRTC of Line Compare (bit8)
#define IND_LINE_COMPARE9       0x09    // index in CRTC of Line Compare (bit9)
#define IND_SET_RESET           0x00    // index of Set/Reset Plane Color Register in Graph Ctrl
#define IND_COLOR_DONT_CARE     0x07    // index of Color Don't Care Register in Graph Ctrl

#define START_SYNC_RESET_VALUE  0x01    // value for Sync Reset reg to start
                                        //  synchronous reset
#define END_SYNC_RESET_VALUE    0x03    // value for Sync Reset reg to end
                                        //  synchronous reset

//
// Values for Attribute Controller Index register to turn video off
// and on, by setting bit 5 to 0 (off) or 1 (on).
//

#define VIDEO_DISABLE 0
#define VIDEO_ENABLE  0x20

//
// Value written to the Read Map register when identifying the existence of
// a VGA in VgaInitialize. This value must be different from the final test
// value written to the Bit Mask in that routine.
//

#define READ_MAP_TEST_SETTING 0x03

//
// Masks to keep only the significant bits of the Graphics Controller and
// Sequencer Address registers. Masking is necessary because some VGAs, such
// as S3-based ones, don't return unused bits set to 0, and some SVGAs use
// these bits if extensions are enabled.
//

#define GRAPH_ADDR_MASK 0x0F
#define SEQ_ADDR_MASK   0x07

//
// IND_DATA_ROTATE : index of Data Rotate reg in GC
//
#define DR_ROT_CNT      0x07   // Data Rotate Count
#define DR_SET          0x00   // Data Unmodified
#define DR_AND          0x08   // Data ANDed with latches
#define DR_OR           0x10   // Data ORed    with latches
#define DR_XOR          0x18   // Data XORed with latches

//
// IND_GRAPH_MODE : index of Mode reg in Graph Ctlr
//
#define M_PROC_WRITE    0x00   // Write processor data rotated
#define M_LATCH_WRITE   0x01   // Write latched data
#define M_COLOR_WRITE   0x02   // Write processor data as color
#define M_AND_WRITE     0x03   // Write (procdata AND bitmask)
#define M_DATA_READ     0x00   // Read selected plane
#define M_COLOR_READ    0x08   // Read color compare

//
// Mask used to toggle Chain4 bit in the Sequencer's Memory Mode register.
//

#define CHAIN4_MASK 0x08

//
// Default text mode setting for various registers, used to restore their
// states if VGA detection fails after they've been modified.
//

#define MEMORY_MODE_TEXT_DEFAULT 0x02
#define BIT_MASK_DEFAULT 0xFF
#define READ_MAP_DEFAULT 0x00

//
// Palette-related info.
//

//
// Highest valid DAC color register index.
//

#define VIDEO_MAX_COLOR_REGISTER  0xFF

//
// Highest valid palette register index
//

#define VIDEO_MAX_PALETTE_REGISTER 0x0F
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\fsvga\fsconins\fsconins.cpp ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *      fsconins.cpp
 *
 *  Abstract:
 *
 *      This file contain FsConInstall class
 *
 *  Author:
 *
 *      Kazuhiko Matsubara (kazum) June-16-1999
 *
 *  Environment:
 *
 *    User Mode
 */

#define _FSCONINS_CPP_
#include <stdlib.h>
#include "oc.h"
#include "fsconins.h"

#include <initguid.h>
#include <devguid.h>
#include <cfgmgr32.h>
#pragma hdrstop


FsConInstall::FsConInstall()
{
    m_cd = NULL;
}

FsConInstall::FsConInstall(
    IN PPER_COMPONENT_DATA cd
    )
{
    m_cd = cd;
}

BOOL
FsConInstall::GUIModeSetupInstall(
    IN HWND hwndParent
)

/*++

Routine Description:

    This is the single entry point for Full Screen Console Driver
    GUI-mode setup install routine.

    It currently simply creates and installs a dev node for FSVGA/FSNEC to interact with
    PnP.

Arguments:

    hwndParent    Handle to parent window for GUI required by this function.

Return Value:

    TRUE on success.  FALSE, otherwise.

--*/

{
    HINSTANCE hndl = NULL;

    //
    // Create the deviceinfo list.
    //
    HDEVINFO devInfoSet;

    devInfoSet = SetupDiCreateDeviceInfoList(&GUID_DEVCLASS_DISPLAY, hwndParent);
    if (devInfoSet == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    //
    // Get the "offical" display class name.
    //
    SP_DEVINFO_DATA deviceInfoData;
    TCHAR className[MAX_CLASS_NAME_LEN];

    ZeroMemory(&deviceInfoData, sizeof(SP_DEVINFO_DATA));
    deviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    if (! SetupDiClassNameFromGuid(&GUID_DEVCLASS_DISPLAY,
                                   className,
                                   sizeof(className)/sizeof(TCHAR),
                                   NULL)) {
        return FALSE;
    }

    //
    // Create the dev node.
    //
    if (! SetupDiCreateDeviceInfo(devInfoSet,
                                  TEXT("Root\\DISPLAY\\0000"),
                                  &GUID_DEVCLASS_DISPLAY,
                                  NULL,
                                  hwndParent,
                                  NULL,              // No flags.
                                  &deviceInfoData)) {
        // If it already exists, then we are done ... because this was an upgrade.
        if (GetLastError() == ERROR_DEVINST_ALREADY_EXISTS) {
            return TRUE;
        }
        else {
            SetupDiDestroyDeviceInfoList(devInfoSet);
            return FALSE;
        }
    }
    else if (! SetupDiSetSelectedDevice(devInfoSet,
                                        &deviceInfoData)) {
        goto InstallError;
    }

    //
    // Add the FSVGA/FSNEC PnP ID.
    //

    // Create the PnP ID string.
    TCHAR pnpID[256];
    DWORD len;

    len = GetPnPID(pnpID, sizeof(pnpID)/sizeof(TCHAR));
    if (len == 0) {
        goto InstallError;
    }

    // Add it to the registry entry for the dev node.
    if (! SetupDiSetDeviceRegistryProperty(devInfoSet,
                                           &deviceInfoData,
                                           SPDRP_HARDWAREID,
                                           (CONST BYTE*)pnpID,
                                           (len + 1) * sizeof(TCHAR))) {
        goto InstallError;
    }

    //
    // Register the, as of yet, phantom dev node with PnP to turn it into a real dev node.
    //
    if (! SetupDiRegisterDeviceInfo(devInfoSet,
                                    &deviceInfoData,
                                    0,
                                    NULL,
                                    NULL,
                                    NULL)) {
        goto InstallError;
    }

    //
    // Get the device instance ID.
    //
    TCHAR devInstanceID[MAX_PATH];

    if (! SetupDiGetDeviceInstanceId(devInfoSet,
                                     &deviceInfoData,
                                     devInstanceID,
                                     sizeof(devInstanceID)/sizeof(TCHAR),
                                     NULL)) {
        goto InstallError;
    }

    //
    // Use newdev.dll to install FSVGA/FSNEC as the driver for this new dev node.
    //
    hndl = LoadLibrary(TEXT("newdev.dll"));
    if (hndl == NULL) {
        goto InstallError;
    }

    typedef BOOL (InstallDevInstFuncType)(
                        HWND hwndParent,
                        LPCWSTR DeviceInstanceId,
                        BOOL UpdateDriver,
                        PDWORD pReboot,
                        BOOL silentInstall);
    InstallDevInstFuncType *pInstallDevInst;

    pInstallDevInst = (InstallDevInstFuncType*)GetProcAddress(hndl, "InstallDevInstEx");
    if (pInstallDevInst == NULL) {
        goto InstallError;
    }

    if ((*pInstallDevInst)(hwndParent,
                           devInstanceID,
                           FALSE,
                           NULL,
                           TRUE)) {
        // Clean up and return success!
        SetupDiDestroyDeviceInfoList(devInfoSet);
        FreeLibrary(hndl);
        return TRUE;
    }

InstallError:
    SetupDiCallClassInstaller(DIF_REMOVE,
                              devInfoSet,
                              &deviceInfoData);
    SetupDiDestroyDeviceInfoList(devInfoSet);
    if (hndl != NULL) {
        FreeLibrary(hndl);
    }
    return FALSE;
}

BOOL
FsConInstall::GUIModeSetupUninstall(
    IN HWND hwndParent
)

/*++

Routine Description:

    This is the single entry point for Full Screen Console Driver
    GUI-mode setup uninstall routine.

    It currently simply remove the dev node created so that FSVGA/FSNEC can interact
    with PnP.

Arguments:

    hwndParent    Handle to parent window for GUI required by this function.

Return Value:

    TRUE on success.  FALSE, otherwise.

--*/

{
    //
    // Get the set of all devices with the FSVGA/FSNEC PnP ID.
    //
    HDEVINFO devInfoSet;
    GUID *pGuid = (GUID*)&GUID_DEVCLASS_DISPLAY;

    devInfoSet = SetupDiGetClassDevs(pGuid,
                                     NULL,
                                     hwndParent,
                                     DIGCF_PRESENT);
    if (devInfoSet == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    // Get FSVGA/FSNEC PnPID
    TCHAR FsConPnPID[256];
    DWORD len;

    len = GetPnPID(FsConPnPID, sizeof(FsConPnPID)/sizeof(TCHAR));
    if (len == 0) {
        return FALSE;
    }

    // Assume that we will be successful.
    BOOL result = TRUE;

    // Get the first device.
    DWORD iLoop = 0;
    BOOL bMoreDevices;
    SP_DEVINFO_DATA deviceInfoData;

    deviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

    //
    // Get the details for all matching device interfaces.
    //
    while (bMoreDevices = SetupDiEnumDeviceInfo(devInfoSet,
                                                iLoop++,
                                                &deviceInfoData)) {
        //
        // Get the PnP ID for the device.
        //
        TCHAR pnpID[256];

        if (SetupDiGetDeviceRegistryProperty(devInfoSet,
                                             &deviceInfoData,
                                             SPDRP_HARDWAREID,
                                             NULL,
                                             (BYTE*)pnpID,
                                             sizeof(pnpID),
                                             NULL)) {
            // If the current device matchs FSVGA/FSNEC, then remove it.
            if (! _tcscmp(pnpID, FsConPnPID)) {
                if (! SetupDiCallClassInstaller(DIF_REMOVE,
                                                devInfoSet,
                                                &deviceInfoData)) {
                    // If we failed here, set the return status to indicate failure,
                    // but don't give up on any other FSVGA/FSNEC dev nodes.
                    result = FALSE;
                }
            }
        }
    }

    // Release the device info list.
    SetupDiDestroyDeviceInfoList(devInfoSet);

    return result;
}

DWORD
FsConInstall::GetPnPID(
    OUT LPTSTR pszPnPID,
    IN  DWORD  dwSize
)
{
    INFCONTEXT context;

    if (! SetupFindFirstLine(m_cd->hinf,
                             TEXT("Manufacturer"),    // Section
                             NULL,                    // Key
                             &context)) {
        return 0;
    }

    TCHAR Manufacture[256];
    DWORD nSize;

    if (! SetupGetStringField(&context,
                              1,                      // Index
                              Manufacture,
                              sizeof(Manufacture)/sizeof(TCHAR),
                              &nSize)) {
        return 0;
    }

    if (! SetupFindFirstLine(m_cd->hinf,
                             Manufacture,             // Section
                             NULL,                    // Key
                             &context)) {
        return 0;
    }

    if (! SetupGetStringField(&context,
                              2,                      // Index 2 is PnP-ID
                              pszPnPID,
                              dwSize,
                              &nSize)) {
        return 0;
    }

    return _tcslen(pszPnPID);
}

BOOL
FsConInstall::InfSectionRegistryAndFiles(
    IN LPCTSTR SubcomponentId,
    IN LPCTSTR Key
    )
{
    INFCONTEXT context;
    TCHAR      section[256];
    BOOL       rc;

    rc = SetupFindFirstLine(m_cd->hinf,
                            SubcomponentId,
                            Key,
                            &context);
    if (rc) {
        rc = SetupGetStringField(&context,
                                 1,
                                 section,
                                 sizeof(section)/sizeof(TCHAR),
                                 NULL);
        if (rc) {
            rc = SetupInstallFromInfSection(NULL,            // hwndOwner
                                            m_cd->hinf,      // inf handle
                                            section,         //
                                            SPINST_ALL & ~SPINST_FILES,
                                                             // operation flags
                                            NULL,            // relative key root
                                            NULL,            // source root path
                                            0,               // copy flags
                                            NULL,            // callback routine
                                            NULL,            // callback routine context
                                            NULL,            // device info set
                                            NULL);           // device info struct
        }
    }

    return rc;
}


// loads current selection state info into "state" and
// returns whether the selection state was changed

BOOL
FsConInstall::QueryStateInfo(
    LPCTSTR SubcomponentId
    )
{
    return m_cd->HelperRoutines.QuerySelectionState(m_cd->HelperRoutines.OcManagerContext,
                                                    SubcomponentId,
                                                    OCSELSTATETYPE_CURRENT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\fsvga\fsconins\fsconins.h ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *      fsconins.h
 *
 *  Abstract:
 *
 *      This file defines FsConInstall class
 *
 *  Author:
 *
 *      Kazuhiko Matsubara (kazum) June-16-1999
 *
 *  Environment:
 *
 *    User Mode
 */

#ifdef _FSCONINS_H_
 #error "fsconins.h already included!"
#else
 #define _FSCONINS_H_
#endif


/*-[ types and defines ]-----------------------------------*/

class FsConInstall {

private:
    PPER_COMPONENT_DATA m_cd;

    DWORD
    GetPnPID(
        OUT LPTSTR pszPnPID,
        IN  DWORD  dwSize
    );

public:
    FsConInstall();

    FsConInstall(
        IN PPER_COMPONENT_DATA cd
    );


    BOOL
    GUIModeSetupInstall(
        IN HWND hwndParent = NULL
    );

    BOOL
    GUIModeSetupUninstall(
        IN HWND hwndParent = NULL
    );

    BOOL
    InfSectionRegistryAndFiles(
        IN LPCTSTR SubcomponentId,
        IN LPCTSTR Key
    );

    BOOL
    QueryStateInfo(
        IN LPCTSTR SubcomponentId
    );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\fsvga\inf\makefile.inc ===
# Copyright (c) 1998 - 1999 Microsoft Corporation
#
# For daytona, this file is designed to be included from 3 levels below
# ie, dayona\$(LANGUAGE)inf\srv, or daytona\$(LANGUAGE)inf\wks
#
# Note: NEC98 builds go through this file twice, the second time
# with "ALT_PROJECT"=="NEC_98".  These latter produce a subset
# of binaries which are only used on NEC98 machines.
#

STAMP=stampinf -f $@

!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

_LNG=..\..\$(LANGUAGE)
_INX=..\..
_INF=obj\$(TARGET_DIRECTORY)


make_infs:$(_INF)\fsvga.inf    \
          $(_INF)\fsvgaadd.inf \
          $(_INF)\fsvgadel.inf

$(_INF)\fsvga.inf: $(_INX)\fsvga.inx $(_LNG)\fsvga.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\fsvgaadd.inf: $(_INX)\fsvgaadd.inf
    copy $(_INX)\$(@B).inf $@
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\fsvgadel.inf: $(_INX)\fsvgadel.inf
    copy $(_INX)\$(@B).inf $@
    $(STAMP)
    $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\fsvga\fsconins\resource.h ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *      resource.h
 *
 *  Abstract:
 *
 *      This file contains all resources defines for fsvgains.dll
 *
 *  Author:
 *
 *      Pat Styles (patst) 21-Nov-1996
 *
 *  Environment:
 *
 *    User Mode
 */

#ifdef _RESOURCE_H_
 #error "resource.h already included!"
#else
 #define _RESOURCE_H_
#endif

#define IDS_DIALOG_CAPTION  1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\fsvga\inf\sources.inc ===
# Copyright (c) 1998 - 1999 Microsoft Corporation
#
# This file is designed to be included from 2 levels below
# (ie, daytona\srv, daytona\wks, cairo\srv, or cairo\wks).
#

SYNCHRONIZE_BLOCK=1

MAJORCOMP=setup
MINORCOMP=infs

TARGETNAME=inf
TARGETPATH=obj
TARGETTYPE=notarget

#
# No explicit sources because build doesn't understand .inf files.
#
SOURCES=

#
# Use NTTARGETFILE0 macros to cause the infs to get built during
# the compile phase. We do this so that we can disable MP build for
# this directory, using BLOCK and DRAIN.
#
NTTARGETFILE0=make_infs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\fsvga\fsconins\oc.cpp ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *      oc.cpp
 *
 *  Abstract:
 *
 *      This file handles all messages passed by the OC Manager
 *
 *  Author:
 *
 *      Kazuhiko Matsubara (kazum) June-16-1999
 *
 *  Environment:
 *
 *    User Mode
 */

#define _OC_CPP_
#include <stdlib.h>
#include "oc.h"
#include "fsconins.h"

#pragma hdrstop


/*
 * called by CRT when _DllMainCRTStartup is the DLL entry point
 */

BOOL
WINAPI
DllMain(
    IN HINSTANCE hinstance,
    IN DWORD     reason,
    IN LPVOID    reserved
    )
{
    UNREFERENCED_PARAMETER(reserved);

    if (reason == DLL_PROCESS_ATTACH) {
        ghinst = hinstance;
    }

    return TRUE;
}


DWORD_PTR
FsConInstallProc(
    IN     LPCTSTR ComponentId,
    IN     LPCTSTR SubcomponentId,
    IN     UINT    Function,
    IN     UINT    Param1,
    IN OUT PVOID   Param2
    )
{
    DWORD_PTR rc;

    switch(Function)
    {
    case OC_PREINITIALIZE:
        rc = OCFLAG_UNICODE;
        break;

    case OC_INIT_COMPONENT:
        rc = OnInitComponent(ComponentId, (PSETUP_INIT_COMPONENT)Param2);
        break;

    case OC_EXTRA_ROUTINES:
        rc = OnExtraRoutines(ComponentId, (PEXTRA_ROUTINES)Param2);
        break;

    case OC_QUERY_CHANGE_SEL_STATE:
        rc = OnQuerySelStateChange(ComponentId, SubcomponentId, Param1, (UINT)((UINT_PTR)Param2));
        break;

    case OC_CALC_DISK_SPACE:
        rc = OnCalcDiskSpace(ComponentId, SubcomponentId, Param1, Param2);
        break;

    case OC_QUERY_STEP_COUNT:
        rc = 0;
        break;

    case OC_COMPLETE_INSTALLATION:
        rc = OnCompleteInstallation(ComponentId, SubcomponentId);
        break;

    case OC_QUERY_STATE:
        rc = OnQueryState(ComponentId, SubcomponentId, Param1);
        break;

    default:
        rc = NO_ERROR;
        break;
    }

    return rc;
}

/*-------------------------------------------------------*/
/*
 * OC Manager message handlers
 *
 *-------------------------------------------------------*/



/*
 * OnInitComponent()
 *
 * handler for OC_INIT_COMPONENT
 */

DWORD
OnInitComponent(
    LPCTSTR ComponentId,
    PSETUP_INIT_COMPONENT psc
    )
{
    PPER_COMPONENT_DATA cd;
    TCHAR buf[256];
    HINF hinf;
    BOOL rc;

    // add component to linked list

    if (!(cd = AddNewComponent(ComponentId)))
        return ERROR_NOT_ENOUGH_MEMORY;

    // store component inf handle

    cd->hinf = (psc->ComponentInfHandle == INVALID_HANDLE_VALUE)
                                           ? NULL
                                           : psc->ComponentInfHandle;

    // open the inf

    if (cd->hinf)
        SetupOpenAppendInfFile(NULL, cd->hinf,NULL);

    // copy helper routines and flags

    cd->HelperRoutines = psc->HelperRoutines;

    cd->Flags = psc->SetupData.OperationFlags;

    cd->SourcePath = NULL;

    return NO_ERROR;
}

/*
 * OnExtraRoutines()
 *
 * handler for OC_EXTRA_ROUTINES
 */

DWORD
OnExtraRoutines(
    LPCTSTR ComponentId,
    PEXTRA_ROUTINES per
    )
{
    PPER_COMPONENT_DATA cd;

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    memcpy(&cd->ExtraRoutines, per, per->size);

    return NO_ERROR;
}

/*
 * OnQuerySelStateChange()
 *
 * don't let the user deselect the sam component
 */

DWORD
OnQuerySelStateChange(
    LPCTSTR ComponentId,
    LPCTSTR SubcomponentId,
    UINT    state,
    UINT    flags
    )
{
    return TRUE;
}

/*
 * OnCalcDiskSpace()
 *
 * handler for OC_ON_CALC_DISK_SPACE
 */

DWORD
OnCalcDiskSpace(
    LPCTSTR ComponentId,
    LPCTSTR SubcomponentId,
    DWORD   addComponent,
    HDSKSPC dspace
    )
{
    DWORD rc = NO_ERROR;
    TCHAR section[S_SIZE];
    PPER_COMPONENT_DATA cd;

    //
    // Param1 = 0 if for removing component or non-0 if for adding component
    // Param2 = HDSKSPC to operate on
    //
    // Return value is Win32 error code indicating outcome.
    //
    // In our case the private section for this component/subcomponent pair
    // is a simple standard inf install section, so we can use the high-level
    // disk space list api to do what we want.
    //

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    _tcscpy(section, SubcomponentId);

    if (addComponent)
    {
        rc = SetupAddInstallSectionToDiskSpaceList(dspace,
                                                   cd->hinf,
                                                   NULL,
                                                   section,
                                                   0,
                                                   0);
    }
    else
    {
        rc = SetupRemoveInstallSectionFromDiskSpaceList(dspace,
                                                        cd->hinf,
                                                        NULL,
                                                        section,
                                                        0,
                                                        0);
    }

    if (!rc)
        rc = GetLastError();
    else
        rc = NO_ERROR;

    return rc;
}

/*
 * OnCompleteInstallation
 *
 * handler for OC_COMPLETE_INSTALLATION
 */

DWORD
OnCompleteInstallation(
    LPCTSTR ComponentId,
    LPCTSTR SubcomponentId
    )
{
    PPER_COMPONENT_DATA cd;
    BOOL                rc;

    // Do post-installation processing in the cleanup section.
    // This way we know all compoents queued for installation
    // have beein installed before we do our stuff.

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    if (!SubcomponentId || !*SubcomponentId)
        return NO_ERROR;

    rc = TRUE;

    FsConInstall* pFsCon = new FsConInstall(cd);
    if (pFsCon == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    if (pFsCon->QueryStateInfo(SubcomponentId)) {
        //
        // installation
        //
        rc = pFsCon->GUIModeSetupInstall();
    }
    else {
        //
        // uninstallation
        //
        rc = pFsCon->GUIModeSetupUninstall();
        //
        // Remove any registry settings and files by Uninstall section on OC INF file.
        //
        if (rc) {
            rc = pFsCon->InfSectionRegistryAndFiles(SubcomponentId, TEXT("Uninstall"));
        }
    }

    delete pFsCon;

    if (rc) {
        return NO_ERROR;
    }
    else {
        return GetLastError();
    }
}

/*
 * OnQueryState()
 *
 * handler for OC_QUERY_STATE
 */

DWORD
OnQueryState(
    LPCTSTR ComponentId,
    LPCTSTR SubcomponentId,
    UINT    state
    )
{
    return SubcompUseOcManagerDefault;
}

/*
 * AddNewComponent()
 *
 * add new compononent to the top of the component list
 */

PPER_COMPONENT_DATA
AddNewComponent(
    LPCTSTR ComponentId
    )
{
    PPER_COMPONENT_DATA data;

    data = (PPER_COMPONENT_DATA)LocalAlloc(LPTR,sizeof(PER_COMPONENT_DATA));
    if (!data)
        return data;

    data->ComponentId = (TCHAR *)LocalAlloc(LMEM_FIXED,
            (_tcslen(ComponentId) + 1) * sizeof(TCHAR));

    if(data->ComponentId)
    {
        _tcscpy((TCHAR *)data->ComponentId, ComponentId);

        // Stick at head of list
        data->Next = gcd;
        gcd = data;
    }
    else
    {
        LocalFree((HLOCAL)data);
        data = NULL;
    }

    return(data);
}

/*
 * LocateComponent()
 *
 * returns a compoent struct that matches the
 * passed component id.
 */

PPER_COMPONENT_DATA
LocateComponent(
    LPCTSTR ComponentId
    )
{
    PPER_COMPONENT_DATA p;

    for (p = gcd; p; p=p->Next)
    {
        if (!_tcsicmp(p->ComponentId, ComponentId))
            return p;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\fsvga\fsconins\oc.h ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *      oc.h
 *
 *  Abstract:
 *
 *      This file defines oc manager generic component
 *
 *  Author:
 *
 *      Kazuhiko Matsubara (kazum) June-16-1999
 *
 *  Environment:
 *
 *    User Mode
 */

#ifdef _OC_H_
 #error "oc.h already included!"
#else
 #define _OC_H_
#endif

#ifndef _WINDOWS_H_
 #include <windows.h>
#endif

#ifndef _TCHAR_H_
 #include <tchar.h>
#endif

#ifndef _SETUPAPI_H_
 #include <setupapi.h>
#endif

#ifndef _OCMANAGE_H_
 #include "ocmanage.h"
#endif

#ifndef _PRSHT_H_
 #include <prsht.h>
#endif

#ifndef _RESOURCE_H_
 #include "resource.h"
#endif

/*-[ types and defines ]-----------------------------------*/

// standard buffer sizes

#define S_SIZE           1024
#define SBUF_SIZE        (S_SIZE * sizeof(TCHAR))

// per component data

typedef struct _PER_COMPONENT_DATA {
    struct _PER_COMPONENT_DATA* Next;
    LPCTSTR                     ComponentId;
    HINF                        hinf;
    DWORDLONG                   Flags;
    TCHAR*                      SourcePath;
    OCMANAGER_ROUTINES          HelperRoutines;
    EXTRA_ROUTINES              ExtraRoutines;
    HSPFILEQ                    queue;
} PER_COMPONENT_DATA, *PPER_COMPONENT_DATA;

/*-[ functions ]-------------------------------------------*/

//
// oc.cpp
//

DWORD
OnInitComponent(
    LPCTSTR ComponentId,
    PSETUP_INIT_COMPONENT psc
    );

DWORD
OnQuerySelStateChange(
    LPCTSTR ComponentId,
    LPCTSTR SubcomponentId,
    UINT    state,
    UINT    flags
    );

DWORD
OnCalcDiskSpace(
    LPCTSTR ComponentId,
    LPCTSTR SubcomponentId,
    DWORD addComponent,
    HDSKSPC dspace
    );

DWORD
OnCompleteInstallation(
    LPCTSTR ComponentId,
    LPCTSTR SubcomponentId
    );

DWORD
OnQueryState(
    LPCTSTR ComponentId,
    LPCTSTR SubcomponentId,
    UINT state
    );

DWORD
OnExtraRoutines(
    LPCTSTR ComponentId,
    PEXTRA_ROUTINES per
    );

PPER_COMPONENT_DATA
AddNewComponent(
    LPCTSTR ComponentId
    );

PPER_COMPONENT_DATA
LocateComponent(
    LPCTSTR ComponentId
    );

BOOL
StateInfo(
    PPER_COMPONENT_DATA cd,
    LPCTSTR SubcomponentId,
    BOOL *state
    );

// just for utility

#ifdef UNICODE
 #define tsscanf swscanf
 #define tvsprintf vswprintf
#else
 #define tsscanf sscanf
 #define tvsprintf vsprintf
#endif



/*-[ global data ]-----------------------------------------*/

#ifndef _OC_CPP_
#define EXTERN extern
#else
 #define EXTERN
#endif

// general stuff

EXTERN HINSTANCE  ghinst;  // app instance handle
EXTERN HWND       ghwnd;   // wizard window handle

// per-component info storage

EXTERN PPER_COMPONENT_DATA gcd;     // array of all components we are installing
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\fsvga\inf\daytona\gerinf\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\fsvga\inf\daytona\chsinf\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=CHS
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\fsvga\inf\daytona\chtinf\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=CHT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\fsvga\inf\daytona\jpninf\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=JPN
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\fsvga\inf\daytona\korinf\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=KOR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\fsvga\inf\daytona\usainf\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\headless\mini\headdata.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    headdata.c

Abstract:

    This module contains all the global data used by the headless driver.

Environment:

    Kernel mode

--*/

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"
#include "headless.h"

#if defined(ALLOC_PRAGMA)
#pragma data_seg("PAGE")
#endif

//
// Video mode table - contains information and commands for initializing each
// mode.
//

VIDEOMODE ModesHeadless[] = {

{
    640, 480
},

{
    800, 600
},

{
    1024, 768
}

};

ULONG NumVideoModes = sizeof(ModesHeadless) / sizeof(VIDEOMODE);

#if defined(ALLOC_PRAGMA)
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\headless\disp\driver.h ===
/******************************Module*Header*******************************\
* Module Name: driver.h
*
* Contains prototypes for the display driver.
*
* Copyright (c) 2000 Microsoft Corporation
\**************************************************************************/

typedef struct _PDEV PDEV;      // Handy forward declaration
//////////////////////////////////////////////////////////////////////
// Miscellaneous shared stuff

#define DLL_NAME                L"headlessd"          // Name of the DLL in UNICODE
#define STANDARD_DEBUG_PREFIX   "HEADLESS: "    // All debug output is prefixed
                                                //   by this string
#define ALLOC_TAG               'rgvD'          // Dvgr	//	Hdls
                                                // Four byte tag (characters in
                                                // reverse order) used for
                                                // memory allocations

#define DRIVER_EXTRA_SIZE   0   // Size of the DriverExtra information in the
                                //   DEVMODE structure

////////////////////////////////////////////////////////////////////////
// The Physical Device data structure

typedef struct  _PDEV
{
    HANDLE      hDriver;                // Handle to \Device\Screen
    HDEV        hdevEng;                // Engine's handle to PDEV

    LONG        cxScreen;               // Visible screen width
    LONG        cyScreen;               // Visible screen height

    HPALETTE    hpalDefault;            // GDI handle to the default palette.
    SURFOBJ*    pso;                    // DIB copy of our surface to which we
                                        //   have GDI draw everything

} PDEV, *PPDEV;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\headless\disp\precomp.h ===
/******************************Module*Header*******************************\
* Module Name: precomp.h
*
* Common headers used throughout the display driver.  This entire include
* file will typically be pre-compiled.
*
* Copyright (c) 2000 Microsoft Corporation
\**************************************************************************/

#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <windef.h>
#include <wingdi.h>
#include <winddi.h>
#include <devioctl.h>
#include <ntddvdeo.h>

#include "driver.h"
#include "debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\headless\mini\headless.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    headless.h

Abstract:

    This module contains the definitions for the code that implements the
    Headless device driver.

Author:

Environment:

    Kernel mode

--*/

#ifndef _HEADLESS_
#define _HEADLESS_

typedef struct {
    USHORT  hres;   // # of pixels across screen
    USHORT  vres;   // # of scan lines down screen
} VIDEOMODE, *PVIDEOMODE;

//
// Function prototypes.
//

VP_STATUS
HeadlessFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

BOOLEAN
HeadlessInitialize(
    PVOID HwDeviceExtension
    );

BOOLEAN
HeadlessStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

//
// Private function prototypes.
//

VP_STATUS
HeadlessQueryAvailableModes(
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    );

VP_STATUS
HeadlessQueryNumberOfAvailableModes(
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    PULONG OutputSize
    );

extern VIDEOMODE ModesHeadless[];
extern ULONG NumVideoModes;

#endif // _HEADLESS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\headless\disp\enable.c ===
/******************************Module*Header*******************************\
* Module Name: enable.c
*
* The initialization guts of the Headless driver.
*
* The drawing guts of a portable Headless driver for Windows NT.  The
* implementation herein may possibly be the simplest method of bringing
* up a driver whose surface is not directly writable by GDI.  One might
* use the phrase "quick and dirty" when describing it.
*
* We create a 4bpp bitmap that is the size of the screen, and simply
* have GDI do all the drawing to it.  We update the screen directly
* from the bitmap, based on the bounds of the drawing (basically
* employing "dirty rectangles").
*
* In total, the only hardware-specific code we had to write was the
* initialization code, and a routine for doing aligned srccopy blts
* from a DIB to the screen.
*
* Obvious Note: This approach is definitely not recommended for decent
*               driver performance.
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Structure****************************\
* DFVFN gadrvfn[]
*
* Build the driver function table gadrvfn with function index/address
* pairs.  This table tells GDI which DDI calls we support, and their
* location (GDI does an indirect call through this table to call us).
*
\**************************************************************************/

static DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV             },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV           },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV            },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface          },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface         },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode             },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes               }
};

ULONG gcdrvfn = sizeof(gadrvfn) / sizeof(DRVFN);

/******************************Public*Structure****************************\
* GDIINFO ggdiDefault
*
* This contains the default GDIINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for a 4bpp non-palette device.
\**************************************************************************/

GDIINFO ggdiDefault = {
     GDI_DRIVER_VERSION,
     DT_RASDISPLAY,         // ulTechnology
     0,                     // ulHorzSize
     0,                     // ulVertSize
     0,                     // ulHorzRes (filled in at initialization)
     0,                     // ulVertRes (filled in at initialization)
     4,                     // cBitsPixel
     1,                     // cPlanes
     16,                    // ulNumColors
     0,                     // flRaster (DDI reserved field)

     0,                     // ulLogPixelsX (filled in at initialization)
     0,                     // ulLogPixelsY (filled in at initialization)

     TC_RA_ABLE,            // flTextCaps

     6,                     // ulDACRed
     6,                     // ulDACGree
     6,                     // ulDACBlue

     0x0024,                // ulAspectX  (one-to-one aspect ratio)
     0x0024,                // ulAspectY
     0x0033,                // ulAspectXY

     1,                     // xStyleStep
     1,                     // yStyleSte;
     3,                     // denStyleStep

     { 0, 0 },              // ptlPhysOffset
     { 0, 0 },              // szlPhysSize

     0,                     // ulNumPalReg (win3.1 16 color drivers say 0 too)

// These fields are for halftone initialization.

     {                                          // ciDevice, ColorInfo
        { 6700, 3300, 0 },                      // Red
        { 2100, 7100, 0 },                      // Green
        { 1400,  800, 0 },                      // Blue
        { 1750, 3950, 0 },                      // Cyan
        { 4050, 2050, 0 },                      // Magenta
        { 4400, 5200, 0 },                      // Yellow
        { 3127, 3290, 0 },                      // AlignmentWhite
        20000,                                  // RedGamma
        20000,                                  // GreenGamma
        20000,                                  // BlueGamma
        0, 0, 0, 0, 0, 0
     },

     0,                      // ulDevicePelsDPI  (filled in at initialization)
     PRIMARY_ORDER_CBA,                         // ulPrimaryOrder
     HT_PATSIZE_4x4_M,                          // ulHTPatternSize
     HT_FORMAT_4BPP_IRGB,                       // ulHTOutputFormat
     HT_FLAG_ADDITIVE_PRIMS,                    // flHTFlags

     0,                                         // ulVRefresh
     1,                      // ulBltAlignment (preferred window alignment
                             //   for fast-text routines)
     0,                                         // ulPanningHorzRes
     0,                                         // ulPanningVertRes
};

/******************************Public*Structure****************************\
* DEVINFO gdevinfoDefault
*
* This contains the default DEVINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for a 4bpp non-palette device.
\**************************************************************************/

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS, \
                       CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY, \
                       VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS, \
                       CLIP_STROKE_PRECIS,PROOF_QUALITY, \
                       VARIABLE_PITCH | FF_DONTCARE,  L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS, \
                       CLIP_STROKE_PRECIS,PROOF_QUALITY, \
                       FIXED_PITCH | FF_DONTCARE, L"Courier"}

DEVINFO gdevinfoDefault =
{
    (GCAPS_MONO_DITHER | GCAPS_COLOR_DITHER), // Graphics capabilities
    SYSTM_LOGFONT,  // Default font description
    HELVE_LOGFONT,  // ANSI variable font description
    COURI_LOGFONT,  // ANSI fixed font description
    0,              // Count of device fonts
    BMF_4BPP,       // preferred DIB format
    8,              // Width of color dither
    8,              // Height of color dither
    0               // Default palette to use for this device
};

/******************************Public*Data*Struct*************************\
* VGALOGPALETTE logPalVGA
*
* This is the palette for the VGA.
*
\**************************************************************************/

typedef struct _VGALOGPALETTE
{
    USHORT          ident;
    USHORT          NumEntries;
    PALETTEENTRY    palPalEntry[16];
} VGALOGPALETTE;

const VGALOGPALETTE logPalVGA =
{
	0x500,  // Driver version
    16,     // Number of entries
    {
        { 0,   0,   0,   0 },       // 0
        { 0x80,0,   0,   0 },       // 1
        { 0,   0x80,0,   0 },       // 2
        { 0x80,0x80,0,   0 },       // 3
        { 0,   0,   0x80,0 },       // 4
        { 0x80,0,   0x80,0 },       // 5
        { 0,   0x80,0x80,0 },       // 6
        { 0x80,0x80,0x80,0 },       // 7

        { 0xC0,0xC0,0xC0,0 },       // 8
        { 0xFF,0,   0,   0 },       // 9
        { 0,   0xFF,0,   0 },       // 10
        { 0xFF,0xFF,0,   0 },       // 11
        { 0,   0,   0xFF,0 },       // 12
        { 0xFF,0,   0xFF,0 },       // 13
        { 0,   0xFF,0xFF,0 },       // 14
        { 0xFF,0xFF,0xFF,0 }        // 15
    }
};

/******************************Public*Routine******************************\
* BOOL DrvEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
\**************************************************************************/

BOOL DrvEnableDriver(
ULONG          iEngineVersion,
ULONG          cj,
DRVENABLEDATA* pded)
{
    // Engine Version is passed down so future drivers can support previous
    // engine versions.  A next generation driver can support both the old
    // and new engine conventions if told what version of engine it is
    // working with.  For the first version the driver does nothing with it.

    // Fill in as much as we can.

    if (cj >= sizeof(DRVENABLEDATA))
        pded->pdrvfn = gadrvfn;

    if (cj >= (sizeof(ULONG) * 2))
        pded->c = gcdrvfn;

    // DDI version this driver was targeted for is passed back to engine.
    // Future graphic's engine may break calls down to old driver format.

    if (cj >= sizeof(ULONG))
        pded->iDriverVersion = DDI_DRIVER_VERSION;

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID DrvDisableDriver
*
* Tells the driver it is being disabled. Release any resources allocated in
* DrvEnableDriver.
*
\**************************************************************************/

VOID DrvDisableDriver(VOID)
{
    return;
}

/******************************Public*Routine******************************\
* DWORD getAvailableModes
*
* Calls the miniport to get the list of modes supported by the kernel driver,
* and returns the list of modes supported by the diplay driver among those
*
* returns the number of entries in the videomode buffer.
* 0 means no modes are supported by the miniport or that an error occured.
*
* NOTE: the buffer must be freed up by the caller.
*
\**************************************************************************/

DWORD getAvailableModes(
HANDLE                   hDriver,
PVIDEO_MODE_INFORMATION* modeInformation,
DWORD*                   cbModeSize)
{
    ULONG ulTemp;
    VIDEO_NUM_MODES modes;
    DWORD status;

    //
    // Get the number of modes supported by the mini-port
    //

    if (status = EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
            NULL,
            0,
            &modes,
            sizeof(VIDEO_NUM_MODES),
            &ulTemp))
    {
        DISPDBG((0, "getAvailableModes failed VIDEO_QUERY_NUM_AVAIL_MODES"));
        DISPDBG((0, "Win32 Status = %x", status));
        return(0);
    }

    *cbModeSize = modes.ModeInformationLength;

    //
    // Allocate the buffer for the mini-port to write the modes in.
    //

    *modeInformation = (PVIDEO_MODE_INFORMATION)
                        EngAllocMem(FL_ZERO_MEMORY,
                                   modes.NumModes *
                                   modes.ModeInformationLength, ALLOC_TAG);

    if (*modeInformation == (PVIDEO_MODE_INFORMATION) NULL)
    {
        DISPDBG((0, "getAvailableModes failed EngAllocMem"));
        return(0);
    }

    //
    // Ask the mini-port to fill in the available modes.
    //

    if (status = EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_AVAIL_MODES,
            NULL,
            0,
            *modeInformation,
            modes.NumModes * modes.ModeInformationLength,
            &ulTemp))
    {

        DISPDBG((0, "getAvailableModes failed VIDEO_QUERY_AVAIL_MODES"));
        DISPDBG((0, "Win32 Status = %x", status));

        EngFreeMem(*modeInformation);
        *modeInformation = (PVIDEO_MODE_INFORMATION) NULL;

        return(0);
    }

    return(modes.NumModes);
}

/******************************Public*Routine******************************\
* BOOL bInitializeModeFields
*
* Initializes a bunch of fields in the pdev, devcaps (aka gdiinfo), and
* devinfo based on the requested mode.
*
\**************************************************************************/

BOOL bInitializeModeFields(
PDEV*     ppdev,
GDIINFO*  pgdi,
DEVINFO*  pdi,
DEVMODEW* pdm)
{
    ULONG                   cModes;
    PVIDEO_MODE_INFORMATION pVideoBuffer;
    PVIDEO_MODE_INFORMATION pVideoModeSelected;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    BOOL                    bSelectDefault;
    VIDEO_MODE_INFORMATION  VideoModeInformation;
    ULONG                   cbModeSize;

    // Call the miniport to get mode information

    cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize);
    if (cModes == 0)
        goto ReturnFalse;

    // Now see if the requested mode has a match in that table.

    pVideoModeSelected = NULL;
    pVideoTemp = pVideoBuffer;

    if ((pdm->dmPelsWidth        == 0) &&
        (pdm->dmPelsHeight       == 0) &&
        (pdm->dmBitsPerPel       == 0) &&
        (pdm->dmDisplayFrequency == 0))
    {
        DISPDBG((1, "Default mode requested"));
        bSelectDefault = TRUE;
    }
    else
    {
        DISPDBG((1, "Requested mode..."));
        DISPDBG((1, "   Screen width  -- %li", pdm->dmPelsWidth));
        DISPDBG((1, "   Screen height -- %li", pdm->dmPelsHeight));
        DISPDBG((1, "   Bits per pel  -- %li", pdm->dmBitsPerPel));
        DISPDBG((1, "   Frequency     -- %li", pdm->dmDisplayFrequency));

        bSelectDefault = FALSE;
    }

    while (cModes--)
    {
        if (pVideoTemp->Length != 0)
        {
            DISPDBG((2, "   Checking against miniport mode:"));
            DISPDBG((2, "      Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((2, "      Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((2, "      Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                                                      pVideoTemp->NumberOfPlanes));
            DISPDBG((2, "      Frequency     -- %li", pVideoTemp->Frequency));

            if (bSelectDefault ||
                ((pVideoTemp->VisScreenWidth  == pdm->dmPelsWidth) &&
                 (pVideoTemp->VisScreenHeight == pdm->dmPelsHeight) &&
                 (pVideoTemp->BitsPerPlane *
                  pVideoTemp->NumberOfPlanes  == pdm->dmBitsPerPel) &&
                 (pVideoTemp->Frequency       == pdm->dmDisplayFrequency)))
            {
                pVideoModeSelected = pVideoTemp;
                DISPDBG((1, "...Found a mode match!"));
                break;
            }
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + cbModeSize);

    }

    // If no mode has been found, return an error

    if (pVideoModeSelected == NULL)
    {
        DISPDBG((1, "...Couldn't find a mode match!"));
        EngFreeMem(pVideoBuffer);
        goto ReturnFalse;
    }

    // We have chosen the one we want.  Save it in a stack buffer and
    // get rid of allocated memory before we forget to free it.

    VideoModeInformation = *pVideoModeSelected;
    EngFreeMem(pVideoBuffer);

    // Set up screen information from the mini-port:

    ppdev->cxScreen         = VideoModeInformation.VisScreenWidth;
    ppdev->cyScreen         = VideoModeInformation.VisScreenHeight;

    // Fill in the GDIINFO data structure with the default 4bpp values:

    *pgdi = ggdiDefault;

    // Now overwrite the defaults with the relevant information returned
    // from the kernel driver:

    pgdi->ulHorzSize        = VideoModeInformation.XMillimeter;
    pgdi->ulVertSize        = VideoModeInformation.YMillimeter;

    pgdi->ulHorzRes         = VideoModeInformation.VisScreenWidth;
    pgdi->ulVertRes         = VideoModeInformation.VisScreenHeight;
    pgdi->ulPanningHorzRes  = VideoModeInformation.VisScreenWidth;
    pgdi->ulPanningVertRes  = VideoModeInformation.VisScreenHeight;

    pgdi->cBitsPixel        = VideoModeInformation.BitsPerPlane;
    pgdi->cPlanes           = VideoModeInformation.NumberOfPlanes;
    pgdi->ulVRefresh        = VideoModeInformation.Frequency;

    pgdi->ulDACRed          = VideoModeInformation.NumberRedBits;
    pgdi->ulDACGreen        = VideoModeInformation.NumberGreenBits;
    pgdi->ulDACBlue         = VideoModeInformation.NumberBlueBits;

    pgdi->ulLogPixelsX      = pdm->dmLogPixels;
    pgdi->ulLogPixelsY      = pdm->dmLogPixels;

    // Fill in the devinfo structure with the default 4bpp values:

    *pdi = gdevinfoDefault;

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bInitializeModeFields"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bInitializePalette
*
* Initializes default palette for PDEV.
*
\**************************************************************************/

BOOL bInitializePalette(
PDEV*    ppdev,
DEVINFO* pdi)
{
    HPALETTE    hpal;

    hpal = EngCreatePalette(PAL_INDEXED, 16, (ULONG*) (logPalVGA.palPalEntry),
                            0, 0, 0);

    if (hpal == 0)
        goto ReturnFalse;

    ppdev->hpalDefault = hpal;
    pdi->hpalDefault   = hpal;

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bInitializePalette"));
    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vUninitializePalette
*
* Frees resources allocated by bInitializePalette.
*
* Note: In an error case, this may be called before bInitializePalette.
*
\**************************************************************************/

VOID vUninitializePalette(PDEV* ppdev)
{
    // Delete the default palette if we created one:

    if (ppdev->hpalDefault != 0)
        EngDeletePalette(ppdev->hpalDefault);
}

/******************************Public*Routine******************************\
* DHPDEV DrvEnablePDEV
*
* Initializes a bunch of fields for GDI, based on the mode we've been asked
* to do.  This is the first thing called after DrvEnableDriver, when GDI
* wants to get some information about us.
*
* (This function mostly returns back information; DrvEnableSurface is used
* for initializing the hardware and driver components.)
*
\**************************************************************************/

DHPDEV DrvEnablePDEV(
DEVMODEW*   pdm,            // Contains data pertaining to requested mode
PWSTR       pwszLogAddr,    // Logical address
ULONG       cPat,           // Count of standard patterns
HSURF*      phsurfPatterns, // Buffer for standard patterns
ULONG       cjCaps,         // Size of buffer for device caps 'pdevcaps'
ULONG*      pdevcaps,       // Buffer for device caps, also known as 'gdiinfo'
ULONG       cjDevInfo,      // Number of bytes in device info 'pdi'
DEVINFO*    pdi,            // Device information
HDEV        hdev,           // HDEV, used for callbacks
PWSTR       pwszDeviceName, // Device name
HANDLE      hDriver)        // Kernel driver handle
{
    PDEV*   ppdev;

    // Future versions of NT had better supply 'devcaps' and 'devinfo'
    // structures that are the same size or larger than the current
    // structures:

    if ((cjCaps < sizeof(GDIINFO)) || (cjDevInfo < sizeof(DEVINFO)))
    {
        DISPDBG((0, "DrvEnablePDEV - Buffer size too small"));
        goto ReturnFailure0;
    }

    // Allocate a physical device structure.  Note that we definitely
    // rely on the zero initialization:

    ppdev = (PDEV*) EngAllocMem(FL_ZERO_MEMORY, sizeof(PDEV), ALLOC_TAG);
    if (ppdev == NULL)
    {
        DISPDBG((0, "DrvEnablePDEV - Failed EngAllocMem"));
        goto ReturnFailure0;
    }

    ppdev->hDriver = hDriver;

    // Get the current screen mode information.  Set up device caps and
    // devinfo:

    if (!bInitializeModeFields(ppdev, (GDIINFO*) pdevcaps, pdi, pdm))
    {
        DISPDBG((0, "DrvEnablePDEV - Failed bInitializeModeFields"));
        goto ReturnFailure1;
    }

    // Initialize palette information.

    if (!bInitializePalette(ppdev, pdi))
    {
        DISPDBG((0, "DrvEnablePDEV - Failed bInitializePalette"));
        goto ReturnFailure1;
    }

    return((DHPDEV) ppdev);

ReturnFailure1:
    DrvDisablePDEV((DHPDEV) ppdev);

ReturnFailure0:
    DISPDBG((0, "Failed DrvEnablePDEV"));

    return(0);
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
* Note: In an error, we may call this before DrvEnablePDEV is done.
*
\**************************************************************************/

VOID DrvDisablePDEV(
DHPDEV  dhpdev)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) dhpdev;

    vUninitializePalette(ppdev);
    EngFreeMem(ppdev);
}

/******************************Public*Routine******************************\
* VOID DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    ((PDEV*) dhpdev)->hdevEng = hdev;
}

/******************************Public*Routine******************************\
* HSURF DrvEnableSurface
*
* Creates the drawing surface, initializes the hardware, and initializes
* driver components.  This function is called after DrvEnablePDEV, and
* performs the final device initialization.
*
\**************************************************************************/

HSURF DrvEnableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;
    HSURF   hsurfShadow;
    SIZEL   sizl;
    DWORD status;
    ULONG ulTemp;

    ppdev = (PDEV*) dhpdev;

    // Create the 4bpp DIB on which we'll have GDI do all the drawing.
    // We'll merely occasionally blt portions to the screen to update.

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    hsurfShadow = (HSURF) EngCreateBitmap(sizl, 0, BMF_4BPP, 0, NULL);
    if (hsurfShadow == 0)
        goto ReturnFailure;

    if (!EngAssociateSurface(hsurfShadow, ppdev->hdevEng, 0))
    {
        DISPDBG((0, "DrvEnableSurface - Failed second EngAssociateSurface"));
        goto ReturnFailure;
    }

    ppdev->pso = EngLockSurface(hsurfShadow);
    if (ppdev->pso == NULL)
        goto ReturnFailure;

    /////////////////////////////////////////////////////////////////////
    // Now enable all the subcomponents.
    //
    // Note that the order in which these 'Enable' functions are called
    // may be significant in low off-screen memory conditions, because
    // the off-screen heap manager may fail some of the later
    // allocations...

    DISPDBG((5, "Passed DrvEnableSurface"));

    return hsurfShadow;

ReturnFailure:
    DrvDisableSurface((DHPDEV) ppdev);

    DISPDBG((0, "Failed DrvEnableSurface"));

    return(0);
}

/******************************Public*Routine******************************\
* VOID DrvDisableSurface
*
* Free resources allocated by DrvEnableSurface.  Release the surface.
*
* Note: In an error case, we may call this before DrvEnableSurface is
*       completely done.
*
\**************************************************************************/

VOID DrvDisableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;
    HSURF   hsurf;
    DWORD status;
    ULONG ulTemp;

    ppdev = (PDEV*) dhpdev;

    // Note: In an error case, some of the following relies on the
    //       fact that the PDEV is zero-initialized, so fields like
    //       'hsurfScreen' will be zero unless the surface has been
    //       sucessfully initialized, and makes the assumption that
    //       EngDeleteSurface can take '0' as a parameter.

    hsurf = ppdev->pso->hsurf;
    EngUnlockSurface(ppdev->pso);
    EngDeleteSurface(hsurf);
}

/******************************Public*Routine******************************\
* VOID DrvAssertMode
*
* This asks the device to reset itself to the mode of the pdev passed in.
*
\**************************************************************************/

BOOL DrvAssertMode(
DHPDEV  dhpdev,
BOOL    bEnable)
{
    return TRUE;
}

/******************************Public*Routine******************************\
* ULONG DrvGetModes
*
* Returns the list of available modes for the device.
*
\**************************************************************************/

ULONG DrvGetModes(
HANDLE      hDriver,
ULONG       cjSize,
DEVMODEW*   pdm)
{

    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;

    cModes = getAvailableModes(hDriver,
                            (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
                            &cbModeSize);
    if (cModes == 0)
    {
        DISPDBG((0, "DrvGetModes failed to get mode information"));
        return(0);
    }

    if (pdm == NULL)
    {
        cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
        //
        // Now copy the information for the supported modes back into the
        // output buffer
        //

        cbOutputSize = 0;

        pVideoTemp = pVideoModeInformation;

        do
        {
            if (pVideoTemp->Length != 0)
            {
                if (cOutputModes == 0)
                {
                    break;
                }

                //
                // Zero the entire structure to start off with.
                //

                memset(pdm, 0, sizeof(DEVMODEW));

                //
                // Set the name of the device to the name of the DLL.
                //

                memcpy(pdm->dmDeviceName, DLL_NAME, sizeof(DLL_NAME));

                pdm->dmSpecVersion      = DM_SPECVERSION;
                pdm->dmDriverVersion    = DM_SPECVERSION;
                pdm->dmSize             = sizeof(DEVMODEW);
                pdm->dmDriverExtra      = DRIVER_EXTRA_SIZE;

                pdm->dmBitsPerPel       = pVideoTemp->NumberOfPlanes *
                                          pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth        = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight       = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;
                pdm->dmDisplayFlags     = 0;

                pdm->dmFields           = DM_BITSPERPEL       |
                                          DM_PELSWIDTH        |
                                          DM_PELSHEIGHT       |
                                          DM_DISPLAYFREQUENCY |
                                          DM_DISPLAYFLAGS     ;

                //
                // Go to the next DEVMODE entry in the buffer.
                //

                cOutputModes--;

                pdm = (LPDEVMODEW) ( ((ULONG_PTR)pdm) + sizeof(DEVMODEW) +
                                                   DRIVER_EXTRA_SIZE);

                cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

            }

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                (((PUCHAR)pVideoTemp) + cbModeSize);


        } while (--cModes);
    }

    EngFreeMem(pVideoModeInformation);

    return(cbOutputSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\headless\disp\debug.h ===
/***************************************************************************\
* Module Name: debug.h
*
* Commonly used debugging macros.
*
* Copyright (c) 2000 Microsoft Corporation
\***************************************************************************/

#if DBG

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

#define DISPDBG(arg) DebugPrint arg
#define RIP(x) { DebugPrint(0, x); EngDebugBreak();}
#define ASSERTDD(x, y) if (!(x)) RIP (y)
#define STATEDBG(level)
#define LOGDBG(arg)

#else

#define DISPDBG(arg)
#define RIP(x)
#define ASSERTDD(x, y)
#define STATEDBG(level)
#define LOGDBG(arg)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\headless\mini\headless.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    headless.c

Abstract:

    This is the miniport driver for the hardware with no graphic adapter.
    Should work only with display driver for headless environment.

Environment:

    kernel mode only

Notes:

--*/

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"
#include "headless.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,DriverEntry)
#pragma alloc_text(PAGE,HeadlessFindAdapter)
#pragma alloc_text(PAGE,HeadlessInitialize)
#pragma alloc_text(PAGE,HeadlessStartIO)
#endif

ULONG
DriverEntry(
    PVOID Context1,
    PVOID Context2
    )

/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    Context1 - First context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

    Context2 - Second context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

Return Value:

    Status from VideoPortInitialize()

--*/

{

    VIDEO_HW_INITIALIZATION_DATA hwInitData;
    ULONG initializationStatus;

    //
    // Zero out structure.
    //

    VideoPortZeroMemory(&hwInitData, sizeof(VIDEO_HW_INITIALIZATION_DATA));

    hwInitData.HwInitDataSize = sizeof(VIDEO_HW_INITIALIZATION_DATA);

    //
    // Set entry points.
    //

    hwInitData.HwFindAdapter = HeadlessFindAdapter;
    hwInitData.HwInitialize  = HeadlessInitialize;
    hwInitData.HwStartIO     = HeadlessStartIO;

    hwInitData.AdapterInterfaceType = PCIBus;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    return initializationStatus;
}

VP_STATUS
HeadlessFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    )

/*++

Routine Description:

    This routine is called to determine if the adapter for this driver
    is present in the system.
    If it is present, the function fills out some information describing
    the adapter.

Arguments:

    HwDeviceExtension - Supplies the miniport driver's adapter storage. This
        storage is initialized to zero before this call.

    HwContext - Supplies the context value which was passed to
        VideoPortInitialize().

    ArgumentString - Supplies a NULL terminated ASCII string. This string
        originates from the user.

    ConfigInfo - Returns the configuration information structure which is
        filled by the miniport driver. This structure is initialized with
        any known configuration information (such as SystemIoBusNumber) by
        the port driver. Where possible, drivers should have one set of
        defaults which do not require any supplied configuration information.

    Again - Indicates if the miniport driver wants the port driver to call
        its VIDEO_HW_FIND_ADAPTER function again with a new device extension
        and the same config info. This is used by the miniport drivers which
        can search for several adapters on a bus.

Return Value:

    This routine must return:

    NO_ERROR - Indicates a host adapter was found and the
        configuration information was successfully determined.

    ERROR_INVALID_PARAMETER - Indicates an adapter was found but there was an
        error obtaining the configuration information. If possible an error
        should be logged.

    ERROR_DEV_NOT_EXIST - Indicates no host adapter was found for the
        supplied configuration information.

--*/

{

    VP_STATUS status;
    PHYSICAL_ADDRESS Zero = { 0, 0 };
    VIDEO_PORT_HEADLESS_INTERFACE HeadlessInterface;

    VideoDebugPrint((2, "Headless - FindAdapter\n"));

    //
    // Make sure the size of the structure is at least as large as what we
    // are expecting (check version of the config info structure).
    //

    if (ConfigInfo->Length < sizeof(VIDEO_PORT_CONFIG_INFO)) {

        return ERROR_INVALID_PARAMETER;
    }

    //
    // We only want this driver to load if no other video miniports
    // loaded successfully.
    //

    HeadlessInterface.Size = sizeof(VIDEO_PORT_HEADLESS_INTERFACE);
    HeadlessInterface.Version = 1;

    status = VideoPortQueryServices(
                 HwDeviceExtension,
                 VideoPortServicesHeadless,
                 (PINTERFACE)&HeadlessInterface);

    if (status == NO_ERROR) {

        ULONG DisplayDeviceCount;

        HeadlessInterface.InterfaceReference(HeadlessInterface.Context);

        DisplayDeviceCount =
            HeadlessInterface.HeadlessGetDeviceCount(HwDeviceExtension);

        HeadlessInterface.InterfaceDereference(HeadlessInterface.Context);

        if (DisplayDeviceCount != 0) {

            return ERROR_DEV_NOT_EXIST;
        }

    } else {

        return ERROR_INVALID_PARAMETER;
    }

    ConfigInfo->NumEmulatorAccessEntries = 0;
    ConfigInfo->EmulatorAccessEntries = NULL;
    ConfigInfo->EmulatorAccessEntriesContext = 0;

    ConfigInfo->VdmPhysicalVideoMemoryAddress = Zero;
    ConfigInfo->VdmPhysicalVideoMemoryLength = 0;

    //
    // Minimum size of the buffer required to store the hardware state
    // information returned by IOCTL_VIDEO_SAVE_HARDWARE_STATE.
    //

    ConfigInfo->HardwareStateSize = 0;

    //
    // Indicate we do not wish to be called again for another initialization.
    //

    *Again = 0;

    return NO_ERROR;

}

BOOLEAN
HeadlessInitialize(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine does one time initialization of the device.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

Return Value:

    None.

--*/

{
    VideoDebugPrint((2, "Headless - Initialize\n"));
    return TRUE;
}

BOOLEAN
HeadlessStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )

/*++

Routine Description:

    This routine is the main execution routine for the miniport driver. It
    acceptss a Video Request Packet, performs the request, and then returns
    with the appropriate status.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

    RequestPacket - Pointer to the video request packet. This structure
        contains all the parameters passed to the VideoIoControl function.

Return Value:

    This routine will return error codes from the various support routines
    and will also return ERROR_INSUFFICIENT_BUFFER for incorrectly sized
    buffers and ERROR_INVALID_FUNCTION for unsupported functions.

--*/

{
    VP_STATUS status;

    //
    // Switch on the IoContolCode in the RequestPacket. It indicates which
    // function must be performed by the driver.
    //

    switch (RequestPacket->IoControlCode) {

    case IOCTL_VIDEO_QUERY_AVAIL_MODES:

        VideoDebugPrint((2, "HeadlessStartIO - QueryAvailableModes\n"));

        status = HeadlessQueryAvailableModes(
                    (PVIDEO_MODE_INFORMATION)RequestPacket->OutputBuffer,
                    RequestPacket->OutputBufferLength,
                    (PULONG)(&RequestPacket->StatusBlock->Information));

        break;


    case IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES:

        VideoDebugPrint((2, "HeadlessStartIO - QueryNumAvailableModes\n"));

        status = HeadlessQueryNumberOfAvailableModes(
                    (PVIDEO_NUM_MODES) RequestPacket->OutputBuffer,
                    RequestPacket->OutputBufferLength,
                    (PULONG)(&RequestPacket->StatusBlock->Information));

        break;

    case IOCTL_VIDEO_RESET_DEVICE:

        VideoDebugPrint((2, "HeadlessStartIO - Got reset, perhaps for dummy device\n"));
        status = NO_ERROR;
        break;

    //
    // if we get here, an invalid IoControlCode was specified.
    //

    default:

        VideoDebugPrint((1, "Fell through headless startIO routine - invalid command 0x%08X\n", RequestPacket->IoControlCode));

        status = ERROR_INVALID_FUNCTION;

        break;

    }

    RequestPacket->StatusBlock->Status = status;

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\headless\disp\debug.c ===
/******************************Module*Header*******************************\
* Module Name: debug.c
*
* debug helpers routine
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

#if DBG

ULONG DebugLevel = 0;

/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive debug print
 *      routine.
 *      If the specified debug level for the print statement is lower or equal
 *      to the current debug level, the message will be printed.
 *
 *   Arguments:
 *
 *      DebugPrintLevel - Specifies at which debugging level the string should
 *          be printed
 *
 *      DebugMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

{

    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel)
    {
        EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
        EngDebugPrint("", "\n", ap);
    }

    va_end(ap);

}

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\bltmm.c ===
/******************************Module*Header*******************************\
*
* $Workfile:   BLTMM.C  $
*
* Contains the low-level memory-mapped IO blt functions.  This module
* mirrors 'bltio.c'.
*
* Hopefully, if you're basing your display driver on this code, to
* support all of DrvBitBlt and DrvCopyBits, you'll only have to implement
* the following routines.  You shouldn't have to modify much in
* 'bitblt.c'.  I've tried to make these routines as few, modular, simple,
* and efficient as I could, while still accelerating as many calls as
* possible that would be cost-effective in terms of performance wins
* versus size and effort.
*
* Note: In the following, 'relative' coordinates refers to coordinates
*       that haven't yet had the offscreen bitmap (DFB) offset applied.
*       'Absolute' coordinates have had the offset applied.  For example,
*       we may be told to blt to (1, 1) of the bitmap, but the bitmap may
*       be sitting in offscreen memory starting at coordinate (0, 768) --
*       (1, 1) would be the 'relative' start coordinate, and (1, 769)
*       would be the 'absolute' start coordinate'.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1997 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/BLTMM.C  $
*
*    Rev 1.3   Mar 04 1998 15:11:50   frido
* Added new shadow macros.
*
*    Rev 1.2   Nov 03 1997 11:44:02   frido
* Added REQUIRE macros.
*
\**************************************************************************/

#include "precomp.h"

#define BLTMM_DBG_LEVEL 0

extern BYTE gajRop[];

/******************************Public*Routine******************************\
* VOID vMmFillSolid
*
* Fills a list of rectangles with a solid colour.
*
\**************************************************************************/

VOID vMmFillSolid(              // Type FNFILL
PDEV*     ppdev,
LONG      c,                    // Can't be zero
RECTL*    prcl,                 // List of rectangles to be filled, in relative
                                                //  coordinates
ULONG     ulHwForeMix,  // Hardware mix mode
ULONG     ulHwBackMix,  // Not used
BRUSHOBJ* pbo,          // Drawing colour is pbo->iSolidColor
POINTL*   pptlBrush)    // Not used
{
        ULONG  ulColor;         // color

        ulColor = pbo->iSolidColor;
    switch (ppdev->ulBitCount)
        {
                case 8:
                        ulColor |= ulColor << 8;

                case 16:
                        ulColor |= ulColor << 16;
        }
        REQUIRE(4);
        LL_BGCOLOR(ulColor, 0);
        LL_DRAWBLTDEF((ppdev->uBLTDEF << 16) | ulHwForeMix, 0);

    do
    {
        REQUIRE(5);
        LL_OP0(prcl->left + ppdev->ptlOffset.x, prcl->top + ppdev->ptlOffset.y);
                LL_BLTEXT(prcl->right - prcl->left, prcl->bottom - prcl->top);

        prcl++;
    }
        while (--c != 0);
}

/******************************Public*Routine******************************\
* VOID vMmFillPatFast
*
* This routine uses the S3 pattern hardware to draw a patterned list of
* rectangles.
*
\**************************************************************************/

VOID vMmFillPatFast(            // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           ulHwForeMix,    // Hardware mix mode (foreground mix mode if
                                //   the brush has a mask)
ULONG           ulHwBackMix,    // Not used (unless the brush has a mask, in
                                //   which case it's the background mix mode)
BRUSHOBJ*                pbo,            // pbo
POINTL*         pptlBrush)      // Pattern alignment
{
        ULONG ulBltDef = ppdev->uBLTDEF;

        if (!SetBrush(ppdev, &ulBltDef, pbo, pptlBrush))
        {
                return;
        }

    REQUIRE(2);
    LL_DRAWBLTDEF((ulBltDef << 16) | ulHwForeMix, 2);

    do
    {
                REQUIRE(5);
                LL_OP0(prcl->left + ppdev->ptlOffset.x, prcl->top + ppdev->ptlOffset.y);
                LL_BLTEXT(prcl->right - prcl->left, prcl->bottom - prcl->top);

                prcl++;
    }
    while (--c != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\5465bw.c ===
/**********************************************************
* Copyright Cirrus Logic, 1997. All rights reserved.
***********************************************************
*
*  5465BW.C - Bandwidth functions for CL-GD5465
*
***********************************************************
*
*  Author: Rick Tillery
*  Date:   03/20/97
*
*  Revision History:
*  -----------------
*  WHO             WHEN            WHAT/WHY/HOW
*  ---             ----            ------------
*
***********************************************************/

#include "precomp.h"

#if defined WINNT_VER35      // WINNT_VER35
// If WinNT 3.5 skip all the source code
#elif defined (NTDRIVER_546x)
// If WinNT 4.0 and 5462/64 build skip all the source code
#else

#ifndef WINNT_VER40
#include "5465BW.h"
#endif

/**********************************************************
*
* ScaleMultiply()
*
* Calculates product of two DWORD factors supplied.  If the
*  result would overflow a DWORD, the larger of the two factors
*  is divided by 2 (shifted right) until the overflow will
*  not occur.
*
* Returns: Number of right shifts applied to the product.
*          Product of the factors shifted by the value above.
*
***********************************************************
* Author: Rick Tillery
* Date:   11/18/95
*
* Revision History:
* -----------------
* WHO WHEN     WHAT/WHY/HOW
* --- ----     ------------
*********************************************************/
static int ScaleMultiply(DWORD   dw1,
                         DWORD   dw2,
                         LPDWORD pdwResult)
{
  int   iShift = 0;   // Start with no shifts
  DWORD dwLimit;

//  ODS("ScaleMultiply() called.\n");

  // Either factor 0 will be a zero result and also cause a problem
  //  in our divide below.
  if((0 == dw1) || (0 == dw2))
  {
    *pdwResult = 0;
  }
  else
  {
    // Determine which factor is larger
    if(dw1 > dw2)
    {
      // Determine largest number by with dw2 can be multiplied without
      //  overflowing a DWORD.
      dwLimit = 0xFFFFFFFFul / dw2;
      // Shift dw1, keeping track of how many times, until it won't
      //  overflow when multiplied by dw2.
      while(dw1 > dwLimit)
      {
        dw1 >>= 1;
        iShift++;
      }
    }
    else
    {
      // Determine largest number by with dw1 can be multiplied without
      //  overflowing a DWORD.
      dwLimit = 0xFFFFFFFFul / dw1;
      // Shift dw2, keeping track of how many times, until it won't
      //  overflow when multiplied by dw1.
      while(dw2 > dwLimit)
      {
        dw2 >>= 1;
        iShift++;
      }
    }
    // Calculate (scaled) product
    *pdwResult = dw1 * dw2;
  }
  // Return the number of shifts we had to use
  return(iShift);
}

/**********************************************************
*
* ChipCalcMCLK()
*
* Determines currently set memory clock (MCLK) based on
*  register values provided.
*
* Returns: Success and current MCLK in Hz.
*
***********************************************************
* Author: Rick Tillery
* Date:   03/21/97
*
* Revision History:
* -----------------
* WHO WHEN     WHAT/WHY/HOW
* --- ----     ------------
*********************************************************/
BOOL ChipCalcMCLK(LPBWREGS pBWRegs,
                  LPDWORD  pdwMCLK)
{
  BOOL  fSuccess = FALSE;
  // We make the assumption that if the BCLK_Denom /4 is set, the reference
  //  xtal is 27MHz.  If it is not set, we assume the ref xtal is 14.31818MHz.
  //  This means that 1/2 the 27MHz (13.5MHz) should not be used.
  DWORD dwRefXtal = (pBWRegs->BCLK_Denom & 0x02) ? (TVO_XTAL / 4) : REF_XTAL;

  ODS("ChipCalcMCLK() called.\n");

  *pdwMCLK = (dwRefXtal * (DWORD)pBWRegs->BCLK_Mult) >> 2;

  ODS("ChipCalcMCLK(): MCLK = %ld\n", *pdwMCLK);

  if(0 == *pdwMCLK)
  {
    ODS("ChipCalcMCLK(): Calculated invalid MCLK (0).\n");
    goto Error;
  }

  fSuccess = TRUE;
Error:
  return(fSuccess);
}


/**********************************************************
*
* ChipCalcVCLK()
*
* Determines currently set pixel clock (VCLK) based on
*  register values provided.
*
* Returns: Success and current VCLK in Hz.
*
***********************************************************
* Author: Rick Tillery
* Date:   11/18/95
*
* Revision History:
* -----------------
* WHO WHEN     WHAT/WHY/HOW
* --- ----     ------------
*********************************************************/
BOOL ChipCalcVCLK(LPBWREGS pBWRegs,
                  LPDWORD  pdwVCLK)
{
  BOOL fSuccess = FALSE;
  BYTE bNum, bDenom;
  int  iShift;
  // We make the assumption that if the BCLK_Denom /4 is set, the reference
  //  xtal is 27MHz.  If it is not set, we assume the ref xtal is 14.31818MHz.
  //  This means that 1/2 the 27MHz (13.5MHz) should not be used.
  //  Add 20000000ul to increas Bandwidth.
  DWORD dwRefXtal = (pBWRegs->BCLK_Denom & 0x02) ? (TVO_XTAL + 2000000ul)  : REF_XTAL;

  ODS("ChipCalcVCLK() called dwRef= %ld\n",dwRefXtal);

  if(pBWRegs->VCLK3Num & 0x80)
  {
    fSuccess = ChipCalcMCLK(pBWRegs, pdwVCLK);
    goto Error;
  }

  /*
   * VCLK is normally based on one of 4 sets of numerator and
   *  denominator pairs.  However, the CL-GD5465 can only access
   *  VCLK 3 through the MMI/O.
   */
  if((pBWRegs->MISCOutput & 0x0C) != 0x0C)
  {
    ODS("ChipCalcVCLK(): VCLK %d in use.  MMI/O can only access VCLK 3.\n",
        (int)((pBWRegs->MISCOutput & 0x0C) >> 2));
//    goto Error;
  }

  bNum = pBWRegs->VCLK3Num & 0x7F;
  bDenom = (pBWRegs->VCLK3Denom & 0xFE) >> 1;

  if(pBWRegs->VCLK3Denom & 0x01)
  {
    // Apply post scalar
    bDenom <<= 1;
  }

  if(0 == bDenom)
  {
    ODS("ChipCalcVCLK(): Invalid VCLK denominator (0).\n");
    goto Error;
  }

  // Calculate actual VCLK frequency (Hz)
  iShift = ScaleMultiply(dwRefXtal, (DWORD)bNum, pdwVCLK);
  *pdwVCLK /= (DWORD)bDenom;
  *pdwVCLK >>= iShift;


  //Check PLL output Frequency  
  iShift = ( pBWRegs->GfVdFormat >> 14 );
  *pdwVCLK >>= iShift;

  ODS("ChipCalcVCLK(): VCLK = %ld\n", *pdwVCLK);

  if(0 == *pdwVCLK)
  {
    ODS("ChipCalcVCLK(): Calculated invalid VCLK (0).\n");
    goto Error;
  }

  fSuccess = TRUE;
Error:
  return(fSuccess);
}


/**********************************************************
*
* ChipIsEnoughBandwidth()
*
* Determines whether their is enough bandwidth for the video
*  configuration specified in the VIDCONFIG structure with
*  the system configuration specified in the BWREGS structure
*  and returns the values that need to be programmed into the
*  bandwidth related registers.  The pProgRegs parameter
*  may be NULL to allow checking a configuration only.  This
*  function gets the register values and passes them to
*  ChipCheckBW() to check the bandwidth.
*  
*
* Returns: BOOLean indicating whether there is sufficient
*           bandwidth for the configuration specified.
*          Values to program into bandwidth related registers
*           if the pProgRegs parameter is not NULL.
*
***********************************************************
* Author: Rick Tillery
* Date:   03/20/97
*
* Revision History:
* -----------------
* WHO WHEN     WHAT/WHY/HOW
* --- ----     ------------
*********************************************************/
BOOL ChipIsEnoughBandwidth(LPPROGREGS  pProgRegs,
                           LPVIDCONFIG pConfig,
                           LPBWREGS    pBWRegs )
{
  BOOL   fSuccess = FALSE;
  DWORD  dwMCLK, dwVCLK;
  DWORD dwDenom;
  int iNumShift, iDenomShift;
  DWORD dwGfxFetch, dwBLTFetch;
  DWORD dwGfxFill, dwBLTFill;
  DWORD dwMaxGfxThresh, dwMinGfxThresh;
  DWORD dwMaxVidThresh, dwMinVidThresh;
  DWORD dwHitLatency, dwRandom;
  BOOL  f500MHZ,fConCurrent;  
  DWORD dwTemp;
  BOOL  f585MHZ = TRUE;  			//PDR#11521

// There are some modes that have the same bandwidth parameters
//  like MCLK, VCLK, but have different dwScreenWidht. The bandwidth
//  related register settings have major differences for these mode.
//  For this reason, dwScreenWidth need to be passed for this function. 
   DWORD dwScreenWidth;
 
//  ODS("ChipIsEnoughBandwidth() called.\n");

  if(!ChipCalcMCLK(pBWRegs, &dwMCLK))
  {
    ODS("ChipIsEnoughBandwidth(): Unable to calculate MCLK.\n");
    goto Error;
  }

  if(!ChipCalcVCLK(pBWRegs, &dwVCLK))
  {
    ODS("ChipIsEnoughBandwidth(): Unable to calculate VCLK.\n");
    goto Error;
  }

  if( dwMCLK > 70000000 )
        f500MHZ = FALSE;
   else
        f500MHZ = TRUE;

  if ((dwMCLK > 70000000) && ( dwMCLK < 72000000))	  //PDR#11521
	  f585MHZ = TRUE;
	else
	  f585MHZ = FALSE;


  dwScreenWidth = (pBWRegs->CR1 + 1 ) << 3;
  if( pBWRegs->CR1E & 0x40 )
    dwScreenWidth += 0x1000;
  
  ODS("ChipIsEnoughBandwidth(): dwScreenWidth = %ld\n",dwScreenWidth);

  dwBLTFetch = (pBWRegs->Control2 & 0x0010) ? 256ul : 128ul;

  dwGfxFetch = (pBWRegs->DispThrsTiming & 0x0040) ? 256ul : 128ul;

ODS("GraphicDepth%ld,VideoDepth=%ld",pConfig->uGfxDepth,pConfig->uSrcDepth);

  if(pBWRegs->RIFControl & 0xC000)
  {
    ODS("ChipIsEnoughBandwidth(): Concurrent RDRAM detected!\n");
    dwHitLatency = CONC_HIT_LATENCY;
    dwRandom = CONC_RANDOM;
    fConCurrent = TRUE;
  }
  else
  {
    ODS("ChipIsEnoughBandwidth(): Normal RDRAM detected.\n");
    dwHitLatency = NORM_HIT_LATENCY;
    dwRandom = NORM_RANDOM;
    fConCurrent = FALSE;
  }
  
  // Determine the number of MCLKs to transfer to the graphics FIFO.
  dwGfxFill = (dwGfxFetch * 8ul) / FIFOWIDTH;
  // And BLTer FIFO.
  dwBLTFill = (dwBLTFetch * 8ul) / FIFOWIDTH;

  //
  // Determine maximum graphics threshold
  //

  dwMaxGfxThresh = dwHitLatency + dwGfxFill + (GFXFIFOSIZE / 2ul) -10ul;

  //    ( K * VCLK * GfxDepth )   GFXFIFOSIZE
  // INT( ------------------- ) + ----------- - 1
  //    ( FIFOWIDTH * MCLK    )        2
  iNumShift = ScaleMultiply(dwMaxGfxThresh, dwVCLK, &dwMaxGfxThresh);
  iNumShift += ScaleMultiply(dwMaxGfxThresh, (DWORD)pConfig->uGfxDepth,
                             &dwMaxGfxThresh);

  iDenomShift = ScaleMultiply(FIFOWIDTH, dwMCLK, &dwDenom);

  if(iNumShift > iDenomShift)
  {
    dwDenom >>= (iNumShift - iDenomShift);
  }
  else
  {
    dwMaxGfxThresh >>= (iDenomShift - iNumShift);
  }

  dwMaxGfxThresh /= dwDenom;

  dwMaxGfxThresh += (GFXFIFOSIZE / 2ul) - 1ul;
  
  if(dwMaxGfxThresh > GFXFIFOSIZE -1 )
        dwMaxGfxThresh = GFXFIFOSIZE -1;
  ODS("ChipIsEnoughBandwidth(): Max graphics thresh = %ld.\n", dwMaxGfxThresh);

  /*
   * Determine minimum graphics threshold
   */
  if(pConfig->dwFlags & VCFLG_DISP)
  {
    // Video enabled

    DWORD dwMinGfxThresh1, dwMinGfxThresh2;

    if(pConfig->dwFlags & VCFLG_420)
    {
      // 4:2:0

      dwMinGfxThresh1 = DISP_LATENCY + dwRandom + dwBLTFill
                        + dwRandom - RIF_SAVINGS + dwBLTFill
                        + dwRandom - RIF_SAVINGS + VID420FILL
                        + dwRandom - RIF_SAVINGS + VID420FILL
                        + dwRandom - RIF_SAVINGS + 1ul;

      dwMinGfxThresh2 = DISP_LATENCY + dwRandom + dwBLTFill
                        + dwRandom - RIF_SAVINGS + dwBLTFill
                        + dwRandom - RIF_SAVINGS + VID420FILL
                        + dwRandom - RIF_SAVINGS + VID420FILL
                        + dwRandom - RIF_SAVINGS + dwGfxFill
                        + dwRandom - RIF_SAVINGS + dwBLTFill
                        + dwRandom - RIF_SAVINGS + VID420FILL
                        + dwRandom - RIF_SAVINGS + VID420FILL
                        + dwRandom - RIF_SAVINGS + 1ul;

    }
    else
    {
      // 4:2:2, 5:5:5, 5:6:5, or X:8:8:8

      dwMinGfxThresh1 = DISP_LATENCY + dwRandom + dwBLTFill
                        + dwRandom - RIF_SAVINGS + dwBLTFill
                        + dwRandom - RIF_SAVINGS + VIDFILL
                        + dwRandom - RIF_SAVINGS + 1ul;

      dwMinGfxThresh2 = DISP_LATENCY + dwRandom + dwBLTFill
                        + dwRandom - RIF_SAVINGS + dwBLTFill
                        + dwRandom - RIF_SAVINGS + VIDFILL
                        + dwRandom - RIF_SAVINGS + dwGfxFill
                        + dwRandom - RIF_SAVINGS + dwBLTFill
                        + dwRandom - RIF_SAVINGS + VIDFILL
                        + dwRandom - RIF_SAVINGS + 1ul;
    }

    //
    // Finish dwMinGfxThresh1
    //
    //    ( K * VCLK * GfxDepth   FIFOWIDTH * MCLK) - 1 )
    // INT( ------------------- + --------------------- ) + 1
    //    (  FIFOWIDTH * MCLK       FIFOWIDTH * MCLK    )
    //
    iNumShift = ScaleMultiply(dwMinGfxThresh1, dwVCLK, &dwMinGfxThresh1);
    iNumShift += ScaleMultiply(dwMinGfxThresh1, (DWORD)pConfig->uGfxDepth,
                               &dwMinGfxThresh1);

    iDenomShift = ScaleMultiply(FIFOWIDTH, dwMCLK, &dwDenom);

    if(iNumShift > iDenomShift)
    {
      dwDenom >>= (iNumShift - iDenomShift);
    }
    else
    {
      dwMinGfxThresh1 >>= (iDenomShift - iNumShift);
    }

    // Be sure rounding below doesn't overflow.
    while((dwMinGfxThresh1 + dwDenom - 1ul) < dwMinGfxThresh1)
    {
      dwMinGfxThresh1 >>= 1;
      dwDenom >>= 1;
    }
    // Round up
    dwMinGfxThresh1 += dwDenom - 1ul;

    dwMinGfxThresh1 /= dwDenom;

    dwMinGfxThresh1++;  // Compensate for decrement by 2

    //
    // Finish dwMinGfxThresh2
    //
    //    ( K * VCLK * GfxDepth   (FIFOWIDTH * MCLK) - 1 )   GfxFetch * 8
    // INT( ------------------- + ---------------------- ) - ------------ + 1
    //    (  FIFOWIDTH * MCLK        FIFOWIDTH * MCLK    )    FIFOWIDTH
    //
    iNumShift = ScaleMultiply(dwMinGfxThresh2, dwVCLK, &dwMinGfxThresh2);
    iNumShift += ScaleMultiply(dwMinGfxThresh2, (DWORD)pConfig->uGfxDepth,
                               &dwMinGfxThresh2);

    iDenomShift = ScaleMultiply(FIFOWIDTH, dwMCLK, &dwDenom);

    if(iNumShift > iDenomShift)
    {
      dwDenom >>= (iNumShift - iDenomShift);
    }
    else
    {
      dwMinGfxThresh2 >>= (iDenomShift - iNumShift);
    }

    // Be sure rounding below doesn't overflow.
    while((dwMinGfxThresh2 + dwDenom - 1ul) < dwMinGfxThresh2)
    {
      dwMinGfxThresh2 >>= 1;
      dwDenom >>= 1;
    }
    // Round up
    dwMinGfxThresh2 += dwDenom - 1ul;

    dwMinGfxThresh2 /= dwDenom;

    // Adjust for second transfer
    dwMinGfxThresh2 -= ((dwGfxFetch * 8ul) / FIFOWIDTH);

    // Adjust for decrement by 2
    dwMinGfxThresh2++;

    if( fConCurrent)
    {
        if( f500MHZ)
        {
            if( (pConfig->uGfxDepth == 32) && ( dwVCLK >= 64982518ul ))
            {
                 dwTemp = ( dwVCLK - 64982518ul) /1083333ul  + 1ul;
                 dwMinGfxThresh2 -= dwTemp;
                 dwMinGfxThresh1 -= 10;
            }
            else if( (pConfig->uGfxDepth == 24) && (dwVCLK > 94500000ul))
                dwMinGfxThresh2 -=5;        //Adjust again for 24 bit #xc
        }
        else        //600MHZ
        {
            if( (pConfig->uGfxDepth == 16) && ( dwVCLK > 156000000ul))
                dwMinGfxThresh2 -= 4;
            else if( (pConfig->uGfxDepth == 24) && ( dwVCLK > 104000000ul))
            {
                dwMinGfxThresh2 -= (5ul+ 8ul * (dwVCLK - 104000000ul) / 17000000ul);
            }
            else if( (pConfig->uGfxDepth == 32) )
            {  
                if( dwVCLK > 94000000ul)
                    dwMinGfxThresh2 -= 16;
               if( dwVCLK > 70000000ul)
                    dwMinGfxThresh2 -= 4;
					 else
						  dwMinGfxThresh2 +=6; //#PDR#11506 10x7x32bit could not
													  //support YUV420.
            }

        }

        if( (pConfig->uGfxDepth == 8) && (dwVCLK > 18000000ul))
                dwMinGfxThresh2 += 6;
    } 
    else    //Normal RDRam
    {   
        if( f500MHZ )
        {
            if( (pConfig->uGfxDepth == 32) && ( dwVCLK > 49500000ul ))
            {
                dwMinGfxThresh1 -= 4;
                dwMinGfxThresh2 -= (( dwVCLK - 49715909ul) / 726981ul + 3ul);
            }
            else if( (pConfig->uGfxDepth == 24) && ( dwVCLK > 60000000ul ) 
                &&  (dwVCLK < 95000000ul))
            {
                dwTemp= ((dwVCLK - 64982518ul) / 1135287ul + 3ul);

                dwMinGfxThresh2 -=dwTemp;
                dwMinGfxThresh1 -= 10;
             }

        }
        else        //600MHZ case
        {
            if( (pConfig->uGfxDepth == 32) && ( dwVCLK > 49700000ul ))
            {
                dwTemp= ((dwVCLK - 49700000ul) / 1252185ul + 5ul);
                dwMinGfxThresh2 -= dwTemp;
                dwMinGfxThresh1 -= 4ul;
            }
            else  if( (pConfig->uGfxDepth == 24) && ( dwVCLK > 60000000ul ))
            {  
                dwTemp= ((dwVCLK - 64982518ul) / 2270575ul + 4ul);

               dwMinGfxThresh2 -=dwTemp;
               dwMinGfxThresh1 -= 8;

            }
            else  if( pConfig->uGfxDepth == 16) 
            {
                  dwMinGfxThresh2 -= 4;
            }
            else  if( pConfig->uGfxDepth == 8)
            {
               if(dwVCLK >170000000)
                  dwMinGfxThresh1 += 10;
               else
                  dwMinGfxThresh1 += 4;
                  
            }
        }
    }

    ODS("ChipIsEnoughBandwidth(): Min graphics thresh1 2 = %ld,%ld.\n",
          dwMinGfxThresh1, dwMinGfxThresh2);
    // Adjust for unsigned overflow
    if(dwMinGfxThresh2 > GFXFIFOSIZE + 20ul)
    {
      dwMinGfxThresh2 = 0ul;
    }

    //
    // Whichever is higher should be the right one
    //
    dwMinGfxThresh = __max(dwMinGfxThresh1, dwMinGfxThresh2);
  }
  else
  {
    // No video enabled

    dwMinGfxThresh = DISP_LATENCY + dwRandom + dwBLTFill
                     + dwRandom - RIF_SAVINGS + 1ul;

    //    ( K * VCLK * GfxDepth   (FIFOWIDTH * MCLK) - 1 )
    // INT( ------------------- + ---------------------- )
    //    (  FIFOWIDTH * MCLK        FIFOWIDTH * MCLK    )
    iNumShift = ScaleMultiply(dwMinGfxThresh, dwVCLK, &dwMinGfxThresh);
    iNumShift += ScaleMultiply(dwMinGfxThresh, (DWORD)pConfig->uGfxDepth,
                               &dwMinGfxThresh);

    iDenomShift = ScaleMultiply(FIFOWIDTH, dwMCLK, &dwDenom);

    if(iNumShift > iDenomShift)
    {
      dwDenom >>= (iNumShift - iDenomShift);
    }
    else
    {
      dwMinGfxThresh >>= (iDenomShift - iNumShift);
    }

    // Be sure rounding below doesn't overflow.
    while((dwMinGfxThresh + dwDenom - 1ul) < dwMinGfxThresh)
    {
      dwMinGfxThresh >>= 1;
      dwDenom >>= 1;
    }
    // Round up
    dwMinGfxThresh += dwDenom - 1ul;

    dwMinGfxThresh /= dwDenom;

    dwMinGfxThresh++; // Compensate for decrement by 2
  }

  ODS("ChipIsEnoughBandwidth(): Min graphics thresh = %ld.\n", dwMinGfxThresh);

  if(dwMaxGfxThresh < dwMinGfxThresh)
  {
    ODS("ChipIsEnoughBandwidth(): Minimum graphics threshold exceeds maximum.\n");
    goto Error;
  }
 
  if(pProgRegs)
  {
    pProgRegs->DispThrsTiming = (WORD)dwMinGfxThresh;
  }
ODS("xfer=%x,cap=%x,src=%x,dsp=%x\n",pConfig->sizXfer.cx,pConfig->sizCap.cx,
    pConfig->sizSrc.cx,pConfig->sizDisp.cx);
  // Start-of-line check is only for capture
  if(pConfig->dwFlags & VCFLG_CAP)
  {
    DWORD dwNonCapMCLKs, dwCapMCLKs;

    // Do start-of-line check to be sure capture FIFO does not overflow.

    // First determine the number of MCLK cycles at the start of the line.
    //  We'll compare this to the number of levels of the capture FIFO
    //  filled during the same time to make sure the capture FIFO doesn't
    //  overflow.

    // Start of line:  BLT + HC + V + G + V + G
    dwNonCapMCLKs = dwRandom + dwBLTFill;
    // Hardware cursor is only necessary if it is on, however, since it can
    //  be enabled or disabled, and VPM has no way of knowing when this
    //  occurs, we must always assume it is on.
    dwNonCapMCLKs += dwRandom - RIF_SAVINGS + CURSORFILL;

    if(pConfig->dwFlags & VCFLG_DISP)
    {
      // Only one video fill is required, however if the video FIFO threshold
      //  is greater than 1/2, the second fill will be done.  Also, because of
      //  the tiled architecture, even though the video might not be aligned,
      //  the transfer will occur on a tile boundary.  If the transfer of a
      //  single tile cannot fulfill the FIFO request, the second fill will be
      //  done.  Since the pitch will vary, and the client can move the source
      //  around, we must always assume that the second video FIFO fill will
      //  be done.
      if(pConfig->dwFlags & VCFLG_420)
      {
        dwNonCapMCLKs += 4ul * (dwRandom - RIF_SAVINGS + VID420FILL);
      }
      else
      {
        dwNonCapMCLKs += 2ul * (dwRandom - RIF_SAVINGS + VIDFILL);
      }
    }
    // The graphics FIFO fill depends on the fetch size.  We also assume that
    //  the pitch is a multiple of the fetch width.
    dwNonCapMCLKs += dwRandom - RIF_SAVINGS + dwGfxFill;
    // The second graphics FIFO fill will be done if:
    //  1. The graphics is not aligned on a fetch boundary (panning).
    //  2. The FIFO threshold is over 1/2 the FIFO (the fill size).
    if((dwMinGfxThresh >= dwGfxFill) || (pConfig->dwFlags & VCFLG_PAN))
    {
      dwNonCapMCLKs += dwRandom - RIF_SAVINGS + dwGfxFill;
    }

    dwNonCapMCLKs += 3; // Magic number that seems to work for now.

    ODS("ChipIsEnoughBandwidth(): dwNonCapMCLKs = %ld\n", dwNonCapMCLKs);

    // sizXfer.cx * FIFOWIDTH * (CAPFIFOSIZE / 2) * dwMCLK
    // ---------------------------------------------------
    //         dwXferRate * uCapDepth * sizCap.cx

    iNumShift = ScaleMultiply((DWORD)pConfig->sizXfer.cx, FIFOWIDTH,
                              &dwCapMCLKs);
    iNumShift += ScaleMultiply(dwCapMCLKs, (CAPFIFOSIZE / 2), &dwCapMCLKs);
    iNumShift += ScaleMultiply(dwCapMCLKs, dwMCLK, &dwCapMCLKs);

    iDenomShift = ScaleMultiply(pConfig->dwXferRate, (DWORD)pConfig->uCapDepth,
                                &dwDenom);
    iDenomShift += ScaleMultiply(dwDenom, (DWORD)pConfig->sizCap.cx, &dwDenom);

    if(iNumShift > iDenomShift)
    {
      dwDenom >>= (iNumShift - iDenomShift);
    }
    else
    {
      dwCapMCLKs >>= (iDenomShift - iNumShift);
    }

    dwCapMCLKs /= dwDenom;

    ODS("ChipIsEnoughBandwidth(): dwCapMCLKs = %ld\n", dwCapMCLKs);
    if(fConCurrent)
    {
        if( pConfig->uGfxDepth == 32) 
            dwCapMCLKs -= 44;     //adjust 32 bit 
    }

    if(dwNonCapMCLKs > dwCapMCLKs)
    {
      ODS("ChipIsEnoughBandwidth(): Capture overflow at start of line.\n");
      goto Error;
    }
  }

  if(pConfig->dwFlags & VCFLG_DISP)
  {
    /*
     * Determine maximum video threshold
     */
    dwMaxVidThresh = dwHitLatency;
    if(pConfig->dwFlags & VCFLG_420)
    {
      dwMaxVidThresh += VID420FILL;
      if( !f500MHZ && fConCurrent )
         dwMaxVidThresh += 5;
    }
    else
    {
      dwMaxVidThresh += VIDFILL;
    }

    //    ( K * VCLK * VidDepth * SrcWidth )
    // INT( ------------------------------ ) + VidFill (/ 2) - 1
    //    ( FIFOWIDTH * MCLK * DispWidth   )             ^non-4:2:0 only
    iNumShift = ScaleMultiply(dwMaxVidThresh, dwVCLK, &dwMaxVidThresh);
    iNumShift += ScaleMultiply(dwMaxVidThresh, (DWORD)pConfig->uSrcDepth,
                                &dwMaxVidThresh);
    iNumShift += ScaleMultiply(dwMaxVidThresh, (DWORD)pConfig->sizSrc.cx,
                                &dwMaxVidThresh);

    iDenomShift = ScaleMultiply(FIFOWIDTH, (DWORD)pConfig->sizDisp.cx, &dwDenom);
    iDenomShift += ScaleMultiply(dwDenom, dwMCLK, &dwDenom);

    if(iNumShift > iDenomShift)
    {
      dwDenom >>= (iNumShift - iDenomShift);
    }
    else
    {
      dwMaxVidThresh >>= (iDenomShift - iNumShift);
    }

    dwMaxVidThresh /= dwDenom;

    if(pConfig->dwFlags & VCFLG_420)
    {
      dwMaxVidThresh += VID420FILL;
    }
    else
    {
      dwMaxVidThresh += VIDFILL;
      // Threshold is programmed in DQWORDS for non-4:2:0
      dwMaxVidThresh /= 2ul;
    }
    dwMaxVidThresh--;

    ODS("ChipIsEnoughBandwidth(): Max video thresh = %ld.\n", dwMaxVidThresh);

     if( fConCurrent && f500MHZ && ( dwVCLK < 66000000ul))
         dwMaxVidThresh = __min(dwMaxVidThresh, 8); 
    /*
     * Determine minimum video threshold
     */
    {
      DWORD dwMinVidThresh1, dwMinVidThresh2;

      if(pConfig->dwFlags & VCFLG_420)
      {
        // 4:2:0

        dwMinVidThresh1 = DISP_LATENCY + dwRandom + dwGfxFill
                          + dwRandom - RIF_SAVINGS + VID420FILL
                          + dwRandom - RIF_SAVINGS + 1;

        dwMinVidThresh2 = DISP_LATENCY + dwRandom + dwGfxFill
                          + dwRandom - RIF_SAVINGS + VID420FILL
                          + dwRandom - RIF_SAVINGS + VID420FILL
                          + dwRandom - RIF_SAVINGS + VID420FILL
                          + dwRandom - RIF_SAVINGS + 1;
      }
      else
      {
        // 4:2:2, 5:5:5, 5:6:5, or X:8:8:8

        dwMinVidThresh1 = DISP_LATENCY + dwRandom + dwGfxFill
                          + dwRandom - RIF_SAVINGS + 2;

        dwMinVidThresh2 = DISP_LATENCY + dwRandom + dwGfxFill
                          + dwRandom - RIF_SAVINGS + VIDFILL
                          + 15ul        //#xc
  //                        + 10ul
                          + dwRandom - RIF_SAVINGS + dwGfxFill
                          + dwRandom - RIF_SAVINGS + 2ul;
        if(fConCurrent)
        {
           if(f500MHZ )
           { 
               if( (pConfig->uGfxDepth == 32) && ( dwVCLK > 60000000ul ))
               {
                    if( dwVCLK > 94000000ul)
                        dwMinVidThresh1 += 105;
                    else if( dwVCLK > 74000000ul)
                        dwMinVidThresh1 += 90;
                     else
                        dwMinVidThresh1 += 65;
                    if(pConfig->dwFlags & VCFLG_CAP) 
                    {
                        if(dwVCLK > 78000000ul)
                            dwMinVidThresh1 += 260; //disable video
                        else if( dwVCLK > 74000000ul)
                            dwMinVidThresh1 += 70;
                    }                
               }  
               else if( pConfig->uGfxDepth == 24)
               {
                      if( dwVCLK > 94500000ul)
                      {
                        if(dwScreenWidth == 1024)
                           dwMinVidThresh2 += 50ul;
                        else
                           dwMinVidThresh2 += 90ul; 
                      }
                      else if( dwVCLK < 41000000ul)
                      {
                        dwMinVidThresh2 += 4;
                      }    
                      else  if(dwVCLK < 80000000ul)
                      {
                         if( (dwVCLK > 74000000ul) && (dwVCLK < 76000000ul))
                         {
                              dwMinVidThresh2 -= 1;
                         }
                         else
                            dwMinVidThresh2 -= 8;
                         dwMinVidThresh1 -= 4;
    
                      }   
                    
                    if(pConfig->dwFlags & VCFLG_CAP) 
                      if( dwVCLK > 94000000ul)
                      { 
                            if((dwVCLK < 95000000ul) && ( dwGfxFetch == 256 ))
                                dwMinVidThresh2 += 60; 
                            else
                                dwMinVidThresh2 += 120; 
                      }                 
                }
               else if( (pConfig->uGfxDepth == 16) && ( dwVCLK > 60000000ul ))
               {                    
                   if( dwVCLK < 94000000ul)
                   {  
                        dwMinVidThresh2 -= 10;
                        dwMinVidThresh1 -= 6;
                   }
                   else if( dwVCLK > 105000000ul)
                        dwMinVidThresh2 += 50;
                } 
               else if( (pConfig->uGfxDepth == 8) && ( dwVCLK > 60000000ul ))
               {
                  if( dwVCLK > 216000000ul)
                  {
                    dwMinVidThresh2 += 50;
                    dwMinVidThresh1 += 20;
                   }   
                  else if( (dwVCLK < 95000000ul) && ( dwScreenWidth <= 1024))
                  {  
                    dwMinVidThresh2 -= 12;
                    dwMinVidThresh1 -= 10;
                    dwMaxVidThresh = __min(dwMaxVidThresh, 9); 
                  }
                  else if(dwVCLK < 109000000ul)
                  {
                    dwMinVidThresh2 += ( 14 -  4 * ( dwVCLK - 94000000ul ) / 14000000ul );
                    dwMinVidThresh1 += 10;
                    dwMaxVidThresh = __min(dwMaxVidThresh, 8); 
                  }  
                  else
                  {
                     dwMinVidThresh2 += 7;
                     dwMinVidThresh1 += 4;
                  }
               }
            }
#if 1//PDR#11521
	        else if (f585MHZ)       //585MHZ
   	     {
                if( (pConfig->uGfxDepth == 8) && ( dwVCLK > 56000000ul))
                {
                    if( dwVCLK > 200000000ul)
                    {
                        dwMaxVidThresh++;
                        dwMinVidThresh1 += 7;
                        dwMinVidThresh2 += 14;    

                    }
                    else if( dwVCLK  < 60000000ul)
                    {
                     dwMinVidThresh2 += 8;
                    }
                    else if( dwVCLK < 160000000ul)
                    {
                        dwMinVidThresh1 -=20;
                        dwMinVidThresh2 -=10;    
                    }
 
                    if(pConfig->dwFlags & VCFLG_CAP)
                    {
                        if( dwVCLK < 76000000ul)
                           dwMinVidThresh2 +=8; 
                        else if( dwVCLK < 140000000ul)    
                           dwMinVidThresh2 +=25;     
                        else                        
                           dwMinVidThresh2 +=32;     
                    }
                }
                else  if( (pConfig->uGfxDepth == 16) && ( dwVCLK > 60000000ul))
                {
                        if( dwVCLK > 157000000ul)
                        {
                            dwMinVidThresh1 += 27;    
                            dwMaxVidThresh ++;
                        }
                        if( dwVCLK > 125000000ul)
                        {
                          dwMinVidThresh1 += 40;
                        }    
                        else if( dwVCLK > 107000000ul)
                        {
                          dwMinVidThresh1 += 34;
                        }
                        else 
                        if( dwVCLK > 74000000ul)
                        {
                          dwMinVidThresh1 += 18;
                        }

                    if( dwVCLK > 189000000ul)     //PDR11521
                            dwMaxVidThresh ++;   

                       if(pConfig->dwFlags & VCFLG_CAP)
                       {
                            if( dwVCLK > 74000000ul)
                               dwMinVidThresh1 +=2; 
                        }
                }
                else  if( pConfig->uGfxDepth == 24)
                {
                    if( dwVCLK < 60000000ul)
                    {
                        dwMinVidThresh1 -= 8;
                        dwMinVidThresh2 -= 16;
                    }
                    else if( dwVCLK  > 107000000ul )
                          dwMinVidThresh2 += 84;
                    else if( (dwVCLK > 94000000ul) && (dwScreenWidth >= 1152))
                    {
                        dwMinVidThresh2 += 40;
                    }

                    if( dwVCLK > 126000000ul)     //PDR11521
                            dwMaxVidThresh ++;   

                    if(pConfig->dwFlags & VCFLG_CAP)
                    {
                         if( dwVCLK > 74000000ul)
                            dwMinVidThresh2 +=12; 
                    }

                }
                else  if(( pConfig->uGfxDepth == 32) && ( dwVCLK > 60000000ul))
                {
                    if( dwVCLK > 74000000ul)
                    {
                        if( (dwVCLK > 77000000ul) && ( dwVCLK < 80000000ul))
                            dwMinVidThresh2 += 120;
                        else
                            dwMinVidThresh2 += 83;       
                    }
                    else                
                        dwMinVidThresh2 += 30;

                    if( dwVCLK > 94000000ul)     //PDR11521
                            dwMaxVidThresh ++;   
    
                    if(pConfig->dwFlags & VCFLG_CAP)
                    {
                          if( dwVCLK > 94000000ul)
                            dwMinVidThresh2 +=2; 
                    }
                }
                else  if(( pConfig->uGfxDepth == 32) && ( dwVCLK > 49000000ul))
                {
                    
                    if(pConfig->dwFlags & VCFLG_CAP)
                            dwMinVidThresh2 +=2; 
                }

      	  }
#endif
            else        //600MZH concurrent
            {
                if( (pConfig->uGfxDepth == 8) && ( dwVCLK > 56000000ul))
                {
                    if( dwVCLK > 200000000ul)
                    {
//PDR#11541                        dwMaxVidThresh++;
                        dwMinVidThresh1 += 7;
                        dwMinVidThresh2 += 14;    

                    }
                    else if( dwVCLK  < 60000000ul)
                    {
                     dwMinVidThresh2 += 8;
                    }
                    else if( dwVCLK < 160000000ul)
                    {
                        dwMinVidThresh1 -=20;
                        dwMinVidThresh2 -=10;    
                    }
 
                    if(pConfig->dwFlags & VCFLG_CAP)
                    {
                        if( dwVCLK < 76000000ul)
                           dwMinVidThresh2 +=8; 
                        else if( dwVCLK < 140000000ul)    
                           dwMinVidThresh2 +=25;     
                        else                        
                           dwMinVidThresh2 +=32;     
                    }
                }
                else  if( (pConfig->uGfxDepth == 16) && ( dwVCLK > 60000000ul))
                {
                        if( dwVCLK > 157000000ul)
                        {
                            dwMinVidThresh1 += 27;    
//PDR#11541                            dwMaxVidThresh ++;
                        }
                        if( dwVCLK > 125000000ul)
                        {
                          dwMinVidThresh1 += 40;
                        }    
                        else if( dwVCLK > 107000000ul)
                        {
                          dwMinVidThresh1 += 34;
                        }
                        else 
                        if( dwVCLK > 74000000ul)
                        {
                          dwMinVidThresh1 += 18;
                        }


                       if(pConfig->dwFlags & VCFLG_CAP)
                       {
                            if( dwVCLK > 74000000ul)
                               dwMinVidThresh1 +=2; 
                        }
                }
                else  if( pConfig->uGfxDepth == 24)
                {
                    if( dwVCLK < 60000000ul)
                    {
                        dwMinVidThresh1 -= 8;
                        dwMinVidThresh2 -= 16;
                    }
                    else if( dwVCLK  > 107000000ul )
                          dwMinVidThresh2 += 84;
                    else if( (dwVCLK > 94000000ul) && (dwScreenWidth >= 1152))
                    {
                        dwMinVidThresh2 += 40;
                    }

                    if(pConfig->dwFlags & VCFLG_CAP)
                    {
                         if( dwVCLK > 74000000ul)
                            dwMinVidThresh2 +=12; 
                    }

                }
                else  if(( pConfig->uGfxDepth == 32) && ( dwVCLK > 60000000ul))
                {
                    if( dwVCLK > 74000000ul)
                    {
                        if( (dwVCLK > 77000000ul) && ( dwVCLK < 80000000ul))
                            dwMinVidThresh2 += 120;
                        else
                            dwMinVidThresh2 += 83;       
                    }
                    else                
                        dwMinVidThresh2 += 30;        
    
                    if(pConfig->dwFlags & VCFLG_CAP)
                    {
                          if( dwVCLK > 94000000ul)
                            dwMinVidThresh2 +=2; 
                    }
                }
                else  if(( pConfig->uGfxDepth == 32) && ( dwVCLK > 49000000ul))
                {
                    
                    if(pConfig->dwFlags & VCFLG_CAP)
                            dwMinVidThresh2 +=2; 
                }

            }
        }
        else     //Normal RDRam case
        {  
           if(f500MHZ )
           { 
             if( (pConfig->uGfxDepth == 32) && ( dwVCLK > 60000000ul ))
             {
                 dwMinVidThresh1 += 75;
                 if(pConfig->dwFlags & VCFLG_CAP)
                    dwMinVidThresh1 +=20;
             }
             else if( (pConfig->uGfxDepth == 24) && ( dwVCLK > 7800000ul ))
             {
                 dwMinVidThresh2 += 52;
                 if(pConfig->dwFlags & VCFLG_CAP)
                 {
                     dwMinVidThresh2 += 50;
                  }
             }   
             else if(pConfig->uGfxDepth == 16)
             {
                 if((dwVCLK > 36000000 ) && ( dwVCLK < 57000000))
                 {
                      dwMinVidThresh2 += 22 - ( dwVCLK - 36000000) * 3L /
                                 4000000; 
                 } 
                 else
                 {
                    dwMinVidThresh2 -= 18;
                    dwMinVidThresh1 -= 8;
                 }   
                if(pConfig->dwFlags & VCFLG_CAP)
                {
                     dwMinVidThresh2 += 5;
                }
              }
              else if((pConfig->uGfxDepth == 8) && ( dwVCLK > 36000000ul )) 
              { 
                if(dwVCLK > 160000000ul)
                    dwMinVidThresh2 -= 6;
                else if( (dwVCLK > 94000000 ) && (dwVCLK < 109000000) && (dwScreenWidth == 1152))
                {
                    dwMinVidThresh2 -=  2 + 4 * ( dwVCLK - 94000000 ) / 13500000;
                }
                else if( (dwVCLK < 109000000) && (dwScreenWidth == 1280))
                {
                     dwMinVidThresh2 -= 5;   
                }
                else if( dwVCLK > 60000000ul)
                {
                     dwMinVidThresh2 -= 18;
                     if(pConfig->dwFlags & VCFLG_CAP)
                     {
                         dwMinVidThresh2 += 5;
                     }
                }
                else 
                    dwMinVidThresh2 += 6;
                dwMinVidThresh1 -= 8;
             } 

           }
           else     //600 MHZ
           { 
                if(pConfig->uGfxDepth == 32)
                { 
                   if( dwVCLK > 60000000ul )
                   {
                        dwTemp = ( dwVCLK - 60000000ul ) /300000ul + 38ul;
                        dwMinVidThresh1 +=  dwTemp;
                   }
                   if((pConfig->dwFlags & VCFLG_CAP) && (dwVCLK > 40000000ul))
                   {
                        if(dwVCLK > 94000000ul)
                            dwTemp = 120;           //disable capture;
                        else
                            dwTemp = ( dwVCLK - 40006685ul) /1085905ul + 5;
                        dwMinVidThresh1 +=dwTemp;
                    }
                }
                else if( pConfig->uGfxDepth == 24) 
                {
                   if( dwVCLK < 50000000ul)
                       dwMinVidThresh2 -= 5;
                   else      
                       dwMinVidThresh2 -= 18;
                   dwMinVidThresh1 -= 8;
                   if((pConfig->dwFlags & VCFLG_CAP) && (dwVCLK > 94000000ul))
                       dwMinVidThresh2 += 8;

                }
                else  if(pConfig->uGfxDepth == 16)
                {
                   if( (dwVCLK < 100000000ul ) && (dwVCLK > 66000000ul))
                   { 
                        dwTemp =   31ul -  (dwVCLK -60000000ul) / 1968750ul;
                    }
                    else  if( dwVCLK <= 66000000ul)  //after 1024X768 only adjust constantly
                    {  
                       if( dwVCLK < 57000000ul) 
                       { 
                          dwTemp = 0ul;
                          dwMinVidThresh2 += 10ul;
                        }
                        else
                          dwTemp = 5ul;  
                    }
                    if(dwVCLK > 100000000ul)
                    {
                        dwMinVidThresh2 += 40ul;
                        dwMinVidThresh1 += 20ul;
                    }
                    else
                    {
                        dwMinVidThresh2 -= dwTemp;
                        dwMinVidThresh1 -= 8ul;
                    }
                }
                else if(pConfig->uGfxDepth == 8) 
                {
                    if((dwVCLK > 94000000ul) && ( dwScreenWidth >=1152))
                    {
                       if(dwVCLK > 108000000ul) 
                           dwMinVidThresh2 += 10;
                       else
                           dwMinVidThresh2 += 20;
                       dwMinVidThresh1 += 1;
                    }
                    else if( dwVCLK > 64000000ul )
                    {
                        if( dwVCLK > 70000000ul)
                            dwTemp = 25;  
                        else
                            dwTemp = 5;

                        if(pConfig->dwFlags & VCFLG_CAP)
                        {
                            if(dwVCLK < 760000000ul )
                                dwTemp = 0;
                            else if(dwVCLK < 950000000ul)
                                dwTemp -= 10;
                        }
                        dwMinVidThresh2 -= dwTemp;

                        dwMinVidThresh1 -= 15;
                    }
                }
           }
        }    
      }

      //
      // Finish dwMinVidThresh1
      //
      //    ( K * VidDepth * SrcWidth * VCLK   (FIFOWIDTH * DispWidth * MCLK) - 1 )
      // INT( ------------------------------ + ---------------------------------- ) (/ 2) + 1
      //    ( FIFOWIDTH * DispWidth * MCLK        FIFOWIDTH * DispWidth * MCLK    )
      iNumShift = ScaleMultiply(dwMinVidThresh1, (DWORD)pConfig->uSrcDepth,
                                &dwMinVidThresh1);
      iNumShift += ScaleMultiply(dwMinVidThresh1, (DWORD)pConfig->sizSrc.cx,
                                &dwMinVidThresh1);
      iNumShift += ScaleMultiply(dwMinVidThresh1, dwVCLK, &dwMinVidThresh1);

      iDenomShift = ScaleMultiply(FIFOWIDTH, (DWORD)pConfig->sizDisp.cx,
                                  &dwDenom);
      iDenomShift += ScaleMultiply(dwDenom, dwMCLK, &dwDenom);

      if(iNumShift > iDenomShift)
      {
        dwDenom >>= (iNumShift - iDenomShift);
      }
      else
      {
        dwMinVidThresh1 >>= (iDenomShift - iNumShift);
      }

      // Be sure rounding below doesn't overflow (it happened!)
      while((dwMinVidThresh1 + dwDenom - 1ul) < dwMinVidThresh1)
      {
        dwMinVidThresh1 >>= 1;
        dwDenom >>= 1;
      }
      dwMinVidThresh1 += dwDenom - 1ul;

      dwMinVidThresh1 /= dwDenom;

      if(!(pConfig->dwFlags & VCFLG_420))
      {
        // Threshold is programmed in DQWORDS for non-4:2:0
        dwMinVidThresh1 /= 2ul;
      }

      dwMinVidThresh1++;  // Adjust for -2 decrement of FIFO count done to
                          //  synchronize MCLK with faster VCLK.

      //
      // Finish dwMinVidThresh2
      //
      // K * VidDepth * VidWidth * VCLK   (FIFOWIDTH * DispWidth * MCLK) - 1
      // ------------------------------ + ----------------------------------
      // FIFOWIDTH * DispWidth * MCLK        FIFOWIDTH * DispWidth * MCLK
      //
      //   VIDFIFOSIZE
      // - ----------- (/ 2) + 1
      //        2        ^non-4:2:0 only
      iNumShift = ScaleMultiply(dwMinVidThresh2, (DWORD)pConfig->uSrcDepth,
                                &dwMinVidThresh2);
      iNumShift += ScaleMultiply(dwMinVidThresh2, (DWORD)pConfig->sizSrc.cx,
                                &dwMinVidThresh2);

      iNumShift += ScaleMultiply(dwMinVidThresh2, dwVCLK, &dwMinVidThresh2);

      iDenomShift = ScaleMultiply(FIFOWIDTH, (DWORD)pConfig->sizDisp.cx,
                                  &dwDenom);
      iDenomShift += ScaleMultiply(dwDenom, dwMCLK, &dwDenom);

      if(iNumShift > iDenomShift)
      {
        dwDenom >>= (iNumShift - iDenomShift);
      }
      else
      {
        dwMinVidThresh2 >>= (iDenomShift - iNumShift);
      }

      // Be sure rounding below doesn't overflow (it happened!)
      while((dwMinVidThresh2 + dwDenom - 1ul) < dwMinVidThresh2)
      {
        dwMinVidThresh2 >>= 1;
        dwDenom >>= 1;
      }
      dwMinVidThresh2 += dwDenom - 1ul;

      dwMinVidThresh2 /= dwDenom;

      if(dwMinVidThresh2 > (VIDFIFOSIZE /2ul) )
          dwMinVidThresh2 -= (VIDFIFOSIZE / 2ul);
      else
          dwMinVidThresh2 = 0;
        
      if(!(pConfig->dwFlags & VCFLG_420))
      {
        // Threshold is programmed in DQWORDS for non-4:2:0
        dwMinVidThresh2 /= 2ul;
      }

      dwMinVidThresh2++;  // Adjust for -2 decrement of FIFO count done to
                          //  synchronize MCLK with faster VCLK.


    ODS("ChipIsEnoughBandwidth(): Min video thresh1 and 2 = %ld %ld.\n", 
                dwMinVidThresh1, dwMinVidThresh2);

      if(dwMinVidThresh2 > VIDFIFOSIZE -1)
      {
        dwMinVidThresh2 = VIDFIFOSIZE -1;
      }
      //
      // Whichever is higher should be the right one
      //
      dwMinVidThresh = __max(dwMinVidThresh1, dwMinVidThresh2);
    }

    ODS("ChipIsEnoughBandwidth(): Min video thresh = %ld.\n", dwMinVidThresh);

    if(dwMaxVidThresh < dwMinVidThresh)
    {
      ODS("ChipIsEnoughBandwidth(): Minimum video threshold exceeds maximum.\n");
      goto Error;
    }
    //I don't know why, but it need checked for capture. #xc
    if((pConfig->dwFlags & VCFLG_CAP) && (dwMaxVidThresh > 8) 
        && ((pConfig->uGfxDepth != 8) || fConCurrent) && ( f500MHZ || !fConCurrent))
    {
      ODS("ChipIsEnoughBandwidth(): Video threshold exceeds non-aligned safe value.\n");
      goto Error;
    }
    if(pProgRegs)
    {
      if((((pConfig->uGfxDepth == 8) && (dwVCLK > 60000000)) || 
          ((pConfig->uGfxDepth != 8)  && ( dwVCLK > 56000000)) ||
         ( !f500MHZ && fConCurrent)) && !(pConfig->dwFlags & VCFLG_CAP))
        pProgRegs->VW0_FIFO_THRSH = (WORD)dwMaxVidThresh;
      else 
        pProgRegs->VW0_FIFO_THRSH = (WORD)__min( 8, dwMaxVidThresh);
    ODS("ChipIsEnoughBandwidth(): thresh = %ld.\n", pProgRegs->VW0_FIFO_THRSH);
    }
  }
  fSuccess = TRUE;
Error:
  return(fSuccess);
}

#endif // WINNT_VER35




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\blt_dl.c ===
/**************************************************************************
***************************************************************************
*
*     Copyright (c) 1996, Cirrus Logic, Inc.
*                 All Rights Reserved
*
* FILE:         blt_dl.c
*
* DESCRIPTION:  Display List blts for the 5464
*
* REVISION HISTORY:
*
* $Log:   X:\log\laguna\ddraw\src\blt_dl.c  $
* 
*    Rev 1.20   06 Jan 1998 15:20:04   xcong
* 
*    Rev 1.19   06 Jan 1998 11:56:22   xcong
* Change pDriverData into lpDDHALData for multi-monitor support.
*
*    Rev 1.18   03 Oct 1997 14:31:12   RUSSL
* Initial changes for use of hw clipped blts
* All changes wrapped in #if ENABLE_CLIPPEDBLTS/#endif blocks and
* ENABLE_CLIPPEDBLTS defaults to 0 (so the code is disabled)
*
*    Rev 1.17   15 Sep 1997 17:25:14   RUSSL
* Fix for PDR 10493 - Minor parenthesis change
*
*    Rev 1.16   24 Jul 1997 12:32:40   RUSSL
* Botched the overlap check, changed || to &&
*
*    Rev 1.15   24 Jul 1997 11:20:16   RUSSL
* Added DL_DrvStrBlt_OverlapCheck & DL_DrvStrMBlt_OverlapCheck
* inline functions
*
*    Rev 1.14   17 Jul 1997 14:31:58   RUSSL
* Fixed my copy & paste errors in the DD_LOG and ASSERTs in DL_DrvStrBlt65
*
*    Rev 1.13   15 Jul 1997 16:19:50   eleland
* removed the increment-and-immediate decrement of display list
* pointer at the end of each blt display list
*
*    Rev 1.12   14 Jul 1997 14:59:52   RUSSL
* Added DL_DrvStrBlt65
*
*    Rev 1.11   02 Jul 1997 19:13:10   eleland
* added wait instruction after each dl blit
*
*    Rev 1.10   03 Apr 1997 15:05:30   RUSSL
* Added DL_DrvDstMBlt function
*
*    Rev 1.9   26 Mar 1997 13:55:22   RUSSL
* Added DL_DrvSrcMBlt function
*
*    Rev 1.8   12 Mar 1997 15:01:20   RUSSL
* replaced a block of includes with include of precomp.h for
*   precompiled headers
*
*    Rev 1.7   07 Mar 1997 12:50:40   RUSSL
* Modified DDRAW_COMPAT usage
*
*    Rev 1.6   11 Feb 1997 11:40:34   bennyn
* Fixed the compiling error for NT
*
*    Rev 1.5   07 Feb 1997 16:30:34   KENTL
* Never mind the #ifdefs. The problems are deeper than that. We'd need
* ifdefs around half the code in the file.
*
*    Rev 1.4   07 Feb 1997 16:18:58   KENTL
* Addd #ifdef's around include qmgr.h
*
*    Rev 1.3   07 Feb 1997 13:22:36   KENTL
* Merged in Evan Leland's modifications to get Display List mode working:
* 	* include qmgr.h
* 	* Invoke qmAllocDisplayList to get pDisplayList pointer.
* 	* Invoke qmExecuteDisplayList on completed DL's
*
*    Rev 1.2   23 Jan 1997 17:08:48   bennyn
* Modified naming of registers
*
*    Rev 1.1   25 Nov 1996 16:15:48   bennyn
* Fixed misc compiling error for NT
*
*    Rev 1.0   25 Nov 1996 15:14:02   RUSSL
* Initial revision.
*
*    Rev 1.2   18 Nov 1996 16:18:56   RUSSL
* Added file logging for DDraw entry points and register writes
*
*    Rev 1.1   01 Nov 1996 13:08:40   RUSSL
* Merge WIN95 & WINNT code for Blt32
*
*    Rev 1.0   01 Nov 1996 09:28:02   BENNYN
* Initial revision.
*
*    Rev 1.0   25 Oct 1996 11:08:22   RUSSL
* Initial revision.
*
***************************************************************************
***************************************************************************/

/***************************************************************************
* I N C L U D E S
****************************************************************************/

#include "precomp.h"

// If WinNT 3.5 skip all the source code
#if defined WINNT_VER35      // WINNT_VER35

#else  // !WINNT_VER35

#ifdef WINNT_VER40      // WINNT_VER40

#define DBGLVL        1
#define AFPRINTF(n)

#else  // !WINNT_VER40

#include "l3system.h"
#include "l2d.h"
#include "bltP.h"
#include "qmgr.h"

#endif   // !WINNT_VER40

/***************************************************************************
* S T A T I C   V A R I A B L E S
****************************************************************************/

#ifndef WINNT_VER40
ASSERTFILE("blt_dl.c");
#endif

/***************************************************************************
*
* FUNCTION:    DL_Delay9BitBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_Delay9BitBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  BOOL        ninebit_on
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_Delay9BitBlt\r\n"));

  /* This is to ensure that the last packet of any previous blt */
  /* does no go out with 9th bit set incorrectly */
  /* The boolean paramter is the 9th bit of the PREVIOUS BLT */

  rc = qmAllocDisplayList(8*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 4, 0);

  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | ((BD_RES + BD_OP0 + BD_OP1 + BD_OP2)*IS_VRAM);
  if (ninebit_on)
    *pDisplayList++ = (C_DRWDEF << 16) | (DD_PTAG | ROP_OP0_copy);
  else
    *pDisplayList++ = (C_DRWDEF << 16) | ROP_OP0_copy;

  // OP0_RDRAM
  *pDisplayList++ = (C_RX_0 << 16) | LOWORD(lpDDHALData->PTAGFooPixel);
  *pDisplayList++ = (C_RY_0 << 16) | HIWORD(lpDDHALData->PTAGFooPixel);

  // BLTEXT_EX
  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_BLTEXT_EX, 1, 0);
  *pDisplayList++ = MAKELONG(1,1);

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_Delay9BitBlt */

/***************************************************************************
*
* FUNCTION:     DL_EdgeFillBlt
*
* DESCRIPTION:  Solid Fill BLT to fill in edges ( Pixel Coords / Extents )
*
****************************************************************************/

void DL_EdgeFillBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  int         xFill,
  int         yFill,
  int         cxFill,
  int         cyFill,
  DWORD       FillValue,
  BOOL        ninebit_on
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_EdgeFillBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          MAKELONG(xFill,yFill),MAKELONG(cxFill,cyFill),FillValue));

  rc = qmAllocDisplayList(10*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 6, 0);

  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | (BD_RES * IS_VRAM + BD_OP1 * IS_SOLID);
  if (ninebit_on)
    *pDisplayList++ = (C_DRWDEF << 16) | (DD_PTAG | ROP_OP1_copy);
  else
    *pDisplayList++ = (C_DRWDEF << 16) | ROP_OP1_copy;

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(FillValue);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(FillValue);

  // OP0_opRDRAM
  *pDisplayList++ = (C_RX_0 << 16) | LOWORD(xFill);
  *pDisplayList++ = (C_RY_0 << 16) | LOWORD(yFill);

  // BLTEXT_EX
  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_BLTEXT_EX, 1, 0);
  *pDisplayList++ = MAKELONG(LOWORD(cxFill),LOWORD(cyFill));

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_EdgeFillBlt */

/***************************************************************************
*
* FUNCTION:     DL_MEdgeFillBlt
*
* DESCRIPTION:  Using BYTE BLT coords / Extents perform EdgeFill BLT
*
****************************************************************************/

void DL_MEdgeFillBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  int         xFill,
  int         yFill,
  int         cxFill,
  int         cyFill,
  DWORD       FillValue,
  BOOL        ninebit_on
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_MEdgeFillBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          MAKELONG(xFill,yFill),MAKELONG(cxFill,cyFill),FillValue));

  rc = qmAllocDisplayList(10*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 6, 0);

  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | (BD_RES * IS_VRAM + BD_OP1 * IS_SOLID);
  if (ninebit_on)
    *pDisplayList++ = (C_DRWDEF << 16) | (DD_PTAG | ROP_OP1_copy);
  else
    *pDisplayList++ = (C_DRWDEF << 16) | ROP_OP1_copy;

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(FillValue);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(FillValue);

  // OP0_opMRDRAM
  *pDisplayList++ = (C_MRX_0 << 16) | LOWORD(xFill);
  *pDisplayList++ = (C_MRY_0 << 16) | LOWORD(yFill);

  // MBLTEXT_EX
  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_MBLTEXT_EX, 1, 0);
  *pDisplayList++ = MAKELONG(LOWORD(cxFill),LOWORD(cyFill));

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_EdgeFillBlt */


/***************************************************************************
*
* FUNCTION:     DL_DrvDstBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_DrvDstBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_DrvDstBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  rc = qmAllocDisplayList(10*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 6, 0);

  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwBgColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwBgColor);

  // OP0_opRDRAM
  *pDisplayList++ = (C_RX_0 << 16) | LOWORD(dwDstCoord);
  *pDisplayList++ = (C_RY_0 << 16) | HIWORD(dwDstCoord);

  // BLTEXT_EX
  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_BLTEXT_EX, 1, 0);
  *pDisplayList++ = dwExtents;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvDstBlt */

/***************************************************************************
*
* FUNCTION:     DL_DrvDstBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_DrvDstMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;

  DD_LOG(("DL_DrvDstMBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  rc = qmAllocDisplayList(10*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 6, 0);

  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwBgColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwBgColor);

  // OP0_opMRDRAM
  *pDisplayList++ = (C_MRX_0 << 16) | LOWORD(dwDstCoord);
  *pDisplayList++ = (C_MRY_0 << 16) | HIWORD(dwDstCoord);

  // MBLTEXT_EX
  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_MBLTEXT_EX, 1, 0);
  *pDisplayList++ = dwExtents;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvDstMBlt */

/***************************************************************************
*
* FUNCTION:     DL_DrvSrcBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_DrvSrcBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;

  // Handle overlapped regions.
  const int xDelta = (int)LOWORD(dwDstCoord) - (int)LOWORD(dwSrcCoord);


  DD_LOG(("DL_DrvSrcBlt - dst=%08lX src=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwSrcCoord,dwExtents,dwKeyColor));

  // Check for x overlap.
  if ( abs(xDelta) < (int)LOWORD(dwExtents) )
  {
    const int yDelta = (int)HIWORD(dwDstCoord) - (int)HIWORD(dwSrcCoord);

    if ( (yDelta > 0) && (yDelta < (int)HIWORD(dwExtents)) )
    {
      const DWORD dwDelta = (dwExtents & MAKELONG(0,-1)) - MAKELONG(0, 1);

      // Convert to a bottom-up blt.
      dwDrawBlt  |= MAKELONG(0, BD_YDIR);
      dwDstCoord += dwDelta;
      dwSrcCoord += dwDelta;
      dwKeyCoord += dwDelta;
    }
    // are we sliding to the right?
    else if ( (xDelta > 0) && (yDelta == 0) )
    {
      const DWORD dwDelta = MAKELONG(xDelta, 0);

      // Blt the overlapped piece first.
      DL_DrvSrcBlt(
#ifdef WINNT_VER40
                   ppdev,
#endif
                   lpDDHALData,
                   dwDrawBlt,
                   dwDstCoord+dwDelta,
                   dwSrcCoord+dwDelta,
                   dwKeyCoord+dwDelta,
                   dwKeyColor,
                   dwExtents-dwDelta);

      // Subtract the overlap from the original extents.
      dwExtents = MAKELONG(xDelta, HIWORD(dwExtents));
    }
  }

  rc = qmAllocDisplayList(14*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 10, 0);

  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // OP0_opRDRAM
  *pDisplayList++ = (C_RX_0 << 16) | LOWORD(dwDstCoord);
  *pDisplayList++ = (C_RY_0 << 16) | HIWORD(dwDstCoord);

  // OP1_opRDRAM
  *pDisplayList++ = (C_RX_1 << 16) | LOWORD(dwSrcCoord);
  *pDisplayList++ = (C_RY_1 << 16) | HIWORD(dwSrcCoord);

  // OP2_opRDRAM
  *pDisplayList++ = (C_RX_2 << 16) | LOWORD(dwKeyCoord);
  *pDisplayList++ = (C_RY_2 << 16) | HIWORD(dwKeyCoord);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwKeyColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwKeyColor);

  // BLTEXT_EX
  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_BLTEXT_EX, 1, 0);
  *pDisplayList++ = dwExtents;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvSrcBlt */

/***************************************************************************
*
* FUNCTION:     DL_DrvSrcMBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_DrvSrcMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;

  // Handle overlapped regions.
  const int xDelta = (int)LOWORD(dwDstCoord) - (int)LOWORD(dwSrcCoord);


  DD_LOG(("DL_DrvSrcMBlt - dst=%08lX src=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwSrcCoord,dwExtents,dwKeyColor));

  // Check for x overlap.
  if ( abs(xDelta) < (int)LOWORD(dwExtents) )
  {
    const int yDelta = (int)HIWORD(dwDstCoord) - (int)HIWORD(dwSrcCoord);

    if ( (yDelta > 0) && (yDelta < (int)HIWORD(dwExtents)) )
    {
      const DWORD dwDelta = (dwExtents & MAKELONG(0,-1)) - MAKELONG(0, 1);

      // Convert to a bottom-up blt.
      dwDrawBlt  |= MAKELONG(0, BD_YDIR);
      dwDstCoord += dwDelta;
      dwSrcCoord += dwDelta;
      dwKeyCoord += dwDelta;
    }
    // are we sliding to the right?
    else if ( (xDelta > 0) && (yDelta == 0) )
    {
      const DWORD dwDelta = MAKELONG(xDelta, 0);

      // Blt the overlapped piece first.
      DL_DrvSrcMBlt(
#ifdef WINNT_VER40
                    ppdev,
#endif
                    lpDDHALData,
                    dwDrawBlt,
                    dwDstCoord+dwDelta,
                    dwSrcCoord+dwDelta,
                    dwKeyCoord+dwDelta,
                    dwKeyColor,
                    dwExtents-dwDelta);

      // Subtract the overlap from the original extents.
      dwExtents = MAKELONG(xDelta, HIWORD(dwExtents));
    }
  }

  rc = qmAllocDisplayList(14*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 10, 0);

  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // OP0_opMRDRAM
  *pDisplayList++ = (C_MRX_0 << 16) | LOWORD(dwDstCoord);
  *pDisplayList++ = (C_MRY_0 << 16) | HIWORD(dwDstCoord);

  // OP1_opMRDRAM
  *pDisplayList++ = (C_MRX_1 << 16) | LOWORD(dwSrcCoord);
  *pDisplayList++ = (C_MRY_1 << 16) | HIWORD(dwSrcCoord);

  // OP2_opMRDRAM
  *pDisplayList++ = (C_MRX_2 << 16) | LOWORD(dwKeyCoord);
  *pDisplayList++ = (C_MRY_2 << 16) | HIWORD(dwKeyCoord);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwKeyColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwKeyColor);

  // MBLTEXT_EX
  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_MBLTEXT_EX, 1, 0);
  *pDisplayList++ = dwExtents;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvSrcMBlt */

#if 0
/***************************************************************************
*
* FUNCTION:     DL_DrvStrBlt_OverlapCheck
*
* DESCRIPTION:
*
****************************************************************************/

static void INLINE DL_DrvStrBlt_OverlapCheck
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  int xdelta,ydelta;


  xdelta = abs(pblt->OP0_opRDRAM.pt.X - pblt->OP1_opRDRAM.pt.X);
  ydelta = abs(pblt->OP0_opRDRAM.pt.Y - pblt->OP1_opRDRAM.pt.Y);

  if ((xdelta < pblt->BLTEXT.pt.X) &&
      (ydelta < pblt->BLTEXT.pt.Y))
  {
    // hack, hack, cough, cough
    // pblt->MBLTEXT.DW has src exents

    // blt the src to the lower right of the dest
    DL_DrvSrcBlt(
#ifdef WINNT_VER40
                 ppdev,
                 lpDDHALData,
#endif
                 MAKELONG(ROP_OP1_copy, BD_RES * IS_VRAM | BD_OP1 * IS_VRAM),
                 pblt->OP0_opRDRAM.DW + pblt->BLTEXT.DW - pblt->MBLTEXT.DW,
                 pblt->OP1_opRDRAM.DW,
						     0UL,         // don't care
						     0UL,
                 pblt->MBLTEXT.DW);

    // update the src ptr to use this copy of the src
    pblt->OP1_opRDRAM.DW = pblt->OP0_opRDRAM.DW + pblt->BLTEXT.DW - pblt->MBLTEXT.DW;
  }
}
#endif

/***************************************************************************
*
* FUNCTION:     DL_DrvStrMBlt_OverlapCheck
*
* DESCRIPTION:
*
****************************************************************************/

static void INLINE DL_DrvStrMBlt_OverlapCheck
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  int xdelta,ydelta;


  xdelta = abs(pblt->OP0_opMRDRAM.pt.X - pblt->OP1_opMRDRAM.pt.X);
  ydelta = abs(pblt->OP0_opMRDRAM.pt.Y - pblt->OP1_opMRDRAM.pt.Y);

  if ((xdelta < pblt->MBLTEXTR_EX.pt.X) &&
      (ydelta < pblt->MBLTEXTR_EX.pt.Y))
  {
    // hack, hack, cough, cough
    // pblt->BLTEXT.DW has src exents (see DrvStretch65)

    // blt the src to the lower right of the dest
    DL_DrvSrcMBlt(
#ifdef WINNT_VER40
                  ppdev,
#endif
                  lpDDHALData,
                  MAKELONG(ROP_OP1_copy, BD_RES * IS_VRAM | BD_OP1 * IS_VRAM),
                  pblt->OP0_opMRDRAM.DW + pblt->MBLTEXTR_EX.DW - pblt->BLTEXT.DW,
                  pblt->OP1_opMRDRAM.DW,
						      0UL,         // don't care
						      0UL,
                  pblt->BLTEXT.DW);

    // update the src ptr to use this copy of the src
    pblt->OP1_opMRDRAM.DW = pblt->OP0_opMRDRAM.DW + pblt->MBLTEXTR_EX.DW - pblt->BLTEXT.DW;
  }
}

/***************************************************************************
*
* FUNCTION:     DL_DrvStrBlt
*
* DESCRIPTION:	 62/64 version
*
****************************************************************************/

void DL_DrvStrBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_DrvStrBlt - dst=%08lX dstext=%08lX src=%08lX\r\n",
          pblt->OP0_opRDRAM.DW,pblt->BLTEXT.DW,pblt->OP1_opRDRAM.DW));

  ASSERT( pblt->BLTEXT.pt.X != 0 );
  ASSERT( pblt->BLTEXT.pt.Y != 0 );

  DBG_MESSAGE(("DL_DrvStrBlt:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));

#if 0
    // check for overlap
    DL_DrvStrBlt_OverlapCheck(
#ifdef WINNT_VER40
                              ppdev,lpDDHALData,
#endif
                              pblt);
#endif

  rc = qmAllocDisplayList(19*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 15, 0);

  *pDisplayList++ = (C_LNCNTL << 16) | pblt->LNCNTL.W;
  *pDisplayList++ = (C_SHINC  << 16) | pblt->SHRINKINC.W;
  *pDisplayList++ = (C_SRCX   << 16) | pblt->SRCX;
  *pDisplayList++ = (C_MAJX   << 16) | pblt->MAJ_X;
  *pDisplayList++ = (C_MINX   << 16) | pblt->MIN_X;
  *pDisplayList++ = (C_ACCUMX << 16) | pblt->ACCUM_X;
  *pDisplayList++ = (C_MAJY   << 16) | pblt->MAJ_Y;
  *pDisplayList++ = (C_MINY   << 16) | pblt->MIN_Y;
  *pDisplayList++ = (C_ACCUMY << 16) | pblt->ACCUM_Y;
  *pDisplayList++ = (C_RX_0   << 16) | pblt->OP0_opRDRAM.pt.X;
  *pDisplayList++ = (C_RY_0   << 16) | pblt->OP0_opRDRAM.pt.Y;
  *pDisplayList++ = (C_RX_1   << 16) | pblt->OP1_opRDRAM.pt.X;
  *pDisplayList++ = (C_RY_1   << 16) | pblt->OP1_opRDRAM.pt.Y;
  *pDisplayList++ = (C_BLTDEF << 16) | pblt->DRAWBLTDEF.lh.HI;
  *pDisplayList++ = (C_DRWDEF << 16) | pblt->DRAWBLTDEF.lh.LO;

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_BLTEXTR_EX, 1, 0);
  *pDisplayList++ = pblt->BLTEXT.DW;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvStrBlt */

/***************************************************************************
*
* FUNCTION:     DL_DrvStrBlt65
*
* DESCRIPTION:  65+ version
*
****************************************************************************/

void DL_DrvStrBlt65
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_DrvStrBlt65 - dst=%08lX dstext=%08lX src=%08lX\r\n",
          pblt->OP0_opMRDRAM.DW,pblt->MBLTEXTR_EX.DW,pblt->OP1_opMRDRAM.DW));

  ASSERT( pblt->MBLTEXTR_EX.pt.X != 0 );
  ASSERT( pblt->MBLTEXTR_EX.pt.Y != 0 );

  DBG_MESSAGE(("DL_DrvStrBlt65:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opMRDRAM.PT.X, pblt->OP1_opMRDRAM.PT.Y,
               pblt->OP0_opMRDRAM.PT.X, pblt->OP0_opMRDRAM.PT.Y,
               pblt->MBLTEXTR_EX.PT.X, pblt->MBLTEXTR_EX.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->STRETCH_CNTL.W));

    // check for overlap
    DL_DrvStrMBlt_OverlapCheck(
#ifdef WINNT_VER40
                               ppdev,
#endif
                               lpDDHALData,
                               pblt);

  rc = qmAllocDisplayList(19*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 15, 0);

  *pDisplayList++ = (C_STRCTL << 16) | pblt->STRETCH_CNTL.W;
  *pDisplayList++ = (C_SHINC  << 16) | pblt->SHRINKINC.W;
  *pDisplayList++ = (C_SRCX   << 16) | pblt->SRCX;
  *pDisplayList++ = (C_MAJX   << 16) | pblt->MAJ_X;
  *pDisplayList++ = (C_MINX   << 16) | pblt->MIN_X;
  *pDisplayList++ = (C_ACCUMX << 16) | pblt->ACCUM_X;
  *pDisplayList++ = (C_MAJY   << 16) | pblt->MAJ_Y;
  *pDisplayList++ = (C_MINY   << 16) | pblt->MIN_Y;
  *pDisplayList++ = (C_ACCUMY << 16) | pblt->ACCUM_Y;
  *pDisplayList++ = (C_MRX_0   << 16) | pblt->OP0_opMRDRAM.pt.X;
  *pDisplayList++ = (C_MRY_0   << 16) | pblt->OP0_opMRDRAM.pt.Y;
  *pDisplayList++ = (C_MRX_1   << 16) | pblt->OP1_opMRDRAM.pt.X;
  *pDisplayList++ = (C_MRY_1   << 16) | pblt->OP1_opMRDRAM.pt.Y;
  *pDisplayList++ = (C_BLTDEF << 16) | pblt->DRAWBLTDEF.lh.HI;
  *pDisplayList++ = (C_DRWDEF << 16) | pblt->DRAWBLTDEF.lh.LO;

  // MBLTEXTR_EX
  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_MBLTEXTR_EX, 1, 0);
  *pDisplayList++ = pblt->MBLTEXTR_EX.DW;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DIR_DrvStrBlt65 */

/***************************************************************************
*
* FUNCTION:     DL_DrvStrMBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_DrvStrMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_DrvStrMBlt - dst=%08lX dstext=%08lX src=%08lX\r\n",
          pblt->OP0_opRDRAM.DW,pblt->BLTEXT.DW,pblt->OP1_opRDRAM.DW));

  ASSERT( pblt->BLTEXT.pt.X != 0 );
  ASSERT( pblt->BLTEXT.pt.Y != 0 );

  DBG_MESSAGE(("DL_DrvStrMBlt:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));

    // check for overlap
    DL_DrvStrMBlt_OverlapCheck(
#ifdef WINNT_VER40
                               ppdev,
#endif
                               lpDDHALData,
                               pblt);

  rc = qmAllocDisplayList(19*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 15, 0);

  *pDisplayList++ = (C_LNCNTL << 16) | pblt->LNCNTL.W;
  *pDisplayList++ = (C_SHINC  << 16) | pblt->SHRINKINC.W;
  *pDisplayList++ = (C_SRCX   << 16) | pblt->SRCX;
  *pDisplayList++ = (C_MAJX   << 16) | pblt->MAJ_X;
  *pDisplayList++ = (C_MINX   << 16) | pblt->MIN_X;
  *pDisplayList++ = (C_ACCUMX << 16) | pblt->ACCUM_X;
  *pDisplayList++ = (C_MAJY   << 16) | pblt->MAJ_Y;
  *pDisplayList++ = (C_MINY   << 16) | pblt->MIN_Y;
  *pDisplayList++ = (C_ACCUMY << 16) | pblt->ACCUM_Y;
  *pDisplayList++ = (C_MRX_0  << 16) | pblt->OP0_opRDRAM.pt.X;
  *pDisplayList++ = (C_MRY_0  << 16) | pblt->OP0_opRDRAM.pt.Y;
  *pDisplayList++ = (C_MRX_1  << 16) | pblt->OP1_opRDRAM.pt.X;
  *pDisplayList++ = (C_MRY_1  << 16) | pblt->OP1_opRDRAM.pt.Y;
  *pDisplayList++ = (C_BLTDEF << 16) | pblt->DRAWBLTDEF.lh.HI;
  *pDisplayList++ = (C_DRWDEF << 16) | pblt->DRAWBLTDEF.lh.LO;

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_MBLTEXTR_EX, 1, 0);
  *pDisplayList++ = pblt->BLTEXT.DW;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvStrMBlt */

/***************************************************************************
*
* FUNCTION:     DL_DrvStrMBltY
*
* DESCRIPTION:  Write regs that don't vary over the stripes
*               Used in conjunction with DL_DrvStrMBltX
*
****************************************************************************/

void DL_DrvStrMBltY
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_DrvStrMBltY - dst.Y=%04X dstext.Y=%04X src=%04X\r\n",
          pblt->OP0_opRDRAM.pt.Y,pblt->BLTEXT.pt.Y,pblt->OP1_opRDRAM.pt.Y));

  ASSERT( pblt->BLTEXT.pt.Y != 0 );

  DBG_MESSAGE(("DrvStrMBltY:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));

  rc = qmAllocDisplayList(13*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 11, 0);

  *pDisplayList++ = (C_LNCNTL << 16) | pblt->LNCNTL.W;
  *pDisplayList++ = (C_SHINC  << 16) | pblt->SHRINKINC.W;
  *pDisplayList++ = (C_MAJX   << 16) | pblt->MAJ_X;
  *pDisplayList++ = (C_MINX   << 16) | pblt->MIN_X;
  *pDisplayList++ = (C_MAJY   << 16) | pblt->MAJ_Y;
  *pDisplayList++ = (C_MINY   << 16) | pblt->MIN_Y;
  *pDisplayList++ = (C_ACCUMY << 16) | pblt->ACCUM_Y;
  *pDisplayList++ = (C_MRY_0  << 16) | pblt->OP0_opRDRAM.pt.Y;
  *pDisplayList++ = (C_MRY_1  << 16) | pblt->OP1_opRDRAM.pt.Y;
  *pDisplayList++ = (C_BLTDEF << 16) | pblt->DRAWBLTDEF.lh.HI;
  *pDisplayList++ = (C_DRWDEF << 16) | pblt->DRAWBLTDEF.lh.LO;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvStrMBltY */

/***************************************************************************
*
* FUNCTION:     DL_DrvStrMBltX
*
* DESCRIPTION:  Write stripe specific regs
*               Used in conjunction with DL_DrvStrMBltY
*
****************************************************************************/

void DL_DrvStrMBltX
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_DrvStrMBltX - dst.X=%04X dstext.X=%04X src.X=%04X\r\n",
          pblt->OP0_opRDRAM.pt.X,pblt->BLTEXT.pt.X,pblt->OP1_opRDRAM.pt.X));

  ASSERT( pblt->BLTEXT.pt.X != 0 );

  DBG_MESSAGE(("DrvStrMBltX:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));

  rc = qmAllocDisplayList(8*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 4, 0);

  *pDisplayList++ = (C_SRCX   << 16) | pblt->SRCX;
  *pDisplayList++ = (C_ACCUMX << 16) | pblt->ACCUM_X;
  *pDisplayList++ = (C_MRX_0  << 16) | pblt->OP0_opRDRAM.pt.X;
  *pDisplayList++ = (C_MRX_1  << 16) | pblt->OP1_opRDRAM.pt.X;

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_MBLTEXTR_EX, 1, 0);
  *pDisplayList++ = pblt->BLTEXT.DW;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvStrMBltX */

/***************************************************************************
*
* FUNCTION:     DL_DrvStrBltY
*
* DESCRIPTION:  Write regs that don't vary over the stripes
*               Used in conjunction with DL_DrvStrBltX
*
****************************************************************************/

void DL_DrvStrBltY
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_DrvStrBltY\r\n"));

  DBG_MESSAGE(("DL_DrvStrBltY:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));

  rc = qmAllocDisplayList(12*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 10, 0);

  *pDisplayList++ = (C_LNCNTL << 16) | pblt->LNCNTL.W;
  *pDisplayList++ = (C_SHINC  << 16) | pblt->SHRINKINC.W;
  *pDisplayList++ = (C_SRCX   << 16) | pblt->SRCX;
  *pDisplayList++ = (C_MAJX   << 16) | pblt->MAJ_X;
  *pDisplayList++ = (C_MINX   << 16) | pblt->MIN_X;
  *pDisplayList++ = (C_MAJY   << 16) | pblt->MAJ_Y;
  *pDisplayList++ = (C_MINY   << 16) | pblt->MIN_Y;
  *pDisplayList++ = (C_ACCUMY << 16) | pblt->ACCUM_Y;
  *pDisplayList++ = (C_BLTDEF << 16) | pblt->DRAWBLTDEF.lh.HI;
  *pDisplayList++ = (C_DRWDEF << 16) | pblt->DRAWBLTDEF.lh.LO;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvStrBltY */

/***************************************************************************
*
* FUNCTION:     DL_DrvStrBltX
*
* DESCRIPTION:  Write stripe specific regs
*               Used in conjunction with DL_DrvStrMBltY
*
****************************************************************************/

void DL_DrvStrBltX
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_DrvStrBltX - dst=%08lX dstext=%08lX src=%08lX\r\n",
          pblt->OP0_opRDRAM.DW,pblt->BLTEXT.DW,pblt->OP1_opRDRAM.DW));

  ASSERT( pblt->BLTEXT.pt.X != 0 );
  ASSERT( pblt->BLTEXT.pt.Y != 0 );

  DBG_MESSAGE(("DL_DrvStrBltX:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));

  rc = qmAllocDisplayList(9*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 5, 0);

  *pDisplayList++ = (C_ACCUMX << 16) | pblt->ACCUM_X;
  *pDisplayList++ = (C_RX_0   << 16) | pblt->OP0_opRDRAM.pt.X;
  *pDisplayList++ = (C_RY_0   << 16) | pblt->OP0_opRDRAM.pt.Y;
  *pDisplayList++ = (C_RX_1   << 16) | pblt->OP1_opRDRAM.pt.X;
  *pDisplayList++ = (C_RY_1   << 16) | pblt->OP1_opRDRAM.pt.Y;

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_BLTEXTR_EX, 1, 0);
  *pDisplayList++ = pblt->BLTEXT.DW;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvStrBltX */

#if ENABLE_CLIPPEDBLTS

/***************************************************************************
*
* FUNCTION:     DL_HWClippedDrvDstBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_HWClippedDrvDstBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD       *pDisplayList;
  qm_return   rc;
  QMDLHandle  Handle;


  DD_LOG(("DL_HWClippedDrvDstBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  // check for negative dst coordinates, hw can't deal with negative OP0 values
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.X)
  {
    (short)((REG32 *)&dwExtents)->pt.X += (short)((REG32 *)&dwDstCoord)->pt.X;
    ((REG32 *)&dwDstCoord)->pt.X = 0;
  }
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.Y)
  {
    (short)((REG32 *)&dwExtents)->pt.Y += (short)((REG32 *)&dwDstCoord)->pt.Y;
    ((REG32 *)&dwDstCoord)->pt.Y = 0;
  }

  rc = qmAllocDisplayList((10+dwRectCnt*4)*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 8, 0);

  // setup blt, write BLTEXT reg with extent which doesn't fire off blt
  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwBgColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwBgColor);

  // OP0_opRDRAM
  *pDisplayList++ = (C_RX_0 << 16) | LOWORD(dwDstCoord);
  *pDisplayList++ = (C_RY_0 << 16) | HIWORD(dwDstCoord);

  // BLTEXT
  *pDisplayList++ = (C_BLTEXT_X << 16) | LOWORD(dwExtents);
  *pDisplayList++ = (C_BLTEXT_Y << 16) | HIWORD(dwExtents);

  // loop over clip list
  do
  {
    REG32   UpperLeft;
    REG32   LowerRight;

    // compute cliprect coords
    UpperLeft.DW  = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    LowerRight.DW = dwDstBaseXY + MAKELONG(pDestRects->right, pDestRects->bottom);

    // write clipping regs
    // CLIPULE
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_CLIPULE, 1, 0);
    *pDisplayList++ = UpperLeft.DW;

    // CLIPLOR_EX
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_CLIPLOR_EX, 1, 0);
    *pDisplayList++ = LowerRight.DW;

    pDestRects++;
  } while (0 < --dwRectCnt);

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_HWClippedDrvDstBlt */

/***************************************************************************
*
* FUNCTION:     DL_HWClippedDrvDstMBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_HWClippedDrvDstMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  const int   nBytesPixel = BYTESPERPIXEL;
  DWORD       *pDisplayList;
  qm_return   rc;
  QMDLHandle  Handle;


  DD_LOG(("DL_HWClippedDrvDstMBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  // check for negative dst coordinates, hw can't deal with negative OP0 values
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.X)
  {
    (short)((REG32 *)&dwExtents)->pt.X += (short)((REG32 *)&dwDstCoord)->pt.X;
    ((REG32 *)&dwDstCoord)->pt.X = 0;
  }
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.Y)
  {
    (short)((REG32 *)&dwExtents)->pt.Y += (short)((REG32 *)&dwDstCoord)->pt.Y;
    ((REG32 *)&dwDstCoord)->pt.Y = 0;
  }

  rc = qmAllocDisplayList((10+dwRectCnt*4)*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 8, 0);

  // setup blt, write BLTEXT reg with extent which doesn't fire off blt
  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwBgColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwBgColor);

  // OP0_opMRDRAM
  *pDisplayList++ = (C_MRX_0 << 16) | LOWORD(dwDstCoord);
  *pDisplayList++ = (C_MRY_0 << 16) | HIWORD(dwDstCoord);

  // MBLTEXT
  *pDisplayList++ = (C_MBLTEXT_X << 16) | LOWORD(dwExtents);
  *pDisplayList++ = (C_MBLTEXT_Y << 16) | HIWORD(dwExtents);

  // loop over clip list
  do
  {
    REG32   UpperLeft;
    REG32   LowerRight;

    // compute cliprect coords
    UpperLeft.DW  = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    LowerRight.DW = dwDstBaseXY + MAKELONG(pDestRects->right, pDestRects->bottom);
    UpperLeft.pt.X  *= nBytesPixel;
    LowerRight.pt.X *= nBytesPixel;

    // write clipping regs
    // MCLIPULE
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_MCLIPULE, 1, 0);
    *pDisplayList++ = UpperLeft.DW;

    // MCLIPLOR_EX
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_MCLIPLOR_EX, 1, 0);
    *pDisplayList++ = LowerRight.DW;

    pDestRects++;
  } while (0 < --dwRectCnt);

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_HWClippedDrvDstMBlt */

/***************************************************************************
*
* FUNCTION:     DL_HWClippedDrvSrcBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_HWClippedDrvSrcBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwSrcBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD       *pDisplayList;
  qm_return   rc;
  QMDLHandle  Handle;

  // Handle overlapped regions
  const int xDelta = (int)LOWORD(dwDstCoord) - (int)LOWORD(dwSrcCoord);


  DD_LOG(("DL_HWClippedDrvSrcBlt - dst=%08lX src=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwSrcCoord,dwExtents,dwKeyColor));

  // check for negative dst coordinates, hw can't deal with negative OP0 values
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.X)
  {
    // reduce extent.X
    (short)((REG32 *)&dwExtents)->pt.X += (short)((REG32 *)&dwDstCoord)->pt.X;
    // bump src.X to right
    (short)((REG32 *)&dwSrcCoord)->pt.X -= (short)((REG32 *)&dwDstCoord)->pt.X;
    if ((DD_TRANS | DD_TRANSOP) & dwDrawBlt)
      // bump key.X to right
      (short)((REG32 *)&dwKeyCoord)->pt.X -= (short)((REG32 *)&dwKeyCoord)->pt.X;
    // clear dst.X
    ((REG32 *)&dwDstCoord)->pt.X = 0;
  }
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.Y)
  {
    // reduce extent.Y
    (short)((REG32 *)&dwExtents)->pt.Y += (short)((REG32 *)&dwDstCoord)->pt.Y;
    // bump src.Y down
    (short)((REG32 *)&dwSrcCoord)->pt.Y -= (short)((REG32 *)&dwDstCoord)->pt.Y;
    if ((DD_TRANS | DD_TRANSOP) & dwDrawBlt)
      // bump key.Y down
      (short)((REG32 *)&dwKeyCoord)->pt.Y -= (short)((REG32 *)&dwKeyCoord)->pt.Y;
    // clean dst.Y
    ((REG32 *)&dwDstCoord)->pt.Y = 0;
  }

  // Check for x overlap
  if ( abs(xDelta) < (int)LOWORD(dwExtents) )
  {
    const int yDelta = (int)HIWORD(dwDstCoord) - (int)HIWORD(dwSrcCoord);

    if ( (yDelta > 0) && (yDelta < (int)HIWORD(dwExtents)) )
    {
      const DWORD dwDelta = (dwExtents & MAKELONG(0, -1)) - MAKELONG(0, 1);

      // Convert to a bottom-up blt.
      dwDrawBlt  |= MAKELONG(0, BD_YDIR);
      dwDstCoord += dwDelta;
      dwSrcCoord += dwDelta;
      dwKeyCoord += dwDelta;
    }
    // are we sliding to the right?
    else if ( (xDelta > 0) && (yDelta == 0) )
    {
      const DWORD dwDelta = MAKELONG(xDelta, 0);

      // Blt the overlapped piece first
      DL_HWClippedDrvSrcBlt(
#ifdef WINNT_VER40
                            ppdev,
                            lpDDHALData,
#endif
                            dwDrawBlt,
                            dwDstCoord+dwDelta,
                            dwSrcCoord+dwDelta,
                            dwKeyCoord+dwDelta,
                            dwKeyColor,
                            dwExtents-dwDelta,
                            dwDstBaseXY,
                            dwSrcBaseXY,
                            dwRectCnt,
                            pDestRects);

      // Subtract the overlap from the original extents.
      dwExtents = MAKELONG(xDelta, HIWORD(dwExtents));
    }
  }

  rc = qmAllocDisplayList((14+dwRectCnt*4)*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 12, 0);

  // setup blt, write BLTEXT reg with extent which doesn't fire off blt
  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // OP0_opRDRAM
  *pDisplayList++ = (C_RX_0 << 16) | LOWORD(dwDstCoord);
  *pDisplayList++ = (C_RY_0 << 16) | HIWORD(dwDstCoord);

  // OP1_opRDRAM
  *pDisplayList++ = (C_RX_1 << 16) | LOWORD(dwSrcCoord);
  *pDisplayList++ = (C_RY_1 << 16) | HIWORD(dwSrcCoord);

  // OP2_opRDRAM
  *pDisplayList++ = (C_RX_2 << 16) | LOWORD(dwKeyCoord);
  *pDisplayList++ = (C_RY_2 << 16) | HIWORD(dwKeyCoord);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwKeyColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwKeyColor);

  // BLTEXT
  *pDisplayList++ = (C_BLTEXT_X << 16) | LOWORD(dwExtents);
  *pDisplayList++ = (C_BLTEXT_Y << 16) | HIWORD(dwExtents);

  // loop over clip list
  do
  {
    REG32   UpperLeft;
    REG32   LowerRight;

    // compute cliprect coords
    UpperLeft.DW  = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    LowerRight.DW = dwDstBaseXY + MAKELONG(pDestRects->right, pDestRects->bottom);

    // write clipping regs
    // CLIPULE
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_CLIPULE, 1, 0);
    *pDisplayList++ = UpperLeft.DW;

    // CLIPLOR_EX
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_CLIPLOR_EX, 1, 0);
    *pDisplayList++ = LowerRight.DW;

    pDestRects++;
  } while (0 < --dwRectCnt);

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_HWClippedDrvSrcBlt */

/***************************************************************************
*
* FUNCTION:     DL_SWClippedDrvDstBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_SWClippedDrvDstBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD       *pDisplayList;
  qm_return   rc;
  QMDLHandle  Handle;


  DD_LOG(("DL_SWClippedDrvDstBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  // make sure DD_CLIP isn't set in drawdef
  dwDrawBlt &= ~DD_CLIP;

  rc = qmAllocDisplayList((6+dwRectCnt*4)*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 4, 0);

  // write regs that don't vary over rectangles
  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwBgColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwBgColor);

  // loop over clip list
  do
  {
    DDRECTL   DstDDRect;

    // compute cliprect coords
    DstDDRect.loc.DW = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    DstDDRect.ext.pt.X = (WORD)(pDestRects->right - pDestRects->left);
    DstDDRect.ext.pt.Y = (WORD)(pDestRects->bottom - pDestRects->top);

    // write OP0 and bltext regs
    // OP0_opRDRAM
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_OP0_OPRDRAM, 1, 0);
    *pDisplayList++ = DstDDRect.loc.DW;

    // BLTEXT_EX
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_BLTEXT_EX, 1, 0);
    *pDisplayList++ = DstDDRect.ext.DW;

    pDestRects++;
  } while (0 < --dwRectCnt);

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_SWClippedDrvDstBlt */

/***************************************************************************
*
* FUNCTION:     DL_SWClippedDrvDstMBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_SWClippedDrvDstMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  const int   nBytesPixel = BYTESPERPIXEL;
  DWORD       *pDisplayList;
  qm_return   rc;
  QMDLHandle  Handle;


  DD_LOG(("DL_SWClippedDrvDstMBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  // make sure DD_CLIP isn't set in drawdef
  dwDrawBlt &= ~DD_CLIP;

  rc = qmAllocDisplayList((6+dwRectCnt*4)*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 4, 0);

  // write regs that don't vary over rectangles
  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwBgColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwBgColor);

  // loop over clip list
  do
  {
    DDRECTL   DstDDRect;

    // compute cliprect coords
    DstDDRect.loc.DW = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    DstDDRect.loc.pt.X *= nBytesPixel;
    DstDDRect.ext.pt.X = (WORD)(pDestRects->right - pDestRects->left) * nBytesPixel;
    DstDDRect.ext.pt.Y = (WORD)(pDestRects->bottom - pDestRects->top);

    // write OP0 and bltext regs
    // OP0_opMRDRAM
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_OP0_OPMRDRAM, 1, 0);
    *pDisplayList++ = DstDDRect.loc.DW;

    // MBLTEXT_EX
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_MBLTEXT_EX, 1, 0);
    *pDisplayList++ = DstDDRect.ext.DW;

    pDestRects++;
  } while (0 < --dwRectCnt);

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_SWClippedDrvDstMBlt */

/***************************************************************************
*
* FUNCTION:     DL_SWClippedDrvSrcBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_SWClippedDrvSrcBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwSrcBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD       *pDisplayList;
  qm_return   rc;
  QMDLHandle  Handle;

  // Handle overlapped regions
  const int xDelta = (int)LOWORD(dwDstCoord) - (int)LOWORD(dwSrcCoord);


  DD_LOG(("DL_SWClippedDrvSrcBlt - dst=%08lX src=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwSrcCoord,dwExtents,dwKeyColor));

  // make sure DD_CLIP isn't set in drawdef
  dwDrawBlt &= ~DD_CLIP;

  // Check for x overlap
  if ( abs(xDelta) < (int)LOWORD(dwExtents) )
  {
    const int yDelta = (int)HIWORD(dwDstCoord) - (int)HIWORD(dwSrcCoord);

    if ( (yDelta > 0) && (yDelta < (int)HIWORD(dwExtents)) )
    {
      const DWORD dwDelta = (dwExtents & MAKELONG(0, -1)) - MAKELONG(0, 1);

      // Convert to a bottom-up blt.
      dwDrawBlt  |= MAKELONG(0, BD_YDIR);
      dwDstCoord += dwDelta;
      dwSrcCoord += dwDelta;
      dwKeyCoord += dwDelta;
    }
    // are we sliding to the right?
    else if ( (xDelta > 0) && (yDelta == 0) )
    {
      const DWORD dwDelta = MAKELONG(xDelta, 0);

      // Blt the overlapped piece first
      DL_SWClippedDrvSrcBlt(
#ifdef WINNT_VER40
                            ppdev,
                            lpDDHALData,
#endif
                            dwDrawBlt,
                            dwDstCoord+dwDelta,
                            dwSrcCoord+dwDelta,
                            dwKeyCoord+dwDelta,
                            dwKeyColor,
                            dwExtents-dwDelta,
                            dwDstBaseXY,
                            dwSrcBaseXY,
                            dwRectCnt,
                            pDestRects);

      // Subtract the overlap from the original extents.
      dwExtents = MAKELONG(xDelta, HIWORD(dwExtents));
    }
  }

  rc = qmAllocDisplayList((6+dwRectCnt*9)*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 4, 0);

  // write regs that don't vary over rectangles
  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwKeyColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwKeyColor);

  // loop over clip list
  do
  {
    DDRECTL   DstDDRect;
    DDRECTL   SrcDDRect;

    // compute dst cliprect coords
    DstDDRect.loc.DW = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    DstDDRect.ext.pt.X = (WORD)(pDestRects->right - pDestRects->left);
    DstDDRect.ext.pt.Y = (WORD)(pDestRects->bottom - pDestRects->top);

    // compute src cliprect coords
    SrcDDRect.loc.DW = dwSrcBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    // don't care about src extent, it's the same as dst extent
    //SrcDDRect.ext.pt.X = (WORD)(pDestRects->right - pDestRects->left);
    //SrcDDRect.ext.pt.Y = (WORD)(pDestRects->bottom - pDestRects->top);

    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 6, 0);

    // write OP0, OP1, OP2 and bltext regs
    if ((DD_TRANS | DD_TRANSOP) == ((DD_TRANS | DD_TRANSOP) & dwDrawBlt))
    {
      // dst color key
      // OP2_opRDRAM
      *pDisplayList++ = (C_RX_2 << 16) | DstDDRect.loc.pt.X;
      *pDisplayList++ = (C_RY_2 << 16) | DstDDRect.loc.pt.Y;
    }
    else if (DD_TRANS == ((DD_TRANS | DD_TRANSOP) & dwDrawBlt))
    {
      // src color key
      // OP2_opRDRAM
      *pDisplayList++ = (C_RX_2 << 16) | SrcDDRect.loc.pt.X;
      *pDisplayList++ = (C_RY_2 << 16) | SrcDDRect.loc.pt.Y;
    }
    else
    {
      // OP2_opRDRAM
      *pDisplayList++ = (C_RX_2 << 16) | 0;
      *pDisplayList++ = (C_RY_2 << 16) | 0;
    }

    // OP0_opRDRAM
    *pDisplayList++ = (C_RX_0 << 16) | DstDDRect.loc.pt.X;
    *pDisplayList++ = (C_RY_0 << 16) | DstDDRect.loc.pt.Y;

    // OP1_opRDRAM
    *pDisplayList++ = (C_RX_1 << 16) | SrcDDRect.loc.pt.X;
    *pDisplayList++ = (C_RY_1 << 16) | SrcDDRect.loc.pt.Y;

    // BLTEXT_EX
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_BLTEXT_EX, 1, 0);
    *pDisplayList++ = DstDDRect.ext.DW;

    pDestRects++;
  } while (0 < --dwRectCnt);

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_SWClippedDrvSrcBlt */

#endif  // ENABLE_CLIPPEDBLTS

#endif // WINNT_VER35
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\blt_dir.c ===
/**************************************************************************
***************************************************************************
*
*     Copyright (c) 1996, Cirrus Logic, Inc.
*                 All Rights Reserved
*
* FILE:         blt_dir.c
*
* DESCRIPTION:  Direct blts for the 546x
*
* REVISION HISTORY:
*
* $Log:   X:/log/laguna/ddraw/src/blt_dir.c  $
* 
*    Rev 1.21   Mar 04 1998 15:07:10   frido
* Added new shadow macros.
* 
*    Rev 1.20   06 Jan 1998 11:40:56   xcong
* Change pDriverData into local lpDDHALData for multi-monitor support.
* 
*    Rev 1.19   Nov 04 1997 09:36:16   frido
* Argh! This file is shared with WIndows 95 and it breaks there because I added
* the REQUIRE macro. So I have defined it for non Windows NT as the WaitForRoom
* macro.
* 
*    Rev 1.18   Nov 03 1997 12:48:22   frido
* Added REQUIRE macros.
* Removed redundant WaitForRoom macros.
* 
*    Rev 1.17   03 Oct 1997 14:29:50   RUSSL
* Initial changes for use of hw clipped blts
* All changes wrapped in #if ENABLE_CLIPPEDBLTS/#endif blocks and
* ENABLE_CLIPPEDBLTS defaults to 0 (so the code is disabled)
*
*    Rev 1.16   19 Aug 1997 09:18:42   RUSSL
* Updated require counts in DIR_DrvStrBlt & DIR_DrvStrBlt65
*
*    Rev 1.15   30 Jul 1997 20:55:52   RANDYS
* Added code to check for zero extent blts
*
*    Rev 1.14   24 Jul 1997 12:32:02   RUSSL
* Botched the overlap check, changed || to &&
*
*    Rev 1.13   24 Jul 1997 11:19:02   RUSSL
* Added DIR_DrvStrBlt_OverlapCheck & DIR_DrvStrMBlt_OverlapCheck
* inline functions
*
*    Rev 1.12   14 Jul 1997 14:55:50   RUSSL
* For Win95, split DIR_DrvStrBlt into two versions, one version for 62/64
* and one version for 65+.  BltInit points pfnDrvStrBlt to the appropriate
* version.
*
*    Rev 1.11   08 Jul 1997 11:17:28   RUSSL
* Modified chip check in DIR_DrvStrBlt to a one bit test rather a two dword
* compare (for Win95 only)
*
*    Rev 1.10   19 May 1997 14:02:02   bennyn
* Removed all #ifdef NT for WaitForRoom macro
*
*    Rev 1.9   03 Apr 1997 15:04:48   RUSSL
* Added DIR_DrvDstMBlt function
*
*    Rev 1.8   26 Mar 1997 13:54:24   RUSSL
* Added DIR_DrvSrcMBlt function
* Changed ACCUM_X workaround to just write 0 to LNCNTL
*
*    Rev 1.7   21 Mar 1997 18:05:04   RUSSL
* Added workaround writing ACCUM_X in DIR_DrvStrBlt
*
*    Rev 1.6   12 Mar 1997 15:00:38   RUSSL
* replaced a block of includes with include of precomp.h for
*   precompiled headers
*
*    Rev 1.5   07 Mar 1997 12:49:16   RUSSL
* Modified DDRAW_COMPAT usage
*
*    Rev 1.4   27 Jan 1997 17:28:34   BENNYN
* Added Win95 support
*
*    Rev 1.3   23 Jan 1997 16:55:56   bennyn
* Added 5465 DD support
*
*    Rev 1.2   25 Nov 1996 16:52:20   RUSSL
* NT change broke Win95 build
*
*    Rev 1.1   25 Nov 1996 16:13:54   bennyn
* Fixed misc compiling error for NT
*
*    Rev 1.0   25 Nov 1996 15:11:12   RUSSL
* Initial revision.
*
*    Rev 1.3   18 Nov 1996 16:20:12   RUSSL
* Added file logging for DDraw entry points and register writes
*
*    Rev 1.2   10 Nov 1996 12:36:24   CRAIGN
* Frido's 1111 release.
* Minor parenthesis change - bug fix.
*
*    Rev 1.1   01 Nov 1996 13:08:32   RUSSL
* Merge WIN95 & WINNT code for Blt32
*
*    Rev 1.0   01 Nov 1996 09:27:42   BENNYN
* Initial revision.
*
*    Rev 1.0   25 Oct 1996 11:08:18   RUSSL
* Initial revision.
*
***************************************************************************
***************************************************************************/

/***************************************************************************
* I N C L U D E S
****************************************************************************/

#include "precomp.h"

// If WinNT 3.5 skip all the source code
#if defined WINNT_VER35      // WINNT_VER35

#else

#ifdef WINNT_VER40      // WINNT_VER40

#define DBGLVL        1
#define AFPRINTF(n)

#else

#include "bltP.h"

#endif // !WINNT_VER40

/***************************************************************************
* D E F I N E S
****************************************************************************/

#ifndef WINNT_VER40
#define REQUIRE( size ) while ( (volatile)pREG->grQFREE < size )
#endif

/***************************************************************************
* S T A T I C   V A R I A B L E S
****************************************************************************/

#ifndef WINNT_VER40

ASSERTFILE("blt_dir.c");
#define LL_DRAWBLTDEF(drawbltdef, r)	LL32(grDRAWBLTDEF.DW, drawbltdef)
#define LL_BGCOLOR(color, r)			LL32(grOP_opBGCOLOR.DW, color)
#define LL_FGCOLOR(color, r)			LL32(grOP_opFGCOLOR.DW, color)
#endif

/***************************************************************************
*
* FUNCTION:    DIR_Delay9BitBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_Delay9BitBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,  
#endif
  BOOL        ninebit_on
)
{
  PVGAR   pREG  = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_Delay9BitBlt\r\n"));

  /* This is to ensure that the last packet of any previous blt */
  /* does no go out with 9th bit set incorrectly */
  /* The boolean paramter is the 9th bit of the PREVIOUS BLT */

  REQUIRE(7);
  if (ninebit_on)
  {
    LL_DRAWBLTDEF(((BD_RES * IS_VRAM + BD_OP1 * IS_SOLID) << 16) |
                           (DD_PTAG | ROP_OP1_copy), 0);
  }
  else
  {
    LL_DRAWBLTDEF(((BD_RES * IS_VRAM + BD_OP1 * IS_SOLID) << 16) |
                           (ROP_OP1_copy), 0);
  }
  LL32(grOP0_opRDRAM.DW, lpDDHALData->PTAGFooPixel);
  LL32(grBLTEXT_EX.DW,   MAKELONG(1,1));
} /* DIR_Delay9BitBlt */

/***************************************************************************
*
* FUNCTION:     DIR_EdgeFillBlt
*
* DESCRIPTION:  Solid Fill BLT to fill in edges ( Pixel Coords / Extents )
*
****************************************************************************/

void DIR_EdgeFillBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,  
#endif
  int         xFill,
  int         yFill,
  int         cxFill,
  int         cyFill,
  DWORD       FillValue,
  BOOL        ninebit_on
)
{
  PVGAR   pREG  = (PVGAR) lpDDHALData->RegsAddress;


#ifdef WINNT_VER40
  DISPDBG((DBGLVL, "DIR_EdgeFillBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          MAKELONG(xFill,yFill),MAKELONG(cxFill,cyFill),FillValue));
#endif
  DD_LOG(("DIR_EdgeFillBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          MAKELONG(xFill,yFill),MAKELONG(cxFill,cyFill),FillValue));

  REQUIRE(9);
  if (ninebit_on)
  {
    LL_DRAWBLTDEF(((BD_RES * IS_VRAM + BD_OP1 * IS_SOLID) << 16) |
                           (DD_PTAG | ROP_OP1_copy), 0);
  }
  else
  {
    LL_DRAWBLTDEF(((BD_RES * IS_VRAM + BD_OP1 * IS_SOLID) << 16) |
                           (ROP_OP1_copy), 0);
  }
  LL_BGCOLOR(FillValue, 0);
  LL32(grOP0_opRDRAM.DW,  MAKELONG(xFill,yFill));
  LL32(grBLTEXT_EX.DW,    MAKELONG(cxFill,cyFill));

#ifndef WINNT_VER40
  DBG_MESSAGE((" Direct Edge Fill %d,%d %d x %d %08X %s", xFill, yFill, cxFill, cyFill, FillValue, (ninebit_on ? "TRUE" : "FALSE")));
#endif // WINNT_VER40

} /* DIR_EdgeFillBlt */

/***************************************************************************
*
* FUNCTION:     DIR_MEdgeFillBlt
*
* DESCRIPTION:  Using BYTE BLT coords / Extents perform EdgeFill BLT
*
****************************************************************************/

void DIR_MEdgeFillBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  int         xFill,
  int         yFill,
  int         cxFill,
  int         cyFill,
  DWORD       FillValue,
  BOOL        ninebit_on
)
{
  PVGAR   pREG  = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_MEdgeFillBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          MAKELONG(xFill,yFill),MAKELONG(cxFill,cyFill),FillValue));

  REQUIRE(9);
  if (ninebit_on)
  {
    LL_DRAWBLTDEF(((BD_RES * IS_VRAM + BD_OP1 * IS_SOLID) << 16) |
                           (DD_PTAG | ROP_OP1_copy), 0);
  }
  else
  {
    LL_DRAWBLTDEF(((BD_RES * IS_VRAM + BD_OP1 * IS_SOLID) << 16) |
                           (ROP_OP1_copy), 0);
  }
  LL_BGCOLOR(FillValue, 0);
  LL32(grOP0_opMRDRAM.DW, MAKELONG(xFill,yFill));
  LL32(grMBLTEXT_EX.DW,   MAKELONG(cxFill,cyFill));

#ifndef WINNT_VER40     // Not WINNT_VER40
  DBG_MESSAGE((" (M) Edge Fill %d,%d %d x %d %08X %s", xFill, yFill, cxFill, cyFill, FillValue, (ninebit_on ? "TRUE" : "FALSE")));
#endif // WINNT_VER40

} /* DIR_MEdgeFillBlt */


/***************************************************************************
*
* FUNCTION:     DIR_DrvDstBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_DrvDstBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,  
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvDstBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  REQUIRE(9);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwBgColor, 0);
  LL32(grOP0_opRDRAM.DW,  dwDstCoord);
  LL32(grBLTEXT_EX.DW,    dwExtents);
} /* DIR_DrvDstBlt */

/***************************************************************************
*
* FUNCTION:     DIR_DrvDstMBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_DrvDstMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,  
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvDstMBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  REQUIRE(9);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwBgColor, 0);
  LL32(grOP0_opMRDRAM.DW, dwDstCoord);
  LL32(grMBLTEXT_EX.DW,   dwExtents);
} /* DIR_DrvDstMBlt */

/***************************************************************************
*
* FUNCTION:     DIR_DrvSrcBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_DrvSrcBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;
  // Handle overlapped regions.
  const int xDelta = (int)LOWORD(dwDstCoord) - (int)LOWORD(dwSrcCoord);


  DD_LOG(("DIR_DrvSrcBlt - dst=%08lX src=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwSrcCoord,dwExtents,dwKeyColor));

  // Check for x overlap.
  if ( abs(xDelta) < (int)LOWORD(dwExtents) )
  {
    const int yDelta = (int)HIWORD(dwDstCoord) - (int)HIWORD(dwSrcCoord);

    if ( (yDelta > 0) && (yDelta < (int)HIWORD(dwExtents)) )
    {
      const DWORD dwDelta = (dwExtents & MAKELONG(0, -1)) - MAKELONG(0, 1);

      // Convert to a bottom-up blt.
      dwDrawBlt  |= MAKELONG(0, BD_YDIR);
      dwDstCoord += dwDelta;
      dwSrcCoord += dwDelta;
      dwKeyCoord += dwDelta;
    }
    // are we sliding to the right?
    else if ( (xDelta > 0) && (yDelta == 0) )
    {
      const DWORD dwDelta = MAKELONG(xDelta, 0);

      // Blt the overlapped piece first.
      DIR_DrvSrcBlt(
#ifdef WINNT_VER40
                    ppdev,
#endif
                    lpDDHALData,
                    dwDrawBlt,
                    dwDstCoord+dwDelta,
                    dwSrcCoord+dwDelta,
                    dwKeyCoord+dwDelta,
                    dwKeyColor,
                    dwExtents-dwDelta);

      // Subtract the overlap from the original extents.
      dwExtents = MAKELONG(xDelta, HIWORD(dwExtents));
    }
  }

  // Blt the rest.
  REQUIRE(13);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwKeyColor, 0);
  LL32(grOP0_opRDRAM.DW,  dwDstCoord);
  LL32(grOP1_opRDRAM.DW,  dwSrcCoord);
  LL32(grOP2_opRDRAM.DW,  dwKeyCoord);
  LL32(grBLTEXT_EX.DW,    dwExtents);
} /* DIR_DrvSrcBlt */

/***************************************************************************
*
* FUNCTION:     DIR_DrvSrcMBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_DrvSrcMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;
  // Handle overlapped regions.
  const int xDelta = (int)LOWORD(dwDstCoord) - (int)LOWORD(dwSrcCoord);


  DD_LOG(("DIR_DrvSrcMBlt - dst=%08lX src=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwSrcCoord,dwExtents,dwKeyColor));

  // Check for x overlap.
  if ( abs(xDelta) < (int)LOWORD(dwExtents) )
  {
    const int yDelta = (int)HIWORD(dwDstCoord) - (int)HIWORD(dwSrcCoord);

    if ( (yDelta > 0) && (yDelta < (int)HIWORD(dwExtents)) )
    {
      const DWORD dwDelta = (dwExtents & MAKELONG(0, -1)) - MAKELONG(0, 1);

      // Convert to a bottom-up blt.
      dwDrawBlt  |= MAKELONG(0, BD_YDIR);
      dwDstCoord += dwDelta;
      dwSrcCoord += dwDelta;
      dwKeyCoord += dwDelta;
    }
    // are we sliding to the right?
    else if ( (xDelta > 0) && (yDelta == 0) )
    {
      const DWORD dwDelta = MAKELONG(xDelta, 0);

      // Blt the overlapped piece first.
      DIR_DrvSrcMBlt(
#ifdef WINNT_VER40
                     ppdev,
#endif
                     lpDDHALData,
                     dwDrawBlt,
                     dwDstCoord+dwDelta,
                     dwSrcCoord+dwDelta,
                     dwKeyCoord+dwDelta,
                     dwKeyColor,
                     dwExtents-dwDelta);

      // Subtract the overlap from the original extents.
      dwExtents = MAKELONG(xDelta, HIWORD(dwExtents));
    }
  }

  // Blt the rest.
  REQUIRE(13);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwKeyColor, 0);
  LL32(grOP0_opMRDRAM.DW, dwDstCoord);
  LL32(grOP1_opMRDRAM.DW, dwSrcCoord);
  LL32(grOP2_opMRDRAM.DW, dwKeyCoord);
  LL32(grMBLTEXT_EX.DW,   dwExtents);
} /* DIR_DrvSrcMBlt */

#if 0
/***************************************************************************
*
* FUNCTION:     DIR_DrvStrBlt_OverlapCheck
*
* DESCRIPTION:
*
****************************************************************************/

static void INLINE DIR_DrvStrBlt_OverlapCheck
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  int xdelta,ydelta;


  xdelta = abs(pblt->OP0_opRDRAM.pt.X - pblt->OP1_opRDRAM.pt.X);
  ydelta = abs(pblt->OP0_opRDRAM.pt.Y - pblt->OP1_opRDRAM.pt.Y);

  if ((xdelta < pblt->BLTEXT.pt.X) &&
      (ydelta < pblt->BLTEXT.pt.Y))
  {
    // hack, hack, cough, cough
    // pblt->MBLTEXT.DW has src exents (see DrvStretch)

    // blt the src to the lower right of the dest
    DIR_DrvSrcBlt(
#ifdef WINNT_VER40
                  ppdev,
#endif
                  lpDDHALData,
                  MAKELONG(ROP_OP1_copy, BD_RES * IS_VRAM | BD_OP1 * IS_VRAM),
                  pblt->OP0_opRDRAM.DW + pblt->BLTEXT.DW - pblt->MBLTEXT.DW,
                  pblt->OP1_opRDRAM.DW,
						      0UL,         // don't care
						      0UL,
                  pblt->MBLTEXT.DW);

    // update the src ptr to use this copy of the src
    pblt->OP1_opRDRAM.DW = pblt->OP0_opRDRAM.DW + pblt->BLTEXT.DW - pblt->MBLTEXT.DW;
  }
}
#endif

/***************************************************************************
*
* FUNCTION:     DIR_DrvStrMBlt_OverlapCheck
*
* DESCRIPTION:
*
****************************************************************************/

static void INLINE DIR_DrvStrMBlt_OverlapCheck
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  int xdelta,ydelta;


  xdelta = abs(pblt->OP0_opMRDRAM.pt.X - pblt->OP1_opMRDRAM.pt.X);
  ydelta = abs(pblt->OP0_opMRDRAM.pt.Y - pblt->OP1_opMRDRAM.pt.Y);

  if ((xdelta < pblt->MBLTEXTR_EX.pt.X) &&
      (ydelta < pblt->MBLTEXTR_EX.pt.Y))
  {
    // hack, hack, cough, cough
    // pblt->BLTEXT.DW has src exents (see DrvStretch65)

    // blt the src to the lower right of the dest
    DIR_DrvSrcMBlt(
#ifdef WINNT_VER40
                   ppdev,
#endif
                   lpDDHALData,
                   MAKELONG(ROP_OP1_copy, BD_RES * IS_VRAM | BD_OP1 * IS_VRAM),
                   pblt->OP0_opMRDRAM.DW + pblt->MBLTEXTR_EX.DW - pblt->BLTEXT.DW,
                   pblt->OP1_opMRDRAM.DW,
						       0UL,         // don't care
						       0UL,
                   pblt->BLTEXT.DW);

    // update the src ptr to use this copy of the src
    pblt->OP1_opMRDRAM.DW = pblt->OP0_opMRDRAM.DW + pblt->MBLTEXTR_EX.DW - pblt->BLTEXT.DW;
  }
}

#ifdef WINNT_VER40
/***************************************************************************
*
* FUNCTION:     DIR_DrvStrBlt
*
* DESCRIPTION:  NT version
*
****************************************************************************/

void DIR_DrvStrBlt
(
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
  autoblt_ptr pblt
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvStrBlt - dst=%08lX dstext=%08lX src=%08lX\r\n",
          pblt->OP0_opRDRAM.DW,pblt->BLTEXT.DW,pblt->OP1_opRDRAM.DW));

  if (ppdev->dwLgDevID >= CL_GD5465)
  {
    // check for overlap
    DIR_DrvStrMBlt_OverlapCheck(
#ifdef WINNT_VER40
                                ppdev,lpDDHALData,
#endif
                                pblt);
	REQUIRE(19);
    LL_DRAWBLTDEF(pblt->DRAWBLTDEF.DW, 0);
// hw clipping currently not used
//    LL32(grCLIPULE.DW,      pblt->CLIPULE.DW);
//    LL32(grCLIPLOR.DW,      pblt->CLIPLOR.DW);
    LL16(grSRCX,            pblt->SRCX);
    LL16(grSHRINKINC.W,     pblt->SHRINKINC.W);
    LL16(grMIN_X,           pblt->MIN_X);
    LL16(grMAJ_X,           pblt->MAJ_X);
#if 0
    LL16(grACCUM_X,         pblt->ACCUM_X);
#else
    // workaround for hw bug when writing to ACCUM_X
    // writing LNCNTL changes STRETCH_CNTL so write
    // STRETCH_CNTL after this
    *(DWORD *)((BYTE *)(pREG)+0x50C) = MAKELONG(pblt->ACCUM_X,0);
    LG_LOG(0x50C,MAKELONG(pblt->ACCUM_X,0));
#endif
    LL16(grSTRETCH_CNTL.W,  pblt->STRETCH_CNTL.W);
    LL16(grMAJ_Y,           pblt->MAJ_Y);
    LL16(grMIN_Y,           pblt->MIN_Y);
    LL16(grACCUM_Y,         pblt->ACCUM_Y);
    LL32(grOP0_opMRDRAM.DW, pblt->OP0_opMRDRAM.DW);
    LL32(grOP1_opMRDRAM.DW, pblt->OP1_opMRDRAM.DW);

    LL32(grMBLTEXTR_EX.DW, pblt->MBLTEXTR_EX.DW);
  }
  else
  {
#if 0
#pragma message("This needs to be checked out on 62/64")
    // check for overlap
    DIR_DrvStrBlt_OverlapCheck(
#ifdef WINNT_VER40
                               ppdev,lpDDHALData,
#endif
                               pblt);
#endif

	REQUIRE(18);
    LL16(grLNCNTL.W,       pblt->LNCNTL.W);
    LL16(grSHRINKINC.W,    pblt->SHRINKINC.W);
    LL16(grSRCX,           pblt->SRCX);
    LL16(grMAJ_X,          pblt->MAJ_X);
    LL16(grMIN_X,          pblt->MIN_X);
    LL16(grACCUM_X,        pblt->ACCUM_X);
    LL16(grMAJ_Y,          pblt->MAJ_Y);
    LL16(grMIN_Y,          pblt->MIN_Y);
    LL16(grACCUM_Y,        pblt->ACCUM_Y);
    LL32(grOP0_opRDRAM.DW, pblt->OP0_opRDRAM.DW);
    LL32(grOP1_opRDRAM.DW, pblt->OP1_opRDRAM.DW);
    LL_DRAWBLTDEF(pblt->DRAWBLTDEF.DW, 0);
    LL32(grBLTEXTR_EX.DW,  pblt->BLTEXT.DW);
  }   // endif (ppdev->dwLgDevID >= CL_GD5465)
} /* DIR_DrvStrBlt */
#endif

#ifndef WINNT_VER40
/***************************************************************************
*
* FUNCTION:     DIR_DrvStrBlt
*
* DESCRIPTION:  Win95 62/64 version
*
****************************************************************************/

void DIR_DrvStrBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvStrBlt - dst=%08lX dstext=%08lX src=%08lX\r\n",
          pblt->OP0_opRDRAM.DW,pblt->BLTEXT.DW,pblt->OP1_opRDRAM.DW));

#if 0
#pragma message("This needs to be checked out on 62/64")
  // check for overlap
  DIR_DrvStrBlt_OverlapCheck(
#ifdef WINNT_VER40
                             ppdev,
#endif
                             lpDDHALData,
                             pblt);
#endif

  REQUIRE(18);
  LL16(grLNCNTL.W,       pblt->LNCNTL.W);
  LL16(grSHRINKINC.W,    pblt->SHRINKINC.W);
  LL16(grSRCX,           pblt->SRCX);
  LL16(grMAJ_X,          pblt->MAJ_X);
  LL16(grMIN_X,          pblt->MIN_X);
  LL16(grACCUM_X,        pblt->ACCUM_X);
  LL16(grMAJ_Y,          pblt->MAJ_Y);
  LL16(grMIN_Y,          pblt->MIN_Y);
  LL16(grACCUM_Y,        pblt->ACCUM_Y);
  LL32(grOP0_opRDRAM.DW, pblt->OP0_opRDRAM.DW);
  LL32(grOP1_opRDRAM.DW, pblt->OP1_opRDRAM.DW);
  LL_DRAWBLTDEF(pblt->DRAWBLTDEF.DW, 0);
  LL32(grBLTEXTR_EX.DW,  pblt->BLTEXT.DW);
} /* DIR_DrvStrBlt */

/***************************************************************************
*
* FUNCTION:     DIR_DrvStrBlt65
*
* DESCRIPTION:  Win95 65+ version
*
****************************************************************************/

void DIR_DrvStrBlt65
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
   LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvStrBlt65 - dst=%08lX dstext=%08lX src=%08lX\r\n",
          pblt->OP0_opMRDRAM.DW,pblt->MBLTEXT.DW,pblt->OP1_opMRDRAM.DW));

  // check for overlap
  DIR_DrvStrMBlt_OverlapCheck(
#ifdef WINNT_VER40
                              ppdev,
#endif
                              lpDDHALData,
                              pblt);

  REQUIRE(19);
  LL_DRAWBLTDEF(pblt->DRAWBLTDEF.DW, 0);
  LL16(grSRCX,            pblt->SRCX);
  LL16(grSHRINKINC.W,     pblt->SHRINKINC.W);
  LL16(grMIN_X,           pblt->MIN_X);
  LL16(grMAJ_X,           pblt->MAJ_X);
#if 0
  LL16(grACCUM_X,         pblt->ACCUM_X);
#else
  // workaround for hw bug when writing to ACCUM_X
  // writing LNCNTL changes STRETCH_CNTL so write
  // STRETCH_CNTL after this
  *(DWORD *)((BYTE *)(pREG)+0x50C) = MAKELONG(pblt->ACCUM_X,0);
  LG_LOG(0x50C,MAKELONG(pblt->ACCUM_X,0));
#endif
  LL16(grSTRETCH_CNTL.W,  pblt->STRETCH_CNTL.W);
  LL16(grMAJ_Y,           pblt->MAJ_Y);
  LL16(grMIN_Y,           pblt->MIN_Y);
  LL16(grACCUM_Y,         pblt->ACCUM_Y);
  LL32(grOP0_opMRDRAM.DW, pblt->OP0_opMRDRAM.DW);
  LL32(grOP1_opMRDRAM.DW, pblt->OP1_opMRDRAM.DW);

	LL32(grMBLTEXTR_EX.DW, pblt->MBLTEXTR_EX.DW);
} /* DIR_DrvStrBlt65 */
#endif

/***************************************************************************
*
* FUNCTION:     DIR_DrvStrMBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_DrvStrMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
   LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvStrMBlt - dst=%08lX dstext=%08lX src=%08lX\r\n",
          pblt->OP0_opRDRAM.DW,pblt->BLTEXT.DW,pblt->OP1_opRDRAM.DW));

#ifndef WINNT_VER40

  /* Check for a zero extent blt */

  if ((pblt->BLTEXT.pt.X == 0) || (pblt->BLTEXT.pt.Y == 0))
    return;

  DBG_MESSAGE(("DIR_DrvStrMBlt:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
  APRINTF(("DIR_DrvStrMBlt:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
           pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
           pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
           pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
           pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
#endif //!WINNT_VER40

  REQUIRE(18);
  LL16(grLNCNTL.W,        pblt->LNCNTL.W);
  LL16(grSHRINKINC.W,     pblt->SHRINKINC.W);
  LL16(grSRCX,            pblt->SRCX);
  LL16(grMAJ_X,           pblt->MAJ_X);
  LL16(grMIN_X,           pblt->MIN_X);
  LL16(grACCUM_X,         pblt->ACCUM_X);
  LL16(grMAJ_Y,           pblt->MAJ_Y);
  LL16(grMIN_Y,           pblt->MIN_Y);
  LL16(grACCUM_Y,         pblt->ACCUM_Y);
  LL32(grOP0_opMRDRAM.DW, pblt->OP0_opRDRAM.DW);
  LL32(grOP1_opMRDRAM.DW, pblt->OP1_opRDRAM.DW);
  LL_DRAWBLTDEF(pblt->DRAWBLTDEF.DW, 0);

#ifndef WINNT_VER40
  // MBLTEXTR_EX.pt.Y is broken in the 5464.
  // We can use BLTEXTR_EX.pt.Y instead.
  //pREG->grMBLTEXTR_EX  = pblt->BLTEXT;

  LL16(grMBLTEXTR_EX.pt.X, pblt->BLTEXT.pt.X);
  LL16(grBLTEXTR_EX.pt.Y,  pblt->BLTEXT.pt.Y);
#else
  LL32(grMBLTEXTR_EX.DW, pblt->BLTEXT.DW);
#endif
} /* DIR_DrvStrMBlt */

/***************************************************************************
*
* FUNCTION:     DIR_DrvStrMBltY
*
* DESCRIPTION:  Write regs that don't vary over the stripes
*               Used in conjunction with DIR_DrvStrMBltX
*
****************************************************************************/

void DIR_DrvStrMBltY
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvStrMBltY - dst.Y=%04X dstext.Y=%04X src=%04X\r\n",
          pblt->OP0_opRDRAM.pt.Y,pblt->BLTEXT.pt.Y,pblt->OP1_opRDRAM.pt.Y));

#ifndef WINNT_VER40

  /* Check for a zero extent */

  if (pblt->BLTEXT.pt.Y == 0)
    return;

  DBG_MESSAGE(("DIR_DrvStrMBltY:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
  APRINTF(("DIR_DrvStrMBltY:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
           pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
           pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
           pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
           pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
#endif  //!WINNT_VER40

  REQUIRE(12);
  LL16(grLNCNTL.W,          pblt->LNCNTL.W);
  LL16(grSHRINKINC.W,       pblt->SHRINKINC.W);
  LL16(grMAJ_X,             pblt->MAJ_X);
  LL16(grMIN_X,             pblt->MIN_X);
  LL16(grMAJ_Y,             pblt->MAJ_Y);
  LL16(grMIN_Y,             pblt->MIN_Y);
  LL16(grACCUM_Y,           pblt->ACCUM_Y);
  LL16(grOP0_opMRDRAM.pt.Y, pblt->OP0_opRDRAM.pt.Y);
  LL16(grOP1_opMRDRAM.pt.Y, pblt->OP1_opRDRAM.pt.Y);
  LL_DRAWBLTDEF(pblt->DRAWBLTDEF.DW, 0);
  LL16(grMBLTEXTR_XEX.pt.Y, pblt->BLTEXT.pt.Y);
} /* DIR_DrvStrMBltY */

/***************************************************************************
*
* FUNCTION:     DrvStrMBltX
*
* DESCRIPTION:  Write stripe specific regs
*               Used in conjunction with DIR_DrvStrMBltY
*
****************************************************************************/

void DIR_DrvStrMBltX
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvStrMBltX - dst.X=%04X dstext.X=%04X src.X=%04X\r\n",
          pblt->OP0_opRDRAM.pt.X,pblt->BLTEXT.pt.X,pblt->OP1_opRDRAM.pt.X));

#ifndef WINNT_VER40

  /* Check for a zero extent */

  if (pblt->BLTEXT.pt.X == 0)
    return;

  DBG_MESSAGE(("DIR_DrvStrMBltX:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
  APRINTF(("DIR_DrvStrMBltX:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
           pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
           pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
           pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
           pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
#endif //!WINNT_VER40

  REQUIRE(6);
  LL16(grSRCX,              pblt->SRCX);
  LL16(grACCUM_X,           pblt->ACCUM_X);
  LL16(grOP0_opMRDRAM.pt.X, pblt->OP0_opRDRAM.pt.X);
  LL16(grOP1_opMRDRAM.pt.X, pblt->OP1_opRDRAM.pt.X);
  LL16(grMBLTEXTR_XEX.pt.X, pblt->BLTEXT.pt.X);
} /* DIR_DrvStrMBltX */

/***************************************************************************
*
* FUNCTION:     DIR_DrvStrBltY
*
* DESCRIPTION:  Write regs that don't vary over the stripes
*               Used in conjunction with DIR_DrvStrBltX
*
****************************************************************************/

void DIR_DrvStrBltY
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvStrBltY\r\n"));

#ifndef WINNT_VER40

  /* Check for a zero extent */

  if (pblt->BLTEXT.pt.Y == 0)
    return;

  DBG_MESSAGE(("DIR_DrvStrBltY:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
  APRINTF(("DIR_DrvStrBltY:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
           pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
           pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
           pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
           pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
#endif //!WINNT_VER40

  REQUIRE(10);
  LL16(grLNCNTL.W,      pblt->LNCNTL.W);
  LL16(grSHRINKINC.W,   pblt->SHRINKINC.W);
  LL16(grSRCX,          pblt->SRCX);
  LL16(grMAJ_X,         pblt->MAJ_X);
  LL16(grMIN_X,         pblt->MIN_X);
  LL16(grMAJ_Y,         pblt->MAJ_Y);
  LL16(grMIN_Y,         pblt->MIN_Y);
  LL16(grACCUM_Y,       pblt->ACCUM_Y);
  LL_DRAWBLTDEF(pblt->DRAWBLTDEF.DW, 0);
} /* DIR_DrvStrBltY */

/***************************************************************************
*
* FUNCTION:     DIR_DrvStrBltX
*
* DESCRIPTION:  Write stripe specific regs
*               Used in conjunction with DIR_DrvStrMBltY
*
****************************************************************************/

void DIR_DrvStrBltX
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvStrBltX - dst=%08lX dstext=%08lX src=%08lX\r\n",
          pblt->OP0_opRDRAM.DW,pblt->BLTEXT.DW,pblt->OP1_opRDRAM.DW));

#ifndef WINNT_VER40

  /* Check for a zero extent */

  if (pblt->BLTEXT.pt.X == 0)
    return;

  DBG_MESSAGE(("DIR_DrvStrMBltX:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
  APRINTF(("DIR_DrvStrMBltX:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
           pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
           pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
           pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
           pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
#endif //!WINNT_VER40

  REQUIRE(8);
  LL16(grACCUM_X,        pblt->ACCUM_X);
  LL32(grOP0_opRDRAM.DW, pblt->OP0_opRDRAM.DW);
  LL32(grOP1_opRDRAM.DW, pblt->OP1_opRDRAM.DW);
  LL32(grBLTEXTR_EX.DW,  pblt->BLTEXT.DW);
} /* DIR_DrvStrBltX */

#if ENABLE_CLIPPEDBLTS

/***************************************************************************
*
* FUNCTION:     DIR_HWClippedDrvDstBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_HWClippedDrvDstBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,  
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_HWClippedDrvDstBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  // check for negative dst coordinates, hw can't deal with negative OP0 values
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.X)
  {
    (short)((REG32 *)&dwExtents)->pt.X += (short)((REG32 *)&dwDstCoord)->pt.X;
    ((REG32 *)&dwDstCoord)->pt.X = 0;
  }
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.Y)
  {
    (short)((REG32 *)&dwExtents)->pt.Y += (short)((REG32 *)&dwDstCoord)->pt.Y;
    ((REG32 *)&dwDstCoord)->pt.Y = 0;
  }

  // setup blt, write BLTEXT reg with extent which doesn't fire off blt
  REQUIRE(8);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwBgColor, 0);
  LL32(grOP0_opRDRAM.DW,  dwDstCoord);
  LL32(grBLTEXT.DW,       dwExtents);

  // loop over clip list
  do
  {
    REG32   UpperLeft;
    REG32   LowerRight;

    // compute cliprect coords
    UpperLeft.DW  = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    LowerRight.DW = dwDstBaseXY + MAKELONG(pDestRects->right, pDestRects->bottom);

    // write clipping regs
    REQUIRE(5);
    LL32(grCLIPULE.DW, UpperLeft.DW);
    LL32(grCLIPLOR_EX.DW, LowerRight.DW);

    pDestRects++;
  } while (0 < --dwRectCnt);
} /* DIR_HWClippedDrvDstBlt */

/***************************************************************************
*
* FUNCTION:     DIR_HWClippedDrvDstMBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_HWClippedDrvDstMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBLDATA   lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
  const int nBytesPixel = BYTESPERPIXEL;
  PVGAR     pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_HWClippedDrvDstMBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  // check for negative dst coordinates, hw can't deal with negative OP0 values
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.X)
  {
    (short)((REG32 *)&dwExtents)->pt.X += (short)((REG32 *)&dwDstCoord)->pt.X;
    ((REG32 *)&dwDstCoord)->pt.X = 0;
  }
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.Y)
  {
    (short)((REG32 *)&dwExtents)->pt.Y += (short)((REG32 *)&dwDstCoord)->pt.Y;
    ((REG32 *)&dwDstCoord)->pt.Y = 0;
  }

  // setup blt, write MBLTEXT reg with extent which doesn't fire off blt
  REQUIRE(8);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwBgColor, 0);
  LL32(grOP0_opMRDRAM.DW, dwDstCoord);
  LL32(grMBLTEXT.DW,      dwExtents);

  // loop over clip list
  do
  {
    REG32   UpperLeft;
    REG32   LowerRight;

    // compute cliprect coords
    UpperLeft.DW  = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    LowerRight.DW = dwDstBaseXY + MAKELONG(pDestRects->right, pDestRects->bottom);
    UpperLeft.pt.X  *= nBytesPixel;
    LowerRight.pt.X *= nBytesPixel;

    // write clipping regs
    REQUIRE(5);
    LL32(grMCLIPULE.DW, UpperLeft.DW);
    LL32(grMCLIPLOR_EX.DW, LowerRight.DW);

    pDestRects++;
  } while (0 < --dwRectCnt);
} /* DIR_HWClippedDrvDstMBlt */

/***************************************************************************
*
* FUNCTION:     DIR_HWClippedDrvSrcBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_HWClippedDrvSrcBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwSrcBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;
  // Handle overlapped regions
  const int xDelta = (int)LOWORD(dwDstCoord) - (int)LOWORD(dwSrcCoord);


  DD_LOG(("DIR_HWClippedDrvSrcBlt - dst=%08lX src=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwSrcCoord,dwExtents,dwKeyColor));

  // check for negative dst coordinates, hw can't deal with negative OP0 values
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.X)
  {
    // reduce extent.X
    (short)((REG32 *)&dwExtents)->pt.X += (short)((REG32 *)&dwDstCoord)->pt.X;
    // bump src.X to right
    (short)((REG32 *)&dwSrcCoord)->pt.X -= (short)((REG32 *)&dwDstCoord)->pt.X;
    if ((DD_TRANS | DD_TRANSOP) & dwDrawBlt)
      // bump key.X to right
      (short)((REG32 *)&dwKeyCoord)->pt.X -= (short)((REG32 *)&dwKeyCoord)->pt.X;
    // clear dst.X
    ((REG32 *)&dwDstCoord)->pt.X = 0;
  }
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.Y)
  {
    // reduce extent.Y
    (short)((REG32 *)&dwExtents)->pt.Y += (short)((REG32 *)&dwDstCoord)->pt.Y;
    // bump src.Y down
    (short)((REG32 *)&dwSrcCoord)->pt.Y -= (short)((REG32 *)&dwDstCoord)->pt.Y;
    if ((DD_TRANS | DD_TRANSOP) & dwDrawBlt)
      // bump key.Y down
      (short)((REG32 *)&dwKeyCoord)->pt.Y -= (short)((REG32 *)&dwKeyCoord)->pt.Y;
    // clear dst.Y
    ((REG32 *)&dwDstCoord)->pt.Y = 0;
  }

  // Check for x overlap
  if ( abs(xDelta) < (int)LOWORD(dwExtents) )
  {
    const int yDelta = (int)HIWORD(dwDstCoord) - (int)HIWORD(dwSrcCoord);

    if ( (yDelta > 0) && (yDelta < (int)HIWORD(dwExtents)) )
    {
      const DWORD dwDelta = (dwExtents & MAKELONG(0, -1)) - MAKELONG(0, 1);

      // Convert to a bottom-up blt.
      dwDrawBlt  |= MAKELONG(0, BD_YDIR);
      dwDstCoord += dwDelta;
      dwSrcCoord += dwDelta;
      dwKeyCoord += dwDelta;
    }
    // are we sliding to the right?
    else if ( (xDelta > 0) && (yDelta == 0) )
    {
      const DWORD dwDelta = MAKELONG(xDelta, 0);

      // Blt the overlapped piece first
      DIR_HWClippedDrvSrcBlt(
#ifdef WINNT_VER40
                             ppdev,
#endif
                             lpDDHALData,
                             dwDrawBlt,
                             dwDstCoord+dwDelta,
                             dwSrcCoord+dwDelta,
                             dwKeyCoord+dwDelta,
                             dwKeyColor,
                             dwExtents-dwDelta,
                             dwDstBaseXY,
                             dwSrcBaseXY,
                             dwRectCnt,
                             pDestRects);

      // Subtract the overlap from the original extents.
      dwExtents = MAKELONG(xDelta, HIWORD(dwExtents));
    }
  }

  // setup blt, write BLTEXT reg with extent which doesn't fire off blt
  REQUIER(12);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwKeyColor, 0);
  LL32(grOP0_opRDRAM.DW,  dwDstCoord);
  LL32(grOP1_opRDRAM.DW,  dwSrcCoord);
  LL32(grOP2_opRDRAM.DW,  dwKeyCoord);
  LL32(grBLTEXT.DW,       dwExtents);

  // loop over clip list
  do
  {
    REG32   UpperLeft;
    REG32   LowerRight;

    // compute cliprect coords
    UpperLeft.DW  = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    LowerRight.DW = dwDstBaseXY + MAKELONG(pDestRects->right, pDestRects->bottom);

    // write clipping regs
    REQUIRE(5);
    LL32(grCLIPULE.DW, UpperLeft.DW);
    LL32(grCLIPLOR_EX.DW, LowerRight.DW);

    pDestRects++;
  } while (0 < --dwRectCnt);
} /* DIR_HWClippedDrvSrcBlt */

/***************************************************************************
*
* FUNCTION:     DIR_SWClippedDrvDstBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_SWClippedDrvDstBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_SWClippedDrvDstBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  // make sure DD_CLIP isn't set in drawdef
  dwDrawBlt &= ~DD_CLIP;

  // write regs that don't vary over rectangles
  REQUIRE(4);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwBgColor, 0);

  // loop over clip list
  do
  {
    DDRECTL   DstDDRect;

    // compute cliprect coords
    DstDDRect.loc.DW = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    DstDDRect.ext.pt.X = (WORD)(pDestRects->right - pDestRects->left);
    DstDDRect.ext.pt.Y = (WORD)(pDestRects->bottom - pDestRects->top);

    // write OP0 and bltext regs
    REQUIRE(5);
    LL32(grOP0_opRDRAM.DW, DstDDRect.loc.DW);
    LL32(grBLTEXT_EX.DW,   DstDDRect.ext.DW);

    pDestRects++;
  } while (0 < --dwRectCnt);
} /* DIR_SWClippedDrvDstBlt */

/***************************************************************************
*
* FUNCTION:     DIR_SWClippedDrvDstMBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_SWClippedDrvDstMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBLADATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
  const int nBytesPixel = BYTESPERPIXEL;
  PVGAR     pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_SWClippedDrvDstMBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  // make sure DD_CLIP isn't set in drawdef
  dwDrawBlt &= ~DD_CLIP;

  // write regs that don't vary over rectangles
  REQUIRE(4);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwBgColor, 0);

  // loop over clip list
  do
  {
    DDRECTL   DstDDRect;

    // compute cliprect coords
    DstDDRect.loc.DW = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    DstDDRect.loc.pt.X *= nBytesPixel;
    DstDDRect.ext.pt.X = (WORD)(pDestRects->right - pDestRects->left) * nBytesPixel;
    DstDDRect.ext.pt.Y = (WORD)(pDestRects->bottom - pDestRects->top);

    // write OP0 and bltext regs
    REQUIRE(5);
    LL32(grOP0_opMRDRAM.DW, DstDDRect.loc.DW);
    LL32(grMBLTEXT_EX.DW,   DstDDRect.ext.DW);

    pDestRects++;
  } while (0 < --dwRectCnt);
} /* DIR_SWClippedDrvDstMBlt */

/***************************************************************************
*
* FUNCTION:     DIR_SWClippedDrvSrcBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_SWClippedDrvSrcBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwSrcBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;
  // Handle overlapped regions
  const int xDelta = (int)LOWORD(dwDstCoord) - (int)LOWORD(dwSrcCoord);


  DD_LOG(("DIR_SWClippedDrvSrcBlt - dst=%08lX src=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwSrcCoord,dwExtents,dwKeyColor));

  // make sure DD_CLIP isn't set in drawdef
  dwDrawBlt &= ~DD_CLIP;

  // Check for x overlap
  if ( abs(xDelta) < (int)LOWORD(dwExtents) )
  {
    const int yDelta = (int)HIWORD(dwDstCoord) - (int)HIWORD(dwSrcCoord);

    if ( (yDelta > 0) && (yDelta < (int)HIWORD(dwExtents)) )
    {
      const DWORD dwDelta = (dwExtents & MAKELONG(0, -1)) - MAKELONG(0, 1);

      // Convert to a bottom-up blt.
      dwDrawBlt  |= MAKELONG(0, BD_YDIR);
      dwDstCoord += dwDelta;
      dwSrcCoord += dwDelta;
      dwKeyCoord += dwDelta;
    }
    // are we sliding to the right?
    else if ( (xDelta > 0) && (yDelta == 0) )
    {
      const DWORD dwDelta = MAKELONG(xDelta, 0);

      // Blt the overlapped piece first
      DIR_SWClippedDrvSrcBlt(
#ifdef WINNT_VER40
                             ppdev,
#endif
                             lpDDHALData,
                             dwDrawBlt,
                             dwDstCoord+dwDelta,
                             dwSrcCoord+dwDelta,
                             dwKeyCoord+dwDelta,
                             dwKeyColor,
                             dwExtents-dwDelta,
                             dwDstBaseXY,
                             dwSrcBaseXY,
                             dwRectCnt,
                             pDestRects);

      // Subtract the overlap from the original extents.
      dwExtents = MAKELONG(xDelta, HIWORD(dwExtents));
    }
  }

  // write regs that don't vary over rectangles
  REQUIRE(4);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwKeyColor, 0);

  // loop over clip list
  do
  {
    DDRECTL   DstDDRect;
    DDRECTL   SrcDDRect;

    // compute dst cliprect coords
    DstDDRect.loc.DW = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    DstDDRect.ext.pt.X = (WORD)(pDestRects->right - pDestRects->left);
    DstDDRect.ext.pt.Y = (WORD)(pDestRects->bottom - pDestRects->top);

    // compute src cliprect coords
    SrcDDRect.loc.DW = dwSrcBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    // don't care about src extent, it's the same as dst extent
    //SrcDDRect.ext.pt.X = (WORD)(pDestRects->right - pDestRects->left);
    //SrcDDRect.ext.pt.Y = (WORD)(pDestRects->bottom - pDestRects->top);

    // write OP0, OP1, OP2 and bltext regs
    if ((DD_TRANS | DD_TRANSOP) == ((DD_TRANS | DD_TRANSOP) & dwDrawBlt))
    {
      // dst color key
      REQUIRE(9);
      LL32(grOP2_opRDRAM.DW, DstDDRect.loc.DW);
    }
    else if (DD_TRANS == ((DD_TRANS | DD_TRANSOP) & dwDrawBlt))
    {
      // src color key
      REQUIRE(9);
      LL32(grOP2_opRDRAM.DW, SrcDDRect.loc.DW);
    }
    else
    {
      REQUIRE(7);
      //LL32(grOP2_opRDRAM.DW, 0);
    }
    LL32(grOP0_opRDRAM.DW, DstDDRect.loc.DW);
    LL32(grOP1_opRDRAM.DW, SrcDDRect.loc.DW);
    LL32(grBLTEXT_EX.DW,   DstDDRect.ext.DW);

    pDestRects++;
  } while (0 < --dwRectCnt);
} /* DIR_SWClippedDrvSrcBlt */

#endif  // ENABLE_CLIPPEDBLTS

#endif // WINNT_VER35
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\bitblt.c ===
/******************************************************************************
* Module Name: BITBLT.c
* Author: Noel VanHook
* Purpose: Handle calls to DrvBitBlt
*
* Copyright (c) 1995,1996 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/BITBLT.C  $
* 
*    Rev 1.45   Mar 04 1998 15:11:56   frido
* Added new shadow macros.
* 
*    Rev 1.44   Feb 24 1998 13:24:40   frido
* Removed some warning messages for NT 5.0 build.
* 
*    Rev 1.43   Jan 22 1998 18:15:58   frido
* Revised the pattern blit filter for Access again.
* 
*    Rev 1.42   Jan 21 1998 17:33:56   frido
* Revised the 24-bpp filter for Access & Excel.
* 
*    Rev 1.41   Jan 20 1998 11:43:56   frido
* Added a filter for 24-bpp PatBlt.
*
*    Rev 1.40   Nov 03 1997 11:35:48   frido
* Added REQUIRE macros.
*
*    Rev 1.39   18 Aug 1997 09:24:04   FRIDO
*
* Changed all SWAT5 labels into MEMMGR (I forgot that during the merge).
* Added dynamic bitmap filter, borrowed from Windows 95.
*
*    Rev 1.38   29 May 1997 10:59:24   noelv
*
* Frido's fix for 9773
* SWAT:
* SWAT:    Rev 1.12   29 May 1997 12:12:20   frido
* SWAT: Changed striping code from 16-bit to 32-bit.
* SWAT:
* SWAT:    Rev 1.10   09 May 1997 12:57:30   frido
* SWAT: Added support for new memory manager.
*
*    Rev 1.37   29 Apr 1997 16:28:12   noelv
*
* Merged in new SWAT code.
* SWAT:
* SWAT:    Rev 1.9   24 Apr 1997 11:45:54   frido
* SWAT: NT140b09 merge.
* SWAT: Revised comments.
* SWAT:
* SWAT:    Rev 1.8   19 Apr 1997 16:42:30   frido
* SWAT: Added SWAT.h include file.
* SWAT:
* SWAT:    Rev 1.7   18 Apr 1997 00:14:58   frido
* SWAT: NT140b07 merge.
* SWAT:
* SWAT:    Rev 1.6   15 Apr 1997 19:13:34   frido
* SWAT: Added SWAT6: striping in PatBlt.
* SWAT:
* SWAT:    Rev 1.5   14 Apr 1997 15:30:12   frido
* SWAT: Enabled SWAT5 (new bitmap allocation scheme).
* SWAT:
* SWAT:    Rev 1.4   10 Apr 1997 17:37:12   frido
* SWAT: Started work on SWAT5 optimizations.
* SWAT:
* SWAT:    Rev 1.3   09 Apr 1997 20:24:18   frido
* SWAT: Revised SWAT1 once again.
* SWAT:
* SWAT:    Rev 1.2   09 Apr 1997 17:36:48   frido
* SWAT: Changed SWAT1 pre-allocation scheme.
* SWAT: Added SWAT1 and SWAT2 switches.
* SWAT:
* SWAT:    Rev 1.1   07 Apr 1997 17:48:06   frido
* SWAT: SWAT1: Added heap pre-allocation during WB97 pause.
*
*    Rev 1.36   08 Apr 1997 11:52:46   einkauf
*
* add SYNC_W_3D to coordination MCD and 2D hw access
*
*    Rev 1.35   21 Mar 1997 10:52:58   noelv
* Combined do_flag and sw_test_flag together into 'pointer_switch'.
*
*    Rev 1.34   04 Feb 1997 10:34:18   SueS
* Added support for hardware clipping for the 5465.
*
*    Rev 1.33   23 Jan 1997 11:03:18   noelv
*
* PuntBitBlt now handles device bitmaps stored on the host.
* bCreateScreenFromDIB now checks the return code from host to screen operati
*
*    Rev 1.32   17 Dec 1996 16:57:04   SueS
* Reject bitmaps of 32x64 or smaller.  This is based on WinBench97
* optimization.  Reject bitmaps that are larger than the visible screen
* width.  Added some things to log file writes.
*
*    Rev 1.31   27 Nov 1996 11:32:46   noelv
* Disabled Magic Bitmap.  Yeah!!!
*
*    Rev 1.30   26 Nov 1996 10:48:40   SueS
* Changed WriteLogFile parameters for buffering.
*
*    Rev 1.29   13 Nov 1996 17:05:12   SueS
* Changed WriteFile calls to WriteLogFile.
*
*    Rev 1.28   07 Nov 1996 16:07:08   bennyn
*
* Added no offscn mem allocation if DD enabled
*
*    Rev 1.27   18 Sep 1996 13:49:04   noelv
* Opps.  Forgot to unhook STROKEANDFILLPATH.
*
*    Rev 1.26   12 Sep 1996 09:18:42   noelv
* Fixed bug in infinite offscreen memory.
*
*    Rev 1.25   06 Sep 1996 09:03:54   noelv
*
* Cleaned up NULL driver code.
*
*    Rev 1.24   20 Aug 1996 11:03:10   noelv
* Bugfix release from Frido 8-19-96
*
*    Rev 1.3   18 Aug 1996 22:48:42   frido
* #lineto - Added DrvLineTo.
*
*    Rev 1.2   17 Aug 1996 19:35:36   frido
* Cleaned source.
* Changed ScreenToMemory bitblt.
*
*    Rev 1.1   15 Aug 1996 11:45:32   frido
* Added precompiled header.
*
*    Rev 1.0   14 Aug 1996 17:16:14   frido
* Initial revision.
*
*    Rev 1.23   07 Aug 1996 09:04:00   noelv
* Sync before punting.
*
*    Rev 1.22   11 Jul 1996 15:52:30   bennyn
* Changed constant 400 and 90 to #define variables
*
*    Rev 1.21   04 Jun 1996 15:56:32   noelv
* Debug code.
*
*    Rev 1.20   28 May 1996 15:11:02   noelv
* Updated data logging.
*
*    Rev 1.19   16 May 1996 15:05:54   bennyn
* Added PIXEL_ALIGN to allocoffscnmem()
*
*    Rev 1.18   16 May 1996 14:54:10   noelv
* Added logging code.
*
*    Rev 1.17   08 May 1996 17:02:46   noelv
*
* Preallocate device bitmap
*
*    Rev 1.16   03 May 1996 14:41:42   noelv
* Modified device bitmap allocation scheme.
*
*    Rev 1.15   01 May 1996 10:57:28   bennyn
*
* Modified for NT4.0
*
*    Rev 1.14   29 Apr 1996 14:16:20   noelv
* Clean up.
*
*    Rev 1.13   10 Apr 1996 14:13:52   NOELV
* Frido release 27
 *
 *    Rev 1.22   08 Apr 1996 16:47:44   frido
 * Added PuntBitBlt.
 *
 *    Rev 1.21   27 Mar 1996 13:06:58   frido
 * Added check for destination in ROP.
 * Masked color expansions.
 * Added return value to clipping routine.
 *
 *    Rev 1.20   25 Mar 1996 11:52:30   frido
 * Bellevue 102B03.
*
*    Rev 1.9   20 Mar 1996 14:17:30   bennyn
*
*    Rev 1.8   18 Mar 1996 11:42:30   noelv
* Added data loggin stuff.  Code cleanup.
*
*    Rev 1.7   13 Mar 1996 13:21:04   noelv
* Cleanup, documentation, and data logging.
*
*    Rev 1.6   12 Mar 1996 15:43:36   noelv
* Added data logging.
* Cleanup.
*
*    Rev 1.5   12 Mar 1996 11:17:48   noelv
* Code cleanup
*
*    Rev 1.4   08 Mar 1996 11:08:50   noelv
* Code cleanup and comments
*
*    Rev 1.3   05 Mar 1996 11:57:28   noelv
* Frido version 19
*
*    Rev 1.15   04 Mar 1996 20:21:44   frido
* Removed check for monochrome source and brush.
*
*    Rev 1.14   01 Mar 1996 17:47:58   frido
* Added check for destination in BLTDEF.
*
*    Rev 1.13   29 Feb 1996 20:17:32   frido
* Added test for special size device bitmaps.
* Check for bEnable in CreateScreenFromDib.
*
*    Rev 1.12   28 Feb 1996 22:37:12   frido
* Added Optimize.h.
* Added check for brushes with monochrome source.
*
*    Rev 1.11   27 Feb 1996 16:38:04   frido
* Added device bitmap store/restore.
*
*    Rev 1.10   26 Feb 1996 23:37:32   frido
* Fixed several bugs.
*
*    Rev 1.9   24 Feb 1996 01:25:12   frido
* Added device bitmaps.
* Removed old BitBlt code.
*
*    Rev 1.8   10 Feb 1996 21:39:28   frido
* Used SetBrush again for PatternBLT.
*
*    Rev 1.7   08 Feb 1996 00:19:50   frido
* Changed the interpretation of cache_slot.
*
*    Rev 1.6   05 Feb 1996 17:35:58   frido
* Added translation cache.
*
*    Rev 1.5   03 Feb 1996 13:58:28   frido
* Use the compile switch "-Dfrido=0" to disable my extensions.
*
*    Rev 1.4   31 Jan 1996 12:57:50   frido
* Called EngBitBlt in case of error.
* Changed clipping algorithmns.
*
*    Rev 1.3   25 Jan 1996 22:46:10   frido
* Removed bug in complex clipping.
*
*    Rev 1.2   25 Jan 1996 22:07:54   frido
* Speeded up the pattern blit.
*
\**************************************************************************/

#include "precomp.h"
#include "SWAT.h"               // SWAT optimizations.

#define BITBLT_DBG_LEVEL    1
#define CLIP_DBG_LEVEL      1
#define BITMAP_DBG_LEVEL    1
#define PUNT_DBG_LEVEL      1

#define P   1
#define S   2
#define D   4
#define PS  (P|S)
#define DP  (P|D)
#define DPS (P|D|S)
#define DS  (S|D)

//
// Table with ROP flags.
//
BYTE ropFlags[256] =
{
0,   DPS, DPS, PS,  DPS, DP,  DPS, DPS, DPS, DPS, DP,  DPS, PS,  DPS, DPS, P,
DPS, DS,  DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS,
DPS, DPS, DS,  DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS,
PS,  DPS, DPS, S,   DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, PS,  DPS, DPS, PS,
DPS, DPS, DPS, DPS, DS,  DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS,
DP,  DPS, DPS, DPS, DPS, D,   DPS, DPS, DPS, DPS, DP,  DPS, DPS, DPS, DPS, DP,
DPS, DPS, DPS, DPS, DPS, DPS, DS,  DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS,
DPS, DPS, DPS, DPS, DPS, DPS, DPS, DS,  DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS,
DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DS,  DPS, DPS, DPS, DPS, DPS, DPS, DPS,
DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DS,  DPS, DPS, DPS, DPS, DPS, DPS,
DP,  DPS, DPS, DPS, DPS, DP,  DPS, DPS, DPS, DPS, D,   DPS, DPS, DPS, DPS, DP,
DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DS,  DPS, DPS, DPS, DPS,
PS,  DPS, DPS, PS,  DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, S,   DPS, DPS, PS,
DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DS,  DPS, DPS,
DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DS,  DPS,
P,   DPS, DPS, PS,  DPS, DP,  DPS, DPS, DPS, DPS, DP,  DPS, PS,  DPS, DPS, 0
};

COPYFN DoDeviceToDevice;
BOOL CopyDeviceBitmap(
    SURFOBJ  *psoTrg,
    SURFOBJ  *psoSrc,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclTrg,
    POINTL   *pptlSrc,
    ULONG    ulDRAWBLTDEF,
    COPYFN   *pfn);

BOOL PuntBitBlt(
    SURFOBJ*  psoDest,
    SURFOBJ*  psoSrc,
    SURFOBJ*  psoMask,
    CLIPOBJ*  pco,
    XLATEOBJ* pxlo,
    RECTL*    prclDest,
    POINTL*   pptlSrc,
    POINTL*   pptlMask,
    BRUSHOBJ* pbo,
    POINTL*   pptlBrush,
    ROP4      rop4);

#if SWAT6
void StripePatBlt(
        PPDEV   ppdev,
        ULONG   x,
        ULONG   y,
        ULONG   cx,
        ULONG   cy);
#endif


//
// If data logging is enabled, Prototype the logging files.
//
#if LOG_CALLS
    void LogBitBlt(
        int       acc,
        SURFOBJ*  psoSrc,
        SURFOBJ*  psoDest,
        ROP4 rop4,
        CLIPOBJ*  pco,
        BRUSHOBJ* pbo,
        XLATEOBJ* pxlo);

    void LogDrvCreateDevBmp(
        int acc,
        PPDEV  ppdev,
        SIZEL  sizl,
        PDSURF pdsurf);

    void LogDrvDeleteDevBmp(
        PDSURF pdsurf);

    void LogCreateDibFromScreen(
        int    acc,
        PPDEV  ppdev,
        PDSURF pdsurf);

    void LogCreateScreenFromDib(
        int acc,
        PPDEV  ppdev,
        PDSURF pdsurf);

//
// If data logging is not enabled, compile out the calls.
//
#else
    #define LogBitBlt(acc, psoSrc, psoDest, rop4, pco, pbo, pxlo)
    #define LogDrvCreateDevBmp(acc, ppdev, sizl, pdsurf)
    #define LogDrvDeleteDevBmp(pdsurf)
    #define LogCreateDibFromScreen(acc, ppdev, pdsurf)
    #define LogCreateScreenFromDib(acc, ppdev, pdsurf)
#endif


/****************************************************************************\
 * bIntersectTest                                                           *
 * Test for intersection between two rectangles.                            *
\****************************************************************************/
#define bIntersectTest(prcl1, prcl2) \
    (((prcl1)->left   < (prcl2)->right)  && \
     ((prcl1)->right  > (prcl2)->left)   && \
     ((prcl1)->top    < (prcl2)->bottom) && \
     ((prcl1)->bottom > (prcl2)->top))




/*****************************************************************************\
* BOOL DrvBitBlt                                                             *
\*****************************************************************************/
#if (USE_ASM && defined(i386))
BOOL i386BitBlt(
#else
BOOL DrvBitBlt(
#endif
SURFOBJ*  psoDest,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDest,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    PPDEV ppdev;
    ULONG fg_rop, bg_rop;
    ULONG bltdef = 0;
    BOOL  fSrc, fDest;

    #if NULL_BITBLT
    {
        if (pointer_switch)     return(TRUE);
    }
    #endif

    DISPDBG((BITBLT_DBG_LEVEL, "DrvBitBlt: Entry.\n"));
    ASSERTMSG(psoDest != NULL, "DrvBitBlt: No destination.\n");


    //
    // Get the PDEV associated with the destination.
    //
    ppdev = (PPDEV) ((psoDest != NULL) ? psoDest->dhpdev :
                    ((psoSrc != NULL) ? psoSrc->dhpdev : NULL));

    // Bad PDEV?
    if (ppdev == NULL) goto GoToEngine;

    SYNC_W_3D(ppdev);

    //
    // Set a flag to tell us if the source is the frame buffer.
    //
    fSrc = (psoSrc != NULL) &&                      // Is there a source?
            ((psoSrc->iType == STYPE_DEVBITMAP) ||  // Is it a device bmp?
             (psoSrc->hsurf == ppdev->hsurfEng) );  // Is it the screen?

    //
    // Set a flag telling us if the destination is the frame buffer.
    //
    fDest = (psoDest != NULL) &&                    // Is there a dest?
            ((psoDest->iType == STYPE_DEVBITMAP) || // Is it a device bmp?
             (psoDest->hsurf == ppdev->hsurfEng) ); // Is it the screen?

    //
    // If the destination is a DIB device bitmap, try copying it into
    // off-screen memory.
    //
    if ( fDest &&                               // If dest is supposed to be
                                                // the frame buffer,
         (psoDest->iType == STYPE_DEVBITMAP) && // and it's a device bitmap,
         ((PDSURF)psoDest->dhsurf)->pso )       // but it's really on the host,
    {
        // try to copy it back into off screen memory.
        if ( !bCreateScreenFromDib(ppdev, (DSURF*) psoDest->dhsurf) )
        {
            // If that fails, then the destination is now on the host.
            psoDest = ((PDSURF)psoDest->dhsurf)->pso;   // Host surface.
            fDest   = FALSE;                    // Dest is not frame buffer.
        }
    }

    //
    // If the source is a DIB device bitmap, try copying it into off-screen
    // memory.
    //
    if ( fSrc &&                                // If the source is supposed to
                                                // be the frame buffer,
         (psoSrc->iType == STYPE_DEVBITMAP) &&  // and it's a device bmp,
         ((PDSURF)psoSrc->dhsurf)->pso )        // but it's really on the host,
    {
        // try to copy it back into off-screen memory.
        if ( !bCreateScreenFromDib(ppdev, (DSURF*) psoSrc->dhsurf) )
        {
            // If that fails, then our source is really the host.
           psoSrc = ((PDSURF)psoSrc->dhsurf)->pso;  // Host surface.
           fSrc   = FALSE;                      // Src is not frame buffer.
        }
    }

    if ( fDest )
    {
        BYTE bROP;

        if (psoDest->iType == STYPE_DEVBITMAP)
            ppdev->ptlOffset = ((PDSURF)psoDest->dhsurf)->ptl;
        else
            ppdev->ptlOffset.x = ppdev->ptlOffset.y = 0;

        //
        // Extract the foreground and background ROP from the ROP4
        //
        ASSERTMSG( (rop4>>16) == 0, "DrvBitBlt: Upper word in ROP4 non-zero. \n");
        fg_rop = rop4 & 0x000000FF;
        bg_rop = (rop4>>8) & 0x000000FF;

        // Punt all true 4 op rops.
        // If fg_rop != bg_rop, then this is a true 4 op rop, so punt it.
        // If fg_rop == bg_rop, then it's really a three op rop.
        if ((fg_rop != bg_rop))        // It's a three op rop,
            goto GoToEngine;

        bROP = ropFlags[fg_rop];

        #if !(USE_ASM && defined(i386))
        {
            if (!(bROP & S))
            {
                // It is a PatBLT.  This is very important, so all calls to the
                // support routines are stretched into linear code, except for
                // the caching of the brushes, which should happen only once
                // for each brush.
                ULONG drawbltdef = 0x10000000 | fg_rop;
                if (bROP & D)
                    drawbltdef |= 0x01000000;

                // Do we have a pttern to load?
                if (bROP & P)
                {
                    ULONG color = pbo->iSolidColor;
                    if (color != (ULONG) -1)
                    {
                        // We have a solid color.
                        switch (ppdev->ulBitCount)
                        {
                        case 8:
                            color = (color << 8) | (color & 0xFF);
                        case 16:
                            color = (color << 16) | (color & 0xFFFF);
                        }
                        drawbltdef |= 0x00070000;
                        REQUIRE(2);
                        LL_BGCOLOR(color, 2);
                    }
                    else
                    {
                        if (!SetBrush(ppdev, &bltdef, pbo, pptlBrush))
                            goto GoToEngine;

                        drawbltdef |= bltdef << 16;
                    }
                }


                // Test for no clipping.
                if ( (pco == NULL) || (pco->iDComplexity == DC_TRIVIAL) )
                {
#if SWAT6
                    REQUIRE(2);
                    LL_DRAWBLTDEF(drawbltdef, 2);
                                        StripePatBlt(ppdev, prclDest->left + ppdev->ptlOffset.x,
                                                        prclDest->top + ppdev->ptlOffset.y,
                                                        prclDest->right - prclDest->left,
                                                        prclDest->bottom - prclDest->top);
#else
                    REQUIRE(7);
                    LL_DRAWBLTDEF(drawbltdef, 0);
                    LL_OP0(prclDest->left + ppdev->ptlOffset.x,
                           prclDest->top + ppdev->ptlOffset.y);
                    LL_BLTEXT(prclDest->right - prclDest->left,
                              prclDest->bottom - prclDest->top);
#endif
                }

                // Test for rectangle clipping.
                else if (pco->iDComplexity == DC_RECT)
                {
                    LONG x, y, cx, cy;
                    x  = max(prclDest->left,   pco->rclBounds.left);
                    y  = max(prclDest->top,    pco->rclBounds.top);
                    cx = min(prclDest->right,  pco->rclBounds.right)  - x;
                    cy = min(prclDest->bottom, pco->rclBounds.bottom) - y;
                    if ( (cx > 0) && (cy > 0) )
                    {
#if SWAT6
                        REQUIRE(2);
                        LL_DRAWBLTDEF(drawbltdef, 2);
                                                StripePatBlt(ppdev, x + ppdev->ptlOffset.x,
                                                                y + ppdev->ptlOffset.y, cx, cy);
#else
                        REQUIRE(7);
                        LL_DRAWBLTDEF(drawbltdef, 0);
                        LL_OP0(x + ppdev->ptlOffset.x, y + ppdev->ptlOffset.y);
                        LL_BLTEXT(cx, cy);
#endif
                    }
                }

                // Complex clipping.
                else
                {
                    BOOL       bMore;
                    ENUMRECTS8 ce;
                    RECTL*     prcl;

                 #if DRIVER_5465 && HW_CLIPPING
                    // Get a chunk of rectangles.
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                    // Enable clipping
                    REQUIRE(6);
                    LL_DRAWBLTDEF(drawbltdef | DD_CLIPEN, 0);
                    LL_CLIPULE(prclDest->left + ppdev->ptlOffset.x,
                               prclDest->top + ppdev->ptlOffset.y);
                    LL_CLIPLOR(prclDest->right + ppdev->ptlOffset.x,
                               prclDest->bottom + ppdev->ptlOffset.y);

                    do
                    {
                        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG *) &ce);
                        for (prcl = ce.arcl; ce.c--; prcl++)
                        {
                            if ((prcl->right > prcl->left) &&
                                (prcl->bottom > prcl->top))
                            {
#if SWAT6
                                                                StripePatBlt(ppdev,
                                                                                prcl->left + ppdev->ptlOffset.x,
                                                                                prcl->top + ppdev->ptlOffset.y,
                                                                                prcl->right - prcl->left,
                                                                                prcl->bottom - prcl->top);
#else
                                REQUIRE(5);
                                LL_OP0(prcl->left + ppdev->ptlOffset.x,
                                       prcl->top + ppdev->ptlOffset.y);
                                LL_BLTEXT(prcl->right - prcl->left,
                                          prcl->bottom - prcl->top);
#endif
                            }
                        }
                    } while (bMore);
                 #else
                    REQUIRE(2);
                    LL_DRAWBLTDEF(drawbltdef, 2);

                    // Get a chunk of rectangles.
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
                    do
                    {
                        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG *) &ce);
                        for (prcl = ce.arcl; ce.c--; prcl++)
                        {
                            LONG x, y, cx, cy;
                            x  = max(prclDest->left,   prcl->left);
                            y  = max(prclDest->top,    prcl->top);
                            cx = min(prclDest->right,  prcl->right)  - x;
                            cy = min(prclDest->bottom, prcl->bottom) - y;
                            if ( (cx > 0) && (cy > 0) )
                            {
#if SWAT6
                                                                StripePatBlt(ppdev, x + ppdev->ptlOffset.x,
                                                                                y + ppdev->ptlOffset.y, cx, cy);
#else
                                REQUIRE(5);
                                LL_OP0(x + ppdev->ptlOffset.x,
                                       y + ppdev->ptlOffset.y);
                                LL_BLTEXT(cx, cy);
#endif
                            }
                        }
                    }
                    while (bMore);
                 #endif
                }
                LogBitBlt(0, psoSrc, psoDest, rop4, pco, pbo, pxlo);
                return(TRUE);
            }
        }
        #endif // !(USE_ASM && defined(i386))

        // We only support HostToScreen blits where the Host is either
        // 1-bpp, 4-bpp, 8-bpp, or the same format as the screen.
        if ( ((psoSrc->iBitmapFormat > BMF_8BPP) &&
             (psoSrc->iBitmapFormat != psoDest->iBitmapFormat)) )
        {
            goto GoToEngine;
        }

        if (bROP & P)
        {
            // Realize the brush.
            if (!SetBrush(ppdev, &bltdef, pbo, pptlBrush))
            {
                goto GoToEngine;
            }
        }

        // If the destination is part of the ROP, set the bit.
        if (bROP & D)
        {
            bltdef |= 0x0100;
        }

        // Do the blit.
        if (CopyDeviceBitmap(psoDest, psoSrc, pco, pxlo, prclDest,
                             pptlSrc, (bltdef << 16) | fg_rop,
                             fSrc ? DoDeviceToDevice : ppdev->pfnHostToScreen))
        {
            LogBitBlt(0, psoSrc, psoDest, rop4, pco, pbo, pxlo);
            return(TRUE);
        }
    } // fDest

    else if (fSrc) // Destination is bitmap, source is screen or device bitmap.
    {
        if (psoSrc->iType == STYPE_DEVBITMAP)
        {
            ppdev->ptlOffset = ((PDSURF) psoSrc->dhsurf)->ptl;
        }
        else
        {
            ppdev->ptlOffset.x = ppdev->ptlOffset.y = 0;
        }

        #if S2H_USE_ENGINE
        {
            // ROP3?
            fg_rop = (BYTE) rop4;
            if (fg_rop == (rop4 >> 8))
            {
                BYTE bROP = ropFlags[fg_rop];

                // We dont's support ROPs where the destination is part of.
                if ( !(bROP & D) )
                {
                    // If we need a brush, load it.
                    if (bROP & P)
                    {
                        if (!SetBrush(ppdev, &bltdef, pbo, pptlBrush))
                        {
                            goto GoToEngine;
                        }
                    }
                    // Now, call the routine through the clip manager.
                    if (CopyDeviceBitmap(psoDest, psoSrc, pco, pxlo,
                                         prclDest, pptlSrc,
                                         (bltdef << 16) | fg_rop,
                                         ppdev->pfnScreenToHost))
                    {
                        LogBitBlt(0, psoSrc, psoDest, rop4, pco, pbo, pxlo);
                        return(TRUE);
                    }
                }
            }
        }
        #else
        {
            // We only support SRCCOPY.
            if (rop4 == 0x0000CCCC)
            {
                // Now, call the routine through the clip manager.
                if (CopyDeviceBitmap(psoDest, psoSrc, pco, pxlo, prclDest,
                                     pptlSrc, 0x000000CC,
                                     ppdev->pfnScreenToHost))
                {
                    LogBitBlt(0, psoSrc, psoDest, rop4, pco, pbo, pxlo);
                    return(TRUE);
                }
            }
        }
        #endif
    }

GoToEngine:

    // BLT is too complex. Punt it to GDI.

    DISPDBG((BITBLT_DBG_LEVEL, "DrvBitBlt: Exit (punt). ROP4 = 0x%02X%02X.\n",
             bg_rop,fg_rop));
    LogBitBlt(1, psoSrc, psoDest, rop4, pco, pbo, pxlo);
    return PuntBitBlt(psoDest, psoSrc, psoMask, pco, pxlo, prclDest, pptlSrc,
                      pptlMask, pbo, pptlBrush, rop4);
}

/*****************************************************************************\
 * DrvCreateDeviceBitmap
 *
 * This routine creates a device bitmap that is allocated off-screen.
 *
 * On entry:    dhpdev      Handle of PDEV structure.
 *      sizl        Size of the device bitmap to create.
 *      iFormat     Bitmap format of the device bitmap to create.
 *
 * Returns: We return the handle of a surface object that holds our device
 *      bitmap or 0 if there is an error.
\*****************************************************************************/
HBITMAP DrvCreateDeviceBitmap(
    DHPDEV dhpdev,
    SIZEL  sizl,
    ULONG  iFormat
)
{
    PPDEV   ppdev = (PPDEV) dhpdev;
    POFMHDL pofm;
    HBITMAP hbmDevice;
    PDSURF  pdsurf;
    FLONG   flHooks =   HOOK_SYNCHRONIZEACCESS | HOOK_TEXTOUT
                      | HOOK_BITBLT | HOOK_COPYBITS | HOOK_PAINT
                      | HOOK_STROKEPATH | HOOK_FILLPATH
                          #ifdef WINNT_VER40
                      | HOOK_LINETO
                      #endif
                  ;

    SYNC_W_3D(ppdev);

    #if WINBENCH96
        //
        // We support only device bitmaps that WinBench is going to use.  This
        // to circumvent the limitations of the heap management when there is
        // not so much video memory.
        //
        // Only support bitmaps with a width between 20 and 31, and bitmaps
        // wider than 100.
        if ( (sizl.cx < 20) || ((sizl.cx >= 32) && (sizl.cx < 100)) )
        {
            LogDrvCreateDevBmp(1, ppdev, sizl, NULL);
            return(0);
        }

    #else
        // We don't support anything under or equal to 8x8 (brushes) since
        // these will only slow us down.
        if ((sizl.cx <= 8) || (sizl.cy <= 8))
        {
            LogDrvCreateDevBmp(2, ppdev, sizl, NULL);
            return(0);
        }

                #if MEMMGR
                // New bitmap filter, borrowed from Windows 95.
                if (ppdev->fBitmapFilter)
                {
                        if ((  (sizl.cx <= ppdev->szlBitmapMin.cx)
                                && (sizl.cy <= ppdev->szlBitmapMin.cy)
                                )
                                || (sizl.cx > ppdev->szlBitmapMax.cx)
                                || (sizl.cy > ppdev->szlBitmapMax.cy)
                        )
                        {
                LogDrvCreateDevBmp(8, ppdev, sizl, NULL);
                DISPDBG((BITMAP_DBG_LEVEL, "DrvCreateDeviceBitmap - Rejected\n"));
                return(0);
                        }
                }
                #else
        // Reject any x<=32, or y<=64, for 16 or 24 bpp.
        // Improves WinBench97 scores.
        if ((iFormat == BMF_16BPP) || (iFormat == BMF_24BPP))
        {
            if ((sizl.cx <= 32) || (sizl.cy <= 64))
            {
                LogDrvCreateDevBmp(8, ppdev, sizl, NULL);
                DISPDBG((BITMAP_DBG_LEVEL, "DrvCreateDeviceBitmap - Reject x<=32||y<=64\n"));
                return(0);
            }
        }
                #endif

    #endif

    // Reject if bigger than current screen size
    if ((ULONG)sizl.cx > ppdev->cxScreen)
    {
       LogDrvCreateDevBmp(9, ppdev, sizl, NULL);
       DISPDBG((BITMAP_DBG_LEVEL, "DrvCreateDeviceBitmap - Reject > cxScreen\n"));
       return(0);
    }

    // If the hardware is not in graphics mode, don't create a device bitmap!
    if (!ppdev->bEnable)
    {
        LogDrvCreateDevBmp(3, ppdev, sizl, NULL);
        return(0);
    }

    // We don't support device bitmaps in any other mode than the hardware.
    if (iFormat != ppdev->iBitmapFormat)
    {
        return(0);
    }

    #ifdef ALLOC_IN_CREATESURFACE
        if (ppdev->bDirectDrawInUse)
           return (0);
    #endif
#if SWAT1
        // Is this the very first device bitmap?
        if (ppdev->fPreAllocate == FALSE)
        {
                // Setup step-down counter.
                ppdev->fPreAllocate = TRUE;
                ppdev->nPages = 10;
        }

        // Is this the WinBench 97 pause bitmap?
        else if (sizl.cx == 300 && sizl.cy == 150)
        {
                if (ppdev->nPages == 0)
                {
                        PVOID p;
                        // Allocate 8 full-screen pages from the heap.
                        #ifdef WINNT_VER40
                        p = MEM_ALLOC(FL_ZERO_MEMORY, 8 * ppdev->cxScreen *
                                        ppdev->iBytesPerPixel * ppdev->cyScreen, ALLOC_TAG);
                        #else
                        p = MEM_ALLOC(LPTR, 8 * ppdev->cxScreen * ppdev->iBytesPerPixel *
                                        ppdev->cyScreen);
                        #endif
                        // Free it again.
                        MEMORY_FREE(p);
                }
                else
                {
                        // Decrement step-down counter.
                        ppdev->nPages--;
                }
        }

        // Is this a full-screen device bitmap?
        else if (  (ppdev->nPages == 0)
                        && (sizl.cx == (LONG) ppdev->cxScreen)
                        && (sizl.cy == (LONG) ppdev->cyScreen)
        )
        {
                PVOID p;
                // Allocate 8 full-screen pages from the heap.
                #ifdef WINNT_VER40
                p = MEM_ALLOC(FL_ZERO_MEMORY, 8 * ppdev->cxScreen *
                                ppdev->iBytesPerPixel * ppdev->cyScreen, ALLOC_TAG);
                #else
                p = MEM_ALLOC(LPTR, 8 * ppdev->cxScreen * ppdev->iBytesPerPixel *
                                ppdev->cyScreen);
                #endif
                // Free it again.
                MEMORY_FREE(p);
        }
#endif // SWAT1

#if SWAT2
        // Is this a full-screen device bitmap?
        if (   (sizl.cx == (LONG) ppdev->cxScreen)
                && (sizl.cy == (LONG) ppdev->cyScreen)
        )
        {
                #if MEMMGR
                // Hostify all device bitmaps.
                extern void HostifyAllBitmaps(PPDEV ppdev);
                HostifyAllBitmaps(ppdev);
                #else
                POFMHDL pofm, pofmNext;

                // Hostify all current off-screen device bitmaps.
                for (pofm = ppdev->OFM_UsedQ; pofm; pofm = pofmNext)
                {
                        pofmNext = pofm->nexthdl;

                        if (pofm->pdsurf && pofm->pdsurf->pofm)
                        {
                                bCreateDibFromScreen(ppdev, pofm->pdsurf);
                        }
                        else if (pofm->alignflag & SAVESCREEN_FLAG)
                        {
                                FreeOffScnMem(ppdev, pofm);
                        }
                }
                #endif
        }
#endif // SWAT2

    //
    // Allocate off-screen memory.
    //
    {
       #if INFINITE_OFFSCREEN_MEM
        //
        // This is our "infinite offscreen memory" test.  Here we always
        // succeed in memory allocation.  We do this by always allocating
        // bitmaps at screen 0,0.
        // It looks ugly, but we can use it to tell of our memory management
        // is hurting our benchmark scores.
        // This option is turned off for the retail version of the driver.
        // 'pointer_switch' is turned on and off in POINTER.C by moving the pointer
        // to a special place on the screen.
        //
        if (pointer_switch)
        {
            pofm = ppdev->ScrnHandle;
        }
        else
        #endif // INFINITE_OFFSCREEN_MEM
        {
            #if WINBENCH96
            //
            // This is our Magic Bitmap.
            // Winbench 96 allocates one special bitmap into which it does *lots*
            // of drawing.  If the allocation for this bitmap fails, our WinBench
            // score will be poor.  We ensure that this allocation succeeds
            // by pre-allocating it at boot time.
            //
            // If the size of the requested bitmap matches our magic bitmap, we
            // assume that Winbench is requesting it's special bitmap, and so we
            // use the magic bitmap.
            //
            if ( (sizl.cx == MAGIC_SIZEX) && (sizl.cy == MAGIC_SIZEY) &&
                 ppdev->pofmMagic && !ppdev->bMagicUsed)
            {
                // If fits.  Use pre-allocated bitmap.
                DISPDBG((BITMAP_DBG_LEVEL,
                         "DrvCreateDeviceBitmap - Using the Magic Bitmap.\n"));
                ppdev->bMagicUsed = 1;
                pofm = ppdev->pofmMagic;
            }
            else
            #endif
            {
                DISPDBG((BITMAP_DBG_LEVEL,
                "DrvCreateDeviceBitmap - Allocating a %d x %d device bitmap.\n",
                 sizl.cx, sizl.cy));
                                #if MEMMGR
                                if (ppdev->fBitmapFilter)
                                {
                                        pofm = AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);
                                        if (pofm == NULL)
                                        {
                                                HostifyAllBitmaps(ppdev);
                                                pofm = AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);
                                        }
                                }
                                else if (sizl.cx <= ppdev->must_have_width)
                                {
                        pofm = AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN | MUST_HAVE,
                                NULL);
                                }
                                else
                                #endif
                pofm = AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);
            }
        }
    }

    //
    // If we got the offscreen memory we need, then let's do some work.
    //
    if (pofm != NULL)
    {
        // Allocate device bitmap structure.

        #ifdef WINNT_VER40
            pdsurf = MEM_ALLOC(FL_ZERO_MEMORY, sizeof(DSURF), ALLOC_TAG);
        #else
            pdsurf = MEM_ALLOC(LPTR, sizeof(DSURF));
        #endif

        if (pdsurf != NULL)
        {
            // Create the device bitmap object.
            hbmDevice = EngCreateDeviceBitmap((DHSURF) pdsurf, sizl, iFormat);
            if (hbmDevice != NULL)
            {
                // Associate the device bitmap with the surface.
                if (EngAssociateSurface((HSURF) hbmDevice,
                                                                ppdev->hdevEng,
                                                                                flHooks)
                )
                {
                    // Store a pointer to the surface.
                    {
                        #if INFINITE_OFFSCREEN_MEM
                            //
                            // If we're using screen(0,0) as a device bitmap
                            // then don't walk on ScrnHandle->pdsurf!
                            //
                            if (pofm != ppdev->ScrnHandle)
                        #endif
                        pofm->pdsurf = pdsurf;
                    }

                    // Initialize the device bitmap structure.
                    pdsurf->ppdev = ppdev;
                    pdsurf->pofm = pofm;
                    pdsurf->ptl.x = pofm->aligned_x / ppdev->iBytesPerPixel;
                    pdsurf->ptl.y = pofm->aligned_y;
                    pdsurf->packedXY = (pdsurf->ptl.y << 16) | pdsurf->ptl.x;
                    pdsurf->sizl = sizl;
                    LogDrvCreateDevBmp(0, ppdev, sizl, pdsurf);

                    return(hbmDevice);
                }
                else
                {
                    LogDrvCreateDevBmp(4, ppdev, sizl, NULL);
                }
                // Delete the surface
                EngDeleteSurface((HSURF) hbmDevice);
            }
            else
            {
                LogDrvCreateDevBmp(5, ppdev, sizl, NULL);
            }
            // Free the device bitmap structure.
            MEMORY_FREE(pdsurf);
        }
        else
        {
            LogDrvCreateDevBmp(6, ppdev, sizl, NULL);
        }

        #if WINBENCH96
        // Free the off-screen memory.
        if (pofm == ppdev->pofmMagic)
        {
            // We were using the preallocated memory block.  Don't free it,
            // just mark it as unused.
            ppdev->bMagicUsed = 0;
        }
        else
        #endif
        {
            #if INFINITE_OFFSCREEN_MEM
                // But don't free it if the device bitmap is at screen(0,0)...
                if (pofm != ppdev->ScrnHandle)
            #endif
            FreeOffScnMem(ppdev, pofm);
        }
    }
    else
    {
        LogDrvCreateDevBmp(7, ppdev, sizl, NULL);
    }

    return(0);
}

/*****************************************************************************\
 * DrvDeleteDeviceBitmap
 *
 * This routine deletes a device bitmap and frees the off-screen memory.
 *
 * On entry:    pdsurf          Pointer to device bitmap to delete.
\*****************************************************************************/
void DrvDeleteDeviceBitmap(DHSURF dhsurf)
{

        PDSURF pdsurf = (PDSURF) dhsurf;

    //
    // Log this call to a file.
    //
    LogDrvDeleteDevBmp(pdsurf);

    // Is the device bitmap stored in a DIB?
    if (pdsurf->pso)
    {
        // Delete the in-memory DIB.
        HSURF hsurfDib = pdsurf->pso->hsurf;
        EngUnlockSurface(pdsurf->pso);
        EngDeleteSurface(hsurfDib);
    }
    else
    {
        PPDEV ppdev = pdsurf->ppdev;

        #if INFINITE_OFFSCREEN_MEM
            //
            // If we're using screen(0,0) as a device bitmap
            // then don't walk on ScrnHandle->pdsurf!
            //
            if (pdsurf->pofm != ppdev->ScrnHandle)
        #endif

        pdsurf->pofm->pdsurf = NULL;

        #if WINBENCH96
        if ( pdsurf->pofm == ppdev->pofmMagic)
        {
            // We were using the preallocated chunk of memory.  Don't free
            // it, just mark it as unused.
            ppdev->bMagicUsed = 0;
        }
        else
        #endif
        {
            // Free the off-screen memory.
            #if INFINITE_OFFSCREEN_MEM
                // unless our device bitmap is at screen(0,0)...
                if (pdsurf->pofm != ppdev->ScrnHandle)
            #endif
            FreeOffScnMem(pdsurf->ppdev, pdsurf->pofm);
        }
    }

    // Free the device bitmap structure.
    MEMORY_FREE(pdsurf);
}


/*****************************************************************************\
 * bCreateDibFromScreen
 *
 * This routine copy a device bitmap into a DIB and frees the off-screen
 * memory.
 *
 * On entry:    ppdev           Pointer to physical device.
 *      pdsurf          Pointer to device bitmap to copy.
 *
 * Returns: TRUE if the off-screen device bitmap was sucessfully copied
 *      into a memory DIB.
\*****************************************************************************/
BOOL bCreateDibFromScreen(
    PPDEV  ppdev,
    PDSURF pdsurf
)
{
    HBITMAP hbmDib;

    // Create a DIB.
    hbmDib = EngCreateBitmap(pdsurf->sizl, 0, ppdev->iBitmapFormat,
                             BMF_TOPDOWN, NULL);
    if (hbmDib)
    {
        // Associate the surface with the driver.
        if (EngAssociateSurface((HSURF) hbmDib, ppdev->hdevEng, 0))
        {
            // Lock the surface.
            SURFOBJ* pso = EngLockSurface((HSURF) hbmDib);
            if (pso != NULL)
            {
                SIZEL sizl;
                PBYTE pjScreen, pjBits;

                // Calculate the size of the blit.
                sizl.cx = pdsurf->sizl.cx * ppdev->iBytesPerPixel;
                sizl.cy = pdsurf->sizl.cy;

                // Calculate the destination variables.
                pjBits = (PBYTE) pso->pvScan0;

                // Calculate the screen address.
                pjScreen = ppdev->pjScreen
                         + (pdsurf->ptl.x * ppdev->iBytesPerPixel)
                         + (pdsurf->ptl.y * ppdev->lDeltaScreen);

                // Wait for the hardware to become idle.
                while (LLDR_SZ(grSTATUS) != 0) ;

                while (sizl.cy--)
                {
                    // Copy all pixels from screen to memory.
                    memcpy(pjBits, pjScreen, sizl.cx);

                    // Next line.
                    pjScreen += ppdev->lDeltaScreen;
                    pjBits += pso->lDelta;
                }

                #if WINBENCH96
                    //
                    // If the block we are freeing is our preallocated
                    // piece, then invalidate it's pointer.
                    //
                    if ( pdsurf->pofm == ppdev->pofmMagic)
                        ppdev->pofmMagic = 0;
                #endif

                                #if !MEMMGR
                // Free the off-screen memory handle.
                #if INFINITE_OFFSCREEN_MEM
                    // unless our device bitmap is at screen(0,0)...
                    if (pdsurf->pofm != ppdev->ScrnHandle)
                #endif
                FreeOffScnMem(pdsurf->ppdev, pdsurf->pofm);
                                #endif

                // Mark the device bitmap as DIB.
                pdsurf->pofm = NULL;
                pdsurf->pso = pso;

                // Done.
                LogCreateDibFromScreen(0, ppdev, pdsurf);
                return(TRUE);
            }
            else
            {
                // Failed to lock host surface
                LogCreateDibFromScreen(1, ppdev, pdsurf);
            }
        }
        else
        {
            // Failed to associate host surface
            LogCreateDibFromScreen(2, ppdev, pdsurf);
        }

        // Delete the DIB.
        EngDeleteSurface((HSURF) hbmDib);
    }
    else
    {
        // Failed to create host surface.
        LogCreateDibFromScreen(3, ppdev, pdsurf);
    }

    // Error.
    return(FALSE);
}

/*****************************************************************************\
 * bCreateScreenFromDib
 *
 * This routine copys a DIB into a device bitmap and frees the DIB from memory.
 *
 * On entry:    ppdev           Pointer to physical device.
 *      pdsurf          Pointer to device bitmap to copy.
 *
 * Returns:     TRUE if the DIB was sucessfully copied into an off-screen
 *          device bitmap.
\*****************************************************************************/
BOOL bCreateScreenFromDib(
    PPDEV     ppdev,
    PDSURF    pdsurf
)
{
    POFMHDL  pofm;
    HSURF    hsurf;
    SURFOBJ* pso;

        #if MEMMGR
        // In low memory situations, bitmaps will be hostified very frequently, so
        // don't copy them back to the off-screen...
        if (ppdev->fBitmapFilter)
        {
                return FALSE;
        }
        #endif

    // If the hardware is not in graphics mode, keep the device bitmap in
    // memory.
    if (!ppdev->bEnable)
    {
        LogCreateScreenFromDib (1, ppdev, pdsurf);
        return(FALSE);
    }

    #ifdef ALLOC_IN_CREATESURFACE
        if (ppdev->bDirectDrawInUse)
            return (FALSE);
    #endif

    // Allocate off-screen memory.
    pofm = AllocOffScnMem(ppdev, &pdsurf->sizl, PIXEL_AlIGN, NULL);
    if (pofm != NULL)
    {
        SURFOBJ psoDest;
        RECTL   rclDest;
        POINTL  ptlSrc;

        //
        // Tell the device bitmap where it lives in offscreen memory.
        //
        pdsurf->ptl.x = pofm->aligned_x / ppdev->iBytesPerPixel;
        pdsurf->ptl.y = pofm->aligned_y;
        pdsurf->packedXY = (pdsurf->ptl.y << 16) | pdsurf->ptl.x;

        //
        // Create a two way link between the device bitmap and
        // its offscreen memory block.
        //
        pdsurf->pofm = pofm;   // Attach offscreen memory block to device bitmap
        pofm->pdsurf = pdsurf; // Attach device bitmap to offscreen memory block

        //
        // Disattach the host bitmap from the device bitmap.
        // Save the pointer, because if we fail to move the device bitmap
        // into the frame buffer, it will remain in host memory, and we
        // will have to restore this pointer.
        //
        pso = pdsurf->pso;     // Save pointer to bitmap in host memory.
        pdsurf->pso = NULL;    // disattach host memory

        //
        // Wrap the offscreen memory in a destination surface object.
        // This is so we can use a host to screen BLT to move the bitmap
        // from the host to the offscreen memory.
        //
        psoDest.dhsurf = (DHSURF) pdsurf;
        psoDest.iType = STYPE_DEVBITMAP;

        //
        // Build a destination rectangle that describes where to put the
        // bitmap in offscreen memory.  This rectangle is relative to
        // upper left corner of the allocated block of offscreen memory.
        //
        rclDest.left = 0;
        rclDest.top = 0;
        rclDest.right = pdsurf->sizl.cx;
        rclDest.bottom = pdsurf->sizl.cy;

        //
        // Build a source point.
        // Since we're moving the entire bitmap, its (0,0).
        //
        ptlSrc.x = ptlSrc.y = 0;

        //
        // Use our host to screen code to copy the DIB into off-screen memory.
        //
        if (!ppdev->pfnHostToScreen(&psoDest, pso, NULL, &rclDest, &ptlSrc,
                               0x000000CC))
        {
            //
            // BLT engine couldn't put it back into off screen memory.
            // Maybe the DIB engine can.
            //
            DISPDBG (( 0, "Couldn't BLT device bitmap back into framebuffer.\n"));

            if (! PuntBitBlt(&psoDest, pso, NULL, NULL, NULL,
                             &rclDest, &ptlSrc, NULL, NULL, NULL, 0x0000CCCC))
            {
                // Nope!  We can't move it back to the frame buffer.
                DISPDBG (( 0, "Couldn't punt device bitmap back into framebuffer.\n"));
                DISPDBG (( 0, "Device bitmap will remain in offscreen memory.\n"));

                // Restore the surface object pointers.
                pdsurf->pofm = NULL; // This device bitmap has no offscreen memory.
                pdsurf->pso = pso;   // This device bitmap lives here, on the host.

                // Free the offscreen memory we allocated and fail.
                FreeOffScnMem(ppdev, pofm);
                return FALSE;
            }
        }

        // Delete the DIB.
        hsurf = pso->hsurf;
        EngUnlockSurface(pso);
        EngDeleteSurface(hsurf);

        // Done.
        LogCreateScreenFromDib (0, ppdev, pdsurf);
        return(TRUE);
    }

    // Error.
    LogCreateScreenFromDib (2, ppdev, pdsurf);
    return(FALSE);
}

#if LOG_CALLS
// ============================================================================
//
//    Everything from here down is for data logging and is not used in the
//    production driver.
//
// ============================================================================
extern long lg_i;
extern char lg_buf[256];


// ****************************************************************************
//
// LogBitBlt()
// This routine is called only from DrvBitBlt()
// Dump information to a file about what is going on in BitBlt land.
//
// ****************************************************************************
void LogBitBlt(
        int       acc,
        SURFOBJ*  psoSrc,
        SURFOBJ*  psoDest,
        ROP4 rop4,
        CLIPOBJ*  pco,
        BRUSHOBJ* pbo,
        XLATEOBJ* pxlo)
{
    PPDEV dppdev,sppdev,ppdev;
    BYTE fg_rop, bg_rop;
    ULONG iDComplexity;

    dppdev = (PPDEV) (psoDest ? psoDest->dhpdev : 0);
    sppdev = (PPDEV) (psoSrc  ? psoSrc->dhpdev  : 0);
    ppdev = dppdev ? dppdev : sppdev;

    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    lg_i = sprintf(lg_buf,"DBB: ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    if (acc)
    {
        lg_i = sprintf(lg_buf,"PNT ");
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }

    fg_rop = (BYTE) (rop4 & 0xff);
    bg_rop = (BYTE) ((rop4>>8) & 0xff);


    //
    // Check the SRC
    //
    if ( (ropFlags[fg_rop] & S) &&
         (psoSrc))
    {
        if (psoSrc->iType == STYPE_DEVBITMAP)
        {
            lg_i = sprintf(lg_buf, "Src Id=%p ", psoSrc->dhsurf);
            WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

            if ( ((PDSURF)psoSrc->dhsurf)->pso  )
                lg_i = sprintf(lg_buf,"S=DH ");
            else
                lg_i = sprintf(lg_buf,"S=DF ");
        }
        else if (psoSrc->hsurf == ppdev->hsurfEng)
            lg_i = sprintf(lg_buf,"S=S ");
        else
            lg_i = sprintf(lg_buf,"S=H ");
    }
    else
        lg_i = sprintf(lg_buf,"S=N ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    //
    // Check the DEST
    //
    if (psoDest)
    {
        if (psoDest->iType == STYPE_DEVBITMAP)
        {
            lg_i = sprintf(lg_buf, "Dst Id=%p ", psoDest->dhsurf);
            WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

            if (  ((PDSURF)psoDest->dhsurf)->pso   )
                lg_i = sprintf(lg_buf,"D=DH ");
            else
                lg_i = sprintf(lg_buf,"D=DF ");
        }
        else if (psoDest->hsurf == ppdev->hsurfEng)
            lg_i = sprintf(lg_buf,"D=S ");
        else
            lg_i = sprintf(lg_buf,"D=H ");
    }
    else
        lg_i = sprintf(lg_buf,"D=N ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);



    //
    // Check the ROP
    //
    if (fg_rop == bg_rop)
        lg_i = sprintf(lg_buf,"R3=%02X ", fg_rop);
    else
        lg_i = sprintf(lg_buf,"R4=%04X ", rop4&0xFFFF);
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    //
    // Check the type of clipping.
    //
    iDComplexity = (pco ? pco->iDComplexity : DC_TRIVIAL);
    lg_i = sprintf(lg_buf,"C=%s ",
                (iDComplexity==DC_TRIVIAL ? "T":
                (iDComplexity == DC_RECT ? "R" : "C" )));
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    //
    // Type of pattern.
    //
   if (ropFlags[fg_rop] & P)
   {
      if (pbo->iSolidColor == 0xFFFFFFFF )
      {
        lg_i = sprintf(lg_buf,"BR=P ");
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
      }
      else
      {
        lg_i = sprintf(lg_buf,"BR=0x%X ",(pbo->iSolidColor));
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
      }
    }
    else
    {
        lg_i = sprintf(lg_buf,"BR=N ");
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }


    //
    // Type of translation
    //
    if (!pxlo)
    {
        lg_i = sprintf(lg_buf,"TR=N ");
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }
    else if (pxlo->flXlate & XO_TRIVIAL)
    {
        lg_i = sprintf(lg_buf,"TR=T ");
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }
    else
    {
        lg_i = sprintf(lg_buf,"TR=NT ");
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }

    lg_i = sprintf(lg_buf,"\r\n");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    return;
}



// ****************************************************************************
//
// LogDrvCreateDevBmp()
// This routine is called only from DrvCreateDeviceBitmap()
// Dump information to a file about what is going on in device bitmap land.
//
// ****************************************************************************
void LogDrvCreateDevBmp(
    int acc,
    PPDEV  ppdev,
    SIZEL  sizl,
    PDSURF pdsurf)
{

    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    switch(acc)
    {
    case 0: // Accelerated
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Id: 0x%08X  Loc: %d,%d \r\n",
                sizl.cx, sizl.cy, pdsurf, pdsurf->pofm->x, pdsurf->pofm->y );
        break;

    case 1: // Punted
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt size.\r\n",
                sizl.cx, sizl.cy);
        break;

    case 2: // Punted
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt 8x8.\r\n",
                sizl.cx, sizl.cy);
        break;

    case 3: // Punted
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt mode.\r\n",
                sizl.cx, sizl.cy);
        break;

    case 4: // Punted
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt assoc.\r\n",
                sizl.cx, sizl.cy);
        break;

    case 5: // Punted
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt bitmap.\r\n",
                sizl.cx, sizl.cy);
        break;

    case 6: // Punted
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt DSURF.\r\n",
                sizl.cx, sizl.cy);
        break;

    case 7: // Punted
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt FB alloc.\r\n",
                sizl.cx, sizl.cy);
        break;

    case 8: // Punted
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt 32x64.\r\n",
                sizl.cx, sizl.cy);
        break;

    case 9: // Punted
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt > cxScreen.\r\n",
                sizl.cx, sizl.cy);
        break;

    default:
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt unknown.\r\n",
                sizl.cx, sizl.cy);
        break;

    }
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
 }



// ****************************************************************************
//
// LogDrvDeleteDevBmp()
// This routine is called only from DrvDeleteDeviceBitmap()
// Dump information to a file about what is going on in device bitmap land.
//
// ****************************************************************************
void LogDrvDeleteDevBmp(
    PDSURF pdsurf)
{

    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    lg_i = sprintf(lg_buf, "DrvDeleteDeviceBitmap:   Id: 0x%08X. ", pdsurf);
    WriteLogFile(pdsurf->ppdev->pmfile, lg_buf,
                 lg_i, pdsurf->ppdev->TxtBuff, &pdsurf->ppdev->TxtBuffIndex);

    if (pdsurf->pso)
    {
        lg_i = sprintf(lg_buf, "Loc: HOST\r\n");
        WriteLogFile(pdsurf->ppdev->pmfile, lg_buf, lg_i,
                     pdsurf->ppdev->TxtBuff, &pdsurf->ppdev->TxtBuffIndex);
    }
    else
    {
        lg_i = sprintf(lg_buf, "Loc: %d,%d\r\n", pdsurf->pofm->x, pdsurf->pofm->y);
        WriteLogFile(pdsurf->ppdev->pmfile, lg_buf, lg_i,
                     pdsurf->ppdev->TxtBuff, &pdsurf->ppdev->TxtBuffIndex);
    }
}



// ****************************************************************************
//
// LogCreateDibFromScreen()
// This routine is called only from bCreateDibFromScreen()
// Dump information to a file about what is going on in device bitmap land.
//
// ****************************************************************************
void LogCreateDibFromScreen(
    int acc,
    PPDEV  ppdev,
    PDSURF pdsurf
)
{

    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    lg_i = sprintf(lg_buf, "CreateDibFromScreen:     Id: 0x%08X ", pdsurf);
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    switch(acc)
    {
    case 0: // Succeeded
        lg_i = sprintf(lg_buf, " \r\n");
        break;

    case 1: // Failed
        lg_i = sprintf(lg_buf, "Fail lock\r\n");
        break;

    case 2: // Failed
        lg_i = sprintf(lg_buf,  "Fail assoc\r\n");
        break;

    case 3: // Failed
        lg_i = sprintf(lg_buf,   " Fail create\r\n");
        break;

    default:
        lg_i = sprintf(lg_buf,  "Failed unknown\r\n");
        break;
    }

    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

}



// ****************************************************************************
//
// LogCreateScreenFromDib()
// This routine is called only from bCreateScreenFromDib()
// Dump information to a file about what is going on in device bitmap land.
//
// ****************************************************************************
void LogCreateScreenFromDib(
    int acc,
    PPDEV  ppdev,
    PDSURF pdsurf
)
{
    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    lg_i = sprintf(lg_buf,   "CreateScreenFromDib: ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    switch(acc)
    {
    case 0: // Succeeded
        lg_i = sprintf(lg_buf, "Id: 0x%08X  Dest: %d,%d\r\n",
                pdsurf, pdsurf->pofm->x, pdsurf->pofm->y );
        break;

    case 1: // Failed
        lg_i = sprintf(lg_buf, "Fail mode\r\n");
        break;

    case 2: // Failed
        lg_i = sprintf(lg_buf, "Fail alloc\r\n");
        break;

    default: // Failed
        lg_i = sprintf(lg_buf, "Fail unknown\r\n");
        break;

    }

    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

}

#endif // LOG_CALLS


// ============================================================================
//
// Punt a drawing operation back to GDI.
//      Return TRUE if punt was successful.
//      Return FALSE if punt failed.
//
BOOL PuntBitBlt(
    SURFOBJ*  psoDest,
    SURFOBJ*  psoSrc,
    SURFOBJ*  psoMask,
    CLIPOBJ*  pco,
    XLATEOBJ* pxlo,
    RECTL*    prclDest,
    POINTL*   pptlSrc,
    POINTL*   pptlMask,
    BRUSHOBJ* pbo,
    POINTL*   pptlBrush,
    ROP4      rop4)
{
    HBITMAP hbmDibSrc = 0;
    HBITMAP hbmDibDest = 0;
    PBYTE   pjScreen;
    BOOL    bStatus;
    PDSURF  pdsurf;
    PPDEV   ppdev = 0;

    DISPDBG((PUNT_DBG_LEVEL, "PuntBitBlt: Entry.\n"));


    //
    // If the source is a device bitmap, build a wrapper around it.
    //
    if ( psoSrc && (psoSrc->iType == STYPE_DEVBITMAP))
    {
        // Source is a device bitmap.
        pdsurf = (PDSURF) psoSrc->dhsurf;
        ppdev = pdsurf->ppdev;

        if ( pdsurf->pofm )  // If it's in the frame buffer.
        {
            DISPDBG((PUNT_DBG_LEVEL,
                "    Source is device bitmap at (%d,%d).\n",
                (pdsurf->ptl.x), (pdsurf->ptl.y)));

            // Calculate the off-screen address.
            // This is the upper left pixel in the device bitmap.
            pjScreen = ppdev->pjScreen
                     + (pdsurf->ptl.x * ppdev->iBytesPerPixel)
                     + (pdsurf->ptl.y * ppdev->lDeltaScreen);

            // Create a DIB. Point it's bits at the device bitmap.
            hbmDibSrc = EngCreateBitmap(pdsurf->sizl, ppdev->lDeltaScreen,
                                        ppdev->iBitmapFormat, BMF_TOPDOWN,
                                        pjScreen);

            // Associate the DIB surface with the driver.
            EngAssociateSurface((HSURF) hbmDibSrc, ppdev->hdevEng, 0);

            // Lock the DIB surface.
            psoSrc = EngLockSurface((HSURF) hbmDibSrc);
        }

        else // The device bitmap is on the host.
        {
            DISPDBG((PUNT_DBG_LEVEL, "    Source is device bitmap on host.\n"));
            psoSrc = pdsurf->pso;   // This is where it lives on the host.
        }
    }


    //
    // If the destination is a device bitmap, build a wrapper around it.
    //
    if ( psoDest && (psoDest->iType == STYPE_DEVBITMAP))
    {
        // Destination is a device bitmap.
        pdsurf = (PDSURF) psoDest->dhsurf;
        ppdev = pdsurf->ppdev;

        if ( pdsurf->pofm )  // If it's in the frame buffer.
        {
            DISPDBG((PUNT_DBG_LEVEL,
                "    Dest is device bitmap at (%d,%d).\n",
                (pdsurf->ptl.x), (pdsurf->ptl.y)));

            // Calculate the off-screen address.
            // This is the upper left pixel in the device bitmap.
            pjScreen = ppdev->pjScreen
                     + (pdsurf->ptl.x * ppdev->iBytesPerPixel)
                     + (pdsurf->ptl.y * ppdev->lDeltaScreen);

            // Create a DIB. Point it's bits at the device bitmap.
            hbmDibDest = EngCreateBitmap(pdsurf->sizl, ppdev->lDeltaScreen,
                                         ppdev->iBitmapFormat, BMF_TOPDOWN,
                                         pjScreen);

            // Associate the DIB surface with the driver.
            EngAssociateSurface((HSURF) hbmDibDest, ppdev->hdevEng, 0);

            // Lock the DIB surface.
            psoDest = EngLockSurface((HSURF) hbmDibDest);
        }

        else // The device bitmap is on the host.
        {
            DISPDBG((PUNT_DBG_LEVEL, "    Dest is device bitmap on host.\n"));
            psoDest = pdsurf->pso;
        }
    }


    //
    // We're fooling GDI into thinking it's drawing to memory, when it's really
    // drawing to the frame buffer.  This means GDI won't call DrvSync() before
    // drawing.
    //
    if (ppdev == 0)
    {
         ppdev = (PPDEV) psoDest->dhpdev;
         if (ppdev == 0)
             ppdev = (PPDEV) psoSrc->dhpdev;
    }
    ASSERTMSG(ppdev,"Panic.  No ppdev in PuntBitBlt()!");
    DrvSynchronize((DHPDEV) ppdev, NULL);

    // Now, call the GDI.
    bStatus = EngBitBlt(psoDest, psoSrc, psoMask, pco, pxlo, prclDest, pptlSrc,
                        pptlMask, pbo, pptlBrush, rop4);

    // Delete the wrappers if they are created.
    if (hbmDibSrc)
    {
        EngUnlockSurface(psoSrc);
        EngDeleteSurface((HSURF) hbmDibSrc);
    }
    if (hbmDibDest)
    {
        EngUnlockSurface(psoDest);
        EngDeleteSurface((HSURF) hbmDibDest);
    }

    DISPDBG((PUNT_DBG_LEVEL, "PuntBitBlt: Exit.\n"));

    // Return the status.
    return(bStatus);
}

#if SWAT6
/******************************************************************************\
* FUNCTION:             StripePatBlt
*
* DESCRIPTION:  Perform a PatBlt with striping.
*
* ON ENTRY:             ppdev           Pointer to physical device.
*                               x                       X coordinate of blit.
*                               y                       Y coordinate of blit.
*                               cx                      Width of blit.
*                               cy                      Height of blit.
*
* RETURNS:              void            Nothing.
\******************************************************************************/
void
StripePatBlt(
        PPDEV   ppdev,
        ULONG   x,
        ULONG   y,
        ULONG   cx,
        ULONG   cy
)
{
        ULONG cxWidth;
        ULONG TileWidth;

        // Determine number of pixels per tile.
        switch (ppdev->iBytesPerPixel)
        {
                case 1:
                        // 8-bpp.
                        TileWidth = (ULONG) ppdev->lTileSize;
                        break;

                case 2:
                        // 16-bpp.
                        TileWidth = (ULONG) (ppdev->lTileSize) / 2;
                        break;

                case 3:
                        // 24-bpp, perform the PatBlt at once since we don't have a nice
                        // number of pixels per tile.
                        REQUIRE(5);
                        LL_OP0(x, y);
                        LL_BLTEXT(cx, cy);
                        if (cx >= 0x391 && cy >= 0x24B)
                        {
                                ENDREQUIRE();
                        }
                        return;

                case 4:
                        // 32-bpp.
                        TileWidth = (ULONG) (ppdev->lTileSize) / 4;
                        break;
        }

        // Determine number of pixels left in first tile.
        cxWidth = TileWidth - (x & (TileWidth - 1));
        if ( (cxWidth >= cx) || (cy == 1) )
        {
                // PatBlt width fits in a single tile.
                REQUIRE(5);
                LL_OP0(x, y);
                LL_BLTEXT(cx, cy);
                return;
        }

        // Perform the PatBlt in the first tile.
        REQUIRE(5);
        LL_OP0(x, y);
        LL_BLTEXT(cxWidth, cy);
        cx -= cxWidth;
        x += cxWidth;

        // Keep looping until we reach the last tile of the PatBlt.
        while (cx > TileWidth)
        {
                // Perform the PatBlt on a complete tile (only x changes).
                REQUIRE(5);
                LL_OP0(x, y);
                LL_BLTEXT(TileWidth, cy);
                cx -= TileWidth;
                x += TileWidth;
        }

        // Perform the PatBlt in the last tile (only x changes).
        REQUIRE(5);
        LL_OP0(x, y);
        LL_BLTEXT(cx, cy);

} // StripePatBlt();
#endif // SWAT6
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\headless\mini\modeset.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    modeset.c

Abstract:

    This is the modeset code for the headless miniport driver.

Environment:

    kernel mode only

Notes:

--*/

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"
#include "headless.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,HeadlessQueryAvailableModes)
#pragma alloc_text(PAGE,HeadlessQueryNumberOfAvailableModes)
#endif

VP_STATUS
HeadlessQueryAvailableModes(
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns the list of all available available modes on the
    card.

Arguments:

    ModeInformation - Pointer to the output buffer supplied by the user.
        This is where the list of all valid modes is stored.

    ModeInformationSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
        for the data being returned.

    NO_ERROR if the operation completed successfully.

--*/

{
    PVIDEO_MODE_INFORMATION videoModes = ModeInformation;
    ULONG i;

    //
    // Find out the size of the data to be put in the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (ModeInformationSize < (*OutputSize =
            NumVideoModes * sizeof(VIDEO_MODE_INFORMATION)) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // For each mode supported by the card, store the mode characteristics
    // in the output buffer.
    //

    for (i = 0; i < NumVideoModes; i++, videoModes++) {

        videoModes->Length = sizeof(VIDEO_MODE_INFORMATION);
        videoModes->ModeIndex  = i;
        videoModes->VisScreenWidth = ModesHeadless[i].hres;
        videoModes->VisScreenHeight = ModesHeadless[i].vres;
        videoModes->NumberOfPlanes = 1;
        videoModes->BitsPerPlane = 4;
        videoModes->Frequency = 60;
        videoModes->XMillimeter = 320;        // temporary hardcoded constant
        videoModes->YMillimeter = 240;        // temporary hardcoded constant
        videoModes->NumberRedBits = 6;
        videoModes->NumberGreenBits = 6;
        videoModes->NumberBlueBits = 6;
        videoModes->RedMask = 0;
        videoModes->GreenMask = 0;
        videoModes->BlueMask = 0;
        videoModes->AttributeFlags = VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS |
               VIDEO_MODE_PALETTE_DRIVEN | VIDEO_MODE_MANAGED_PALETTE;
    }

    return NO_ERROR;

}

VP_STATUS
HeadlessQueryNumberOfAvailableModes(
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns the number of available modes for this particular
    video card.

Arguments:

    NumModes - Pointer to the output buffer supplied by the user. This is
        where the number of modes is stored.

    NumModesSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
        for the data being returned.

    NO_ERROR if the operation completed successfully.

--*/

{
    //
    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (NumModesSize < (*OutputSize = sizeof(VIDEO_NUM_MODES)) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Store the number of modes into the buffer.
    //

    NumModes->NumModes = NumVideoModes;
    NumModes->ModeInformationLength = sizeof(VIDEO_MODE_INFORMATION);

    return NO_ERROR;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\5465over.c ===
/**************************************************************************
***************************************************************************
*
*     Copyright (c) 1997, Cirrus Logic, Inc.
*                 All Rights Reserved
*
* FILE:         5465over.c
*
* DESCRIPTION:
*
* REVISION HISTORY:
*
* $Log:   \\uinac\log\log\laguna\ddraw\src\5465over.c  $
* 
*    Rev 1.75   19 May 1998 09:54:36   xcong
* Assign GfVdFormat in ChipIOReadBWRegs() for TV-Out support.
* 
*    Rev 1.74   07 Apr 1998 17:28:58   xcong
* Get CR1 and CR1E in ChipIOBWRead()
* 
*    Rev 1.73   Mar 30 1998 13:06:52   frido
* Changed some parenthesis so the Codewright source parser can find the
* functions.
* 
*    Rev 1.72   08 Jan 1998 10:45:28   xcong
* Don't pass lpDDHALData in ComputeVWPositionData() for NT.
* 
*    Rev 1.71   07 Jan 1998 17:55:32   xcong
* Delete *lpDDHALData in SetPostion() for NT only.
* 
* 
*    Rev 1.70   06 Jan 1998 14:43:54   xcong
* Pass lpDDHALData in CurrentVLine().
* 
*    Rev 1.69   06 Jan 1998 11:42:06   xcong
* Change pDriverData into local lpDDHALData for multi-monitor support.
* 
*    Rev 1.68   Dec 11 1997 14:03:28   frido
* PDR#11011: A workaround has been added to convert a "dummy"
* update into a SHOW update when certain criteria are met.
* 
*    Rev 1.67   Dec 10 1997 13:41:32   frido
* Merged from 1.62 branch.
* 
*    Rev 1.63.2.0   Dec 03 1997 14:44:54   frido
* PDR#11017. The hardware is broken when shrinking videos horizontally with
* RGB32 format. A software workaround has been added to disable overlay in
* this case.
* 
*    Rev 1.66   Dec 10 1997 13:32:08   frido
* Merged from 1.62 branch.
* 
*    Rev 1.65   14 Nov 1997 13:04:18   XCONG
* Undo the modification for dwOverlayOffset for NT.
* 
*    Rev 1.64   06 Nov 1997 15:46:14   XCONG
* When update dwOverlayOffset, update this variable for all the attached surf
* too.
* 
*    Rev 1.63.2.0   Dec 03 1997 14:44:54   frido
* PDR#11017. The hardware is broken when shrinking videos horizontally with
* RGB32 format. A software workaround has been added to disable overlay in
* this case.
* 
*    Rev 1.63   04 Nov 1997 13:41:34   RUSSL
* Fix for PDR #10815
*
*    Rev 1.62   04 Nov 1997 12:57:02   RUSSL
* Removed forcing of min stretch in 24bpp to start at 1000 (for new bweq code)
*
*    Rev 1.61   30 Oct 1997 14:34:18   RUSSL
* Mods to support new interface to bweqn code
* Moved KillOverlay function here from 5465bw.c
* ChipIOReadBWRegs reads additional regs that are new to the BWREGS struct
* Added code in ChipIOReadBWRegs to clear bits 4 & 7 (the 256 byte fetch
*   related bits) of the BWREGS Control2 value.  The bweqn should use
*   256 byte fetch off values, since we are disabling 256 byte fetch
*   when overlay or videoport surfaces are created.
*
*    Rev 1.60   08 Oct 1997 11:15:02   RUSSL
* Fix for NT40 build without overlay support
*
*    Rev 1.59   25 Sep 1997 17:33:40   RUSSL
* Modified HeapAlloc calls to use HEAP_ALLOC macro
*      and HeapFree calls to use HEAP_FREE macro
*
*    Rev 1.58   19 Sep 1997 14:35:04   bennyn
* Fixed NT4.0 5462/64 build problem
*
*    Rev 1.57   17 Sep 1997 16:27:20   RUSSL
* Looks like setting the HardwareOwner is FlipOverlayStatus is an NT only
* thing.
*
*    Rev 1.56   16 Sep 1997 15:28:38   bennyn
* Modified for NT DD overlay
*
*    Rev 1.55   04 Sep 1997 09:43:26   RUSSL
* Fixed up Xing's changes so they compile for NT
*
*    Rev 1.54   04 Sep 1997 10:07:52   XCONG
* Delete f256Fetch, since the code to disable 256 byte fetch is moved to
* surface.c, nobody use this variable anymore.
*
*    Rev 1.53   03 Sep 1997 18:40:12   XCONG
* Disable overlay in 640*480*32 at 85Hz by calling KillOverlay().
* This is temporary fix for PDR#10381.
*
*    Rev 1.52   03 Sep 1997 16:35:02   RUSSL
*
*    Rev 1.51   02 Sep 1997 12:35:48   RUSSL
* Added GET_SURFACE_DATA_PTR macro and modified relevant code to get ptr
* using macro.  This will minimize the remaining changes needed for NT.
*
*    Rev 1.50   29 Aug 1997 16:47:26   RUSSL
* Added support for NT
* It's not quite complete, we need to allocate a LP_SURFACE_DATA structure
*   for each overlay surface and store it somewhere in the DD_SURFACE_LOCAL
*   structure (this needs to be done by CreateSurface).  And then add code
*   in here to get access to that struct when necessary.  #pragma message's
*   indicate where.
* Removed code to disable 256 byte fetch, its done by CreateSurface32
*
*    Rev 1.49   15 Aug 1997 16:38:30   XCONG
* Put overlay source alignment back to 1.  This is screen alignment instead o
*
*    Rev 1.48   14 Aug 1997 16:47:42   XCONG
* If overlay window is created, disable 256 byte fetch.
* Move gwNormalDTTR initialization into CreateSurface function.
*
*    Rev 1.47   29 Jul 1997 15:29:14   XCONG
* For autoflip overlay make sure dwNumAutoFlip == 2
*
*    Rev 1.46   28 Jul 1997 09:19:46   RUSSL
* Modified GetOverlayFlipStatus to check arm bit in hw rather than determine
*  elapsed time since previous flip
* Added video window index argument to GetOverlayFlipStatus function
* Made dwNumVideoWindows a global var rather than static
* Moved GetVideoWindowIndex inline function to overlay.h
*
*    Rev 1.45   24 Jul 1997 17:50:14   RUSSL
* modified src alignment values reported in ddhalinfo
* fixed error with disabling dst colorkey at 24bpp, I was turning off
* src colorkey related caps bits
*
*    Rev 1.44   16 Jul 1997 17:15:32   XCONG
* Add and use dwOverlayOffset and more in SURFACE_DATA structure in order
* to eliminate global variables.
*
*    Rev 1.43   14 Jul 1997 13:11:50   RUSSL
* added ChipIOReadBWRegs (moved here from 5465bw.c)
*
*    Rev 1.42   11 Jul 1997 11:57:26   XCONG
* Fix ptich problem in FlipOverlay for interleaved surface.
*
*    Rev 1.41   11 Jul 1997 08:57:02   RUSSL
* Fixed y clipping of CLPL surfaces in FlipOverlaySurface and
*   ComputeVWPositionData
*
*    Rev 1.40   09 Jul 1997 15:27:44   RUSSL
* Implemented CLPL lobotomy mode
*   allocates a block of system memory for the app to write the UV data to,
*   when the app locks the surface the system memory addresses are returned
*   so the app writes to system memory, and when the app unlocks the surface,
*   the data is copied into the frame buffer.  The copy is done from left to
*   right a scanline at a time.  There appears to be a hw bug when writing
*   to aperture 3 from right to left.  Roughly every other 4 dwords is
*   dropped.  This bug showed up when allowing the Compcore MPEG player to
*   write directly to aperture 3.  (also see comments in SysToFBCopy)
* Added GetUserSettings to read user controllable options from registry
* Current user controllable settings are:
*   OverlayBW   - enables/disables use of bandwidth equation (default=enabled)
*   OverlayCLPL - enables/disables support for CLPL format (default=enabled)
* 	OverlayCLPLLobotomyMode - enables/disables above described CLPL
*                             lobotomy mode (default=enabled)
* For forward compatibility, assume future chips have one video window
*
*    Rev 1.39   30 Jun 1997 10:37:20   RUSSL
* Added global var to control whether or not CLPL is supported
* CLPL support is based on a registry key "OverlayCLPL", set to "on" to
*   enable CLPL, default is "off"
*
*    Rev 1.38   23 Jun 1997 10:50:10   RUSSL
* Modified for reduced size of CLPL surfaces
*
*    Rev 1.37   20 Jun 1997 13:47:44   RUSSL
* Enabled CLPL overlay surface support (aka YUV420 & YUVPLANAR)
* Enabled 32 bit overlay surface support
* Removed REQUIREs and HW_(UN)LOCK_SEMAPHOREs (they didn't do anything anyway)
* CreateSurface now returns an HRESULT
*
*    Rev 1.36   09 Jun 1997 13:46:22   XCONG
* In FlipOverlaySurface(), Update VW_CONTROL0 too for DDFLIP_EVEN.
*
*    Rev 1.35   03 Jun 1997 09:52:50   RUSSL
* Added setting of VWEnable bit in CONTROL0 register in SetPosition and
* FlipOverlaySurface functions
*
*    Rev 1.34   22 May 1997 16:27:46   RUSSL
* Disable overlay shrink at 24bpp
*
*    Rev 1.33   15 May 1997 17:36:38   RUSSL
* Set ddCaps.dwAlignStrideAlign to bytes per pixel in Init5465Overlay
* Set bNoOverlayInThisMode to TRUE if in interlaced mode
*
*    Rev 1.32   15 May 1997 15:48:20   XCONG
* Change all the BWE flags back (in bw.h).
*
*    Rev 1.31   15 May 1997 10:56:54   RUSSL
* Changed IsFormatValid to return an HRESULT rather than a BOOL so
* CanCreateSurface32 can return a reasonable error code if the surface
* can't be created
*
*    Rev 1.30   13 May 1997 09:53:04   RUSSL
* Removed code in Init5465Info that was initializing the VW0_TEST0 register
*
*    Rev 1.29   12 May 1997 17:22:32   XCONG
* Change wVPortCreated in VideoPortEx into wNotify
*
*    Rev 1.28   10 May 1997 12:51:02   EDWINW
* Fix PDR 9574.  DestroySurface trashes tile size when trying to restore the
* DTTR's FIFO threshold.
*
*    Rev 1.27   09 May 1997 16:26:36   XCONG
* Only check VPE_ON and OVERLAY_ON flags in DX5
*
*    Rev 1.26   09 May 1997 11:10:22   XCONG
* Uses the flags in overlay.h for BWE flags. Befor save and restore
* gwNormIDTTR check VPE is still running or not, because VPE will do the same
* thing.
*
*    Rev 1.25   08 May 1997 17:57:40   XCONG
* Make the BWE variables global.  Set uDispDepth as the same as
* sourc depth instead of graphic depth.
*
*    Rev 1.24   24 Apr 1997 14:36:46   XCONG
* For SW playback only use smooth-interlaced mode when BOB and INTERLEAVE
* flags are both set.
*
*    Rev 1.23   24 Apr 1997 12:02:54   RUSSL
* Reenabled writing 0x52 to TEST0 reg on 5465AC if bw eqn is in use.
* 800x600x16 @ 85Hz looks like it's running on the hairy edge of
* stability with this.  All other modes (at all resolutions, colordepths
* and refresh rates) with sufficient bandwidth to use overlay looked
* stable although there is still some static in some modes.
*
*    Rev 1.22   17 Apr 1997 09:38:22   RUSSL
* Fix for PDR #9339, disable destination colorkeying support at 24bpp.
*   This looks like its a HWBUG.  This code can be disabled by defining
*   HWBUG_24BPP_DST_COLORKEY as zero.
* Write DTTR FIFO value returned by ChipIsEnoughBandwidth, original DTTR
*   setting is saved in a global var which is restored when final overlay
*   surface is destroyed
*
*    Rev 1.21   16 Apr 1997 10:19:28   RUSSL
* Had to update list of parms passed to GetBooleanSetting
*
*    Rev 1.20   15 Apr 1997 17:46:46   RUSSL
* Added use of PDC's bandwidth equation
* Added use of registry key/system.ini entry to disable use of BWEqn
* Removed IsSufficientBandwidth functions
* Modified Init5465Info to determine min & max zoom factors in current
*   mode by calling BWEqn
* ComputeVWFifoThreshold sets VW fifo threshold to value returned previously
*   by bandwidth equation (or it uses 8 if use of BWEqn is disabled)
*
*    Rev 1.19   04 Apr 1997 16:11:56   XCONG
* Add support for SW double-buffer and BOB palyback. Change the way to
* calculate VACCUM_STP for interleaved BOB.
*
*    Rev 1.18   03 Apr 1997 09:58:42   RUSSL
* Disable writing 0x42 or 0x52 to TEST0 reg, it's more grief than it's worth
*   Wait until we get a real bandwidth equation
* Made IsFormatValid always return FALSE when we're in an interlaced mode,
*   this essentially disables use of overlay in interlaced modes
*
*    Rev 1.17   28 Mar 1997 14:57:26   RUSSL
* Need to write 0x42 to TEST0 in 24bpp modes
* Display driver now puts 32bit linear address of pDevice in
*   pDriverData->lpPDevice, so don't need to call MapSLFix
*
*    Rev 1.16   24 Mar 1997 22:54:58   XCONG
* Add auto-flip overlay support. Include SSD_STRT_ADDR in tagVWDATA for
* all the version of DDRAW.
*
*    Rev 1.15   24 Mar 1997 16:44:56   RUSSL
* Changed CreateSurface so that CreateSurface32 fills in the blocksize, etc.
*
*    Rev 1.14   24 Mar 1997 12:12:40   RUSSL
* Added write of 0x52 to TEST0 reg on 5465AC, this enables some hw fixes
*
*    Rev 1.13   19 Mar 1997 11:47:40   cjl
* Simply added line to include new ddshared.h file.
*
*    Rev 1.12   12 Mar 1997 14:59:00   RUSSL
* replaced a block of includes with include of precomp.h for
*   precompiled headers
* Removed unneeded pragma message related to mapping in YUY2 aperture
*
*    Rev 1.11   07 Mar 1997 12:43:22   RUSSL
* Modified DDRAW_COMPAT usage
* Merged in PDC's VPE code for DX5
* Made IsSufficientBandwidth5465 global rather than static
*
*    Rev 1.10   24 Feb 1997 13:49:52   RUSSL
* Enabled YUY2 format
* Added RBGtoYCbCr function
* Modified DetermineVWColorKeyData to handle source color keying of UYVY
*   and YUY2 surfaces
*
*    Rev 1.9   14 Feb 1997 10:01:14   RUSSL
* Added more conditional compilation flags to enable/disable horizontal
*   mirroring, use of REQUIRE for qfree checking and use of HW_IN_USE
*   driver semaphore.
* If building debug version, change inline functions to not be inline.
*   WINICE can't deal with inline functions, so source code doesn't line
*   up correctly.
* Added ASSERT to make sure post immediately bit is clear in TEST0 reg
*   before updating video window registers
* Ignore DDOVER_DDFX flag in UpdateSurface because Microsoft's WHQL Overfly
*   test program sets this flag but fills overlayFX.dwDDFX with junk.
*   In some cases they set the DDOVERFX_MIRRORLEFTRIGHT bit even though
*   we don't even say we support that capability!  In order to get Overfly
*   to work, we need to ignore the overlayFX.dwDDFX flags that we don't
*   support (which is currently all of them)  This fixes BPR #8528
*
*    Rev 1.8   04 Feb 1997 14:15:48   RUSSL
* Added check in IsFormatValid to see if VPM is using the hardware
* Added SaveRectangles to reduce duplicate code in UpdateSurface
* Adjusted zoom code calculation for x shrink so don't go past end of src
*
*    Rev 1.7   31 Jan 1997 08:59:30   RUSSL
* Added better video window support checking based on chip id in
*   Init5465Overlay
* Adjusted init code alignment requirements reported to ddraw
* Addressed most of pragma message statements
* Fixed bug in FlipOverlaySurface when surface is clipped
* Enabled overlay shrink caps and added shrink zoom code calculations
*
*    Rev 1.6   29 Jan 1997 18:00:30   RUSSL
* Added use of require macro before register writes
* Modified zoom code calculations
*
*    Rev 1.5   28 Jan 1997 17:34:58   RUSSL
* VEND is the last line shown by the overlay
* Karl and I figured out how to make source color key work (at least at 16bpp)
*   hopefully the code matches what we did manually.  We need an app
*   that uses source color keying to really test it.
*
*    Rev 1.4   28 Jan 1997 15:29:42   RUSSL
* destination color keying is actually done using the hardware CLRKEY
*   registers and setting OCCLUDE in CONTROL0 to 1 (the documentation
*   appears to have the source color key settings & the destination color
*   key settings swapped)
* source color keying doesn't appear to work
*
*    Rev 1.3   27 Jan 1997 19:10:26   RUSSL
* Use a variable dwNumVideoWindows rather than a hardcoded define
* Added WaitForArmToClear, Set5465FlipDuration & PanOverlay1_Init
* Made IsFormatValid return TRUE only for UYVY overlay surfaces for now
* Made CreateSurface use rectangular allocation, specify block size for
*   rgb surfaces if we are managing surface creation, let CreateSurface
*   return NOTHANDLED so DDraw will fill in the surface ptr
* Added error checking for dwReserved1 of local surface struct in case
*   it's NULL
* Added additional debug output
* Put code in ComputeVWZoomCodes, ComputeVWPosData, DetermineColorKeyData,
*   ComputeVWFifoThreshold
* Added programming of the hw registers in RegInitVideoVW & RegMoveVideoVW
*
*    Rev 1.2   21 Jan 1997 15:44:40   RUSSL
* Okay this didn't compile and link last time
*
*    Rev 1.1   21 Jan 1997 14:55:14   RUSSL
* Port of 5480 overlay code from CirrusMM driver to 5465
*
*    Rev 1.0   15 Jan 1997 10:36:22   RUSSL
* Initial revision.
*
***************************************************************************
***************************************************************************/

/***************************************************************************
* I N C L U D E S
****************************************************************************/

#include "precomp.h"

#if defined WINNT_VER35      // WINNT_VER35
// If WinNT 3.5 skip all the source code
#elif defined (NTDRIVER_546x)
// If WinNT 4.0 and 5462/64 build skip all the source code
#elif defined(WINNT_VER40) && !defined(OVERLAY)
// if nt40 without overlay, skip all the source code
#else

#ifndef WINNT_VER40
#include "ddshared.h"
#include "flip.h"
#include "surface.h"
#include "blt.h"
#include "overlay.h"

#if DDRAW_COMPAT >= 50
#include "vp.h"
#endif

#include "settings.h"
#include "5465bw.h"
#include "swat.inc"
#endif

/***************************************************************************
* D E F I N E S
****************************************************************************/

#ifdef WINNT_VER40
#define ENABLE_YUY2                 0
#define ENABLE_YUVPLANAR            0
#define DISABLE_MOST_MODES          0
#else
#define ENABLE_YUY2                 1
#define ENABLE_YUVPLANAR            1
#define DISABLE_MOST_MODES          0
#endif

#define ENABLE_SD_RGB32             1

#define ENABLE_MIRRORING            0

#define HWBUG_24BPP_DST_COLORKEY    1

#ifdef DEBUG
#define INLINE
#else
#define INLINE  __inline
#endif

// VW_CAP0 bits
#define VWCAP_VW_PRESENT      0x00000001

// VW_CONTROL1 bits
#define VW_ByPassClrSpc       0x00000002
#define VW_YShrinkEn          0x00000001

// VW_CONTROL0 bits
#define VW_XShrinkBy2         0x80000000
#define VW_ClkMode2x          0x40000000
#define VW_FIFO_THRSH_EN      0x20000000
#define VW_ALPHA_KEYCMP_EN    0x10000000

#define VW_DB_VPORT_ID_MASK   0x0F000000
#define VW_DB_VSM_ID_MASK     0x00F00000
#define VW_DB_CTL_MASK        0x000F0000

#define VW_SD_FRMT_MASK       0x0000FF00
#define VW_OCCLUDE_MASK       0x000000F0

#define VW_SMTH_INT           0x00000008
#define VW_HMIRR_EN           0x00000004
#define VW_VWE                0x00000002
#define VW_ARM                0x00000001

// Source Data Formats for SD_FRMT
#define SD_YUV422             0x00    // ITU 601 compliant YUV data
#define SD_YUV420             0x03    // ITU 601 compliant YUV data
#define SD_YUV422_FS          0x04    // Full Scale YUV data
#define SD_YVU420_FS          0x07    // Full Scale YUV data
#define SD_RGB16_555          0x08    // 5:5:5
#define SD_RGB16_565          0x09    // 5:6:5
#define SD_RGB32              0x0B    // ARGB

#define SD_FRMT_SHIFT         8

// Occlude types for OCCLUDE
#define NO_OCCLUSION          0       // video window always displayed
#define COLOR_KEY             1       // destination color keying
#define CHROMA_KEY            2       // source color keying

#define OCCLUDE_SHIFT         4

// VW_TEST0 bits
#define VW_PostImed           1
#define VWVRepEnable          0x4

// defines used in Init5465Info()
#define SRC_WIDTH              160
#define SRC_HEIGHT             120
#define MAX_ZOOM              8000
#define MIN_ZOOM               500
#define ZOOM_STEP              100

#ifdef WINNT_VER40
#define lpDDHALData       ((DRIVERDATA *)(&(ppdev->DriverData)))
#define ASSERT(x)
#define DRAW_ENGINE_BUSY  DrawEngineBusy(lpDDHALData)
#endif

#ifdef WINNT_VER40
#define GET_SURFACE_DATA_PTR(lpSurface)   (LP_SURFACE_DATA)((lpSurface)->dwReserved1)
#else
#define GET_SURFACE_DATA_PTR(lpSurface)   (LP_SURFACE_DATA)((lpSurface)->dwReserved1)
#endif

#if ENABLE_256_BYTE_FETCH
// bit defs for PERFORMANCE register
#define ECO_256_BYTES_FIX_EN      0x4000
// bit defs for CONTROL2 register
#define MONO_SAFETY_256           0x0080
#define BYTE_REQ_256              0x0010
#endif

/***************************************************************************
* T Y P E D E F S
****************************************************************************/

typedef struct tagVWDATA
{
  WORD  HSTRT;
  WORD  HSDSZ;
  WORD  HEND;
  DWORD HACCUM_STP;
  DWORD HACCUM_SD;
  WORD  VSTRT;
  WORD  VEND;
  DWORD VACCUM_STP;
  DWORD VACCUM_SDA;
  DWORD VACCUM_SDB;
  DWORD PSD_STRT_ADDR;
  DWORD SSD_STRT_ADDR;
#if ENABLE_YUVPLANAR
  DWORD PSD_UVSTRT_ADDR;
  DWORD SSD_UVSTRT_ADDR;
#endif
  WORD  SD_PITCH;
  DWORD CLRKEY_MIN;
  DWORD CLRKEY_MAX;
  DWORD CHRMKEY_MIN;
  DWORD CHRMKEY_MAX;
//  WORD  BRIGHT_ADJ;
//  BYTE  Z_ORDER;
  WORD  FIFO_THRSH;
  DWORD CONTROL1;
  DWORD CONTROL0;
//  DWORD CAP1;
//  DWORD CAP0;
//  DWORD TEST0;
} VWDATA;

typedef struct tagUSERSETTINGS
{
  BOOL  *pVar;
  char  *pRegKey;
  BOOL  defaultVal;
} USERSETTINGS;

#if ENABLE_YUVPLANAR
// structure for CLPL (YUV planar) surface
typedef struct tagCLPLInfo
{
  LPVOID  fpYSurface;     // Y data in first aperture
  LPVOID  fpUSurface;     // U data in 0-2M of fourth aperture
  LPVOID  fpVSurface;     // V data in 2-4M of fourth aperture

  // pointers for CLPLLobotomyMode
  LPVOID  fpUSystemSurface;
  LPVOID  fpVSystemSurface;
  LPVOID  fpRealUSurface; // U data in 0-2M of fourth aperture
  LPVOID  fpRealVSurface; // V data in 2-4M of fourth aperture
} CLPLInfo;

typedef CLPLInfo  *LPCLPLSURFACE;
#endif

/***************************************************************************
* E X T E R N A L   V A R I A B L E S
****************************************************************************/

#ifndef WINNT_VER40
#if DDRAW_COMPAT >= 50
 extern WORD gwNotify;       //#xc
#endif
#endif

/***************************************************************************
* S T A T I C   V A R I A B L E S
****************************************************************************/

#ifdef WINNT_VER40

// For NT these are in ppdev->DriverData
#define bUseBWEqn               ppdev->DriverData.bUseBWEqn
#define bNoOverlayInThisMode    ppdev->DriverData.bNoOverlayInThisMode

#define lpHardwareOwner         ppdev->DriverData.lpHardwareOwner
#define lpColorSurfaceVW        ppdev->DriverData.lpColorSurfaceVW
#define lpSrcColorSurfaceVW     ppdev->DriverData.lpSrcColorSurfaceVW

#define grOverlaySrc            ppdev->DriverData.grOverlaySrc
#define grOverlayDest           ppdev->DriverData.grOverlayDest
#define gdwFourccVW             ppdev->DriverData.gdwFourccVW
#if ENABLE_MIRRORING
#define bIsVWMirrored           ppdev->DriverData.bIsVWMirrored
#endif

#define gdwAvailVW              ppdev->DriverData.gdwAvailVW              // Next available video window
//#define gwZOrder                ppdev->DriverData.gwZOrder                // default primary on top.
#define gdwColorKey             ppdev->DriverData.gdwColorKey
#define gdwSrcColorKeyLow       ppdev->DriverData.gdwSrcColorKeyLow
#define gdwSrcColorKeyHigh      ppdev->DriverData.gdwSrcColorKeyHigh
#define gdwDestColorKeyOwnerVW  ppdev->DriverData.gdwDestColorKeyOwnerVW  // DstColorKey owner (NULL or FLG_VWX)
#define gdwSrcColorKeyOwnerVW   ppdev->DriverData.gdwSrcColorKeyOwnerVW   // SrcColorKey owner (NULL or FLG_VWX)

#define giOvlyCnt               ppdev->DriverData.giOvlyCnt
#if ENABLE_YUVPLANAR                                            // YUV Planar surfaces cannot exist
#define giPlanarCnt             ppdev->DriverData.giPlanarCnt   // with other overlay surfaces
#define bCLPLLobotomyMode       ppdev->DriverData.bCLPLLobotomyMode
#endif
//#define gbDoubleClock           ppdev->DriverData.gbDoubleClock

#if DISABLE_MOST_MODES
#define bDisableMostModes       ppdev->DriverData.bDisableMostModes
#endif

#else   // Win95

ASSERTFILE("5465over.c");

STATIC DIBENGINE  *pPDevice;
STATIC BOOL       bUseBWEqn;
STATIC BOOL       bNoOverlayInThisMode;

STATIC LPDDRAWI_DDRAWSURFACE_LCL lpHardwareOwner[MAX_VIDEO_WINDOWS];
STATIC LPDDRAWI_DDRAWSURFACE_LCL lpColorSurfaceVW[MAX_VIDEO_WINDOWS];
STATIC LPDDRAWI_DDRAWSURFACE_LCL lpSrcColorSurfaceVW[MAX_VIDEO_WINDOWS];

STATIC RECTL      grOverlaySrc[MAX_VIDEO_WINDOWS];
STATIC RECTL      grOverlayDest[MAX_VIDEO_WINDOWS];
STATIC DWORD      gdwFourccVW[MAX_VIDEO_WINDOWS];
#if ENABLE_MIRRORING
STATIC BOOL       bIsVWMirrored[MAX_VIDEO_WINDOWS];
#endif

STATIC DWORD      gdwAvailVW;    // Next available video window
//STATIC WORD       gwZOrder = OVERLAYZ_PRIMARY_ON_TOP; // default primary on top.
STATIC DWORD      gdwColorKey;
STATIC DWORD      gdwSrcColorKeyLow;
STATIC DWORD      gdwSrcColorKeyHigh;
STATIC DWORD      gdwDestColorKeyOwnerVW = 0; // DstColorKey owner (NULL or FLG_VWX)
STATIC DWORD      gdwSrcColorKeyOwnerVW = 0;  // SrcColorKey owner (NULL or FLG_VWX)

STATIC int        giOvlyCnt[MAX_VIDEO_WINDOWS];
#if ENABLE_YUVPLANAR                          // YUV Planar surfaces cannot exist
STATIC int        giPlanarCnt = 0;            // with other overlay surfaces
STATIC BOOL       bCLPLLobotomyMode;
#endif
//STATIC BOOL       gbDoubleClock;

#if DISABLE_MOST_MODES
STATIC BOOL       bDisableMostModes;
#endif

#endif

/***************************************************************************
* G L O B A L   V A R I A B L E S
****************************************************************************/

#ifdef WINNT_VER40

// For NT these are in ppdev->DriverData
#define gsOverlayFlip       ppdev->DriverData.gsOverlayFlip
#define gsProgRegs          ppdev->DriverData.gsProgRegs
#define gvidConfig          ppdev->DriverData.gvidConfig
#define gwNormalDTTR        ppdev->DriverData.gwNormalDTTR
#define dwNumVideoWindows   ppdev->DriverData.dwNumVideoWindows

#if ENABLE_YUVPLANAR
#define bEnableCLPL         ppdev->DriverData.bEnableCLPL
#endif

#else

OVERLAYFLIPRECORD gsOverlayFlip;

PROGREGS    gsProgRegs = {0};  //Make them global so VPE can use the same ones
VIDCONFIG   gvidConfig = {0};
WORD        gwNormalDTTR;
DWORD       dwNumVideoWindows;

#if ENABLE_YUVPLANAR
BOOL        bEnableCLPL;
#endif

#endif

/***************************************************************************
* S T A T I C   F U N C T I O N   P R O T O T Y P E S
****************************************************************************/

#ifdef WINNT_VER40

static void    GetUserSettings      ( PDEV * );

STATIC HRESULT IsFormatValid        ( PDEV*, DWORD, DWORD );
STATIC HRESULT CreateOverlaySurface ( PDEV*, PDD_SURFACE_LOCAL, DWORD );
STATIC VOID    DestroyOverlaySurface( PDEV*, PDD_DESTROYSURFACEDATA );
STATIC DWORD   FlipOverlaySurface   ( PDEV*, PDD_FLIPDATA );
STATIC DWORD   LockSurface          ( PDEV*, PDD_LOCKDATA );
STATIC VOID    UnlockSurface        ( PDEV*, PDD_UNLOCKDATA );
STATIC VOID    SetColorKey          ( PDEV*, PDD_SETCOLORKEYDATA );
STATIC DWORD   UpdateSurface        ( PDEV*, PDD_UPDATEOVERLAYDATA );
STATIC DWORD   SetPosition          ( PDEV*, PDD_SETOVERLAYPOSITIONDATA );
STATIC DWORD   GetOverlayFlipStatus ( PDEV*, FLATPTR, DWORD );

STATIC BOOL    RegInitVideoVW ( PDEV*, DWORD, PDD_SURFACE_LOCAL );
STATIC VOID    RegMoveVideoVW ( PDEV*, DWORD, PDD_SURFACE_LOCAL );

#else

static void    GetUserSettings      ( void );

STATIC HRESULT IsFormatValid        ( LPGLOBALDATA, DWORD, DWORD );
STATIC HRESULT CreateSurface        ( LPDDRAWI_DDRAWSURFACE_LCL, DWORD,LPGLOBALDATA );
STATIC VOID    DestroySurface       ( LPDDHAL_DESTROYSURFACEDATA );
STATIC DWORD   FlipOverlaySurface   ( LPDDHAL_FLIPDATA );
STATIC DWORD   LockSurface          ( LPDDHAL_LOCKDATA );
STATIC VOID    UnlockSurface        ( LPDDHAL_UNLOCKDATA );
STATIC VOID    SetColorKey          ( LPDDHAL_SETCOLORKEYDATA);
STATIC DWORD   UpdateSurface        ( LPDDHAL_UPDATEOVERLAYDATA );
STATIC DWORD   SetPosition          ( LPDDHAL_SETOVERLAYPOSITIONDATA );
STATIC DWORD   GetOverlayFlipStatus (LPGLOBALDATA, FLATPTR, DWORD );

STATIC BOOL    RegInitVideoVW ( DWORD, LPDDRAWI_DDRAWSURFACE_LCL,LPGLOBALDATA );
STATIC VOID    RegMoveVideoVW ( DWORD, LPDDRAWI_DDRAWSURFACE_LCL,LPGLOBALDATA );

#endif

/***************************************************************************
* E X T E R N A L   F U N C T I O N   P R O T O T Y P E S
****************************************************************************/

#if WINNT_VER40
extern int  CurrentVLine  (PDEV *);
extern VOID GetFormatInfo (LPDDPIXELFORMAT, LPDWORD, LPDWORD);
#endif
#ifdef USE_OLD_BWEQ
extern BOOL KillOverlay
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
#endif
  WORD wScreenX,
  UINT uScreenDepth
); //fix PDR#10381
#endif

BOOL ChipIOReadBWRegs
(
#ifdef WINNT_VER40
  PDEV      *ppdev,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  LPBWREGS  pBWRegs
);

/***************************************************************************
*
* FUNCTION:     MakeVideoWindowFlag
*
* DESCRIPTION:
*
****************************************************************************/

static INLINE DWORD
MakeVideoWindowFlag ( DWORD dwVWIndex )
{
  ASSERT(dwNumVideoWindows > dwVWIndex);
  return ((1 << dwVWIndex) << FLG_VW_SHIFT);
}

#if 0
/***************************************************************************
*
* FUNCTION:     GetDoubleClockStatus
*
* DESCRIPTION:
*
****************************************************************************/

static INLINE DWORD
GetDoubleClockStatus ( VOID )
{
#pragma message("GetDoubleClockStatus not implemented!")
  return FALSE;
}
#endif

/***************************************************************************
*
* FUNCTION:     GetDDHALContext
*
* DESCRIPTION:
*               Get shared data structure (SDATA) pointer
****************************************************************************/
#ifndef WINNT_VER40
INLINE LPGLOBALDATA  GetDDHALContext( LPDDRAWI_DIRECTDRAW_GBL lpGb )
{
#if (DDRAW_COMPAT >= 50)
    if(lpGb->dwReserved3)       //the SDATA pointer is passed by dwReserved3
                                //for DX50    
      return (LPGLOBALDATA)lpGb->dwReserved3;
    else
#endif
     return pDriverData;
}
#endif

/***************************************************************************
*
* FUNCTION:     IsHardwareInUseVW
*
* DESCRIPTION:
*
****************************************************************************/

static INLINE BOOL IsVWHardwareInUse
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD dwVWIndex
)
{
  ASSERT(dwNumVideoWindows > dwVWIndex);
  if (VW_VWE & ((PVGAR)lpDDHALData->RegsAddress)->VideoWindow[dwVWIndex].grVW_CONTROL0)
    return TRUE;
  return FALSE;
}

/***************************************************************************
*
* FUNCTION:     WaitForArmToClear
*
* DESCRIPTION:
*
****************************************************************************/

static INLINE VOID WaitForVWArmToClear
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD dwVWIndex
)
{
  // wait for previous register writes to post
  // the hardware clears the ARM bit at that time
  ASSERT(dwNumVideoWindows > dwVWIndex);
  while (((PVGAR)lpDDHALData->RegsAddress)->VideoWindow[dwVWIndex].grVW_CONTROL0 & VW_ARM)
    ;
}

/***************************************************************************
*
* FUNCTION:     EnableOverlay
*
* DESCRIPTION:
*
****************************************************************************/

static INLINE VOID EnableOverlay
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD dwVWIndex
)
{
  ASSERT(dwNumVideoWindows > dwVWIndex);
#ifdef WINNT_VER40
  WaitForVWArmToClear(ppdev,dwVWIndex);
#else
  WaitForVWArmToClear(lpDDHALData,dwVWIndex);
#endif
  ((PVGAR)lpDDHALData->RegsAddress)->VideoWindow[dwVWIndex].grVW_CONTROL0 |= (VW_VWE | VW_ARM);
}

/***************************************************************************
*
* FUNCTION:     DisableOverlay
*
* DESCRIPTION:
*
****************************************************************************/

static INLINE VOID DisableOverlay
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD dwVWIndex
)
{
  ASSERT(dwNumVideoWindows > dwVWIndex);
#ifdef WINNT_VER40
  WaitForVWArmToClear(ppdev,dwVWIndex);
#else
  WaitForVWArmToClear(lpDDHALData,dwVWIndex);
#endif
  ((PVGAR)lpDDHALData->RegsAddress)->VideoWindow[dwVWIndex].grVW_CONTROL0 &=
                ~(VW_FIFO_THRSH_EN | VW_VWE);
  ((PVGAR)lpDDHALData->RegsAddress)->VideoWindow[dwVWIndex].grVW_CONTROL0 |= VW_ARM;
}

/***************************************************************************
*
* FUNCTION:     Set5465FlipDuration
*
* DESCRIPTION:
*
****************************************************************************/

VOID Set5465FlipDuration
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
#endif
  DWORD dwFlipDuration
)
{
  gsOverlayFlip.dwFlipDuration = dwFlipDuration;
}

/***************************************************************************
*
* FUNCTION:     GetUserSettings
*
* DESCRIPTION:
*
****************************************************************************/

VOID GetUserSettings
(
#ifdef WINNT_VER40
  PDEV  *ppdev
#else
  VOID
#endif
)
{
#ifdef WINNT_VER40

#pragma message("GetUserSettings: Where are laguna settings stored in the NT registry?")
  bUseBWEqn = TRUE;

#if ENABLE_YUVPLANAR
  bEnableCLPL = TRUE;
  bCLPLLobotomyMode = TRUE;
#endif

#else  // else Win95
  static const USERSETTINGS   UserSettings[] =
  {
    { &bUseBWEqn,         "OverlayBW",               TRUE },
#if ENABLE_YUVPLANAR
    { &bEnableCLPL,       "OverlayCLPL",             TRUE },
    { &bCLPLLobotomyMode, "OverlayCLPLLobotomyMode", TRUE },
#endif
#if DISABLE_MOST_MODES
    { &bDisableMostModes, "OverlayBWHack",           TRUE },
#endif
  };

  const USERSETTINGS *pUserSetting;


  for (pUserSetting = &UserSettings[0];
       pUserSetting < &UserSettings[sizeof(UserSettings)/sizeof(UserSettings[0])];
       pUserSetting++)
  {
    *(pUserSetting->pVar) = pUserSetting->defaultVal;
    GetBooleanSetting(pUserSetting->pRegKey,
                      pUserSetting->pVar,
                      LOCATION_OF_3D_PERFORMANCE);
  }
#endif
}

/***************************************************************************
*
* FUNCTION:     Init5465Overlay
*
* DESCRIPTION:
*
****************************************************************************/

VOID Init5465Overlay
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
  DWORD           dwChipType,
  PDD_HALINFO     pDDHALInfo,
  LPOVERLAYTABLE  pOverlayTable
#else
  DWORD           dwChipType,
  LPDDHALINFO     pDDHALInfo,
  LPOVERLAYTABLE  pOverlayTable,
  LPGLOBALDATA    lpDDHALData
#endif
)
{
  DWORD   dwNumFourCCs;


#ifdef WINNT_VER40
  GetUserSettings(ppdev);
#else
  GetUserSettings();
#endif

  if (! bUseBWEqn)
    gsProgRegs.VW0_FIFO_THRSH = 8;

  // We should check the capabilities register on the chip
  // but it's busted
#ifdef WINNT_VER40
  if (CL_GD5465 == dwChipType)
#else
  if (GD5465_PCI_DEVICE_ID == dwChipType)
#endif
    dwNumVideoWindows = 1;
  else
  {
#if 1
    dwNumVideoWindows = 1;
#else
    int     i;
    PVGAR   pREG = (PVGAR)lpDDHALData->RegsAddress;

    dwNumVideoWindows = 0;
    for (i = 0; i < MAX_VIDEO_WINDOWS; i++)
    {
      if (VWCAP_VW_PRESENT & pREG->VideoWindow[i].grVW_CAP0)
        dwNumVideoWindows++;
    }
#endif
  }

#ifdef WINNT_VER40
  if (NULL != pDDHALInfo)
#endif
  {
    pDDHALInfo->ddCaps.dwMaxVisibleOverlays  = dwNumVideoWindows;
    pDDHALInfo->ddCaps.dwCurrVisibleOverlays = 0;

#ifndef WINNT_VER40
    pPDevice = (DIBENGINE *)lpDDHALData->lpPDevice;
#endif

  // Fill in the caps
    pDDHALInfo->ddCaps.dwCaps |= DDCAPS_OVERLAY
                              |  DDCAPS_OVERLAYFOURCC
                              |  DDCAPS_OVERLAYSTRETCH
                              |  DDCAPS_ALIGNSTRIDE
                              |  DDCAPS_OVERLAYCANTCLIP
                              ;

    pDDHALInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_OVERLAY
                                      ;

    pDDHALInfo->ddCaps.dwFXCaps |= DDFXCAPS_OVERLAYARITHSTRETCHY
                                |  DDFXCAPS_OVERLAYSTRETCHX
                                |  DDFXCAPS_OVERLAYSTRETCHY
                                |  DDFXCAPS_OVERLAYSHRINKX
                                |  DDFXCAPS_OVERLAYSHRINKY
#if ENABLE_MIRRORING
                                |  DDFXCAPS_OVERLAYMIRRORLEFTRIGHT
#endif
                                ;
  }

  /* FOURCCs supported */
#if (MAX_FOURCCS < 3)
#error dwFourCC array too small
#endif
  dwNumFourCCs = 0;
  lpDDHALData->dwFourCC[dwNumFourCCs++] = FOURCC_UYVY;
#if ENABLE_YUY2
  lpDDHALData->dwFourCC[dwNumFourCCs++] = FOURCC_YUY2;
#endif
#if ENABLE_YUVPLANAR
  // add CLPL fourcc if registry key set to "on"
  if (bEnableCLPL)
    lpDDHALData->dwFourCC[dwNumFourCCs++] = FOURCC_YUVPLANAR;
#endif

#ifdef WINNT_VER40
  if (NULL != pDDHALInfo)
#endif
  {
    pDDHALInfo->ddCaps.dwNumFourCCCodes = dwNumFourCCs;

    // say we can handle byte alignment and any byte width
    pDDHALInfo->ddCaps.dwAlignBoundarySrc  = 1;   // src rect x byte alignment
    pDDHALInfo->ddCaps.dwAlignSizeSrc      = 1;   // src rect x byte size
    pDDHALInfo->ddCaps.dwAlignBoundaryDest = 1;   // dst rect x byte alignment
    pDDHALInfo->ddCaps.dwAlignSizeDest     = 1;   // dst rect x byte size
    // stride alignment
#ifdef WINNT_VER40
    pDDHALInfo->ddCaps.dwAlignStrideAlign = ppdev->cxMemory;
#else
    pDDHALInfo->ddCaps.dwAlignStrideAlign = pPDevice->deWidthBytes;
#endif

    pDDHALInfo->ddCaps.dwMinOverlayStretch = 500;   // min stretch is 0.5:1
    pDDHALInfo->ddCaps.dwMaxOverlayStretch = 8000;  // max stretch is 8:1
#ifdef WINNT_VER40
    ppdev->DriverData.dwMinOverlayStretch = 500;
    ppdev->DriverData.dwMaxOverlayStretch = 8000;
#endif
    pDDHALInfo->vmiData.dwOverlayAlign     = 8 * 8; // qword alignment in bits
  }

  // Initialize OverlayTable function pointers
  pOverlayTable->pfnCanCreateSurface = IsFormatValid;
#ifdef WINNT_VER40
  pOverlayTable->pfnCreateSurface    = CreateOverlaySurface;
  pOverlayTable->pfnDestroySurface   = DestroyOverlaySurface;
#else
  pOverlayTable->pfnCreateSurface    = CreateSurface;
  pOverlayTable->pfnDestroySurface   = DestroySurface;
#endif
  pOverlayTable->pfnLock             = LockSurface;
  pOverlayTable->pfnUnlock           = UnlockSurface;
  pOverlayTable->pfnSetColorKey      = SetColorKey;
  pOverlayTable->pfnFlip             = FlipOverlaySurface;
  pOverlayTable->pfnUpdateOverlay    = UpdateSurface;
  pOverlayTable->pfnSetOverlayPos    = SetPosition;
  pOverlayTable->pfnGetFlipStatus    = GetOverlayFlipStatus;

  // do mode specific initialization
#ifdef WINNT_VER40
  if (NULL != pDDHALInfo)
    Init5465Info(ppdev, pDDHALInfo);
#else
  Init5465Info(pDDHALInfo, lpDDHALData);
#endif
}

/***************************************************************************
*
* FUNCTION:     Init5465Info
*
* DESCRIPTION:
*
****************************************************************************/

VOID Init5465Info
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  PDD_HALINFO pDDHALInfo
#else
  LPDDHALINFO pDDHALInfo,
  LPGLOBALDATA  lpDDHALData  
#endif
)
{
  // assume we can use overlay in this mode
  bNoOverlayInThisMode = FALSE;

  if (! bUseBWEqn)
    gsProgRegs.DispThrsTiming =
    ((PVGAR)lpDDHALData->RegsAddress)->grDisplay_Threshold_and_Tiling & 0x3F;

  // Are we double clocked?
//  gbDoubleClock = GetDoubleClockStatus();

  // re-init these on mode change, we might tweak them below
  pDDHALInfo->ddCaps.dwAlignBoundaryDest = 1;
  pDDHALInfo->ddCaps.dwAlignSizeDest     = 1;
  pDDHALInfo->ddCaps.dwMinOverlayStretch = 500;
  pDDHALInfo->ddCaps.dwMaxOverlayStretch = 8000;
#ifdef WINNT_VER40
  ppdev->DriverData.dwMinOverlayStretch = 500;
  ppdev->DriverData.dwMaxOverlayStretch = 8000;
#endif

  // tell ddraw we can do colorkeying
  // we might undo this below
  pDDHALInfo->ddCaps.dwCKeyCaps |= DDCKEYCAPS_DESTOVERLAY
                                |  DDCKEYCAPS_DESTOVERLAYYUV
                                |  DDCKEYCAPS_DESTOVERLAYONEACTIVE
                                |  DDCKEYCAPS_SRCOVERLAY
                                |  DDCKEYCAPS_SRCOVERLAYYUV
                                |  DDCKEYCAPS_SRCOVERLAYONEACTIVE
                                |  DDCKEYCAPS_SRCOVERLAYCLRSPACE
                                |  DDCKEYCAPS_SRCOVERLAYCLRSPACEYUV
                                ;
  if (bUseBWEqn)
  {
    DWORD     dwZoom;
    VIDCONFIG vidConfig;
    BWREGS    bwregs;


    // initialize vidConfig
    memset(&vidConfig, 0, sizeof(vidConfig));

    vidConfig.uSrcDepth  = 16;
#ifdef WINNT_VER40
    vidConfig.uDispDepth = ppdev->ulBitCount;
    vidConfig.uGfxDepth  = ppdev->ulBitCount;
#else
    vidConfig.uDispDepth = pPDevice->deBitsPixel;
    vidConfig.uGfxDepth  = pPDevice->deBitsPixel;
#endif
    vidConfig.dwFlags    =  VCFLG_COLORKEY | VCFLG_DISP;

    vidConfig.sizSrc.cx = SRC_WIDTH;
    vidConfig.sizSrc.cy = SRC_HEIGHT;
    if(gvidConfig.dwFlags & VCFLG_CAP)
    {
      //if video port is on, includes it for BWE
        vidConfig.dwFlags |= VCFLG_CAP;
        vidConfig.sizXfer = gvidConfig.sizXfer;
        vidConfig.sizCap = gvidConfig.sizCap;
        vidConfig.sizXfer = gvidConfig.sizXfer;
        vidConfig.dwXferRate = gvidConfig.dwXferRate;
        vidConfig.uXferDepth = gvidConfig.uXferDepth;
        vidConfig.uCapDepth = gvidConfig.uCapDepth;
        vidConfig.uSrcDepth = gvidConfig.uSrcDepth;
    }
#ifdef WINNT_VER40
    ChipIOReadBWRegs(ppdev, &bwregs);
#else
    ChipIOReadBWRegs(lpDDHALData, &bwregs);
#endif
#ifdef USE_OLD_BWEQ
    //Kill overlay for some modes
#ifdef WINNT_VER40
    if(KillOverlay(ppdev, (WORD)ppdev->cxScreen, (UINT)ppdev->ulBitCount))
#else
    if(KillOverlay( pPDevice->deWidth,pPDevice->deBitsPixel))
#endif
      bNoOverlayInThisMode = TRUE;
    else
#endif
    {
        // stupid linear search for min & max zoom factors

        // Check bandwidth to find the maximum zoom factor of 16 bit data
        // with colorkey
        dwZoom = MAX_ZOOM;
        do
        {
          vidConfig.sizDisp.cx = (SRC_WIDTH  * dwZoom) / 1000;
          vidConfig.sizDisp.cy = (SRC_HEIGHT * dwZoom) / 1000;

          if (ChipIsEnoughBandwidth(&gsProgRegs, &vidConfig, &bwregs))
          {
    #ifndef WINNT_VER40
            DBG_MESSAGE(("Maximum zoom factor: %d", dwZoom));
    #endif

            pDDHALInfo->ddCaps.dwMaxOverlayStretch = dwZoom;

    #ifdef WINNT_VER40
            ppdev->DriverData.dwMaxOverlayStretch = dwZoom;
    #endif
            break;
          }
          dwZoom -= ZOOM_STEP;
        } while (dwZoom > 4000);
        if (dwZoom != pDDHALInfo->ddCaps.dwMaxOverlayStretch)
          bNoOverlayInThisMode = TRUE;

        // Check bandwidth to find the minimum zoom factor of 16 bit data
        // with colorkey
        dwZoom = MIN_ZOOM;
#ifdef USE_OLD_BWEQ
        // disable overlay shrink in 24bpp modes
#ifdef WINNT_VER40
        if (24 == ppdev->ulBitCount)
#else
        if (24 == pPDevice->deBitsPixel)
#endif
          dwZoom = 1000;
#endif
        do
        {
          vidConfig.sizDisp.cx = (SRC_WIDTH  * dwZoom) / 1000;
          vidConfig.sizDisp.cy = (SRC_HEIGHT * dwZoom) / 1000;

          if (ChipIsEnoughBandwidth(&gsProgRegs, &vidConfig, &bwregs))
          {
    #ifndef WINNT_VER40
            DBG_MESSAGE(("Minimum zoom factor: %d", dwZoom));
    #endif

            pDDHALInfo->ddCaps.dwMinOverlayStretch = dwZoom;

    #ifdef WINNT_VER40
            ppdev->DriverData.dwMinOverlayStretch = dwZoom;
    #endif
            break;
          }
          dwZoom += ZOOM_STEP;
        } while (dwZoom < 4000);
        if (dwZoom != pDDHALInfo->ddCaps.dwMinOverlayStretch)
          bNoOverlayInThisMode = TRUE;
    }
    // I'll leave this code in here but so far I have only seen that if
    // we don't have enough bandwidth to use overlay with colorkey then
    // we don't have enough bandwidth period

    // try to see if there's enough bandwidth to use overlay without colorkey
    if (TRUE == bNoOverlayInThisMode)
    {
      // reset this in case we find enough bandwidth to use overlay
      // without colorkey
      bNoOverlayInThisMode = FALSE;

      // retry without colorkey available
      // tell ddraw we don't do colorkeying
      pDDHALInfo->ddCaps.dwCKeyCaps &= ~(DDCKEYCAPS_DESTOVERLAY
                                    |    DDCKEYCAPS_DESTOVERLAYYUV
                                    |    DDCKEYCAPS_DESTOVERLAYONEACTIVE
                                    |    DDCKEYCAPS_SRCOVERLAY
                                    |    DDCKEYCAPS_SRCOVERLAYYUV
                                    |    DDCKEYCAPS_SRCOVERLAYONEACTIVE
                                    |    DDCKEYCAPS_SRCOVERLAYCLRSPACE
                                    |    DDCKEYCAPS_SRCOVERLAYCLRSPACEYUV)
                                    ;

#ifdef USE_OLD_BWEQ
#ifdef WINNT_VER40
      if(KillOverlay(ppdev, (WORD)ppdev->cxScreen, (UINT)ppdev->ulBitCount))
#else
      if(KillOverlay( pPDevice->deWidth,pPDevice->deBitsPixel))
#endif
          bNoOverlayInThisMode = TRUE;
      else
#endif
      {
           // Check bandwidth to find the maximum zoom factor of 16 bit data
          dwZoom = MAX_ZOOM;
          do
          {
            vidConfig.sizDisp.cx = (SRC_WIDTH  * dwZoom) / 1000;
            vidConfig.sizDisp.cy = (SRC_HEIGHT * dwZoom) / 1000;

            if (ChipIsEnoughBandwidth(&gsProgRegs, &vidConfig, &bwregs))
            {
    #ifndef WINNT_VER40
              DBG_MESSAGE(("Maximum zoom factor: %d", dwZoom));
    #endif

              pDDHALInfo->ddCaps.dwMaxOverlayStretch = dwZoom;

    #ifdef WINNT_VER40
              ppdev->DriverData.dwMaxOverlayStretch = dwZoom;
    #endif
              break;
            }
            dwZoom -= ZOOM_STEP;
          } while (dwZoom > 4000);
          if (dwZoom != pDDHALInfo->ddCaps.dwMaxOverlayStretch)
            bNoOverlayInThisMode = TRUE;

          // Check bandwidth to find the minimum zoom factor of 16 bit data
          dwZoom = MIN_ZOOM;
          // disable overlay shrink in 24bpp modes
    #ifdef WINNT_VER40
          if (24 == ppdev->ulBitCount)
    #else
          if (24 == pPDevice->deBitsPixel)
    #endif
            dwZoom = 1000;
          do
          {
            vidConfig.sizDisp.cx = (SRC_WIDTH  * dwZoom) / 1000;
            vidConfig.sizDisp.cy = (SRC_HEIGHT * dwZoom) / 1000;

            if (ChipIsEnoughBandwidth(&gsProgRegs, &vidConfig, &bwregs))
            {
    #ifndef WINNT_VER40
              DBG_MESSAGE(("Minimum zoom factor: %d", dwZoom));
    #endif

              pDDHALInfo->ddCaps.dwMinOverlayStretch = dwZoom;

    #ifdef WINNT_VER40
              ppdev->DriverData.dwMinOverlayStretch = dwZoom;
    #endif
              break;
            }
            dwZoom += ZOOM_STEP;
          } while (dwZoom < 4000);
          if (dwZoom != pDDHALInfo->ddCaps.dwMinOverlayStretch)
            bNoOverlayInThisMode = TRUE;
      }
#ifdef DEBUG
      if (bNoOverlayInThisMode)
      {
        ERRORLOG(("  overlay disabled in %ldx%ldx%ld",
                  (DWORD)pPDevice->deWidth,
                  (DWORD)pPDevice->deHeight,
                  (DWORD)pPDevice->deBitsPixel));
      }
      else
      {
        ERRORLOG(("  overlay colorkey not supported in %ldx%ldx%ld",
                  (DWORD)pPDevice->deWidth,
                  (DWORD)pPDevice->deHeight,
                  (DWORD)pPDevice->deBitsPixel));
      }
#endif
    }
    // see if we're in interlaced mode, if so disable overlay
    if (1 & ((PVGAR)lpDDHALData->RegsAddress)->grCR1A)
      bNoOverlayInThisMode = TRUE;

#if DISABLE_MOST_MODES
    if (bDisableMostModes)
    {
      PVGAR   pREG = (PVGAR)lpDDHALData->RegsAddress;

      // disable overlay support for 1024x768 and above
      if ((1024 <= pPDevice->deWidth) && ( 768 <= pPDevice->deHeight))
        bNoOverlayInThisMode = TRUE;
      // disable overlay support for 640x480x32@85Hz
      if ((640 == pPDevice->deWidth)     &&
          (480 == pPDevice->deHeight)    &&
          ( 32 == pPDevice->deBitsPixel) &&
          (0x33 == pREG->grSRE)          &&
          (0x7E == pREG->grSR1E))
        bNoOverlayInThisMode = TRUE;
      // disable overlay support for 800x600x32@85Hz
      if ((800 == pPDevice->deWidth)     &&
          (600 == pPDevice->deHeight)    &&
          ( 32 == pPDevice->deBitsPixel) &&
          (0x1C == pREG->grSRE)          &&
          (0x37 == pREG->grSR1E))
        bNoOverlayInThisMode = TRUE;
    }
#endif

#if 0
// TDDRAW.EXE error return from UpdateOverlay in to following cases
    if (ppdev->ulBitCount == 8 && ppdev->cxScreen == 1280)
    {
      if ( (ppdev->cyScreen == 1024 && ppdev->ulFreq >= 72) ||
           (ppdev->cyScreen ==  960 && ppdev->ulFreq >= 85) )
        bNoOverlayInThisMode = TRUE;
    }
    if ( ppdev->cxScreen == 640 &&
         ppdev->cyScreen == 350 )
       bNoOverlayInThisMode = TRUE;
#endif// 0

    // if no overlay in this mode set min & max overlay stretch to 0
    if (TRUE == bNoOverlayInThisMode)
    {
      pDDHALInfo->ddCaps.dwMinOverlayStretch = 0;
      pDDHALInfo->ddCaps.dwMaxOverlayStretch = 0;
#ifdef WINNT_VER40
      ppdev->DriverData.dwMinOverlayStretch = 0;
      ppdev->DriverData.dwMaxOverlayStretch = 0;
#endif
    }
  }

#if HWBUG_24BPP_DST_COLORKEY
#ifdef WINNT_VER40
  if (24 == ppdev->ulBitCount)
#else
  if (24 == pPDevice->deBitsPixel)
#endif
  {
    // disable destination colorkey support at 24bpp
    // the hardware appears to be busted
    pDDHALInfo->ddCaps.dwCKeyCaps &= ~(  DDCKEYCAPS_DESTOVERLAY
                                       | DDCKEYCAPS_DESTOVERLAYYUV
                                       | DDCKEYCAPS_DESTOVERLAYONEACTIVE);
  }
#endif

#if 0
  // When double clocking (i.e. 1280x1024), the minimum
  // zoom is 2X.
  if ((gbDoubleClock) && (pDDHALInfo->ddCaps.dwMinOverlayStretch < 2000))
  {
    pDDHALInfo->ddCaps.dwMinOverlayStretch = 2000;
  }

  // don't use overlay in the 1X case.
  if (pDDHALInfo->ddCaps.dwMinOverlayStretch < 1500)
  {
    pDDHALInfo->ddCaps.dwMinOverlayStretch = 1500;
  }

  // Specify destination requirements.
  if ((BITSPERPIXEL == 24) || gbDoubleClock)
  {
    pDDHALInfo->ddCaps.dwCaps |= DDCAPS_ALIGNBOUNDARYDEST
                              |  DDCAPS_ALIGNSIZEDEST
                              ;
    pDDHALInfo->ddCaps.dwAlignBoundaryDest = 4;
    pDDHALInfo->ddCaps.dwAlignSizeDest = 4;
  }
#endif
}

/***************************************************************************
*
* FUNCTION:     IsFormatValid
*
* DESCRIPTION:  This function verifies that the overlay hardware can
*               support the specified format.
*
****************************************************************************/

STATIC HRESULT IsFormatValid
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD dwFourcc,
  DWORD dwBitCount
)
{
  DWORD i;


#ifndef WINNT_VER40
  DBG_MESSAGE(("IsFormatValid (dwFourcc = 0x%08lX, dwBitCount = 0x%08lX)",
               dwFourcc, dwBitCount));
#endif

	// see if we're in interlaced mode
	// if so then don't allow overlay surface to be created
  // also if there isn't enough bandwidth then fail all
  // overlay surface CanCreate requests
  if (bNoOverlayInThisMode || (1 & ((PVGAR)lpDDHALData->RegsAddress)->grCR1A))
    return DDERR_CURRENTLYNOTAVAIL;

  for (i = 0; i < dwNumVideoWindows; i++)
  {
    // see if ddraw thinks the video window is available
    // and make sure VPM isn't using it
    if ((0 == giOvlyCnt[i]) &&
#ifdef WINNT_VER40
        (! IsVWHardwareInUse(ppdev,i))
#else
        (! IsVWHardwareInUse(lpDDHALData,i))
#endif
       )
    {
    #ifndef WINNT_VER40
      DBG_MESSAGE(("Video Window %d available", i));
    #endif

      // I'll say YUCK again!
      // I hate this, what if VPM sneaks in between a CanCreateSurface
      // call and a CreateSurface call and grabs this video window
      // Guess we'll just say the creation succeeded but then fail all use
      // of the video window
      gdwAvailVW = MakeVideoWindowFlag(i);
      break;
    }
  }
  if (dwNumVideoWindows == i)
  {
    DBG_MESSAGE(("All video windows in use, returning FALSE"));
    return DDERR_CURRENTLYNOTAVAIL;
  }

  // only support 5:5:5, 5:6:5 and UYVY overlay surfaces
  if (   ((dwFourcc != BI_RGB) || (dwBitCount != 16))
#if ENABLE_SD_RGB32
      && ((dwFourcc != BI_RGB) || (dwBitCount != 32))
#endif
      && (dwFourcc != BI_BITFIELDS)
      && (dwFourcc != FOURCC_UYVY)
#if ENABLE_YUY2
      && (dwFourcc != FOURCC_YUY2)
#endif
#if ENABLE_YUVPLANAR
      && (dwFourcc != FOURCC_YUVPLANAR)
#endif
     )
  {
#ifndef WINNT_VER40
    DBG_MESSAGE(("IsFormatValid5465: returning FALSE, FourCC = %08lX", dwFourcc));
#endif

    return DDERR_INVALIDPIXELFORMAT;
  }

#ifndef WINNT_VER40
  DBG_MESSAGE(("IsFormatValid5465: returning TRUE, FourCC = %08lX", dwFourcc));
#endif

  return DD_OK;
}

/***************************************************************************
*
* FUNCTION:     CreateSurface
*
* DESCRIPTION:  This function sets various flags depending on what
*               is happening.
*
****************************************************************************/

#ifdef WINNT_VER40
STATIC HRESULT CreateOverlaySurface(
#else
STATIC HRESULT CreateSurface(
#endif
#ifdef WINNT_VER40
  PDEV                      *ppdev,
  PDD_SURFACE_LOCAL         lpSurface,
  DWORD                     dwFourcc
#else
  LPDDRAWI_DDRAWSURFACE_LCL lpSurface,
  DWORD                     dwFourcc,
  LPGLOBALDATA               lpDDHALData
#endif
)
{
  LP_SURFACE_DATA   lpSurfaceData = GET_SURFACE_DATA_PTR(lpSurface);
  DWORD             dwVWIndex;


  // For non-RGB surfaces, we must always specify the block size.
#ifndef WINNT_VER40
  DBG_MESSAGE(("Overlay CreateSurface (lpSurface = %08lX, dwFourcc = %08lX)",
               lpSurface, dwFourcc));
#endif

  lpSurfaceData->dwOverlayFlags |= FLG_OVERLAY;

#ifdef WINNT_VER40
	if (gdwAvailVW == 0)
	{
		UINT i;
		for (i = 0; i < dwNumVideoWindows; i++)
		{
			// see if ddraw thinks the video window is available
			// and make sure VPM isn't using it
			if ( (giOvlyCnt[i] == 0) && ! IsVWHardwareInUse(ppdev,i) )
			{
				gdwAvailVW = MakeVideoWindowFlag(i);
				break;
			}
		}
		if (i == dwNumVideoWindows)
		{
			DBG_MESSAGE(("All video windows in use, returning FALSE"));
			return DDERR_CURRENTLYNOTAVAIL;
		}
	}
#endif

  dwVWIndex = GetVideoWindowIndex(gdwAvailVW);
  ASSERT(dwNumVideoWindows > dwVWIndex);
  lpSurfaceData->dwOverlayFlags |= gdwAvailVW;
  gdwFourccVW[dwVWIndex] = dwFourcc;

  if (   (dwFourcc == FOURCC_UYVY)
#if ENABLE_YUY2
      || (dwFourcc == FOURCC_YUY2)
#endif
#if ENABLE_YUVPLANAR
      || (dwFourcc == FOURCC_YUVPLANAR)
#endif
     )
  {
    lpSurface->lpGbl->ddpfSurface.dwYUVBitCount = 16;
    lpSurface->lpGbl->ddpfSurface.dwYBitMask = (DWORD) -1;
    lpSurface->lpGbl->ddpfSurface.dwUBitMask = (DWORD) -1;
    lpSurface->lpGbl->ddpfSurface.dwVBitMask = (DWORD) -1;

    if (dwFourcc == FOURCC_UYVY)
    {
      lpSurfaceData->dwOverlayFlags |= FLG_UYVY;
    }
#if ENABLE_YUY2
    else if (dwFourcc == FOURCC_YUY2)
    {
      lpSurfaceData->dwOverlayFlags |= FLG_YUY2;
    }
#endif
#if ENABLE_YUVPLANAR
    else // if (dwFourcc == FOURCC_YUVPLANAR)
    {
      lpSurfaceData->dwOverlayFlags |= FLG_YUVPLANAR;
      giPlanarCnt++;

      lpSurface->lpGbl->ddpfSurface.dwYUVBitCount = 12;

      //allocate a CLPLInfo structure
      lpSurfaceData->lpCLPLData = HEAP_ALLOC(hSharedHeap,
                                             HEAP_ZERO_MEMORY,
                                             sizeof(CLPLInfo),
                                             OWNER_OVERLAY,
                                             (DWORD)lpSurface);
      if (0 == lpSurfaceData->lpCLPLData)
      {
        return DDERR_OUTOFMEMORY;
      }
      if (bCLPLLobotomyMode)
      {
        LPCLPLSURFACE   lpCLPL = lpSurfaceData->lpCLPLData;
        DWORD           dwSize;

        dwSize = (lpSurface->lpGbl->wWidth * lpSurface->lpGbl->wHeight) / 2;
        lpCLPL->fpUSystemSurface = HEAP_ALLOC(hSharedHeap,
                                              HEAP_ZERO_MEMORY,
                                              dwSize,
                                              OWNER_OVERLAY,
                                              (DWORD)lpSurface);
        if (0 == lpCLPL->fpUSystemSurface)
        {
          return DDERR_OUTOFMEMORY;
        }
        lpCLPL->fpVSystemSurface = (LPVOID)((DWORD)(lpCLPL->fpUSystemSurface) + dwSize / 2);

        DBG_MESSAGE(("CLPL lobotomy mode addrs: USys=%08lX, VSys=%08lX, size=%08lX",
                     lpCLPL->fpUSystemSurface, lpCLPL->fpVSystemSurface, dwSize));
      }
    }
#endif
  }

  if(giOvlyCnt[dwVWIndex] == 0 )
  {
    // save copy of current DTTR value
#if DDRAW_COMPAT >= 50
    gwNotify |= OVERLAY_ON;
    //if VPE is created this variable is already initialized
    if(!(gwNotify & VPE_ON))
#endif
    {
      gwNormalDTTR = ((PVGAR)lpDDHALData->RegsAddress)->grDisplay_Threshold_and_Tiling;
    }
  }
  giOvlyCnt[dwVWIndex]++;

  // CreateSurface32 fills in block size
  return DD_OK;
}

/***************************************************************************
*
* FUNCTION:     DestroySurface
*
* DESCRIPTION:  This does misc things when an overlay surface is
*               destroyed.
*
****************************************************************************/

#ifdef WINNT_VER40
STATIC VOID DestroyOverlaySurface(
#else
STATIC VOID DestroySurface(
#endif
#ifdef WINNT_VER40
  PDEV                    *ppdev,
  PDD_DESTROYSURFACEDATA  lpInput
#else
  LPDDHAL_DESTROYSURFACEDATA lpInput
#endif
)
{
#ifndef WINNT_VER40
  LPGLOBALDATA    lpDDHALData = GetDDHALContext( lpInput->lpDD);
#endif
  LP_SURFACE_DATA lpSurfaceData;
  PVGAR           pREG = (PVGAR)lpDDHALData->RegsAddress;
  DWORD           dwVWIndex;

#ifndef WINNT_VER40
  DBG_MESSAGE(("Overlay DestroySurface (lpInput = 0x%08lX)", lpInput));
#endif

  if (0 == lpInput->lpDDSurface->dwReserved1)
  {
    lpInput->ddRVal = DDERR_NOTAOVERLAYSURFACE;
    return;
  }
  lpSurfaceData = GET_SURFACE_DATA_PTR(lpInput->lpDDSurface);

  dwVWIndex = GetVideoWindowIndex(lpSurfaceData->dwOverlayFlags);
  ASSERT(dwNumVideoWindows > dwVWIndex);

  if (lpSurfaceData->dwOverlayFlags & FLG_ENABLED)
  {
    // Turn the video off
#ifndef WINNT_VER40
    DBG_MESSAGE(("Turning off VW %ld in DestroySurface", dwVWIndex));
#endif

#ifdef WINNT_VER40
    DisableOverlay(ppdev, dwVWIndex);
#else
    DisableOverlay(lpDDHALData, dwVWIndex);
#endif

    lpHardwareOwner[dwVWIndex] = NULL;

    // clear show bit if panning of desktop enabled
  }

#if ENABLE_YUVPLANAR
  if (lpSurfaceData->dwOverlayFlags & FLG_YUVPLANAR)
  {
    if (giPlanarCnt > 0)
    {
      LPCLPLSURFACE   lpCLPL = lpSurfaceData->lpCLPLData;

      giPlanarCnt--;
      if (0 != lpCLPL)
      {
        if ((bCLPLLobotomyMode) && (0 != lpCLPL->fpUSystemSurface))
          HEAP_FREE(hSharedHeap, 0, (LPVOID)lpCLPL->fpUSystemSurface);
        // Free up the memory for the CLPLInfo structure
        HEAP_FREE(hSharedHeap, 0, (LPVOID)lpCLPL);
      }
    }
  }
#endif
  if (lpSurfaceData->dwOverlayFlags & FLG_VW_MASK)
  {
    if (giOvlyCnt[dwVWIndex] > 0)
    {
      if (0 == --giOvlyCnt[dwVWIndex])
      {
        // get current DTTR, mask off FIFO threshold
        WORD CurrentDTTR = pREG->grDisplay_Threshold_and_Tiling & 0xFFC0;

#if DDRAW_COMPAT >= 50
        gvidConfig.dwFlags    &= ~(VCFLG_COLORKEY | VCFLG_CHROMAKEY |
                                      VCFLG_DISP | VCFLG_420);

        gwNotify &= ~OVERLAY_ON;
        if(!(gwNotify & VPE_ON))
#endif
        {
        // Fix PDR 9574: Restore FIFO threshold value when overlay surface
        // is destroyed, do not restore the tile size.
        // If tile size has changed, we are likely in the middle of changing
        // video mode.  No need to resotre FIFO in this case.
          if ( CurrentDTTR == (gwNormalDTTR & 0xFFC0) ) {  // check tile size
             pREG->grDisplay_Threshold_and_Tiling =
                  CurrentDTTR | (gwNormalDTTR & 0x003F); // reset FIFO Threshold
           }
        }
      }
    }
  }

  // Clear up the ownership of Dest ColorKey.
  gdwDestColorKeyOwnerVW &= ~(lpSurfaceData->dwOverlayFlags & FLG_VW_MASK);

  // Clear up the ownership of Src ColorKey.
  gdwSrcColorKeyOwnerVW &= ~(lpSurfaceData->dwOverlayFlags & FLG_VW_MASK);

#if 0
  if (lpInput->lpDDSurface->ddsCaps.dwCaps & DDSCAPS_LIVEVIDEO)
  {
    // Disable Video Capture.
#pragma message("Destroy Surface")
#pragma message("  Who the hell turned on video capture?")
#pragma message("  Shouldn't they shut it off?")
#pragma message("  How do I disable video capture on this fraggin' thing?")
  }
#endif
}

/***************************************************************************
*
* FUNCTION:     FlipOverlaySurface
*
* DESCRIPTION:  This function is called by DDDRV when it wants to flip the
*               overlay surface.
*
****************************************************************************/

STATIC DWORD FlipOverlaySurface
(
#ifdef WINNT_VER40
  PDEV          *ppdev,
  PDD_FLIPDATA  lpFlipData
#else
  LPDDHAL_FLIPDATA lpFlipData
#endif
)
{
#ifndef WINNT_VER40
  LPGLOBALDATA    lpDDHALData = GetDDHALContext( lpFlipData->lpDD);
#endif
  DWORD           dwOffset,dwOffset2;
  LP_SURFACE_DATA lpSurfaceData;
  DWORD           dwFourcc;
  DWORD           dwBitCount;
  PVGAR           pREG = (PVGAR)lpDDHALData->RegsAddress;
  DWORD           dwVWIndex;
#if DDRAW_COMPAT >= 50
  DWORD           dwControl0;
  DWORD           dwSrfFlags = FALSE;
#endif
  DWORD           dwSurfBase, dwSurfOffset;


#ifndef WINNT_VER40
  DBG_MESSAGE(("FlipOverlaySurface (lpFlipData = 0x%08lX)", lpFlipData));
#endif

  if (0 == lpFlipData->lpSurfCurr->dwReserved1)
  {
    lpFlipData->ddRVal = DDERR_NOTAOVERLAYSURFACE;
    return DDHAL_DRIVER_HANDLED;
  }
  lpSurfaceData = GET_SURFACE_DATA_PTR(lpFlipData->lpSurfCurr);

  dwVWIndex = GetVideoWindowIndex(lpSurfaceData->dwOverlayFlags);
  ASSERT(dwNumVideoWindows > dwVWIndex);

  // When TVTap/VPM is used with DirectDraw, things got more twisted.
  // VPM doesn't call UpdateSurface, so lpHardwareOwner
  // won't be set, nevertheless, the HW is grabbed by VPM.
  // In that case, should fail the Flip call to prevent bad VPM.

  // YUCK!!!
  // The VWE bit in the hardware seems to be the semaphore for sharing the
  // overlay with VPM

  if ((lpHardwareOwner[dwVWIndex] == NULL) &&
#ifdef WINNT_VER40
      IsVWHardwareInUse(ppdev, dwVWIndex)
#else
      IsVWHardwareInUse(lpDDHALData,dwVWIndex)
#endif
     )
  {
#ifndef WINNT_VER40
    DBG_MESSAGE(("VW %ld already in use, Out of Caps!", dwVWIndex));
#endif

    lpFlipData->ddRVal = DDERR_OUTOFCAPS;
    return (DDHAL_DRIVER_HANDLED);
  }

#ifdef WINNT_VER40
  if(GetOverlayFlipStatus(ppdev, 0, dwVWIndex) != DD_OK || DRAW_ENGINE_BUSY || IN_VBLANK)
#else
  if(GetOverlayFlipStatus(lpDDHALData,0, dwVWIndex) != DD_OK || DRAW_ENGINE_BUSY || IN_VBLANK)
#endif
  {
    lpFlipData->ddRVal = DDERR_WASSTILLDRAWING;
    return DDHAL_DRIVER_HANDLED;
  }

  // Determine the format of the video data
  if (lpFlipData->lpSurfTarg->dwFlags & DDRAWISURF_HASPIXELFORMAT)
  {
    GetFormatInfo (&(lpFlipData->lpSurfTarg->lpGbl->ddpfSurface),
                   &dwFourcc,
                   &dwBitCount);
  }
  else
  {
    dwBitCount = BITSPERPIXEL;
  }

  // Determine the offset to the new area.
#ifdef WINNT_VER40
  dwSurfBase = lpFlipData->lpSurfTarg->lpGbl->fpVidMem;
#else
  dwSurfBase = (lpFlipData->lpSurfTarg->lpGbl->fpVidMem - lpDDHALData->ScreenAddress);
#endif
  dwSurfOffset = lpSurfaceData->dwOverlayOffset;
  dwOffset = dwSurfBase + dwSurfOffset;

#if ENABLE_MIRRORING
  // Flip the overlay surface by changing PSD_STRT_ADDR
  if (bIsVWMirrored[dwVWIndex])
  {
    // for mirroring
    // point to the last byte of the last pixel on the right edge of the source
    dwOffset += (DWORD)(grOverlaySrc[dwVWIndex].right -
                        grOverlaySrc[dwVWIndex].left  - 1);
  }
#endif
  dwOffset2 = 0;
#if DDRAW_COMPAT >= 50
  dwControl0 =  pREG->VideoWindow[dwVWIndex].grVW_CONTROL0;
  if(lpFlipData->lpSurfTarg->lpSurfMore->lpVideoPort != NULL)
  {
     if(( lpFlipData->lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_AUTOFLIP)
             &&(lpFlipData->lpSurfTarg->lpSurfMore->lpVideoPort->ddvpInfo.dwVPFlags
                      &DDVP_AUTOFLIP)
             && (lpFlipData->lpSurfTarg->lpAttachListFrom != NULL)
             && (lpFlipData->lpSurfTarg->lpAttachListFrom->lpAttached != NULL))
     {
        dwSrfFlags = DDOVER_AUTOFLIP;
     }
     else if(( lpFlipData->lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_BOB)
         &&(lpFlipData->lpSurfTarg->lpSurfMore->lpVideoPort->ddvpInfo.dwVPFlags
           & DDVP_INTERLEAVE))
     {
        dwSrfFlags = DDOVER_BOB;
       //Smooth interlace
       dwOffset2 = dwOffset +
            lpFlipData->lpSurfTarg->lpGbl->lPitch; //point to the next line
     }
  }

  if(dwSrfFlags & DDOVER_BOB)
  {
       //Smooth interlace
       dwOffset2 = dwOffset +
            lpFlipData->lpSurfTarg->lpGbl->lPitch; //point to the next line

  }
  else if(dwSrfFlags & DDOVER_AUTOFLIP)
  {
    //Auto Flip Overlay
        dwOffset2 = lpSurfaceData->dwAutoBaseAddr2 + dwSurfOffset;
        if(dwOffset2 == dwOffset)
        {
           dwOffset = lpSurfaceData->dwAutoBaseAddr1 + dwSurfOffset;
        }
        //For non-smooth-interlaced auto-flip these two address need
        // to be switched.  HW BUG
        if(!(lpFlipData->lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_BOB))
        {
           DWORD dwTmp = dwOffset;
           dwOffset = dwOffset2;
           dwOffset2 = dwTmp;
        }
  }
  else if( lpFlipData->lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_INTERLEAVED)
  {
    dwControl0 &= ~0x30000;
    if(lpFlipData->dwFlags & DDFLIP_ODD)    //SW flip
    {
        dwOffset2 = dwOffset +
            lpFlipData->lpSurfTarg->lpGbl->lPitch ; //point to the next line
        dwControl0 |= 0x10000;  //use VW_SDD

    }
  }
  else if(lpFlipData->dwFlags & DDFLIP_ODD)    //SW flip
  {
        dwOffset2 = dwOffset;
        dwControl0 &= ~0x30000;
        dwControl0 |= 0x10000;  //use VW_SDD
  }
#endif

  // write new start address to hardware
#ifdef WINNT_VER40
  WaitForVWArmToClear(ppdev,dwVWIndex);
#else
  WaitForVWArmToClear(lpDDHALData,dwVWIndex);
#endif
  ASSERT(! (pREG->VideoWindow[dwVWIndex].grVW_TEST0 & VW_PostImed));

  LL32(VideoWindow[dwVWIndex].grVW_PSD_STRT_ADDR, dwOffset);
  LL32(VideoWindow[dwVWIndex].grVW_SSD_STRT_ADDR, dwOffset2);
#if ENABLE_YUVPLANAR
  if (lpSurfaceData->dwOverlayFlags & FLG_YUVPLANAR)
  {
    // PSD_STRT_ADDR has been set to the start of the Y data in aperture0
    // set PSD_UVSTRT_ADDR to start of UV interleaved data in aperture 0
    // UV data is only half the height of Y data
    LL32(VideoWindow[dwVWIndex].grVW_PSD_UVSTRT_ADDR,
         dwSurfBase +
         (((lpFlipData->lpSurfTarg->lpGbl->wHeight * lpFlipData->lpSurfTarg->lpGbl->lPitch) + 7) & ~7) +
         (dwSurfOffset / 2));
    LL32(VideoWindow[dwVWIndex].grVW_SSD_UVSTRT_ADDR, dwOffset2);
  }
#endif

#if DDRAW_COMPAT >= 50
  if (lpSurfaceData->dwOverlayFlags & FLG_ENABLED)
    pREG->VideoWindow[dwVWIndex].grVW_CONTROL0 = (dwControl0 |VW_VWE | VW_ARM);
  else
    pREG->VideoWindow[dwVWIndex].grVW_CONTROL0 = dwControl0 | VW_ARM;
#else
  if (lpSurfaceData->dwOverlayFlags & FLG_ENABLED)
    pREG->VideoWindow[dwVWIndex].grVW_CONTROL0 |= (VW_VWE | VW_ARM);
  else
    pREG->VideoWindow[dwVWIndex].grVW_CONTROL0 |= VW_ARM;
#endif

#ifdef WINNT_VER40
  // Update the hardware owner
  lpHardwareOwner[dwVWIndex] = lpFlipData->lpSurfTarg;
#endif

  // remember where/when we were when we did the flip
#ifdef WINNT_VER40
  EngQueryPerformanceCounter(&gsOverlayFlip.liFlipTime);
#else
  QueryPerformanceCounter((LARGE_INTEGER *)&gsOverlayFlip.liFlipTime);
#endif
#ifdef WINNT_VER40
  gsOverlayFlip.dwFlipScanline = CurrentVLine(ppdev);
#else
  gsOverlayFlip.dwFlipScanline = CurrentVLine(lpDDHALData);
#endif
  gsOverlayFlip.bFlipFlag = TRUE;
  gsOverlayFlip.fpFlipFrom = lpFlipData->lpSurfCurr->lpGbl->fpVidMem;
  gsOverlayFlip.bHaveEverCrossedVBlank = FALSE;

  if (IN_VBLANK)
  {
    gsOverlayFlip.bWasEverInDisplay = FALSE;
  }
  else
  {
    gsOverlayFlip.bWasEverInDisplay = TRUE;
  }

  lpFlipData->ddRVal = DD_OK;
  return DDHAL_DRIVER_HANDLED;
}

/***************************************************************************
*
* FUNCTION:     LockSurface
*
* DESCRIPTION:  Checks for flipping before allowing access to the surface.
*
****************************************************************************/

STATIC DWORD LockSurface
(
#ifdef WINNT_VER40
  PDEV          *ppdev,
  PDD_LOCKDATA  lpInput
#else
  LPDDHAL_LOCKDATA lpInput
#endif
)
{
#if ENABLE_YUVPLANAR
  LPCLPLSURFACE   lpCLPL;         // pointer to our YUV planar
  DWORD           dwUVOffset;
#endif
  LP_SURFACE_DATA lpSurfaceData;
  DWORD           dwVWIndex;
#ifndef WINNT_VER40
  LPGLOBALDATA    lpDDHALData = GetDDHALContext( lpInput->lpDD);
#endif

#ifndef WINNT_VER40
  DBG_MESSAGE(("Overlay LockSurface (lpInput = 0x%08lX)", lpInput));
#endif

  if (0 == lpInput->lpDDSurface->dwReserved1)
  {
    lpInput->ddRVal = DDERR_NOTAOVERLAYSURFACE;
    return DDHAL_DRIVER_HANDLED;
  }
  lpSurfaceData = GET_SURFACE_DATA_PTR(lpInput->lpDDSurface);

  dwVWIndex = GetVideoWindowIndex(lpSurfaceData->dwOverlayFlags);
  ASSERT(dwNumVideoWindows > dwVWIndex);

  // Check for flipping
  if ((gsOverlayFlip.bFlipFlag) &&
      (
#ifdef WINNT_VER40
       GetOverlayFlipStatus(ppdev, lpInput->lpDDSurface->lpGbl->fpVidMem, dwVWIndex)
#else
       GetOverlayFlipStatus(lpDDHALData,lpInput->lpDDSurface->lpGbl->fpVidMem, dwVWIndex)
#endif
        == DDERR_WASSTILLDRAWING))
  {
    lpInput->ddRVal = DDERR_WASSTILLDRAWING;
    return DDHAL_DRIVER_HANDLED;
  }

#if ENABLE_YUVPLANAR
  if (lpSurfaceData->dwOverlayFlags & FLG_YUVPLANAR)
  {
    // make sure CLPL aperture is mapped in
    if (! lpDDHALData->dwCLPLAperture)
    {
      lpInput->ddRVal = DD_OK;
      return DDHAL_DRIVER_NOTHANDLED;
    }

    // here's how this YUV420/YUVPLANAR/CLPL stuff works:
    // the CLPL surface consists of all the Y data followed by a region of
    // UV interleaved data.  We are currently supporting only linear surfaces
    // for CLPL so there will be wHeight lines of Y data followed by wHeight/2
    // lines of UV interleaved data.  CreateSurface32 has padded the surface
    // allocation such that the UV interleaved data will start on the first
    // quadword boundary following the Y data.
    //
    // We pass back a pointer to a structure containing the address of a Y
    // region, a U region and a V region to the app.  The app writes to the
    // U and V regions as if they are linear and the hardware converts this
    // data into the UV interleaved data in aperture 0.
    //
    // For the U ptr we give the app an address pointing somewhere in the
    // first four meg of aperture 3 and for the V ptr we give the app an
    // address pointing to the same somewhere but in the second four meg
    // of aperture 3.  When the app writes to these addresses, the data
    // shows up in aperture 0 such that:
    //    the U data is at   ap0_offset = ap3_offset * 2
    //    the V data is at   ap0_offset = (ap3_offset - 4MB) * 2 + 1
    //
    // what we need to do then is give the app the folloing ptrs:
    //   Y ptr = ap0_offset of the Y region (the beginning of the surface)
    //   U ptr = ap3_offset for U data = U_ap0_offset / 2
    //   V ptr = ap3_offset for V data = (V_ap0_offset - 1) / 2 + 4MB
    // where U_ap0_offset = offset we want the U data to start
    //   and V_ap0_offset = offset we want the V data to start
    // we also need V_ap0_offset = U_ap0_offset + 1

    // Compute Y and UV aperture in frame buffer
    lpCLPL = (LPCLPLSURFACE)lpSurfaceData->lpCLPLData;
    lpInput->lpSurfData = (LPVOID)lpCLPL;

    // Y data starts at beginning of surface in aperture0
    lpCLPL->fpYSurface = (LPVOID)lpInput->lpDDSurface->lpGbl->fpVidMem;

    DBG_MESSAGE(("Aperture0 Y offset = %08lX",
                 (lpInput->lpDDSurface->lpGbl->fpVidMem - lpDDHALData->ScreenAddress)));
    DBG_MESSAGE(("  surface height = %08lX, pitch = %08lX",
                 lpInput->lpDDSurface->lpGbl->wHeight,
                 lpInput->lpDDSurface->lpGbl->lPitch));

    // determine offset of UV data in aperture 0 (and make it qword aligned)
    dwUVOffset = (lpInput->lpDDSurface->lpGbl->fpVidMem - lpDDHALData->ScreenAddress) +
                 (((lpInput->lpDDSurface->lpGbl->wHeight * lpInput->lpDDSurface->lpGbl->lPitch) + 7) & ~7);
    DBG_MESSAGE(("Aperture0 UV offset = %08lX", dwUVOffset));

    // convert UV aperture0 offset to aperture3 offset
    DBG_MESSAGE(("Aperture3 UV offset = %08lX", dwUVOffset / 2));
    dwUVOffset = lpDDHALData->dwCLPLAperture + dwUVOffset / 2;

    if (bCLPLLobotomyMode)
    {
      lpCLPL->fpRealUSurface = (LPVOID)(dwUVOffset);
      lpCLPL->fpRealVSurface = (LPVOID)(dwUVOffset + 0x400000);
      DBG_MESSAGE(("CLPL lobotomy mode addrs: RealU=%08lX, RealV=%08lX",
                   lpCLPL->fpRealUSurface, lpCLPL->fpRealVSurface));
      lpCLPL->fpUSurface = lpCLPL->fpUSystemSurface;
      lpCLPL->fpVSurface = lpCLPL->fpVSystemSurface;
    }
    else
    {
      lpCLPL->fpUSurface = (LPVOID)(dwUVOffset);
      lpCLPL->fpVSurface = (LPVOID)(dwUVOffset + 0x400000);
    }

    DBG_MESSAGE(("CLPL addrs: Y=%08lX, U=%08lX, V=%08lX",
                 lpCLPL->fpYSurface, lpCLPL->fpUSurface, lpCLPL->fpVSurface));

    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
  }
#endif

#if ENABLE_YUY2
  // Force them to use the byte swap aperture
  if (lpSurfaceData->dwOverlayFlags & FLG_YUY2)
  {
    // make sure the YUY2 aperture is mapped in
    if (! lpDDHALData->dwYUY2Aperture)
    {
      lpInput->ddRVal = DD_OK;
      return DDHAL_DRIVER_NOTHANDLED;
    }

    lpInput->lpSurfData = (LPVOID) ((lpInput->lpDDSurface->lpGbl->fpVidMem -
                                     lpDDHALData->ScreenAddress) +
                                     lpDDHALData->dwYUY2Aperture);

    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
  }
#endif

  lpInput->ddRVal = DD_OK;
  return DDHAL_DRIVER_NOTHANDLED;
}

#if ENABLE_YUVPLANAR
/***************************************************************************
*
* FUNCTION:    SysToFBCopy()
*
* DESCRIPTION:
*
****************************************************************************/

#if 1
static INLINE VOID
SysToFBCopy ( BYTE *dst, LONG dstPitch, BYTE *src, LONG srcPitch, REG32 ext, LONG bpp )
{
  int yext = ext.pt.Y;
  int xext = ext.pt.X * bpp;

  while (0 < yext--)
  {
    memcpy(dst,src,xext);
    dst += dstPitch;
    src += srcPitch;
  }
}
#else
// writing the scanline from right to left shows the hwbug where roughly
// every other 4 dwords written to aperture3 is dropped
// and the video is generally display with a lovely flourescent green
// checkerboard pattern
//
// This duplicates the problem seen by allowing the Compcore MPEG player
// write directly to aperture3
#pragma optimize("", off)
// the compiler ignores __inline because of the inline assembly
static INLINE VOID
SysToFBCopy ( BYTE *dst, LONG dstPitch, BYTE *src, LONG srcPitch, REG32 ext, LONG bpp )
{
  int yext = ext.pt.Y;
  int xext = ext.pt.X * bpp;

  _asm    std

  dst += dstPitch - sizeof(DWORD);
  src += srcPitch - sizeof(DWORD);

  while (0 < yext--)
  {
    _asm
    {
          mov   eax,xext
          mov   edi,dst
          mov   esi,src
          mov   ecx,eax
          shr   ecx,2
      rep movsd
          mov   ecx,eax
          and   ecx,3
      rep movsb
    }
    dst += dstPitch;
    src += srcPitch;
  }

  _asm    cld
}
#pragma optimize("", on)
#endif
#endif

/***************************************************************************
*
* FUNCTION:     UnlockSurface
*
* DESCRIPTION:  This function is called by DDHAL when it is finished accessing
*               the frame buffer.
*
****************************************************************************/

STATIC VOID UnlockSurface
(
#ifdef WINNT_VER40
  PDEV            *ppdev,
  PDD_UNLOCKDATA  lpInput
#else
  LPDDHAL_UNLOCKDATA lpInput
#endif
)
{
#if ENABLE_YUVPLANAR
  LPCLPLSURFACE   lpCLPL;         // pointer to our YUV planar
#endif
  LP_SURFACE_DATA lpSurfaceData;


#ifndef WINNT_VER40
  DBG_MESSAGE(("Overlay UnlockSurface (lpInput = 0x%08lX)", lpInput));
#endif

  if (0 == lpInput->lpDDSurface->dwReserved1)
  {
    lpInput->ddRVal = DDERR_NOTAOVERLAYSURFACE;
    return;
  }
  lpSurfaceData = GET_SURFACE_DATA_PTR(lpInput->lpDDSurface);

#if ENABLE_YUVPLANAR
  if ((lpSurfaceData->dwOverlayFlags & FLG_YUVPLANAR) && bCLPLLobotomyMode)
  {
    REG32 ext;
    LONG  pitch;

    lpCLPL = (LPCLPLSURFACE)lpSurfaceData->lpCLPLData;

    ext.pt.X = lpInput->lpDDSurface->lpGbl->wWidth / 2;
    ext.pt.Y = lpInput->lpDDSurface->lpGbl->wHeight / 2;
    pitch = lpInput->lpDDSurface->lpGbl->lPitch / 2;

    SysToFBCopy(lpCLPL->fpRealUSurface, pitch, lpCLPL->fpUSystemSurface, pitch, ext, 1);
    SysToFBCopy(lpCLPL->fpRealVSurface, pitch, lpCLPL->fpVSystemSurface, pitch, ext, 1);
  }
#endif
}

/***************************************************************************
*
* FUNCTION:     SetColorKey
*
* DESCRIPTION:  Looks at the color key for changes in the while
*               overlay is active.
*
****************************************************************************/

STATIC VOID SetColorKey
(
#ifdef WINNT_VER40
  PDEV                  *ppdev,
  PDD_SETCOLORKEYDATA   lpInput
#else
  LPDDHAL_SETCOLORKEYDATA lpInput
#endif
)
{
  LP_SURFACE_DATA lpSurfaceData;
  LP_SURFACE_DATA lpHWOwnerData;
  DWORD           dwVWIndex;
#ifndef WINNT_VER40
  LPGLOBALDATA    lpDDHALData = GetDDHALContext( lpInput->lpDD);
#endif

#ifndef WINNT_VER40
  DBG_MESSAGE(("Overlay SetColorKey (lpInput = 0x%08lX)", lpInput));
#endif

  if (0 == lpInput->lpDDSurface->dwReserved1)
  {
    lpInput->ddRVal = DDERR_NOTAOVERLAYSURFACE;
    return;
  }
  lpSurfaceData = GET_SURFACE_DATA_PTR(lpInput->lpDDSurface);

  dwVWIndex = GetVideoWindowIndex(lpSurfaceData->dwOverlayFlags);
  ASSERT(dwNumVideoWindows > dwVWIndex);

  if ((lpInput->dwFlags & DDCKEY_DESTOVERLAY) &&
      (lpInput->lpDDSurface == lpColorSurfaceVW[dwVWIndex]))
  {
    // See if someone else is already using the colorkey.
    if ((gdwDestColorKeyOwnerVW & FLG_VW_MASK) &&
        (lpInput->lpDDSurface != lpColorSurfaceVW[dwVWIndex]))
    {
      // ColorKey already being used.
      lpInput->ddRVal = DDERR_OUTOFCAPS;
      return;
    }

    // You get here only when the call is issued AFTER UpdateOverlay.
    gdwColorKey = lpInput->ckNew.dwColorSpaceLowValue;

    if (0 == lpHardwareOwner[dwVWIndex]->dwReserved1)
    {
      lpInput->ddRVal = DDERR_NOTAOVERLAYSURFACE;
      return;
    }
    lpHWOwnerData = GET_SURFACE_DATA_PTR(lpHardwareOwner[dwVWIndex]);

    if ((lpInput->lpDDSurface == lpColorSurfaceVW[dwVWIndex]) &&
        (lpHardwareOwner[dwVWIndex]) &&
        (lpHWOwnerData->dwOverlayFlags & FLG_ENABLED))
    {
      gdwDestColorKeyOwnerVW = MakeVideoWindowFlag(dwVWIndex);
      lpHWOwnerData->dwOverlayFlags |= FLG_COLOR_KEY;
#ifdef WINNT_VER40
      RegInitVideoVW(ppdev, dwVWIndex, lpHardwareOwner[dwVWIndex]);
#else
      RegInitVideoVW(dwVWIndex, lpHardwareOwner[dwVWIndex],lpDDHALData);
#endif
    }
  }
  else if ((lpInput->dwFlags & DDCKEY_SRCOVERLAY) &&
           (lpInput->lpDDSurface == lpSrcColorSurfaceVW[dwVWIndex]))
  {
    // See if someone else already uses the colorkey.
    if ((gdwSrcColorKeyOwnerVW != 0 ) &&
        !(gdwSrcColorKeyOwnerVW & lpSurfaceData->dwOverlayFlags))
    {
      // ColorKey already been used.
      lpInput->ddRVal = DDERR_OUTOFCAPS;
      return;
    }
    gdwSrcColorKeyLow = lpInput->ckNew.dwColorSpaceLowValue;
    gdwSrcColorKeyHigh = lpInput->ckNew.dwColorSpaceHighValue;
    if (gdwSrcColorKeyLow > gdwSrcColorKeyHigh)
    {
      gdwSrcColorKeyHigh = gdwSrcColorKeyLow;
    }

    if (0 == lpHardwareOwner[dwVWIndex]->dwReserved1)
    {
      lpInput->ddRVal = DDERR_NOTAOVERLAYSURFACE;
      return;
    }
    lpHWOwnerData = GET_SURFACE_DATA_PTR(lpHardwareOwner[dwVWIndex]);

    if ((lpSurfaceData->dwOverlayFlags & FLG_VW_MASK) &&
        (lpHardwareOwner[dwVWIndex]) &&
        (lpHWOwnerData->dwOverlayFlags & FLG_ENABLED))
    {
      gdwSrcColorKeyOwnerVW = MakeVideoWindowFlag(dwVWIndex);
      lpHWOwnerData->dwOverlayFlags |= FLG_SRC_COLOR_KEY;
#ifdef WINNT_VER40
      RegInitVideoVW(ppdev, dwVWIndex, lpHardwareOwner[dwVWIndex]);
#else
      RegInitVideoVW(dwVWIndex, lpHardwareOwner[dwVWIndex],lpDDHALData);
#endif
    }
  }
}

/***************************************************************************
*
* FUNCTION:     SaveRectangles
*
* DESCRIPTION:
*
****************************************************************************/

static INLINE BOOL SaveRectangles
(
#ifdef WINNT_VER40
  PDEV                        *ppdev,
#endif
  DWORD                       dwVWIndex,
  BOOL                        bCheckBandwidth,
  DWORD                       dwBitCount,
#ifdef WINNT_VER40
  PDD_UPDATEOVERLAYDATA       lpInput
#else
  LPDDHAL_UPDATEOVERLAYDATA   lpInput,
  LPGLOBALDATA                lpDDHALData
#endif
)
{
  SIZEL       Dst;
  SIZEL       Src;
  BWREGS      bwregs;

  // Is there sufficient bandwidth to work?

  gvidConfig.sizSrc.cx  = lpInput->rSrc.right  - lpInput->rSrc.left;
  gvidConfig.sizSrc.cy  = lpInput->rSrc.bottom - lpInput->rSrc.top;
  gvidConfig.sizDisp.cx = lpInput->rDest.right  - lpInput->rDest.left;
  gvidConfig.sizDisp.cy = lpInput->rDest.bottom - lpInput->rDest.top;
  gvidConfig.uSrcDepth  = dwBitCount;
  gvidConfig.uDispDepth = dwBitCount;   //video window has the same as source
  gvidConfig.uGfxDepth  = BITSPERPIXEL;
  gvidConfig.dwFlags    |= VCFLG_DISP;
#ifdef WINNT_VER40
  ChipIOReadBWRegs(ppdev, &bwregs);
#else
  ChipIOReadBWRegs(lpDDHALData, &bwregs);
#endif
  if (bCheckBandwidth && bUseBWEqn &&
      !ChipIsEnoughBandwidth(&gsProgRegs, &gvidConfig, &bwregs)
     )
  {
     gvidConfig.dwFlags    &= ~VCFLG_DISP;
    lpInput->ddRVal = DDERR_OUTOFCAPS;
    return FALSE;
  }

  // Save the rectangles
#ifndef WINNT_VER40
  DBG_MESSAGE(("rSrc          = %lX,%lX %lX,%lX",
               lpInput->rSrc.left,lpInput->rSrc.top,
               lpInput->rSrc.right,lpInput->rSrc.bottom));

  DBG_MESSAGE(("rcOverlaySrc  = %lX,%lX %lX,%lX",
               lpInput->lpDDSrcSurface->rcOverlaySrc.left,
               lpInput->lpDDSrcSurface->rcOverlaySrc.top,
               lpInput->lpDDSrcSurface->rcOverlaySrc.right,
               lpInput->lpDDSrcSurface->rcOverlaySrc.bottom));
#endif

  grOverlaySrc[dwVWIndex].left    = (int)lpInput->rSrc.left;
  grOverlaySrc[dwVWIndex].right   = (int)lpInput->rSrc.right;
  grOverlaySrc[dwVWIndex].top     = (int)lpInput->rSrc.top;
  grOverlaySrc[dwVWIndex].bottom  = (int)lpInput->rSrc.bottom;

#ifndef WINNT_VER40
  DBG_MESSAGE(("rDest         = %lX,%lX %lX,%lX",
               lpInput->rDest.left,lpInput->rDest.top,
               lpInput->rDest.right,lpInput->rDest.bottom));

  DBG_MESSAGE(("rcOverlayDest = %lX,%lX %lX,%lX",
               lpInput->lpDDSrcSurface->rcOverlayDest.left,
               lpInput->lpDDSrcSurface->rcOverlayDest.top,
               lpInput->lpDDSrcSurface->rcOverlayDest.right,
               lpInput->lpDDSrcSurface->rcOverlayDest.bottom));
#endif

  grOverlayDest[dwVWIndex].left   = (int)lpInput->rDest.left;
  grOverlayDest[dwVWIndex].right  = (int)lpInput->rDest.right;
  grOverlayDest[dwVWIndex].top    = (int)lpInput->rDest.top;
  grOverlayDest[dwVWIndex].bottom = (int)lpInput->rDest.bottom;

  // make sure resize is within hw capabilities
  // x can shrink down to 1/2 and stretch up to 8x
  // y can stretch up to 8x
  Dst.cx = grOverlayDest[dwVWIndex].right - grOverlayDest[dwVWIndex].left;
  Dst.cy = grOverlayDest[dwVWIndex].bottom - grOverlayDest[dwVWIndex].top;
  Src.cx = grOverlaySrc[dwVWIndex].right  - grOverlaySrc[dwVWIndex].left;
  Src.cy = grOverlaySrc[dwVWIndex].bottom  - grOverlaySrc[dwVWIndex].top;

#ifdef WINNT_VER40
  if (Dst.cx > (LONG)(lpDDHALData->dwMaxOverlayStretch * Src.cx / 1000))
#else
  if (Dst.cx > (LONG)(lpDDHALData->HALInfo.ddCaps.dwMaxOverlayStretch * Src.cx / 1000))
#endif
  {
    lpInput->ddRVal = DDERR_TOOBIGWIDTH;
    return FALSE;
  }
#ifdef WINNT_VER40
  else if (Dst.cy > (LONG)(lpDDHALData->dwMaxOverlayStretch * Src.cy / 1000))
#else
  else if (Dst.cy > (LONG)(lpDDHALData->HALInfo.ddCaps.dwMaxOverlayStretch * Src.cy / 1000))
#endif
  {
    lpInput->ddRVal = DDERR_TOOBIGHEIGHT;
    return FALSE;
  }
#ifdef WINNT_VER40
  else if (Dst.cx < (LONG)(lpDDHALData->dwMinOverlayStretch * Src.cx / 1000))
#else
  else if (Dst.cx < (LONG)(lpDDHALData->HALInfo.ddCaps.dwMinOverlayStretch * Src.cx / 1000))
#endif
  {
    lpInput->ddRVal = DDERR_UNSUPPORTED;    // too small width
    return FALSE;
  }

  if (MIN_OLAY_WIDTH >= Src.cx)
  {
    lpInput->ddRVal = DDERR_OUTOFCAPS;
    return FALSE;
  }

  return TRUE;
}

/***************************************************************************
*
* FUNCTION:     UpdateSurface
*
* DESCRIPTION:
*
****************************************************************************/

STATIC DWORD UpdateSurface
(
#ifdef WINNT_VER40
  PDEV                  *ppdev,
  PDD_UPDATEOVERLAYDATA lpInput
#else
  LPDDHAL_UPDATEOVERLAYDATA lpInput
#endif
)
{
  DWORD             dwOldStatus;
  DWORD             dwFourcc;
  BOOL              bCheckBandwidth;
  DWORD             dwBitCount;
  DWORD             dwDestColorKey;
  LP_SURFACE_DATA   lpSrcSurfaceData;
  DWORD             dwVWIndex;
  DWORD             dwVWFlag;
  BWREGS            bwregs;
  BOOL				bShowOverlay = FALSE;
#ifndef WINNT_VER40
  LPGLOBALDATA    lpDDHALData = GetDDHALContext( lpInput->lpDD);
#endif
#ifndef WINNT_VER40
  DBG_MESSAGE(("Overlay UpdateSurface (lpInput = 0x%08lX)", lpInput));
#endif

  if (0 == lpInput->lpDDSrcSurface->dwReserved1)
  {
    lpInput->ddRVal = DDERR_NOTAOVERLAYSURFACE;
    return DDHAL_DRIVER_HANDLED;
  }
  lpSrcSurfaceData = GET_SURFACE_DATA_PTR(lpInput->lpDDSrcSurface);

  if (lpInput->lpDDSrcSurface->dwFlags & DDRAWISURF_HASPIXELFORMAT)
  {
    GetFormatInfo(&(lpInput->lpDDSrcSurface->lpGbl->ddpfSurface),
                  &dwFourcc, &dwBitCount);
  }
  else
  {
    dwBitCount = BITSPERPIXEL;
    if (16 == dwBitCount)
      dwFourcc = BI_BITFIELDS;    // 5:6:5
    else
      dwFourcc = BI_RGB;          // 8bpp, 5:5:5, 24bpp & 32bpp
  }

  gvidConfig.dwFlags &= ~(VCFLG_COLORKEY | VCFLG_CHROMAKEY |
                          VCFLG_DISP | VCFLG_420);
#if ENABLE_YUVPLANAR
  if (lpSrcSurfaceData->dwOverlayFlags & FLG_YUVPLANAR)
    gvidConfig.dwFlags |= VCFLG_420;
#endif

  // Are we color keying?
  bCheckBandwidth = TRUE;
  dwOldStatus = lpSrcSurfaceData->dwOverlayFlags;

  dwVWIndex = GetVideoWindowIndex(dwOldStatus);
  ASSERT(dwNumVideoWindows > dwVWIndex);
  dwVWFlag = MakeVideoWindowFlag(dwVWIndex);

  lpColorSurfaceVW[dwVWIndex] = lpSrcColorSurfaceVW[dwVWIndex] = NULL;
#if ENABLE_MIRRORING
  bIsVWMirrored[dwVWIndex] = FALSE;
#endif

  if ((lpInput->dwFlags & (DDOVER_KEYDEST | DDOVER_KEYDESTOVERRIDE)) &&
      (lpInput->dwFlags & (DDOVER_KEYSRC | DDOVER_KEYSRCOVERRIDE)))
  {
    // Cannot perform src colorkey and dest colorkey at the same time
    lpInput->ddRVal = DDERR_NOCOLORKEYHW;
    return DDHAL_DRIVER_HANDLED;
  }

#if HWBUG_24BPP_DST_COLORKEY
  if (
#ifdef WINNT_VER40
      (24 == ppdev->ulBitCount) &&
#else
      (24 == pPDevice->deBitsPixel) &&
#endif
      (lpInput->dwFlags & (DDOVER_KEYDEST | DDOVER_KEYDESTOVERRIDE)))
  {
    // destination colorkeying at 24bpp is busted in hardware
    lpInput->ddRVal = DDERR_NOCOLORKEYHW;
    return DDHAL_DRIVER_HANDLED;
  }
#endif

#ifdef WINNT_VER40
  ChipIOReadBWRegs(ppdev, &bwregs);
#else
  ChipIOReadBWRegs(lpDDHALData, &bwregs);
#endif

  lpSrcSurfaceData->dwOverlayFlags &= ~(FLG_COLOR_KEY|FLG_SRC_COLOR_KEY);

#ifndef WINNT_VER40
	if (   (lpInput->dwFlags == 0)
		&& (lpHardwareOwner[dwVWIndex] == NULL)
		&& (lpSrcSurfaceData->dwOverlayFlags & FLG_OVERLAY) )
	{
		bShowOverlay = TRUE;
	}
#endif

  if (lpInput->dwFlags & (DDOVER_KEYDEST | DDOVER_KEYDESTOVERRIDE))
  {
    dwDestColorKey = (lpInput->dwFlags & DDOVER_KEYDEST)
            ? lpInput->lpDDDestSurface->ddckCKDestOverlay.dwColorSpaceLowValue
            : lpInput->overlayFX.dckDestColorkey.dwColorSpaceLowValue;

    // Allow colorkey override only when it's the original
    // colorkey owner, or no one owns the colorkey so far.
    if (gdwDestColorKeyOwnerVW == 0)
    {
      gdwDestColorKeyOwnerVW = dwVWFlag;
    }
    else if ((dwDestColorKey != gdwColorKey) &&
	  		     (dwOldStatus & dwVWFlag) &&
	  		     !(gdwDestColorKeyOwnerVW & dwVWFlag))
    {
      // ColorKey already been used by someone else.
      // It's not the original colorkey owner,
      // and the key color is not the same as the other one.
      lpInput->ddRVal = DDERR_OUTOFCAPS;
      return DDHAL_DRIVER_HANDLED;
    }

    // Is there sufficient bandwidth to work?
    gvidConfig.sizSrc.cx  = lpInput->rSrc.right  - lpInput->rSrc.left;
    gvidConfig.sizSrc.cy  = lpInput->rSrc.bottom - lpInput->rSrc.top;
    gvidConfig.sizDisp.cx = lpInput->rDest.right  - lpInput->rDest.left;
    gvidConfig.sizDisp.cy = lpInput->rDest.bottom - lpInput->rDest.top;
    gvidConfig.uSrcDepth  = dwBitCount;
    gvidConfig.uDispDepth = dwBitCount; //video window has the same depth as
                                        //the source
    gvidConfig.uGfxDepth  = BITSPERPIXEL;
    gvidConfig.dwFlags   |=  VCFLG_COLORKEY | VCFLG_DISP;

    if (!bUseBWEqn ||
        ChipIsEnoughBandwidth(&gsProgRegs, &gvidConfig, &bwregs)
       )
    {
      bCheckBandwidth = FALSE;
      lpSrcSurfaceData->dwOverlayFlags |= FLG_COLOR_KEY;

      if (lpInput->dwFlags & DDOVER_KEYDEST)
      {
        gdwColorKey = lpInput->lpDDDestSurface->ddckCKDestOverlay.dwColorSpaceLowValue;
        lpColorSurfaceVW[dwVWIndex] = lpInput->lpDDDestSurface;
      }
      else
      {
        gdwColorKey = lpInput->overlayFX.dckDestColorkey.dwColorSpaceLowValue;
      }
    }
    else
    {
      gvidConfig.dwFlags    &=  ~(VCFLG_COLORKEY | VCFLG_DISP);
      lpInput->ddRVal = DDERR_NOCOLORKEYHW;
      return DDHAL_DRIVER_HANDLED;
    }
  }
  else if (lpInput->dwFlags & (DDOVER_KEYSRC | DDOVER_KEYSRCOVERRIDE))
  {
    // Allow SrcColorKey override only when it's the original
    // colorkey owner, or no one owns the colorkey so far.
    if (gdwSrcColorKeyOwnerVW == 0)
    {
      gdwSrcColorKeyOwnerVW = dwVWFlag;
    }
    else if (!(dwOldStatus & gdwSrcColorKeyOwnerVW))
    {
      // It's not the original colorkey owner
      lpInput->ddRVal = DDERR_OUTOFCAPS;
      return DDHAL_DRIVER_HANDLED;
    }
    // Is there sufficient bandwidth to work?
    gvidConfig.sizSrc.cx  = lpInput->rSrc.right  - lpInput->rSrc.left;
    gvidConfig.sizSrc.cy  = lpInput->rSrc.bottom - lpInput->rSrc.top;
    gvidConfig.sizDisp.cx = lpInput->rDest.right  - lpInput->rDest.left;
    gvidConfig.sizDisp.cy = lpInput->rDest.bottom - lpInput->rDest.top;
    gvidConfig.uSrcDepth  = dwBitCount;
    gvidConfig.uDispDepth = dwBitCount;   //video window has the same as source
    gvidConfig.uGfxDepth  = BITSPERPIXEL;
    gvidConfig.dwFlags   |=  VCFLG_CHROMAKEY | VCFLG_DISP;

    if (!bUseBWEqn ||
        ChipIsEnoughBandwidth(&gsProgRegs, &gvidConfig, &bwregs)
       )
    {
      bCheckBandwidth = FALSE;
      lpSrcSurfaceData->dwOverlayFlags |= FLG_SRC_COLOR_KEY;

      lpSrcColorSurfaceVW[dwVWIndex] = lpInput->lpDDSrcSurface;

      if (lpInput->dwFlags & DDOVER_KEYSRC)
      {
        gdwSrcColorKeyLow = lpInput->lpDDSrcSurface->ddckCKSrcOverlay.dwColorSpaceLowValue;
        gdwSrcColorKeyHigh = lpInput->lpDDSrcSurface->ddckCKSrcOverlay.dwColorSpaceHighValue;
      }
      else
      {
        gdwSrcColorKeyLow = lpInput->overlayFX.dckSrcColorkey.dwColorSpaceLowValue;
        gdwSrcColorKeyHigh = lpInput->overlayFX.dckSrcColorkey.dwColorSpaceHighValue;
      }
      if (gdwSrcColorKeyHigh < gdwSrcColorKeyHigh)
      {
        gdwSrcColorKeyHigh = gdwSrcColorKeyLow;
      }
    }
    else
    {
      gvidConfig.dwFlags &= ~(VCFLG_CHROMAKEY | VCFLG_DISP);
      lpInput->ddRVal = DDERR_NOCOLORKEYHW;
      return DDHAL_DRIVER_HANDLED;
    }
  }

#ifdef WINNT_VER40
#if 0
	// The hardware is broken when using RGB32 data and ShrinkXBy2.
	if (   (dwFourcc == BI_RGB) && (dwBitCount == 32)
		&& (gvidConfig.sizSrc.cx > gvidConfig.sizDisp.cx)
		&& (lpSrcSurfaceData->dwOverlayFlags & (FLG_ENABLED | 0x02000000)) )
	{
		if (lpSrcSurfaceData->dwOverlayFlags & FLG_ENABLED)
		{
			// Turn the video off.
			DisableOverlay(ppdev, dwVWIndex);
			lpHardwareOwner[dwVWIndex] = NULL;
			lpSrcSurfaceData->dwOverlayFlags &= ~FLG_ENABLED;
			lpSrcSurfaceData->dwOverlayFlags |= 0x02000000;
		}

		if (lpSrcSurfaceData->dwOverlayFlags & FLG_VW_MASK)
		{
	    	PVGAR pREG = (PVGAR) lpDDHALData->RegsAddress;

			if (giOvlyCnt[dwVWIndex] > 0)
			{
				if (--giOvlyCnt[dwVWIndex] == 0)
				{
					// Get current DTTR, mask off FIFO threshold.
					WORD CurrentDTTR = pREG->grDisplay_Threshold_and_Tiling
							& 0xFFC0;

					// Fix PDR 9574: Restore FIFO threshold value when overlay
					// surface is destroyed, do not restore the tile size.  If
					// tile size has changed, we are likely in the middle of
					// changing video mode.  No need to restore FIFO in this
					// case.
					if ( CurrentDTTR == (gwNormalDTTR & 0xFFC0) )
					{
						pREG->grDisplay_Threshold_and_Tiling = CurrentDTTR
								| (gwNormalDTTR & 0x003F);
					}
				}
			}
		}
		else if (giOvlyCnt[dwVWIndex] > 0)
		{
			giOvlyCnt[dwVWIndex]--;
		}

		// Clear up the ownership of Dest ColorKey.
		gdwDestColorKeyOwnerVW &= ~(lpSrcSurfaceData->dwOverlayFlags
				& FLG_VW_MASK);

		// Clear up the ownership of Src ColorKey.
		gdwSrcColorKeyOwnerVW &= ~(lpSrcSurfaceData->dwOverlayFlags
				& FLG_VW_MASK);

		lpInput->ddRVal = DDERR_OUTOFCAPS;
		return(DDHAL_DRIVER_HANDLED);
	}
#else
	// The hardware is broken when using RGB32 data and ShrinkXBy2.
	if (   (dwFourcc == BI_RGB) && (dwBitCount == 32)
		&& (gvidConfig.sizSrc.cx > gvidConfig.sizDisp.cx)
		&& (lpSrcSurfaceData->dwOverlayFlags & FLG_ENABLED) )
	{
		// Turn the video off.
		DisableOverlay(ppdev, dwVWIndex);
		lpHardwareOwner[dwVWIndex] = NULL;
		lpSrcSurfaceData->dwOverlayFlags &= ~FLG_ENABLED;
		lpSrcSurfaceData->dwOverlayFlags |= 0x02000000;

		if (lpSrcSurfaceData->dwOverlayFlags & FLG_VW_MASK)
		{
	    	PVGAR pREG = (PVGAR) lpDDHALData->RegsAddress;

			if (giOvlyCnt[dwVWIndex] > 0)
			{
				if (--giOvlyCnt[dwVWIndex] == 0)
				{
					// Get current DTTR, mask off FIFO threshold.
					WORD CurrentDTTR = pREG->grDisplay_Threshold_and_Tiling
							& 0xFFC0;

					// Fix PDR 9574: Restore FIFO threshold value when overlay
					// surface is destroyed, do not restore the tile size.  If
					// tile size has changed, we are likely in the middle of
					// changing video mode.  No need to restore FIFO in this
					// case.
					if ( CurrentDTTR == (gwNormalDTTR & 0xFFC0) )
					{
						pREG->grDisplay_Threshold_and_Tiling = CurrentDTTR
								| (gwNormalDTTR & 0x003F);
					}
				}
			}
		}
		else if (giOvlyCnt[dwVWIndex] > 0)
		{
			giOvlyCnt[dwVWIndex]--;
		}

		// Clear up the ownership of Dest ColorKey.
		gdwDestColorKeyOwnerVW &= ~(lpSrcSurfaceData->dwOverlayFlags
				& FLG_VW_MASK);

		// Clear up the ownership of Src ColorKey.
		gdwSrcColorKeyOwnerVW &= ~(lpSrcSurfaceData->dwOverlayFlags
				& FLG_VW_MASK);

		lpInput->ddRVal = DDERR_OUTOFCAPS;
		return(DDHAL_DRIVER_HANDLED);
	}
	else if (lpSrcSurfaceData->dwOverlayFlags & 0x02000000)
	{
		if (gvidConfig.sizSrc.cx > gvidConfig.sizDisp.cx)
		{
			lpInput->ddRVal = DDERR_OUTOFCAPS;
			return(DDHAL_DRIVER_HANDLED);
		}
		lpSrcSurfaceData->dwOverlayFlags &= ~0x02000000;
	}
#endif
#endif /* WINNT_VER40 */

  // Because of Microsoft's Overfly bug we must ignore DDOVER_DDFX completely
  // or Overfly reports DDERR_UNSUPPORTED at least in 1024x768x16
  // So these guys can't even write a test app for WHQL that abides by their
  // own rules?
  if (lpInput->dwFlags & DDOVER_DDFX)
  {
#ifndef WINNT_VER40
    DBG_MESSAGE(("  overlayFX.dwFlags = %08lX", lpInput->overlayFX.dwFlags));
    DBG_MESSAGE(("  overlayFX.dwDDFX  = %08lX", lpInput->overlayFX.dwDDFX));
#endif

#if ENABLE_MIRRORING
    if (lpInput->overlayFX.dwDDFX & DDOVERFX_MIRRORLEFTRIGHT)
    {
      bIsVWMirrored[dwVWIndex] = TRUE;
    }
    // For some bizarre reason, Microsoft's WHQL Overfly app sets the
    // DDOVER_DDFX flag but sets overlayFX.dwDDFX with complete junk
    // overlayFX.dwFlags also has junk
    // so we must ignore dwDDFX flags we don't support rather than return an
    // error.  Gee that sound like good practice!
#if 0
    else
    {
      lpInput->ddRVal = DDERR_UNSUPPORTED;
      return DDHAL_DRIVER_HANDLED;
    }
#endif
#endif
  }

#if DDRAW_COMPAT >= 50
  if( lpInput->dwFlags & DDOVER_AUTOFLIP)
  {
      if(lpInput->lpDDSrcSurface->lpSurfMore->lpVideoPort)
      {
         if(lpInput->lpDDSrcSurface->lpSurfMore->lpVideoPort->dwNumAutoflip
            != 2)
         {
             //Hardware only support autoflip between 2 surfaces
             lpInput->ddRVal = DDERR_GENERIC;
             return (DDHAL_DRIVER_HANDLED);
         }
      }
      else
      {
           //Autoflip must use vport
           lpInput->ddRVal = DDERR_INVALIDPARAMS;
           return (DDHAL_DRIVER_HANDLED);
      }
  }
#endif

  if ( (lpInput->dwFlags & DDOVER_SHOW) || bShowOverlay)
  {
    // Is somebody else using our hardware?
    if (((lpHardwareOwner[dwVWIndex] != NULL) &&
         (lpHardwareOwner[dwVWIndex] != lpInput->lpDDSrcSurface)) ||
        ((lpHardwareOwner[dwVWIndex] == NULL) &&
#ifdef WINNT_VER40
         IsVWHardwareInUse(ppdev, dwVWIndex)
#else
         IsVWHardwareInUse(lpDDHALData,dwVWIndex)
#endif
        ))
    {
      lpInput->ddRVal = DDERR_OUTOFCAPS;
      return DDHAL_DRIVER_HANDLED;
    }

    // Is a valid destination surface specified?
    if (!(lpInput->lpDDDestSurface->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE))
    {
      lpInput->ddRVal = DDERR_INVALIDPARAMS;
      return DDHAL_DRIVER_HANDLED;
    }

    // Save the rectangles
#ifdef WINNT_VER40
    if (! SaveRectangles(ppdev, dwVWIndex, bCheckBandwidth, dwBitCount, lpInput))
#else
    if (! SaveRectangles(dwVWIndex, bCheckBandwidth, dwBitCount,lpInput,lpDDHALData))
#endif
    {
      // SaveRectangles sets lpInput->ddRVal on error
      return DDHAL_DRIVER_HANDLED;
    }

#if DDRAW_COMPAT >= 50
    lpInput->lpDDSrcSurface->lpSurfMore->dwOverlayFlags = lpInput->dwFlags;
#endif

    lpHardwareOwner[dwVWIndex] = lpInput->lpDDSrcSurface;
    lpSrcSurfaceData->dwOverlayFlags |= FLG_ENABLED;
#ifdef WINNT_VER40
    RegInitVideoVW(ppdev, dwVWIndex, lpInput->lpDDSrcSurface);
#else
    RegInitVideoVW(dwVWIndex, lpInput->lpDDSrcSurface, lpDDHALData);
#endif
  }
  else if (lpInput->dwFlags & DDOVER_HIDE)
  {
    if (lpHardwareOwner[dwVWIndex] == lpInput->lpDDSrcSurface)
    {
      lpHardwareOwner[dwVWIndex] = NULL;
      // clear panning show bit here

      // Turn the video off
      lpSrcSurfaceData->dwOverlayFlags &= ~FLG_ENABLED;
#ifdef WINNT_VER40
      DisableOverlay(ppdev, dwVWIndex);
#else
      DisableOverlay(lpDDHALData, dwVWIndex);
#endif
    }
  }
  else if (lpHardwareOwner[dwVWIndex] == lpInput->lpDDSrcSurface)
  {
    //Save the rectangles
#ifdef WINNT_VER40
    if (! SaveRectangles(ppdev, dwVWIndex, bCheckBandwidth, dwBitCount, lpInput))
#else
    if (! SaveRectangles(dwVWIndex, bCheckBandwidth, dwBitCount,lpInput,lpDDHALData))
#endif
    {
      // SaveRectangles sets lpInput->ddRVal on error
      return DDHAL_DRIVER_HANDLED;
    }
#if DDRAW_COMPAT >= 50
    lpInput->lpDDSrcSurface->lpSurfMore->dwOverlayFlags = lpInput->dwFlags;
#endif

#ifdef WINNT_VER40
    RegInitVideoVW(ppdev, dwVWIndex, lpInput->lpDDSrcSurface);
#else
    RegInitVideoVW(dwVWIndex, lpInput->lpDDSrcSurface, lpDDHALData);
#endif
  }

  lpInput->ddRVal = DD_OK;
  return DDHAL_DRIVER_HANDLED;
}

/***************************************************************************
*
* FUNCTION:     SetPosition
*
* DESCRIPTION:
*
****************************************************************************/

STATIC DWORD SetPosition
(
#ifdef WINNT_VER40
  PDEV                        *ppdev,
  PDD_SETOVERLAYPOSITIONDATA  lpInput
#else
  LPDDHAL_SETOVERLAYPOSITIONDATA lpInput
#endif
)
{
  LP_SURFACE_DATA   lpSrcSurfaceData;
  DWORD             dwVWIndex;
#ifndef WINNT_VER40
  LPGLOBALDATA    lpDDHALData = GetDDHALContext( lpInput->lpDD);
#endif

#ifndef WINNT_VER40
  DBG_MESSAGE(("Overlay SetPosition (lpInput = 0x%08lX)", lpInput));
#endif

  if (0 == lpInput->lpDDSrcSurface->dwReserved1)
  {
    lpInput->ddRVal = DDERR_NOTAOVERLAYSURFACE;
    return DDHAL_DRIVER_HANDLED;
  }
  lpSrcSurfaceData = GET_SURFACE_DATA_PTR(lpInput->lpDDSrcSurface);

  dwVWIndex = GetVideoWindowIndex(lpSrcSurfaceData->dwOverlayFlags);
  ASSERT(dwNumVideoWindows > dwVWIndex);

  if (lpHardwareOwner[dwVWIndex] == lpInput->lpDDSrcSurface)
  {
    // Update the rectangles
    grOverlayDest[dwVWIndex].right =
              (int)(grOverlayDest[dwVWIndex].right - grOverlayDest[dwVWIndex].left)
                          + (int)lpInput->lXPos;
    grOverlayDest[dwVWIndex].left = (int) lpInput->lXPos;
    grOverlayDest[dwVWIndex].bottom =
              (int)(grOverlayDest[dwVWIndex].bottom - grOverlayDest[dwVWIndex].top)
                          + (int)lpInput->lYPos;
    grOverlayDest[dwVWIndex].top = (int) lpInput->lYPos;

#ifdef WINNT_VER40
    RegMoveVideoVW(ppdev, dwVWIndex, lpInput->lpDDSrcSurface);
#else
    RegMoveVideoVW(dwVWIndex, lpInput->lpDDSrcSurface, lpDDHALData);
#endif
  }

  lpInput->ddRVal = DD_OK;
  return DDHAL_DRIVER_HANDLED;
}

/***************************************************************************
*
* FUNCTION:     GetOverlayFlipStatus
*
* DESCRIPTION:
*
****************************************************************************/

STATIC DWORD GetOverlayFlipStatus
(
#ifdef WINNT_VER40
  PDEV    *ppdev,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  FLATPTR fpVidMem,
  DWORD   dwVWIndex
)
{
  if (gsOverlayFlip.bFlipFlag &&
      ((fpVidMem == 0) || (fpVidMem == gsOverlayFlip.fpFlipFrom)))
  {
#if 1
    // if arm bit is set then some action is still pending
    // so fail
    ASSERT(dwNumVideoWindows > dwVWIndex);
    if (VW_ARM & ((PVGAR)lpDDHALData->RegsAddress)->VideoWindow[dwVWIndex].grVW_CONTROL0)
      return (DWORD)DDERR_WASSTILLDRAWING;
#else
    __int64 ttime;
    int     iTemp;


    DBG_MESSAGE(("GetOverlayFlipStatus (fpVidMem = 0x%08lX)", fpVidMem));

    // If the current scanline is less than the flip scan line,
    // we know that a VSYNC has occurred.
    iTemp = CurrentVLine(lpDDHALData);
    if (gsOverlayFlip.dwFlipScanline > (DWORD) iTemp)
    {
      // Don't allow access during the vertical retrace
      if (iTemp == 0)
      {
        if (gsOverlayFlip.bWasEverInDisplay)
        {
          gsOverlayFlip.bHaveEverCrossedVBlank = TRUE;
        }
        return (DWORD)DDERR_WASSTILLDRAWING;
      }
    }

    // Otherwise, we can check to see if 1) we have ever
    // been in a vertical retrace or 2) if a fixed amount of time
    // has expired.
    else if (gsOverlayFlip.bHaveEverCrossedVBlank == FALSE)
    {
      gsOverlayFlip.bWasEverInDisplay = TRUE;
      QueryPerformanceCounter((LARGE_INTEGER *)&ttime);
      if ((ttime-gsOverlayFlip.liFlipTime) <= gsOverlayFlip.dwFlipDuration)
      {
        return (DWORD)DDERR_WASSTILLDRAWING;
      }
    }
#endif
    gsOverlayFlip.bFlipFlag = FALSE;
  }

  return DD_OK;
}

/***************************************************************************
*
* FUNCTION:     ComputeVWZoomCodes
*
* DESCRIPTION:  Computes HACCUM_STP, HACCUM_SD,
*                        VACCUM_STP, VACCUM_SDA and VACCUM_SDB
*
****************************************************************************/

STATIC VOID ComputeVWZoomCodes
(
#ifdef WINNT_VER40
  PDEV    *ppdev,
#endif
  DWORD   dwVWIndex,
  VWDATA  *pVWData
)
{
  SIZEL Dst;
  SIZEL Src;


  Dst.cx = grOverlayDest[dwVWIndex].right - grOverlayDest[dwVWIndex].left;
  Src.cx = grOverlaySrc[dwVWIndex].right  - grOverlaySrc[dwVWIndex].left;

  if (Dst.cx == Src.cx)
  {
    // no horizontal resize
    pVWData->HACCUM_STP = 0x00010000;
  }
  else if (Dst.cx > Src.cx)
  {
    // make sure we aren't going beyond hw capabilities
    ASSERT(Dst.cx <= 8 * Src.cx);

    // horizontal stretch
    //
    // ideally zoom code = 256 * (256 * Src.cx / Dst.cx)
    // we always want to truncate (256 * Src.cy / Dst.cx)
    // because truncating will give us back a Src.cx which is less than or
    // equal to the actual width of the source and we will never overrun the
    // source extent (and won't get the green stripe)
    pVWData->HACCUM_STP = (256 * 256 * Src.cx) / Dst.cx;
  }
  else
  {
    // make sure we aren't going beyond hw capabilities
    ASSERT(2 * Dst.cx >= Src.cx);

    // horizontal shrink
    //
    // this is the zoom code for Src.cx/2 be stretched to Dst.cx

    // using 128 seems to give a zoom code one too high
    // then we get the green stripe on the right edge of the video
    pVWData->HACCUM_STP = (256 * 127 * Src.cx) / Dst.cx;
    pVWData->CONTROL0 |= VW_XShrinkBy2;
  }
  // Just set horizontal seeds to zero for now
  pVWData->HACCUM_SD = 0;

  Dst.cy = grOverlayDest[dwVWIndex].bottom - grOverlayDest[dwVWIndex].top;
  Src.cy = grOverlaySrc[dwVWIndex].bottom  - grOverlaySrc[dwVWIndex].top;

  if (Dst.cy == Src.cy)
  {
    pVWData->VACCUM_STP = 0x00010000;
  }
  else if (Dst.cy > Src.cy)
  {
    // make sure we aren't going beyond hw capabilities
    ASSERT(Dst.cy <= 8 * Src.cy);

    // vertical stretch
    //
    // ideally zoom code = 256 * (256 * Src.cy / Dst.cy)
    // we always want to truncate (256 * Src.cy / Dst.cy)
    // because truncating will give us back a Src.cy which is less than or
    // equal to the actual size of the source and we will never overrun the
    // source extent (and won't get the green stripe)

    // using 256 seems to give a zoom code one too high for full screen
    // then we get garbage on the bottom of the screen
    pVWData->VACCUM_STP = (256 * 255 * Src.cy) / Dst.cy;
  }
  else
  {
    // vertical shrink
    //
    // ideally zoom code = 256 * (256 * Dst.cy / Src.cy)
    // we always want to round up (256 * Dst.cy / Src.cy)
    // because rounding up will give us back a Src.cy which is less than or
    // equal to the actual size of the source and we will never overrun the
    // source extent (and won't get the green stripe)
    pVWData->VACCUM_STP = (256 * 256 * Dst.cy + 256 * (Src.cy - 1)) / Src.cy;
    pVWData->CONTROL1 |= VW_YShrinkEn;
 }
  // Just set vertical seeds to zero for now
  pVWData->VACCUM_SDA = 0;
  pVWData->VACCUM_SDB = 0;
}

/***************************************************************************
*
* FUNCTION:     ComputeVWPositionData
*
* DESCRIPTION:  Computes HSTRT, HEND, HSDSZ, VSTRT, VEND,
*                        PD_STRT_ADDR and SD_PITCH
*
****************************************************************************/

STATIC VOID
ComputeVWPositionData ( PRECTL                      pVideoRect,
                        PRECTL                      pOverlaySrc,
                        PRECTL                      pOverlayDest,
#ifdef WINNT_VER40
                        PDD_SURFACE_GLOBAL          pGbl,
#else
                        LPDDRAWI_DDRAWSURFACE_GBL   pGbl,
                        LPGLOBALDATA                lpDDHALData,
#endif
                        DWORD                       dwBitCount,
                        VWDATA                      *pVWData,
                        BOOL                        bCLPL )
{
  DWORD   dwSurfBase,dwSurfOffset;


  pVWData->HSTRT = LOWORD(pVideoRect->left);
  pVWData->HEND  = LOWORD(pVideoRect->right) - 1;
  pVWData->HSDSZ = (WORD)(pOverlaySrc->right - pOverlaySrc->left);

  pVWData->VSTRT = LOWORD(pVideoRect->top);
  pVWData->VEND  = LOWORD(pVideoRect->bottom) - 1;

#ifdef WINNT_VER40
  dwSurfBase = pGbl->fpVidMem;
#else
  dwSurfBase = (pGbl->fpVidMem - lpDDHALData->ScreenAddress);
#endif
  dwSurfOffset = pOverlaySrc->top * pGbl->lPitch +
                 pOverlaySrc->left * (dwBitCount / 8);
  pVWData->PSD_STRT_ADDR = dwSurfBase + dwSurfOffset;

#if ENABLE_YUVPLANAR
  if (bCLPL)
  {
    // qword aligned offset of UV interleaved data in aperture 0
    // need same offset into UV data as offset into Y data
    // so it's just PSD_STRT_ADDR plus area of Y data
    pVWData->PSD_UVSTRT_ADDR = dwSurfBase +
                               (((pGbl->wHeight * pGbl->lPitch) + 7) & ~7) +
                               (dwSurfOffset / 2);
  }
  else
    pVWData->PSD_UVSTRT_ADDR = 0;
#endif

#if ENABLE_MIRRORING
  if (bIsVWMirrored[dwVWIndex])
  {
    // for mirroring
    // point to the last byte of the last pixel on the right edge of the source
    pVWData->PSD_STRT_ADDR += (DWORD)(pOverlaySrc->right - pOverlaySrc->left  - 1);
  }
#endif

  pVWData->SD_PITCH = (WORD)(pGbl->lPitch);
}

/***************************************************************************
*
* FUNCTION:     RGBtoYCrCb
*
* DESCRIPTION:  Conversion equations are from page 42 of the second edition
*               of "Video Demystified" by Keith Jack
*
****************************************************************************/

STATIC DWORD INLINE
RGBtoYCbCr ( DWORD dwRGB )
{
  long  Y, Cr, Cb;
  long  r, g, b;


  r = (dwRGB & 0xF800) >> 8;
  g = (dwRGB & 0x07E0) >> 3;
  b = (dwRGB & 0x001F) << 3;

  Y  = ( 77 * r + 150 * g +  29 * b) / 256;
  // max value of Y from this is if r, g & b are all 255 then Y = 255
  // min value of Y from this is if r, g & b are all   0 then Y = 0
  // so don't need to clamp Y

  Cb = (-44 * r -  87 * g + 131 * b) / 256 + 128;
  // max value of Cb is if r & g are 0 and b is 255 then Cb = 258
  // min value of Cb is if r & g are 255 and b is 0 then Cb =  -2
  // so need to clamp Cb between 0 and 255
  if (255 < Cb)
    Cb = 255;
  else if (0 > Cb)
    Cb = 0;

  Cr = (131 * r - 110 * g -  21 * b) / 256 + 128;
  // max value of Cr is if r is 255 and g & b are 0 then Cr = 258
  // min value of Cr is if r is 0 and g & b are 255 then Cr =  -2
  // so need to clamp Cr between 0 and 255
  if (255 < Cr)
    Cr = 255;
  else if (0 > Cr)
    Cr = 0;

  return (((Y & 0xFF) << 16) | ((Cb & 0xFF) << 8) | ((Cr & 0xFF)));
}

/***************************************************************************
*
* FUNCTION:     DetermineVWColorKeyData
*
* DESCRIPTION:  Determines CLRKEY_MIN & CLRKEY_MAX or
*                          CHRMKEY_MIN & CHRMKEY_MAX
*
****************************************************************************/

STATIC VOID DetermineVWColorKeyData
(
#ifdef WINNT_VER40
  PDEV    *ppdev,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD   dwOverlayFlags,
  DWORD   dwBitCount,
  VWDATA  *pVWData
)
{
  if (FLG_COLOR_KEY & dwOverlayFlags)
  {
    // destination color key, uses color key on 5465
    pVWData->CLRKEY_MIN = gdwColorKey;
    pVWData->CLRKEY_MAX = gdwColorKey;
    pVWData->CONTROL0 &= ~VW_OCCLUDE_MASK;
    pVWData->CONTROL0 |= (COLOR_KEY << OCCLUDE_SHIFT);
  }
  else if (FLG_SRC_COLOR_KEY & dwOverlayFlags)
  {
    PVGAR     pREG = (PVGAR)lpDDHALData->RegsAddress;
    BYTE      r,g,b;

    // source color key, uses chroma key on 5465
    switch (dwBitCount)
    {
      case  8:
        // read colors from the DAC
        LL8(grPalette_Read_Address,(BYTE)(gdwSrcColorKeyLow & 0xFF));
        r = pREG->grPalette_Data;
        g = pREG->grPalette_Data;
        b = pREG->grPalette_Data;
        pVWData->CHRMKEY_MIN = ((DWORD)(r) << 16) |
                               ((DWORD)(g) <<  8) |
                               ((DWORD)(b));
        LL8(grPalette_Read_Address,(BYTE)(gdwSrcColorKeyHigh & 0xFF));
        r = pREG->grPalette_Data;
        g = pREG->grPalette_Data;
        b = pREG->grPalette_Data;
        pVWData->CHRMKEY_MAX = ((DWORD)(r) << 16) |
                               ((DWORD)(g) <<  8) |
                               ((DWORD)(b));
        break;

      case 16:

        if ((FLG_UYVY | FLG_YUY2) & dwOverlayFlags)
        {
          // Since we are currently using ITU 601 compliant YUV data
          // convert color key to YCrCb
          pVWData->CHRMKEY_MIN = RGBtoYCbCr(gdwSrcColorKeyLow);
          pVWData->CHRMKEY_MAX = RGBtoYCbCr(gdwSrcColorKeyHigh);
        }
        else
        {
          // convert 5:6:5 to true color
          pVWData->CHRMKEY_MIN = ((gdwSrcColorKeyLow  & 0xF800) << 8) |   // red
                                 ((gdwSrcColorKeyLow  & 0x07E0) << 5) |   // green
                                 ((gdwSrcColorKeyLow  & 0x001F) << 3);    // blue
          pVWData->CHRMKEY_MAX = ((gdwSrcColorKeyHigh & 0xF800) << 8) |   // red
                                 ((gdwSrcColorKeyHigh & 0x07E0) << 5) |   // green
                                 ((gdwSrcColorKeyHigh & 0x001F) << 3);    // blue
        }
        break;

      case 24:
      case 32:
        pVWData->CHRMKEY_MIN = (gdwSrcColorKeyLow  & 0x00FFFFFF);
        pVWData->CHRMKEY_MAX = (gdwSrcColorKeyHigh & 0x00FFFFFF);
        break;
    }
    pVWData->CONTROL0 &= ~VW_OCCLUDE_MASK;
    pVWData->CONTROL0 |= (CHROMA_KEY << OCCLUDE_SHIFT);
  }
  else
  {
    pVWData->CONTROL0 &= ~VW_OCCLUDE_MASK;
    pVWData->CONTROL0 |= (NO_OCCLUSION << OCCLUDE_SHIFT);
  }
}

/***************************************************************************
*
* FUNCTION:     ComputeVWFifoThreshold
*
* DESCRIPTION:
*
****************************************************************************/

static INLINE VOID ComputeVWFifoThreshold
(
#ifdef WINNT_VER40
  PDEV    *ppdev,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  VWDATA  *pVWData
)
{
  PVGAR   pREG = (PVGAR)lpDDHALData->RegsAddress;


  pREG->grDisplay_Threshold_and_Tiling =
                      (pREG->grDisplay_Threshold_and_Tiling & 0xFFC0) |
                      (gsProgRegs.DispThrsTiming & 0x003F);

  pVWData->FIFO_THRSH = gsProgRegs.VW0_FIFO_THRSH;
}

/***************************************************************************
*
* FUNCTION:     PanOverlay1_Init
*
* DESCRIPTION:  Save data for panning overlay window one.
*               Clip lpVideoRect to panning viewport.
*
****************************************************************************/

static INLINE VOID PanOverlay1_Init
(
#ifdef WINNT_VER40
  PDEV    *ppdev,
#endif
  LPRECTL lpVideoRect,
  LPRECTL lpOverlaySrc,
  LPRECTL lpOverlayDest
)
{
  // This is not necessary on Laguna since we can't pan the screen

  // clip left edge of destination
  if (0 > (lpVideoRect->left = lpOverlayDest->left))
    lpVideoRect->left = 0;

  // clip right edge of destination
#ifdef WINNT_VER40
  if ((LONG)ppdev->cxScreen < (lpVideoRect->right = lpOverlayDest->right))
    lpVideoRect->right = (LONG)ppdev->cxScreen;
#else
  if ((LONG)pPDevice->deWidth < (lpVideoRect->right = lpOverlayDest->right))
    lpVideoRect->right = (LONG)pPDevice->deWidth;
#endif

  // clip top edge of destination
  if (0 > (lpVideoRect->top = lpOverlayDest->top))
    lpVideoRect->top = 0;

  // clip bottom edge of destination
#ifdef WINNT_VER40
  if ((LONG)ppdev->cyScreen < (lpVideoRect->bottom = lpOverlayDest->bottom))
    lpVideoRect->bottom = (LONG)ppdev->cyScreen;
#else
  if ((LONG)pPDevice->deHeight < (lpVideoRect->bottom = lpOverlayDest->bottom))
    lpVideoRect->bottom = (LONG)pPDevice->deHeight;
#endif
}

/***************************************************************************
*
* FUNCTION:     RegInitVideoVW
*
* DESCRIPTION:  This function is called to program the video format and
*               the physical offset of the Video Window video data
*               in the frame buffer.
*
****************************************************************************/

STATIC BOOL RegInitVideoVW
(
#ifdef WINNT_VER40
  PDEV              *ppdev,
  DWORD             dwVWIndex,
  PDD_SURFACE_LOCAL lpSurface
#else
  DWORD                     dwVWIndex,
  LPDDRAWI_DDRAWSURFACE_LCL lpSurface,
  LPGLOBALDATA              lpDDHALData
#endif
)
{
  LP_SURFACE_DATA   lpSurfaceData = GET_SURFACE_DATA_PTR(lpSurface);
  VWDATA            VWData;
  BOOL              bOverlayTooSmall = FALSE;
  DWORD             dwFourcc;
  LONG              lPitch;
  DWORD             dwBitCount;
  RECTL             rVideoRect;
  PVGAR             pREG = (PVGAR)lpDDHALData->RegsAddress;
#if DDRAW_COMPAT >= 50
  DWORD             dwSrfFlags = FALSE;
#endif
  DWORD             width;
//////#ifndef WINNT_VER40
  PDD_ATTACHLIST    lpSurfaceAttached;
  LP_SURFACE_DATA   lpSurfaceDataTmp;
//////#endif

  ASSERT(dwNumVideoWindows > dwVWIndex);

  // Determine the format of the video data
  if (lpSurface->dwFlags & DDRAWISURF_HASPIXELFORMAT)
  {
    GetFormatInfo(&(lpSurface->lpGbl->ddpfSurface), &dwFourcc, &dwBitCount);
  }
  else
  {
    dwBitCount = BITSPERPIXEL;
    if (16 == dwBitCount)
      dwFourcc = BI_BITFIELDS;    // 5:6:5
    else
      dwFourcc = BI_RGB;          // 8bpp, 5:5:5, 24bpp & 32bpp
  }

#ifdef WINNT_VER40
  PanOverlay1_Init(ppdev,&rVideoRect,&grOverlaySrc[dwVWIndex],&grOverlayDest[dwVWIndex]);
#else
  PanOverlay1_Init(&rVideoRect,&grOverlaySrc[dwVWIndex],&grOverlayDest[dwVWIndex]);
#endif

  // rVideoRect is now adjusted and clipped to the panning viewport.
  // Disable overlay if totally clipped by viewport.
  if (((rVideoRect.right - rVideoRect.left) <= 0) ||
      ((rVideoRect.bottom- rVideoRect.top ) <= 0))
  {
#ifdef WINNT_VER40
    DisableOverlay(ppdev, dwVWIndex);
#else
    DisableOverlay(lpDDHALData,dwVWIndex);
#endif
    return TRUE;
  }

  memset(&VWData, 0, sizeof(VWData));

  lPitch = lpSurface->lpGbl->lPitch;

#ifdef WINNT_VER40
  ComputeVWZoomCodes(ppdev, dwVWIndex, &VWData);
#else
  ComputeVWZoomCodes(dwVWIndex, &VWData);
#endif

  ComputeVWPositionData(&rVideoRect,
                        &grOverlaySrc[dwVWIndex],
                        &grOverlayDest[dwVWIndex],
                        lpSurface->lpGbl,
#ifndef     WINNT_VER40
                        lpDDHALData,
#endif
                        dwBitCount,
                        &VWData,
                        FOURCC_YUVPLANAR == dwFourcc);

   lpSurfaceData->dwOverlayOffset =  //This offset will be used in FlipOverlay
          VWData.PSD_STRT_ADDR  -  // and VPE
         lpSurface->lpGbl->fpVidMem
#ifndef WINNT_VER40
         + lpDDHALData->ScreenAddress
#endif
         ;

/////////#ifndef WINNT_VER40

 //Update all the attached surfaces
 lpSurfaceAttached = lpSurface->lpAttachListFrom;

 while( lpSurfaceAttached)
 {
    if(lpSurfaceAttached->lpAttached)
    {
       lpSurfaceDataTmp = GET_SURFACE_DATA_PTR(lpSurfaceAttached->lpAttached);
       lpSurfaceDataTmp->dwOverlayOffset = lpSurfaceData->dwOverlayOffset;
       lpSurfaceAttached = lpSurfaceAttached->lpAttached->lpAttachListFrom;
    }
    else
        break;

 }
 
 lpSurfaceAttached = lpSurface->lpAttachList;

 while( lpSurfaceAttached)
 {
    if(lpSurfaceAttached->lpAttached)
    {
       lpSurfaceDataTmp = GET_SURFACE_DATA_PTR(lpSurfaceAttached->lpAttached);
       lpSurfaceDataTmp->dwOverlayOffset = lpSurfaceData->dwOverlayOffset;
       lpSurfaceAttached = lpSurfaceAttached->lpAttached->lpAttachList;
    }
    else
        break;

 }

//////////#endif

#if ENABLE_MIRRORING
  // Mirror Video Windows support.
  if (bIsVWMirrored[dwVWIndex])
    VWData.CONTROL0 |= VW_HMIRR_EN;
#endif
  // Xing, isn't the memset above enough?
  VWData.SSD_STRT_ADDR = 0L;
#if DDRAW_COMPAT >= 50
  if (gwNotify & VPE_ON)
  {
    if((lpSurface->lpSurfMore->lpVideoPort != NULL)&&
       (lpSurface->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT))
    {
      if((lpSurface->lpSurfMore->dwOverlayFlags & DDOVER_BOB)
         &&(lpSurface->lpSurfMore->lpVideoPort->ddvpInfo.dwVPFlags
                & DDVP_INTERLEAVE))
      {
        dwSrfFlags = DDOVER_BOB;
      }
      else if((lpSurface->lpSurfMore->lpVideoPort->ddvpInfo.dwVPFlags
                    &DDVP_AUTOFLIP)
            &&(lpSurface->lpSurfMore->dwOverlayFlags & DDOVER_AUTOFLIP)
            && (lpSurface->lpAttachListFrom != NULL)
            && (lpSurface->lpAttachListFrom->lpAttached != NULL))
      {
          dwSrfFlags = DDOVER_AUTOFLIP;
      }
    }
  }

  if((dwSrfFlags & DDOVER_BOB)
   ||(!dwSrfFlags
    &&(lpSurface->lpSurfMore->dwOverlayFlags & DDOVER_INTERLEAVED)))
  {
      RECTL   rcTemp;
       rcTemp = grOverlaySrc[dwVWIndex];
       grOverlaySrc[dwVWIndex].top >>=1;
       grOverlaySrc[dwVWIndex].bottom >>=1;    //use half source size to
       VWData.CONTROL1 &= ~VW_YShrinkEn;       //find zoom factor
       ComputeVWZoomCodes(dwVWIndex, &VWData);
       grOverlaySrc[dwVWIndex] = rcTemp;

       VWData.SD_PITCH <<= 1;
       VWData.CONTROL0 &= ~0x30000ul;
       if(dwSrfFlags & DDOVER_BOB)
       {
           VWData.SSD_STRT_ADDR = VWData.PSD_STRT_ADDR + lPitch;
           VWData.CONTROL0 |= 0x20000ul;        //enable buffer two
       }

  }
  else if(dwSrfFlags & DDOVER_AUTOFLIP)
  {

     VWData.SSD_STRT_ADDR =  lpSurfaceData->dwAutoBaseAddr2 +
                                  lpSurfaceData->dwOverlayOffset;
     if( VWData.PSD_STRT_ADDR == VWData.SSD_STRT_ADDR )
     {
          VWData.PSD_STRT_ADDR = lpSurfaceData->dwAutoBaseAddr1 +
                                   lpSurfaceData->dwOverlayOffset;
      }

      VWData.CONTROL0 &= ~0x30000ul;
      VWData.CONTROL0 |= 0x20000ul;     //enable the second buffer
      if(!(lpSurface->lpSurfMore->dwOverlayFlags & DDOVER_BOB))
      {
        //For non-smooth-interlaced auto-flip these two address need
        // to be switched.  HW BUG
         DWORD dwTmp = VWData.PSD_STRT_ADDR;
         VWData.PSD_STRT_ADDR = VWData.SSD_STRT_ADDR;
         VWData.SSD_STRT_ADDR = dwTmp;
      }
  }

  if(lpSurface->lpSurfMore->dwOverlayFlags & DDOVER_BOB)
  {
     BOOL fSDAHalf = TRUE;
#if ENABLE_MIRRORING
     if (lpInput->overlayFX.dwDDFX & DDOVERFX_MIRRORLEFTRIGHT)
         fSDAHalf = !fSDAHalf;
#endif
     if(VWData.VACCUM_STP >= 0x8000ul)
          fSDAHalf = !fSDAHalf;

     if(fSDAHalf)
     {
            VWData.VACCUM_SDA = 0x8000ul;
            VWData.VACCUM_SDB = 0ul;
     }
     else
     {
            VWData.VACCUM_SDA = 0ul;
            VWData.VACCUM_SDB = 0x8000ul;
     }
     VWData.CONTROL0 |= 0x8ul;
  }
#endif

  if (lpSurfaceData->dwOverlayFlags & FLG_ENABLED)
    VWData.CONTROL0 |= (VW_VWE | VW_ARM);

  // set source data format
  if (dwFourcc == BI_RGB)
  {
    if (dwBitCount == 16)
    {
      VWData.CONTROL0 |= (SD_RGB16_555 << SD_FRMT_SHIFT);
    }
#if ENABLE_SD_RGB32
    else if (dwBitCount == 32)
    {
      VWData.CONTROL0 |= (SD_RGB32 << SD_FRMT_SHIFT);
    }
#endif
  }
  else if (dwFourcc == BI_BITFIELDS)
  {
    VWData.CONTROL0 |= (SD_RGB16_565 << SD_FRMT_SHIFT);
  }
#if ENABLE_YUVPLANAR
  else if (dwFourcc == FOURCC_YUVPLANAR)
  {
    VWData.CONTROL0 |= (SD_YUV420 << SD_FRMT_SHIFT);
  }
#endif
  else if (FOURCC_UYVY == dwFourcc)
  {
    VWData.CONTROL0 |= (SD_YUV422 << SD_FRMT_SHIFT);
  }

#ifdef WINNT_VER40
  DetermineVWColorKeyData(ppdev, lpSurfaceData->dwOverlayFlags, dwBitCount, &VWData);
#else
  DetermineVWColorKeyData(lpDDHALData,lpSurfaceData->dwOverlayFlags, dwBitCount, &VWData);
#endif

#ifdef WINNT_VER40
  ComputeVWFifoThreshold(ppdev, &VWData);
#else
  ComputeVWFifoThreshold(lpDDHALData,&VWData);
#endif

  // Now start programming the registers
#ifdef WINNT_VER40
  WaitForVWArmToClear(ppdev, dwVWIndex);
#else
  WaitForVWArmToClear(lpDDHALData, dwVWIndex);
#endif
  ASSERT(! (pREG->VideoWindow[dwVWIndex].grVW_TEST0 & VW_PostImed));

  LL16(VideoWindow[dwVWIndex].grVW_HSTRT,         VWData.HSTRT);
  LL16(VideoWindow[dwVWIndex].grVW_HEND,          VWData.HEND);
  LL16(VideoWindow[dwVWIndex].grVW_HSDSZ,         VWData.HSDSZ);
  LL32(VideoWindow[dwVWIndex].grVW_HACCUM_STP,    VWData.HACCUM_STP);
  LL32(VideoWindow[dwVWIndex].grVW_HACCUM_SD,     VWData.HACCUM_SD);
  LL16(VideoWindow[dwVWIndex].grVW_VSTRT,         VWData.VSTRT);
  LL16(VideoWindow[dwVWIndex].grVW_VEND,          VWData.VEND);
  LL32(VideoWindow[dwVWIndex].grVW_VACCUM_STP,    VWData.VACCUM_STP);
  LL32(VideoWindow[dwVWIndex].grVW_VACCUM_SDA,    VWData.VACCUM_SDA);
  LL32(VideoWindow[dwVWIndex].grVW_VACCUM_SDB,    VWData.VACCUM_SDB);
  LL32(VideoWindow[dwVWIndex].grVW_PSD_STRT_ADDR, VWData.PSD_STRT_ADDR);
  LL32(VideoWindow[dwVWIndex].grVW_SSD_STRT_ADDR, VWData.SSD_STRT_ADDR);
#if ENABLE_YUVPLANAR
  if (dwFourcc == FOURCC_YUVPLANAR)
  {
    LL32(VideoWindow[dwVWIndex].grVW_PSD_UVSTRT_ADDR, VWData.PSD_UVSTRT_ADDR);
    LL32(VideoWindow[dwVWIndex].grVW_SSD_UVSTRT_ADDR, VWData.SSD_UVSTRT_ADDR);
  }
#endif
  LL16(VideoWindow[dwVWIndex].grVW_SD_PITCH,      VWData.SD_PITCH);

  if (FLG_SRC_COLOR_KEY & lpSurfaceData->dwOverlayFlags)
  {
    LL32(VideoWindow[dwVWIndex].grVW_CHRMKEY_MIN, VWData.CHRMKEY_MIN);
    LL32(VideoWindow[dwVWIndex].grVW_CHRMKEY_MAX, VWData.CHRMKEY_MAX);
  }
  else if (FLG_COLOR_KEY & lpSurfaceData->dwOverlayFlags)
  {
    LL32(VideoWindow[dwVWIndex].grVW_CLRKEY_MIN, VWData.CLRKEY_MIN);
    LL32(VideoWindow[dwVWIndex].grVW_CLRKEY_MAX, VWData.CLRKEY_MAX);
  }

  LL16(VideoWindow[dwVWIndex].grVW_FIFO_THRSH, VWData.FIFO_THRSH);
  LL32(VideoWindow[dwVWIndex].grVW_CONTROL1,   VWData.CONTROL1);

  // fix for PDR #10815
  // if src width >= 1536 bytes (or 3072 bytes for shrink)
  // disable vertical interpolation
  width = (grOverlaySrc[dwVWIndex].right - grOverlaySrc[dwVWIndex].left) * (dwBitCount / 8);
  if (VW_YShrinkEn & VWData.CONTROL1)
    width /= 2;
  if (width >= 1536)
  {
    // set replication bit in TEST0 reg
    pREG->VideoWindow[dwVWIndex].grVW_TEST0 |= VWVRepEnable;
  }
  else
  {
    // clear replication bit in TEST0 reg
    pREG->VideoWindow[dwVWIndex].grVW_TEST0 &= ~VWVRepEnable;
  }

  // write last to arm
  LL32(VideoWindow[dwVWIndex].grVW_CONTROL0,   VWData.CONTROL0);

  return TRUE;
}

/***************************************************************************
*
* FUNCTION:     RegMoveVideoVW
*
* DESCRIPTION:  This function is called to move the video window that has
*               already been programed.
*
****************************************************************************/

STATIC VOID RegMoveVideoVW
(
#ifdef WINNT_VER40
  PDEV              *ppdev,
  DWORD             dwVWIndex,
  PDD_SURFACE_LOCAL lpSurface
#else
  DWORD                     dwVWIndex,
  LPDDRAWI_DDRAWSURFACE_LCL lpSurface,
  LPGLOBALDATA              lpDDHALData
#endif
)
{
  LP_SURFACE_DATA   lpSurfaceData = GET_SURFACE_DATA_PTR(lpSurface);
  VWDATA            VWData;
  DWORD             dwFourcc;
  LONG              lPitch;
  DWORD             dwBitCount;
  RECTL             rVideoRect;
  PVGAR             pREG = (PVGAR)lpDDHALData->RegsAddress;


  ASSERT(dwNumVideoWindows > dwVWIndex);

  // Determine the format of the video data
  if (lpSurface->dwFlags & DDRAWISURF_HASPIXELFORMAT)
  {
    GetFormatInfo (&(lpSurface->lpGbl->ddpfSurface), &dwFourcc, &dwBitCount);
  }
  else
  {
    dwBitCount = BITSPERPIXEL;
    if (16 == dwBitCount)
      dwFourcc = BI_BITFIELDS;    // 5:6:5
    else
      dwFourcc = BI_RGB;          // 8bpp, 5:5:5, 24bpp & 32bpp
  }

#ifdef WINNT_VER40
  PanOverlay1_Init(ppdev,&rVideoRect,&grOverlaySrc[dwVWIndex],&grOverlayDest[dwVWIndex]);
#else
  PanOverlay1_Init(&rVideoRect,&grOverlaySrc[dwVWIndex],&grOverlayDest[dwVWIndex]);
#endif

  // rVideoRect is now adjusted and clipped to the panning viewport.
  // Disable overlay if totally clipped by viewport.
  if (((rVideoRect.right - rVideoRect.left) <= 0) ||
      ((rVideoRect.bottom- rVideoRect.top ) <= 0))
  {
#ifdef WINNT_VER40
    DisableOverlay(ppdev, dwVWIndex);
#else
    DisableOverlay(lpDDHALData, dwVWIndex);
#endif
    return;
  }

  memset(&VWData, 0, sizeof(VWData));
  VWData.CONTROL0 = pREG->VideoWindow[dwVWIndex].grVW_CONTROL0;
  if (lpSurfaceData->dwOverlayFlags & FLG_ENABLED)
    VWData.CONTROL0 |= VW_VWE;
  VWData.CONTROL0 |= VW_ARM;

  lPitch = lpSurface->lpGbl->lPitch;

  // if shrink in x, set shrink x by 2 bit in CONTROL0
  // shrink in y is okay, because that bit is in CONTROL1 and
  // we aren't touching CONTROL1 here
  if ((grOverlayDest[dwVWIndex].right - grOverlayDest[dwVWIndex].left) <
      (grOverlaySrc[dwVWIndex].right  - grOverlaySrc[dwVWIndex].left))
  {
    VWData.CONTROL0 |= VW_XShrinkBy2;
  }

  ComputeVWPositionData(&rVideoRect,
                        &grOverlaySrc[dwVWIndex],
                        &grOverlayDest[dwVWIndex],
                        lpSurface->lpGbl,
#ifndef   WINNT_VER40
                        lpDDHALData,
#endif
                        dwBitCount,
                        &VWData,
                        FOURCC_YUVPLANAR == dwFourcc);

#if ENABLE_MIRRORING
  if (bIsVWMirrored[dwVWIndex])
    VWData.CONTROL0 |= VW_HMIRR_EN;
#endif
  // Xing, isn't the memset above enough?
  VWData.SSD_STRT_ADDR = 0;
#if DDRAW_COMPAT >= 50
  if( gwNotify & VPE_ON)
  {
   if(lpSurface->lpSurfMore->lpVideoPort != NULL)
   {
     if((lpSurface->lpSurfMore->lpVideoPort->ddvpInfo.dwVPFlags
                &DDVP_AUTOFLIP)
        && (lpSurface->lpSurfMore->dwOverlayFlags & DDOVER_AUTOFLIP)
        && (lpSurface->lpAttachListFrom != NULL)
        && (lpSurface->lpAttachListFrom->lpAttached != NULL))
     {

         VWData.SSD_STRT_ADDR =  lpSurfaceData->dwAutoBaseAddr2 +
                                  lpSurfaceData->dwOverlayOffset;
         if( VWData.PSD_STRT_ADDR == VWData.SSD_STRT_ADDR )
         {
             VWData.PSD_STRT_ADDR = lpSurfaceData->dwAutoBaseAddr1 +
                                     lpSurfaceData->dwOverlayOffset;
         }
         VWData.CONTROL0 &= ~0x30000ul;
         VWData.CONTROL0 |= 0x20000ul;     //enable the second buffer

         if(!(lpSurface->lpSurfMore->dwOverlayFlags & DDOVER_BOB))
         {
           //For non-smooth-interlaced auto-flip these two address need
           // to be switched.  HW BUG
           DWORD dwTmp = VWData.PSD_STRT_ADDR;
           VWData.PSD_STRT_ADDR = VWData.SSD_STRT_ADDR;
           VWData.SSD_STRT_ADDR = dwTmp;
         }
     }
    else if((lpSurface->lpSurfMore->dwOverlayFlags & DDOVER_BOB)
         &&(lpSurface->lpSurfMore->lpVideoPort->ddvpInfo.dwVPFlags
                & DDVP_INTERLEAVE))
     {
          VWData.SSD_STRT_ADDR = VWData.PSD_STRT_ADDR + lPitch;
     }
    }
  }
#endif

  // Now start programming the registers
  ASSERT(! (pREG->VideoWindow[dwVWIndex].grVW_TEST0 & VW_PostImed));
#ifdef WINNT_VER40
  WaitForVWArmToClear(ppdev, dwVWIndex);
#else
  WaitForVWArmToClear(lpDDHALData, dwVWIndex);
#endif

  LL16(VideoWindow[dwVWIndex].grVW_HSTRT, VWData.HSTRT);
  LL16(VideoWindow[dwVWIndex].grVW_HEND,  VWData.HEND);
  LL16(VideoWindow[dwVWIndex].grVW_HSDSZ, VWData.HSDSZ);
  LL16(VideoWindow[dwVWIndex].grVW_VSTRT, VWData.VSTRT);
  LL16(VideoWindow[dwVWIndex].grVW_VEND,  VWData.VEND);
  LL32(VideoWindow[dwVWIndex].grVW_PSD_STRT_ADDR, VWData.PSD_STRT_ADDR);
  LL32(VideoWindow[dwVWIndex].grVW_SSD_STRT_ADDR, VWData.SSD_STRT_ADDR);
#if ENABLE_YUVPLANAR
  if (dwFourcc == FOURCC_YUVPLANAR)
  {
    LL32(VideoWindow[dwVWIndex].grVW_PSD_UVSTRT_ADDR, VWData.PSD_UVSTRT_ADDR);
    LL32(VideoWindow[dwVWIndex].grVW_SSD_UVSTRT_ADDR, VWData.SSD_UVSTRT_ADDR);
  }
#endif
  LL16(VideoWindow[dwVWIndex].grVW_SD_PITCH, VWData.SD_PITCH);
  LL32(VideoWindow[dwVWIndex].grVW_CONTROL0, VWData.CONTROL0);
}

/***************************************************************************
*
* FUNCTION:     ChipIOReadBWRegs
*
* DESCRIPTION:
*
****************************************************************************/

BOOL ChipIOReadBWRegs
(
#ifdef WINNT_VER40
  PDEV      *ppdev,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  LPBWREGS  pBWRegs
)
{
  PVGAR   pREG = (PVGAR)lpDDHALData->RegsAddress;


#ifdef WINNT_VER40
  pBWRegs->BCLK_Mult      = pREG->grBCLK_Multiplier;
#else
  pBWRegs->BCLK_Mult      = pREG->grBCLK_numerator;
#endif
  pBWRegs->MISCOutput     = pREG->grMISC;
  pBWRegs->VCLK3Denom     = pREG->grSRE;
  pBWRegs->VCLK3Num       = pREG->grSR1E;
  pBWRegs->DispThrsTiming = pREG->grDisplay_Threshold_and_Tiling;
  pBWRegs->RIFControl     = pREG->grRIF_CONTROL;
  pBWRegs->GfVdFormat     = pREG->grFormat;

#ifdef WINNT_VER40
  pBWRegs->BCLK_Denom     = pREG->grBCLK_Denominator;
#else
  pBWRegs->BCLK_Denom     = pREG->grBCLK_denom;
#endif
  pBWRegs->Control2       = pREG->grCONTROL2;
  pBWRegs->CR1            = pREG->grCR1;
  pBWRegs->CR1E           = pREG->grCR1E;

#if ENABLE_256_BYTE_FETCH
  // if we are disabling 256 byte fetch when overlay or videoport
  // surfaces are created, then wipe out the 256 byte fetch related
  // bits in CONTROL2
  // clear MONO_SAFETY_256 & BYTE_REQ_256 bits of CONTROL2 register
  pBWRegs->Control2 &= ~(MONO_SAFETY_256 | BYTE_REQ_256);
#endif

  return TRUE;
}

#ifdef USE_OLD_BWEQ
/***************************************************************************
*
* FUNCTION:     KillOverlay
*
* DESCRIPTION:  Disable overlay in the following cases
*
****************************************************************************/

BOOL KillOverlay
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
#endif
  WORD  wScreenX,
  UINT  uScreenDepth
)
{
  BWREGS bwregs;
  DWORD  dwMCLK, dwVCLK;

#ifdef WINNT_VER40
  if(!ChipIOReadBWRegs(ppdev, &bwregs))
#else
  if(!ChipIOReadBWRegs(&bwregs))
#endif
  {
    return TRUE;
  }

  if(!ChipCalcMCLK(&bwregs, &dwMCLK))
  {
    return TRUE;
  }

  if(!ChipCalcVCLK(&bwregs, &dwVCLK))
  {
    return TRUE;
  }
  if(dwMCLK < 75000000)
  {
     if(uScreenDepth == 32 )
     {
        if(wScreenX == 640 )
        {
            if(dwVCLK > 32000000)
                return TRUE;
         }
     }
  }
  return FALSE;

}
#endif // USE_OLD_BWEQ

#endif // WINNT_VER35
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\blt65.c ===
/**************************************************************************
***************************************************************************
*
*     Copyright (c) 1997, Cirrus Logic, Inc.
*                 All Rights Reserved
*
* FILE:         blt65.c
*
* DESCRIPTION:
*
* REVISION HISTORY:
*
* $Log:   //uinac/log/log/laguna/ddraw/src/Blt65.c  $
*
*    Rev 1.47   Jun 21 1998 12:16:46   clang
* Fixed PDR#11507 CK with ConCurrent RAM has the same transparent
* blt problem with AC
*
*    Rev 1.46   May 01 1998 15:47:06   frido
* Fixed the checks for the programmable blitter stride.
*
*    Rev 1.45   May 01 1998 13:37:06   frido
* Copied programmable blitter stride to Windows 95 code as well.
*
*    Rev 1.44   May 01 1998 11:12:38   frido
* Added test for programmable blitter stride.
*
*    Rev 1.43   Feb 24 1998 11:36:56   frido
* The overlay data has been changed in Windows NT 5.0.
*
*    Rev 1.42   Feb 16 1998 16:23:06   frido
* Moved the PFN_UPDATEFLIPSTATUS into Windows 95 specific region.
*
*    Rev 1.41   14 Jan 1998 06:14:02   eleland
*
* added support for display list flipping: calls to UpdateFlipStatus are
* thru function pointer pfnUpdateFlipStatus
*
*    Rev 1.40   06 Jan 1998 15:01:58   xcong
* Pass lpDDHALData into some functions and macros for multi-monitor support.
*
*    Rev 1.39   06 Jan 1998 11:52:16   xcong
* change pDriverData into local lpDDHALData for multi-monitor support.
*
*    Rev 1.38   28 Oct 1997 15:33:24   RUSSL
* src colorkey blts are faster and less work for the hw if just OP2 is used
* with a rop of F0 rather than using both OP1 & OP2 with a rop of CC
* To get back the old way, set the OP2_ONLY_SRC_COLORKEY define to 0
*
*    Rev 1.37   16 Oct 1997 17:01:34   RUSSL
* In Blt65, if REMOVE_GLOBAL_VARS is nonzero, get pdevice pointer from
*   DDRAWI_DIRECTDRAW_GBL struct.  It's a 16:16 ptr so call an asm function
*   to convert it to a 32 bit linear address and then store this in
*   DDRAWI_DIRECTDRAW_GBL dwReserved1 element.
*
*    Rev 1.36   03 Oct 1997 15:45:12   RUSSL
* Initial changes for use of hw clipped blts
* All changes wrapped in #if ENABLE_CLIPPEDBLTS/#endif blocks and
* ENABLE_CLIPPEDBLTS defaults to 0 (so the code is disabled)
*
*    Rev 1.35   01 Oct 1997 12:57:20   eleland
* added check in blt65() to detect blts to host texture surfaces and
* punt those blts back to the ddraw hel
*
*    Rev 1.34   20 Aug 1997 15:36:30   RUSSL
* Added ColorKeyBlt24 function.
* With 256 byte fetch disabled, SrcColorKey blts seem to be working
* correctly at 24bpp and DstColorKey blts appear to be working correctly
* for the tddraw BLT, single DESTKEY, VMem to Primary case but running
* foxbear in 24bpp modes with only DDCKEYCAPS_DESTBLT set doesn't look
* correct.  The best I've been able to do is run the tddraw DESTKEY case
* and force ColorKeyBlt24 to go though each path and verify that they
* each work correctly.  This leads me to expect that foxbear using
* DstColorKeying wasn't debugged very thoroughly (now that's probably a big
* surprise to everyone).  We need more dest color key blt tests.
* For Win95, this was basically a wasted effort since 256 byte fetch appears
* to break 24bpp colorkey blts in some other way, which would require yet
* another workaround.
*
*    Rev 1.33   18 Aug 1997 15:00:42   bennyn
* For NT, if DDBLTFX dwSize not equal to sizeof(DDBLTFX), set dwColor to 0.
*
*    Rev 1.32   13 Aug 1997 12:20:48   bennyn
* For NT, punt if no scratch buffer and DDBLTFX dwSize is not sizeof(DDBLTFX)
*
*    Rev 1.31   29 Jul 1997 17:18:18   bennyn
* Fixed the Foxbear F8 bug
*
*    Rev 1.30   29 Jul 1997 10:51:40   bennyn
* NT only, punt if it is a host to screen BLT
*
*    Rev 1.29   24 Jul 1997 12:30:36   RUSSL
* Added check for NULL src surface ptr in Blt65 before nonlocal vidmem test
*
*    Rev 1.28   24 Jul 1997 11:17:14   RUSSL
* cover up various wickle crimes against humanity
* which means disabling interpolated stretch blts among other things
*
*    Rev 1.27   18 Jul 1997 10:21:50   RUSSL
* Added check for zero extent blts in TransparentStretch65
*
*    Rev 1.26   14 Jul 1997 13:15:14   RUSSL
* Fix for PDR 9947 - include support for all surface formats for blts
* between overlay surfaces
*
*    Rev 1.25   08 Jul 1997 11:50:48   RUSSL
* Rewrite of TransparentStretch65, similar to TransparentStretch in ddblt.c
* but can blt each scanline's full x extent without striping.
* Modified calls to do stretch blt with source colorkeying in Blt65.
*
*    Rev 1.24   07 Jul 1997 13:43:52   dzenz
* Added check of DRVSEM_DISPLAY_LIST semaphore to ascertain if
* qmRequestDirectAccess needs to be called.
*
*    Rev 1.23   20 Jun 1997 09:45:32   RUSSL
* Added FBToFBCopy to handle blts to/from a linear surface
*   (currently these can be overlay or videoport surfaces only)
* Fixed one of our seemingly inevitable NT/Win95 collisions
*
*    Rev 1.22   12 Jun 1997 17:30:46   bennyn
* For 24 & 32 BPP use StretchColor() instead of TransparentStretch()
*
*    Rev 1.21   23 May 1997 15:41:28   noelv
* Added nt method for chip revision test.
*
*    Rev 1.20   22 May 1997 16:46:38   RUSSL
* Fix for PDRs 9710 & 9706, remove xext <= 8 check on striping of src
* colorkey blts on 65AC (this is a workaround for a hw bug)
* Add check for 65AC or earlier and do striping of src colorkey blts
* on 65AD striping isn't needed so just do single blt
*
*    Rev 1.19   19 May 1997 13:08:10   noelv
* Put NT4.0 wrapper around DrvSrcMBlt call.
*
*    Rev 1.18   16 May 1997 15:32:02   RUSSL
* Added blt case to handle blts from a UYVY surface to another UYVY surface
* This fixes the VFW bugs, WinBench 97 video bugs and Encarta 97 video bugs
* PDRs 9557, 9604, 9692, 9268 & 9270
* Thanks to Peter Hou
*
*    Rev 1.17   16 Apr 1997 18:40:48   RUSSL
* Fix for PDR #9340, for color conversion and resize blts calculate surface
* offset based on frame buffer pixel format then calculate offset into surface
* based on surface pixel format.  Pass DrvStretch65 byte based coordinates
* rather than pixel based coordinates.
*
*    Rev 1.16   16 Apr 1997 10:50:54   bennyn
* Eliminated the warning due to Win95 DBG_MESSAGE call.
*
*    Rev 1.15   08 Apr 1997 11:50:46   einkauf
* WINNT_VER40 affected only:add SYNC_W_3D to coordinate MCD and 2D hw access
*
*    Rev 1.14   03 Apr 1997 15:25:34   RUSSL
* Modified DDBLT_DEPTHFILL case in Blt65 to blt based on surface colordepth
*   it was clearing 16bit zbuffers in 32bit modes with pixel blts so would
*   wipe out everything to the right of the actual zbuffer
*   Fixes at least PDRs #9152, 9150 & 8789 (maybe others as well)
*
*    Rev 1.13   02 Apr 1997 15:44:54   RUSSL
* Stripe src color key blts at 24bpp, fixes PDR #9113
* Added TransparentStretch65 but hw doesn't work so it's #if'd out
*
*    Rev 1.12   27 Mar 1997 16:12:36   RUSSL
* Tossed the whole bloody mess in the bit bucket.  Reverted to rev 1.1
* Changed name of DrvStretch to DrvStretch65
* Modified DrvStretch65 to do 65-style resize blts using stretch_cntl
*   rather than lncntl
* Added use of original src & dst rectangle (if available) to compute
*   error terms.  Walk DDA's in DrvStretch65 for clipped rect's.
* Changed Blt65 locals dwDstCoord, dwDstWidth, dwDstHeight and dwSrcCoord,
*   dwSrcWidth, dwSrcHeight to DstDDRect and SrcDDRect DDRECTL structures
* Moved sync with queue manager in front of call to updateFlipStatus since
*   updateFlipStatus might access the hardware
* Added workaround for hw bug for src colorkey blts less than one qword
*   wide that require fetching from two src qwords but writing to only
*   one dst qword.  Fixes white lines on foxbear that used to appear in
*   some modes
*
*    Rev 1.11   21 Mar 1997 18:08:38   RUSSL
* Fixups in StretchRect so Foxbear now runs correctly in a window at
* all 4 colordepths
*
*    Rev 1.10   18 Mar 1997 07:51:44   bennyn
* Resolved NT comiling error by #ifdef queue manager sync call
*
*    Rev 1.9   12 Mar 1997 14:59:50   RUSSL
* replaced a block of includes with include of precomp.h for
*   precompiled headers
*
*    Rev 1.8   07 Mar 1997 12:47:10   RUSSL
* Modified DDRAW_COMPAT usage
*
*    Rev 1.7   03 Mar 1997 10:31:40   eleland
* inserted queue manager sync call to blt65(), removed #ifdef
* USE_QUEUE_MANAGER
*
*    Rev 1.6   21 Feb 1997 15:40:38   RUSSL
* Anybody know why we were doing every 1:1 blt through the
* resize engine rather than just a normal blt ???????
*
*    Rev 1.5   06 Feb 1997 13:09:36   BENNYN
* Fixed DWORD alignment for DD resizing code
*
*    Rev 1.4   31 Jan 1997 13:44:06   BENNYN
* Added clipping support and no interpolation set for 24BPP & YUV src shrink
*
*    Rev 1.3   27 Jan 1997 17:29:14   BENNYN
* Added Win95 support
*
*    Rev 1.2   23 Jan 1997 17:10:10   bennyn
* Modified to support 5465 DD
*
*    Rev 1.1   21 Jan 1997 15:09:28   RUSSL
* Added include of ddinline.h
*
*    Rev 1.0   15 Jan 1997 10:35:20   RUSSL
* Initial revision.
*
***************************************************************************
***************************************************************************/

/*----------------------------- INCLUDES ----------------------------------*/

#include "precomp.h"

// If WinNT 3.5 skip all the source code
#if defined WINNT_VER35      // WINNT_VER35
#else  // !WinNT 3.51

#ifdef WINNT_VER40     // WINNT_VER40

#define DBGLVL        1

#else  // Win95

#include "flip.h"
#include "surface.h"
#include "blt.h"
#include "palette.h"

#include "bltP.h"
#include "ddinline.h"
#include "qmgr.h"

#include "ddshared.h"
#include "overlay.h"

#endif // WINNT_VER40

/*----------------------------- DEFINES -----------------------------------*/

#define OP2_ONLY_SRC_COLORKEY   1

#ifdef WINNT_VER40
#define UPDATE_FLIP_STATUS(arg)   vUpdateFlipStatus(&ppdev->flipRecord,(arg))
#else   // Win95
#define UPDATE_FLIP_STATUS(arg)   updateFlipStatus((arg),lpDDHALData)
#endif  // WINNT_VER40

#define LOCK_HW_SEMAPHORE()    (lpDDHALData->DrvSemaphore |= DRVSEM_IN_USE)
#define UNLOCK_HW_SEMAPHORE()  (lpDDHALData->DrvSemaphore &= ~ DRVSEM_IN_USE)

// defines for STRETCH_CNTL register
#define RGB_8_FMT          0
#define RGB_555_FMT        1
#define RGB_565_FMT        2
#define RGB_24_FMT         3
#define RGB_32_FMT         4
#define YUV_422_FMT        9

#define SRC_FMT_SHIFT     12
#define DST_FMT_SHIFT      8
#define SRC_FMT_MASK      0xF000
#define DST_FMT_MASK      0x0F00

#define YSHRINK_ENABLE    0x8
#define XSHRINK_ENABLE    0x4
#define YINTERP_ENABLE    0x2
#define XINTERP_ENABLE    0x1

// bltdef defines
#define BD_TYPE_RESIZE    (1 << 9)
#define BD_TYPE_NORMAL    0

/*----------------------------- TYPEDEFS ----------------------------------*/

typedef short DDAX;
typedef struct tagAxis
{
  DDAX accum;
  DDAX maj;
  DDAX min;
} AXIS;

#if !ENABLE_CLIPPEDBLTS
typedef struct _DDRECTL
{
  REG32   loc;
  REG32   ext;
} DDRECTL;
#endif

/*------------------------- FUNCTION PROTOTYPES ---------------------------*/

#ifdef DEBUG
extern VOID SaveSurfaceToBmp ( DDRAWI_DDRAWSURFACE_LCL *pSurface );
#endif

/*-------------------------- STATIC VARIABLES -----------------------------*/

#ifndef WINNT_VER40

ASSERTFILE("blt65.c");
extern PFN_UPDATEFLIPSTATUS    pfnUpdateFlipStatus;

#endif

/*-------------------------- GLOBAL FUNCTIONS -----------------------------*/

/***************************************************************************
*
* FUNCTION:    DrvStretch65()
*
* DESCRIPTION:
*
****************************************************************************/

void DrvStretch65
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DDRECTL     SrcDDRect,
  DDRECTL     DstDDRect,
  DWORD       Stretch_Cntl,
  DDRECTL     OrigSrcDDRect,
  DDRECTL     OrigDstDDRect
)
{
  const int nBytesPixel = BYTESPERPIXEL;

  autoblt_regs  bltr;
  AXIS          axis[2];
  int           nDst[2];
  int           nSrc[2];
  int           i;
  int           ext;


#ifndef WINNT_VER40
  DBG_MESSAGE(("DrvStretch65: %4d,%4d %4dx%4d -> %4d,%4d %4dx%4d",
               SrcDDRect.loc.pt.X, SrcDDRect.loc.pt.Y,
               SrcDDRect.ext.pt.X, SrcDDRect.ext.pt.Y,
               DstDDRect.loc.pt.X, DstDDRect.loc.pt.Y,
               DstDDRect.ext.pt.X, DstDDRect.ext.pt.Y));
#endif // WINNT_VER40

  if ((0 == DstDDRect.ext.pt.X) || (0 == DstDDRect.ext.pt.Y) ||
      (0 == SrcDDRect.ext.pt.X) || (0 == SrcDDRect.ext.pt.Y))
  {
    // nothing to do, so get outta here!
    return;
  }

#ifdef WINNT_VER40
  SYNC_W_3D(ppdev);
#endif

  bltr.DRAWBLTDEF.DW = MAKELONG(ROP_OP1_copy, BD_RES * IS_VRAM |
                                              BD_OP1 * IS_VRAM |
                                              BD_TYPE_RESIZE);

  // dst coords
  bltr.OP0_opMRDRAM.DW = DstDDRect.loc.DW;

  // src coords
  bltr.OP1_opMRDRAM.DW = SrcDDRect.loc.DW;

  // blt extent
  bltr.MBLTEXTR_EX.DW = DstDDRect.ext.DW;
#if 1
  // tddraw agp Case 47 puts the goofy happy face with arms image in the middle
  // of the screen and then expects us to stretch it over the top of itself
  // if we don't handle the overlap somehow, the result is trash at the bottom
  // we blt the original src to the lower right of the dest and then stretch
  // that copy of the src to the dest
  // hack, hack, cough, cough
  bltr.BLTEXT.DW = SrcDDRect.ext.DW;        // stuff this here for overlap check
#endif

  bltr.STRETCH_CNTL.W = (WORD)Stretch_Cntl;

  bltr.SHRINKINC.W = 0x0000;

  bltr.SRCX = SrcDDRect.ext.pt.X;

  // convert back to pixels for error term computations
  DstDDRect.ext.pt.X /= (USHORT)nBytesPixel;
  OrigDstDDRect.ext.pt.X /= (USHORT)nBytesPixel;
  if ((YUV_422_FMT << SRC_FMT_SHIFT) == (SRC_FMT_MASK & Stretch_Cntl))
  {
    bltr.OP1_opMRDRAM.pt.X &= 0xFFFC;
    SrcDDRect.ext.pt.X /= 2;
    OrigSrcDDRect.ext.pt.X /= 2;
  }
  else
  {
    SrcDDRect.ext.pt.X /= (USHORT)nBytesPixel;
    OrigSrcDDRect.ext.pt.X /= (USHORT)nBytesPixel;
  }
  if (DstDDRect.ext.pt.X < SrcDDRect.ext.pt.X)
  {
    bltr.STRETCH_CNTL.W |= XSHRINK_ENABLE;
    bltr.STRETCH_CNTL.W &= ~XINTERP_ENABLE;
    bltr.SHRINKINC.pt.X = SrcDDRect.ext.pt.X / DstDDRect.ext.pt.X;
  }
  if (DstDDRect.ext.pt.Y < SrcDDRect.ext.pt.Y)
  {
    bltr.STRETCH_CNTL.W |= YSHRINK_ENABLE;
    bltr.STRETCH_CNTL.W &= ~YINTERP_ENABLE;
    bltr.SHRINKINC.pt.Y = SrcDDRect.ext.pt.Y / DstDDRect.ext.pt.Y;
  }

  // Compute DDA terms.
  nDst[0] = OrigDstDDRect.ext.pt.X;
  nDst[1] = OrigDstDDRect.ext.pt.Y;
  nSrc[0] = OrigSrcDDRect.ext.pt.X;
  nSrc[1] = OrigSrcDDRect.ext.pt.Y;

  for (i = 0; i < 2; i++)
  {
    int kDst = 1;

    if (bltr.STRETCH_CNTL.W & ((i==0) ? XINTERP_ENABLE : YINTERP_ENABLE))
    {
      nDst[i] *= 4;
      nSrc[i] *= 4;
      nSrc[i] -= 3;

      kDst = 0x8000 / nDst[i];
    }

    if (bltr.STRETCH_CNTL.W & ((i==0) ? XSHRINK_ENABLE : YSHRINK_ENABLE))
    { /* Shrink Terms */
      axis[i].maj   =  (short)nDst[i];
      axis[i].min   = - (nSrc[i] % nDst[i]);
      axis[i].accum = axis[i].maj - 1
                      - ((nSrc[i] % nDst[i]) / (nSrc[i]/nDst[i] + 1));
    }
    else
    { /* Stretch Terms */
      axis[i].maj   =  kDst * nDst[i];
      axis[i].min   = -kDst * nSrc[i];
      axis[i].accum = axis[i].maj - 1
                      - ((axis[i].maj % -axis[i].min) / (nDst[i]/nSrc[i] + 1));
    }
  }

  bltr.MAJ_X   = axis[0].maj;
  bltr.MIN_X   = axis[0].min;
  bltr.ACCUM_X = axis[0].accum;

  bltr.MAJ_Y   = axis[1].maj;
  bltr.MIN_Y   = axis[1].min;
  bltr.ACCUM_Y = axis[1].accum;

#define DO_SW_CLIPPING
#ifdef DO_SW_CLIPPING
  // walk DDA's to get correct initial ACCUM terms
  ext = DstDDRect.loc.pt.X - OrigDstDDRect.loc.pt.X;
  while (0 < ext--)
  {
    bltr.ACCUM_X += bltr.MIN_X;
    if (0 > (short)bltr.ACCUM_X)
    {
      bltr.ACCUM_X += bltr.MAJ_X;
    }
  }
  ext = DstDDRect.loc.pt.Y - OrigDstDDRect.loc.pt.Y;
  while (0 < ext--)
  {
    bltr.ACCUM_Y += bltr.MIN_Y;
    if (0 > (short)bltr.ACCUM_Y)
    {
      bltr.ACCUM_Y += bltr.MAJ_Y;
    }
  }
#else
#pragma message("Add hw clipping")
#endif

#ifdef WINNT_VER40
  ppdev->pfnDrvStrBlt(ppdev, lpDDHALData,
#else
  pfnDrvStrBlt(
                lpDDHALData,
#endif
               &bltr);
}

/***************************************************************************
*
* FUNCTION:    TransparentStretch65()
*
* DESCRIPTION:
*
****************************************************************************/

void TransparentStretch65
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DDRECTL     SrcDDRect,
  DDRECTL     DstDDRect,
  DWORD       Stretch_Cntl,
  DWORD       ColorKey
)
{
  const int nBytesPixel = BYTESPERPIXEL;

  autoblt_regs  SrcToScratch;

  AXIS  axis[2];
  int   nDst[2];
  int   nSrc[2];
  int   i;


  // currently this only supports same src & dst formats
#ifndef WINNT_VER40
  ASSERT(((SRC_FMT_MASK & Stretch_Cntl) >> SRC_FMT_SHIFT) ==
         ((DST_FMT_MASK & Stretch_Cntl) >> DST_FMT_SHIFT));

  DBG_MESSAGE(("TransparentStretch65: %4X,%4X %4Xx%4X -> %4X,%4X %4Xx%4X",
               SrcDDRect.loc.pt.X, SrcDDRect.loc.pt.Y,
               SrcDDRect.ext.pt.X, SrcDDRect.ext.pt.Y,
               DstDDRect.loc.pt.X, DstDDRect.loc.pt.Y,
               DstDDRect.ext.pt.X, DstDDRect.ext.pt.Y));

#endif

  if ((0 == DstDDRect.ext.pt.X) || (0 == DstDDRect.ext.pt.Y) ||
      (0 == SrcDDRect.ext.pt.X) || (0 == SrcDDRect.ext.pt.Y))
  {
    // nothing to do, so get outta here!
    return;
  }

  // initialize auto blt struct for src to scratch buffer
  SrcToScratch.DRAWBLTDEF.DW  = MAKELONG(ROP_OP1_copy, BD_RES * IS_VRAM |
                                                       BD_OP1 * IS_VRAM |
                                                       BD_TYPE_RESIZE);

  // dst coords in bytes (scratch buffer)
  SrcToScratch.OP0_opMRDRAM.DW = lpDDHALData->ScratchBufferOrg;
  SrcToScratch.OP0_opMRDRAM.pt.X *= (USHORT)nBytesPixel;

  // src coords in bytes
  SrcToScratch.OP1_opMRDRAM.DW = SrcDDRect.loc.DW;
  SrcToScratch.OP1_opMRDRAM.pt.X *= (USHORT)nBytesPixel;

  // blt extent in bytes (1 scanline at a time)
  SrcToScratch.MBLTEXTR_EX.DW = MAKELONG(DstDDRect.ext.pt.X * nBytesPixel,1);

  SrcToScratch.STRETCH_CNTL.W = (WORD)Stretch_Cntl;

  SrcToScratch.SHRINKINC.W = 0x0000;

  SrcToScratch.SRCX = SrcDDRect.ext.pt.X * nBytesPixel;

  if (DstDDRect.ext.pt.X < SrcDDRect.ext.pt.X)
  {
    SrcToScratch.STRETCH_CNTL.W |= XSHRINK_ENABLE;
    SrcToScratch.STRETCH_CNTL.W &= ~XINTERP_ENABLE;
    SrcToScratch.SHRINKINC.pt.X = SrcDDRect.ext.pt.X / DstDDRect.ext.pt.X;
  }

  if (DstDDRect.ext.pt.Y < SrcDDRect.ext.pt.Y)
  {
    SrcToScratch.STRETCH_CNTL.W |= YSHRINK_ENABLE;
    SrcToScratch.STRETCH_CNTL.W &= ~YINTERP_ENABLE;
    SrcToScratch.SHRINKINC.pt.Y = SrcDDRect.ext.pt.Y / DstDDRect.ext.pt.Y;
  }

  // Compute DDA terms

  nDst[0] = DstDDRect.ext.pt.X;
  nDst[1] = DstDDRect.ext.pt.Y;
  nSrc[0] = SrcDDRect.ext.pt.X;
  nSrc[1] = SrcDDRect.ext.pt.Y;

  for (i = 0; i < 2; i++)
  {
    int kDst = 1;

    if (SrcToScratch.STRETCH_CNTL.W & ((i==0) ? XINTERP_ENABLE : YINTERP_ENABLE))
    {
      nDst[i] *= 4;
      nSrc[i] *= 4;
      nSrc[i] -= 3;

      kDst = 0x8000 / nDst[i];
    }

    if (SrcToScratch.STRETCH_CNTL.W & ((i==0) ? XSHRINK_ENABLE : YSHRINK_ENABLE))
    { /* Shrink Terms */
      axis[i].maj   =  (short)nDst[i];
      axis[i].min   = - (nSrc[i] % nDst[i]);
      axis[i].accum = axis[i].maj - 1
                      - ((nSrc[i] % nDst[i]) / (nSrc[i]/nDst[i] + 1));
    }
    else
    { /* Stretch Terms */
      axis[i].maj   =  kDst * nDst[i];
      axis[i].min   = -kDst * nSrc[i];
      axis[i].accum = axis[i].maj - 1
                      - ((axis[i].maj % -axis[i].min) / (nDst[i]/nSrc[i] + 1));
    }
  }

  SrcToScratch.MAJ_X   = axis[0].maj;
  SrcToScratch.MIN_X   = axis[0].min;
  SrcToScratch.ACCUM_X = axis[0].accum;

  SrcToScratch.MAJ_Y   = axis[1].maj;
  SrcToScratch.MIN_Y   = axis[1].min;
  SrcToScratch.ACCUM_Y = axis[1].accum;



  // loop over scanlines in dst
  // do two blts for each, one from src to scratch buffer
  //   then one from scratch buffer to dst
  while (0 < DstDDRect.ext.pt.Y)
  {
    // blt one scanline high from src to scratch buffer
#ifdef WINNT_VER40
    ppdev->pfnDrvStrBlt(ppdev, lpDDHALData,
#else
    pfnDrvStrBlt(
                lpDDHALData,
#endif
                 &SrcToScratch);

    // walk Y DDA for src to scratch buffer blt
    SrcToScratch.ACCUM_Y += SrcToScratch.MIN_Y;
    SrcToScratch.OP1_opMRDRAM.pt.Y += SrcToScratch.SHRINKINC.pt.Y;
    if (0 > (short)SrcToScratch.ACCUM_Y)
    {
      SrcToScratch.ACCUM_Y += SrcToScratch.MAJ_Y;
      SrcToScratch.OP1_opMRDRAM.pt.Y++;
    }


    // blt from scratch buffer to dst
    // 1:1 in X, 1:1 in Y, uses colorkey
#ifdef WINNT_VER40
    ppdev->pfnDrvSrcBlt(ppdev, lpDDHALData,
#else
    pfnDrvSrcBlt(
            lpDDHALData,
#endif
#if OP2_ONLY_SRC_COLORKEY
                 MAKELONG((DD_TRANS | ROP_OP2_copy),
                          ((BD_RES+BD_OP2)*IS_VRAM)),
#else
                 MAKELONG((DD_TRANS | ROP_OP1_copy),
                          ((BD_RES+BD_OP1+BD_OP2)*IS_VRAM)),
#endif
                 DstDDRect.loc.DW,
                 lpDDHALData->ScratchBufferOrg,
                 lpDDHALData->ScratchBufferOrg,
                 ColorKey,
                 MAKELONG(DstDDRect.ext.pt.X,1));
    DstDDRect.loc.pt.Y++;
    DstDDRect.ext.pt.Y--;
  }
}

#ifndef WINNT_VER40
/***************************************************************************
*
* FUNCTION:    FBToFBCopy()
*
* DESCRIPTION:
*
****************************************************************************/

VOID
FBToFBCopy ( BYTE *dst, LONG dstPitch, BYTE *src, LONG srcPitch, REG32 ext, LONG bpp )
{
  int yext = ext.pt.Y;
  int xext = ext.pt.X * bpp;

  while (0 < yext--)
  {
    memcpy(dst,src,xext);
    dst += dstPitch;
    src += srcPitch;
  }
}
#endif

/***************************************************************************
*
* FUNCTION:    ColorKeyBlt24()
*
* DESCRIPTION:
*
****************************************************************************/

#define MIN_WIDTH     21    // empirically determined that most widths less than this don't work
#define STRIPE_WIDTH  40    // max is 128 / 3 = 42 pixels, but use 40 to account for phase

STATIC VOID ColorKeyBlt24
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD       drawbltdef,
  DDRECTL     DstDDRect,
  DDRECTL     SrcDDRect,
  DDRECTL     KeyDDRect,
  DWORD       dwColorKey
)
{
  short   xStep = 1;
  short   yStep = 1;
  WORD    xExt;


  // check for overlap
  if ((abs(DstDDRect.loc.pt.X - SrcDDRect.loc.pt.X) < DstDDRect.ext.pt.X) &&
      (abs(DstDDRect.loc.pt.Y - SrcDDRect.loc.pt.Y) < DstDDRect.ext.pt.Y))
  {
    // see if we need to blt from bottom to top
    if (DstDDRect.loc.pt.Y > SrcDDRect.loc.pt.Y)
    {
      // point to bottom scanline and update bltdef
      drawbltdef |= MAKELONG(0, BD_YDIR);
      DstDDRect.loc.pt.Y += (DstDDRect.ext.pt.Y - 1);
      SrcDDRect.loc.pt.Y += (DstDDRect.ext.pt.Y - 1);
      KeyDDRect.loc.pt.Y += (DstDDRect.ext.pt.Y - 1);
      yStep = -1;
    }
    // see if we need to blt from right to left
    if (DstDDRect.loc.pt.X > SrcDDRect.loc.pt.X)
    {
      // point to right edge pixel
      DstDDRect.loc.pt.X += (DstDDRect.ext.pt.X - 1);
      SrcDDRect.loc.pt.X += (DstDDRect.ext.pt.X - 1);
      KeyDDRect.loc.pt.X += (DstDDRect.ext.pt.X - 1);
      xStep = -1;
    }
  }

  // if width is too narrow, do blt a pixel at a time
  // Also blt a pixel at a time for certain overlapping src/dst combinations
  // that won't work correctly otherwise.  While setting BD_YDIR to blt from
  // bottom to top and also bltting in SRAM width stripes from right to left
  // do work at 24bpp, they unfortunately don't work for certain overlap cases.
  // In particular BD_YDIR doesn't work when you need it (period!) and bltting
  // in SRAM width stripes from right to left doesn't work if the src and dst
  // have the same y.  Take out the two || cases and try the tddraw
  // BLT_BltFast, SRCKEY, From/To same surface test and see for yourself.
  if (   (MIN_WIDTH >= DstDDRect.ext.pt.X)
      || (0 > yStep)
      || ((0 > xStep) && (DstDDRect.loc.pt.Y == SrcDDRect.loc.pt.Y))
     )
  {
BltOnePixelAtATime:
    // loop over scanlines
    while (0 < DstDDRect.ext.pt.Y)
    {
      DWORD   dst  = DstDDRect.loc.DW;
      DWORD   src  = SrcDDRect.loc.DW;
      DWORD   key  = KeyDDRect.loc.DW;

      xExt = DstDDRect.ext.pt.X;

      // loop over pixels in scanline
      while (0 < xExt)
      {
#ifdef WINNT_VER40
        ppdev->pfnDrvSrcBlt(ppdev, lpDDHALData,
#else
        pfnDrvSrcBlt(
                lpDDHALData,
#endif
                     drawbltdef, dst, src, key, dwColorKey, MAKELONG(1,1));
        // adjust extent and ptrs (x is in low word)
        xExt--;
        dst += xStep;
        src += xStep;
        key += xStep;
      }
      // adjust extent and ptrs (y is in high word)
      DstDDRect.ext.pt.Y--;
      SrcDDRect.loc.pt.Y += yStep;
      DstDDRect.loc.pt.Y += yStep;
      KeyDDRect.loc.pt.Y += yStep;
    }
  }
  // if width is less than SRAM width, just do a single blt
  else if (STRIPE_WIDTH >= DstDDRect.ext.pt.X)
  {
    // except if there's overlap, do it the slow way
    //if ((0 > xStep) || (0 > yStep))
    if (0 > xStep)          // check for (0 > yStep) already handled above
      goto BltOnePixelAtATime;

    // just blt it
#ifdef WINNT_VER40
    ppdev->pfnDrvSrcBlt(ppdev, lpDDHALData,
#else
    pfnDrvSrcBlt(
                lpDDHALData,
#endif
                 drawbltdef,
                 DstDDRect.loc.DW,
                 SrcDDRect.loc.DW,
                 KeyDDRect.loc.DW,
                 dwColorKey,
                 DstDDRect.ext.DW);
  }
  // stripe the blt into SRAM width blts
  else
  {
    xExt = STRIPE_WIDTH;

    // blt from right to left
    if (0 > xStep)
    {
      DstDDRect.loc.pt.X++;
      SrcDDRect.loc.pt.X++;
      KeyDDRect.loc.pt.X++;

      while (1)
      {
        // adjust ptrs to start of stripe
        DstDDRect.loc.pt.X -= xExt;
        SrcDDRect.loc.pt.X -= xExt;
        KeyDDRect.loc.pt.X -= xExt;

        // blt the stripe
#ifdef WINNT_VER40
        ppdev->pfnDrvSrcBlt(ppdev, lpDDHALData,
#else
        pfnDrvSrcBlt(
                    lpDDHALData,
#endif
                     drawbltdef,
                     DstDDRect.loc.DW,
                     SrcDDRect.loc.DW,
                     KeyDDRect.loc.DW,
                     dwColorKey,
                     MAKELONG(xExt,DstDDRect.ext.pt.Y));

        // adjust remaining extent
        DstDDRect.ext.pt.X -= xExt;
        // are we done?
        if (0 == DstDDRect.ext.pt.X)
          break;

        // last stripe might not be STRIPE_WIDTH wide
        if (xExt > DstDDRect.ext.pt.X)
        {
          xExt = DstDDRect.ext.pt.X;

          // if the last stripe is too narrow,
          // finish the blt the even slower way
          if (MIN_WIDTH >= xExt)
          {
            // but first point to x pixel to start with
            SrcDDRect.loc.pt.X--;
            DstDDRect.loc.pt.X--;
            KeyDDRect.loc.pt.X--;
            goto BltOnePixelAtATime;
          }
        }
      }
    }
    // blt from left to right
    else
    {
      while (1)
      {
        // blt the stripe
#ifdef WINNT_VER40
        ppdev->pfnDrvSrcBlt(ppdev, lpDDHALData,
#else
        pfnDrvSrcBlt(
                    lpDDHALData,
#endif
                     drawbltdef,
                     DstDDRect.loc.DW,
                     SrcDDRect.loc.DW,
                     KeyDDRect.loc.DW,
                     dwColorKey,
                     MAKELONG(xExt,DstDDRect.ext.pt.Y));

        // adjust remaining extent
        DstDDRect.ext.pt.X -= xExt;
        // are we done?
        if (0 >= DstDDRect.ext.pt.X)
          break;

        // adjust ptrs to start of next stripe
        SrcDDRect.loc.pt.X += xExt;
        DstDDRect.loc.pt.X += xExt;
        KeyDDRect.loc.pt.X += xExt;

        // last stripe might not be STRIPE_WIDTH wide
        if (xExt > DstDDRect.ext.pt.X)
        {
          xExt = DstDDRect.ext.pt.X;

          // if the last stripe is too narrow,
          // finish the blt the even slower way
          if (MIN_WIDTH >= xExt)
          {
            // ptrs already set
            goto BltOnePixelAtATime;
          }
        }
      }
    }
  }
}

/***************************************************************************
*
* FUNCTION:    Blt65()
*
* DESCRIPTION:
*
****************************************************************************/

#ifdef WINNT_VER40
DWORD Blt65(PDD_BLTDATA pbd)
{
  DRIVERDATA* lpDDHALData;
  PDEV*    ppdev;
  PVGAR    pREG;
#else   // Win95
DWORD __stdcall
Blt65 ( LPDDHAL_BLTDATA pbd)
{
LPGLOBALDATA lpDDHALData = GetDDHALContext( pbd->lpDD);
#endif

  HRESULT  ddrval;
  DWORD    dwFlags;

  DDRECTL DstDDRect;
  DDRECTL SrcDDRect;

#ifdef WINNT_VER40

  PDD_SURFACE_GLOBAL  dst;
  PDD_SURFACE_GLOBAL  src;

  DISPDBG((DBGLVL, "DDraw - Blt65\n"));

  ppdev = (PDEV*) pbd->lpDD->dhpdev;
  lpDDHALData = (DRIVERDATA*) &ppdev->DriverData;  //why ?
  pREG = (PVGAR) lpDDHALData->RegsAddress;

#else   // Win95

  LPDDRAWI_DDRAWSURFACE_GBL  dst;
  LPDDRAWI_DDRAWSURFACE_GBL  src;

#if defined(REMOVE_GLOBAL_VARS) && (REMOVE_GLOBAL_VARS != 0)
  PDEV  *ppdev;

  ppdev = GetPDevice(pbd->lpDD);
#endif
#endif  // WINNT_VER40

  DD_LOG(("Blt65 Entry\r\n"));

#ifdef WINNT_VER40
  SYNC_W_3D(ppdev);

  // Punt, we don't support Host memory to Screen BLT
  if ((NULL != pbd->lpDDSrcSurface) &&
      (pbd->lpDDSrcSurface->lpGbl->xHint != 0) &&
      (pbd->lpDDSrcSurface->lpGbl->yHint != 0) &&
      (pbd->lpDDSrcSurface->dwReserved1 == 0))
  {
    pbd->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
  }
#endif

#if 1 // PC98
#ifdef WINNT_VER40
	if (   (pbd->lpDDSrcSurface != NULL)
		&& (pbd->lpDDSrcSurface->lpGbl->lPitch < ppdev->lDeltaScreen)
	)
	{
		pbd->ddRVal = DDERR_UNSUPPORTED;
		return DDHAL_DRIVER_NOTHANDLED;
	}
#else
	if (   (pbd->lpDDSrcSurface != NULL)
		&& (pbd->lpDDSrcSurface->lpGbl->lPitch < pDriverData->HALInfo.vmiData.lDisplayPitch)
	)
	{
		pbd->ddRVal = DDERR_UNSUPPORTED;
		return DDHAL_DRIVER_NOTHANDLED;
	}
#endif
#endif

  // NOTES:
  //   Everything you need is in lpBlt->bltFX .
  //   Look at lpBlt->dwFlags to determine what kind of blt you are doing,
  //   DDBLT_xxxx are the flags.
  //
  // COLORKEY NOTES:
  //   ColorKey ALWAYS comes in BLTFX. You don't have to look it up in
  //   the surface.

#ifdef WINNT_VER40      // WINNT_VER40

#else   // ----- #elseif WINNT_VER40 -----
  // if direct draw is NOT using display list, it must sync here
  // updateFlipStatus may access the hardware!
  if (!lpDDHALData->DisplayListDDraw && ((lpDDHALData->DrvSemaphore & DRVSEM_3D_BUSY) || (lpDDHALData->DrvSemaphore & DRVSEM_DISPLAY_LIST)))
  {
     qmRequestDirectAccess();
  }
#endif // WINNT_VER40

  // is a flip in progress?
#ifdef WINNT_VER40
  ddrval = vUpdateFlipStatus(&ppdev->flipRecord,pbd->lpDDDestSurface->lpGbl->fpVidMem);
#else
#if defined(DDRAW_COMPAT_10)
  ddrval = pfnUpdateFlipStatus(pbd->lpDDDestSurface->lpData->fpVidMem,lpDDHALData);
#else
  ddrval = pfnUpdateFlipStatus(pbd->lpDDDestSurface->lpGbl->fpVidMem,lpDDHALData);
#endif
#endif

  if (ddrval != DD_OK)
  {
    pbd->ddRVal = ddrval;
    DD_LOG(("Blt65 Exit - flip in progress, returning %08lX\r\n", ddrval));
    return (DDHAL_DRIVER_HANDLED);
  }

  // If async, then only work if blter isn't busy.
  // This should probably be a little more specific to each call !!!
  dwFlags = pbd->dwFlags;

#if 1
  // billy and dah boyz strike again
  // tddraw agp Case 59 asks us to blt between to nonlocal video memory
  // surfaces even though we report that we don't support offscreen
  // plain nonlocal video memory surfaces
  // why is ddraw allocating offscreen plain surfaces in agp memory?
#if DDRAW_COMPAT >= 50
  // see if the dest is in nonlocal video memory
  if (DDSCAPS_NONLOCALVIDMEM & pbd->lpDDDestSurface->ddsCaps.dwCaps)
  {
    pbd->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
  }
  // if there is a src, see if it's in nonlocal video memory
  if ((NULL != pbd->lpDDSrcSurface) &&
      (DDSCAPS_NONLOCALVIDMEM & pbd->lpDDSrcSurface->ddsCaps.dwCaps))
  {
    pbd->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
  }
#endif
#endif

#ifndef WINNT_VER40
  // if the destination surface of this blt is a texture
  if (DDSCAPS_TEXTURE & pbd->lpDDDestSurface->ddsCaps.dwCaps)
  {
    LP_SURFACE_DATA lpSurfaceData;

    lpSurfaceData = (LP_SURFACE_DATA)(pbd->lpDDDestSurface->dwReserved1);

    // if the texture is a non-agp host texture (i.e. pci memory)
    if (lpSurfaceData->dwFlags & SURF_HOST_BASED_TEXTURE)
    {
        // punt the blt to direct draw hel
        pbd->ddRVal = DDERR_UNSUPPORTED;
        return DDHAL_DRIVER_NOTHANDLED;
    }
  }

  // if the source surface of this blt is non-null and is a texture
  if ((NULL != pbd->lpDDSrcSurface) &&
      (DDSCAPS_TEXTURE & pbd->lpDDSrcSurface->ddsCaps.dwCaps))
  {
    LP_SURFACE_DATA lpSurfaceData;

    lpSurfaceData = (LP_SURFACE_DATA)(pbd->lpDDSrcSurface->dwReserved1);

    // if the texture is a non-agp host texture (i.e. pci memory)
    if (lpSurfaceData->dwFlags & SURF_HOST_BASED_TEXTURE)
    {
        // punt the blt to direct draw hel
        pbd->ddRVal = DDERR_UNSUPPORTED;
        return DDHAL_DRIVER_NOTHANDLED;
    }
  }
#endif

  // get offset, width, and height for destination
#if defined(DDRAW_COMPAT_10)
  dst  = pbd->lpDDDestSurface->lpData;
#else
  dst  = pbd->lpDDDestSurface->lpGbl;
#endif

#ifdef WINNT_VER40
  DstDDRect.loc.DW = cvlxy(ppdev->lDeltaScreen,dst->fpVidMem,BYTESPERPIXEL);
#else   // Win95
  DstDDRect.loc.DW = cvlxy(lpDDHALData,dst->fpVidMem-lpDDHALData->ScreenAddress,BYTESPERPIXEL);
#endif
  DstDDRect.loc.DW  += MAKELONG(pbd->rDest.left,pbd->rDest.top);
  DstDDRect.ext.pt.X = (WORD)(pbd->rDest.right  - pbd->rDest.left);
  DstDDRect.ext.pt.Y = (WORD)(pbd->rDest.bottom - pbd->rDest.top);

  // If someone is running a full-screen exclusive app it is the
  // responsibility of the app to take care of the cursor. We don't
  // call BeginAccess or EndAccess for them.
  //
  // However, if someone is running a windowed app and they have
  // attached a clipper object to the destination surface then they
  // are more like a normal windows app and we call BeginAccess and
  // EndAccess for them around a blt. That is the only circumstance
  // where we currently do cursor exclusion.
  //
  // We do intend to add calls to BeginAccess and EndAccess around
  // a rectangle lock of the primary surface. In this case, we
  // would only do cursor exclusion if a lock rect is specified.
  // This will be implemented with DirectDraw 2.0.
  //
  // I believe that you should not do automatic cursor exclusion in
  // the driver because you will penalize all blts and locks.

  // Grab the hardware - disable HW cursor updates.
  LOCK_HW_SEMAPHORE();

  // Decipher the flags.
  if (dwFlags & DDBLT_ROP)
  {
    static const WORD mix2blt[] =
    {  // all ops color vram
      BD_RES                  ,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES          | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0         ,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0         ,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES          | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES
    };  // all ops color vram

    DWORD dwROP = pbd->bltFX.dwROP;
    WORD  rop = (WORD) LOBYTE( HIWORD( dwROP ) );
    WORD  mix = rop & 0x0f;
    WORD  bdf = mix2blt[mix];

    if (bdf & BD_OP1) // SRC rops
    {
#if defined(DDRAW_COMPAT_10)
      src  = pbd->lpDDSrcSurface->lpData;
#else
      src  = pbd->lpDDSrcSurface->lpGbl;
#endif

#ifdef WINNT_VER40
      SrcDDRect.loc.DW = cvlxy(ppdev->lDeltaScreen,src->fpVidMem,BYTESPERPIXEL);
#else   // Win95
      SrcDDRect.loc.DW = cvlxy(lpDDHALData,src->fpVidMem-lpDDHALData->ScreenAddress,BYTESPERPIXEL);
#endif
      SrcDDRect.loc.DW  += MAKELONG(pbd->rSrc.left,pbd->rSrc.top);
      SrcDDRect.ext.pt.X = (WORD)(pbd->rSrc.right  - pbd->rSrc.left);
      SrcDDRect.ext.pt.Y = (WORD)(pbd->rSrc.bottom - pbd->rSrc.top);

      if (dwFlags & DDBLT_KEYSRCOVERRIDE) // Source Color Key
      {
        DWORD dwColor =
#ifdef WINNT_VER40
                        DupColor(ppdev,
#else
                        DupColor(
                                 lpDDHALData,
#endif
                                 pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue);

        DD_LOG(("Src Color Key Blt\r\n"));

#ifdef DEBUG
        if (FALSE)
          SaveSurfaceToBmp(pbd->lpDDSrcSurface);
#endif

        if ((SrcDDRect.ext.pt.X != DstDDRect.ext.pt.X) ||
            (SrcDDRect.ext.pt.Y != DstDDRect.ext.pt.Y))
        {
#ifdef WINNT_VER40
           // If there is no scratch buffer allocated then punt the
           // transparent stretch BLT
           if (lpDDHALData->ScratchBufferOrg == 0)
           {
              ddrval = DDERR_UNSUPPORTED;
              goto blt_exit;
           };
#endif

          if ( !(pbd->lpDDSrcSurface->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
               (rop == 0x00CC) )
          {
            if (16 >= BITSPERPIXEL)
            {
              DWORD     StretchCntl;


              if (8 == BITSPERPIXEL)
              {
                StretchCntl = (RGB_8_FMT << SRC_FMT_SHIFT) |
                              (RGB_8_FMT << DST_FMT_SHIFT) |
                              0;
              }
              else
              {
                // this only works because the src & dst fmt's in stretch control
                // for 565, 24bpp & 32bpp are the same as the bytes/pixel
                StretchCntl = (BYTESPERPIXEL << SRC_FMT_SHIFT) |
                              (BYTESPERPIXEL << DST_FMT_SHIFT) |
                              0;
              }
#ifdef WINNT_VER40
              TransparentStretch65(ppdev, lpDDHALData,
#else
              TransparentStretch65(
                                   lpDDHALData,
#endif
                                   SrcDDRect, DstDDRect, StretchCntl, dwColor);
            }
            else
            {
#ifdef WINNT_VER40
              StretchColor(ppdev, lpDDHALData,
#else
              StretchColor(
                           lpDDHALData,
#endif
                           DstDDRect.loc.pt.X, DstDDRect.loc.pt.Y,
                           DstDDRect.ext.pt.X, DstDDRect.ext.pt.Y,
                           SrcDDRect.loc.pt.X, SrcDDRect.loc.pt.Y,
                           SrcDDRect.ext.pt.X, SrcDDRect.ext.pt.Y,
                           dwColor);
            }
            goto blt_exit;
          }
          else
          {
            DD_LOG(("Unsupported SrcColorKey Blt -> punt\r\n"));
            ddrval = DDERR_UNSUPPORTED;
            goto blt_exit;
          }
        }

        if (24 != BITSPERPIXEL)
        {
          // if it's 5465AC or earlier, do hw transparency bug workaround
#ifdef WINNT_VER40
          if (1 >= ppdev->dwLgDevRev)
#else
#if 1 //PDR#11507 CK with ConCurrent RAM has the same transparent blt problem with AC.
          if (1 >= lpDDHALData->bLgRevID)
#else
			 if ( ( 1 >= lpDDHALData->bLgRevID ) ||
				 ( (0x25 == lpDDHALData->bLgRevID) &&
					 lpDDHALData->bConCurrentRAM) )
#endif
#endif
          {
            // convert to byte extents and positions
            SrcDDRect.loc.pt.X *= (WORD)BYTESPERPIXEL;
            SrcDDRect.ext.pt.X *= (WORD)BYTESPERPIXEL;
            DstDDRect.loc.pt.X *= (WORD)BYTESPERPIXEL;
            DstDDRect.ext.pt.X *= (WORD)BYTESPERPIXEL;

            if (//(8 >= SrcDDRect.ext.pt.X) &&
                ((7 & SrcDDRect.loc.pt.X) > (7 & DstDDRect.loc.pt.X)))
            {
              WORD  x_ext;

              x_ext = 8 - (SrcDDRect.loc.pt.X & 7);
              if (x_ext < SrcDDRect.ext.pt.X)
              {
#ifdef WINNT_VER40
                ppdev->pfnDrvSrcMBlt(ppdev, lpDDHALData,
#else
                pfnDrvSrcMBlt(
                               lpDDHALData,
#endif
#if OP2_ONLY_SRC_COLORKEY
                              MAKELONG((DD_TRANS | ROP_OP2_copy),
                                       ((BD_RES+BD_OP2)*IS_VRAM)),
#else
                              MAKELONG(rop|DD_TRANS, bdf | BD_OP2),
#endif
                              DstDDRect.loc.DW,
                              SrcDDRect.loc.DW,
                              SrcDDRect.loc.DW,  // Src transparency
                              dwColor,
                              MAKELONG(x_ext,DstDDRect.ext.pt.Y));
                SrcDDRect.loc.pt.X += x_ext;
                DstDDRect.loc.pt.X += x_ext;
                SrcDDRect.ext.pt.X -= x_ext;
                DstDDRect.ext.pt.X -= x_ext;
              }
            }
#ifdef WINNT_VER40
            ppdev->pfnDrvSrcMBlt(ppdev, lpDDHALData,
#else
            pfnDrvSrcMBlt(
                            lpDDHALData,
#endif
#if OP2_ONLY_SRC_COLORKEY
                          MAKELONG((DD_TRANS | ROP_OP2_copy),
                                   ((BD_RES+BD_OP2)*IS_VRAM)),
#else
                          MAKELONG(rop|DD_TRANS, bdf | BD_OP2),
#endif
                          DstDDRect.loc.DW,
                          SrcDDRect.loc.DW,
                          SrcDDRect.loc.DW,  // Src transparency
                          dwColor,
                          DstDDRect.ext.DW);
          }
          // 5465AD and later can do it as a single blt
          else
          {
#ifdef WINNT_VER40
            ppdev->pfnDrvSrcBlt(ppdev, lpDDHALData,
#else
            pfnDrvSrcBlt(
                        lpDDHALData,
#endif
#if OP2_ONLY_SRC_COLORKEY
                         MAKELONG((DD_TRANS | ROP_OP2_copy),
                                  ((BD_RES+BD_OP2)*IS_VRAM)),
#else
                         MAKELONG(rop|DD_TRANS, bdf | BD_OP2),
#endif
                         DstDDRect.loc.DW,
                         SrcDDRect.loc.DW,
                         SrcDDRect.loc.DW,  // Src transparency
                         dwColor,
                         DstDDRect.ext.DW);
          }
        }
        else // 24bpp workaround (needed on 5465AD also)
        {
#ifdef WINNT_VER40
          ColorKeyBlt24(ppdev,lpDDHALData,
#else
          ColorKeyBlt24(
                        lpDDHALData,
#endif
#if OP2_ONLY_SRC_COLORKEY
                        MAKELONG((DD_TRANS | ROP_OP2_copy),
                                 ((BD_RES+BD_OP2)*IS_VRAM)),
#else
                        MAKELONG(rop|DD_TRANS, bdf|BD_OP2),
#endif
                        DstDDRect,
                        SrcDDRect,
                        SrcDDRect,   // src transparency
                        dwColor);
        }
#ifdef DEBUG
        if (FALSE)
          SaveSurfaceToBmp(pbd->lpDDDestSurface);
#endif

      } // (dwFlags & DDBLT_KEYSRCOVERRIDE) // Source Color Key
      else if (dwFlags & DDBLT_KEYDESTOVERRIDE) // Destination Color Key
      {
        DWORD dwColor;

        dwColor =
#ifdef WINNT_VER40
                        DupColor(ppdev,
#else
                        DupColor(
                                 lpDDHALData,
#endif
                                 pbd->bltFX.ddckDestColorkey.dwColorSpaceLowValue);

        DD_LOG(("Dst Color Key Blt\r\n"));

        // Punt if stretch or shrink requested.
        if ((SrcDDRect.ext.pt.X != DstDDRect.ext.pt.X) ||
            (SrcDDRect.ext.pt.Y != DstDDRect.ext.pt.Y))
        {
          DD_LOG(("Unsupported DstColorKey Blt -> punt\r\n"));
          ddrval = DDERR_UNSUPPORTED;
          goto blt_exit;
        }

#ifdef WINNT_VER40
        // If the dwSize not equal to the size of DDBLTFX structure
        // Punt it.
        //
        // For the WHQL TDDRAW test case 29, for some reason, the DDBLTFX
        // structure in DD_BLTDATA is invalid. The dwSize and the
        // ddckDestColorkey fields contain garbage value.
        // In order to pass the test, we force the dwColor to zero if
        // the dwSize of DDBLTFX is invalid.
        if (pbd->bltFX.dwSize != sizeof(DDBLTFX))
        {
//           ddrval = DDERR_UNSUPPORTED;
//           goto blt_exit;
            dwColor = 0;
        };
#endif

        if (24 != BITSPERPIXEL)
        {
#ifdef WINNT_VER40
          ppdev->pfnDrvSrcBlt(ppdev, lpDDHALData,
#else
          pfnDrvSrcBlt(
                        lpDDHALData,
#endif
                       MAKELONG(rop|DD_TRANS|DD_TRANSOP, bdf | BD_OP2),
                       DstDDRect.loc.DW,
                       SrcDDRect.loc.DW,
                       DstDDRect.loc.DW,  // Dst transparency
                       dwColor,     //
                       DstDDRect.ext.DW);
        }
        else
        {
#ifdef WINNT_VER40
          ColorKeyBlt24(ppdev,lpDDHALData,
#else
          ColorKeyBlt24(
                        lpDDHALData,
#endif
                        MAKELONG(rop|DD_TRANS|DD_TRANSOP, bdf|BD_OP2),
                        DstDDRect,
                        SrcDDRect,
                        DstDDRect,   // dst transparency
                        dwColor);
        }
      } // (dwFlags & DDBLT_KEYDESTOVERRIDE) // Destination Color Key
      else
      {
#if _WIN32_WINNT >= 0x0500
	#define BLAM  (DDRAWISURF_HASPIXELFORMAT)
#else
	#define BLAM  (DDRAWISURF_HASPIXELFORMAT | DDRAWISURF_HASOVERLAYDATA)
#endif
        if ((BLAM == (BLAM & pbd->lpDDDestSurface->dwFlags)) &&
            (BLAM == (BLAM & pbd->lpDDSrcSurface->dwFlags))
#if _WIN32_WINNT >= 0x0500
			&& (pbd->lpDDDestSurface->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
			&& (pbd->lpDDSrcSurface->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
#endif
		)
        {
          if (//(FOURCC_UYVY == dst->ddpfSurface.dwFourCC) &&
              //(FOURCC_UYVY == src->ddpfSurface.dwFourCC) &&
              (SrcDDRect.ext.pt.X == DstDDRect.ext.pt.X) &&
              (SrcDDRect.ext.pt.Y == DstDDRect.ext.pt.Y))
          {
#ifndef WINNT_VER40
            LP_SURFACE_DATA lpSrcSurfaceData;
            LP_SURFACE_DATA lpDstSurfaceData;
#endif
            DWORD   dstbpp,srcbpp;

            dstbpp = pbd->lpDDDestSurface->lpGbl->ddpfSurface.dwRGBBitCount / 8;
            srcbpp = pbd->lpDDSrcSurface->lpGbl->ddpfSurface.dwRGBBitCount / 8;
            if (dstbpp != srcbpp)
            {
              ddrval = DDERR_UNSUPPORTED;
              goto blt_exit;
            }

#ifndef WINNT_VER40
            // see if either the src or dst is a linear surface
            // if so do a CPU memcpy
            lpSrcSurfaceData = (LP_SURFACE_DATA)(pbd->lpDDSrcSurface->dwReserved1);
            lpDstSurfaceData = (LP_SURFACE_DATA)(pbd->lpDDDestSurface->dwReserved1);
            if ((FLG_LINEAR & lpSrcSurfaceData->dwOverlayFlags) ||
                (FLG_LINEAR & lpDstSurfaceData->dwOverlayFlags))
            {
              if (ROP_OP1_copy == rop)
              {
                // mind numbing fb to fb copy
                FBToFBCopy((BYTE *)(lpDDHALData->ScreenAddress + DstDDRect.loc.pt.Y * PITCH + DstDDRect.loc.pt.X * 2),
                           dst->lPitch,
                           (BYTE *)(lpDDHALData->ScreenAddress + SrcDDRect.loc.pt.Y * PITCH + SrcDDRect.loc.pt.X * 2),
                           src->lPitch,
                           DstDDRect.ext,
                           dstbpp);
              }
              else
              {
                // punt it
                ddrval = DDERR_UNSUPPORTED;
                goto blt_exit;
              }
            }
            else
#endif
            {
              SrcDDRect.loc.pt.X *= (WORD)BYTESPERPIXEL;
              DstDDRect.loc.pt.X *= (WORD)BYTESPERPIXEL;
              SrcDDRect.ext.pt.X *= (WORD)dstbpp;
              DstDDRect.ext.pt.X *= (WORD)dstbpp;
#ifdef WINNT_VER40
              ppdev->pfnDrvSrcMBlt(ppdev, lpDDHALData,
#else
              pfnDrvSrcMBlt(
                        lpDDHALData,
#endif
                            MAKELONG(rop, bdf),
                            DstDDRect.loc.DW,
                            SrcDDRect.loc.DW,
                            0UL,         // don't care
                            0UL,
                            DstDDRect.ext.DW);
            }
          }
          else
          {
            ddrval = DDERR_UNSUPPORTED;
            goto blt_exit;
          }
        }
        else if ((SrcDDRect.ext.pt.X != DstDDRect.ext.pt.X) ||
                 (SrcDDRect.ext.pt.Y != DstDDRect.ext.pt.Y) ||
                 (DDRAWISURF_HASPIXELFORMAT & pbd->lpDDSrcSurface->dwFlags))
        {
          DWORD     StretchCntl;
          DDRECTL   OrigSrcDDRect;
          DDRECTL   OrigDstDDRect;
          int       nDstBytesPixel = BYTESPERPIXEL;
          int       nSrcBytesPixel = BYTESPERPIXEL;


          if (8 == BITSPERPIXEL)
          {
            StretchCntl = (RGB_8_FMT << SRC_FMT_SHIFT) |
                          (RGB_8_FMT << DST_FMT_SHIFT) |
                          0;
          }
          else if ((DDRAWISURF_HASPIXELFORMAT & pbd->lpDDSrcSurface->dwFlags) &&
                   (DDPF_FOURCC & src->ddpfSurface.dwFlags) &&
                   (FOURCC_UYVY == src->ddpfSurface.dwFourCC))
          {
            StretchCntl =   (YUV_422_FMT << SRC_FMT_SHIFT)
                          | (BYTESPERPIXEL << DST_FMT_SHIFT)
                          | XINTERP_ENABLE | YINTERP_ENABLE
                          ;
            nSrcBytesPixel = 2;
          }
          else
          {
            // this only works because the src & dst fmt's in stretch control
            // for 565, 24bpp & 32bpp are the same as the bytes/pixel
            StretchCntl =   (BYTESPERPIXEL << SRC_FMT_SHIFT)
                          | (BYTESPERPIXEL << DST_FMT_SHIFT)
#if 0
            // tddraw agp Cases 21, 23 & 42 do stretch blts with ddraw and
            // the same stretch through gdi, then they expect the results
            // to be identical
            // Since our display driver is not using interpolation on stretch
            // blts then we either need to rewrite StretchBlt in the display
            // driver (lots of days of work) or disable interpolation in
            // ddraw (a one line change)
                          | XINTERP_ENABLE | YINTERP_ENABLE
#endif
                          ;
          }

          // now compute byte coordinates of src and dst
          // upper left of surface is based on frame buffer pixel format
          // offset into surface is based on surface pixel format
#ifdef WINNT_VER40
          OrigDstDDRect.loc.DW = cvlxy(ppdev->lDeltaScreen,dst->fpVidMem,BYTESPERPIXEL);
#else
          OrigDstDDRect.loc.DW = cvlxy(lpDDHALData,dst->fpVidMem-lpDDHALData->ScreenAddress,
                                       BYTESPERPIXEL);
#endif
          OrigDstDDRect.loc.pt.X *= (USHORT)nDstBytesPixel;
          DstDDRect.loc.DW = OrigDstDDRect.loc.DW;

#ifdef WINNT_VER40
          OrigSrcDDRect.loc.DW = cvlxy(ppdev->lDeltaScreen,src->fpVidMem,BYTESPERPIXEL);
#else
          OrigSrcDDRect.loc.DW = cvlxy(lpDDHALData,src->fpVidMem-lpDDHALData->ScreenAddress,
                                       BYTESPERPIXEL);
#endif
          OrigSrcDDRect.loc.pt.X *= (USHORT)nDstBytesPixel; // YES, it's nDstBytesPixel
          SrcDDRect.loc.DW = OrigSrcDDRect.loc.DW;

#ifndef WINNT_VER40   // nt doesn't get this info
          if (pbd->IsClipped)
          {
            OrigDstDDRect.loc.DW += MAKELONG(pbd->rOrigDest.left * nDstBytesPixel,
                                             pbd->rOrigDest.top);
            OrigDstDDRect.ext.pt.X = (WORD)((pbd->rOrigDest.right - pbd->rOrigDest.left) *
                                            nDstBytesPixel);
            OrigDstDDRect.ext.pt.Y = (WORD)(pbd->rOrigDest.bottom - pbd->rOrigDest.top);

            OrigSrcDDRect.loc.DW += MAKELONG(pbd->rOrigSrc.left * nSrcBytesPixel,
                                             pbd->rOrigSrc.top);
            OrigSrcDDRect.ext.pt.X = (WORD)((pbd->rOrigSrc.right - pbd->rOrigSrc.left) *
                                            nSrcBytesPixel);
            OrigSrcDDRect.ext.pt.Y = (WORD)(pbd->rOrigSrc.bottom - pbd->rOrigSrc.top);

            DstDDRect.loc.DW += MAKELONG(pbd->rDest.left * nDstBytesPixel,
                                         pbd->rDest.top);
            DstDDRect.ext.pt.X = (WORD)((pbd->rDest.right - pbd->rDest.left) *
                                        nDstBytesPixel);
            DstDDRect.ext.pt.Y = (WORD)(pbd->rDest.bottom - pbd->rDest.top);

            SrcDDRect.loc.DW += MAKELONG(pbd->rSrc.left * nSrcBytesPixel,
                                         pbd->rSrc.top);
            SrcDDRect.ext.pt.X = (WORD)((pbd->rSrc.right - pbd->rSrc.left) *
                                        nSrcBytesPixel);
            SrcDDRect.ext.pt.Y = (WORD)(pbd->rSrc.bottom - pbd->rSrc.top);
          }
          else
#endif
          {
            OrigDstDDRect.loc.DW += MAKELONG(pbd->rDest.left * nDstBytesPixel,
                                             pbd->rDest.top);
            DstDDRect.loc.DW = OrigDstDDRect.loc.DW;
            OrigDstDDRect.ext.pt.X = (WORD)((pbd->rDest.right - pbd->rDest.left) *
                                            nDstBytesPixel);
            DstDDRect.ext.pt.X = OrigDstDDRect.ext.pt.X;
            OrigDstDDRect.ext.pt.Y = (WORD)(pbd->rDest.bottom - pbd->rDest.top);
            DstDDRect.ext.pt.Y = OrigDstDDRect.ext.pt.Y;

            OrigSrcDDRect.loc.DW += MAKELONG(pbd->rSrc.left * nSrcBytesPixel,
                                             pbd->rSrc.top);
            SrcDDRect.loc.DW = OrigSrcDDRect.loc.DW;
            OrigSrcDDRect.ext.pt.X = (WORD)((pbd->rSrc.right - pbd->rSrc.left) *
                                            nSrcBytesPixel);
            SrcDDRect.ext.pt.X = OrigSrcDDRect.ext.pt.X;
            OrigSrcDDRect.ext.pt.Y = (WORD)(pbd->rSrc.bottom - pbd->rSrc.top);
            SrcDDRect.ext.pt.Y = OrigSrcDDRect.ext.pt.Y;
          }

#ifdef WINNT_VER40
          DrvStretch65(ppdev, lpDDHALData,
#else
          DrvStretch65(
                        lpDDHALData,
#endif
                     SrcDDRect,
                     DstDDRect,
                     StretchCntl,
                     OrigSrcDDRect,
                     OrigDstDDRect);
        }
        else
        {
#if ENABLE_CLIPPEDBLTS
          DWORD   dstBaseXY;
          DWORD   srcBaseXY;

#ifdef WINNT_VER40
          dstBaseXY = cvlxy(ppdev->lDeltaScreen,dst->fpVidMem,BYTESPERPIXEL);
          srcBaseXY = cvlxy(ppdev->lDeltaScreen,src->fpVidMem,BYTESPERPIXEL);
#else   // Win95
          dstBaseXY = cvlxy(dst->fpVidMem-lpDDHALData->ScreenAddress,BYTESPERPIXEL);
          srcBaseXY = cvlxy(src->fpVidMem-lpDDHALData->ScreenAddress,BYTESPERPIXEL);
#endif

          if (pbd->IsClipped)
          {
            // compute original dst coordinates
            DstDDRect.loc.DW   = dstBaseXY + MAKELONG(pbd->rOrigDest.left, pbd->rOrigDest.top);
            DstDDRect.ext.pt.X = (WORD)(pbd->rOrigDest.right - pbd->rOrigDest.left);
            DstDDRect.ext.pt.Y = (WORD)(pbd->rOrigDest.bottom - pbd->rOrigDest.top);

            // compute original src coordinates
            SrcDDRect.loc.DW   = srcBaseXY + MAKELONG(pbd->rOrigSrc.left, pbd->rOrigSrc.top);
            SrcDDRect.ext.pt.X = (WORD)(pbd->rOrigSrc.right - pbd->rOrigSrc.left);
            SrcDDRect.ext.pt.Y = (WORD)(pbd->rOrigSrc.bottom - pbd->rOrigSrc.top);

            // do the blts
#ifdef WINNT_VER40
            ppdev->pfnClippedDrvSrcBlt(ppdev, lpDDHALData,
#else
            pfnClippedDrvSrcBlt(
                        lpDDHALData,
#endif
                                MAKELONG(rop|DD_CLIP, bdf),
						                    DstDDRect.loc.DW,
						                    SrcDDRect.loc.DW,
						                    0UL,         // don't care
						                    0UL,
						                    DstDDRect.ext.DW,
                                dstBaseXY,
                                srcBaseXY,
                                pbd->dwRectCnt,
                                pbd->prDestRects);
          }
          else  // just do a single blt
          {
            // compute dst coordinates
            DstDDRect.loc.DW   = dstBaseXY + MAKELONG(pbd->rDest.left, pbd->rDest.top);
            DstDDRect.ext.pt.X = (WORD)(pbd->rDest.right - pbd->rDest.left);
            DstDDRect.ext.pt.Y = (WORD)(pbd->rDest.bottom - pbd->rDest.top);

            // compute src coordinates
            SrcDDRect.loc.DW   = srcBaseXY + MAKELONG(pbd->rSrc.left, pbd->rSrc.top);
            SrcDDRect.ext.pt.X = (WORD)(pbd->rSrc.right - pbd->rSrc.left);
            SrcDDRect.ext.pt.Y = (WORD)(pbd->rSrc.bottom - pbd->rSrc.top);
#endif  // ENABLE_CLIPPEDBLTS

            // do the blt
#ifdef WINNT_VER40
            ppdev->pfnDrvSrcBlt(ppdev, lpDDHALData,
#else
            pfnDrvSrcBlt(
                        lpDDHALData,
#endif
                         MAKELONG(rop, bdf),
						             DstDDRect.loc.DW,
						             SrcDDRect.loc.DW,
						             0UL,         // don't care
						             0UL,
						             DstDDRect.ext.DW);
#if ENABLE_CLIPPEDBLTS
          }
#endif  // ENABLE_CLIPPEDBLTS
				}
      }
    }
    else // DST ONLY rops
    {
#if ENABLE_CLIPPEDBLTS
      DWORD   dstBaseXY;
#endif  // ENABLE_CLIPPEDBLTS

      DD_LOG(("Dst Only Blt\r\n"));

#if ENABLE_CLIPPEDBLTS
#ifdef WINNT_VER40
      dstBaseXY = cvlxy(ppdev->lDeltaScreen,dst->fpVidMem,BYTESPERPIXEL);
#else   // Win95
      dstBaseXY = cvlxy(dst->fpVidMem-lpDDHALData->ScreenAddress,BYTESPERPIXEL);
#endif

      if (pbd->IsClipped)
      {
        // compute original dst coordinates
        DstDDRect.loc.DW   = dstBaseXY + MAKELONG(pbd->rOrigDest.left, pbd->rOrigDest.top);
        DstDDRect.ext.pt.X = (WORD)(pbd->rOrigDest.right - pbd->rOrigDest.left);
        DstDDRect.ext.pt.Y = (WORD)(pbd->rOrigDest.bottom - pbd->rOrigDest.top);

        // do the blts
#ifdef WINNT_VER40
        ppdev->pfnDrvClippedDstBlt(ppdev, lpDDHALData,
#else
        pfnDrvClippedDstBlt(
                        lpDDHALData,
#endif
                            MAKELONG(rop|DD_CLIP, bdf),
                            DstDDRect.loc.DW,
                            0UL,         // don't care
                            DstDDRect.ext.DW,
                            dstBaseXY,
                            pbd->dwRectCnt,
                            pbd->prDestRects);
      }
      else  // just do a single blt
      {
        // compute dst coordinates
        DstDDRect.loc.DW   = dstBaseXY + MAKELONG(pbd->rDest.left, pbd->rDest.top);
        DstDDRect.ext.pt.X = (WORD)(pbd->rDest.right - pbd->rDest.left);
        DstDDRect.ext.pt.Y = (WORD)(pbd->rDest.bottom - pbd->rDest.top);
#endif  // ENABLE_CLIPPEDBLTS

#ifdef WINNT_VER40
        ppdev->pfnDrvDstBlt(ppdev, lpDDHALData,
#else
        pfnDrvDstBlt(
                        lpDDHALData,
#endif
                     MAKELONG(rop, bdf),
                     DstDDRect.loc.DW,
                     0UL,  // don't care
                     DstDDRect.ext.DW);
#if ENABLE_CLIPPEDBLTS
      }
#endif  // ENABLE_CLIPPEDBLTS
    }  // endif (bdf & BD_OP1) // SRC rops
  } // (dwFlags & DDBLT_ROP)
  else if (dwFlags & DDBLT_COLORFILL)
  {
    DWORD dwColor;
#if ENABLE_CLIPPEDBLTS
    DWORD   dstBaseXY;
#endif


    DD_LOG(("Solid Color Fill\r\n"));

#ifdef WINNT_VER40
    dwColor = DupColor(ppdev,pbd->bltFX.dwFillColor);
#else
    dwColor = DupColor(lpDDHALData,pbd->bltFX.dwFillColor);
#endif

#if ENABLE_CLIPPEDBLTS
#ifdef WINNT_VER40
    dstBaseXY = cvlxy(ppdev->lDeltaScreen,dst->fpVidMem,BYTESPERPIXEL);
#else   // Win95
    dstBaseXY = cvlxy(dst->fpVidMem-lpDDHALData->ScreenAddress,BYTESPERPIXEL);
#endif

    if (pbd->IsClipped)
    {
      // compute original dst coordinates
      DstDDRect.loc.DW   = dstBaseXY + MAKELONG(pbd->rOrigDest.left, pbd->rOrigDest.top);
      DstDDRect.ext.pt.X = (WORD)(pbd->rOrigDest.right - pbd->rOrigDest.left);
      DstDDRect.ext.pt.Y = (WORD)(pbd->rOrigDest.bottom - pbd->rOrigDest.top);

      // do the blts
#ifdef WINNT_VER40
      ppdev->pfnClippedDrvDstBlt(ppdev, lpDDHALData,
#else
      pfnDrvClippedDstBlt(
                        lpDDHALData,
#endif
                          MAKELONG(ROP_OP1_copy | DD_CLIP, BD_RES | (BD_OP1 * IS_SOLID)),
                          DstDDRect.loc.DW,
                          dwColor,
                          DstDDRect.ext.DW,
                          dstBaseXY,
                          pbd->dwRectCnt,
                          pbd->prDestRects);
    }
    else  // just do a single blt
    {
      // compute dst coordinates
      DstDDRect.loc.DW   = dstBaseXY + MAKELONG(pbd->rDest.left, pbd->rDest.top);
      DstDDRect.ext.pt.X = (WORD)(pbd->rDest.right - pbd->rDest.left);
      DstDDRect.ext.pt.Y = (WORD)(pbd->rDest.bottom - pbd->rDest.top);
#endif  // ENABLE_CLIPPEDBLTS

#ifdef WINNT_VER40
      ppdev->pfnDrvDstBlt(ppdev, lpDDHALData,
#else
      pfnDrvDstBlt(
                        lpDDHALData,
#endif
                   MAKELONG(ROP_OP1_copy, BD_RES | (BD_OP1 * IS_SOLID)),
                   DstDDRect.loc.DW,
                   dwColor,  // fill color
                   DstDDRect.ext.DW);
#if ENABLE_CLIPPEDBLTS
    }
#endif
  }
#ifndef WINNT_VER40     // Not WINNT_VER40
  else if (bD3DInit && dwFlags & DDBLT_DEPTHFILL)
  {
    DWORD   dwFillDepth;
#if ENABLE_CLIPPEDBLTS      // I don't think we'll ever get a clipped zbuffer but you never know ...
    DWORD   dstBaseXY;
#endif // ENABLE_CLIPPEDBLTS


    DD_LOG(("Depth Fill Blt\r\n"));

#ifdef WINNT_VER40
    dwFillDepth = DupZFill(ppdev,pbd->bltFX.dwFillDepth,dst->ddpfSurface.dwZBufferBitDepth);
#else
    dwFillDepth = DupZFill(lpDDHALData,pbd->bltFX.dwFillDepth,dst->ddpfSurface.dwZBufferBitDepth);
#endif

#if ENABLE_CLIPPEDBLTS
#ifdef WINNT_VER40
    dstBaseXY = cvlxy(ppdev->lDeltaScreen,dst->fpVidMem,BYTESPERPIXEL);
#else   // Win95
    dstBaseXY = cvlxy(dst->fpVidMem-lpDDHALData->ScreenAddress,BYTESPERPIXEL);
#endif

    if (pbd->IsClipped)
    {
      // compute original dst coordinates
      DstDDRect.loc.DW   = dstBaseXY + MAKELONG(pbd->rOrigDest.left, pbd->rOrigDest.top);
      DstDDRect.ext.pt.X = (WORD)(pbd->rOrigDest.right - pbd->rOrigDest.left);
      DstDDRect.ext.pt.Y = (WORD)(pbd->rOrigDest.bottom - pbd->rOrigDest.top);

      // convert to byte blt
      // 16 bit zbuffer in 32 bit frame buffer trashes everything to right
      // of zbuffer
      // Fixes PDR #9152
      DstDDRect.loc.pt.X *= (WORD)(dst->ddpfSurface.dwZBufferBitDepth / 8);
      DstDDRect.ext.pt.X *= (WORD)(dst->ddpfSurface.dwZBufferBitDepth / 8);

      // do the blts
#ifdef WINNT_VER40
      ppdev->pfnClippedDrvDstMBlt(ppdev, lpDDHALData,
#else
      pfnClippedDrvDstMBlt(
                        lpDDHALData,
#endif
                           MAKELONG(ROP_OP1_copy | DD_CLIP, BD_RES | (BD_OP1 * IS_SOLID)),
                           DstDDRect.loc.DW,
                           dwFillDepth,
                           DstDDRect.ext.DW,
                           dstBaseXY,
                           pbd->dwRectCnt,
                           pbd->prDestRects);
    }
    else  // just do a single blt
    {
      // compute dst coordinates
      DstDDRect.loc.DW   = dstBaseXY + MAKELONG(pbd->rDest.left, pbd->rDest.top);
      DstDDRect.ext.pt.X = (WORD)(pbd->rDest.right - pbd->rDest.left);
      DstDDRect.ext.pt.Y = (WORD)(pbd->rDest.bottom - pbd->rDest.top);
#endif  // ENABLE_CLIPPEDBLTS

      // convert to byte blt
      // 16 bit zbuffer in 32 bit frame buffer trashes everything to right
      // of zbuffer
      // Fixes PDR #9152
      DstDDRect.loc.pt.X *= (WORD)(dst->ddpfSurface.dwZBufferBitDepth / 8);
      DstDDRect.ext.pt.X *= (WORD)(dst->ddpfSurface.dwZBufferBitDepth / 8);

#ifdef WINNT_VER40
      ppdev->pfnDrvDstMBlt(ppdev, lpDDHALData,
#else
      pfnDrvDstMBlt(
                    lpDDHALData,
#endif
                    MAKELONG(ROP_OP1_copy, BD_RES | (BD_OP1 * IS_SOLID)),
                    DstDDRect.loc.DW,
                    dwFillDepth,
                    DstDDRect.ext.DW);
#if ENABLE_CLIPPEDBLTS
    }
#endif // ENABLE_CLIPPEDBLTS
  }
#endif
  else
  {
    DD_LOG(("Unsupported blt - dwFlags = %08lX\r\n", dwFlags));
    ddrval = DDERR_UNSUPPORTED;
    goto blt_exit;
  } // endif (dwFlags & DDBLT_ROP)

blt_exit:

  // Release the hardware - enable HW cursor updates.
  UNLOCK_HW_SEMAPHORE();

  if (ddrval != DD_OK)
     return DDHAL_DRIVER_NOTHANDLED;

  pbd->ddRVal = DD_OK;

  DD_LOG(("Blt65 Exit\r\n"));

  return DDHAL_DRIVER_HANDLED;
} /* Blt65 */

#endif // WINNT_VER35
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\color.c ===
/******************************Module*Header*******************************\
 *
 * Module Name: color.c
 *
 * This algorithm for color dithering is patent pending and its use is
 * restricted to Microsoft products and drivers for Microsoft products.
 * Use in non-Microsoft products or in drivers for non-Microsoft product is
 * prohibited without written permission from Microsoft.
 *
 * The patent application is the primary reference for the operation of the
 * color dithering code.
 *
 * Note that in the comments and variable names, "vertex" means "vertex of
 * either the inner (half intensity) or outer (full intensity) color cube."
 * Vertices map to colors 0-6 and 248-255 of the Windows standard (required)
 * 256-color palette, where vertices 0-6 and 248 are the vertices of the inner
 * color cube, and 0 plus 249-255 are the vertices of the full color cube.
 * Vertex 7 is 75% gray; this could be used in the dither, but that would break
 * apps that depend on the exact Windows 3.1 dithering. This code is Window 3.1
 * compatible.
 *
 * Copyright (c) 1992 Microsoft Corporation
 *
 * $Log:   X:/log/laguna/nt35/displays/cl546x/COLOR.C  $
* 
*    Rev 1.4   20 Aug 1996 11:03:18   noelv
* Bugfix release from Frido 8-19-96
* 
*    Rev 1.1   15 Aug 1996 11:44:24   frido
* Added precompiled header.
* 
*    Rev 1.0   14 Aug 1996 17:16:16   frido
* Initial revision.
* 
*    Rev 1.3   05 Mar 1996 11:57:44   noelv
* Frido version 19
 * 
 *    Rev 1.2   03 Feb 1996 13:36:14   frido
 * Use the compile switch "-Dfrido=0" to disable my extensions.
 * 
 *    Rev 1.1   20 Jan 1996 22:14:52   frido
 * Moved the colored dithering to a seperate routine for the new dither cache.
 *
\**************************************************************************/

#include "precomp.h"

#ifndef frido
  #define frido 1
#endif

/**************************************************************************\
* This function takes a value from 0 - 255 and uses it to create an
* 8x8 pile of bits in the form of a 1BPP bitmap.  It can also take an
* RGB value and make an 8x8 bitmap.  These can then be used as brushes
* to simulate color unavaible on the device.
*
* For monochrome the basic algorithm is equivalent to turning on bits
* in the 8x8 array according to the following order:
*
*  00 32 08 40 02 34 10 42
*  48 16 56 24 50 18 58 26
*  12 44 04 36 14 46 06 38
*  60 28 52 20 62 30 54 22
*  03 35 11 43 01 33 09 41
*  51 19 59 27 49 17 57 25
*  15 47 07 39 13 45 05 37
*  63 31 55 23 61 29 53 21
*
* Reference: A Survey of Techniques for the Display of Continous
*            Tone Pictures on Bilevel Displays,;
*            Jarvis, Judice, & Ninke;
*            COMPUTER GRAPHICS AND IMAGE PROCESSING 5, pp 13-40, (1976)
\**************************************************************************/

#define SWAP_RB 0x00000004
#define SWAP_GB 0x00000002
#define SWAP_RG 0x00000001

#define SWAPTHEM(a,b) (ulTemp = a, a = b, b = ulTemp)

// PATTERNSIZE is the number of pixels in a dither pattern.
#define PATTERNSIZE 64

typedef union _PAL_ULONG {
	PALETTEENTRY pal;
	ULONG ul;
} PAL_ULONG;

typedef struct _VERTEX_DATA {
	ULONG ulCount;  // # of pixels in this vertex
	ULONG ulVertex; // vertex #
} VERTEX_DATA;

// Tells which row to turn a pel on in when dithering for monochrome bitmaps.
static BYTE ajByte[] = {
	0, 4, 0, 4, 2, 6, 2, 6,
	0, 4, 0, 4, 2, 6, 2, 6,
	1, 5, 1, 5, 3, 7, 3, 7,
	1, 5, 1, 5, 3, 7, 3, 7,
	0, 4, 0, 4, 2, 6, 2, 6,
	0, 4, 0, 4, 2, 6, 2, 6,
	1, 5, 1, 5, 3, 7, 3, 7,
	1, 5, 1, 5, 3, 7, 3, 7
};

// The array of monochrome bits used for monc
static BYTE ajBits[] = {
	0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
	0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80,
	0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
	0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
	0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
	0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
	0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
	0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80
};

// Translates vertices back to the original subspace. Each row is a subspace,
// as encoded in ulSymmetry, and each column is a vertex between 0 and 15.
BYTE jSwapSubSpace[8*16] = {
	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
	0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 14, 13, 15,
	0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
	0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
	0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15,
	0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
	0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
	0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
};

// Converts a nibble value in the range 0-15 to a dword value containing the
// nibble value packed 8 times.
ULONG ulNibbleToDwordWithConvert[16] = {
	0x00000000,
	0x01010101,
	0x02020202,
	0x03030303,
	0x04040404,
	0x05050505,
	0x06060606,
	0xF8F8F8F8,
	0x07070707,
	0xF9F9F9F9,
	0xFAFAFAFA,
	0xFBFBFBFB,
	0xFCFCFCFC,
	0xFDFDFDFD,
	0xFEFEFEFE,
	0xFFFFFFFF
};

// Specifies where in the dither pattern colors should be placed in order
// of increasing intensity.
ULONG aulDitherOrder[] = {
  0, 36,  4, 32, 18, 54, 22, 50,
  2, 38,  6, 34, 16, 52, 20, 48,
  9, 45, 13, 41, 27, 63, 31, 59,
 11, 47, 15, 43, 25, 61, 29, 57,
  1, 37,  5, 33, 19, 55, 23, 51,
  3, 39,  7, 35, 17, 53, 21, 49,
  8, 44, 12, 40, 26, 62, 30, 58,
 10, 46, 14, 42, 24, 60, 28, 56,
};

// Array to convert to 256 color from 16 color. Maps from index that represents
// a 16-color vertex (color) to value that specifies the color index in the
// 256-color palette.

BYTE ajConvert[] =
{
	0,
	1,
	2,
	3,
	4,
	5,
	6,
	248,
	7,
	249,
	250,
	251,
	252,
	253,
	254,
	255
};

/******************************Public*Routine******************************\
* DrvDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA colors
*
\**************************************************************************/

ULONG DrvDitherColor(
IN  DHPDEV dhpdev,
IN  ULONG  iMode,
IN  ULONG  rgb,
OUT ULONG *pul)
{
	ULONG   ulGrey, ulRed, ulGreen, ulBlue;

	// Figure out if we need a full color dither or only a monochrome dither
	if (iMode != DM_MONOCHROME)
	{
		// Full color dither
		#if !frido
		/*
		 *	I have moved all code here to a seperate routine for faster dither
		 *	realization. It doesn't effect the original code so I just keep it
		 *	split.
		 */
		#endif
		vDitherColor(rgb, pul);
	}
	else
	{
		// For monochrome we will only use the Intensity (grey level)
		RtlFillMemory((PVOID) pul, PATTERNSIZE / 2, 0); // zero the dither bits

		ulRed	= (ULONG) ((PALETTEENTRY *) &rgb)->peRed;
		ulGreen	= (ULONG) ((PALETTEENTRY *) &rgb)->peGreen;
		ulBlue	= (ULONG) ((PALETTEENTRY *) &rgb)->peBlue;

		// I = .30R + .59G + .11B
		// For convience the following ratios are used:
		//
		//  77/256 = 30.08%
		// 151/256 = 58.98%
		//  28/256 = 10.94%

		ulGrey = (((ulRed * 77) + (ulGreen * 151) + (ulBlue * 28)) >> 8) & 255;

		// Convert the RGBI from 0-255 to 0-64 notation.

		ulGrey = (ulGrey + 1) >> 2;

		while(ulGrey)
		{
			ulGrey--;
			pul[ajByte[ulGrey]] |= (ULONG) ajBits[ulGrey];
		}
	}

	return(DCR_DRIVER);
}

VOID vDitherColor(ULONG rgb, ULONG *pul)
{
	ULONG		ulRed, ulGreen, ulBlue, ulSymmetry;
	ULONG		ulRedTemp, ulGreenTemp, ulBlueTemp, ulTemp;
	VERTEX_DATA	vVertexData[4];
	VERTEX_DATA	*pvVertexData;
	VERTEX_DATA	*pvVertexDataEnd;
	ULONG		*pulDitherOrder;
	ULONG		ulNumPixels;
	BYTE		jColor;
	ULONG		ulColor;
	VERTEX_DATA	*pvMaxVertex;
	ULONG		ulVertex0Temp, ulVertex1Temp, ulVertex2Temp, ulVertex3Temp;
	BYTE		*pjDither = (BYTE *)pul;
	int			i;

	// Split the color into red, green, and blue components
	ulRedTemp	= ((PAL_ULONG *) &rgb)->pal.peRed;
	ulGreenTemp	= ((PAL_ULONG *) &rgb)->pal.peGreen;
	ulBlueTemp	= ((PAL_ULONG *) &rgb)->pal.peBlue;

	// Sort the RGB so that the point is transformed into subspace 0, and
	// keep track of the swaps in ulSymmetry so we can unravel it again
	// later.  We want r >= g >= b (subspace 0).
	ulSymmetry = 0;
	if (ulBlueTemp > ulRedTemp)
	{
		SWAPTHEM(ulBlueTemp,ulRedTemp);
		ulSymmetry = SWAP_RB;
	}

	if (ulBlueTemp > ulGreenTemp)
	{
		SWAPTHEM(ulBlueTemp,ulGreenTemp);
		ulSymmetry |= SWAP_GB;
	}

	if (ulGreenTemp > ulRedTemp)
	{
		SWAPTHEM(ulGreenTemp,ulRedTemp);
		ulSymmetry |= SWAP_RG;
	}

	ulSymmetry <<= 4;   // for lookup purposes

	// Scale the values from 0-255 to 0-64. Note that the scaling is not
	// symmetric at the ends; this is done to match Windows 3.1 dithering
	ulRed	= (ulRedTemp + 1) >> 2;
	ulGreen	= (ulGreenTemp + 1) >> 2;
	ulBlue	= (ulBlueTemp + 1) >> 2;

	// Compute the subsubspace within subspace 0 in which the point lies,
	// then calculate the # of pixels to dither in the colors that are the
	// four vertexes of the tetrahedron bounding the color we're emulating.
	// Only vertices with more than zero pixels are stored, and the
	// vertices are stored in order of increasing intensity, saving us the
	// need to sort them later
	if ((ulRedTemp + ulGreenTemp) > 256)
	{
		// Subsubspace 2 or 3
		if ((ulRedTemp + ulBlueTemp) > 256)
		{
			// Subsubspace 3
			// Calculate the number of pixels per vertex, still in
			// subsubspace 3, then convert to original subspace. The pixel
			// counts and vertex numbers are matching pairs, stored in
			// ascending intensity order, skipping vertices with zero
			// pixels. The vertex intensity order for subsubspace 3 is:
			// 7, 9, 0x0B, 0x0F
			pvVertexData = vVertexData;
			if ((ulVertex0Temp = (64 - ulRed) << 1) != 0)
			{
				pvVertexData->ulCount = ulVertex0Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
			}
			ulVertex2Temp = ulGreen - ulBlue;
			ulVertex3Temp = (ulRed - 64) + ulBlue;
			if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
					ulVertex2Temp) - ulVertex3Temp) != 0)
			{
				pvVertexData->ulCount = ulVertex1Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
			}
			if (ulVertex2Temp != 0)
			{
				pvVertexData->ulCount = ulVertex2Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
			}
			if (ulVertex3Temp != 0)
			{
				pvVertexData->ulCount = ulVertex3Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0F];
			}
		}
		else
		{
			// Subsubspace 2
			// Calculate the number of pixels per vertex, still in
			// subsubspace 2, then convert to original subspace. The pixel
			// counts and vertex numbers are matching pairs, stored in
			// ascending intensity order, skipping vertices with zero
			// pixels. The vertex intensity order for subsubspace 2 is:
			// 3, 7, 9, 0x0B
			pvVertexData = vVertexData;
			ulVertex1Temp = ulBlue << 1;
			ulVertex2Temp = ulRed - ulGreen;
			ulVertex3Temp = (ulRed - 32) + (ulGreen - 32);
			if ((ulVertex0Temp = ((PATTERNSIZE - ulVertex1Temp) -
					ulVertex2Temp) - ulVertex3Temp) != 0)
			{
				pvVertexData->ulCount = ulVertex0Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
			}
			if (ulVertex1Temp != 0)
			{
				pvVertexData->ulCount = ulVertex1Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
			}
			if (ulVertex2Temp != 0)
			{
				pvVertexData->ulCount = ulVertex2Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
			}
			if (ulVertex3Temp != 0)
			{
				pvVertexData->ulCount = ulVertex3Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
			}
		}
	}
	else
	{
		// Subsubspace 0 or 1
		if (ulRedTemp > 128)
		{
			// Subsubspace 1
			// Calculate the number of pixels per vertex, still in
			// subsubspace 1, then convert to original subspace. The pixel
			// counts and vertex numbers are matching pairs, stored in
			// ascending intensity order, skipping vertices with zero
			// pixels. The vertex intensity order for subsubspace 1 is:
			// 1, 3, 7, 9
			pvVertexData = vVertexData;
			if ((ulVertex0Temp = ((32 - ulGreen) + (32 - ulRed)) << 1) != 0)
			{
				pvVertexData->ulCount = ulVertex0Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
			}
			ulVertex2Temp = ulBlue << 1;
			ulVertex3Temp = (ulRed - 32) << 1;
			if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
					ulVertex2Temp) - ulVertex3Temp) != 0)
			{
				pvVertexData->ulCount = ulVertex1Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
			}
			if (ulVertex2Temp != 0)
			{
				pvVertexData->ulCount = ulVertex2Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
			}
			if (ulVertex3Temp != 0)
			{
				pvVertexData->ulCount = ulVertex3Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
			}
		}
		else
		{
			// Subsubspace 0
			// Calculate the number of pixels per vertex, still in
			// subsubspace 0, then convert to original subspace. The pixel
			// counts and vertex numbers are matching pairs, stored in
			// ascending intensity order, skipping vertices with zero
			// pixels. The vertex intensity order for subsubspace 0 is:
			// 0, 1, 3, 7
			pvVertexData = vVertexData;
			if ((ulVertex0Temp = (32 - ulRed) << 1) != 0)
			{
				pvVertexData->ulCount = ulVertex0Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x00];
			}
			if ((ulVertex1Temp = (ulRed - ulGreen) << 1) != 0)
			{
				pvVertexData->ulCount = ulVertex1Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
			}
			ulVertex3Temp = ulBlue << 1;
			if ((ulVertex2Temp = ((PATTERNSIZE - ulVertex0Temp) -
					ulVertex1Temp) - ulVertex3Temp) != 0)
			{
				pvVertexData->ulCount = ulVertex2Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
			}
			if (ulVertex3Temp != 0)
			{
				pvVertexData->ulCount = ulVertex3Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
			}
		}
	}

	// Now that we have found the bounding vertices and the number of
	// pixels to dither for each vertex, we can create the dither pattern

	// Handle 1, 2, and 3 & 4 vertices per dither separately
	ulTemp = pvVertexData - vVertexData;	// # of vertices with more than
											// zero pixels
	if (ulTemp > 2)
	{
		// There are 3 or 4 vertices in this dither

		if (ulTemp == 3)
		{
			// There are 3 vertices in this dither

			// Find the vertex with the most pixels, and fill the whole
			// destination bitmap with that vertex's color, which is faster
			// than dithering it
			if (vVertexData[1].ulCount >= vVertexData[2].ulCount)
			{
				pvMaxVertex = &vVertexData[1];
				ulTemp = vVertexData[1].ulCount;
			}
			else
			{
				pvMaxVertex = &vVertexData[2];
				ulTemp = vVertexData[2].ulCount;
			}
		}
		else
		{
			// There are 4 vertices in this dither

			// Find the vertex with the most pixels, and fill the whole
			// destination bitmap with that vertex's color, which is faster
			// than dithering it
			if (vVertexData[2].ulCount >= vVertexData[3].ulCount)
			{
				pvMaxVertex = &vVertexData[2];
				ulTemp = vVertexData[2].ulCount;
			}
			else
			{
				pvMaxVertex = &vVertexData[3];
				ulTemp = vVertexData[3].ulCount;
			}
		}

		if (vVertexData[1].ulCount > ulTemp)
		{
			pvMaxVertex = &vVertexData[1];
			ulTemp = vVertexData[1].ulCount;
		}
		if (vVertexData[0].ulCount > ulTemp)
		{
			pvMaxVertex = &vVertexData[0];
		}

		pvVertexDataEnd = pvVertexData;

		// Prepare a dword version of the most common vertex number (color)
		ulColor = ulNibbleToDwordWithConvert[pvMaxVertex->ulVertex];

		// Mark that the vertex we're about to do doesn't need to be done
		// later
		pvMaxVertex->ulVertex = 0xFF;

		// Block fill the dither pattern with the more common vertex
		for (i = 0; i < 16; i++)
		{
			pul[i] = ulColor;
		}

		// Now dither all the remaining vertices in order 0->2 or 0->3
		// (in order of increasing intensity)
		pulDitherOrder = aulDitherOrder;
		pvVertexData = vVertexData;
		do
		{
			if (pvVertexData->ulVertex == 0xFF)
			{
				// This is the max vertex, which we already did, but we
				// have to account for it in the dither order
				pulDitherOrder += pvVertexData->ulCount;
			}
			else
			{
				jColor = ajConvert[pvVertexData->ulVertex];
				ulNumPixels = pvVertexData->ulCount;
				switch (ulNumPixels & 3)
				{
					case 3:
						pjDither[*(pulDitherOrder+2)] = jColor;

					case 2:
						pjDither[*(pulDitherOrder+1)] = jColor;

					case 1:
						pjDither[*(pulDitherOrder+0)] = jColor;
						pulDitherOrder += ulNumPixels & 3;

					case 0:
						break;
				}
				if ((ulNumPixels >>= 2) != 0)
				{
					do
					{
						pjDither[*pulDitherOrder] = jColor;
						pjDither[*(pulDitherOrder+1)] = jColor;
						pjDither[*(pulDitherOrder+2)] = jColor;
						pjDither[*(pulDitherOrder+3)] = jColor;
						pulDitherOrder += 4;
					}
					while (--ulNumPixels);
				}
			}
		}
		while (++pvVertexData < pvVertexDataEnd);
	}
	else if (ulTemp == 2)
	{
		// There are exactly two vertices with more than zero pixels; fill
		// in the dither array as follows: block fill with vertex with more
		// points first, then dither in the other vertex
		if (vVertexData[0].ulCount >= vVertexData[1].ulCount)
		{
			// There are no more vertex 1 than vertex 0 pixels, so do
			// the block fill with vertex 0
			ulColor = ulNibbleToDwordWithConvert[vVertexData[0].ulVertex];
			// Do the dither with vertex 1
			jColor = ajConvert[vVertexData[1].ulVertex];
			ulNumPixels = vVertexData[1].ulCount;
			// Set where to start dithering with vertex 1 (vertex 0 is
			// lower intensity, so its pixels come first in the dither
			// order)
			pulDitherOrder = aulDitherOrder + vVertexData[0].ulCount;
		}
		else
		{
			// There are more vertex 1 pixels, so do the block fill
			// with vertex 1
			ulColor = ulNibbleToDwordWithConvert[vVertexData[1].ulVertex];
			// Do the dither with vertex 0
			jColor = ajConvert[vVertexData[0].ulVertex];
			ulNumPixels = vVertexData[0].ulCount;
			// Set where to start dithering with vertex 0 (vertex 0 is
			// lower intensity, so its pixels come first in the dither
			// order)
			pulDitherOrder = aulDitherOrder;
		}

		// Block fill the dither pattern with the more common vertex
		for (i = 0; i < 16; i++)
		{
			pul[i] = ulColor;
		}

		// Dither in the less common vertex
		switch (ulNumPixels & 3)
		{
			case 3:
				pjDither[*(pulDitherOrder+2)] = jColor;

			case 2:
				pjDither[*(pulDitherOrder+1)] = jColor;

			case 1:
				pjDither[*(pulDitherOrder+0)] = jColor;
				pulDitherOrder += ulNumPixels & 3;

			case 0:
				break;
		}
		if ((ulNumPixels >>= 2) != 0)
		{
			do
			{
				pjDither[*pulDitherOrder] = jColor;
				pjDither[*(pulDitherOrder+1)] = jColor;
				pjDither[*(pulDitherOrder+2)] = jColor;
				pjDither[*(pulDitherOrder+3)] = jColor;
				pulDitherOrder += 4;
			}
			while (--ulNumPixels);
		}
	}
	else
	{
		// There is only one vertex in this dither

		// No sorting or dithering is needed for just one color; we can
		// just generate the final DIB directly
		ulColor = ulNibbleToDwordWithConvert[vVertexData[0].ulVertex];
		for (i = 0; i < 16; i++)
		{
			pul[i] = ulColor;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\ddblt.c ===
/***************************************************************************
*
*                ******************************************
*                * Copyright (c) 1996, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:  Laguna I (CL-GD546x) -
*
* FILE:     ddblt.c
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This module implements the DirectDraw BLT components
*           for the Laguna NT driver.
*
* MODULES:
*           WINNT                   WIN95
*             DdGetBltStatus()        GetBltStatus32()
*             SetGamma()
*             DrvStretch64()          DrvStretch64()
*             DrvStretch62()          DrvStretch62()
*             DdBlt()                 Blt32()
*             DupColor()              DupColor()
*             EnoughFifoForBlt()      EnoughFifoForBlt()
*                                     RGBResizeBOF64()
*                                     RGB16ShrinkBOF64()
*
* REVISION HISTORY:
*   7/12/96     Benny Ng      Initial version
*
* $Log:   X:/log/laguna/ddraw/src/ddblt.c  $
*
*    Rev 1.25   Feb 16 1998 16:20:02   frido
* Fixed a NT 4.0 compilation bug (lpData is called lpGbl).
*
*    Rev 1.24   14 Jan 1998 06:18:58   eleland
*
* support for display list page-flipping: calls to UpdateFlipStatus are
* thru pointer to function pfnUpdateFlipStatus
*
*    Rev 1.23   07 Jan 1998 17:45:30   xcong
* Fix the change for WIN95 which breaks NT in DUP_COLOR macro.
*
*    Rev 1.22   06 Jan 1998 14:31:28   xcong
* Change all the macros to use lpDDHALData instead of pDriverData.
*
*    Rev 1.21   06 Jan 1998 11:44:42   xcong
* Change pDriverData into local lpDDHALData for multi-monitor support.
*
*    Rev 1.20   03 Oct 1997 14:46:50   RUSSL
* Initial changes for use of hw clipped blts
* All changes wrapped in #if ENABLE_CLIPPEDBLTS/#endif blocks and
* ENABLE_CLIPPEDBLTS defaults to 0 (so the code is disabled)
*
*    Rev 1.19   01 Oct 1997 17:44:24   eleland
* added check in blt32() to detect blts to host texture surfaces and
* punt those blts back to the ddraw HEL
*
*    Rev 1.18   30 Jul 1997 20:56:22   RANDYS
*
* Added code to check for zero extent blts
*
*    Rev 1.17   18 Jul 1997 10:23:34   RUSSL
* Modified StretchColor to use function ptr to blt routines rather than
* directly program registers.  This is for compatiblity with display lists
*
*    Rev 1.16   14 Jul 1997 14:49:32   RUSSL
* Modified BltInit's initialization of pfnDrvStrBlt for Win95
*
*    Rev 1.15   08 Jul 1997 11:15:20   RUSSL
* Removed an ASSERT that is no longer valid in StretchColor
*
*    Rev 1.14   07 Jul 1997 10:57:14   dzenz
* Added check of DRVSEM_DISPLAY_LIST semaphore to ascertain if
* qmRequestDirectAccess needs to be called.
*
*    Rev 1.13   08 Apr 1997 12:17:06   einkauf
* WINNT_VER40 affected only: add SYNC_W_3D to coordinate MCD/2D HW access
*
*    Rev 1.12   03 Apr 1997 15:24:48   RUSSL
* Added pfnDrvDstMBlt global var
* Added initializing pfnDrvDstMBlt in BltInit
* Modified DDBLT_DEPTHFILL case in Blt32 to blt based on surface colordepth
*   it was clearing 16bit zbuffers in 32bit modes with pixel blts so would
*   wipe out everything to the right of the actual zbuffer
*   Fixes at least PDRs #9152, 9150 & 8789 (maybe others as well)
*
*    Rev 1.11   01 Apr 1997 09:15:24   RUSSL
* Added calls to SyncWithQueueManager in GetBltStatus32
*
*    Rev 1.10   26 Mar 1997 14:08:22   RUSSL
* Added pfnDrvSrcMBlt global var
* Added initializing pfnDrvSrcMBlt in BltInit
* Moved sync with queue manager in Blt32 in front of updateFlipStatus since
*   updateFlipStatus may access the hardware
*
*    Rev 1.9   18 Mar 1997 07:50:24   bennyn
* Resolved NT compiling error by #ifdef queue manager sync call
*
*    Rev 1.8   12 Mar 1997 15:02:02   RUSSL
* replaced a block of includes with include of precomp.h for
*   precompiled headers
*
*    Rev 1.7   07 Mar 1997 12:51:38   RUSSL
* Modified DDRAW_COMPAT usage
*
*    Rev 1.6   03 Mar 1997 10:32:34   eleland
* modified queue manager sync call to check 2d display list
* flag; removed USE_QUEUE_MANAGER #ifdef
*
*    Rev 1.5   07 Feb 1997 13:22:36   KENTL
* Merged in Evan Leland's modifications to get Display List mode working:
* 	* include qmgr.h
* 	* Call qmRequesetDirectAcces() if 3D is busy (Disabled)
*
*    Rev 1.4   21 Jan 1997 14:45:42   RUSSL
* Added include of ddinline.h
*
*    Rev 1.3   15 Jan 1997 10:45:20   RUSSL
* Made Win95 function ptr vars global
* Moved following inline functions to bltP.h: DupZFill, DupColor &
*   EnoughFifoForBlt
*
*    Rev 1.2   13 Dec 1996 15:28:32   CRAIGN
* Added a Frido YUV move fix.
*
*    Rev 1.1   25 Nov 1996 16:16:10   bennyn
* Fixed misc compiling errors for NT
*
*    Rev 1.0   25 Nov 1996 14:43:02   RUSSL
* Initial revision.
*
*    Rev 1.6   25 Nov 1996 14:40:02   RUSSL
* Yet another merge of winNT & win95 code
*
*    Rev 1.5   25 Nov 1996 11:39:02   RUSSL
* Added TransparentStretch function
*
*    Rev 1.4   18 Nov 1996 16:16:18   RUSSL
* Added file logging for DDraw entry points and register writes
*
*    Rev 1.3   12 Nov 1996 09:42:02   CRAIGN
* Frido 1112s2 release... fixes TDDRAW case 26.
* Changed transparency for DDBLT_KEYDESTOVERRIDE to "not equal."
*
*    Rev 1.2   11 Nov 1996 12:36:48   CRAIGN
* Frido 1112 release - added software color key stretch.
*
*    Rev 1.1   06 Nov 1996 12:28:42   CRAIGN
* Frido 1106 - added check for rectangle movement.
*
*    Rev 1.0   01 Nov 1996 13:09:30   RUSSL
* Merge WIN95 & WINNT code for Blt32
*
*    Rev 1.9   01 Nov 1996 09:23:24   BENNYN
* Initial copy of shareable DD blt code
*
* COMBINED WINNT & WIN95 VERSIONS OF BLT CODE
*
*    Rev 1.17   25 Oct 1996 11:55:54   RUSSL
* Forgot to remove the undef RDRAM_8BIT
*
*    Rev 1.16   25 Oct 1996 11:50:16   RUSSL
* Added use of function pointers for all the short blt functions (like
* DrvDstBlt, DrvSrcBlt, etc.).  Moved the short blt functions to a
* separate file (blt_dir.c).  Modified DrvStretch64, DrvStretch62,
* RGBResizeBOF64 & RGB16ShrinkBOF64 to use the blt function pointers
* rather than directly call one of the short blt functions or write
* directly to the registers.  This enables the short blt functions to
* be written as display lists rather than directly writing to the
* registers (in fact, that's whats in blt_dl.c)
*
* Added BltInit function to initialize the function pointers.  BltInit
* needs to be called by buildHALInfo32.
*
*    Rev 1.15   21 Oct 1996 11:56:08   RUSSL
* Added RGB16ShrinkBOF64 to handle 16bpp shrink blts on the 5464
* Now RGBResizeBOF64 only handles 8bpp stretches, 8bpp shrinks and
*   16bpp stretches on the 5464
* Added QFREE checking before blts in both RGB???BOF64 functions
*
*    Rev 1.14   16 Oct 1996 16:10:40   RUSSL
* Added RGBResizeBOF64 to handle resize blts on 5464
* 8bpp stretches, 8bpp shrinks and 16bpp stretches ain't perfect but
*   hopefully they're acceptable
* 16bpp shrinks are still broken
*
*    Rev 1.13   07 Oct 1996 09:03:04   RUSSL
* Modified DDRAW_COMPAT_xx conditionally compiled stuff
*
*    Rev 1.12   04 Oct 1996 11:39:10   KENTL
* Fixed PDR#6799 - playing two AVI's result in first window replicated in
* second. Changed the way Blt32 does an x-coordinate computation.
*
*    Rev 1.11   04 Oct 1996 10:46:50   KENTL
* Added fix for 32bpp video bug: we were trying to do stretches in 32bpp,
* which a) is not supported in HW and b) was being interpreted as 16bpp
* which cause really lousy things to happen on the screen.
*
*    Rev 1.9   04 Sep 1996 17:32:06   MARTINB
* Corrected shrink by 8 bug in odd sized mpegs.
* Corrected multiple mpeg sources corrupting working stroage.
*
*    Rev 1.8   22 Aug 1996 10:37:14   MARTINB
* Corrected a number of QFREE check constants for the strech62 routines that
* were causing sound breakup on moving / resizing a video window.
*
*    Rev 1.7   14 Aug 1996 16:53:20   MARTINB
* Yet another last minute fix to the last minute fix. This one fixes
* the banding in 422 video caused by doing the blt twice. The second time
* incorrectly !!
*
*    Rev 1.6   13 Aug 1996 13:25:02   MARTINB
* Moved shrink rejection for 565/8bit formats to correct place in blt32 logic
*
*    Rev 1.5   13 Aug 1996 08:31:12   MARTINB
* Added stretch routines for CL-GD5464 support
* renamed previous stretch logic to DrvStretch62.
*
*    Rev 1.4   23 Jul 1996 11:20:04   KENTL
* Merged in Jeff Orts D3D integration changes.
*   * Created DupZFill()
*   * Added code to do Z-Fill blits.
*
*    Rev 1.3   19 Jul 1996 16:24:38   CRAIGN
* Removed two int 3s that I left in the code.
*
*    Rev 1.2   19 Jul 1996 09:31:20   CRAIGN
* Added workaround for Stretch Bug o' Death.
* Instead of doing SRAM blts to make sure that PTAG is set/reset,
* use a destcopy blt to PTAGFooPixel.  This x/y coordinate is set by the
* display driver to be one pixel below the bottom of the screen (where the
* scratch buffer lives).
*
*    Rev 1.1   15 Jul 1996 16:58:40   RUSSL
* Added support for DirectDraw 3.0
*
*    Rev 1.0   26 Jun 1996 11:05:06   RUSSL
* Initial revision.
*
****************************************************************************
****************************************************************************/

/*----------------------------- INCLUDES ----------------------------------*/

#include "precomp.h"

// If WinNT 3.5 skip all the source code
#if defined WINNT_VER35      // WINNT_VER35

#else

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifndef WINNT_VER40     // Not WINNT_VER40

#include "flip.h"
#include "surface.h"
#include "blt.h"
#include "palette.h"
#include "qmgr.h"
#include "bltP.h"
#include "ddinline.h"
#include "ddshared.h"
#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

/*----------------------------- DEFINES -----------------------------------*/

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

// DBGBREAKPOINT();
#define AFPRINTF(n)

#define DBGLVL        1
#define DBGLVL1       1
#define DBGLVL2       1      // DrvSrcBlt & SrvDstBlt
#define DBGLVL3       1      // DrvStretchBlt

#define LGDEVID              ppdev->dwLgDevID
#define OFFSCR_YUV_VAR       ppdev->offscr_YUV
#define MEMCMP(A,B)          memcmp(&ppdev->offscr_YUV.SrcRect, (A),(B))

#define DRAW_ENGINE_BUSY     DrawEngineBusy(lpDDHALData)
#define ENOUGH_FIFO_FOR_BLT  EnoughFifoForBlt(DRIVERDATA* lpDDHALData)
#define SET_GAMMA            SetGamma(PDEV* ppdev, DRIVERDATA* lpDDHALData)
#define UPDATE_FLIP_STATUS(arg)  vUpdateFlipStatus(&ppdev->flipRecord, (arg))

#define DRVSTRETCH64      DrvStretch64(PDEV* ppdev, DRIVERDATA* lpDDHALData,
#define DRVSTRETCH62      DrvStretch62(PDEV* ppdev, DRIVERDATA* lpDDHALData,
#define DUP_COLOR         DupColor(PDEV* ppdev,
#define RGB_RESIZEBOF64   RGBResizeBOF64(PDEV* ppdev, DRIVERDATA* lpDDHALData,
#define RGB_16SHRINKBOF64 RGB16ShrinkBOF64(PDEV* ppdev, DRIVERDATA* lpDDHALData,
#define DUPZFILL          DupZFill(PDEV* ppdev,

#define CALL_ENOUGH_FIFO_FOR_BLT  EnoughFifoForBlt(lpDDHALData)

#define CALL_DELAY_9BIT_BLT(arg)          ppdev->pfnDelay9BitBlt(ppdev,lpDDHALData, (arg))
#define CALL_EDGE_FILL_BLT(A,B,C,D,E,F)   ppdev->pfnEdgeFillBlt(ppdev,lpDDHALData, (A),(B),(C),(D),(E),(F))
#define CALL_MEDGE_FILL_BLT(A,B,C,D,E,F)  ppdev->pfnMEdgeFillBlt(ppdev,lpDDHALData, (A),(B),(C),(D),(E),(F))
#define CALL_DRV_DST_BLT(A,B,C,D)         ppdev->pfnDrvDstBlt(ppdev,lpDDHALData, (A),(B),(C),(D))
#define CALL_DRV_DST_MBLT(A,B,C,D)        ppdev->pfnDrvDstMBlt(ppdev,lpDDHALData, (A),(B),(C),(D))
#define CALL_DRV_SRC_BLT(A,B,C,D,E,F)     ppdev->pfnDrvSrcBlt(ppdev,lpDDHALData, (A),(B),(C),(D),(E),(F))
#define CALL_DRV_STR_BLT(A)               ppdev->pfnDrvStrBlt(ppdev,lpDDHALData, (A))
#define CALL_DRV_STR_MBLT(A)              ppdev->pfnDrvStrMBlt(ppdev,lpDDHALData, (A))
#define CALL_DRV_STR_MBLTX(A)             ppdev->pfnDrvStrMBltX(ppdev,lpDDHALData, (A))
#define CALL_DRV_STR_MBLTY(A)             ppdev->pfnDrvStrMBltY(ppdev,lpDDHALData, (A))
#define CALL_DRV_STR_BLTY(A)              ppdev->pfnDrvStrBltY(ppdev,lpDDHALData, (A))
#define CALL_DRV_STR_BLTX(A)              ppdev->pfnDrvStrBltX(ppdev,lpDDHALData, (A))

#define CALL_DIR_DELAY_9BIT_BLT(arg)          DIR_Delay9BitBlt(ppdev,lpDDHALData, (arg))
#define CALL_DIR_EDGE_FILL_BLT(A,B,C,D,E,F)   DIR_EdgeFillBlt(ppdev,lpDDHALData, (A),(B),(C),(D),(E),(F))
#define CALL_DIR_MEDGE_FILL_BLT(A,B,C,D,E,F)  DIR_MEdgeFillBlt(ppdev,lpDDHALData, (A),(B),(C),(D),(E),(F))
#define CALL_DIR_DRV_DST_BLT(A,B,C,D)         DIR_DrvDstBlt(ppdev,lpDDHALData, (A),(B),(C),(D))
#define CALL_DIR_DRV_STR_BLT(A)               DIR_DrvStrBlt(ppdev,lpDDHALData, (A))
#define CALL_DIR_DRV_STR_MBLT(A)              DIR_DrvStrMBlt(ppdev,lpDDHALData, (A))
#define CALL_DIR_DRV_STR_MBLTX(A)             DIR_DrvStrMBltX(ppdev,lpDDHALData, (A))
#define CALL_DIR_DRV_STR_MBLTY(A)             DIR_DrvStrMBltY(ppdev,lpDDHALData, (A))

#define CALL_DRVSTRETCH64(A,B,C,D,E,F,G,H,I,J,K,L)    DrvStretch64(ppdev,lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L))
#define CALL_DRVSTRETCH62(A,B,C,D,E,F,G,H,I,J,K,L)    DrvStretch62(ppdev,lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L))
#define CALL_DUP_COLOR(A)                             DupColor(ppdev, (A))
#define CALL_RGB_RESIZEBOF64(A,B,C,D,E,F,G,H)    RGBResizeBOF64(ppdev,lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H))
#define CALL_RGB_16SHRINKBOF64(A,B,C,D,E,F,G,H)  RGB16ShrinkBOF64(ppdev,lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H))
#define CALL_DUPZFILL(A,B)                       DupZFill(ppdev, (A),(B))

#define STRETCHCOLOR                                StretchColor(PDEV* ppdev, DRIVERDATA* lpDDHALData,
#define CALL_STRETCHCOLOR(A,B,C,D,E,F,G,H,I)        StretchColor(ppdev,lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H),(I))
#define TRANSPARENTSTRETCH                          TransparentStretch(PDEV* ppdev, DRIVERDATA* lpDDHALData,
#define CALL_TRANSPARENTSTRETCH(A,B,C,D,E,F,G,H,I)  TransparentStretch(ppdev,lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H),(I))

#else   // ----- #elseif WINNT_VER40-----

#define TRACE_STRETCH 1
#define TRACE_ALL     1

#define LGDEVID                   lpDDHALData->dwLgVenDevID
#define OFFSCR_YUV_VAR            offscr_YUV
#define MEMCMP(A,B)               memcmp(&offscr_YUV.SrcRect, (A),(B))

#define ENOUGH_FIFO_FOR_BLT       EnoughFifoForBlt(lpDDHALData)
#define SET_GAMMA                 SetGamma(lpDDHALData)
#define UPDATE_FLIP_STATUS(arg)   updateFlipStatus((arg), lpDDHALData)

#define DRVSTRETCH64              DrvStretch64(
#define DRVSTRETCH62              DrvStretch62(
#define DUP_COLOR                 DupColor(
#define RGB_RESIZEBOF64           RGBResizeBOF64(
#define RGB_16SHRINKBOF64         RGB16ShrinkBOF64(
#define DUPZFILL                  DupZFill(

#define CALL_ENOUGH_FIFO_FOR_BLT              EnoughFifoForBlt(lpDDHALData)
#define CALL_DELAY_9BIT_BLT(arg)              pfnDelay9BitBlt(lpDDHALData,(arg))
#define CALL_EDGE_FILL_BLT(A,B,C,D,E,F)       pfnEdgeFillBlt(lpDDHALData,(A),(B),(C),(D),(E),(F))
#define CALL_MEDGE_FILL_BLT(A,B,C,D,E,F)      pfnMEdgeFillBlt(lpDDHALData,(A),(B),(C),(D),(E),(F))
#define CALL_DRV_DST_BLT(A,B,C,D)             pfnDrvDstBlt(lpDDHALData,(A),(B),(C),(D))
#define CALL_DRV_DST_MBLT(A,B,C,D)            pfnDrvDstMBlt(lpDDHALData,(A),(B),(C),(D))
#define CALL_DRV_SRC_BLT(A,B,C,D,E,F)         pfnDrvSrcBlt(lpDDHALData,(A),(B),(C),(D),(E),(F))
#define CALL_DRV_STR_BLT(A)                   pfnDrvStrBlt(lpDDHALData,(A))
#define CALL_DRV_STR_MBLT(A)                  pfnDrvStrMBlt(lpDDHALData,(A))
#define CALL_DRV_STR_MBLTX(A)                 pfnDrvStrMBltX(lpDDHALData,(A))
#define CALL_DRV_STR_MBLTY(A)                 pfnDrvStrMBltY(lpDDHALData,(A))
#define CALL_DRV_STR_BLTY(A)                  pfnDrvStrBltY(lpDDHALData,(A))
#define CALL_DRV_STR_BLTX(A)                  pfnDrvStrBltX(lpDDHALData,(A))

#define CALL_DIR_DELAY_9BIT_BLT(arg)          DIR_Delay9BitBlt(lpDDHALData,(arg))
#define CALL_DIR_EDGE_FILL_BLT(A,B,C,D,E,F)   DIR_EdgeFillBlt(lpDDHALData,(A),(B),(C),(D),(E),(F))
#define CALL_DIR_MEDGE_FILL_BLT(A,B,C,D,E,F)  DIR_MEdgeFillBlt(lpDDHALData,(A),(B),(C),(D),(E),(F))
#define CALL_DIR_DRV_DST_BLT(A,B,C,D)         DIR_DrvDstBlt(lpDDHALData,(A),(B),(C),(D))
#define CALL_DIR_DRV_STR_BLT(A)               DIR_DrvStrBlt(lpDDHALData,(A))
#define CALL_DIR_DRV_STR_MBLT(A)              DIR_DrvStrMBlt(lpDDHALData,(A))
#define CALL_DIR_DRV_STR_MBLTX(A)             DIR_DrvStrMBltX(lpDDHALData,(A))
#define CALL_DIR_DRV_STR_MBLTY(A)             DIR_DrvStrMBltY(lpDDHALData,(A))

#define CALL_DRVSTRETCH64(A,B,C,D,E,F,G,H,I,J,K,L)    DrvStretch64(lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L))
#define CALL_DRVSTRETCH62(A,B,C,D,E,F,G,H,I,J,K,L)    DrvStretch62(lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L))
#define CALL_DUP_COLOR(A)                             DupColor(lpDDHALData,(A))
#define CALL_RGB_RESIZEBOF64(A,B,C,D,E,F,G,H)         RGBResizeBOF64(lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H))
#define CALL_RGB_16SHRINKBOF64(A,B,C,D,E,F,G,H)       RGB16ShrinkBOF64(lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H))
#define CALL_DUPZFILL(A,B)                            DupZFill(lpDDHALData,(A),(B))

#define STRETCHCOLOR                                StretchColor(
#define CALL_STRETCHCOLOR(A,B,C,D,E,F,G,H,I)        StretchColor(lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H),(I))
#define TRANSPARENTSTRETCH                          TransparentStretch(
#define CALL_TRANSPARENTSTRETCH(A,B,C,D,E,F,G,H,I)  TransparentStretch(lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H),(I))


#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

typedef short DDAX;
typedef struct {DDAX accum; DDAX maj; DDAX min;} AXIS;

#define EDGE_CLIP     // Trim excess pixels from edges (>= 10%) in 8Bpp Mode
#define EDGE_CLIP_16  // Trim excess pixels from edges (>= 10%) in 8Bpp Mode
#define BOGUS_YUV  0x0081 // Top of palette below Windows reserved area
//#define BOGUS_8BIT

#define LOCK_HW_SEMAPHORE()    (lpDDHALData->DrvSemaphore |= DRVSEM_IN_USE)
#define UNLOCK_HW_SEMAPHORE()  (lpDDHALData->DrvSemaphore &= ~ DRVSEM_IN_USE)


/*--------------------- STATIC FUNCTION PROTOTYPES ------------------------*/
#ifdef WINNT_VER40
static __inline DWORD DUP_COLOR   DWORD dwColor );
#else
static __inline DWORD DUP_COLOR   LPGLOBALDATA lpDDHALData, DWORD dwColor );
#endif
static __inline BOOL ENOUGH_FIFO_FOR_BLT;

/*--------------------------- ENUMERATIONS --------------------------------*/

/*----------------------------- TYPEDEFS ----------------------------------*/

/*-------------------------- STATIC VARIABLES -----------------------------*/
static const WORD lncntl[] = {LN_8BIT, LN_RGB565, LN_24PACK, LN_24ARGB,};


// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifndef WINNT_VER40     // Not WINNT_VER40

ASSERTFILE("blt.c");
OFFSCR_YUV  offscr_YUV = {{ 0, 0, 0, 0}, FALSE};

PFN_DELAY9BLT    pfnDelay9BitBlt;
PFN_EDGEFILLBLT  pfnEdgeFillBlt;
PFN_MEDGEFILLBLT pfnMEdgeFillBlt;
PFN_DRVDSTBLT    pfnDrvDstBlt;
PFN_DRVDSTMBLT   pfnDrvDstMBlt;
PFN_DRVSRCBLT    pfnDrvSrcBlt;
PFN_DRVSRCMBLT   pfnDrvSrcMBlt;
PFN_DRVSTRBLT    pfnDrvStrBlt;
PFN_DRVSTRMBLT   pfnDrvStrMBlt;
PFN_DRVSTRMBLTY  pfnDrvStrMBltY;
PFN_DRVSTRMBLTX  pfnDrvStrMBltX;
PFN_DRVSTRBLTY   pfnDrvStrBltY;
PFN_DRVSTRBLTX   pfnDrvStrBltX;

extern PFN_UPDATEFLIPSTATUS pfnUpdateFlipStatus;

#if ENABLE_CLIPPEDBLTS
PFN_CLIPPEDDRVDSTBLT  pfnClippedDrvDstBlt;
PFN_CLIPPEDDRVDSTMBLT pfnClippedDrvDstMBlt;
PFN_CLIPPEDDRVSRCBLT  pfnClippedDrvSrcBlt;
#endif

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>


/*-------------------------- GLOBAL FUNCTIONS -----------------------------*/

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

//***** SetGamma ********************************************************
// Use only for YUV 8BPP
//
#define LOWER_YUV       16
#define UPPER_YUV       240
#define LOWER_PALETTE   0
#define UPPER_PALETTE   255

void SetGamma(PDEV* ppdev, DRIVERDATA* lpDDHALData)
{
  int indx;
  PVGAR pREG = (PVGAR) lpDDHALData->RegsAddress;

  DISPDBG((DBGLVL, "DDraw - SetGamma\n"));

  for ( indx = LOWER_PALETTE ; indx <= UPPER_PALETTE ; indx++ )
  { // Initialise gamma palette

    int  value;
    value = ((indx - LOWER_YUV) * UPPER_PALETTE) / (UPPER_YUV - LOWER_YUV);
    if ( value < LOWER_PALETTE )
      value = LOWER_PALETTE;

    if ( value > UPPER_PALETTE )
      value = UPPER_PALETTE;

    LL8(grPalette_Write_Address, (BYTE)(indx));
    LL8(grPalette_Data, (BYTE)(value)); // Red
    LL8(grPalette_Data, (BYTE)(value)); // Grn
    LL8(grPalette_Data, (BYTE)(value)); // Blu
  };
} // SetGamma

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>


/***************************************************************************
*
* FUNCTION:     RGBResizeBOF64
*
* DESCRIPTION:  Handles 8bpp RGB stretches, 8bpp RGB shrinks and
*               16bpp RGB stretches on the 5464
*
****************************************************************************/

#define SRAM_SIZE     128

void RGB_RESIZEBOF64
#ifndef WINNT_VER40
         LPGLOBALDATA lpDDHALData,
#endif
         int xDst, int yDst, int cxDst, int cyDst,
         int xSrc, int ySrc, int cxSrc, int cySrc )
{
  const int nBytesPixel = BYTESPERPIXEL;

  // setting nSRAMPixels to the number of pixels that fit in sram divided
  // by two gives better shrinks at 8bpp and doesn't lock up the chip on
  // stretches at 16bpp
  const int nSRAMPixels = (SRAM_SIZE / nBytesPixel) / 2;
  const int nSRAMMask   = nSRAMPixels - 1;

  autoblt_regs  bltr;

  AXIS  axis[2];
  int   nDst[2];
  int   nSrc[2];
  int   i;

  DDAX  accx;
  int   srcxext;
  int   dstxext;
  int   srcx;
  int   xext;


  DD_LOG(("RGBResizeBOF64 - %d bpp %s in X\r\n", nBytesPixel,
          (cxDst < cxSrc) ? "shrink" : "stretch"));
  DD_LOG(("dst=%08lX dstext=%08lX src=%08lX srcext=%08lX\r\n",
          MAKELONG(xDst,yDst),MAKELONG(cxDst,cyDst),
          MAKELONG(xSrc,ySrc),MAKELONG(cxSrc,cySrc)));

#ifndef WINNT_VER40
  // Verify this is an 8bpp shrink or stretch
  //     or its a 16bpp stretch
  ASSERT((1 == nBytesPixel) || (cxSrc <= cxDst));

  DBG_MESSAGE((" RGBResizeBOF64 - Dst %08lXh,%08lXh  %08lX,%08lX",xDst,yDst,cxDst,cyDst));
  DBG_MESSAGE(("                  Src %08lXh,%08lXh  %08lX,%08lX",xSrc,ySrc,cxSrc,cySrc));
#endif

  // initialize auto blt struct
  bltr.DRAWBLTDEF.DW  = MAKELONG(ROP_OP1_copy, (BD_RES+BD_OP1)*IS_VRAM);

  bltr.OP0_opRDRAM.DW = MAKELONG(LOWORD(xDst),LOWORD(yDst));
  bltr.OP1_opRDRAM.DW = MAKELONG(LOWORD(xSrc),LOWORD(ySrc));
  bltr.BLTEXT.DW      = MAKELONG(LOWORD(cxDst),LOWORD(cyDst));

  bltr.LNCNTL.W       = lncntl[nBytesPixel-1] << LN_YUV_SHIFT;

  bltr.SRCX           = cxSrc * nBytesPixel;

  // Enable interpolation unless we have a palette (8bpp)
  if (1 < nBytesPixel)
    bltr.LNCNTL.W |= (LN_XINTP_EN | LN_YINTP_EN);

  bltr.SHRINKINC.W = 0x0000;

  if (cxDst < cxSrc)
  {
    bltr.LNCNTL.W |= LN_XSHRINK;
    bltr.LNCNTL.W &= ~LN_XINTP_EN;
    bltr.SHRINKINC.pt.X = (cxSrc / cxDst);
  }

  if ( cyDst < cySrc )
  {
    bltr.LNCNTL.W |= LN_YSHRINK;
    bltr.LNCNTL.W &= ~LN_YINTP_EN;
    bltr.SHRINKINC.pt.Y = (cySrc / cyDst);
  }

  // Compute DDA terms.

  nDst[0] = cxDst;
  nDst[1] = cyDst;
  nSrc[0] = cxSrc;
  nSrc[1] = cySrc;

  for (i = 0; i < 2; i++)
  {
    int kDst = 1;

    if (bltr.LNCNTL.W & ((i==0) ? LN_XINTP_EN : LN_YINTP_EN))
    {
      nDst[i] *= 4;
      nSrc[i] *= 4;
      nSrc[i] -= 3;

      kDst = 0x8000 / nDst[i];
    }

    if (bltr.LNCNTL.W & ((i==0) ? LN_XSHRINK : LN_YSHRINK))
    { /* Shrink Terms */
      axis[i].maj   =  (DDAX)nDst[i];
      axis[i].min   = - (nSrc[i] % nDst[i]);
      axis[i].accum = axis[i].maj - 1
                      - ((nSrc[i] % nDst[i]) / (nSrc[i]/nDst[i] + 1));
    }
    else
    { /* Stretch Terms */
      axis[i].maj   =  kDst * nDst[i];
      axis[i].min   = -kDst * nSrc[i];
      axis[i].accum = axis[i].maj - 1
                      - ((axis[i].maj % -axis[i].min) / (nDst[i]/nSrc[i] + 1));
    }
  }

  bltr.MAJ_X   = axis[0].maj;
  bltr.MIN_X   = axis[0].min;
  bltr.ACCUM_X = axis[0].accum;

  bltr.MAJ_Y   = axis[1].maj;
  bltr.MIN_Y   = axis[1].min;
  bltr.ACCUM_Y = axis[1].accum;

  // write settings that don't vary over stripes to the chip
  CALL_DRV_STR_BLTY(&bltr);

  if (bltr.LNCNTL.W & LN_XSHRINK)
  {
    // 8bpp shrink in X
    accx = bltr.ACCUM_X;

    while (cxDst > 0)
    {
      // walk DDA to determine number of src & dst pixels to blt in
      // current stripe
      // computes error term (accx) for next stripe also
      srcxext = 0;
      dstxext = 0;
      for (;;)
      {
        // check for worst case srcxext larger than num pixels that
        // fit in sram
        if ((srcxext + bltr.SHRINKINC.pt.X + 1) > nSRAMPixels)
          break;

        accx += bltr.MIN_X;
        srcxext += bltr.SHRINKINC.pt.X;
        if (0 > accx)
        {
          accx += bltr.MAJ_X;
          srcxext++;
        }

        dstxext++;
        if (dstxext >= cxDst)
          break;
      }

      // adjust dst extent
      bltr.BLTEXT.pt.X = (USHORT)dstxext;

      // blt current stripe
      CALL_DRV_STR_BLTX(&bltr);

      // adjust dst extent remaining
      cxDst -= dstxext;

      // update auto blt struct settings
      // increment xDst & xSrc
      // store error term for next stripe
      bltr.OP0_opRDRAM.pt.X += (USHORT)dstxext;
      bltr.OP1_opRDRAM.pt.X += (USHORT)srcxext;
      bltr.ACCUM_X          = accx;
    }
  }
  else
  {
    // stretch in X

    // set values for initial stripe
    xext = ((xDst + nSRAMPixels) & (~nSRAMMask)) - xDst;
    accx = bltr.ACCUM_X;
    srcx = xSrc;

    while (cxDst > xext)
    {
      // update auto blt struct settings
      bltr.OP0_opRDRAM.pt.X = (USHORT)xDst;
      bltr.OP1_opRDRAM.pt.X = (USHORT)srcx;
      bltr.ACCUM_X          = accx;
      bltr.BLTEXT.pt.X      = (USHORT)xext;

      // blt current stripe
      CALL_DRV_STR_BLTX(&bltr);

      // increment xDst and decrement remaining dst extent
      xDst  += xext;
      cxDst -= xext;

      // walk DDA to compute error term (accx) and xSrc for next stripe
      for (i = 0; i < xext; i++)
      {
        accx += bltr.MIN_X;
        if (0 > accx)
        {
          accx += bltr.MAJ_X;
          srcx++;
        }
      }
      // set dst ext of current stripe
      xext = nSRAMPixels;
    }

    // if there's some area left to blt, then do it
    if (0 < cxDst)
    {
      // update auto blt struct settings
      bltr.OP0_opRDRAM.pt.X = (USHORT)xDst;
      bltr.OP1_opRDRAM.pt.X = (USHORT)srcx;
      bltr.ACCUM_X          = accx;
      bltr.BLTEXT.pt.X      = (USHORT)cxDst;

      // blt final stripe
      CALL_DRV_STR_BLTX(&bltr);
    }
  }
}

/***************************************************************************
*
* FUNCTION:     RGB16ShrinkBOF64
*
* DESCRIPTION:  Handles 16bpp RGB shrinks on the 5464
*
****************************************************************************/

#define ENABLE_INTERPOLATED_BLTS    1

void RGB_16SHRINKBOF64
#ifndef WINNT_VER40
        LPGLOBALDATA lpDDHALData,
#endif
         int xDst, int yDst, int cxDst, int cyDst,
         int xSrc, int ySrc, int cxSrc, int cySrc )
{
  const int nBytesPixel = BYTESPERPIXEL;
  const int nSRAMPixels = (SRAM_SIZE / nBytesPixel) / 2;
  const int nSRAMMask   = nSRAMPixels - 1;

  autoblt_regs  SrcToScratch;
  autoblt_regs  ScratchToDst;

  int   xScratch, yScratch;
  int   cxScratch, cyScratch;

  AXIS  axis[2];
  int   nDst[2];
  int   nSrc[2];
  int   i;

  DDAX  accx;
  int   srcx;
  int   xext;

  int   nSRAMext;
  int   cxTemp;
  int   xTemp;


  DD_LOG(("RGB16ResizeBOF64 - 16 bpp shrink in X\r\n"));
  DD_LOG(("dst=%08lX dstext=%08lX src=%08lX srcext=%08lX\r\n",
          MAKELONG(xDst,yDst),MAKELONG(cxDst,cyDst),
          MAKELONG(xSrc,ySrc),MAKELONG(cxSrc,cySrc)));

#ifndef WINNT_VER40
  // Verify this is a 16bpp shrink!
  ASSERT(cxSrc > cxDst);
  ASSERT(nBytesPixel == 2);

  DBG_WARNING((" RGB16ShrinkBOF64 - Dst %08lXh,%08lXh  %08lX,%08lX",xDst,yDst,cxDst,cyDst));
  DBG_WARNING(("                    Src %08lXh,%08lXh  %08lX,%08lX",xSrc,ySrc,cxSrc,cySrc));
#endif

  xScratch = LOWORD(lpDDHALData->ScratchBufferOrg);
  yScratch = HIWORD(lpDDHALData->ScratchBufferOrg);
  cyScratch = cyDst;

  // initialize auto blt struct for src to scratch buffer
  SrcToScratch.DRAWBLTDEF.DW  = MAKELONG(ROP_OP1_copy, (BD_RES+BD_OP1)*IS_VRAM);

  SrcToScratch.OP0_opRDRAM.DW = MAKELONG(LOWORD(xScratch),LOWORD(yScratch));
  SrcToScratch.OP1_opRDRAM.DW = MAKELONG(LOWORD(xSrc),LOWORD(ySrc));

  SrcToScratch.LNCNTL.W       = lncntl[nBytesPixel-1] << LN_YUV_SHIFT;

  SrcToScratch.SRCX           = cxSrc * nBytesPixel;

#if ENABLE_INTERPOLATED_BLTS
  // Enable interpolation unless we have a palette (8bpp)
  if (1 < nBytesPixel)
    SrcToScratch.LNCNTL.W |= (LN_XINTP_EN | LN_YINTP_EN);
#endif

  SrcToScratch.SHRINKINC.W = 0x0000;

  // THIS IS A SHRINK IN X!
  cxScratch = cxSrc & ~1;
  nSRAMext = 0x38;
  while (cxScratch > cxDst)
  {
    cxScratch >>= 1;
    nSRAMext >>= 1;
  }
  /* Check for zero extent blt */
  if (nSRAMext == 0)
    return;

  SrcToScratch.BLTEXT.DW      = MAKELONG(LOWORD(cxScratch),1);
  // Yes, the following line doesn't make any sense but using
  // half the dest x ext on a 16bpp rgb shrink to compute the
  // minor, major and initial accumulator terms appears to get
  // the hw to work correctly
  cxScratch /= 2;

  SrcToScratch.LNCNTL.W |= LN_XSHRINK;
#if ENABLE_INTERPOLATED_BLTS
  SrcToScratch.LNCNTL.W &= ~LN_XINTP_EN;
#endif
  SrcToScratch.SHRINKINC.pt.X = (cxSrc / cxScratch);

  if ( cyDst < cySrc )
  {
    SrcToScratch.LNCNTL.W |= LN_YSHRINK;
#if ENABLE_INTERPOLATED_BLTS
    SrcToScratch.LNCNTL.W &= ~LN_YINTP_EN;
#endif
    SrcToScratch.SHRINKINC.pt.Y = (cySrc / cyScratch);
  }

  // Compute DDA terms

  nDst[0] = cxScratch;
  nDst[1] = cyScratch;
  nSrc[0] = cxSrc;
  nSrc[1] = cySrc;

  for (i = 0; i < 2; i++)
  {
    int kDst = 1;

#if ENABLE_INTERPOLATED_BLTS
    if (SrcToScratch.LNCNTL.W & ((i==0) ? LN_XINTP_EN : LN_YINTP_EN))
    {
      nDst[i] *= 4;
      nSrc[i] *= 4;
      nSrc[i] -= 3;

      kDst = 0x8000 / nDst[i];
    }
#endif

    if (SrcToScratch.LNCNTL.W & ((i==0) ? LN_XSHRINK : LN_YSHRINK))
    { /* Shrink Terms */
      axis[i].maj   =  (short)nDst[i];
      axis[i].min   = - (nSrc[i] % nDst[i]);
      axis[i].accum = axis[i].maj - 1
                      - ((nSrc[i] % nDst[i]) / (nSrc[i]/nDst[i] + 1));
    }
    else
    { /* Stretch Terms */
      axis[i].maj   =  kDst * nDst[i];
      axis[i].min   = -kDst * nSrc[i];
      axis[i].accum = axis[i].maj - 1
                      - ((axis[i].maj % -axis[i].min) / (nDst[i]/nSrc[i] + 1));
    }
  }

  SrcToScratch.MAJ_X   = axis[0].maj;
  SrcToScratch.MIN_X   = axis[0].min;
  SrcToScratch.ACCUM_X = axis[0].accum;

  SrcToScratch.MAJ_Y   = axis[1].maj;
  SrcToScratch.MIN_Y   = axis[1].min;
  SrcToScratch.ACCUM_Y = axis[1].accum;

  // Now that we have the major, minor and initial accumulator terms
  // computed, adjust dest x ext back to full width so we do the full
  // width of the blt below
  cxScratch *= 2;



  // initialize auto blt struct for scratch buffer to dst
  ScratchToDst.DRAWBLTDEF.DW  = MAKELONG(ROP_OP1_copy, (BD_RES+BD_OP1)*IS_VRAM);

  ScratchToDst.OP0_opRDRAM.DW = MAKELONG(LOWORD(xDst),LOWORD(yDst));
  ScratchToDst.OP1_opRDRAM.DW = MAKELONG(LOWORD(xScratch),LOWORD(yScratch));
  ScratchToDst.BLTEXT.DW      = MAKELONG(LOWORD(cxDst),1);

  ScratchToDst.LNCNTL.W       = lncntl[nBytesPixel-1] << LN_YUV_SHIFT;

  ScratchToDst.SRCX           = cxScratch * nBytesPixel;

#if ENABLE_INTERPOLATED_BLTS
  // Enable interpolation unless we have a palette (8bpp)
  if (1 < nBytesPixel)
    ScratchToDst.LNCNTL.W |= (LN_XINTP_EN | LN_YINTP_EN);
#endif

  ScratchToDst.SHRINKINC.W = 0x0000;

  // THIS IS A STRETCH IN X!

  // THIS IS 1:1 IN Y

  // Compute DDA terms

  nDst[0] = cxDst;
  nDst[1] = cyDst;
  nSrc[0] = cxScratch;
  nSrc[1] = cyScratch;

  for (i = 0; i < 2; i++)
  {
    int kDst = 1;

#if ENABLE_INTERPOLATED_BLTS
    if (ScratchToDst.LNCNTL.W & ((i==0) ? LN_XINTP_EN : LN_YINTP_EN))
    {
      nDst[i] *= 4;
      nSrc[i] *= 4;
      nSrc[i] -= 3;

      kDst = 0x8000 / nDst[i];
    }
#endif

    if (ScratchToDst.LNCNTL.W & ((i==0) ? LN_XSHRINK : LN_YSHRINK))
    { /* Shrink Terms */
      axis[i].maj   =  (short)nDst[i];
      axis[i].min   = - (nSrc[i] % nDst[i]);
      axis[i].accum = axis[i].maj - 1
                      - ((nSrc[i] % nDst[i]) / (nSrc[i]/nDst[i] + 1));
    }
    else
    { /* Stretch Terms */
      axis[i].maj   =  kDst * nDst[i];
      axis[i].min   = -kDst * nSrc[i];
      axis[i].accum = axis[i].maj - 1
                      - ((axis[i].maj % -axis[i].min) / (nDst[i]/nSrc[i] + 1));
    }
  }

  ScratchToDst.MAJ_X   = axis[0].maj;
  ScratchToDst.MIN_X   = axis[0].min;
  ScratchToDst.ACCUM_X = axis[0].accum;

  ScratchToDst.MAJ_Y   = axis[1].maj;
  ScratchToDst.MIN_Y   = axis[1].min;
  ScratchToDst.ACCUM_Y = axis[1].accum;


  // loop over scanlines in dst
  // do two blts for each, one from src to scratch buffer
  //   then one from scratch buffer to dst
  while (0 < cyDst)
  {
    // blt one scanline high from src to scratch buffer

    // set values for initial stripe
    xext = nSRAMext;
    accx = SrcToScratch.ACCUM_X;
    srcx = xSrc;

    // write settings that don't vary over stripes to the chip
    CALL_DRV_STR_BLTY(&SrcToScratch);

    cxTemp = cxScratch;
    xTemp = xScratch;

    while (cxTemp > xext)
    {
      // update auto blt struct settings
      SrcToScratch.OP0_opRDRAM.pt.X = (USHORT)xTemp;
      SrcToScratch.OP1_opRDRAM.pt.X = (USHORT)srcx;
      SrcToScratch.BLTEXT.pt.X      = (USHORT)xext;

      // blt current stripe
      CALL_DRV_STR_BLTX(&SrcToScratch);

      // increment xDst and decrement remaining dst extent
      xTemp  += xext;
      cxTemp -= xext;

      // walk DDA to compute error term (accx) and xSrc for next stripe
      for (i = 0; i < xext; i++)
      {
        SrcToScratch.ACCUM_X += SrcToScratch.MIN_X;
        // Even though the following line should be correct
        // the hw doesn't work correctly so we'll skip it
        // here and adjust srcx after the for loop
        //srcx += SrcToScratch.SHRINKINC.pt.X;
        if (0 > (short)SrcToScratch.ACCUM_X)
        {
          SrcToScratch.ACCUM_X += SrcToScratch.MAJ_X;
          srcx++;
        }
      }
      // now adjust srcx with a bizarre equation that appears to get
      // the hw to work correctly
      srcx += ((nSRAMext / 2) * SrcToScratch.SHRINKINC.pt.X);
    }
    // if there's some area left to blt, then do it
    if (0 < cxTemp)
    {
      // update auto blt struct settings
      SrcToScratch.OP0_opRDRAM.pt.X = (USHORT)xTemp;
      SrcToScratch.OP1_opRDRAM.pt.X = (USHORT)srcx;
      SrcToScratch.BLTEXT.pt.X      = (USHORT)cxTemp;

      // blt final stripe
      CALL_DRV_STR_BLTX(&SrcToScratch);
    }
    // reset ACCUM_X for beginning of next scanline
    SrcToScratch.ACCUM_X = accx;

    // walk Y DDA for src to scratch buffer blt
    SrcToScratch.ACCUM_Y += SrcToScratch.MIN_Y;
    SrcToScratch.OP1_opRDRAM.pt.Y += SrcToScratch.SHRINKINC.pt.Y;
    if (0 > (short)SrcToScratch.ACCUM_Y)
    {
      SrcToScratch.ACCUM_Y += SrcToScratch.MAJ_Y;
      SrcToScratch.OP1_opRDRAM.pt.Y++;
    }


    // blt from scratch buffer to dst
    // stretch in X, 1:1 in Y

    // set values for initial stripe
    xext = ((xDst + nSRAMPixels) & (~nSRAMMask)) - xDst;
    accx = ScratchToDst.ACCUM_X;
    srcx = xScratch;

    // write settings that don't vary over stripes to the chip
    CALL_DRV_STR_BLTY(&ScratchToDst);

    xTemp  = xDst;
    cxTemp = cxDst;

    while (cxTemp > xext)
    {
      // update auto blt struct settings
      ScratchToDst.OP0_opRDRAM.pt.X = (USHORT)xTemp;
      ScratchToDst.OP1_opRDRAM.pt.X = (USHORT)srcx;
      ScratchToDst.BLTEXT.pt.X      = (USHORT)xext;

      // blt current stripe
      CALL_DRV_STR_BLTX(&ScratchToDst);

      // increment xDst and decrement remaining dst extent
      xTemp  += xext;
      cxTemp -= xext;

      // walk DDA to compute error term (accx) and xSrc for next stripe
      for (i = 0; i < xext; i++)
      {
        ScratchToDst.ACCUM_X += ScratchToDst.MIN_X;
        if (0 > (short)ScratchToDst.ACCUM_X)
        {
          ScratchToDst.ACCUM_X += ScratchToDst.MAJ_X;
          srcx++;
        }
      }
      // set dst ext of current stripe
      xext = nSRAMPixels;
    }

    // if there's some area left to blt, then do it
    if (0 < cxTemp)
    {
      // update auto blt struct settings
      ScratchToDst.OP0_opRDRAM.pt.X = (USHORT)xTemp;
      ScratchToDst.OP1_opRDRAM.pt.X = (USHORT)srcx;
      ScratchToDst.BLTEXT.pt.X      = (USHORT)cxTemp;

      // blt final stripe
      CALL_DRV_STR_BLTX(&ScratchToDst);
    }
    // reset ACCUM_X for beginning of next scanline
    ScratchToDst.ACCUM_X = accx;

    // adjust dst ptr and dst extent
    ScratchToDst.OP0_opRDRAM.pt.Y++;
    cyDst--;
  }
}

/****************************************************************************
* FUNCTION NAME: DdGetBltStatus (NT)
*                GetBltStatus32 (Win95)
*
* DESCRIPTION:   Doesn't currently really care what surface is specified,
*                just checks and goes.
****************************************************************************/
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

DWORD DdGetBltStatus(PDD_GETBLTSTATUSDATA lpGetBltStatus)
{
  DRIVERDATA* lpDDHALData;
  PDEV*   ppdev;
  HRESULT ddRVal;

  DISPDBG((DBGLVL, "DDraw - DdGetBltStatus\n"));

  ppdev = (PDEV*) lpGetBltStatus->lpDD->dhpdev;
  lpDDHALData = (DRIVERDATA*) &ppdev->DriverData;

#else   // ----- #elseif WINNT_VER40 -----

DWORD __stdcall GetBltStatus32( LPDDHAL_GETBLTSTATUSDATA lpGetBltStatus)
{
  LPGLOBALDATA lpDDHALData = GetDDHALContext( lpGetBltStatus->lpDD);
  HRESULT ddRVal;
#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>


  DD_LOG(("GetBltStatus32 Entry\r\n"));

#ifndef WINNT_VER40
  SyncWithQueueManager(lpDDHALData);
#endif

#ifdef WINNT_VER40
  SYNC_W_3D(ppdev);   // if 3D context(s) active, make sure 3D engine idle before continuing...
#endif

  // DDGBS_CANBLT: can we add a blt?
  ddRVal = DD_OK;
  if (lpGetBltStatus->dwFlags == DDGBS_CANBLT)
  {
    // is a flip in progress?
#ifdef WINNT_VER40
    ddRVal = vUpdateFlipStatus(
        &ppdev->flipRecord,
        lpGetBltStatus->lpDDSurface->lpGbl->fpVidMem);
#else
#if defined(DDRAW_COMPAT_10)
    ddRVal = pfnUpdateFlipStatus(
        lpGetBltStatus->lpDDSurface->lpData->fpVidMem,
        lpDDHALData);
#else
    ddRVal = pfnUpdateFlipStatus(
        lpGetBltStatus->lpDDSurface->lpGbl->fpVidMem,
        lpDDHALData);
#endif
#endif

     if (ddRVal == DD_OK)
     {
        // so there was no flip going on, is there room in the fifo
        // to add a blt?
        if (!CALL_ENOUGH_FIFO_FOR_BLT)
           ddRVal = DDERR_WASSTILLDRAWING;
        else
           ddRVal = DD_OK;
     };
  }
  else
  {
     // DDGBS_ISBLTDONE case: is a blt in progress?
    if (DRAW_ENGINE_BUSY)

       ddRVal = DDERR_WASSTILLDRAWING;
    else
       ddRVal = DD_OK;
  };

  lpGetBltStatus->ddRVal = ddRVal;

  DD_LOG(("GetBltStatus32 Exit\r\n"));

  return(DDHAL_DRIVER_HANDLED);

} // DDGetBltStatus or GetBltStatus32

/***************************************************************************
*
* FUNCTION:     DrvStretch64
*
* DESCRIPTION:
*
****************************************************************************/

void DRVSTRETCH64
#ifndef WINNT_VER40
       LPGLOBALDATA lpDDHALData,
#endif
       int xDst, int yDst, int cxDst, int cyDst,
       int xSrc, int ySrc, int cxSrc, int cySrc,
       int nBytesPixel, int SrcType, int BaseOffset,
       int OnScreen)
{
  int   cxClip = cxDst;
  int   cyClip = cyDst;
  int   cxFill = 0;
  int   cyFill = cyDst;
  int   xFill  = xDst;
  int   yFill  = yDst;
  int   cxTrim = 0;
  int   iratio, i;

#ifdef RDRAM_8BIT
  PVGAR pREG = (PVGAR) lpDDHALData->RegsAddress;
#endif

  autoblt_regs bltr;

  AXIS axis[2];
  int  nDst[2];
  int  nSrc[2];

#ifdef RDRAM_8BIT
  RECTL   SrcRectl;
  int     nFound = FALSE;
#endif

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

  DISPDBG((DBGLVL3, "DDraw - DrvStretch64 xD=%x, yD=%x, cxD=%x, cyD=%x, xS=%x, yS=%x, cxS=%x, cyS=%x, bpp=%x, t=%x, bo=%x, scn=%x\n",
           xDst, yDst, cxDst, cyDst,
           xSrc, ySrc, cxSrc, cySrc,
           nBytesPixel, SrcType, BaseOffset, OnScreen));

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

  DD_LOG(("DrvStretch64 - dst=%08lX dstext=%08lX src=%08lX srcext=%08lX\r\n",
          MAKELONG(xDst,yDst),MAKELONG(cxDst,cyDst),
          MAKELONG(xSrc,ySrc),MAKELONG(cxSrc,cySrc)));

#ifdef RDRAM_8BIT
  if (!lpDDHALData->fNineBitRDRAMS)
  {
     if (SrcType == LN_YUV422)
     {
        SrcRectl.left   = xSrc;
        SrcRectl.top    = ySrc;
        SrcRectl.right  = xSrc+cxSrc;
        SrcRectl.bottom = ySrc+cySrc;
        if (MEMCMP(&SrcRectl, sizeof(SrcRectl)) == 0)
           nFound = TRUE;

        if (nFound)
        {
#if 0
        DBG_MESSAGE(("Stretch: Found Offscreen Area P1(%x,%x) P2(%x,%x) Dst(%x, %x) Dst(%x %x)\n",
                     SrcRectl.left,
                     SrcRectl.top,
                     SrcRectl.right,
                     SrcRectl.bottom,
                     xDst,
                     yDst,
                     xDst+cxDst,
                     yDst+cyDst));
#endif

           LL16(grX_Start_2, xDst + ((4 - (xDst & 3)) & 3));
           LL16(grY_Start_2, yDst);
           LL16(grX_End_2, xDst+(cxDst>>3<<3));
           LL16(grY_End_2, yDst+cyDst);
        }
        else
        {
#if 0
        DBG_MESSAGE(("Stretch: Not Found Offscreen Area P1(%x,%x) P2(%x,%x)\n",
                     SrcRectl.left,
                     SrcRectl.top,
                     SrcRectl.right,
                     SrcRectl.bottom));
#endif

           LL16(grX_Start_2, 0);
           LL16(grY_Start_2, 0);
           LL16(grX_End_2, 0);
           LL16(grY_End_2, 0);

           // Black Blit Here
           CALL_DRV_DST_BLT(0x107000CC,MAKELONG(xDst,yDst),0,MAKELONG(cxDst,cyDst));
           return ;
        }
     }  // endif (SrcType == LN_YUV422)
  }  // endif (!lpDDHALData->fNineBitRDRAMS)
#endif

#ifdef TRACE_STRETCH
  DBG_MESSAGE(("DrvStretch64: %4d,%4d %4dx%4d -> %4d,%4d %4dx%4d (%d %d) %d",
               xSrc, ySrc, cxSrc, cySrc,
               xDst, yDst, cxDst, cyDst,
               nBytesPixel, SrcType, BaseOffset));
#endif

  if ((SrcType == LN_YUV422) ||
     ((SrcType == LN_RGB565) && (nBytesPixel == 1)))
  { // Force alignment of output to QWORD ( it is documented as DWORD but broken)

    if (nBytesPixel == 2)
    {  // 16 bit frame buffer ( Note all ptrs/extents in terms of 16 bpp )
       // The X portions will be mutiplied by 2 by chip on being written )

       if (cxDst > cxSrc)
          iratio = cxDst / cxSrc; // integer ratio of stretch
       else
          iratio = cxSrc / cxDst; // integer ratio of shrink

       if (xDst & 3)   // This should be for LN_YUV422 only
       {
          cxFill = 4 - (xDst & 3);
          cxTrim = cxFill;   // save trim count for source clipping if required

          if ( cxFill > cxClip )
             cxFill = cxClip;  // check for no stretch left

           cxClip -= cxFill;  // reduce size
           cxDst  -= cxFill;  // reduce size
           xDst   += cxFill;  // force alignment to next even DWORD boundary

           CALL_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                              MAKELONG(BOGUS_YUV, BOGUS_YUV),
                              FALSE);
       }  // endif (xDst & 3)

       cxFill  = cxClip & 3;
       if (OnScreen && cxFill )
       {
          cxClip -= cxFill;   // force size to next smaller even DWORD count
          xFill   = xDst + cxClip;
          if ( cxClip >= cxSrc)
          {  // If shrink defer edge fill to later as there may be more
             CALL_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                                MAKELONG(BOGUS_YUV, BOGUS_YUV), FALSE);
          }
       }  // endif ( cxFill )

       if ( (cxClip < cxSrc) )
       {  // Edge Clip on shrinks only ( add config flag check here )

          // extra pixels to discard above integer ratio
          int excess = (cxSrc / iratio) - cxClip;

#ifdef TRACE_STRETCH
         DBG_MESSAGE((" Edge Clip iratio = %d excess = %d Trim %% = %d", iratio, excess, lpDDHALData->EdgeTrim));
#endif

          if ( excess && cxTrim )
          {  // These excess pixels are caused by our Dest alignment
             // problems on the Left edge
             if ( excess < (cxTrim * iratio) )
             {
                cxSrc  -= excess;
                xSrc   += excess;
                excess  = 0;
             }
             else
             {
                cxSrc  -= cxTrim * iratio;
                xSrc   += cxTrim * iratio;
                excess -= cxTrim * iratio;
             }
          }  // endif ( (cxClip < cxSrc) )

         if ( excess && cxFill)
         {  // These excess pixels are caused by our Dest alignment
            // problems on the Right edge

            if ( excess < (cxFill * iratio) )
            {
               cxSrc  -= excess;
               excess  = 0;
            }
            else
            {
               cxSrc  -= cxFill * iratio;
               excess -= cxFill * iratio;
            }
         }  // endif ( excess && cxFill)

         if ( excess && (excess <= (lpDDHALData->EdgeTrim * cxSrc)/100 ))
         {  // if excess is less than % of frame trim edges
            int trim  = excess / 2; // half the excess of pixels
            xSrc     +=  trim;      // offset pixel pointer
            cxSrc    -= excess;     // all the excess in pixels

#ifdef TRACE_STRETCH
            DBG_MESSAGE((" Edge Clip Left = %d, xSrc = %d, cxSrc = %d", trim, xSrc, cxSrc));
#endif
         }

         if ( iratio == 1 )
         {  // we may have just changed a shrink to a 1 : 1
            // if excess is zero do edge fill now

            // extra pixels to discard above integer ratio
            excess = ( cxSrc / iratio ) - cxClip;

            if ( !excess && cxFill )
            {
               xFill = xDst + cxClip;
               CALL_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                                  MAKELONG(BOGUS_YUV, BOGUS_YUV), FALSE);
            }
         }  // endif ( iratio == 1 )
       }
       else
       { // Stretch adjustments
         if ( xSrc - BaseOffset )
         {  // if we are not starting from left edge of source image

            if ( cxTrim )
            {  // And we were forced to offset for left edge alignment

#ifdef TRACE_STRETCH
          DBG_MESSAGE((" Edge Trim for stretch iratio = %d , cxTrim = %d xSrc %d", iratio, cxTrim, xSrc));
#endif
               cxSrc -= cxTrim / iratio;
               xSrc  += cxTrim / iratio;
            }
         }
       }  // endif ( (cxClip < cxSrc) )

       // Global adjustments
       if ( xSrc & 1 )   // HW bug workaound for clipping
       {
          xSrc  += 1;    // Align to SRC DWORD Boundary
          cxSrc -= 1;    // Account for smaller size
       }
    }
    else
    {  // 8 Bit frame buffer.
       // Force alignment of output to QWORD ( it is documented as DWORD but broken)

       if ( cxDst >= (cxSrc*2) )
          iratio = cxDst / (2 * cxSrc); // integer ratio of stretch
       else
          iratio = (2 * cxSrc ) / cxDst;  // integer ratio of shrink

       if ( xDst & 7 )   /* This should be for LN_YUV422 only */
       {
          cxFill = 8 - (xDst & 7);

          if ( cxFill > cxClip )
             cxFill   = cxClip;  // check for no stretch left

          cxClip -= cxFill;  // reduce size
          cxDst  -= cxFill;  // reduce size
          xDst   += cxFill;  // force alignment to next even WORD boundary

          CALL_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                             0x00000000, FALSE);
       }  // endif ( xDst & 7 )

      cxFill  = cxClip & 7;

      if (OnScreen && cxFill )
      {
         cxClip -= cxFill;    /* force size to next smaller even DWORD count */

         if ( cxClip >= (cxSrc * 2))
         {  // If shrink defer edge fill to later as there may be more
            xFill = xDst + cxClip;
            CALL_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                               0x00000000, FALSE);
         }
      }  // endif ( cxFill )

      // change pixel pointer to byte pointer
      // taking account of X origin of buffer
      xSrc = BaseOffset + (xSrc - BaseOffset) * 2;

      cxSrc *= 2;  // change pixel count to byte count

#ifdef EDGE_CLIP
      if ( (cxClip < cxSrc) && lpDDHALData->EdgeTrim)
      {  // Edge Clip on shrinks only ( add config flag check here )
         int excess;
         excess = ( cxSrc / iratio ) - cxClip; // extra pixels to discard
                                              // above integer ratio
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

         DISPDBG((DBGLVL1,
                 "DDraw - Edge Clip iratio = %d excess = %d Trim %% = %d",
                 iratio, excess, lpDDHALData->EdgeTrim));

#else   // ----- #elseif WINNT_VER40 -----

         DBG_MESSAGE((" Edge Clip iratio = %d excess = %d Trim %% = %d",
                     iratio, excess, lpDDHALData->EdgeTrim));

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

         if ( excess && cxTrim )
         {  // These excess pixels are caused by our Dest alignment
            // problems on the Left edge
            if ( excess < (cxTrim * iratio) )
            {
               cxSrc  -= excess;
               xSrc   += excess;
               excess  = 0;
            }
            else
            {
                cxSrc  -= cxTrim * iratio;
                xSrc   += cxTrim * iratio;
                excess -= cxTrim * iratio;
             }
         }  // endif ( excess && cxTrim )

         if ( excess && cxFill)
         {  // These excess pixels are caused by our Dest alignment
            //  problems on the Right edge

            if ( excess < (cxFill * iratio) )
            {
               cxSrc -= excess;
               excess = 0;
            }
            else
            {
               cxSrc -= cxFill * iratio;
               excess -= cxFill * iratio;
            }
         }  // endif ( excess && cxFill)

         if ( excess && ( excess <= (lpDDHALData->EdgeTrim * cxSrc)/100 ) )
         {  // if excess is less than specific % of frame trim edges
            int trim = excess / 2;  // half the excess as pixels
            xSrc +=  trim;          // offset pixel pointer
            cxSrc -= excess;        // all the excess in bytes

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

            DISPDBG((DBGLVL1,
                     "DDraw - Edge Clip Left = %d, xSrc = %d, cxSrc = %d",
                     trim, xSrc, cxSrc));

#else   // ----- #elseif WINNT_VER40 -----

          DBG_MESSAGE((" Edge Clip Left = %d, xSrc = %d, cxSrc = %d",
                       trim, xSrc, cxSrc));

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

         } // endif (excess && ( excess <= (lpDDHALData->EdgeTrim * cxSrc)/100))

         if ( iratio == 1 )
         {  // we may have just changed a shrink to a 1 : 1
            // if excess is no zero do edge fill now

            // extra pixels to discard above integer ratio
            excess = ( cxSrc / iratio ) - cxClip;

            if ( !excess && cxFill )
            {
               xFill = xDst + cxClip;
               CALL_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                                  0x00000000, FALSE);
            }
         }  // endif ( iratio == 1 )
      }  // endif ( (cxClip < cxSrc) && lpDDHALData->EdgeTrim)
#endif

      if ( xSrc & 3 )   /* HW bug workaound for clipping */
      {
         cxSrc -= 4 - (xSrc & 3);  /* reduce size */
         xSrc = (xSrc + 3) & ~ 3;    /* Align to SRC DWORD Boundary */
      }
    }  // endif (nBytesPixel == 2)
  }

  if ( cxClip == 0 )
     return;     // discard zero extent stretchs

  if (nBytesPixel == 1 && ((SrcType == LN_YUV422) || (SrcType == LN_RGB565))
     || ((nBytesPixel == 2) && (SrcType == LN_YUV422)))
  {
     CALL_DELAY_9BIT_BLT(FALSE);

     bltr.DRAWBLTDEF.DW   = MAKELONG(0x04CC, BD_RES | BD_OP1);
     lpDDHALData->YUVLeft = (USHORT)xDst;  // Save 9th bit rect coords for main
     lpDDHALData->YUVTop = (USHORT)yDst;   // driver for exclusion purposes.
     lpDDHALData->YUVXExt = (USHORT)cxClip;
     lpDDHALData->YUVYExt = (USHORT)cyClip;

     // tell main driver the rectangle is valid
     lpDDHALData->DrvSemaphore |= DRVSEM_YUV_RECT_VALID;
  }
  else
    bltr.DRAWBLTDEF.DW = MAKELONG(0x00CC, BD_RES | BD_OP1);

  bltr.OP0_opRDRAM.DW  = MAKELONG(xDst, yDst);
  bltr.OP1_opRDRAM.DW  = MAKELONG(xSrc, ySrc);

  bltr.BLTEXT.DW = MAKELONG(cxClip, cyClip);

  bltr.LNCNTL.W  = SrcType << LN_YUV_SHIFT;

  // Enable interpolation unless we have a palette (8bpp).
  if (SrcType != LN_8BIT )
     bltr.LNCNTL.W  |= LN_XINTP_EN | LN_YINTP_EN;

  bltr.SHRINKINC.w = 0x0000;

  if ( cxClip < cxSrc )
  {
     bltr.LNCNTL.W  |= LN_XSHRINK;
     bltr.LNCNTL.W  &= ~LN_XINTP_EN;   // Clear Average bit for ALL shrinks
     bltr.SHRINKINC.pt.X = (cxSrc / cxClip);
  }

  if ( cyDst < cySrc )
  {
     bltr.LNCNTL.W |= LN_YSHRINK;
     bltr.LNCNTL.W &= ~LN_YINTP_EN;
     bltr.SHRINKINC.pt.Y = (cySrc / cyDst);
  }

  if ( SrcType == LN_YUV422 || SrcType == LN_RGB565 )
  {
     if ( nBytesPixel == 1 )
        bltr.SRCX       = (USHORT)cxSrc;  // If mixed mode is *2 already
     else
        bltr.SRCX       = cxSrc * 2;
  }
  else
     bltr.SRCX       = cxSrc * nBytesPixel;

#ifdef TRACE_STRETCH
  DBG_MESSAGE((" cSrc = %d , %d : cDst = %d , %d : cClip = %d , %d",
               cxSrc, cySrc, cxDst, cyDst, cxClip, cyClip));
#endif

  // Compute DDA terms.
  nDst[0] = cxClip; nDst[1] = cyDst;
  nSrc[0] = cxSrc; nSrc[1] = cySrc;

  for (i = 0; i < 2; i++)
  {
    int kDst = 1;

    if (bltr.LNCNTL.W & ((i==0) ? LN_XINTP_EN : LN_YINTP_EN))
    {
       nDst[i] *= 4;
       nSrc[i] *= 4;
       nSrc[i] -= 3;

       kDst = 0x8000 / nDst[i];
    }

    if (bltr.LNCNTL.W & ((i==0) ? LN_XSHRINK : LN_YSHRINK))
    {  /* Shrink Terms */
       axis[i].maj =  (short)nDst[i];
       axis[i].min = - (nSrc[i] % nDst[i]);
       axis[i].accum = axis[i].maj - 1
                     - ((nSrc[i] % nDst[i]) / (nSrc[i]/nDst[i] + 1));
    }
    else
    {  /* Stretch Terms */
       axis[i].maj =  kDst * nDst[i];
       axis[i].min = -kDst * nSrc[i];
       axis[i].accum = axis[i].maj - 1
                     - ((axis[i].maj % -axis[i].min) / (nDst[i]/nSrc[i] + 1));
    }
  } // endfor

  bltr.MAJ_X   = axis[0].maj;
  bltr.MIN_X   = axis[0].min;
  bltr.ACCUM_X = axis[0].accum;

  bltr.MAJ_Y   = axis[1].maj;
  bltr.MIN_Y   = axis[1].min;
  bltr.ACCUM_Y = axis[1].accum;

  if ( ((SrcType == LN_8BIT) || (SrcType == LN_YUV422))
        && !(bltr.LNCNTL.W & LN_XSHRINK) )
  {
    // Put DDA parameter check/adjust (Optional for 5462/required for 5464)

    const  short maj_x = bltr.MAJ_X;
    const  short min_x = bltr.MIN_X;
    short  xaccum      = bltr.ACCUM_X;
    short  copy_xDst   = bltr.BLTEXT.pt.X;
    short  src_ext;
    short  inc_dx      = 1;
    short  inc_sx      = 0;
    short  SrcDstSz;

    SrcDstSz = ( SrcType == LN_8BIT ) ? 1 : 2 ;

    if ( (bltr.LNCNTL.W & LN_XSHRINK) )
       inc_sx = bltr.SHRINKINC.pt.X;

    inc_sx    *= SrcDstSz;
    inc_dx    *= SrcDstSz;
    copy_xDst *= (short)nBytesPixel;
    src_ext    = SrcDstSz;    // Source size starts with a pixel !!

    do
    { // Step through the X DDA accounting for src pixels consumed
      copy_xDst  -= inc_dx;
      src_ext    += inc_sx;
      xaccum     += min_x;
      if ( xaccum < 0 )
      {
        xaccum   += maj_x;
        src_ext  += SrcDstSz;
      }
    } while ( copy_xDst > 0 );

    bltr.SRCX  = src_ext;

    // End DDA parameter check / adjust.

    CALL_DRV_STR_BLT(&bltr);   // Single stretch

    if ( (SrcType == LN_YUV422) )
       CALL_DELAY_9BIT_BLT(TRUE);
  }
//  else if (SrcType == LN_RGB565 && !(bltr.LNCNTL.W & LN_XSHRINK))
  else if (SrcType == LN_RGB565)
  {
    // HWBUG !!! -- Break into sram-aligned vertical tiles
    // based on destination alignment
    // dword and tile masks

    const int mdwrd =   4 ;
    const int mtile_s = 128 - 1; // sram is 128 bytes
    int mtile_d = 128 - 1 ;      // 5464 Dest Workaround half tile size mask

    int endx  = xDst + cxClip;    // last x, exclusive
    int dstxe = endx & ~mtile_d;  // start of last tile

    int  accx = axis[0].accum;
    int  dstx = xDst;
    int  srcx = xSrc;
    int  src_ext = 0;
    int  sav_accx;
    int  sav_dstx;
    int  sav_srcx;
    int  sav_src_ext;
    int  copy_srcx;
    int  xext;
    int  inc_sx;

#ifndef WINNT_VER40
    ASSERT( BITSPERPIXEL != 24 ); // HWBUG !!!
#endif
    if (bltr.LNCNTL.W & LN_XSHRINK)
    {
       mtile_d = 128 - 1;
       dstxe   = endx & ~mtile_d;
    }

    if ( nBytesPixel == 2 )
    {
       cxSrc *= 2;   /* convert size to Bytes from pixels */
       cxDst *= 2;
       srcx = (xSrc *= 2);
       dstx = (xDst *= 2);
       bltr.OP0_opRDRAM.pt.X *= 2;
       bltr.OP1_opRDRAM.pt.X *= 2;
       endx *= 2;
       dstxe = endx & ~mtile_d;
    }

    if (LGDEVID == CL_GD5464)
    {
       bltr.SHRINKINC.pt.X *= 2;
       CALL_DRV_STR_MBLTY(&bltr);   // Load the invariant registers
       bltr.SHRINKINC.pt.X /= 2;
    }
    else
       CALL_DRV_STR_MBLTY(&bltr);   // Load the invariant registers

    copy_srcx  = bltr.SRCX;

    while (dstx < dstxe)
    {
      bltr.OP0_opRDRAM.PT.X   = (USHORT)dstx;
      bltr.OP1_opRDRAM.PT.X   = (USHORT)srcx;
      bltr.ACCUM_X            = (USHORT)accx;
      xext                    = 0;
      src_ext                 = 0;
      inc_sx                  = bltr.SHRINKINC.pt.X * 2;

      if ( bltr.LNCNTL.W & LN_XSHRINK )
      {  // We have to treat the stretch / shrink cases differently
         // because of the need to handle both SRC & DST aligned cases.
         do
         {
           dstx     += 2;
           xext     += 2;
           accx     += axis[0].min;
           srcx     += inc_sx;
           src_ext  += inc_sx;

           if ( !(srcx & mtile_s) )
              break;    // Try double striping !!

           if (accx < 0)
           {
              accx    += axis[0].maj;
              srcx    += 2;
              src_ext += 2;

              if ( !(srcx & mtile_s) )
                 break;    // Try double striping !!
           }
         } while ((dstx + 4 ) & mtile_d);

         sav_dstx = dstx;
         sav_accx = accx;
         sav_srcx = srcx;
         sav_src_ext = src_ext;

         do
         {
           dstx    += 2;
           xext    += 2;
           accx    += axis[0].min;
           srcx    += inc_sx;
           src_ext += inc_sx;

           if ( !(srcx & mtile_s) )
              break;    // Try double striping !!

           if (accx < 0)
           {
              accx    += axis[0].maj;
              srcx    += 2;
              src_ext += 2;

              if ( !(srcx & mtile_s) )
                 break;    // Try double striping !!
           }
         } while ((dstx) & mtile_d);

         bltr.SRCX  = (USHORT)src_ext;
      }
      else
      {
         do
         {
            dstx += 2;
            xext += 2;
            accx += axis[0].min;

            if (accx < 0)
            {
               accx     += axis[0].maj;
               srcx     += 2;
               src_ext  += 2;

               if ( !(srcx & mtile_s) )
                  break;    // Try double striping !!

            }
         } while (dstx & mtile_d);

         bltr.SRCX = src_ext + 2;
         sav_dstx = dstx;
         sav_accx = accx;
         sav_srcx = srcx;
         sav_src_ext = src_ext;
      }

      bltr.BLTEXT.PT.X = (USHORT)xext;

      CALL_DRV_STR_MBLTX(&bltr);

      dstx = sav_dstx;
      accx = sav_accx;
      srcx = sav_srcx;
      src_ext = sav_src_ext;
      copy_srcx -= src_ext;
    } // end while (dstx < dstxe)

    // do the last tile
    if (dstx < endx)
    {
       bltr.OP0_opRDRAM.PT.X  = (USHORT)dstx;
       bltr.OP1_opRDRAM.PT.X  = (USHORT)srcx;
       bltr.ACCUM_X            = (USHORT)accx;
       bltr.SRCX               = (USHORT)copy_srcx;
       bltr.BLTEXT.PT.X        = endx - dstx;

       CALL_DRV_STR_MBLTX(&bltr);
    }

    if ((SrcType == LN_YUV422) || (SrcType == LN_RGB565 && nBytesPixel == 1))
       CALL_DELAY_9BIT_BLT(TRUE);
  }
  else
  {
    // HWBUG !!! -- Break into sram-aligned vertical tiles
    // based on source alignment
    // tile mask
    const int mtile = 128; /* sram is 128 bytes */
    const int mtile_mask = mtile - 1;
    const short maj_x = bltr.MAJ_X;
    const short min_x = bltr.MIN_X;
    int endx  = xDst + cxClip;  // last x, exclusive, in pixels

    short  xaccum;
    int  dstx = xDst;
    int  srcx = xSrc;
    int  dst_ext;
    int  src_ext;
    int  copy_src_ext;

#ifndef WINNT_VER40
    ASSERT( BITSPERPIXEL != 24 ); // HWBUG !!!
#endif

    if ( nBytesPixel == 2 )
    {
       cxSrc *= 2;   /* convert size to Bytes from pixels */
       cxDst *= 2;
       srcx = (xSrc *= 2);
       dstx = (xDst *= 2);
       bltr.OP0_opRDRAM.pt.X *= 2;
       bltr.OP1_opRDRAM.pt.X *= 2;
       endx *= 2;    /* convert end marker to bytes */
    }

#ifdef TRACE_STRETCH
#ifdef TRACE_ALL
    DBG_MESSAGE((" mtile = %d  maj = %d min = %d accum = %d shrinkinc = %04x",
                 mtile, maj_x, min_x, bltr.ACCUM_X, bltr.SHRINKINC));
#endif
#endif

    if (LGDEVID == CL_GD5464 && SrcType != LN_8BIT)
    {
       bltr.SHRINKINC.pt.X *= 2;
       CALL_DRV_STR_MBLTY(&bltr);   // Load the invariant registers
       bltr.SHRINKINC.pt.X /= 2;
    }
    else
       CALL_DRV_STR_MBLTY(&bltr);   // Load the invariant registers

    do
    {
      // get alignment to first src tile / sram break;
      if ( srcx & mtile_mask ) // initial alignment
      {
        src_ext = mtile  - (srcx & mtile_mask);
        if ( src_ext > cxSrc )
          src_ext = cxSrc;
      }
      else
      {
        if ( cxSrc < mtile )
           src_ext = cxSrc; // last partial tile
        else
           src_ext = mtile; // complete tile
      }

      srcx += src_ext;    // account for amount of src consumed
      cxSrc -= src_ext;

      // calculate how many destination pixels == src_ext
      xaccum  = bltr.ACCUM_X;
      dst_ext = 0;
      copy_src_ext = src_ext;

      do
      {
        dst_ext += 2;
        copy_src_ext -= 2 * bltr.SHRINKINC.pt.X;
        xaccum += min_x;

        if ( xaccum < 0 )
        {
           xaccum += maj_x;
           copy_src_ext -= 2;
        }
      } while ( copy_src_ext > 0 && (dstx + dst_ext <= endx) );

      dst_ext &= ~3;    /* force destination extent to DWORDs */

      dstx += dst_ext;

#ifdef TRACE_STRETCH
#ifdef TRACE_ALL
      DBG_MESSAGE((" srcx = %d src_ext = %d cxSrc = %d dstx = %d dst_ext = %d end = %d",
                   srcx, src_ext, cxSrc, dstx, dst_ext, endx ));
#endif
#endif

      if ( SrcType == LN_RGB565 )
         bltr.SRCX           = src_ext + 2;
      else
         bltr.SRCX           = (USHORT)src_ext;

      bltr.BLTEXT.pt.X      = (USHORT)dst_ext;

      if ( dst_ext > 0 )
         CALL_DRV_STR_MBLTX(&bltr);

      bltr.ACCUM_X        = xaccum;
      bltr.OP0_opRDRAM.pt.X += (USHORT)dst_ext;
      bltr.OP1_opRDRAM.pt.X += (USHORT)src_ext;
    } while ( (dstx < endx) && ( cxSrc > 0));

    xFill = bltr.OP0_opRDRAM.pt.X;

    cxFill  = (xDst + cxDst) - xFill;

#ifdef TRACE_STRETCH
    DBG_MESSAGE((" srcx=%d src_ext=%d cxSrc=%d  dstx=%d dst_ext=%d end=%d xFill=%d cxFill=%d",
                 srcx, src_ext, cxSrc, dstx, dst_ext, endx, xFill, cxFill ));
#endif

    // Edge Fill for trailing edge was deferred. Calculate correct amount
    // Taking into account pixels skipped above for alignment.
    //
    if ((cxFill > 0) && (cxClip = (xFill & 7)) &&
       ((SrcType == LN_YUV422)||((nBytesPixel == 1) && (SrcType == LN_RGB565))))
    {  // these must be extra pixels.  They must be filled using
       //  the same 9th bit and in the same format as the stretch
       if ( SrcType == LN_YUV422  )
          CALL_MEDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                              MAKELONG(BOGUS_YUV, BOGUS_YUV), TRUE);
       else
          CALL_MEDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                              0x00000000, TRUE);

       xFill = bltr.OP0_opRDRAM.pt.X + cxClip;
       cxFill -= cxClip;
    }

    if ((SrcType == LN_YUV422) || (SrcType == LN_RGB565 && nBytesPixel == 1))
        CALL_DELAY_9BIT_BLT(TRUE);

    if ( cxFill > 0 )
    {
      /* perform edge fill Blt */
      if ( nBytesPixel == 2 )
         CALL_MEDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                             MAKELONG(BOGUS_YUV, BOGUS_YUV), FALSE);
     else
         CALL_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                            0x00000000, FALSE);
    }
  }
} // DrvStretch64

/***************************************************************************
*
* FUNCTION:     DrvStretch62
*
* DESCRIPTION:  The 5462 doesn't do display list programming, so
*               all blts must be direct (call the DIR_XXX functions)
*
****************************************************************************/

void DRVSTRETCH62
#ifndef WINNT_VER40
       LPGLOBALDATA lpDDHALData,
#endif
       int xDst, int yDst, int cxDst, int cyDst,
       int xSrc, int ySrc, int cxSrc, int cySrc,
       int nBytesPixel, int SrcType, int BaseOffset,
       int OnScreen)
{
  int   cxClip = cxDst;
  int   cyClip = cyDst;
  int   cxFill = 0;
  int   cyFill = cyDst;
  int   xFill  = xDst;
  int   yFill  = yDst;
  int   cxTrim = 0;
  int   iratio, i;
#ifdef RDRAM_8BIT
  PVGAR pREG = (PVGAR) lpDDHALData->RegsAddress;
#endif

  autoblt_regs bltr;

  AXIS axis[2];
  int  nDst[2];
  int  nSrc[2];

#ifdef RDRAM_8BIT
  RECTL   SrcRectl;
  int     nFound = FALSE;
#endif

  DD_LOG(("DrvStretch62 - dst=%08lX dstext=%08lX src=%08lX srcext=%08lX\r\n",
          MAKELONG(xDst,yDst),MAKELONG(cxDst,cyDst),
          MAKELONG(xSrc,ySrc),MAKELONG(cxSrc,cySrc)));

#ifdef RDRAM_8BIT
  if (!lpDDHALData->fNineBitRDRAMS)
  {
     if (SrcType == LN_YUV422)
     {
        SrcRectl.left   = xSrc;
        SrcRectl.top    = ySrc;
        SrcRectl.right  = xSrc+cxSrc;
        SrcRectl.bottom = ySrc+cySrc;

        if (MEMCMP(&SrcRectl, sizeof(SrcRectl)) == 0)
           nFound = TRUE;

        if (nFound)
        {
#if 0
        DBG_MESSAGE(("Stretch: Found Offscreen Area P1(%x,%x) P2(%x,%x) Dst(%x, %x) Dst(%x %x)\n",
                     SrcRectl.left,
                     SrcRectl.top,
                     SrcRectl.right,
                     SrcRectl.bottom,
                     xDst,
                     yDst,
                     xDst+cxDst,
                     yDst+cyDst));
#endif

           LL16(grX_Start_2, xDst + ((4 - (xDst & 3)) & 3));
           LL16(grY_Start_2, yDst);
           LL16(grX_End_2, xDst+(cxDst>>3<<3));
           LL16(grY_End_2, yDst+cyDst);
        }
        else
        {
#if 0
        DBG_MESSAGE(("Stretch: Not Found Offscreen Area P1(%x,%x) P2(%x,%x)\n",
                     SrcRectl.left,
                     SrcRectl.top,
                     SrcRectl.right,
                     SrcRectl.bottom));
#endif

           LL16(grX_Start_2, 0);
           LL16(grY_Start_2, 0);
           LL16(grX_End_2, 0);
           LL16(grY_End_2, 0);

           // Black Blit Here
           CALL_DIR_DRV_DST_BLT(0x107000CC,MAKELONG(xDst,yDst),0,MAKELONG(cxDst,cyDst));
           return ;
        }
     }  // endif (SrcType == LN_YUV422)
  }  // endif (!lpDDHALData->fNineBitRDRAMS)
#endif

#ifdef TRACE_STRETCH
  DBG_MESSAGE(("DrvStretch62: %4d,%4d %4dx%4d -> %4d,%4d %4dx%4d (%d %d) %d",
               xSrc, ySrc, cxSrc, cySrc,
               xDst, yDst, cxDst, cyDst,
               nBytesPixel, SrcType, BaseOffset));
#endif

  if ((SrcType == LN_YUV422) ||
      ((SrcType == LN_RGB565) && (nBytesPixel == 1)))
  { // Force alignment of output to QWORD ( it is documented as DWORD but broken)

    if ( nBytesPixel == 2 )
    {  // 16 bit frame buffer ( Note all ptrs/extents in terms of 16 bpp )
       // The X portions will be mutiplied by 2 by chip on being written )

       if ( cxDst > cxSrc )
          iratio = cxDst / cxSrc; // integer ratio of stretch
       else
          iratio = cxSrc / cxDst; // integer ratio of shrink

       if ( xDst & 3 )   /* This should be for LN_YUV422 only */
       {
          cxFill = 4 - (xDst & 3);
          cxTrim = cxFill;    // save trim count for source clipping if required

          if ( cxFill > cxClip )
            cxFill = cxClip;  // check for no stretch left

          cxClip -= cxFill;  /* reduce size */
          cxDst  -= cxFill;  /* reduce size */
          xDst   += cxFill;  /* force alignment to next even DWORD boundary */

          CALL_DIR_DRV_DST_BLT(MAKELONG(0x0000,BD_RES),MAKELONG(xFill,yFill),
                               0,MAKELONG(cxFill,cyFill));

#ifdef TRACE_STRETCH
        DBG_MESSAGE((" Edge Fill(1) %d,%d %d x %d", xFill, yFill, cxFill, cyFill));
#endif
      }  //endif ( xDst & 3 )

      cxFill  = cxClip & 3;

      if ( cxFill )
      {
         cxClip -= cxFill;    /* force size to next smaller even DWORD count */
         xFill   = xDst + cxClip;

        if ( cxClip >= cxSrc)
        {  // If shrink defer edge fill to later as there may be more
          CALL_DIR_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                                 MAKELONG(BOGUS_YUV, BOGUS_YUV), FALSE);
#ifdef TRACE_STRETCH
          DBG_MESSAGE((" Edge Fill(2) %d,%d %d x %d", xFill, yFill, cxFill, cyFill));
#endif
        }  // endif ( cxClip >= cxSrc)
      } // endif ( cxFill )

      if ( (cxClip < cxSrc) )
      {  // Edge Clip on shrinks only ( add config flag check here )
         int excess;

         // extra pixels to discard above integer ratio
         excess = ( cxSrc / iratio ) - cxClip;

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

         DISPDBG((DBGLVL1,
                  "DDraw - Edge Clip iratio = %d excess = %d Trim %% = %d",
                  iratio, excess, 2));

#else   // ----- #elseif WINNT_VER40 -----

        DBG_MESSAGE((" Edge Clip iratio = %d excess = %d Trim %% = %d", iratio, excess, 2));

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

         if ( excess && cxTrim )
         {  // These excess pixels are caused by our Dest alignment
            // problems on the Left edge
            if ( excess < (cxTrim * iratio) )
            {
               cxSrc  -= excess;
               xSrc   += excess;
               excess  = 0;
            }
            else
            {
               cxSrc  -= cxTrim * iratio;
               xSrc   += cxTrim * iratio;
               excess -= cxTrim * iratio;
            }
         }  // endif ( excess && cxTrim )

         if ( excess && cxFill)
         {  // These excess pixels are caused by our Dest alignment
            //  problems on the Right edge
            if ( excess < (cxFill * iratio) )
            {
               cxSrc -= excess;
               excess = 0;
            }
            else
            {
               cxSrc -= cxFill * iratio;
               excess -= cxFill * iratio;
            }
         }  // endif ( excess < (cxFill * iratio) )

         if ( excess && (excess < (2 * cxClip)/100 ))
         {  // if excess is less than 2% of frame trim edges
            int trim = excess / 2; // half the excess of pixels
            xSrc +=  trim;         // offset pixel pointer
            cxSrc -= excess;       // all the excess in pixels

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

            DISPDBG((DBGLVL1,
                     "DDraw - Edge Clip Left = %d, xSrc = %d, cxSrc = %d",
                     trim, xSrc, cxSrc));

#else   // ----- #elseif WINNT_VER40 -----

          DBG_MESSAGE((" Edge Clip Left = %d, xSrc = %d, cxSrc = %d", trim, xSrc, cxSrc));

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>
         }

         if ( iratio == 1 )
         {  // we may have just changed a shrink to a 1 : 1
            // if excess is zero do edge fill now

            // extra pixels to discard above integer ratio
            excess = ( cxSrc / iratio ) - cxClip;

            if ( !excess && cxFill )
            {
               xFill = xDst + cxClip;

               CALL_DIR_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                                      MAKELONG(BOGUS_YUV, BOGUS_YUV), FALSE);
#ifdef TRACE_STRETCH
            DBG_MESSAGE((" Edge Fill(7) %d,%d %d x %d", xFill, yFill, cxFill, cyFill));
#endif
            }
         }  // endif ( iratio == 1 )
      }
      else
      { // Stretch adjustments
        if ( xSrc - BaseOffset )
        { // if we are not starting from left edge of source image

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

          DISPDBG((DBGLVL1,
                   "DDraw - Edge Trim for stretch iratio = %d , cxTrim = %d xSrc %d",
                   iratio, cxTrim, xSrc));

#else   // ----- #elseif WINNT_VER40 -----

          DBG_MESSAGE((" Edge Trim for stretch iratio = %d , cxTrim = %d xSrc %d", iratio, cxTrim, xSrc));

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

          if ( cxTrim )
          {  // And we were forced to offset for left edge alignment
             cxSrc  -= cxTrim / iratio;
             xSrc += cxTrim / iratio;
          }
        }
      }  // endif ( (cxClip < cxSrc) )

      // Global adjustments
      if ( xSrc & 1 )   /* HW bug workaound for clipping */
      {
         xSrc += 1;    /* Align to SRC DWORD Boundary */
         cxSrc -= 1;   /* Account for smaller size */
      }
    }
    else
    { // 8 Bit frame buffer.
      // Force alignment of output to QWORD ( it is documented as DWORD but broken)

      if ( cxDst >= (cxSrc*2) )
         iratio = cxDst / (2 * cxSrc); // integer ratio of stretch
      else
         iratio = (2 * cxSrc ) / cxDst;  // integer ratio of shrink

      if ( xDst & 7 )   /* This should be for LN_YUV422 only */
      {
         cxFill = 8 - (xDst & 7);

         if ( cxFill > cxClip )
            cxFill = cxClip;  // check for no stretch left

         cxClip -= cxFill;  /* reduce size */
         cxDst  -= cxFill;  /* reduce size */
         xDst   += cxFill;  /* force alignment to next even WORD boundary */

         CALL_DIR_DRV_DST_BLT(MAKELONG(0x0000,BD_RES),MAKELONG(xFill,yFill),
                              0,MAKELONG(cxFill,cyFill));
#ifdef TRACE_STRETCH
        DBG_MESSAGE((" Edge Fill(3) %d,%d %d x %d", xFill, yFill, cxFill, cyFill));
#endif
      }  // endif ( xDst & 7 )

      cxFill  = cxClip & 7;

      if ( cxFill )
      {
         cxClip -= cxFill;    /* force size to next smaller even DWORD count */
         if ( cxClip >= (cxSrc * 2))
         { // If shrink defer edge fill to later as there may be more

           xFill  = xDst + cxClip;

#ifdef BOGUS_8BIT
           CALL_DIR_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                                  MAKELONG(BOGUS_YUV, BOGUS_YUV), FALSE);
#else
           CALL_DIR_DRV_DST_BLT(MAKELONG(0x0000,BD_RES),MAKELONG(xFill,yFill),
                                0,MAKELONG(cxFill,cyFill));
#endif

#ifdef TRACE_STRETCH
          DBG_MESSAGE((" Edge Fill(4) %d,%d %d x %d", xFill, yFill, cxFill, cyFill));
#endif
         }
      } // endif ( cxFill )

      // change pixel pointer to byte pointer
      // taking account of X origin of buffer
      xSrc = BaseOffset + (xSrc - BaseOffset) * 2;

      cxSrc *= 2;     /* change pixel count to byte count */

#ifdef EDGE_CLIP
      if ( (cxClip < cxSrc) && lpDDHALData->EdgeTrim)
      {  // Edge Clip on shrinks only ( add config flag check here )
         int excess;

         // extra pixels to discard above integer ratio
         excess = ( cxSrc / iratio ) - cxClip;

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

         DISPDBG((DBGLVL1,
                  "DDraw - Edge Clip iratio = %d excess = %d Trim %% = %d",
                  iratio, excess, lpDDHALData->EdgeTrim));

#else   // ----- #elseif WINNT_VER40 -----

        DBG_MESSAGE((" Edge Clip iratio = %d excess = %d Trim %% = %d",
                     iratio, excess, lpDDHALData->EdgeTrim));

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

         if ( excess && cxTrim )
         {  // These excess pixels are caused by our Dest alignment
            // problems on the Left edge
            if ( excess < (cxTrim * iratio) )
            {
               cxSrc  -= excess;
               xSrc   += excess;
               excess  = 0;
            }
            else
            {
               cxSrc  -= cxTrim * iratio;
               xSrc   += cxTrim * iratio;
               excess -= cxTrim * iratio;
            }
         }  // endif ( excess && cxTrim )

         if ( excess && cxFill)
         {  // These excess pixels are caused by our Dest alignment
            //  problems on the Right edge

            if ( excess < (cxFill * iratio) )
            {
               cxSrc -= excess;
               excess = 0;
            }
            else
            {
               cxSrc -= cxFill * iratio;
               excess -= cxFill * iratio;
            }
         }  // endif ( excess && cxFill)

        if ( excess && ( excess < (lpDDHALData->EdgeTrim * cxClip)/100 ) )
        {  // if excess is less than specific % of frame trim edges
           int trim = excess / 2;  // half the excess as pixels
           xSrc  +=  trim;      // offset pixel pointer
           cxSrc -= excess;    // all the excess in bytes

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

           DISPDBG((DBGLVL1,
                    "DDraw - Edge Clip Left = %d, xSrc = %d, cxSrc = %d",
                    trim, xSrc, cxSrc));

#else   // ----- #elseif WINNT_VER40 -----

          DBG_MESSAGE((" Edge Clip Left = %d, xSrc = %d, cxSrc = %d",
                       trim, xSrc, cxSrc));

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>
        }

        if ( iratio == 1 )
        { // we may have just changed a shrink to a 1 : 1
          // if excess is no zero do edge fill now

          // extra pixels to discard above integer ratio
          excess = ( cxSrc / iratio ) - cxClip;

          if ( !excess && cxFill )
          {
             xFill = xDst + cxClip;

#ifdef BOGUS_8BIT
             CALL_DIR_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                                    MAKELONG(BOGUS_YUV, BOGUS_YUV), FALSE);
#else
             CALL_DIR_DRV_DST_BLT(MAKELONG(0x0000,BD_RES),MAKELONG(xFill,yFill),
                                  0,MAKELONG(cxFill,cyFill));
#endif
#ifdef TRACE_STRETCH
            DBG_MESSAGE((" Edge Fill(6) %d,%d %d x %d", xFill, yFill, cxFill, cyFill));
#endif
          }  // endif ( !excess && cxFill )
        }  // endif ( iratio == 1 )
      } // endif ( (cxClip < cxSrc) && lpDDHALData->EdgeTrim)
#endif

      if ( xSrc & 3 )   /* HW bug workaound for clipping */
      {
         cxSrc -= 4 - (xSrc & 3);      // reduce size
         xSrc   = (xSrc + 3) & ~ 3;    // Align to SRC DWORD Boundary
      }
    }  // endif ( nBytesPixel == 2 )
  }

  if ( cxClip == 0 )
     return;     // discard zero extent stretchs

  if ( nBytesPixel == 1 &&
       ((SrcType == LN_YUV422) || (SrcType == LN_RGB565 )) ||
       ((nBytesPixel == 2) && (SrcType == LN_YUV422) ) )
  {
     /* This is to ensure that the last packet of any previous blt */
     /* does no go out with 9th bit set */

     CALL_DIR_DELAY_9BIT_BLT(FALSE);

     bltr.DRAWBLTDEF.DW   = MAKELONG(0x04CC, BD_RES | BD_OP1);
     lpDDHALData->YUVLeft = (USHORT)xDst;  // Save 9th bit rect coords for main
     lpDDHALData->YUVTop  = (USHORT)yDst;   // driver for exclusion purposes.
     lpDDHALData->YUVXExt = (USHORT)cxClip;
     lpDDHALData->YUVYExt = (USHORT)cyClip;

     // tell main driver the rectangle is valid
     lpDDHALData->DrvSemaphore |= DRVSEM_YUV_RECT_VALID;
  }
  else
     bltr.DRAWBLTDEF.DW  = MAKELONG(0x00CC, BD_RES | BD_OP1);

  bltr.OP0_opRDRAM.DW  = MAKELONG(xDst, yDst);
  bltr.OP1_opRDRAM.DW  = MAKELONG(xSrc, ySrc);

  bltr.BLTEXT.DW = MAKELONG(cxClip, cyClip);

  bltr.LNCNTL.W  = SrcType << LN_YUV_SHIFT;

  // Enable interpolation unless we have a palette (8bpp).
  if (SrcType != LN_8BIT )
     bltr.LNCNTL.W    |= LN_XINTP_EN | LN_YINTP_EN;

  bltr.SHRINKINC.w = 0x0000;

  if ( cxClip < cxSrc )
  {
     bltr.LNCNTL.W   |= LN_XSHRINK;
     bltr.LNCNTL.W   &= ~LN_XINTP_EN;
     bltr.SHRINKINC.pt.X = (cxSrc / cxClip);
  }

  if ( cyDst < cySrc )
  {
     bltr.LNCNTL.W   |= LN_YSHRINK;
     bltr.LNCNTL.W   &= ~LN_YINTP_EN;
     bltr.SHRINKINC.pt.Y = (cySrc / cyDst);
  }

  if ( SrcType == LN_YUV422 || SrcType == LN_RGB565 )
  {
    if ( nBytesPixel == 1 )
      bltr.SRCX  = (USHORT)cxSrc;  // If mixed mode is *2 already
    else
      bltr.SRCX = cxSrc * 2;
  }
  else
    bltr.SRCX   = cxSrc * nBytesPixel;

#ifdef TRACE_STRETCH
  DBG_MESSAGE((" cSrc = %d , %d : cDst = %d , %d : cClip = %d , %d",
               cxSrc, cySrc, cxDst, cyDst, cxClip, cyClip));
#endif

  // Compute DDA terms.
  nDst[0] = cxClip; nDst[1] = cyDst;
  nSrc[0] = cxSrc; nSrc[1] = cySrc;

  for (i = 0; i < 2; i++)
  {
    int kDst = 1;

    if (bltr.LNCNTL.W & ((i==0) ? LN_XINTP_EN : LN_YINTP_EN))
    {
      nDst[i] *= 4;
      nSrc[i] *= 4;
      nSrc[i] -= 3;

      kDst = 0x8000 / nDst[i];
    }

    if (bltr.LNCNTL.W & ((i==0) ? LN_XSHRINK : LN_YSHRINK))
    { /* Shrink Terms */
      axis[i].maj =  (short)nDst[i];
      axis[i].min = - (nSrc[i] % nDst[i]);
      axis[i].accum = axis[i].maj - 1
                      - ((nSrc[i] % nDst[i]) / (nSrc[i]/nDst[i] + 1));
    }
    else
    { /* Stretch Terms */
      axis[i].maj =  kDst * nDst[i];
      axis[i].min = -kDst * nSrc[i];
      axis[i].accum = axis[i].maj - 1
                      - ((axis[i].maj % -axis[i].min) / (nDst[i]/nSrc[i] + 1));
    }
  }  // endfor (i = 0; i < 2; i++)

  bltr.MAJ_X   = axis[0].maj;
  bltr.MIN_X   = axis[0].min;
  bltr.ACCUM_X = axis[0].accum;

  bltr.MAJ_Y   = axis[1].maj;
  bltr.MIN_Y   = axis[1].min;
  bltr.ACCUM_Y = axis[1].accum;

  if ((SrcType == LN_8BIT) ||
      ((SrcType == LN_YUV422) && !(bltr.LNCNTL.W & LN_XSHRINK)) )
  {
     CALL_DIR_DRV_STR_BLT(&bltr);   // Single stretch

     if ( (SrcType == LN_YUV422) )
     {
        // This is to ensure that the last packet of blt does no go out with
        // 9th bit clear  It is cheaper than waiting, especially on single
        // stripe BLTs

        CALL_DIR_DELAY_9BIT_BLT(TRUE);
     }
  }
  else if (SrcType == LN_RGB565 && !(bltr.LNCNTL.W & LN_XSHRINK))
#if 1
  {
    // HWBUG !!! -- Break into sram-aligned vertical tiles
    // based on destination alignment
    // dword and tile masks

    const int mdwrd =   4 ;
    const int tile = 128 ; /* sram is 128 bytes */
    const int mtile = 128 - 1 ; /* sram is 128 bytes */

    int endx  = xDst + cxClip;  // last x, exclusive
    int dstxe = endx & ~mtile;  // start of last tile

    DDAX accx = axis[0].accum;
    int  dstx = xDst;
    int  srcx = xSrc;
    int  src_ext = 0;
    int  xext;

#ifndef WINNT_VER40
    ASSERT( BITSPERPIXEL != 24 ); // HWBUG !!!
#endif

    if ( nBytesPixel == 2 )
    {
       cxSrc *= 2;   /* convert size to Bytes from pixels */
       cxDst *= 2;
       srcx = (xSrc *= 2);
       dstx = (xDst *= 2);
       bltr.OP0_opRDRAM.pt.X *= 2;
       bltr.OP1_opRDRAM.pt.X *= 2;
       endx *= 2;
       dstxe = endx & ~mtile;
    }

    CALL_DIR_DRV_STR_MBLTY(&bltr); // load the invariant sections of the engine

    // step to the next tile
    xext = 0;
    while ((dstx & mtile) && (dstx < endx))
    {
      dstx += 2;
      xext += 2;
      accx += axis[0].min;
      if (accx < 0)
      {
        accx += axis[0].maj;
        srcx += 2;
        src_ext += 2;
      }
    }  // endwhile ((dstx & mtile) && (dstx < endx))

    // do the odd pixels we stepped over
    if (xext)
    {
       bltr.BLTEXT.PT.X    = (USHORT)xext;
       CALL_DIR_DRV_STR_MBLTX(&bltr);
    }

    // do all the whole tiles but the last
    bltr.SRCX  -= (USHORT)src_ext;

    while (dstx < dstxe)
    {
      bltr.OP0_opRDRAM.PT.X = (USHORT)dstx;
      bltr.OP1_opRDRAM.PT.X = (USHORT)srcx;
      bltr.ACCUM_X = accx;
      xext = 0;
      src_ext = 0;

      do
      {
        dstx += 2;
        xext += 2;
        accx += axis[0].min;
        if (accx < 0)
        {
          accx += axis[0].maj;
          srcx += 2;
          src_ext += 2;
        }
      } while (dstx & mtile);

      bltr.BLTEXT.PT.X = (USHORT)xext;

      CALL_DIR_DRV_STR_MBLTX(&bltr);

      bltr.SRCX -= (USHORT)src_ext;
    }  // endwhile (dstx < dstxe)

    // do the last tile
    if (dstx < endx)
    {
       bltr.OP0_opRDRAM.PT.X = (USHORT)dstx;
       bltr.OP1_opRDRAM.PT.X = (USHORT)srcx;
       bltr.ACCUM_X  = accx;

       bltr.BLTEXT.PT.X = endx - dstx;

       CALL_DIR_DRV_STR_MBLTX(&bltr);
    }

    if ( (SrcType == LN_YUV422) || (SrcType == LN_RGB565 && nBytesPixel == 1) )
    {
       // This is to ensure that the last packet of stretch blt does no go out
       // with 9th bit clear. It is cheaper than waiting, especially on single
       // stripe BLTs

       CALL_DIR_DELAY_9BIT_BLT(TRUE);
    }
  }
#else
  {
    // HWBUG !!! -- Break into Double aligned vertical stripes
    // based on src and dest alignment
    // dword and tile masks

    const int mdwrd =   4 ;
    const int tile = 128 ; /* sram is 128 bytes */
    const int mtile = 128 - 1 ; /* sram is 128 bytes */

    int endx  = xDst + cxClip;  // last x, exclusive
    int dstxe = endx & ~mtile;  // start of last tile

    DDAX accx = axis[0].accum;
    int  dstx = xDst;
    int  srcx = xSrc;
    int  src_ext = 0;
    int  xext;

#ifndef WINNT_VER40
    ASSERT( BITSPERPIXEL != 24 ); // HWBUG !!!
#endif

    if ( nBytesPixel == 2 )
    {
      cxSrc *= 2;   /* convert size to Bytes from pixels */
      cxDst *= 2;
      srcx = (xSrc *= 2);
      dstx = (xDst *= 2);
      bltr.OP0_opRDRAM.pt.X *= 2;
      bltr.OP1_opRDRAM.pt.X *= 2;
      endx *= 2;
      dstxe = endx & ~mtile;
    }

    // step to the next tile
    xext = 0;
    while ((dstx & mtile) && (dstx < endx))
    {
      dstx += 2;
      xext += 2;
      accx += axis[0].min;
      if (accx < 0)
      {
        accx += axis[0].maj;
        srcx += 2;
        src_ext += 2;
      }
    }

    // do the odd pixels we stepped over

    if (xext)
    {
      bltr.BLTEXT.PT.X    = xext;
      CALL_DIR_DRV_STR_MBLT(&bltr);
    }

    // do all the whole tiles but the last

    bltr.SRCX         -= src_ext;

    while (dstx < dstxe)
    {
      bltr.OP0_opRDRAM.PT.X = dstx;
      bltr.OP1_opRDRAM.PT.X = srcx;
      bltr.ACCUM_X      = accx;
      xext = 0;
      src_ext = 0;
      do
      {
        dstx += 2;
        xext += 2;
        accx += axis[0].min;
        if (accx < 0)
        {
          accx += axis[0].maj;
          srcx += 2;
          src_ext += 2;
        }
      } while (dstx & mtile);

      bltr.BLTEXT.PT.X    = xext;

      CALL_DIR_DRV_STR_MBLT(&bltr);
    }

    // do the last tile
    if (dstx < endx)
    {
      bltr.OP0_opRDRAM.PT.X = dstx;
      bltr.OP1_opRDRAM.PT.X = srcx;
      bltr.ACCUM_X      = accx;

      bltr.BLTEXT.PT.X    = endx - dstx;

      CALL_DIR_DRV_STR_MBLT(&bltr);
    }
    if ( (SrcType == LN_YUV422) || (SrcType == LN_RGB565 && nBytesPixel == 1) )
    {
      /* This is to ensure that the last packet of stretch blt does no go out with 9th bit clear */
      /* It is cheaper than waiting, especially on single stripe BLTs */

      CALL_DIR_DELAY_9BIT_BLT(TRUE);
    }
  }
#endif
  else
  {
    // HWBUG !!! -- Break into sram-aligned vertical tiles
    // based on source alignment
    // tile mask
    const int mtile = 128; /* sram is 128 bytes */
    const int mtile_mask = mtile - 1;
    const short maj_x = bltr.MAJ_X;
    const short min_x = bltr.MIN_X;
    int endx  = xDst + cxClip;  // last x, exclusive, in pixels

    short  xaccum;
    int  dstx = xDst;
    int  srcx = xSrc;
    int  dst_ext;
    int  src_ext;
    int  copy_src_ext;

#ifndef WINNT_VER40
    ASSERT( BITSPERPIXEL != 24 ); // HWBUG !!!
#endif

    if ( nBytesPixel == 2 )
    {
       cxSrc *= 2;   /* convert size to Bytes from pixels */
       cxDst *= 2;
       srcx = (xSrc *= 2);
       dstx = (xDst *= 2);
       bltr.OP0_opRDRAM.pt.X *= 2;
       bltr.OP1_opRDRAM.pt.X *= 2;
       endx *= 2;    /* convert end marker to bytes */
    }

#ifdef TRACE_STRETCH
#ifdef TRACE_ALL
    DBG_MESSAGE((" mtile = %d  maj = %d min = %d accum = %d shrinkinc = %04x",
                 mtile, maj_x, min_x, bltr.ACCUM_X, bltr.SHRINKINC));
#endif
#endif

    CALL_DIR_DRV_STR_MBLTY(&bltr);   // Load the invariant registers

    do
    {
      // get alignment to first src tile / sram break;
      if ( srcx & mtile_mask ) // initial alignment
      {
         src_ext = mtile  - (srcx & mtile_mask);
         if ( src_ext > cxSrc )
            src_ext = cxSrc;
      }
      else
      {
         if ( cxSrc < mtile )
            src_ext = cxSrc; // last partial tile
        else
            src_ext = mtile; // complete tile
      }

      srcx  += src_ext;    // account for amount of src consumed
      cxSrc -= src_ext;

      // calculate how many destination pixels == src_ext
      xaccum  = bltr.ACCUM_X;
      dst_ext = 0;
      copy_src_ext = src_ext;
      do
      {
        dst_ext += 2;
        copy_src_ext -= 2 * bltr.SHRINKINC.pt.X;
        xaccum += min_x;
        if ( xaccum < 0 )
        {
          xaccum += maj_x;
          copy_src_ext -= 2;
        }
      } while ( copy_src_ext > 0 && (dstx + dst_ext <= endx) );

      dst_ext &= ~3;    /* force destination extent to DWORDs */

      dstx += dst_ext;

#ifdef TRACE_STRETCH
#ifdef TRACE_ALL
      DBG_MESSAGE((" srcx = %d src_ext = %d cxSrc = %d dstx = %d dst_ext = %d end = %d",
                   srcx, src_ext, cxSrc, dstx, dst_ext, endx ));
#endif
#endif

      bltr.BLTEXT.pt.X = (USHORT)dst_ext;

      if ( dst_ext > 0 )
         CALL_DIR_DRV_STR_MBLTX(&bltr);

      bltr.ACCUM_X      = xaccum;
      bltr.OP0_opRDRAM.pt.X += (USHORT)dst_ext;
      bltr.OP1_opRDRAM.pt.X += (USHORT)src_ext;
      bltr.SRCX         -= (USHORT)src_ext;
    } while ( (dstx < endx) && ( cxSrc > 0));

    xFill = bltr.OP0_opRDRAM.pt.X;

    cxFill  = (xDst + cxDst) - xFill;

#ifdef TRACE_STRETCH
    DBG_MESSAGE((" srcx=%d src_ext=%d cxSrc=%d  dstx=%d dst_ext=%d end=%d xFill=%d cxFill=%d",
                 srcx, src_ext, cxSrc, dstx, dst_ext, endx, xFill, cxFill ));
#endif

    // Edge Fill for trailing edge was deferred. Calculate correct amount
    // Taking into account pixels skipped above for alignment.

    if ((cxFill > 0) && (cxClip = (xFill & 7)) && ((SrcType == LN_YUV422)||((nBytesPixel == 1) &&(SrcType == LN_RGB565))))
    {// these must be extra pixels.  They must be filled using
     //  the same 9th bit and in the same format as the stretch

      cxClip = 8 - cxClip;

      if ( SrcType == LN_YUV422 )
      {
        CALL_DIR_MEDGE_FILL_BLT(xFill,yFill,cxClip,cyFill,
                                MAKELONG(BOGUS_YUV-1,BOGUS_YUV-1),TRUE);
      }
      else
      {
        CALL_DIR_MEDGE_FILL_BLT(xFill,yFill,cxClip,cyFill,0,TRUE);
      }

#ifdef TRACE_STRETCH
      DBG_MESSAGE((" Edge Fill 9th bit set %d,%d %d x %d", xFill, yFill, cxFill, cyFill));
#endif

      xFill = bltr.OP0_opRDRAM.pt.X + cxClip;
      cxFill -= cxClip;
    }

    if ( (SrcType == LN_YUV422) || (SrcType == LN_RGB565 && nBytesPixel == 1) )
    {
      /* This is to ensure that the last packet of stretch blt does no go out with 9th bit clear */
      /* It is cheaper than waiting, especially on single stripe BLTs */

      CALL_DIR_DELAY_9BIT_BLT(TRUE);
    }

    if ( cxFill > 0 )
    {
      /* perform edge fill Blt */
#ifdef BOGUS_8BIT
      CALL_DIR_MEDGE_FILL_BLT(xFill,yFill,cxFill,cyFill,
                              MAKELONG(BOGUS_YUV,BOGUS_YUV),FALSE);
#else
      if ( nBytesPixel == 2 )
        CALL_DIR_MEDGE_FILL_BLT(xFill,yFill,cxFill,cyFill,
                                MAKELONG(BOGUS_YUV,BOGUS_YUV),FALSE);
      else
        CALL_DIR_MEDGE_FILL_BLT(xFill,yFill,cxFill,cyFill,0,FALSE);
#endif

#ifdef TRACE_STRETCH
      DBG_MESSAGE((" Edge Fill(5) %d,%d %d x %d", xFill, yFill, cxFill, cyFill));
#endif
    }
  }
} /* DrvStretch62 */

/***************************************************************************
*
* FUNCTION:     StretchColor
*
* DESCRIPTION:  This is a software solution for both the 5462 and 5464
*               to perform a stretch or shrink while there is a source
*               color key specified.
*
****************************************************************************/

void STRETCHCOLOR
#ifndef WINNT_VER40
  LPGLOBALDATA lpDDHALData,
#endif
  int xDst, int yDst, int cxDst, int cyDst,
  int xSrc, int ySrc, int cxSrc, int cySrc,
  DWORD ColorKey)
{
  PVGAR pREG = (PVGAR) lpDDHALData->RegsAddress;
  int   xError, yError;
  int   xRun, yRun;


  DD_LOG(("StretchColor - dst=%08lX dstext= %08lX src=%08lX srcext=%08lX colorkey=%08lX\r\n",
          MAKELONG(xDst,yDst),MAKELONG(cxDst,cyDst),
          MAKELONG(xSrc,ySrc),MAKELONG(cxSrc,cxSrc),
          ColorKey));
//  DD_LOG(("  Beer break! - we're gonna blt every pixel one at a time\r\n"));

  // Setup the hardware.
  //LL32(grDRAWBLTDEF.DW,   0x101101CC);
  //LL32(grOP_opBGCOLOR.DW, ColorKey);

  // Initialize the error terms.
  xError = ((cxSrc << 16) - 1) / cxDst + 1;
  yError = ((cySrc << 16) - 1) / cyDst + 1;

  // Y loop.
  for (yRun = 0; cyDst--;)
  {
    int dst = xDst;
    int src = xSrc;
    int cx  = cxDst;

    // X loop.
    for (xRun = 0; cx--;)
    {
      // Copy one pixel with color keying
      //LL32(grOP0_opRDRAM.DW, MAKELONG(dst, yDst));
      //LL32(grOP1_opRDRAM.DW, MAKELONG(src, ySrc));
      //LL32(grOP2_opRDRAM.DW, MAKELONG(src, ySrc));
      //LL32(grBLTEXT_EX.DW,   MAKELONG(1, 1));

      // this is bad but is needed for compatibility with display list
      CALL_DRV_SRC_BLT(0x101101CC,          // drawbltdef
                       MAKELONG(dst,yDst),  // dst coord
                       MAKELONG(src,ySrc),  // src coord
                       MAKELONG(src,ySrc),  // colorkey coord
                       ColorKey,            // colorkey
                       MAKELONG(1,1));      // extent

      // Advance destination x.
      dst++;

      // Adjust x error term.
      xRun += xError;
      while (HIWORD(xRun))
      {
        // Advance source x.
        src++;
        xRun -= MAKELONG(0, 1);
      }
    }

    // Advance destination y.
    yDst++;

    // Adjust y error term.
    yRun += yError;
    while (HIWORD(yRun))
    {
      // Advance source y.
      ySrc++;
      yRun -= MAKELONG(0, 1);
    }
  }
} /* StretchColor */

/***************************************************************************
*
* FUNCTION:     TransparentStretch
*
* DESCRIPTION:
*
****************************************************************************/

void TRANSPARENTSTRETCH
#ifndef WINNT_VER40
  LPGLOBALDATA  lpDDHALData,
#endif
  int xDst, int yDst, int cxDst, int cyDst,
  int xSrc, int ySrc, int cxSrc, int cySrc,
  DWORD ColorKey)
{
  const int nBytesPixel = BYTESPERPIXEL;
  const int nSRAMPixels = (SRAM_SIZE / nBytesPixel) / 2;
  const int nSRAMMask   = nSRAMPixels - 1;

  autoblt_regs  SrcToScratch;

  int   xScratch, yScratch;
  int   cxScratch, cyScratch;

  AXIS  axis[2];
  int   nDst[2];
  int   nSrc[2];
  int   i;

  DDAX  accx;
  int   srcx;
  int   xext;

  int   cxTemp;
  int   xTemp;


#ifndef WINNT_VER40
  ASSERT(cxDst >= cxSrc);
#endif

  xScratch = LOWORD(lpDDHALData->ScratchBufferOrg);
  yScratch = HIWORD(lpDDHALData->ScratchBufferOrg);
  cxScratch = cxDst;
  cyScratch = cyDst;

  // initialize auto blt struct for src to scratch buffer
  SrcToScratch.DRAWBLTDEF.DW  = MAKELONG(ROP_OP1_copy, (BD_RES+BD_OP1)*IS_VRAM);

  SrcToScratch.OP0_opRDRAM.DW = MAKELONG(LOWORD(xScratch),LOWORD(yScratch));
  SrcToScratch.OP1_opRDRAM.DW = MAKELONG(LOWORD(xSrc),LOWORD(ySrc));

  SrcToScratch.LNCNTL.W       = lncntl[nBytesPixel-1] << LN_YUV_SHIFT;

  SrcToScratch.SRCX           = cxSrc * nBytesPixel;

#if ENABLE_INTERPOLATED_BLTS
  // Enable interpolation unless we have a palette (8bpp)
  if (1 < nBytesPixel)
    SrcToScratch.LNCNTL.W |= (LN_XINTP_EN | LN_YINTP_EN);
#endif

  SrcToScratch.SHRINKINC.W = 0x0000;

  if (cxDst < cxSrc)
  {
    SrcToScratch.LNCNTL.W |= LN_XSHRINK;
    SrcToScratch.LNCNTL.W &= ~LN_XINTP_EN;
    SrcToScratch.SHRINKINC.pt.X = (cxSrc / cxDst);
  }

  if ( cyDst < cySrc )
  {
    SrcToScratch.LNCNTL.W |= LN_YSHRINK;
    SrcToScratch.LNCNTL.W &= ~LN_YINTP_EN;
    SrcToScratch.SHRINKINC.pt.Y = (cySrc / cyDst);
  }

  SrcToScratch.BLTEXT.DW = MAKELONG(LOWORD(cxScratch),1);

  // Compute DDA terms

  nDst[0] = cxScratch;
  nDst[1] = cyScratch;
  nSrc[0] = cxSrc;
  nSrc[1] = cySrc;

  for (i = 0; i < 2; i++)
  {
    int kDst = 1;

#if ENABLE_INTERPOLATED_BLTS
    if (SrcToScratch.LNCNTL.W & ((i==0) ? LN_XINTP_EN : LN_YINTP_EN))
    {
      nDst[i] *= 4;
      nSrc[i] *= 4;
      nSrc[i] -= 3;

      kDst = 0x8000 / nDst[i];
    }
#endif

    if (SrcToScratch.LNCNTL.W & ((i==0) ? LN_XSHRINK : LN_YSHRINK))
    { /* Shrink Terms */
      axis[i].maj   =  (short)nDst[i];
      axis[i].min   = - (nSrc[i] % nDst[i]);
      axis[i].accum = axis[i].maj - 1
                      - ((nSrc[i] % nDst[i]) / (nSrc[i]/nDst[i] + 1));
    }
    else
    { /* Stretch Terms */
      axis[i].maj   =  kDst * nDst[i];
      axis[i].min   = -kDst * nSrc[i];
      axis[i].accum = axis[i].maj - 1
                      - ((axis[i].maj % -axis[i].min) / (nDst[i]/nSrc[i] + 1));
    }
  }

  SrcToScratch.MAJ_X   = axis[0].maj;
  SrcToScratch.MIN_X   = axis[0].min;
  SrcToScratch.ACCUM_X = axis[0].accum;

  SrcToScratch.MAJ_Y   = axis[1].maj;
  SrcToScratch.MIN_Y   = axis[1].min;
  SrcToScratch.ACCUM_Y = axis[1].accum;



  // loop over scanlines in dst
  // do two blts for each, one from src to scratch buffer
  //   then one from scratch buffer to dst
  while (0 < cyDst)
  {
    // blt one scanline high from src to scratch buffer

    // set values for initial stripe
    xext = nSRAMPixels;
    accx = SrcToScratch.ACCUM_X;
    srcx = xSrc;

    // write settings that don't vary over stripes to the chip
    CALL_DRV_STR_BLTY(&SrcToScratch);

    cxTemp = cxScratch;
    xTemp = xScratch;

    while (cxTemp > xext)
    {
      // update auto blt struct settings
      SrcToScratch.OP0_opRDRAM.pt.X = (USHORT)xTemp;
      SrcToScratch.OP1_opRDRAM.pt.X = (USHORT)srcx;
      SrcToScratch.BLTEXT.pt.X      = (USHORT)xext;

      // blt current stripe
      CALL_DRV_STR_BLTX(&SrcToScratch);

      // increment xDst and decrement remaining dst extent
      xTemp  += xext;
      cxTemp -= xext;

      // walk DDA to compute error term (accx) and xSrc for next stripe
      for (i = 0; i < xext; i++)
      {
        SrcToScratch.ACCUM_X += SrcToScratch.MIN_X;
        if (0 > (short)SrcToScratch.ACCUM_X)
        {
          SrcToScratch.ACCUM_X += SrcToScratch.MAJ_X;
          srcx++;
        }
      }
    }
    // if there's some area left to blt, then do it
    if (0 < cxTemp)
    {
      // update auto blt struct settings
      SrcToScratch.OP0_opRDRAM.pt.X = (USHORT)xTemp;
      SrcToScratch.OP1_opRDRAM.pt.X = (USHORT)srcx;
      SrcToScratch.BLTEXT.pt.X      = (USHORT)cxTemp;

      // blt final stripe
      CALL_DRV_STR_BLTX(&SrcToScratch);
    }
    // reset ACCUM_X for beginning of next scanline
    SrcToScratch.ACCUM_X = accx;

    // walk Y DDA for src to scratch buffer blt
    SrcToScratch.ACCUM_Y += SrcToScratch.MIN_Y;
    SrcToScratch.OP1_opRDRAM.pt.Y += SrcToScratch.SHRINKINC.pt.Y;
    if (0 > (short)SrcToScratch.ACCUM_Y)
    {
      SrcToScratch.ACCUM_Y += SrcToScratch.MAJ_Y;
      SrcToScratch.OP1_opRDRAM.pt.Y++;
    }


    // blt from scratch buffer to dst
    // 1:1 in X, 1:1 in Y, uses colorkey

    CALL_DRV_SRC_BLT(MAKELONG((DD_TRANS | ROP_OP1_copy),
                              ((BD_RES+BD_OP1+BD_OP2)*IS_VRAM)),
                     MAKELONG(xDst,yDst),
                     MAKELONG(xScratch,yScratch),
                     MAKELONG(xScratch,yScratch),
                     ColorKey,
                     MAKELONG(cxDst,1));
    yDst++;
    cyDst--;
  }
}

/****************************************************************************
* FUNCTION NAME: DdBlt (NT) or Blt32 (Win95)
*
* DESCRIPTION:
****************************************************************************/
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40
DWORD DdBlt(PDD_BLTDATA pbd)
{
  DRIVERDATA* lpDDHALData;
  PDEV*    ppdev;
  PVGAR    pREG;

#else   // ----- #elseif WINNT_VER40 -----
DWORD __stdcall Blt32(LPDDHAL_BLTDATA pbd)
{
  LPGLOBALDATA lpDDHALData = GetDDHALContext( pbd->lpDD);
#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

  HRESULT  ddrval;
  DWORD    dwFlags;

  DWORD  dwDstCoord;
  DWORD  dwDstWidth;
  DWORD  dwDstHeight;

  DWORD  dwSrcCoord;
  DWORD  dwSrcWidth;
  DWORD  dwSrcHeight;
  int    BaseOffset;

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

  PDD_SURFACE_LOCAL   dstx;
  PDD_SURFACE_LOCAL   srcx;
  PDD_SURFACE_GLOBAL  dst;
  PDD_SURFACE_GLOBAL  src;

  DISPDBG((DBGLVL, "DDraw - DdBlt\n"));

  ppdev = (PDEV*) pbd->lpDD->dhpdev;
  lpDDHALData = (DRIVERDATA*) &ppdev->DriverData;
  pREG = (PVGAR) lpDDHALData->RegsAddress;

#else   // ----- #elseif WINNT_VER40 -----

  LPDDRAWI_DDRAWSURFACE_LCL  dstx;
  LPDDRAWI_DDRAWSURFACE_LCL  srcx;
  LPDDRAWI_DDRAWSURFACE_GBL  dst;
  LPDDRAWI_DDRAWSURFACE_GBL  src;

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

  DD_LOG(("Blt32 Entry\r\n"));

#ifdef WINNT_VER40
  SYNC_W_3D(ppdev); // if 3D context(s) active, make sure 3D engine idle before continuing...
#endif

  // NOTES:
  //   Everything you need is in lpBlt->bltFX .
  //   Look at lpBlt->dwFlags to determine what kind of blt you are doing,
  //   DDBLT_xxxx are the flags.
  //
  // COLORKEY NOTES:
  //   ColorKey ALWAYS comes in BLTFX. You don't have to look it up in
  //   the surface.

#ifdef WINNT_VER40      // WINNT_VER40

#else   // ----- #elseif WINNT_VER40 -----
  // if direct draw is NOT using display list, it must sync here
  // updateFlipStatus may access the hardware!
  if (!lpDDHALData->DisplayListDDraw && ((lpDDHALData->DrvSemaphore & DRVSEM_3D_BUSY) || (lpDDHALData->DrvSemaphore & DRVSEM_DISPLAY_LIST)))
  {
     qmRequestDirectAccess();
  }
#endif // WINNT_VER40

    // is a flip in progress?
#ifdef WINNT_VER40
    ddrval = vUpdateFlipStatus(
        &ppdev->flipRecord,
        pbd->lpDDDestSurface->lpGbl->fpVidMem);
#else
#if defined(DDRAW_COMPAT_10)
    ddrval = pfnUpdateFlipStatus(
        pbd->lpDDDestSurface->lpData->fpVidMem
        lpDDHALData);
#else
    ddrval = pfnUpdateFlipStatus(
        pbd->lpDDDestSurface->lpGbl->fpVidMem,
        lpDDHALData);
#endif
#endif

  if (ddrval != DD_OK)
  {
     pbd->ddRVal = ddrval;
     DD_LOG(("Blt32 Exit - flip in progress, returning %08lX\r\n", ddrval));
     return (DDHAL_DRIVER_HANDLED);
  }

#ifndef WINNT_VER40
  // if the destination surface of this blt is a texture
  if (DDSCAPS_TEXTURE & pbd->lpDDDestSurface->ddsCaps.dwCaps)
  {
    LP_SURFACE_DATA lpSurfaceData;

    lpSurfaceData = (LP_SURFACE_DATA)(pbd->lpDDDestSurface->dwReserved1);

    // if the texture is a non-agp host texture (i.e. pci memory)
    if (lpSurfaceData->dwFlags & SURF_HOST_BASED_TEXTURE)
    {
        // punt the blt to direct draw hel
        pbd->ddRVal = DDERR_UNSUPPORTED;
        return DDHAL_DRIVER_NOTHANDLED;
    }
  }

  // if the source surface of this blt is non-null and is a texture
  if ((NULL != pbd->lpDDSrcSurface) &&
      (DDSCAPS_TEXTURE & pbd->lpDDSrcSurface->ddsCaps.dwCaps))
  {
    LP_SURFACE_DATA lpSurfaceData;

    lpSurfaceData = (LP_SURFACE_DATA)(pbd->lpDDSrcSurface->dwReserved1);

    // if the texture is a non-agp host texture (i.e. pci memory)
    if (lpSurfaceData->dwFlags & SURF_HOST_BASED_TEXTURE)
    {
        // punt the blt to direct draw hel
        pbd->ddRVal = DDERR_UNSUPPORTED;
        return DDHAL_DRIVER_NOTHANDLED;
    }
  }
#endif

  // If async, then only work if blter isn't busy.
  // This should probably be a little more specific to each call !!!
  dwFlags = pbd->dwFlags;

//#if 0
//  if( dwFlags & DDBLT_ASYNC )
//  {
//    if( !ENOUGH_FIFO_FOR_BLT )
//    {
//#if 0 // diagnostics for ASYNC BLT lockup
//      DWORD dwROP = pbd->bltFX.dwROP;
//      WORD rop = (WORD) LOBYTE( HIWORD( dwROP ) );
//      PVGAR pREG = (PVGAR) lpDDHALData->RegsAddress;
//      DBG_MESSAGE(("Status = %02x QFREE = %2d", pREG->grSTATUS, pREG->grQFREE));
//      dstx = pbd->lpDDDestSurface;
//      dst  = dstx->lpData;
//      dwDstCoord  = cvlxy( dst->fpVidMem - lpDDHALData->ScreenAddress, BYTESPERPIXEL );
//      dwDstCoord += MAKELONG( pbd->rDest.left, pbd->rDest.top );
//      dwDstWidth  = pbd->rDest.right  - pbd->rDest.left;
//      dwDstHeight = pbd->rDest.bottom - pbd->rDest.top;
//      srcx = pbd->lpDDSrcSurface;
//      src  = srcx->lpData;
//      dwSrcCoord  = cvlxy( src->fpVidMem - lpDDHALData->ScreenAddress, BYTESPERPIXEL );
//      dwSrcCoord += MAKELONG( pbd->rSrc.left, pbd->rSrc.top );
//      dwSrcWidth  = pbd->rSrc.right  - pbd->rSrc.left;
//      dwSrcHeight = pbd->rSrc.bottom - pbd->rSrc.top;
//
//        DBG_MESSAGE(("Failed Blt32: Blt from %08X %dx%d -> %08X %dx%d  rop %X",
//          dwSrcCoord, dwSrcWidth, dwSrcHeight,
//          dwDstCoord, dwDstWidth, dwDstHeight,
//          rop));
//#endif
//      DBG_MESSAGE(("ASYNC FAILED"));
//      pbd->ddRVal = DDERR_WASSTILLDRAWING;
//      return DDHAL_DRIVER_HANDLED;
//    }
//  }
//#endif

  // get offset, width, and height for destination
  dstx = pbd->lpDDDestSurface;

#if DDRAW_COMPAT == 10
  dst  = dstx->lpData;
#else
  dst  = dstx->lpGbl;
#endif

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

  dwDstCoord = cvlxy(ppdev->lDeltaScreen,
                     dst->fpVidMem,
                     BYTESPERPIXEL);

#else   // ----- #elseif WINNT_VER40 -----

  dwDstCoord  = cvlxy( lpDDHALData,dst->fpVidMem - lpDDHALData->ScreenAddress, BYTESPERPIXEL );

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

  dwDstCoord += MAKELONG(pbd->rDest.left, pbd->rDest.top);
  dwDstWidth  = pbd->rDest.right  - pbd->rDest.left;
  dwDstHeight = pbd->rDest.bottom - pbd->rDest.top;

  /* Check for a zero extent stretchblt */

  if ((dwDstWidth == 0) || (dwDstHeight == 0))
  {
     pbd->ddRVal = DD_OK;
     return (DDHAL_DRIVER_HANDLED);
  }
  // If someone is running a full-screen exclusive app it is the
  // responsibility of the app to take care of the cursor. We don't
  // call BeginAccess or EndAccess for them.
  //
  // However, if someone is running a windowed app and they have
  // attached a clipper object to the destination surface then they
  // are more like a normal windows app and we call BeginAccess and
  // EndAccess for them around a blt. That is the only circumstance
  // where we currently do cursor exclusion.
  //
  // We do intend to add calls to BeginAccess and EndAccess around
  // a rectangle lock of the primary surface. In this case, we
  // would only do cursor exclusion if a lock rect is specified.
  // This will be implemented with DirectDraw 2.0.
  //
  // I believe that you should not do automatic cursor exclusion in
  // the driver because you will penalize all blts and locks.

  // Grab the hardware - disable HW cursor updates.
  LOCK_HW_SEMAPHORE();

  // Decipher the flags.
  if (dwFlags & DDBLT_ROP)
  {
    static const WORD mix2blt[] =
    {  // all ops color vram
      BD_RES                  ,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES          | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0         ,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0         ,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES          | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES
    };  // all ops color vram

    DWORD dwROP = pbd->bltFX.dwROP;
    WORD  rop = (WORD) LOBYTE( HIWORD( dwROP ) );
    WORD  mix = rop & 0x0f;
    WORD  bdf = mix2blt[mix];

    if (bdf & BD_OP1) // SRC rops
    {
      srcx = pbd->lpDDSrcSurface;

#if DDRAW_COMPAT == 10
      src  = srcx->lpData;
#else
      src  = srcx->lpGbl;
#endif


#ifdef WINNT_VER40    // YUV movement code
#else
  if ((srcx->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
    (src->ddpfSurface.dwFlags & DDPF_FOURCC)    &&
    (lpDDHALData->DrvSemaphore & DRVSEM_YUV_MOVED) )
  {
    BOOL fMoved = FALSE;
    RECT rYUV;
		LONG lDeltaX, lDeltaY, Scale;
		LONG SrcWidth, SrcHeight, DstWidth, DstHeight;

		SrcWidth = src->wWidth;
		SrcHeight = src->wHeight;

		if (lpDDHALData->DrvSemaphore & DRVSEM_YUV_RECT_VALID)
		{
			rYUV.left	= min(lpDDHALData->YUVLeft,
							  pbd->rDest.left);
			rYUV.top	= min(lpDDHALData->YUVTop,
							  pbd->rDest.top);
			rYUV.right	= max(lpDDHALData->YUVLeft + lpDDHALData->YUVXExt,
							  pbd->rDest.right);
			rYUV.bottom	= max(lpDDHALData->YUVTop + lpDDHALData->YUVYExt,
							  pbd->rDest.bottom);
			DstWidth  = rYUV.right  - rYUV.left;
			DstHeight = rYUV.bottom - rYUV.top;

			if (pbd->rDest.left > rYUV.left)
			{
				// YUV has moved to left.
				lDeltaX = pbd->rDest.left - rYUV.left;
				Scale   = (SrcWidth - pbd->rSrc.right) * DstWidth / SrcWidth;
				lDeltaX = min(lDeltaX, Scale);
				pbd->rSrc.right += lDeltaX * SrcWidth / DstWidth;
				pbd->rDest.left -= lDeltaX;
				fMoved = TRUE;
			}
			if (pbd->rSrc.left > 0)
			{
				// YUV has moved to right.
				lDeltaX = rYUV.right - pbd->rDest.right;
				Scale   = pbd->rSrc.left * DstWidth / SrcWidth;
				lDeltaX = min(lDeltaX, Scale);
				pbd->rSrc.left   -= lDeltaX * SrcWidth / DstWidth;
				pbd->rDest.right += lDeltaX;
				fMoved = TRUE;
			}

			if (pbd->rDest.top > rYUV.top)
			{
				// YUV has moved up.
				lDeltaY = pbd->rDest.top - rYUV.top;
				Scale   = (SrcHeight - pbd->rSrc.bottom) * DstHeight / SrcHeight;
				lDeltaY = min(lDeltaY, Scale);
				pbd->rSrc.bottom += lDeltaY * SrcHeight / DstHeight;
				pbd->rDest.top   -= lDeltaY;
				fMoved = TRUE;
			}
			if (pbd->rSrc.top > 0)
			{
				// YUV has moved down.
				lDeltaY = rYUV.bottom - pbd->rDest.bottom;
				Scale   = pbd->rSrc.top * DstHeight / SrcHeight;
				lDeltaY = min(lDeltaY, Scale);
				pbd->rSrc.top     -= lDeltaY * SrcHeight / DstHeight;
				pbd->rDest.bottom += lDeltaY;
				fMoved = TRUE;
			}
		}

		if (fMoved)
		{
			// Recalculate the destination parameters since they might have
			// changed.
			dwDstCoord  = cvlxy(lpDDHALData,dst->fpVidMem - lpDDHALData->ScreenAddress,
								BYTESPERPIXEL);
			dwDstCoord += MAKELONG(pbd->rDest.left, pbd->rDest.top);
			dwDstWidth  = pbd->rDest.right  - pbd->rDest.left;
			dwDstHeight = pbd->rDest.bottom - pbd->rDest.top;
		}
		else
		{
			// Clear the YUV movement flag.
			lpDDHALData->DrvSemaphore &= ~DRVSEM_YUV_MOVED;
		}
	}

#endif // YUV movement code

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

      dwSrcCoord  = cvlxy(ppdev->lDeltaScreen,
                          src->fpVidMem,
                          BYTESPERPIXEL);

#else   // ----- #elseif WINNT_VER40 -----

      dwSrcCoord  = cvlxy( lpDDHALData,src->fpVidMem - lpDDHALData->ScreenAddress, BYTESPERPIXEL );

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

      dwSrcCoord += MAKELONG( pbd->rSrc.left, pbd->rSrc.top );
      dwSrcWidth  = pbd->rSrc.right  - pbd->rSrc.left;
      dwSrcHeight = pbd->rSrc.bottom - pbd->rSrc.top;

      if (dwFlags & DDBLT_KEYSRCOVERRIDE) // Source Color Key
      {
        DWORD dwColor = CALL_DUP_COLOR(pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue);

        DD_LOG(("Src Color Key Blt\r\n"));

        if ( (dwSrcWidth != dwDstWidth) || (dwSrcHeight != dwDstHeight) )
        {
          if ( !(srcx->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
               (rop == 0x00CC) )
          {
            if (dwSrcWidth < dwDstWidth)
            {
              CALL_TRANSPARENTSTRETCH(LOWORD(dwDstCoord), HIWORD(dwDstCoord),
                                      dwDstWidth, dwDstHeight,
                                      LOWORD(dwSrcCoord), HIWORD(dwSrcCoord),
                                      dwSrcWidth, dwSrcHeight,
                                      dwColor);
              goto blt_exit;
            }
            else
            {
              CALL_STRETCHCOLOR(LOWORD(dwDstCoord), HIWORD(dwDstCoord),
                               dwDstWidth, dwDstHeight,
                               LOWORD(dwSrcCoord), HIWORD(dwSrcCoord),
                               dwSrcWidth, dwSrcHeight,
                               dwColor);
              goto blt_exit;
            }
          }
          else
          {
            DD_LOG(("Unsupported SrcColorKey Blt -> punt\r\n"));
            ddrval = DDERR_UNSUPPORTED;
            goto blt_exit;
          }
        }

//        // PATCOPY is faster if that's all we're doing.
//        if (rop == 0xCC)
//        {
//           rop = 0xF0;
//           bdf = BD_RES | BD_OP2;
//        }

        CALL_DRV_SRC_BLT(MAKELONG(rop|DD_TRANS, bdf | BD_OP2),
                         dwDstCoord,
                         dwSrcCoord,
                         dwSrcCoord,  // Src transparency
                         dwColor,     //
                         MAKELONG(dwDstWidth, dwDstHeight) );

      } // (dwFlags & DDBLT_KEYSRCOVERRIDE) // Source Color Key
      else if (dwFlags & DDBLT_KEYDESTOVERRIDE) // Destination Color Key
      {
        #if _WIN32_WINNT >= 0x500
        // For some reason on NT 5.0 ddckDestColorkey does not work,
        // but ddckSrcColorkey does...
        DWORD dwColor = CALL_DUP_COLOR(pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue);
        #else
        DWORD dwColor = CALL_DUP_COLOR(pbd->bltFX.ddckDestColorkey.dwColorSpaceLowValue);
        #endif

        DD_LOG(("Dst Color Key Blt\r\n"));

        // Punt if stretch or shrink requested.
        if ((dwSrcWidth != dwDstWidth) || (dwSrcHeight != dwDstHeight))
        {
          DD_LOG(("Unsupported DstColorKey Blt -> punt\r\n"));
          ddrval = DDERR_UNSUPPORTED;
          goto blt_exit;
        }

        CALL_DRV_SRC_BLT(MAKELONG(rop|DD_TRANS|DD_TRANSOP, bdf | BD_OP2),
                         dwDstCoord,
                         dwSrcCoord,
                         dwDstCoord,  // Dst transparency
                         dwColor,     //
                         MAKELONG(dwDstWidth, dwDstHeight) );

      } // (dwFlags & DDBLT_KEYDESTOVERRIDE) // Destination Color Key
      else
      {
#ifdef TRACE_STRETCH
        DBG_MESSAGE(("Blt32: Blt from %08X %dx%d -> %08X %dx%d  rop %X",
                     dwSrcCoord, dwSrcWidth, dwSrcHeight,
                     dwDstCoord, dwDstWidth, dwDstHeight,
                     rop));
#endif
#ifdef TRACE_STRETCH
        DBG_MESSAGE(("Blt32: BaseOffset  %08X  %08X",
                     src->fpVidMem - lpDDHALData->ScreenAddress, PITCH));
        DBG_MESSAGE(("Blt32: src->w %04d  %04d (%04x)",
                     src->wWidth, src->wHeight,
                     (src->fpVidMem - lpDDHALData->ScreenAddress) / PITCH ));

#endif

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40
        BaseOffset = src->fpVidMem % ppdev->lDeltaScreen;
#else   // ----- #elseif WINNT_VER40 -----
        BaseOffset = (src->fpVidMem - lpDDHALData->ScreenAddress) % PITCH;
#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

        if ((dwSrcWidth != dwDstWidth) || (dwSrcHeight != dwDstHeight) ||
            (srcx->dwFlags & DDRAWISURF_HASPIXELFORMAT))
        {
          int  nBytesPixel = BYTESPERPIXEL;
          int  SrcType = lncntl[nBytesPixel - 1];
          int  SrcSize = nBytesPixel;

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

          int  ySrcAddr = src->fpVidMem / ppdev->lDeltaScreen;

#else   // ----- #elseif WINNT_VER40 -----

          int ySrcAddr    =  (src->fpVidMem - lpDDHALData->ScreenAddress) / PITCH;

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

          // Punt if 32bpp. The '62 and '64 don't do 32bpp stretches at all...
          // KENTL - 10/4/96
          if (nBytesPixel == 4)
          {
            DD_LOG(("Unsupported 32bpp resize blt -> punt\r\n"));
            ddrval = DDERR_UNSUPPORTED;
            goto blt_exit;
          }

          // Punt if not SRCCPY.
          if (rop != 0x00CC)
          {
            DD_LOG(("Unsupport rop in resize blt -> punt\r\n"));
            ddrval = DDERR_UNSUPPORTED;
            goto blt_exit;
          }

          // This should only be RGB565 in 8Bit FB or YUV422 in 8 or 16.
          if ( srcx->dwFlags & DDRAWISURF_HASPIXELFORMAT )
          {
            if ( src->ddpfSurface.dwFlags & DDPF_FOURCC )
               SrcType = LN_YUV422;
            else
               SrcType = LN_RGB565;

            SrcSize = 2;
          }

          if (LGDEVID == CL_GD5464)
          {
            if ( ! lpDDHALData->EdgeTrim )
              lpDDHALData->EdgeTrim = 15;  // Assign minimum trim percentage

            if ((SrcType == LN_YUV422))
            {
              // Check for 5464 shrink workaround
              if ((dwDstWidth * nBytesPixel) <=
                  ((dwSrcWidth * SrcSize) * (100 - lpDDHALData->EdgeTrim)/100))
              {
                DWORD  dwTDst_X;
                int    iratio;
                int    ratio_1, ratio_2;
                unsigned int  excess;

                if ( nBytesPixel == 1 )
                   dwSrcWidth *= SrcSize;

                iratio = dwSrcWidth / dwDstWidth;
                excess = dwSrcWidth % dwDstWidth;

                ratio_1 = iratio;

                // get power of 2 greater than current number
                ratio_2    = 1;
                do
                {
                   ratio_2 <<= 1;
                } while ( ratio_1 >>= 1 );

                // Check for special cases of ratio already a perfect
                // power of 2 or could be trimmed to a power of two.
                if ((!excess || ((100 * excess) <= (dwSrcWidth * (100 - lpDDHALData->EdgeTrim)/100)))
                    && ( (ratio_2 / iratio) == 2 ) )
                   ratio_2 >>= 1;

                if ( nBytesPixel == 1 )
                { // Mixed mode frame buffer so adjust coords / sizes
                  // to match
//#if 0
//                  if ( !( OFFSCR_YUV_VAR.ratio == ratio_2 ) )
//                  {
//                     OFFSCR_YUV_VAR.ratio = ratio_2;
//
//                     ratio_2 /= 2;
//
//                     // Perform offscreen shrink to adjacent src buffer
//                     CALL_DRVSTRETCH64(
//                       OFFSCR_YUV_VAR.SrcRect.right * SrcSize,
//                       OFFSCR_YUV_VAR.SrcRect.top,
//                       (OFFSCR_YUV_VAR.SrcRect.right - OFFSCR_YUV_VAR.SrcRect.left)/ratio_2,
//                       OFFSCR_YUV_VAR.SrcRect.bottom - OFFSCR_YUV_VAR.SrcRect.top,
//                       OFFSCR_YUV_VAR.SrcRect.left,
//                       OFFSCR_YUV_VAR.SrcRect.top,
//                       OFFSCR_YUV_VAR.SrcRect.right  - OFFSCR_YUV_VAR.SrcRect.left,
//                       OFFSCR_YUV_VAR.SrcRect.bottom - OFFSCR_YUV_VAR.SrcRect.top,
//                       nBytesPixel,
//                       SrcType,
//                       BaseOffset,
//                       FALSE);
//
//                     ratio_2 *= 2;
//                  }  // endif ( !( offscr_YUV.ratio == ratio_2 ) )
//
//                  // Perform stretch from adjacent src buffer to
//                  // onscreen dst
//                  dwTDst_X = LOWORD(dwSrcCoord) +
//                    (OFFSCR_YUV_VAR.SrcRect.right - OFFSCR_YUV_VAR.SrcRect.left) *
//                    SrcSize;
//#else
                  if (!( src->dwReserved1 == (DWORD)ratio_2))
                  {
                     src->dwReserved1 = ratio_2;

                     ratio_2 /= 2;

                     DD_LOG(("YUV shrink to extra buffer (8bpp)\r\n"));

                     // Perform offscreen shrink to adjacent src buffer
                     CALL_DRVSTRETCH64(
                        BaseOffset+(src->wWidth * SrcSize), // X Address of DST buffer
                        ySrcAddr,               // Y Address of DST buffer
                        src->wWidth / ratio_2,  // Width in PIXELS of DST
                        src->wHeight,           // Height
                        BaseOffset,             // X Address of SRC buffer
                        ySrcAddr,               // Y Address of SRC buffer
                        src->wWidth,            // Width in PIXELS of SRC
                        src->wHeight,           // Height
                        nBytesPixel,
                        SrcType,
                        BaseOffset,
                        FALSE);

                        ratio_2 *= 2;
                  }

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40
                  // Perform stretch from adjacent src buffer to onscreen dst
                  dwTDst_X = LOWORD(dwSrcCoord) / ratio_2 + (src->wWidth * SrcSize);
#else   // ----- #elseif WINNT_VER40 -----
                  // Perform stretch from adjacent src buffer   to onscreen dst
                  // Russ/Kent 10/4/96 - This fails for unknown reasons as code. The alternate coding
                  // seems to work better. Fixes PDR#6799
                  //  dwTDst_X  =  LOWORD(dwSrcCoord) / ratio_2 + (src->wWidth * SrcSize);
                  dwTDst_X  = BaseOffset + (LOWORD(dwSrcCoord) - BaseOffset)/ratio_2 + (src->wWidth*SrcSize);
#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

//#endif

//                  dwTDst_X   /= SrcSize;    // Modify src X address
                  dwSrcWidth /= SrcSize;

                  DD_LOG(("YUV stretch from extra buffer (8bpp)\r\n"));

                  CALL_DRVSTRETCH64(
                               LOWORD(dwDstCoord),
                               HIWORD(dwDstCoord),
                               dwDstWidth,
                               dwDstHeight,
                               dwTDst_X,
                               HIWORD(dwSrcCoord),
                               dwSrcWidth / ratio_2,
                               dwSrcHeight,
                               nBytesPixel,
                               SrcType,
                               BaseOffset + (src->wWidth * SrcSize),
                               TRUE);

                } // if ( nBytesPixel == 1 )
                else
                {
//#if 0
//                  if (!( OFFSCR_YUV_VAR.ratio == ratio_2))
//                  {
//                     OFFSCR_YUV_VAR.ratio = ratio_2;
//
//                     CALL_DRVSTRETCH64(
//                       lpDDHALData,
//                       OFFSCR_YUV_VAR.SrcRect.right,
//                       OFFSCR_YUV_VAR.SrcRect.top,
//                       (OFFSCR_YUV_VAR.SrcRect.right - OFFSCR_YUV_VAR.SrcRect.left)/ratio_2,
//                       OFFSCR_YUV_VAR.SrcRect.bottom - OFFSCR_YUV_VAR.SrcRect.top,
//                       OFFSCR_YUV_VAR.SrcRect.left,
//                       OFFSCR_YUV_VAR.SrcRect.top,
//                       OFFSCR_YUV_VAR.SrcRect.right  - OFFSCR_YUV_VAR.SrcRect.left,
//                       OFFSCR_YUV_VAR.SrcRect.bottom - OFFSCR_YUV_VAR.SrcRect.top,
//                       nBytesPixel, SrcType, BaseOffset,
//                       FALSE);
//
//                  }; // endif (!(offscr_YUV.ratio == ratio_2))
//
//                  // Perform stretch from adjacent src buffer to onscreen dst
//                  dwTDst_X = (LOWORD(dwSrcCoord) / ratio_2) +
//                    (OFFSCR_YUV_VAR.SrcRect.right - OFFSCR_YUV_VAR.SrcRect.left);
//
//#else
                  if ( !( src->dwReserved1 == (DWORD)ratio_2 ) )
                  {
                     src->dwReserved1 = ratio_2;

                     DD_LOG(("YUV shrink to extra buffer (16bpp)\r\n"));

                     // Perform offscreen shrink to adjacent src buffer
                     CALL_DRVSTRETCH64(
                       BaseOffset + (src->wWidth) , // X Address of DST buffer
                       ySrcAddr,               // Y Address of DST buffer
                       src->wWidth / ratio_2,  // Width in PIXELS of DST
                       src->wHeight,           // Height
                       BaseOffset,             // X Address of SRC buffer
                       ySrcAddr,               // Y Address of SRC buffer
                       src->wWidth,            // Width in PIXELS of SRC
                       src->wHeight,           // Height
                       nBytesPixel,
                       SrcType,
                       BaseOffset,
                       FALSE);
                  }

                  // Perform stretch from adjacent src buffer to onscreen dst
                  dwTDst_X = (LOWORD(dwSrcCoord) - BaseOffset) / ratio_2 + BaseOffset + (src->wWidth);
//#endif

                  DD_LOG(("YUV stretch from extra buffer (16bpp)\r\n"));

                  CALL_DRVSTRETCH64(
                               LOWORD(dwDstCoord),
                               HIWORD(dwDstCoord),
                               dwDstWidth,
                               dwDstHeight,
                               dwTDst_X,
                               HIWORD(dwSrcCoord),
                               dwSrcWidth / ratio_2,
                               dwSrcHeight,
                               nBytesPixel,
                               SrcType,
                               BaseOffset,
                               TRUE);

                } // endif ( nBytesPixel == 1 )
              }
              else
              {
                DD_LOG(("YUV stretch\r\n"));

                CALL_DRVSTRETCH64(
                             LOWORD(dwDstCoord),
                             HIWORD(dwDstCoord),
                             dwDstWidth,
                             dwDstHeight,
                             LOWORD(dwSrcCoord),
                             HIWORD(dwSrcCoord),
                             dwSrcWidth,
                             dwSrcHeight,
                             nBytesPixel,
                             SrcType,
                             BaseOffset,
                             TRUE);
              }
            }  // if ((SrcType == LN_YUV422))
            else
            {
              DD_LOG(("RGB resize blt\r\n"));

              // handle shrinks & stretches
              if ((2 == nBytesPixel) && (dwSrcWidth > dwDstWidth))
              {
                // handles 16bpp RGB shrinks
                CALL_RGB_16SHRINKBOF64(LOWORD(dwDstCoord), HIWORD(dwDstCoord),
                                       dwDstWidth, dwDstHeight,
                                       LOWORD(dwSrcCoord), HIWORD(dwSrcCoord),
                                       dwSrcWidth, dwSrcHeight);
              }
              else
              {
                // handles 16bpp RGB stretches, 8bpp stretches & 8bpp shrinks
                CALL_RGB_RESIZEBOF64(LOWORD(dwDstCoord), HIWORD(dwDstCoord),
                                     dwDstWidth, dwDstHeight,
                                     LOWORD(dwSrcCoord), HIWORD(dwSrcCoord),
                                     dwSrcWidth, dwSrcHeight);
              }
            } // endif ((SrcType == LN_YUV422))
          }  // if (LGDEVID == CL_GD5464)
          else
          {
            DD_LOG(("calling DrvStretch62\r\n"));

            CALL_DRVSTRETCH62(
                          LOWORD(dwDstCoord),
                          HIWORD(dwDstCoord),
                          dwDstWidth,
                          dwDstHeight,
                          LOWORD(dwSrcCoord),
                          HIWORD(dwSrcCoord),
                          dwSrcWidth,
                          dwSrcHeight,
                          nBytesPixel,
                          SrcType,
                          BaseOffset,
                          TRUE);

          }  // endif (LGDEVID == CL_GD5464)
        }
        else
        {
          DD_LOG(("1:1 two operand blt\r\n"));

          CALL_DRV_SRC_BLT(MAKELONG(rop, bdf),
                           dwDstCoord,
                           dwSrcCoord,
                           0UL,     // don't care
                           0UL,     //
                           MAKELONG(dwDstWidth, dwDstHeight));
        }
      } // endif (dwFlags & DDBLT_KEYSRCOVERRIDE) // Source Color Key
    }
    else // DST ONLY rops
    {
      DD_LOG(("Dst Only Blt\r\n"));

      CALL_DRV_DST_BLT(MAKELONG(rop, bdf),
                       dwDstCoord,
                       0UL,  // don't care
                       MAKELONG(dwDstWidth, dwDstHeight) );
    }  // endif (bdf & BD_OP1) // SRC rops
  } // (dwFlags & DDBLT_ROP)
  else if (dwFlags & DDBLT_COLORFILL)
  {
    DWORD dwColor = CALL_DUP_COLOR(pbd->bltFX.dwFillColor);

    DD_LOG(("Solid Color Fill\r\n"));

    CALL_DRV_DST_BLT(MAKELONG(0x00CC, BD_RES | (BD_OP1 * IS_SOLID)),
                     dwDstCoord,
                     dwColor,  // fill color
                     MAKELONG(dwDstWidth, dwDstHeight));
  }
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifndef WINNT_VER40     // Not WINNT_VER40
  else if (bD3DInit && dwFlags & DDBLT_DEPTHFILL)
  {
    //JGO changed for Laguna3D integration
    DWORD dwFillDepth = CALL_DUPZFILL(pbd->bltFX.dwFillDepth,
                                      dstx->lpGbl->ddpfSurface.dwZBufferBitDepth);

    DD_LOG(("Depth Fill Blt\r\n"));

    // convert to byte blt
    // 16 bit zbuffer in 32 bit frame buffer trashes everything to right
    // of zbuffer
    // Fixes PDR #9152
    ((PT *)(&dwDstCoord))->X *= (WORD)(dst->ddpfSurface.dwZBufferBitDepth / 8);
    dwDstWidth *= (dst->ddpfSurface.dwZBufferBitDepth / 8);

    CALL_DRV_DST_MBLT(MAKELONG(0x00CC, BD_RES | (BD_OP1 * IS_SOLID)),
                     dwDstCoord,
                     dwFillDepth,
                     MAKELONG(dwDstWidth, dwDstHeight));
  }
#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>
  else
  {
    DD_LOG(("Unsupported blt - dwFlags = %08lX\r\n", dwFlags));
    ddrval = DDERR_UNSUPPORTED;
    goto blt_exit;
  } // endif (dwFlags & DDBLT_ROP)

blt_exit:

  // Release the hardware - enable HW cursor updates.
  UNLOCK_HW_SEMAPHORE();

  if (ddrval != DD_OK)
     return DDHAL_DRIVER_NOTHANDLED;

  pbd->ddRVal = DD_OK;

  DD_LOG(("Blt32 Exit\r\n"));

  return DDHAL_DRIVER_HANDLED;

} /* DdBlt */

/***************************************************************************
*
* FUNCTION:     BltInit
*
* DESCRIPTION:
*
****************************************************************************/

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40
void BltInit (PDEV* ppdev,  BOOL bEnableDisplayListBlts )
#else   // ----- #elseif WINNT_VER40-----
void BltInit ( BOOL bEnableDisplayListBlts ,LPGLOBALDATA lpDDHALData)
#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>
{
  if ((CL_GD5462 == LGDEVID) || (FALSE == bEnableDisplayListBlts))
  {
#ifdef WINNT_VER40
    ppdev->pfnDelay9BitBlt = DIR_Delay9BitBlt;
    ppdev->pfnEdgeFillBlt  = DIR_EdgeFillBlt;
    ppdev->pfnMEdgeFillBlt = DIR_MEdgeFillBlt;
    ppdev->pfnDrvDstBlt    = DIR_DrvDstBlt;
    ppdev->pfnDrvDstMBlt   = DIR_DrvDstMBlt;
    ppdev->pfnDrvSrcBlt    = DIR_DrvSrcBlt;
    ppdev->pfnDrvSrcMBlt   = DIR_DrvSrcMBlt;
    ppdev->pfnDrvStrBlt    = DIR_DrvStrBlt;
    ppdev->pfnDrvStrMBlt   = DIR_DrvStrMBlt;
    ppdev->pfnDrvStrMBltY  = DIR_DrvStrMBltY;
    ppdev->pfnDrvStrMBltX  = DIR_DrvStrMBltX;
    ppdev->pfnDrvStrBltY   = DIR_DrvStrBltY;
    ppdev->pfnDrvStrBltX   = DIR_DrvStrBltX;
#else
    pfnDelay9BitBlt = DIR_Delay9BitBlt;
    pfnEdgeFillBlt  = DIR_EdgeFillBlt;
    pfnMEdgeFillBlt = DIR_MEdgeFillBlt;
    pfnDrvDstBlt    = DIR_DrvDstBlt;
    pfnDrvDstMBlt   = DIR_DrvDstMBlt;
    pfnDrvSrcBlt    = DIR_DrvSrcBlt;
    pfnDrvSrcMBlt   = DIR_DrvSrcMBlt;
    if (REVID_PRE65 & lpDDHALData->bRevInfoBits)
      pfnDrvStrBlt  = DIR_DrvStrBlt;
    else
      pfnDrvStrBlt  = DIR_DrvStrBlt65;
    pfnDrvStrMBlt   = DIR_DrvStrMBlt;
    pfnDrvStrMBltY  = DIR_DrvStrMBltY;
    pfnDrvStrMBltX  = DIR_DrvStrMBltX;
    pfnDrvStrBltY   = DIR_DrvStrBltY;
    pfnDrvStrBltX   = DIR_DrvStrBltX;
#if ENABLE_CLIPPEDBLTS
    if (! (REVID_PRE65 & lpDDHALData->bRevInfoBits))
    {
      if (CL_GD5465 == LGDEVID)
      {
        pfnClippedDrvDstBlt  = DIR_SWClippedDrvDstBlt;
        pfnClippedDrvDstMBlt = DIR_SWClippedDrvDstMBlt;
        pfnClippedDrvSrcBlt  = DIR_SWClippedDrvSrcBlt;
      }
      else
      {
        pfnClippedDrvDstBlt  = DIR_HWClippedDrvDstBlt;
        pfnClippedDrvDstMBlt = DIR_HWClippedDrvDstMBlt;
        pfnClippedDrvSrcBlt  = DIR_HWClippedDrvSrcBlt;
      }
    }
#endif
#endif
  }
  else
  {
#ifdef WINNT_VER40
    ppdev->pfnDelay9BitBlt = DL_Delay9BitBlt;
    ppdev->pfnEdgeFillBlt  = DL_EdgeFillBlt;
    ppdev->pfnMEdgeFillBlt = DL_MEdgeFillBlt;
    ppdev->pfnDrvDstBlt    = DL_DrvDstBlt;
    ppdev->pfnDrvDstMBlt   = DL_DrvDstMBlt;
    ppdev->pfnDrvSrcBlt    = DL_DrvSrcBlt;
    ppdev->pfnDrvSrcMBlt   = DL_DrvSrcMBlt;
    ppdev->pfnDrvStrBlt    = DL_DrvStrBlt;
    ppdev->pfnDrvStrMBlt   = DL_DrvStrMBlt;
    ppdev->pfnDrvStrMBltY  = DL_DrvStrMBltY;
    ppdev->pfnDrvStrMBltX  = DL_DrvStrMBltX;
    ppdev->pfnDrvStrBltY   = DL_DrvStrBltY;
    ppdev->pfnDrvStrBltX   = DL_DrvStrBltX;
#else
    pfnDelay9BitBlt = DL_Delay9BitBlt;
    pfnEdgeFillBlt  = DL_EdgeFillBlt;
    pfnMEdgeFillBlt = DL_MEdgeFillBlt;
    pfnDrvDstBlt    = DL_DrvDstBlt;
    pfnDrvDstMBlt   = DL_DrvDstMBlt;
    pfnDrvSrcBlt    = DL_DrvSrcBlt;
    pfnDrvSrcMBlt   = DL_DrvSrcMBlt;
    if (REVID_PRE65 & lpDDHALData->bRevInfoBits)
      pfnDrvStrBlt  = DL_DrvStrBlt;
    else
      pfnDrvStrBlt  = DL_DrvStrBlt65;
    pfnDrvStrMBlt   = DL_DrvStrMBlt;
    pfnDrvStrMBltY  = DL_DrvStrMBltY;
    pfnDrvStrMBltX  = DL_DrvStrMBltX;
    pfnDrvStrBltY   = DL_DrvStrBltY;
    pfnDrvStrBltX   = DL_DrvStrBltX;
#if ENABLE_CLIPPEDBLTS
    if (! (REVID_PRE65 & lpDDHALData->bRevInfoBits))
    {
      if (CL_GD5465 == LGDEVID)
      {
        pfnClippedDrvDstBlt  = DL_SWClippedDrvDstBlt;
        pfnClippedDrvDstMBlt = DL_SWClippedDrvDstMBlt;
        pfnClippedDrvSrcBlt  = DL_SWClippedDrvSrcBlt;
      }
      else
      {
        pfnClippedDrvDstBlt  = DL_HWClippedDrvDstBlt;
        pfnClippedDrvDstMBlt = DL_HWClippedDrvDstMBlt;
        pfnClippedDrvSrcBlt  = DL_HWClippedDrvSrcBlt;
      }
    }
#endif
#endif
  }
}
#endif // WINNT_VER35
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\ddsurf.c ===
/***************************************************************************
*
*                ******************************************
*                * Copyright (c) 1996, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:  Laguna I (CL-GD546x) -
*
* FILE:     ddsurf.c
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This module implements the DirectDraw SURFACE
*           components for the Laguna NT driver.
*
* MODULES:
*           DdLock()
*           DdUnlock()
*           CanCreateSurface()
*           CreateSurface()
*           DestroySurface()
*
* REVISION HISTORY:
*   7/12/96     Benny Ng      Initial version
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/ddsurf.c  $
* 
*    Rev 1.25   May 01 1998 11:33:02   frido
* Added one more check for PC98.
* 
*    Rev 1.24   May 01 1998 11:07:24   frido
* Finally the programmable blitter stride works.
* 
*    Rev 1.23   Mar 30 1998 13:04:38   frido
* Added one more call to Set256ByteFetch if an overlay failed to be created.
* 
*    Rev 1.22   Mar 25 1998 18:09:44   frido
* PDR#11184. Finally. When overlays are turned on, 256-byte fetch
* should be turned off. And when overlays are turned off again, 256-byte
* fetch should be restored.
* 
*    Rev 1.21   17 Oct 1997 11:29:48   bennyn
* Clear dwReserved1 after DestroySurface.
* 
*    Rev 1.20   16 Oct 1997 09:52:56   bennyn
* 
* Fixed the FlipCube FPS exceed refresh rate problem
* 
*    Rev 1.19   08 Oct 1997 11:29:38   RUSSL
* Fix so this file can be compiled without OVERLAY defined
* 
*    Rev 1.18   26 Sep 1997 11:01:14   bennyn
* Fixed PDR 10563
* 
*    Rev 1.17   16 Sep 1997 15:13:46   bennyn
* Added DD overlay support.
* 
*    Rev 1.16   03 Sep 1997 17:00:48   bennyn
* In CreateSurface() punts the request if at 320x240x8 or 320x200x8
*
****************************************************************************
****************************************************************************/

/*----------------------------- INCLUDES ----------------------------------*/
#include "precomp.h"
#include <clioctl.h>

//
// This file isn't used in NT 3.51
//
#ifndef WINNT_VER35


/*----------------------------- DEFINES -----------------------------------*/
//#define DBGBRK
#define DBGLVL        1

/*--------------------- STATIC FUNCTION PROTOTYPES ------------------------*/

#if DRIVER_5465 && defined(OVERLAY)
VOID GetFormatInfo (LPDDPIXELFORMAT lpFormat, LPDWORD lpFourcc, LPDWORD lpBitCount);
#endif

/*--------------------------- ENUMERATIONS --------------------------------*/

/*----------------------------- TYPEDEFS ----------------------------------*/

/*-------------------------- STATIC VARIABLES -----------------------------*/

/*-------------------------- GLOBAL FUNCTIONS -----------------------------*/

#if DRIVER_5465 // PDR#11184
VOID Set256ByteFetch(PPDEV ppdev, BOOL fEnable)
{
	ULONG ulStall = 50 * 1000;
	ULONG ulReturn;

	while (LLDR_SZ(grSTATUS) != 0) ;	// Wait for idle chip.
	while (LLDR_SZ(grQFREE) != 25) ;	// Wait for empty FIFO queue.
	DEVICE_IO_CTRL(ppdev->hDriver,		// Wait for 50 ms.
				   IOCTL_STALL,
				   &ulStall, sizeof(ulStall),
				   NULL, 0,
				   &ulReturn,
				   NULL);

	if (fEnable)
	{
		// Restore the CONTROL2 register value.
		LL16(grCONTROL2, ppdev->DriverData.dwCONTROL2Save);
	}
	else
	{
		// Disable 256-byte fetch after storing the current value.
		ppdev->DriverData.dwCONTROL2Save = LLDR_SZ(grCONTROL2);
		LL16(grCONTROL2, ppdev->DriverData.dwCONTROL2Save & ~0x0010);
	}
}
#endif

/****************************************************************************
* FUNCTION NAME: DdLock
*
* DESCRIPTION:   This callback is invoked whenever a surface is about
*                to be directly accessed by the user. This is where you
*                need to make sure that a surface can be safely accessed
*                by the user.
*                If your memory cannot be accessed while in accelerator
*                mode, you should take either take the card out of
*                accelerator mode or else return DDERR_SURFACEBUSY
*                If someone is accessing a surface that was just flipped
*                away from, make sure that the old surface (what was the
*                primary) has finished being displayed.
*                (Based on Laguna Win95 DirectDraw code)
****************************************************************************/
DWORD DdLock(PDD_LOCKDATA lpLock)
{
#ifdef RDRAM_8BIT
  RECTL SrcRectl;
#endif

  DRIVERDATA* pDriverData;
  PDEV*       ppdev;
  HRESULT     ddrval;
  DWORD       tmp;


  DISPDBG((DBGLVL, "DDraw - DdLock\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  ppdev = (PDEV*) lpLock->lpDD->dhpdev;
  pDriverData = (DRIVERDATA*) &ppdev->DriverData;

  SYNC_W_3D(ppdev);

#if DRIVER_5465 && defined(OVERLAY)
  if (DDSCAPS_OVERLAY & lpLock->lpDDSurface->ddsCaps.dwCaps)
  {
    ppdev->dwDDLinearCnt++;
    return pDriverData->OverlayTable.pfnLock(ppdev, lpLock);
  }
#endif

#ifdef RDRAM_8BIT
  if (lpLock->lpDDSurface->lpGbl->ddpfSurface.dwFlags & DDPF_FOURCC)
  {
     if (lpLock->bHasRect)
        SrcRectl = lpLock->rArea;
     else
     {
        tmp = lpLock->lpDDSurface->lpGbl->fpVidMem;
        SrcRectl.top  = cvlxy(ppdev->lDeltaScreen, tmp, BYTESPERPIXEL);

        SrcRectl.left = SrcRectl.top & 0xFFFF;
        SrcRectl.top = (SrcRectl.top >> 16) & 0xFFFF;
        SrcRectl.bottom = SrcRectl.top + lpLock->lpDDSurface->lpGbl->wHeight;
        SrcRectl.right = SrcRectl.left + lpLock->lpDDSurface->lpGbl->wWidth;
     };

    ppdev->offscr_YUV.nInUse = TRUE;
    ppdev->offscr_YUV.SrcRect = SrcRectl;

	 ppdev->offscr_YUV.ratio = 0;
	 lpLock->lpDDSurface->lpGbl->dwReserved1 = 0;
  };
#endif

  // get the monitor frequency after a mode reset
  if (pDriverData->fReset)
  {
     vGetDisplayDuration(&ppdev->flipRecord);
     pDriverData->fReset = FALSE;
  };

  // Check to see if any pending physical flip has occurred.
  // Don't allow a lock if a blt is in progress:
  ddrval = vUpdateFlipStatus(&ppdev->flipRecord,
                             lpLock->lpDDSurface->lpGbl->fpVidMem);

  if (ddrval != DD_OK)
  {
     lpLock->ddRVal = DDERR_WASSTILLDRAWING;
     return(DDHAL_DRIVER_HANDLED);
  };

  // don't allow a lock if a blt is in progress
  // (only do this if your hardware requires it)
  // Note: GD5462 requires it. Blitter and screen
  // access are not otherwise synchronized.
  if ((ppdev->dwDDLinearCnt == 0) && (DrawEngineBusy(pDriverData)))
  {
     lpLock->ddRVal = DDERR_WASSTILLDRAWING;
     return DDHAL_DRIVER_HANDLED;
  };

  // Reference count it, just for the heck of it:
  ppdev->dwDDLinearCnt++;

  return(DDHAL_DRIVER_NOTHANDLED);

} // Lock


/****************************************************************************
* FUNCTION NAME: DdUnlock
*
* DESCRIPTION:
****************************************************************************/
DWORD DdUnlock(PDD_UNLOCKDATA lpUnlock)
{
  PDEV* ppdev = (PDEV*) lpUnlock->lpDD->dhpdev;

  DISPDBG((DBGLVL, "DDraw - DdUnlock\n"));

#if DRIVER_5465 && defined(OVERLAY)
  if (DDSCAPS_OVERLAY & lpUnlock->lpDDSurface->ddsCaps.dwCaps)
    ppdev->DriverData.OverlayTable.pfnUnlock(ppdev,lpUnlock);
#endif

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  ppdev->dwDDLinearCnt--;

  return DDHAL_DRIVER_NOTHANDLED;

} // Unlock


/****************************************************************************
* FUNCTION NAME: CanCreateSurface
*
* DESCRIPTION:
*                (Based on Laguna Win95 DirectDraw code)
****************************************************************************/
DWORD CanCreateSurface (PDD_CANCREATESURFACEDATA lpInput)
{
  DRIVERDATA* pDriverData;
  PDEV*       ppdev;

  DISPDBG((DBGLVL, "DDraw - CanCreateSurface\n"));

  #ifdef DBGBRK
    DBGBREAKPOINT();
  #endif

  ppdev = (PDEV*) lpInput->lpDD->dhpdev;
  pDriverData = (DRIVERDATA*) &ppdev->DriverData;

  // First check for overlay surfaces
  if (lpInput->lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
  {
    #if DRIVER_5465 && defined(OVERLAY)
        if (DDSCAPS_OVERLAY & lpInput->lpDDSurfaceDesc->ddsCaps.dwCaps)
        {
            DWORD   dwFourCC;
            DWORD   dwBitCount;
            HRESULT hr;

            if (lpInput->bIsDifferentPixelFormat)
            {
                GetFormatInfo(&(lpInput->lpDDSurfaceDesc->ddpfPixelFormat),
                            &dwFourCC, &dwBitCount);
            }
            else
            {
                dwBitCount = BITSPERPIXEL;
                if (16 == dwBitCount)
                dwFourCC = BI_BITFIELDS;
                else
                dwFourCC = BI_RGB;
            }

            hr = pDriverData->OverlayTable.pfnCanCreateSurface(ppdev,dwFourCC,dwBitCount);
            if (DD_OK != hr)
            {
                lpInput->ddRVal = hr;
                return DDHAL_DRIVER_HANDLED;
            }
        }
    #else
        lpInput->ddRVal = DDERR_NOOVERLAYHW;;
        return (DDHAL_DRIVER_HANDLED);
    #endif
  }
  else if (lpInput->bIsDifferentPixelFormat)
  {
    // Next check for formats that don't match the primary surface.
    LPDDPIXELFORMAT lpFormat = &lpInput->lpDDSurfaceDesc->ddpfPixelFormat;

    if (lpFormat->dwFlags & DDPF_FOURCC)
    {
        // YUV422 surface
        if (lpFormat->dwFourCC == FOURCC_UYVY)
        {
            #if DRIVER_5465
                if (ppdev->iBitmapFormat == BMF_8BPP)
                    lpInput->ddRVal = DDERR_INVALIDPIXELFORMAT;
                else
                    lpInput->ddRVal = DD_OK;

                return (DDHAL_DRIVER_HANDLED);
                
            #else // 5462 and 5464 driver
                #if _WIN32_WINNT >= 0x0500
                    // For NT5 do not allow any YUV surfaces that are not
                    // overlays.
                    ;
                #else // NT4
                    // if we have nine bit RDRAMs then surface creation is okay
                    if (TRUE == pDriverData->fNineBitRDRAMS)
                    {
                        lpInput->ddRVal = DD_OK;
                        return (DDHAL_DRIVER_HANDLED);
                    }

                    // if we have eight bit RDRAMs then see if already
                    // have a YUV422 surface
                    else if (FALSE == ppdev->offscr_YUV.nInUse)
                    {
                        lpInput->ddRVal = DD_OK;
                        return (DDHAL_DRIVER_HANDLED);
                    };
                #endif
            #endif  // DRIVER_5465
        }; // endif (lpFormat->dwFourCC == FOURCC_UYVY)
    }
    else
    {
        // support RGB565 with RGB8 primary surface !!!
    };  // endif (lpFormat->dwFlags & DDPF_FOURCC)

    lpInput->ddRVal = DDERR_INVALIDPIXELFORMAT;

    return (DDHAL_DRIVER_HANDLED);
  }; // endif (lpInput->lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_OVERLAY)

  lpInput->ddRVal = DD_OK;

  return (DDHAL_DRIVER_HANDLED);
} // CanCreateSurface


/****************************************************************************
* FUNCTION NAME: InsertInDDOFSQ()
*
* DESCRIPTION:   Insert the handle into the DD Offscreen memory queue.
****************************************************************************/
void InsertInDDOFSQ(PPDEV  ppdev, DDOFM *hdl)
{
  hdl->prevhdl = NULL;

  if (ppdev->DDOffScnMemQ == NULL)
  {
    hdl->nexthdl = NULL;
    ppdev->DDOffScnMemQ = hdl;
  }
  else
  {
    ppdev->DDOffScnMemQ->prevhdl = hdl;
    hdl->nexthdl = ppdev->DDOffScnMemQ;
    ppdev->DDOffScnMemQ = hdl;
  };

} // InsertInDDOFSQ()



/****************************************************************************
* FUNCTION NAME: RemoveFrmDDOFSQ()
*
* DESCRIPTION:   Remove the handle from the DD Offscreen memory queue.
****************************************************************************/
BOOL RemoveFrmDDOFSQ(PPDEV  ppdev, DDOFM *hdl)
{
  DDOFM  *prvpds, *nxtpds;
  DDOFM  *pds;
  BOOL   fndflg;


  // Validate the release block
  fndflg = FALSE;
  pds = ppdev->DDOffScnMemQ;
  while (pds != 0)
  {
    if (hdl == pds)
    {
       fndflg = TRUE;
       break;
    };

    // Next free block
    pds = pds->nexthdl;
  }; // end while

  // Return if it is an invalid handle
  if (!fndflg)
     return (FALSE);

  prvpds = hdl->prevhdl;
  nxtpds = hdl->nexthdl;

  if (hdl == ppdev->DDOffScnMemQ)
  {
    ppdev->DDOffScnMemQ = nxtpds;

    if (nxtpds != 0)
       nxtpds->prevhdl = NULL;
  }
  else
  {
    if (nxtpds != NULL)
       nxtpds->prevhdl = prvpds;

    if (prvpds != NULL)
       prvpds->nexthdl = nxtpds;
  };

  // Free allocated DDOFM structure from host memory
  MEMORY_FREE(hdl);

  return (TRUE);
} // RemoveFrmDDOFSQ()



/****************************************************************************
* FUNCTION NAME: CreateSurface
*
* DESCRIPTION:
*                (Based on Laguna Win95 DirectDraw code)
****************************************************************************/
DWORD CreateSurface (PDD_CREATESURFACEDATA lpInput)
{
  BOOL        puntflag;
  BOOL        bYUVsurf;
#if DRIVER_5465 && defined(OVERLAY)
  BOOL        bOverlaySurf;
#endif  // #if DRIVER_5465 && defined(OVERLAY)
  DRIVERDATA* pDriverData;
  PDEV*       ppdev;
  LPDDSURFACEDESC lpDDSurfaceDesc = lpInput->lpDDSurfaceDesc;
  LPDDPIXELFORMAT lpFormat = &lpInput->lpDDSurfaceDesc->ddpfPixelFormat;
  DWORD		  dwPitch = 0;

  DISPDBG((DBGLVL, "DDraw - CreateSurface\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  ppdev = (PDEV*) lpInput->lpDD->dhpdev;
  pDriverData = (DRIVERDATA*) &ppdev->DriverData;

  bYUVsurf = FALSE;
#if DRIVER_5465 && defined(OVERLAY)
  bOverlaySurf = FALSE;
#endif  // #if DRIVER_5465 && defined(OVERLAY)

#if DRIVER_5465

#ifdef ALLOC_IN_CREATESURFACE
{ // Support for 5465

  PDD_SURFACE_LOCAL  *lplpSurface;
  SIZEL   sizl;
  OFMHDL  *hdl;
  DDOFM   *pds;
  DWORD   i;

#if DRIVER_5465 && defined(OVERLAY)
  DWORD             dwBitCount;
  DWORD             dwFourCC;

  // check for overlay surface
  if (lpDDSurfaceDesc->ddsCaps.dwCaps & (  DDSCAPS_OVERLAY
#if DDRAW_COMPAT >= 50
                                         | DDSCAPS_VIDEOPORT
#endif
                                        ))
  {
    if (lpDDSurfaceDesc->dwFlags & DDSD_PIXELFORMAT)
    {
      GetFormatInfo(&(lpInput->lpDDSurfaceDesc->ddpfPixelFormat),
                    &dwFourCC, &dwBitCount);
    }
    else
    {
      dwFourCC = 0;
      dwBitCount = BITSPERPIXEL;
    }

#if DDRAW_COMPAT >= 50
    if((CL_GD5465 == pDriverData->dwLgVenDevID)
       && (DDSCAPS_VIDEOPORT & lpDDSurfaceDesc->ddsCaps.dwCaps))
    {
      if((lpDDSurfaceDesc->dwWidth * dwBitCount >> 3) >= 2048 )
      {
        //Surface is too wide for video port
        lpInput->ddRVal = DDERR_TOOBIGWIDTH;
        return DDHAL_DRIVER_HANDLED;
      }
    }
#endif

    bOverlaySurf = TRUE;

  } // end overlay surface handler
  else
#endif  // #if DRIVER_5465 && defined(OVERLAY)

  if (lpInput->lpDDSurfaceDesc->dwFlags & DDSD_PIXELFORMAT)
  {
     // Specify the block size for non-RGB surfaces
     if (lpFormat->dwFlags & DDPF_FOURCC)
     {
        // YUV422 surface
        if (lpFormat->dwFourCC == FOURCC_UYVY)
        {
           bYUVsurf = TRUE;
        }; // endif (lpFormat->dwFourCC == FOURCC_UYVY)
     };  // endif (lpFormat->dwFlags & DDPF_FOURCC)
  }  // endif (lpInput->lpDDSurfaceDesc->dwFlags & DDSD_PIXELFORMAT)

  // Not support 8BPP YUV surface
  if (
#if DRIVER_5465 && defined(OVERLAY)
      (!bOverlaySurf) &&
#endif  // #if DRIVER_5465 && defined(OVERLAY)
      ((bYUVsurf) && (8 == BITSPERPIXEL)))
  {
     lpInput->ddRVal = DDERR_INVALIDPIXELFORMAT;
     return DDHAL_DRIVER_HANDLED;
  };  // endif (8 == BITSPERPIXEL)

  lplpSurface = lpInput->lplpSList;
  for (i = 0; i < lpInput->dwSCnt; i++)
  {
    PDD_SURFACE_LOCAL lpSurface = *lplpSurface;

    sizl.cx = lpSurface->lpGbl->wWidth;
    sizl.cy = lpSurface->lpGbl->wHeight;

#if 1 // PC98
	if (   (lpDDSurfaceDesc->dwFlags == (DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH))
		&& (lpDDSurfaceDesc->ddsCaps.dwCaps == DDSCAPS_VIDEOMEMORY)
		&& (lpDDSurfaceDesc->dwHeight == 32 && lpDDSurfaceDesc->dwWidth == 32)
		&& (sizl.cx == 32 && sizl.cy == 32)
		&& (lpInput->dwSCnt == 1)
	)
	{
		sizl.cx = min(32 * 32, ppdev->lDeltaScreen / ppdev->iBytesPerPixel);
		sizl.cy = (32 * 32) / sizl.cx;
		if ( (sizl.cx * sizl.cy) < (32 * 32) )
		{
			sizl.cy++;
		}
		dwPitch = 32 * ppdev->iBytesPerPixel;
	}
#endif

#if DRIVER_5465 && defined(OVERLAY)
    // Adjust the overlay surface request size with pixel format 
    if (bOverlaySurf)
    {
       unsigned long  OvlyBPP;

       if (bYUVsurf)
          OvlyBPP = lpSurface->lpGbl->ddpfSurface.dwYUVBitCount/8;
       else
          OvlyBPP = lpSurface->lpGbl->ddpfSurface.dwRGBBitCount/8;

       if (OvlyBPP > BYTESPERPIXEL)
          sizl.cx = (sizl.cx * OvlyBPP) / BYTESPERPIXEL;
    };
#endif  // #if DRIVER_5465 && defined(OVERLAY)

    // At certain modes (eg 1280x1024x24), When you runs MOV or AVI from
    // desktop, the DD CreateSurface has to punt the request back to DD 
    // due to no offscreen memmory available. When you hit ALT-ENTER to
    // go full screen, the appl swithces to mode (320x240x8 or 320x200x8),
    // create DD surfaces and then directly write to the DD surfaces.
    // Unfortunely, in those modes the pitch is 640 but the appl assumes
    // the pitch is 320 and we got half screen of the imagine.
    //
    // To fix the problem, just fails the create surface for those 
    // particule request.
    //
    puntflag = FALSE;
    if (ppdev->iBytesPerPixel == 1)
    {
       if ((ppdev->cxScreen == 320) && (sizl.cx == 320))
       {
          if (((ppdev->cyScreen == 240) && (sizl.cy == 240)) ||
              ((ppdev->cyScreen == 200) && (sizl.cy == 200)))
          {
             // Punt the create surface cause FlipCube FPS exceeds the
             // refresh rate.
             // So in order to bypass the above problem, it is looking for
             // bPrevModeDDOutOfVideoMem to be set when create surface fails
             // due to out of video memory in the previous mode before
             // punting the request.
             if (ppdev->bPrevModeDDOutOfVideoMem)
                puntflag = TRUE;
          };
       };
    };

    if (!puntflag)
    {
#if DRIVER_5465 && defined(OVERLAY)
		if (bOverlaySurf)
		{
			hdl = AllocOffScnMem(ppdev, &sizl, EIGHT_BYTES_ALIGN, NULL);
		}
		else
#endif  // #if DRIVER_5465 && defined(OVERLAY)
			hdl = AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);

#if 1 // PC98
		if (!bOverlaySurf)
#endif
       // Somehow when allocate the bottom of the offscreen memory to
       // DirectDraw, it hangs the DirectDraw.
       // The following is temporary patch fix for the problem
       {
         BOOL   gotit;
         ULONG  val;
         ULONG  fpvidmem;

         val = ppdev->lTotalMem - 0x20000;
         gotit = FALSE;
         while ((!gotit) && (hdl != NULL))
         {
            fpvidmem  = (hdl->aligned_y * ppdev->lDeltaScreen) + hdl->aligned_x;

            if (fpvidmem > val)
            {
               pds = (DDOFM *) MEM_ALLOC (FL_ZERO_MEMORY, sizeof(DDOFM), ALLOC_TAG);
               if (pds==NULL) 
               {
                    FreeOffScnMem(ppdev, hdl);
                    lpInput->ddRVal = DDERR_OUTOFMEMORY;
                    return DDHAL_DRIVER_NOTHANDLED;
               }
               pds->prevhdl = 0;
               pds->nexthdl = 0;
               pds->phdl = hdl;

               InsertInDDOFSQ(ppdev, pds);
               hdl = AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);
            }
            else
            {
               gotit = TRUE;
            };
         };  // endwhile
       }

       lpSurface->dwReserved1 = 0;

       if (hdl != NULL)
       {
#ifdef WINNT_VER40
          if ((pds = (DDOFM *) MEM_ALLOC (FL_ZERO_MEMORY, sizeof(DDOFM), ALLOC_TAG)) != NULL)
#else
          if ((pds = (DDOFM *) MEM_ALLOC (LPTR, sizeof(DDOFM))) != NULL)
#endif
          {
             ppdev->bPrevModeDDOutOfVideoMem = FALSE;

             // If pixel format is difference from FB, set the flag
             if (lpInput->lpDDSurfaceDesc->dwFlags & DDSD_PIXELFORMAT)
             {
                lpSurface->dwFlags |= DDRAWISURF_HASPIXELFORMAT;
             };

//           lpSurface->lpGbl->fpVidMem = DDHAL_PLEASEALLOC_BLOCKSIZE;
             if (bYUVsurf)
             {
                lpSurface->lpGbl->ddpfSurface.dwYUVBitCount = 16;
                lpSurface->lpGbl->ddpfSurface.dwYBitMask = (DWORD) -1;
                lpSurface->lpGbl->ddpfSurface.dwUBitMask = (DWORD) -1;
                lpSurface->lpGbl->ddpfSurface.dwVBitMask = (DWORD) -1;
                lpSurface->lpGbl->dwBlockSizeX = lpSurface->lpGbl->wWidth;
                lpSurface->lpGbl->dwBlockSizeY = lpSurface->lpGbl->wHeight;
                lpSurface->dwFlags |= DDRAWISURF_HASPIXELFORMAT;
             }; // endif (bYUVsurf)

#if DRIVER_5465 && defined(OVERLAY)
             if (bOverlaySurf)
             {
#if DDRAW_COMPAT >= 50
               if (lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
#endif
               {
                 HRESULT hResult;

#if 1 // PDR#11184
// Finally... When overlays are turned on, 256-byte fetch should be turned off.
					if (pDriverData->dwOverlayCount++ == 0)
					{
						Set256ByteFetch(ppdev, FALSE);
					}
#endif

                 lpSurface->dwReserved1 = (DWORD) pds;
                 hResult = pDriverData->OverlayTable.pfnCreateSurface(ppdev,
                                                                      lpSurface,
                                                                      dwFourCC);

                 if (DD_OK != hResult)
                 {
					#if 1 // PDR#11184
					// Decrement overlay counter and maybe turn 256-byte fetch
					// back on.
					if (--pDriverData->dwOverlayCount == 0)
					{
						Set256ByteFetch(ppdev, TRUE);
					}
					#endif

                   // Free the allocated offscreen memory
                   FreeOffScnMem(ppdev, hdl);

                   // Free allocated DDOFM structure from host memory
            	    MEMORY_FREE(pds);

                   lpSurface->dwReserved1 = 0;

                   lpInput->ddRVal = hResult;
                   return DDHAL_DRIVER_HANDLED;
                 }
               }

// don't need this for NT yet
#if 0
               // if the surface width is larger than the display pitch, or
               // its a 5465, and a videoport surface wider than 2048 bytes or
               // its a CLPL surface
               // then convert to a linear allocation
               //
               // prior to DX5 we never even get called for surfaces wider than 
               // the display pitch

               if (   (FOURCC_YUVPLANAR == dwFourCC)
#if DDRAW_COMPAT >= 50
                   || (lpSurface->lpGbl->dwBlockSizeX > pDriverData->ScreenPitch)
                   || (   (CL_GD5465 == pDriverData->dwLgVenDevID)
                       && (DDSCAPS_VIDEOPORT & lpDDSurfaceDesc->ddsCaps.dwCaps)
                       && (2048 <= pDriverData->ScreenPitch)
                      )
#endif
                  )
               {
                 // fake a linear space in rectangular memory
                 LP_SURFACE_DATA   lpSurfaceData = (LP_SURFACE_DATA)(lpSurface->dwReserved1);
                 DWORD             dwTotalBytes;
                 DWORD             dwNumScanLines;

                 lpSurfaceData->dwOverlayFlags |= FLG_LINEAR;

                 // CLPL surfaces need 3/4 of the space an equivalent size
                 // YUV422 surface would need, the space allocated for the
                 // Y values is the width * height and the space for the UV
                 // interleaved values is half again as much.  Pad the Y
                 // region so the UV interleaved data is on a qword boundary
                 // in aperture 0
                 if (FOURCC_YUVPLANAR == dwFourCC)
                 {
                   // compute space needed for Y values
                   dwTotalBytes = ((lpSurface->lpGbl->wHeight * lpSurface->lpGbl->wWidth) + 7) & ~7;

                   // add on space for UV interleaved values
                   dwTotalBytes += dwTotalBytes / 2;

                   // CLPL surfaces have pitch same as width
                   lpSurface->lpGbl->lPitch = lpSurface->lpGbl->wWidth;
                 }
                 // the normal case
                 else
                 {
                   dwTotalBytes = lpSurface->lpGbl->dwBlockSizeY *
                                  lpSurface->lpGbl->dwBlockSizeX;

                   lpSurface->lpGbl->lPitch = lpSurface->lpGbl->dwBlockSizeX;
                 }

                 dwNumScanLines = (dwTotalBytes + pDriverData->ScreenPitch - 1) /
                                  pDriverData->ScreenPitch;

                 lpSurface->lpGbl->dwBlockSizeY = dwNumScanLines;
                 lpSurface->lpGbl->dwBlockSizeX = pDriverData->ScreenPitch;

                 if (! pDriverData->fWeAllocDDSurfaces)
                 {
                   LOAD_THE_STILL(lpSurface->lpGbl->dwBlockSizeX,
                                  lpSurface->lpGbl->dwBlockSizeY);
                 }
                 lpSurface->lpGbl->fpVidMem = DDHAL_PLEASEALLOC_BLOCKSIZE;
               }
#endif  // if 0
             };  // endif (bOverlaySurf)
#endif  // #if DRIVER_5465 && defined(OVERLAY)

             pds->prevhdl = 0;
             pds->nexthdl = 0;
             pds->phdl = hdl;

             InsertInDDOFSQ(ppdev, pds);

             lpSurface->lpGbl->fpVidMem  = (hdl->aligned_y * ppdev->lDeltaScreen) +
                                           hdl->aligned_x;

             lpSurface->dwReserved1 = (DWORD) pds ;
             lpSurface->lpGbl->xHint = hdl->aligned_x/ppdev->iBytesPerPixel;
             lpSurface->lpGbl->yHint = hdl->aligned_y;
#if 1 // PC98
			if (dwPitch)
			{
				lpSurface->lpGbl->lPitch = dwPitch;
			}
			else
#endif
             lpSurface->lpGbl->lPitch = ppdev->lDeltaScreen;

#if 1 // PC98
			if (dwPitch)
			{
				lpDDSurfaceDesc->lPitch = dwPitch;
			}
			else
#endif
             lpDDSurfaceDesc->lPitch   = ppdev->lDeltaScreen;
             lpDDSurfaceDesc->dwFlags |= DDSD_PITCH;

             // We handled the creation entirely ourselves, so we have to
             // set the return code and return DDHAL_DRIVER_HANDLED:
             lpInput->ddRVal = DD_OK;
          }
          else
          {
             FreeOffScnMem(ppdev, hdl);
             lpInput->ddRVal = DDERR_OUTOFMEMORY;
             return DDHAL_DRIVER_NOTHANDLED;
          };
       }
       else
       {
          ppdev->bPrevModeDDOutOfVideoMem = TRUE;

          lpInput->ddRVal = DDERR_OUTOFVIDEOMEMORY;
          return DDHAL_DRIVER_NOTHANDLED;

//          lpSurface->lpGbl->lPitch = (ppdev->iBytesPerPixel * sizl.cx + 3) & ~3;
//          lpSurface->lpGbl->dwUserMemSize = lpSurface->lpGbl->lPitch * sizl.cy;

//          if (bYUVsurf)
//             lpSurface->lpGbl->fpVidMem |= DDHAL_PLEASEALLOC_USERMEM;
       };  // if (hdl != NULL)
    }  // endif (puntflag)

    lplpSurface++;
  };  // endfor

  if (puntflag)
  {
     lpInput->ddRVal = DDERR_GENERIC;
     return DDHAL_DRIVER_HANDLED;
  };

  if (hdl != NULL)
  {
     lpInput->ddRVal = DD_OK;
     return DDHAL_DRIVER_HANDLED;
  }
  else
  {
     return DDHAL_DRIVER_NOTHANDLED;
  };
};  //  // Support for 5465

#endif // ALLOC_IN_CREATESURFACE

#else
{ // Support for 5462 or 5464

  // Do nothing except fill in the block size for YUV surfaces.
  // We tag and count the video surfaces in Blt32.
  if (lpInput->lpDDSurfaceDesc->dwFlags & DDSD_PIXELFORMAT)
  {
     // only support alternate pixel format in 8 & 16 bpp frame buffers
     if ((8 != BITSPERPIXEL) && (16 != BITSPERPIXEL))
     {
        lpInput->ddRVal = DDERR_INVALIDPIXELFORMAT;
        return DDHAL_DRIVER_HANDLED;
     };

     // Specify the block size for non-RGB surfaces
     if (lpFormat->dwFlags & DDPF_FOURCC)
     {
        #if _WIN32_WINNT >= 0x0500
           // For NT5, do not allow any YUV surfaces for 5462 and 5464
           lpInput->ddRVal = DDERR_INVALIDPIXELFORMAT;
           return DDHAL_DRIVER_HANDLED;
        #endif

        // YUV422 surface
        if (lpFormat->dwFourCC == FOURCC_UYVY)
        {
           PDD_SURFACE_LOCAL  *lplpSurface;
           unsigned int i;

           GRAB_VIDEO_FORMAT_SEMAPHORE(&(pDriverData->VideoSemaphore));
           if (0 == pDriverData->NumVideoSurfaces)
           {
              // no video surfaces so we can create anu format we want
              pDriverData->NumVideoSurfaces += (WORD)lpInput->dwSCnt;
              pDriverData->CurrentVideoFormat &= 0xFF00;

              pDriverData->CurrentVideoFormat |= FMT_VID_16BPP | FMT_VID_YUV422;

              if (2 == BYTESPERPIXEL)
              {
                 pDriverData->CurrentVideoFormat |= FMT_VID_GAMMA;
                 SetGamma(ppdev, pDriverData);
              };

              ppdev->grFORMAT = (ppdev->grFORMAT & 0xFF00) |
                                (pDriverData->CurrentVideoFormat & 0x00FF);

              LL16(grFormat, ppdev->grFORMAT);

              if (TRUE == pDriverData->fNineBitRDRAMS)
              {
                 LL8(grStop_BLT_2, ENABLE_VIDEO_FORMAT);
                 LL8(grExternal_Overlay, ENABLE_RAMBUS_9TH_BIT);
              }
              else // 8 bit RDRAMs
              {
                 LL8(grStart_BLT_2, ENABLE_VIDEO_FORMAT | ENABLE_VIDEO_WINDOW);
                 LL8(grStop_BLT_2,  ENABLE_VIDEO_FORMAT | ENABLE_VIDEO_WINDOW);
              };
           }
           else
           {
              if ((FMT_VID_16BPP | FMT_VID_YUV422) == pDriverData->CurrentVideoFormat)
              {
                 pDriverData->NumVideoSurfaces += (WORD)lpInput->dwSCnt;
              }
              else
              {
                 UNGRAB_VIDEO_FORMAT_SEMAPHORE(&(pDriverData->VideoSemaphore));
                 lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
                 return DDHAL_DRIVER_HANDLED;
              };
           };  // endif (0 == pDriverData->NumVideoSurfaces)

           UNGRAB_VIDEO_FORMAT_SEMAPHORE(&(pDriverData->VideoSemaphore));

           SET_DRVSEM_YUV();
           ppdev->bYUVSurfaceOn = TRUE;

           bYUVsurf = TRUE;

           // They may have specified multiple surfaces
           lplpSurface = lpInput->lplpSList;
           for (i = 0; i < lpInput->dwSCnt; i++)
           {
             PDD_SURFACE_LOCAL lpSurface = *lplpSurface;

             lpSurface->lpGbl->ddpfSurface.dwYUVBitCount = 16;
             lpSurface->lpGbl->ddpfSurface.dwYBitMask = (DWORD) -1;
             lpSurface->lpGbl->ddpfSurface.dwUBitMask = (DWORD) -1;
             lpSurface->lpGbl->ddpfSurface.dwVBitMask = (DWORD) -1;
             lpSurface->lpGbl->lPitch = ppdev->lDeltaScreen;

             if (CL_GD5462 == ppdev->dwLgDevID)
                lpSurface->lpGbl->dwBlockSizeX = lpSurface->lpGbl->wWidth << 1;
             else
                lpSurface->lpGbl->dwBlockSizeX = lpSurface->lpGbl->wWidth * 3;

             lpSurface->lpGbl->dwBlockSizeY = lpSurface->lpGbl->wHeight;

             lpSurface->lpGbl->fpVidMem = DDHAL_PLEASEALLOC_BLOCKSIZE;

             lplpSurface++;
           };  // endfor
        }; // endif (lpFormat->dwFourCC == FOURCC_UYVY)
     };  // endif (lpFormat->dwFlags & DDPF_FOURCC)
  }  // endif (lpInput->lpDDSurfaceDesc->dwFlags & DDSD_PIXELFORMAT)

#ifdef ALLOC_IN_CREATESURFACE
  {
    PDD_SURFACE_LOCAL  *lplpSurface;
    SIZEL   sizl;
    OFMHDL  *hdl;
    DDOFM   *pds;
    DWORD   i;

    lplpSurface = lpInput->lplpSList;
    for (i = 0; i < lpInput->dwSCnt; i++)
    {
      PDD_SURFACE_LOCAL lpSurface = *lplpSurface;

      if (bYUVsurf)
      {
         sizl.cx = lpSurface->lpGbl->dwBlockSizeX/ppdev->iBytesPerPixel;
         sizl.cy = lpSurface->lpGbl->dwBlockSizeY;
         lpSurface->dwFlags |= DDRAWISURF_HASPIXELFORMAT;
      }
      else
      {
         sizl.cx = lpSurface->lpGbl->wWidth;
         sizl.cy = lpSurface->lpGbl->wHeight;
      };

      hdl = AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);

      // Somehow when allocate the bottom of the offscreen memory to
      // DirectDraw, it hangs the DirectDraw.
      // The following is temporary patch fix for the problem
      {
        BOOL   gotit;
        ULONG  val;
        ULONG  fpvidmem;

        val = ppdev->lTotalMem - 0x20000;
        gotit = FALSE;
        while ((!gotit) && (hdl != NULL))
        {
           fpvidmem  = (hdl->aligned_y * ppdev->lDeltaScreen) + hdl->aligned_x;

           if (fpvidmem > val)
           {
              pds = (DDOFM *) MEM_ALLOC (FL_ZERO_MEMORY, sizeof(DDOFM), ALLOC_TAG);
              if (pds==NULL) 
              {
                  FreeOffScnMem(ppdev, hdl);
                  lpInput->ddRVal = DDERR_OUTOFMEMORY;
                  return DDHAL_DRIVER_NOTHANDLED;
              }
              pds->prevhdl = 0;
              pds->nexthdl = 0;
              pds->phdl = hdl;

              InsertInDDOFSQ(ppdev, pds);
              hdl = AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);
           }
           else
           {
              gotit = TRUE;
           };
        };  // endwhile
      }

      lpSurface->dwReserved1 = 0;

      if (hdl != NULL)
      {
#ifdef WINNT_VER40
         if ((pds = (DDOFM *) MEM_ALLOC (FL_ZERO_MEMORY, sizeof(DDOFM), ALLOC_TAG)) != NULL)
#else
         if ((pds = (DDOFM *) MEM_ALLOC (LPTR, sizeof(DDOFM))) != NULL)
#endif
         {
            pds->prevhdl = 0;
            pds->nexthdl = 0;
            pds->phdl = hdl;

            InsertInDDOFSQ(ppdev, pds);

            lpSurface->lpGbl->fpVidMem  = (hdl->aligned_y * ppdev->lDeltaScreen) +
                                          hdl->aligned_x;

            lpSurface->dwReserved1 = (DWORD) pds ;
            lpSurface->lpGbl->xHint = hdl->aligned_x/ppdev->iBytesPerPixel;
            lpSurface->lpGbl->yHint = hdl->aligned_y;
            lpSurface->lpGbl->lPitch = ppdev->lDeltaScreen;

            lpDDSurfaceDesc->lPitch   = ppdev->lDeltaScreen;
            lpDDSurfaceDesc->dwFlags |= DDSD_PITCH;

            // We handled the creation entirely ourselves, so we have to
            // set the return code and return DDHAL_DRIVER_HANDLED:
            lpInput->ddRVal = DD_OK;
         }
         else
         {
            FreeOffScnMem(ppdev, hdl);
         };
      };  // if (hdl != NULL)

      lplpSurface++;
    };  // endfor

    if (hdl != NULL)
       return DDHAL_DRIVER_HANDLED;
    else
       return DDHAL_DRIVER_NOTHANDLED;
  };
#endif // ALLOC_IN_CREATESURFACE
} // Support for 5462 or 5464

#endif  // DRIVER_5465

  return DDHAL_DRIVER_NOTHANDLED;
} // CreateSurface


/****************************************************************************
* FUNCTION NAME: DestroySurface
*
* DESCRIPTION:
*                (Based on Laguna Win95 DirectDraw code)
****************************************************************************/
DWORD DestroySurface (PDD_DESTROYSURFACEDATA lpInput)
{
  PDD_SURFACE_LOCAL  lpLocalSurface;
  DRIVERDATA* pDriverData;
  PDEV*       ppdev;
  DDOFM       *hdl;

  DISPDBG((DBGLVL, "DDraw - DestroySurface\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  ppdev = (PDEV*) lpInput->lpDD->dhpdev;
  pDriverData = (DRIVERDATA*) &ppdev->DriverData;
  lpLocalSurface = lpInput->lpDDSurface;

#if DRIVER_5465
{ // Support for 5465
#if DRIVER_5465 && defined(OVERLAY)
	// check for overlay surface
	if (lpInput->lpDDSurface->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
	{
		pDriverData->OverlayTable.pfnDestroySurface(ppdev,lpInput);
#if 1 // PDR#11184
		// Enable 256-byte fetch if the last overlay surface has been destroyed.
		if (--pDriverData->dwOverlayCount == 0)
		{
			Set256ByteFetch(ppdev, TRUE);
		}
#endif
	}

#endif
} // Support for 5465

#else
{ // Support for 5462 or 5464

  if (DDRAWISURF_HASPIXELFORMAT & lpInput->lpDDSurface->dwFlags)
  {
     LPDDPIXELFORMAT lpFormat = &lpInput->lpDDSurface->lpGbl->ddpfSurface;

     if (DDPF_FOURCC & lpFormat->dwFlags)
     {
        if (FOURCC_UYVY == lpFormat->dwFourCC)
        {
           GRAB_VIDEO_FORMAT_SEMAPHORE(&(pDriverData->VideoSemaphore));

           if (0 == --pDriverData->NumVideoSurfaces)
           {
              CLR_DRVSEM_YUV();

              // disable stuff if there's no more video windows
              pDriverData->CurrentVideoFormat = pDriverData->CurrentVideoFormat & 0xFF00;

              // These trash the video window left on screen
              //pDriverData->grFormat = pREG->grFormat & 0xFF00;
              //pDriverData->grStop_BLT_2 &= ~ENABLE_VIDEO_FORMAT;
              //pDriverData->grExternal_Overlay &= ~ENABLE_RAMBUS_9TH_BIT;
           }; // endif (0 == --pDriverData->NumVideoSurfaces)

           UNGRAB_VIDEO_FORMAT_SEMAPHORE(&(pDriverData->VideoSemaphore));

#ifdef RDRAM_8BIT
           if (FALSE == pDriverData->fNineBitRDRAMS)
           {
              // Need to Delete Rectangle and Clear Window
              ppdev->offscr_YUV.nInUse = FALSE;
              LL16(grX_Start_2, 0);
              LL16(grY_Start_2, 0);
              LL16(grX_End_2, 0);
              LL16(grY_End_2, 0);
           };
#endif
        }; // endif (FOURCC_UYVY == lpFormat->dwFourCC)
     };  // endif (DDPF_FOURCC & lpFormat->dwFlags)
  };  // endif (DDRAWISURF_HASPIXELFORMAT & lpInput->lpDDSurface->dwFlags)

} // Support for 5462 or 5464
#endif  // #endif DRIVER_5465


#ifdef ALLOC_IN_CREATESURFACE
  if (lpLocalSurface->dwReserved1 != 0)
  {
     hdl = (DDOFM *) lpLocalSurface->dwReserved1;
     FreeOffScnMem(ppdev, hdl->phdl);
     RemoveFrmDDOFSQ(ppdev, hdl);
     lpLocalSurface->dwReserved1 = 0;
  };

  lpInput->ddRVal = DD_OK;

  return DDHAL_DRIVER_HANDLED;
#endif // ALLOC_IN_CREATESURFACE

  return DDHAL_DRIVER_NOTHANDLED;

} // DestroySurface

#if DRIVER_5465 && defined(OVERLAY)
/***************************************************************************
*
* FUNCTION:     GetFormatInfo()
*
* DESCRIPTION:  This returns the FOURCC and the bit depth of the specified
*               format.  This is useful since DirectDraw has so many
*               different ways to determine the format.
*
****************************************************************************/

VOID
GetFormatInfo (LPDDPIXELFORMAT lpFormat, LPDWORD lpFourcc, LPDWORD lpBitCount)
{
  if (lpFormat->dwFlags & DDPF_FOURCC)
  {
    *lpFourcc = lpFormat->dwFourCC;
    if (lpFormat->dwFourCC == BI_RGB)
    {
      *lpBitCount = lpFormat->dwRGBBitCount;
#ifdef DEBUG
      if (lpFormat->dwRGBBitCount == 8)
      {
        DBG_MESSAGE(("Format: RGB 8"));
      }
      else if (lpFormat->dwRGBBitCount == 16)
      {
        DBG_MESSAGE(("Format: RGB 5:5:5"));
      }
#endif
    }
    else if (lpFormat->dwFourCC == BI_BITFIELDS)
    {
      if ((lpFormat->dwRGBBitCount != 16) ||
          (lpFormat->dwRBitMask != 0xf800) ||
          (lpFormat->dwGBitMask != 0x07e0) ||
          (lpFormat->dwBBitMask != 0x001f))
      {
        *lpFourcc = (DWORD) -1;
      }
      else
      {
        *lpBitCount = 16;
        DBG_MESSAGE(("Format: RGB 5:6:5"));
      }
    }
    else
    {
      lpFormat->dwRBitMask = (DWORD) -1;
      lpFormat->dwGBitMask = (DWORD) -1;
      lpFormat->dwBBitMask = (DWORD) -1;
      if (FOURCC_YUVPLANAR == lpFormat->dwFourCC)
      {
        *lpBitCount = 8;
        DBG_MESSAGE(("Format: CLPL"));
      }
      else
      {
        *lpBitCount = 16;
        DBG_MESSAGE(("Format: UYVY"));
      }
    }
  }
  else if (lpFormat->dwFlags & DDPF_RGB)
  {
    if (lpFormat->dwRGBBitCount == 8)
    {
      *lpFourcc = BI_RGB;
      DBG_MESSAGE(("Format: RGB 8"));
    }
    else if ((lpFormat->dwRGBBitCount == 16)  &&
             (lpFormat->dwRBitMask == 0xf800) &&
             (lpFormat->dwGBitMask == 0x07e0) &&
             (lpFormat->dwBBitMask == 0x001f))
    {
      *lpFourcc = BI_BITFIELDS;
      DBG_MESSAGE(("Format: RGB 5:6:5"));
    }
    else if ((lpFormat->dwRGBBitCount == 16)  &&
             (lpFormat->dwRBitMask == 0x7C00) &&
             (lpFormat->dwGBitMask == 0x03e0) &&
             (lpFormat->dwBBitMask == 0x001f))
    {
      *lpFourcc = BI_RGB;
      DBG_MESSAGE(("Format: RGB 5:5:5"));
    }
    else if (((lpFormat->dwRGBBitCount == 24) ||
              (lpFormat->dwRGBBitCount == 32))  &&
             (lpFormat->dwRBitMask == 0xff0000) &&
             (lpFormat->dwGBitMask == 0x00ff00) &&
             (lpFormat->dwBBitMask == 0x0000ff))
    {
      *lpFourcc = BI_RGB;
      DBG_MESSAGE(("Format: RGB 8:8:8"));
    }
    else
    {
      *lpFourcc = (DWORD) -1;
    }
    *lpBitCount = lpFormat->dwRGBBitCount;
  }
  else if (DDPF_PALETTEINDEXED4 & lpFormat->dwFlags)
  {
    *lpFourcc = (DWORD)-1;
    *lpBitCount = 4;
  }
  else if (DDPF_PALETTEINDEXED8 & lpFormat->dwFlags)
  {
    *lpFourcc = (DWORD)-1;
    *lpBitCount = 8;
  }
  else if (lpFormat->dwRGBBitCount == 16)
  {
    *lpFourcc = BI_RGB;
    *lpBitCount = lpFormat->dwRGBBitCount;    // always 16 for now.
  }
  else
  {
    *lpFourcc = (DWORD) -1;
    *lpBitCount = 0;
  }
}
#endif // DRIVER_5465 && OVERLAY

#endif // ! ver 3.51




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\ddraw.c ===
/***************************************************************************
*
*                ******************************************
*                * Copyright (c) 1996, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:  Laguna I (CL-GD546x) -
*
* FILE:     ddraw.c
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This module implements the DirectDraw components for the
*           Laguna NT driver.
*
* MODULES:
*           DdMapMemory()
*           DrvGetDirectDrawInfo()
*           DrvEnableDirectDraw()
*           DrvDisableDirectDraw()
*
* REVISION HISTORY:
*   7/12/96     Benny Ng      Initial version
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/ddraw.c  $
* 
*    Rev 1.25   Apr 16 1998 15:19:50   frido
* PDR#11160. The hardware is broken converting 16-bit YUV to 24-bit RGB.
* 
*    Rev 1.24   16 Sep 1997 15:01:24   bennyn
* 
* Modified for NT DD overlay
* 
*    Rev 1.23   29 Aug 1997 17:11:54   RUSSL
* Added overlay support
*
*    Rev 1.22   12 Aug 1997 16:57:10   bennyn
*
* Moved the DD scratch buffer allocation to bInitSurf()
*
*    Rev 1.21   11 Aug 1997 14:06:10   bennyn
* Added DDCAPS_READSCANLINE support (For PDR 10254)
*
****************************************************************************
****************************************************************************/

/*----------------------------- INCLUDES ----------------------------------*/
#include "precomp.h"
#include "clioctl.h"
//#include <driver.h>
//#include "laguna.h"

//
// This file isn't used in NT 3.51
//
#ifndef WINNT_VER35

/*----------------------------- DEFINES -----------------------------------*/
//#define DBGBRK
#define DBGLVL        1

// FourCC formats are encoded in reverse because we're little endian:
#define FOURCC_YUY2  '2YUY'  // Encoded in reverse because we're little endian

#define SQXINDEX (0x3c4)
#define RDRAM_INDEX (0x0a)
#define BIT_9 (0x80)

/*--------------------- STATIC FUNCTION PROTOTYPES ------------------------*/

/*--------------------------- ENUMERATIONS --------------------------------*/

/*----------------------------- TYPEDEFS ----------------------------------*/

/*-------------------------- STATIC VARIABLES -----------------------------*/

/*-------------------------- GLOBAL FUNCTIONS -----------------------------*/

/****************************************************************************
* FUNCTION NAME: DdMapMemory
*
* DESCRIPTION:   This is a new DDI call specific to Windows NT that is
*                used to map or unmap all the application modifiable
*                portions of the frame buffer into the specified process's
*                address space.
****************************************************************************/
DWORD DdMapMemory(PDD_MAPMEMORYDATA lpMapMemory)
{
  PDEV*                           ppdev;
  VIDEO_SHARE_MEMORY              ShareMemory;
  VIDEO_SHARE_MEMORY_INFORMATION  ShareMemoryInformation;
  DWORD                           ReturnedDataLength;

  ppdev = (PDEV*) lpMapMemory->lpDD->dhpdev;

  DISPDBG((DBGLVL, "DDraw - DdMapMemory\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  ShareMemory.ProcessHandle = lpMapMemory->hProcess;

  if (lpMapMemory->bMap)
  {
     // 'RequestedVirtualAddress' isn't actually used for the SHARE IOCTL:
     ShareMemory.RequestedVirtualAddress = 0;

     // We map in starting at the top of the frame buffer:
     ShareMemory.ViewOffset = 0;

     // We map down to the end of the frame buffer.
     //
     // Note: There is a 64k granularity on the mapping (meaning that
     //       we have to round up to 64k).
     //
     // Note: If there is any portion of the frame buffer that must
     //       not be modified by an application, that portion of memory
     //       MUST NOT be mapped in by this call.  This would include
     //       any data that, if modified by a malicious application,
     //       would cause the driver to crash.  This could include, for
     //       example, any DSP code that is kept in off-screen memory.

// v-normmi
// ShareMemory.ViewSize = ROUND_UP_TO_64K(ppdev->cyMemory * ppdev->lDeltaScreen);
   ShareMemory.ViewSize = ROUND_UP_TO_64K(ppdev->cyMemoryReal * ppdev->lDeltaScreen);

     if (EngDeviceIoControl(ppdev->hDriver,
                            IOCTL_VIDEO_SHARE_VIDEO_MEMORY,
                            &ShareMemory,
                            sizeof(VIDEO_SHARE_MEMORY),
                            &ShareMemoryInformation,
                            sizeof(VIDEO_SHARE_MEMORY_INFORMATION),
                            &ReturnedDataLength))
     {
         DISPDBG((0, "DDraw - Failed IOCTL_VIDEO_SHARE_MEMORY"));

         lpMapMemory->ddRVal = DDERR_GENERIC;
         return(DDHAL_DRIVER_HANDLED);
     };

     lpMapMemory->fpProcess = (DWORD) ShareMemoryInformation.VirtualAddress;
  }
  else
  {
     ShareMemory.ViewOffset    = 0;
     ShareMemory.ViewSize      = 0;
     ShareMemory.RequestedVirtualAddress = (VOID*) lpMapMemory->fpProcess;

     if (EngDeviceIoControl(ppdev->hDriver,
                            IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY,
                            &ShareMemory,
                            sizeof(VIDEO_SHARE_MEMORY),
                            NULL,
                            0,
                            &ReturnedDataLength))
     {
         DISPDBG((0, "DDraw - Failed IOCTL_VIDEO_SHARE_MEMORY"));
     };
  };

  lpMapMemory->ddRVal = DD_OK;

  return(DDHAL_DRIVER_HANDLED);
}


/****************************************************************************
* FUNCTION NAME: DrvGetDirectDrawInfo
*
* DESCRIPTION:   Will be called before DrvEnableDirectDraw is called.
****************************************************************************/
BOOL DrvGetDirectDrawInfo(DHPDEV       dhpdev,
                          DD_HALINFO*  pHalInfo,
                          DWORD*       pdwNumHeaps,
                          VIDEOMEMORY* pvmList,   // Will be NULL on 1st call
                          DWORD*       pdwNumFourCC,
                          DWORD*       pdwFourCC) // Will be NULL on 1st call
{
  BOOL        bCanFlip;
  PDEV*       ppdev = (PDEV*) dhpdev;
  DRIVERDATA* pDriverData = (DRIVERDATA*) &ppdev->DriverData;
  POFMHDL     pds = NULL;

  DISPDBG((DBGLVL, "DDraw - DrvGetDirectDrawInfo\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  pHalInfo->dwSize = sizeof(DD_HALINFO);

  // Current primary surface attributes. Since HalInfo is zero-initialized
  // by GDI, we only have to fill in the fields which should be non-zero:
  pHalInfo->vmiData.pvPrimary       = ppdev->pjScreen;
  pHalInfo->vmiData.dwDisplayWidth  = ppdev->cxScreen;
  pHalInfo->vmiData.dwDisplayHeight = ppdev->cyScreen;
  pHalInfo->vmiData.lDisplayPitch   = ppdev->lDeltaScreen;

  pHalInfo->vmiData.ddpfDisplay.dwSize  = sizeof(DDPIXELFORMAT);
  pHalInfo->vmiData.ddpfDisplay.dwFlags = DDPF_RGB;

  pHalInfo->vmiData.ddpfDisplay.dwRGBBitCount = ppdev->ulBitCount;

  if (ppdev->iBitmapFormat == BMF_8BPP)
     pHalInfo->vmiData.ddpfDisplay.dwFlags |= DDPF_PALETTEINDEXED8;

  // These masks will be zero at 8bpp:
  pHalInfo->vmiData.ddpfDisplay.dwRBitMask = ppdev->flRed;
  pHalInfo->vmiData.ddpfDisplay.dwGBitMask = ppdev->flGreen;
  pHalInfo->vmiData.ddpfDisplay.dwBBitMask = ppdev->flBlue;

  // Set up the pointer to the first available video memory after
  // the primary surface:
  bCanFlip     = FALSE;
  *pdwNumHeaps = 0;

  // Free up as much off-screen memory as possible:
  // Now simply reserve the biggest chunk for use by DirectDraw:
  if ((pds = ppdev->DirectDrawHandle) == NULL)
  {
#if DRIVER_5465
    pds = DDOffScnMemAlloc(ppdev);
    ppdev->DirectDrawHandle = pds;
#else
     // Because the 24 BPP transparent BLT is broken, punt it
     if (ppdev->iBitmapFormat != BMF_24BPP)
     {
        pds = DDOffScnMemAlloc(ppdev);
        ppdev->DirectDrawHandle = pds;
     };
#endif  // DRIVER_5465
  };

  if (pds != NULL)
  {
     *pdwNumHeaps = 1;

     // Fill in the list of off-screen rectangles if we've been asked
     // to do so:
     if (pvmList != NULL)
     {
        DISPDBG((0, "DirectDraw gets %li x %li surface at (%li, %li)\n",
                     pds->sizex,
                     pds->sizey,
                     pds->x,
                     pds->y));

        pvmList->dwFlags  = VIDMEM_ISRECTANGULAR;
        pvmList->fpStart  = (pds->y * ppdev->lDeltaScreen) + pds->x;

        pvmList->dwWidth  = pds->sizex;
        pvmList->dwHeight = pds->sizey;
        pvmList->ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;

        if ((DWORD) ppdev->cyScreen <= pvmList->dwHeight)
           bCanFlip = TRUE;

     }; // if (pvmList != NULL)
//#ifdef ALLOC_IN_CREATESURFACE
//  }
//  else
//  {
//     *pdwNumHeaps = 1;
//
//     // Fill in the list of off-screen rectangles if we've been asked
//     // to do so:
//     if (pvmList != NULL)
//     {
//        pvmList->dwFlags  = VIDMEM_ISRECTANGULAR;
//        pvmList->fpStart  = (FLATPTR) ppdev->pjScreen;
//
//        pvmList->dwWidth  = 1;
//        pvmList->dwHeight = ppdev->lTotalMem;
//        pvmList->ddsCaps.dwCaps = 0;
//        pvmList->ddsCapsAlt.dwCaps = 0;
//     }; // if (pvmList != NULL)
//#endif
  }; // if (pds != NULL)

  // Capabilities supported:
  pHalInfo->ddCaps.dwCaps = 0
                          | DDCAPS_BLT
                          | DDCAPS_BLTCOLORFILL
						  ;

#if 1 // PDR#11160
  if (ppdev->iBitmapFormat != BMF_24BPP)
		pHalInfo->ddCaps.dwCaps |= DDCAPS_BLTFOURCC;
#endif

  // ReadScanLine only support in 5464 & 5465
  if (ppdev->dwLgDevID >= CL_GD5464)
     pHalInfo->ddCaps.dwCaps |= DDCAPS_READSCANLINE;

  #if DRIVER_5465
      pHalInfo->ddCaps.dwCaps = pHalInfo->ddCaps.dwCaps
                                  | DDCAPS_BLTSTRETCH
                                  ;

      if (ppdev->iBitmapFormat != BMF_24BPP)
      {
          pHalInfo->ddCaps.dwCaps = pHalInfo->ddCaps.dwCaps
                                  | DDCAPS_COLORKEY // NVH turned off for 24bpp  PDR #10142
                                  | DDCAPS_COLORKEYHWASSIST // NVH turned off for 24bpp PDR #10142
                                  ;
      }
  #else
      if (ppdev->iBitmapFormat != BMF_24BPP)
      {
         pHalInfo->ddCaps.dwCaps = pHalInfo->ddCaps.dwCaps
                                 | DDCAPS_COLORKEY
                                 | DDCAPS_COLORKEYHWASSIST;

         if (ppdev->iBitmapFormat != BMF_32BPP)
         {
            pHalInfo->ddCaps.dwCaps |= DDCAPS_BLTSTRETCH;
         };
      };
  #endif  // DRIVER_5465

  pHalInfo->ddCaps.dwCKeyCaps = 0;
  if (ppdev->iBitmapFormat != BMF_24BPP)
  {
      pHalInfo->ddCaps.dwCKeyCaps = pHalInfo->ddCaps.dwCKeyCaps
                                  | DDCKEYCAPS_SRCBLT   // NVH Turn off for 24bpp. PDR #10142
                                  | DDCKEYCAPS_DESTBLT  // NVH Turn off for 24bpp. PDR #10142
                                  ;
  }

  pHalInfo->ddCaps.ddsCaps.dwCaps = 0
                                  | DDSCAPS_OFFSCREENPLAIN
                                  | DDSCAPS_PRIMARYSURFACE
                                  ;
#ifndef ALLOC_IN_CREATESURFACE
  if (bCanFlip)
#endif
     pHalInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_FLIP;

#ifdef ALLOC_IN_CREATESURFACE
  // Since we do our own memory allocation, we have to set dwVidMemTotal
  // ourselves.  Note that this represents the amount of available off-
  // screen memory, not all of video memory:
  pHalInfo->ddCaps.dwVidMemFree = ppdev->lTotalMem -
                 (ppdev->cxScreen * ppdev->cyScreen * ppdev->iBytesPerPixel);

  pHalInfo->ddCaps.dwVidMemTotal = pHalInfo->ddCaps.dwVidMemFree;
#endif

#if DRIVER_5465
  pHalInfo->ddCaps.dwFXCaps = 0
                            | DDFXCAPS_BLTARITHSTRETCHY
                            | DDFXCAPS_BLTSTRETCHX
                            | DDFXCAPS_BLTSTRETCHXN
                            | DDFXCAPS_BLTSTRETCHY
                            | DDFXCAPS_BLTSTRETCHYN
                            | DDFXCAPS_BLTSHRINKX
                            | DDFXCAPS_BLTSHRINKY
                            ;
#else
  if ((ppdev->iBitmapFormat != BMF_24BPP) &&
      (ppdev->iBitmapFormat != BMF_32BPP))
  {
     pHalInfo->ddCaps.dwFXCaps = 0
                               | DDFXCAPS_BLTARITHSTRETCHY
                               | DDFXCAPS_BLTSTRETCHX
                               | DDFXCAPS_BLTSTRETCHXN
                               | DDFXCAPS_BLTSTRETCHY
                               | DDFXCAPS_BLTSTRETCHYN
                               | DDFXCAPS_BLTSHRINKX
                               | DDFXCAPS_BLTSHRINKY
                               ;
  };
#endif  // DRIVER_5465

  // FOURCCs supported
#if DRIVER_5465 && defined(OVERLAY)
  if (! QueryOverlaySupport(ppdev, ppdev->dwLgDevID))
#endif
  {
    *pdwNumFourCC = 1;
#if DRIVER_5465 && defined(OVERLAY)
    pDriverData->dwFourCC[0] = FOURCC_UYVY;
#else
    pDriverData->dwFourCC = FOURCC_UYVY;
#endif

    if (pdwFourCC != NULL)
    {
       *pdwFourCC = FOURCC_YUY2;
    }
  }

  // We have to tell DirectDraw our preferred off-screen alignment, even
  // if we're doing our own off-screen memory management:
  pHalInfo->vmiData.dwOffscreenAlign = 4;

  pHalInfo->vmiData.dwOverlayAlign = 0;
  pHalInfo->vmiData.dwTextureAlign = 0;
  pHalInfo->vmiData.dwZBufferAlign = 0;
  pHalInfo->vmiData.dwAlphaAlign = 0;

  pDriverData->RegsAddress = ppdev->pLgREGS;

#if DRIVER_5465 && defined(OVERLAY)
  if (QueryOverlaySupport(ppdev, ppdev->dwLgDevID))
  {
    // fill in overlay caps
    OverlayInit(ppdev, ppdev->dwLgDevID, NULL, pHalInfo);
  }
#endif

  return(TRUE);
} // DrvGetDirectDrawInfo


/****************************************************************************
* FUNCTION NAME: DrvEnableDirectDraw
*
* DESCRIPTION:   GDI calls this function to obtain pointers to the
*                DirectDraw callbacks that the driver supports.
****************************************************************************/
BOOL DrvEnableDirectDraw(DHPDEV               dhpdev,
                         DD_CALLBACKS*        pCallBacks,
                         DD_SURFACECALLBACKS* pSurfaceCallBacks,
                         DD_PALETTECALLBACKS* pPaletteCallBacks)
{
  SIZEL  sizl;
  PDEV*  ppdev = (PDEV*) dhpdev;
  DRIVERDATA* pDriverData = (DRIVERDATA*) &ppdev->DriverData;

  DISPDBG((DBGLVL, "DDraw - DrvEnableDirectDraw\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  #if (VS_CONTROL_HACK && DRIVER_5465)
  {
    DWORD ReturnedDataLength;

    DISPDBG((0,"DrvEnableDirectDraw: Enable MMIO for PCI config regs.\n"));
    // Send message to miniport to enable MMIO access of PCI registers
    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_ENABLE_PCI_MMIO,
                           NULL,
                           0,
                           NULL,
                           0,
                           &ReturnedDataLength))
    {
      RIP("DrvEnableDirectDraw failed IOCTL_VIDEO_ENABLE_PCI_MMIO");
    }
  }
  #endif

  pDriverData->ScreenAddress = ppdev->pjScreen;
  pDriverData->VideoBase = ppdev->pjScreen;

#if DRIVER_5465
#else  // for 5462 or 5464
  // Initialize the DRIVERDATA structure in PDEV
  pDriverData->PTAGFooPixel = 0;

  _outp(SQXINDEX, RDRAM_INDEX);
  pDriverData->fNineBitRDRAMS = _inp(SQXINDEX+1) & BIT_9 ? TRUE : FALSE;

  pDriverData->fReset = FALSE;
  pDriverData->DrvSemaphore = 0;
  pDriverData->EdgeTrim = 0;

  pDriverData->VideoSemaphore = 0;
  pDriverData->CurrentVideoFormat = 0;
  pDriverData->NumVideoSurfaces = 0;

  pDriverData->YUVTop  = 0;
  pDriverData->YUVLeft = 0;
  pDriverData->YUVXExt = 0;
  pDriverData->YUVYExt = 0;

  ppdev->offscr_YUV.SrcRect.left   = 0;
  ppdev->offscr_YUV.SrcRect.top    = 0;
  ppdev->offscr_YUV.SrcRect.right  = 0;
  ppdev->offscr_YUV.SrcRect.bottom = 0;
  ppdev->offscr_YUV.nInUse = 0;
  ppdev->offscr_YUV.ratio = 0;

  ppdev->bYUVuseSWPtr = TRUE;
#endif  // DRIVER_5465

  ppdev->bDirectDrawInUse = TRUE;

  // Setup DD Display list pointers
  BltInit (ppdev, FALSE);


  // Fill out the driver callback
  pCallBacks->dwFlags              = 0;

  pCallBacks->MapMemory            = DdMapMemory;
  pCallBacks->dwFlags              |= DDHAL_CB32_MAPMEMORY;

  pCallBacks->WaitForVerticalBlank = DdWaitForVerticalBlank;
  pCallBacks->dwFlags              |= DDHAL_CB32_WAITFORVERTICALBLANK;


  pCallBacks->CanCreateSurface     = CanCreateSurface;
  pCallBacks->dwFlags              |= DDHAL_CB32_CANCREATESURFACE;

  pCallBacks->CreateSurface        = CreateSurface;
  pCallBacks->dwFlags              |= DDHAL_CB32_CREATESURFACE;

// #ifdef  DDDRV_GETSCANLINE    //***********
  // ReadScanLine only support in 5464 & 5465
  if (ppdev->dwLgDevID >= CL_GD5464)
  {
     pCallBacks->GetScanLine       = GetScanLine;
     pCallBacks->dwFlags           |= DDHAL_CB32_GETSCANLINE;
  }
// #endif // DDDRV_GETSCANLINE   ************

  // Fill out the surface callback
  pSurfaceCallBacks->dwFlags       = 0;

#if DRIVER_5465
  pSurfaceCallBacks->Blt        = Blt65;
#else
  pSurfaceCallBacks->Blt        = DdBlt;
#endif  // DRIVER_5465

  pSurfaceCallBacks->dwFlags       |= DDHAL_SURFCB32_BLT;

  pSurfaceCallBacks->GetBltStatus  = DdGetBltStatus;
  pSurfaceCallBacks->dwFlags       |= DDHAL_SURFCB32_GETBLTSTATUS;

  pSurfaceCallBacks->Flip          = DdFlip;
  pSurfaceCallBacks->dwFlags       |= DDHAL_SURFCB32_FLIP;

  pSurfaceCallBacks->GetFlipStatus = DdGetFlipStatus;
  pSurfaceCallBacks->dwFlags       |= DDHAL_SURFCB32_GETFLIPSTATUS;

  pSurfaceCallBacks->Lock          = DdLock;
  pSurfaceCallBacks->dwFlags       |= DDHAL_SURFCB32_LOCK;

  pSurfaceCallBacks->Unlock        = DdUnlock;
  pSurfaceCallBacks->dwFlags       |= DDHAL_SURFCB32_UNLOCK;

  pSurfaceCallBacks->DestroySurface = DestroySurface;
  pSurfaceCallBacks->dwFlags       |= DDHAL_SURFCB32_DESTROYSURFACE;

#if DRIVER_5465 && defined(OVERLAY)
  if (QueryOverlaySupport(ppdev, ppdev->dwLgDevID))
  {
    // fill in overlay caps
    OverlayInit(ppdev, ppdev->dwLgDevID, pSurfaceCallBacks, NULL);
  }
#endif

  // Note that we don't call 'vGetDisplayDuration' here, for a couple of
  // reasons:
  //  o Because the system is already running, it would be disconcerting
  //    to pause the graphics for a good portion of a second just to read
  //    the refresh rate;
  //  o More importantly, we may not be in graphics mode right now.
  //
  // For both reasons, we always measure the refresh rate when we switch
  // to a new mode.

  return(TRUE);
}  // DrvEnableDirectDraw


/****************************************************************************
* FUNCTION NAME: DrvDisableDirectDraw
*
* DESCRIPTION:   GDI call this function when the last DirectDraw application
*                has finished running.
****************************************************************************/
VOID DrvDisableDirectDraw(DHPDEV dhpdev)
{
  DRIVERDATA* pDriverData;
  ULONG ultmp;

  PDEV* ppdev = (PDEV*) dhpdev;
  pDriverData = (DRIVERDATA*) &ppdev->DriverData;

  DISPDBG((DBGLVL, "DDraw - DrvDisableDirectDraw\n"));

#if 0
  #if (VS_CONTROL_HACK && DRIVER_5465)
  {
    // Clear bit 0 to disable PCI register MMIO access
    DISPDBG((0,"DrvDisableDirectDraw: Disable MMIO for PCI config regs.\n"));
    ppdev->grVS_CONTROL &= 0xFFFFFFFE;
    LL32 (grVS_Control, ppdev->grVS_CONTROL);
  }
  #endif
#endif

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

#if DRIVER_5465
#else  // for 5462 or 5464
  if (ppdev->bYUVuseSWPtr)
  {
     // Disable the Hw cursor by clearing the hw cursor enable
     // bit in CURSOR_CONTROL reg
     ultmp = LLDR_SZ (grCursor_Control);
     if (ultmp & 1)
     {
        ultmp &= 0xFFFE;
        LL16 (grCursor_Control, ultmp);
     };
  };
#endif  // DRIVER_5465

  // DirectDraw is done with the display, so we can go back to using
  // all of off-screen memory ourselves:
  DDOffScnMemRestore(ppdev);

  ppdev->bYUVSurfaceOn = FALSE;
  ppdev->bDirectDrawInUse = FALSE;

} // DrvDisableDirectDraw

#endif // ! ver3.51



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\debug.c ===
/******************************Module*Header*******************************\
* Module Name: debug.c
*
* debug helpers routine
*
* Copyright (c) 1992 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

#if DBG
  
ULONG DebugLevel = 0;

#endif // DBG

/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive debug print
 *      routine.
 *      If the specified debug level for the print statement is lower or equal
 *      to the current debug level, the message will be printed.
 *
 *   Arguments:
 *
 *      DebugPrintLevel - Specifies at which debugging level the string should
 *          be printed
 *
 *      DebugMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

#if DRIVER_5465

#define STANDARD_DEBUG_PREFIX "CL5465:"

#else // if DRIVER_5465

#define STANDARD_DEBUG_PREFIX "CL546X:"

#endif // if DRIVER_5465


VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

{

#if DBG

    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel) {

#ifdef WINNT_VER40
	     EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
#else
        char buffer[128];

        vsprintf(buffer, DebugMessage, ap);

        OutputDebugStringA(buffer);
#endif

    }

    va_end(ap);

#endif // DBG

} // DebugPrint()

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\copybits.c ===
/******************************Module*Header*******************************\
* Module Name: COPYBITS.c
*
* Author: Noel VanHook
* Date: May. 31, 1995
* Purpose: Handle calls to DrvCopyBits
*
* Copyright (c) 1997 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/COPYBITS.C  $
*
*    Rev 1.50   Mar 04 1998 15:22:54   frido
* Added new shadow macros.
*
*    Rev 1.49   Feb 25 1998 16:43:48   frido
* Fixed a 16-bpp color translation problem for NT 5.0.
*
*    Rev 1.48   Feb 24 1998 13:19:10   frido
* Removed a few warning messages for NT 5.0.
*
*    Rev 1.47   Dec 10 1997 13:29:54   frido
* Merged from 1.62 branch.
*
*    Rev 1.46.1.0   Nov 10 1997 14:58:46   frido
* PDR#10893: With monochrome color translations in 8-bpp (palette) NT
* decides that a 2-color translation table with values 0 and 1 is a TRIVIAL
* translation table. But this breaks our assumption that the background is
* always black (0) and the foreground if white (FF). Lucky for us NT sets
* an extra bit in this case: the translation table is both TRIVIAL and has a
* TABLE.
*
*    Rev 1.46   Nov 04 1997 17:36:58   frido
* Fixed 8-bpp path when no color translation is required.
*
*    Rev 1.45   Nov 04 1997 09:41:10   frido
* Added COLOR_TRANSLATE switches around hardware color translation code.
* Removed unaccessed local variables.
*
*    Rev 1.44   Nov 03 1997 15:09:24   frido
* Added REQUIRE and WRITE_STRING macros.
*
*    Rev 1.43   15 Oct 1997 12:02:26   noelv
* Added host to screen color translation
*
*    Rev 1.42   08 Aug 1997 17:23:34   FRIDO
*
* Updatded SWAT7 code for monochrome hardware bug.
*
*    Rev 1.41   25 Jun 1997 16:01:36   noelv
* Check for NULL translation table before using it.
*
*    Rev 1.40   12 Jun 1997 14:46:12   noelv
* Frido's optimized workaround for MONO HOSTDATA bug (SWAT7)
* SWAT:
* SWAT:    Rev 1.3   06 Jun 1997 10:42:34   frido
* SWAT: Changed 896 pixel width into 888.
* SWAT:
* SWAT:    Rev 1.2   05 Jun 1997 14:48:14   frido
* SWAT: Added SWAT7 code (monochrome bitblt cut-off).
*
*    Rev 1.39   08 Apr 1997 12:14:16   einkauf
*
* add SYNC_W_3D to coordinate MCD/2D HW access
*
*    Rev 1.38   21 Mar 1997 10:54:16   noelv
*
* Combined 'do_flag' and 'sw_test_flag' together into 'pointer_switch'
*
*    Rev 1.37   19 Feb 1997 13:14:50   noelv
* Moved default xlate table to xlate.c
*
*    Rev 1.36   06 Feb 1997 10:37:38   noelv
*
* Put device to device stuff in it's own file.
*
*    Rev 1.35   28 Jan 1997 11:13:42   noelv
*
* Removed extra dword requirements from 5465 driver.
*
*    Rev 1.34   23 Jan 1997 17:26:36   bennyn
* Modified to support 5465 DD
*
*    Rev 1.33   23 Jan 1997 11:26:10   noelv
*
* Modified the '62 workaround to only happen on the '62
*
*    Rev 1.32   17 Jan 1997 10:10:30   noelv
* Workaround (punt) for HOSTDATA lockup on '62
*
*    Rev 1.31   18 Dec 1996 11:35:30   noelv
* Official workaround for mono hostdata bug.
*
*    Rev 1.30   17 Dec 1996 17:05:48   SueS
* Added test for writing to log file based on cursor at (0,0).  Added more
* information to the log file.
*
*    Rev 1.29   11 Dec 1996 14:18:54   noelv
*
* Punt 24bpp mono host to screen with rop=66 (hw bug?)
*
*    Rev 1.28   26 Nov 1996 10:47:34   SueS
* Changed WriteLogFile parameters for buffering.
*
*    Rev 1.27   13 Nov 1996 17:21:38   SueS
* Changed WriteFile calls to WriteLogFile.  Ifdef'ed out YUVBlt code
* if USE_ASM is turned off.
*
*    Rev 1.26   04 Oct 1996 16:52:00   bennyn
*
* Added DirectDraw YUV support
*
*    Rev 1.25   06 Sep 1996 09:14:46   noelv
*
* Cleaned up NULL driver code.
*
*    Rev 1.24   20 Aug 1996 11:03:20   noelv
* Bugfix release from Frido 8-19-96
*
*    Rev 1.3   18 Aug 1996 20:39:08   frido
* Changed DrvCopyBits' detection of memory bitmaps. This fixes some GPF's.
*
*    Rev 1.2   17 Aug 1996 13:18:14   frido
* New release from Bellevue.
*
*    Rev 1.1   15 Aug 1996 11:44:08   frido
* Added precompiled header.
*
*    Rev 1.0   14 Aug 1996 17:16:16   frido
* Initial revision.
*
*    Rev 1.22   28 May 1996 15:11:18   noelv
* Updated data logging.
*
*    Rev 1.21   24 Apr 1996 20:41:46   noelv
* Fixed syntax error in C code (not used when using inline assembler)
*
*    Rev 1.20   16 Apr 1996 22:48:42   noelv
* accelerated color xlate for device to device.
*
*    Rev 1.22   15 Apr 1996 17:26:46   frido
* Added color translation in DeviceToDevice.
*
*    Rev 1.21   12 Apr 1996 11:27:00   frido
* Fixed a type in DeviceToHost24.
*
*    Rev 1.20   08 Apr 1996 16:45:08   frido
* Added call to PuntBitBlt.
* Added check for translation in ScreenToHost.
* Added SolidBrush cache.
*
*    Rev 1.19   04 Apr 1996 09:57:10   frido
* Added test for bitmap format in ScreenToHost.
*
*    Rev 1.18   30 Mar 1996 22:12:16   frido
* Refined checking for invalid translation flags.
*
*    Rev 1.17   29 Mar 1996 14:53:52   frido
* Fixed problem with grayed icons.
*
*    Rev 1.16   27 Mar 1996 16:56:14   frido
* Added return values to Do... routines.
* Added check for undocumented translation flags.
* Added check for translation tables.
* Removed OP0 field in BLTDEF.
*
*    Rev 1.15   25 Mar 1996 12:03:58   frido
* Changed #ifdef frido into #if frido.
*
*    Rev 1.14   25 Mar 1996 11:53:30   frido
* Removed assembly for DoDeviceToDevice.
*
*    Rev 1.13   25 Mar 1996 11:52:38   frido
* Bellevue 102B03.
*
*    Rev 1.9   20 Mar 1996 17:16:08   BENNYN
* Fixed the BPR910 & BPR920 Phostone problems
*
*    Rev 1.8   20 Mar 1996 14:17:42   bennyn
*
*
*    Rev 1.7   19 Mar 1996 11:37:32   noelv
*
* Added data logging.
*
*    Rev 1.6   14 Mar 1996 09:38:46   andys
*
* Added if def on DoDeviceToDevice
*
*    Rev 1.5   07 Mar 1996 18:20:58   bennyn
* Removed read/modify/write on CONTROL reg
*
*    Rev 1.4   06 Mar 1996 12:51:30   noelv
* Frido ver 19b
*
*    Rev 1.9   06 Mar 1996 14:59:06   frido
* Added 'striping' wide bitmaps in 16-bpp and higher.
*
*    Rev 1.8   04 Mar 1996 20:22:50   frido
* Cached grCONTROL register.
*
*    Rev 1.7   01 Mar 1996 17:48:12   frido
* Added in-line assembly.
*
*    Rev 1.6   29 Feb 1996 20:23:46   frido
* Added 8-bpp source translation in 24- and 32-bpp HostToScreen.
*
*    Rev 1.5   28 Feb 1996 22:35:20   frido
* Added 8-bpp source translation in 16-bpp HostToScreen.
*
*    Rev 1.4   27 Feb 1996 16:38:06   frido
* Added device bitmap store/restore.
*
*    Rev 1.3   26 Feb 1996 23:37:08   frido
* Added comments.
* Rewritten ScreenToHost and HostToScreen routines.
* Removed several other bugs.
*
\**************************************************************************/

#include "precomp.h"
#include "SWAT.h"


#define COPYBITS_DBG_LEVEL 1

#if LOG_CALLS
    void LogCopyBits(
        int       acc,
        SURFOBJ*  psoSrc,
        SURFOBJ*  psoDest,
        CLIPOBJ*  pco,
        XLATEOBJ* pxlo);
#else
    #define LogCopyBits(acc, psoSrc, psoDest, pco, pxlo)
#endif

//
// Top level BLT functions.
//

#if (defined(i386) && USE_ASM)
BOOL YUVBlt(SURFOBJ*  psoTrg, SURFOBJ* psoSrc,  CLIPOBJ* pco,
            XLATEOBJ* pxlo,   RECTL*   prclTrg, POINTL*  pptlSrc);
#endif

BOOL CopyDeviceBitmap(SURFOBJ* psoTrg, SURFOBJ* psoSrc, CLIPOBJ* pco,
              XLATEOBJ* pxlo, RECTL* prclTrg, POINTL* pptlSrc,
              ULONG ulDRAWBLTDEF, COPYFN* pfn);
BOOL DoDeviceToDevice(SURFOBJ* psoTrg, SURFOBJ* psoSrc, XLATEOBJ* pxlo,
              RECTL* prclTrg, POINTL* pptlSrc, ULONG ulDRAWBLTDEF);
BOOL PuntBitBlt(SURFOBJ* psoDest, SURFOBJ* psoSrc, SURFOBJ* psoMask,
        CLIPOBJ* pco, XLATEOBJ* pxlo, RECTL* prclDest, POINTL* pptlSrc,
        POINTL* pptlMask, BRUSHOBJ* pbo, POINTL* pptlBrush, ROP4 rop4);

BOOL DoDeviceToDeviceWithXlate(SURFOBJ* psoTrg, SURFOBJ* psoSrc, ULONG* pulXlate,
              RECTL* prclTrg, POINTL* pptlSrc, ULONG ulDRAWBLTDEF);


#if SOLID_CACHE
    VOID CacheSolid(PDEV* ppdev);
#endif


/******************************************************************************\
*                                                                                                                                                          *
*  DrvCopyBits                                                                                             *
*                                                                                                                  *
\******************************************************************************/
BOOL DrvCopyBits(
    SURFOBJ*  psoTrg,
    SURFOBJ*  psoSrc,
    CLIPOBJ*  pco,
    XLATEOBJ* pxlo,
    RECTL*    prclTrg,
    POINTL*   pptlSrc)
{
    BOOL  fSrc, fDest;
    PDEV* ppdev;

    #if NULL_COPYBITS
    {
        if (pointer_switch)   return(TRUE);
    }
    #endif

    DISPDBG((COPYBITS_DBG_LEVEL, "DrvCopyBits\n"));

    // Determine if the source and target are the screen or a device bitmap.  I
    // have seen several cases where memory bitmaps are created with the dhpdev
    // set to the screen, so we must check if the surface handles to the screen
    // match.
    fDest = (psoTrg->dhpdev != 0);
    if (fDest)
    {
                // The destination must be either the screen or a device bitmap.
                if ((psoTrg->hsurf != ((PDEV*)(psoTrg->dhpdev))->hsurfEng) &&
                        (psoTrg->iType != STYPE_DEVBITMAP))
                {
                        fDest = FALSE;  // The destination is a memory bitmap.
                }
    }

    fSrc = (psoSrc->dhpdev != 0);
    if (fSrc)
    {
        // The source must be either the screen or a device bitmap.
        if ((psoSrc->hsurf != ((PDEV*)(psoSrc->dhpdev))->hsurfEng) &&
            (psoSrc->iType != STYPE_DEVBITMAP))
        {
            fSrc = FALSE;       // The source is a memory bitmap.
        }
    }

    ppdev = (PDEV*) (fSrc ? psoSrc->dhpdev : (fDest ? psoTrg->dhpdev : NULL));

    SYNC_W_3D(ppdev);

#if (defined(i386) && USE_ASM)
    if (ppdev->dwLgDevID < CL_GD5465)
    {
       if (YUVBlt(psoTrg, psoSrc, pco, pxlo, prclTrg, pptlSrc))
          return TRUE;
    };
#endif

    // If the destination is a DIB device bitmap, try copying it into
    // off-screen memory.
    if ( fDest &&                                       // Is destination valid?
         (psoTrg->iType == STYPE_DEVBITMAP) &&          // Is it a device bitmap?
                 ((DSURF*) psoTrg->dhsurf)->pso )       // Has it a surface?
    {
        if ( !bCreateScreenFromDib(ppdev, (DSURF*) psoTrg->dhsurf) )
        {
                psoTrg = ((DSURF*) psoTrg->dhsurf)->pso;
                fDest  = FALSE; // Destination is memory.
        }
    }

    // If the source is a DIB device bitmap, try copying it into off-screen
    // memory.
    if ( fSrc &&                                        // Is source valid?
         (psoSrc->iType == STYPE_DEVBITMAP) &&          // Is it a device bitmap?
                 ((DSURF*) psoSrc->dhsurf)->pso )       // Has it a surface?
    {
        if ( !bCreateScreenFromDib(ppdev, (DSURF*) psoSrc->dhsurf) )
        {
            psoSrc = ((DSURF*) psoSrc->dhsurf)->pso;
            fSrc   = FALSE;     // Source is memory.
        }
    }

    if (fDest)
    {
        // The target is the screen.
        if (fSrc)
        {
             // The source is the screen.
             if (CopyDeviceBitmap(psoTrg, psoSrc, pco, pxlo, prclTrg, pptlSrc,
                                 0x000000CC, DoDeviceToDevice))
             {
                 LogCopyBits(0, psoSrc,  psoTrg, pco, pxlo);
                 return(TRUE);
             }
        }
        else if ( (psoSrc->iBitmapFormat <= BMF_8BPP) ||
                  (psoSrc->iBitmapFormat == psoTrg->iBitmapFormat) )
        {
            // Ths source is main memory. We only support 1-bpp, 4-bpp, 8-bpp,
            // or the device-bpp formats.
            if (CopyDeviceBitmap(psoTrg, psoSrc, pco, pxlo, prclTrg, pptlSrc,
                                 0x000000CC, ppdev->pfnHostToScreen))
            {
                LogCopyBits(0, psoSrc,  psoTrg, pco, pxlo);
                return(TRUE);
            }
        }
    }


    else if (fSrc)
    {
        // The source is the screen.
        if (CopyDeviceBitmap(psoTrg, psoSrc, pco, pxlo, prclTrg, pptlSrc,
                             0x000000CC, ppdev->pfnScreenToHost))
        {
            LogCopyBits(0, psoSrc,  psoTrg, pco, pxlo);
            return(TRUE);
        }
    }

    // We have a memory to memory blit. Let NT handle it!
    LogCopyBits(1, psoSrc,  psoTrg, pco, pxlo);
    return PuntBitBlt(psoTrg, psoSrc, NULL, pco, pxlo, prclTrg, pptlSrc, NULL,
                      NULL, NULL, 0x0000CCCC);
}

#if LOG_CALLS
// ****************************************************************************
//
// LogCopyBlt()
// This routine is called only from DrvCopyBits()
// Dump information to a file about what is going on in CopyBit land.
//
// ****************************************************************************
void LogCopyBits(
        int       acc,
        SURFOBJ*  psoSrc,
        SURFOBJ*  psoDest,
        CLIPOBJ*  pco,
        XLATEOBJ* pxlo)
{
    PPDEV dppdev,sppdev,ppdev;
    char buf[256];
    int i;
    BYTE fg_rop, bg_rop;
    ULONG iDComplexity;

    dppdev = (PPDEV) (psoDest ? psoDest->dhpdev : 0);
    sppdev = (PPDEV) (psoSrc  ? psoSrc->dhpdev  : 0);
    ppdev = dppdev ? dppdev : sppdev;

    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    i = sprintf(buf,"DCB: ");
        WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

        switch(acc)
    {
        case 0: // Accelerated
            i = sprintf(buf, "ACCL ");
            break;

        case 1: // Punted
            i = sprintf(buf, "PUNT BitBlt ");
            break;

        default:
            i = sprintf(buf, "PUNT unknown ");
            break;

    }
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);


    //
    // Check the SRC
    //
    if (psoSrc)
    {
        if (psoSrc->iType == STYPE_DEVBITMAP)
        {
            i = sprintf(buf, "Src Id=%p ", psoSrc->dhsurf);
            WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
            if ( ((PDSURF)psoSrc->dhsurf)->pso  )
                i = sprintf(buf,"S=DH ");
            else
                i = sprintf(buf,"S=DF ");
        }
        else if (psoSrc->hsurf == ppdev->hsurfEng)
            i = sprintf(buf,"S=S ");
        else
            i = sprintf(buf,"S=H ");
    }
    else
        i = sprintf(buf,"S=N ");
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);


    //
    // Check the DEST
    //
    if (psoDest)
    {
        if (psoDest->iType == STYPE_DEVBITMAP)
        {
            i = sprintf(buf, "Dst Id=%p ", psoDest->dhsurf);
            WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
            if (  ((PDSURF)psoDest->dhsurf)->pso   )
                i = sprintf(buf,"D=DH ");
            else
                i = sprintf(buf,"D=DF ");
        }
        else if (psoDest->hsurf == ppdev->hsurfEng)
            i = sprintf(buf,"D=S ");
        else
            i = sprintf(buf,"D=H ");
    }
    else
        i = sprintf(buf,"D=N ");
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);




    //
    // Check the type of clipping.
    //
    iDComplexity = (pco ? pco->iDComplexity : DC_TRIVIAL);
    i = sprintf(buf,"C=%s ",
                (iDComplexity==DC_TRIVIAL ? "T":
                (iDComplexity == DC_RECT ? "R" : "C" )));
        WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);


    //
    // Type of translation
    //
    if (!pxlo)
    {
        i = sprintf(buf,"T=N ");
        WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }
    else if (pxlo->flXlate & XO_TRIVIAL)
    {
        i = sprintf(buf,"T=T ");
                WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }
    else
    {
        i = sprintf(buf,"T=NT ");
                WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }

    i = sprintf(buf,"\r\n");
        WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

}

#endif

/*****************************************************************************\
 * CopyDeviceBitmap
 *
 * This is the main entry routine for all bitblt functions. It will dispatch
 * the blit to the correct handler and performs the clipping.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pco                             Pointer to clip object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags. It will be filled
 *                                                              by the dispatch routine.
 *                              pfn                             Pointer to dispatch function.
 *
 * Returns:             TRUE if successful, FALSE if we cannot handle this blit.
\*****************************************************************************/
BOOL CopyDeviceBitmap(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        CLIPOBJ  *pco,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF,
        COPYFN   *pfn
)
{
        // Check for no clipping.
        if ( (pco == NULL) || (pco->iDComplexity == DC_TRIVIAL) )
        {
                return(pfn(psoTrg, psoSrc, pxlo, prclTrg, pptlSrc, ulDRAWBLTDEF));
        }

        // Check for single rectangle clipping.
        else if (pco->iDComplexity == DC_RECT)
        {
                RECTL  rcl;
                POINTL ptl;

                // Intersect the destination rectangle with the clipping rectangle.
                rcl.left = max(prclTrg->left, pco->rclBounds.left);
                rcl.top = max(prclTrg->top, pco->rclBounds.top);
                rcl.right = min(prclTrg->right, pco->rclBounds.right);
                rcl.bottom = min(prclTrg->bottom, pco->rclBounds.bottom);

                // Do we have a valid rectangle?
                if ( (rcl.left < rcl.right) && (rcl.top < rcl.bottom) )
                {
                        // Setup the source offset.
                        ptl.x = pptlSrc->x + (rcl.left - prclTrg->left);
                        ptl.y = pptlSrc->y + (rcl.top - prclTrg->top);
                        // Dispatch the blit.
                        return(pfn(psoTrg, psoSrc, pxlo, &rcl, &ptl, ulDRAWBLTDEF));
                }
        }

        // Complex clipping.
        else
        {
                BOOL       bMore;
                ENUMRECTS8 ce;
                RECTL*     prcl;
                ULONG      ulDirClip = CD_ANY;

                // If we have a screen to screen blit, we must specify the sorting of
                // the rectangles since we must take care not to draw on a destination
                // before that destination itself may be used as the source for a blit.
                // This only accounts for the same physical surface, not between
                // different device bitmaps.
                if ( (pfn == DoDeviceToDevice) && (psoSrc->dhsurf == psoTrg->dhsurf) )
                {
                        if (prclTrg->left > pptlSrc->x)
                        {
                                ulDirClip =
                                        (prclTrg->top > pptlSrc->y) ? CD_LEFTUP : CD_LEFTDOWN;
                        }
                        else
                        {
                                ulDirClip =
                                        (prclTrg->top > pptlSrc->y) ? CD_RIGHTUP : CD_RIGHTDOWN;
                        }
                }

                // Start the enumeration process.
                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, ulDirClip, 0);
                do
                {
                        // Get a bunch of clipping rectangles.
                        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG *) &ce);

                        // Loop through all clipping rectangles.
                        for (prcl = ce.arcl; ce.c--; prcl++)
                        {
                                RECTL  rcl;
                                POINTL ptl;

                                // Intersect the destination rectangle with the clipping
                                // rectangle.
                                rcl.left = max(prclTrg->left, prcl->left);
                                rcl.top = max(prclTrg->top, prcl->top);
                                rcl.right = min(prclTrg->right, prcl->right);
                                rcl.bottom = min(prclTrg->bottom, prcl->bottom);

                                if ( (rcl.left < rcl.right) && (rcl.top < rcl.bottom) )
                                {
                                        // Setup the source offset.
                                        ptl.x = pptlSrc->x + (rcl.left - prclTrg->left);
                                        ptl.y = pptlSrc->y + (rcl.top - prclTrg->top);
                                        // Dispatch the blit.
                                        if (!pfn(psoTrg, psoSrc, pxlo, &rcl, &ptl, ulDRAWBLTDEF))
                                        {
                                                return(FALSE);
                                        }
                                }
                        }
                }
                while (bMore);
        }

        // Always return TRUE.
        return(TRUE);
}




/*****************************************************************************\
 *                                                                                                                                                       *
 *                                                                      8 - B P P                                                                *
 *                                                                                                                                                       *
\*****************************************************************************/

/*****************************************************************************\
 * DoHost8ToDevice
 *
 * This routine performs a HostToScreen or HostToDevice blit. The host data
 * can be either monochrome, 4-bpp, or 8-bpp. Color translation is supported.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags.
\*****************************************************************************/
BOOL DoHost8ToDevice(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF
)
{
        POINTL ptlDest, ptlSrc;
        SIZEL  sizl;
        PPDEV  ppdev;
        PBYTE  pBits;
        LONG   lDelta, i, n, lLeadIn, lExtra;
        ULONG  *pulXlate;
        FLONG  flXlate;

        // Calculate the source offset.
        ptlSrc.x = pptlSrc->x;
        ptlSrc.y = pptlSrc->y;

        // Determine the destination type and calculate the destination offset.
        if (psoTrg->iType == STYPE_DEVBITMAP)
        {
                PDSURF pdsurf = (PDSURF) psoTrg->dhsurf;

                ptlDest.x = prclTrg->left + pdsurf->ptl.x;
                ptlDest.y = prclTrg->top + pdsurf->ptl.y;
                ppdev = pdsurf->ppdev;
        }
        else
        {
                ptlDest.x = prclTrg->left;
                ptlDest.y = prclTrg->top;
                ppdev = (PPDEV) psoTrg->dhpdev;
        }

        // Calculate the size of the blit.
    sizl.cx = prclTrg->right - prclTrg->left;
    sizl.cy = prclTrg->bottom - prclTrg->top;

        // Get the source variables and offset into source bits.
        lDelta = psoSrc->lDelta;
        pBits = (PBYTE)psoSrc->pvScan0 + (ptlSrc.y * lDelta);


        /*      -----------------------------------------------------------------------
                Test for monochrome source.
        */
        if (psoSrc->iBitmapFormat == BMF_1BPP)
        {
                ULONG  bgColor, fgColor;
#if SWAT7
                SIZEL  sizlTotal;
#endif
        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if ( (flXlate & XO_TRIVIAL) && !(flXlate & XO_TABLE) )
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // Set background and foreground colors.
                if (pulXlate == NULL)
                {
                        bgColor = 0x00000000;
                        fgColor = 0xFFFFFFFF;
                }
                else
                {
                        bgColor = pulXlate[0];
                        fgColor = pulXlate[1];

                        // Expand the colors.
                        bgColor |= bgColor << 8;
                        fgColor |= fgColor << 8;
                        bgColor |= bgColor << 16;
                        fgColor |= fgColor << 16;
                }

                //
                // Special case: when we are expanding monochrome sources and we
                // already have a colored brush, we must make sure the monochrome color
                // translation can be achived by setting the saturation bit (expanding
                // 0's to 0 and 1's to 1). If the monochrome source also requires color
                // translation, we simply punt this blit back to GDI.
                //
                if (ulDRAWBLTDEF & 0x00040000)
                {
                        if ( (bgColor == 0x00000000) && (fgColor == 0xFFFFFFFF) )
                        {
                                // Enable saturation for source (OP1).
                                ulDRAWBLTDEF |= 0x00008000;
                        }
                        #if SOLID_CACHE
                        else if ( ((ulDRAWBLTDEF & 0x000F0000) == 0x00070000) &&
                                          ppdev->Bcache )
                        {
                                CacheSolid(ppdev);
                                ulDRAWBLTDEF ^= (0x00070000 ^ 0x00090000);
                                REQUIRE(4);
                                LL_BGCOLOR(bgColor, 2);
                                LL_FGCOLOR(fgColor, 2);
                        }
                        #endif
                        else
                        {
                                // Punt this call to the GDI.
                                return(FALSE);
                        }
                }
                else
                {
                        REQUIRE(4);
                        LL_BGCOLOR(bgColor, 2);
                        LL_FGCOLOR(fgColor, 2);
                }

                REQUIRE(9);
#if SWAT7
                // Setup the Laguna registers for the blit. We also set the bit swizzle
                // bit in the grCONTROL register.
                ppdev->grCONTROL |= SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10600000, 2);

                sizlTotal = sizl;
                while (sizlTotal.cx)
                {
                        sizl.cx = min(sizlTotal.cx, 864);
                        sizl.cy = sizlTotal.cy;

                        #if 1 // SWAT: 08/08/97
                        // In 8-bpp the 5465AD has a hardware bug when 64 < width < 128.
                        if (sizl.cx > 64 && sizl.cx < 128)
                        {
                                sizl.cx = 64;
                        }
                        #endif
#endif
                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we must setup the source phase.
                lLeadIn = ptlSrc.x & 31;
                pBits += (ptlSrc.x >> 3) & ~3;
                n = (sizl.cx + lLeadIn + 31) >> 5;

#if !SWAT7
                // Setup the Laguna registers for the blit. We also set the bit swizzle
                // bit in the grCONTROL register.
                ppdev->grCONTROL |= SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10600000, 2);
#endif

                // Start the blit.
// added REQUIRE above
//              REQUIRE(7);
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // Copy all the bits to the screen, 32-bits at a time. We don't have to
                // worry about crossing any boundary since NT is always DWORD aligned.
                while (sizl.cy--)
                {
                        WRITE_STRING(pBits, n);
                        pBits += lDelta;
                }
#if SWAT7
                sizlTotal.cx -= sizl.cx;
                ptlSrc.x += sizl.cx;
                ptlDest.x += sizl.cx;

                // Reload pBits.
                pBits = (PBYTE) psoSrc->pvScan0 + (ptlSrc.y * lDelta);
                }
#endif

                // Disable the swizzle bit in the grCONTROL register.
                ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
        }

        /*      -----------------------------------------------------------------------
                Test for 4-bpp source.
        */
        else if (psoSrc->iBitmapFormat == BMF_4BPP)
        {
        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // Calculate the source parameters. We are going to BYTE adjust the
                // source, so we also set the source phase.
                lLeadIn = ptlSrc.x & 1;
                pBits += ptlSrc.x >> 1;
                n = sizl.cx + (ptlSrc.x & 1);

        #if ! DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
        if (ppdev->dwLgDevID == CL_GD5462)
        {
            if (MAKE_HD_INDEX(sizl.cx, lLeadIn, ptlDest.x) == 3788)
            {
                // We have a problem with the HOSTDATA TABLE.
                // Punt till we can figure it out.
                return FALSE;
            }
                lExtra = ExtraDwordTable[MAKE_HD_INDEX(sizl.cx, lLeadIn, ptlDest.x)];
        }
        else
            lExtra = 0;
        #endif

                // Start the blit.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // If there is no translation table, use the default translation table.
                if (pulXlate == NULL)
                {
                        pulXlate = ulXlate;
                }

                // Now we are ready to copy all the pixels to the hardware.
                while (sizl.cy--)
                {
                        BYTE  *p = pBits;
                        BYTE  data[4];

                        // First, we convert 4 pixels at a time to create a 32-bit value to
                        // write to the hardware.
                        for (i = n; i >= 4; i -= 4)
                        {
                                data[0] = (BYTE) pulXlate[p[0] >> 4];
                                data[1] = (BYTE) pulXlate[p[0] & 0x0F];
                                data[2] = (BYTE) pulXlate[p[1] >> 4];
                                data[3] = (BYTE) pulXlate[p[1] & 0x0F];
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], *(DWORD *)data);
                                p += 2;
                        }

                        // Now, write any remaining pixels.
                        switch (i)
                        {
                                case 1:
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], pulXlate[p[0] >> 4]);
                                        break;

                                case 2:
                                        data[0] = (BYTE) pulXlate[p[0] >> 4];
                                        data[1] = (BYTE) pulXlate[p[0] & 0x0F];
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], *(DWORD *)data);
                                        break;

                                case 3:
                                        data[0] = (BYTE) pulXlate[p[0] >> 4];
                                        data[1] = (BYTE) pulXlate[p[0] & 0x0F];
                                        data[2] = (BYTE) pulXlate[p[1] >> 4];
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], *(DWORD *)data);
                                        break;
                        }

            #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }
            #endif

                        // Next line.
                        pBits += lDelta;
                }
        }

        /*      -----------------------------------------------------------------------
                Source is in same color depth as screen.
        */
        else
        {
        //
        // If color translation is required, attempt to load the translation
        // table into the chip.
        //
                #if COLOR_TRANSLATE
        ULONG UseHWxlate = bCacheXlateTable(ppdev, &pulXlate, psoTrg, psoSrc,
                                            pxlo, (BYTE)(ulDRAWBLTDEF & 0xCC));
                #else
                if ( (pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL) )
                {
                        pulXlate = NULL;
                }
                else if (pxlo->flXlate & XO_TABLE)
                {
                        pulXlate = pxlo->pulXlate;
                }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }
                #endif

        // pulXlate == NULL if there is no color translation is required.
        // pulXlate == translation table if color translation is required.
        // UseHWxlate == FALSE if the hardware will do the xlate for us.
        // UseHWxlate == TRUE if we must do the translation in software.

                // If we have invalid translation flags, punt the blit.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
                if (flXlate & 0x10)
                {
                        return(FALSE);
                }

                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we also set the source phase.
                pBits += ptlSrc.x;
                lLeadIn = (DWORD)pBits & 3;
                pBits -= lLeadIn;
                n = (sizl.cx + lLeadIn + 3) >> 2;

        #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
            {
                if (MAKE_HD_INDEX(sizl.cx, lLeadIn, ptlDest.x) == 3788)
                {
                                // We have a problem with the HOSTDATA TABLE.
                                // Punt till we can figure it out.
                                return(FALSE);
                        }
                        lExtra =
                                        ExtraDwordTable[MAKE_HD_INDEX(sizl.cx, lLeadIn, ptlDest.x)];
                }
                else
                {
                        lExtra = 0;
                }
        #endif

                // Setup the Laguna registers.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);

                // Start the blit.
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);

                // Test for SW color translation.
#if COLOR_TRANSLATE
                if (UseHWxlate)
#else
                if (pulXlate == NULL)
#endif
        {    // HW color translate, or no translate required.

            if (pulXlate)
            {
                DISPDBG((COPYBITS_DBG_LEVEL, "Host8ToDevice: "
                   "Attempting HW color translation on 8bpp Host to Screen.\n"));
                LL_BLTEXT_XLATE(8, sizl.cx, sizl.cy); // HW xlate.
            }
            else
            {
                DISPDBG((COPYBITS_DBG_LEVEL, "Host8ToDevice: "
                   "No color translation required on 8bpp Host to Screen.\n"));
                        LL_BLTEXT(sizl.cx, sizl.cy); // No xlate.
            }

                        while (sizl.cy--)
                        {
                                // Copy all data in 32-bit. We don't have to worry about
                                // crossing any boundaries, since within NT everything is DWORD
                                // aligned.
                                WRITE_STRING(pBits, n);

                #if !DRIVER_5465
                                // Now, write the extra DWORDS.
                                REQUIRE(lExtra);
                                for (i = 0; i < lExtra; i++)
                                {
                                        LL32(grHOSTDATA[0], 0);
                                }
                #endif

                                // Next line.
                                pBits += lDelta;
                        }
                }
                else  // Software color translation is required.
                {
            DISPDBG((COPYBITS_DBG_LEVEL, "Host8ToDevice: "
                  "Attempting SW color translation on 8bpp Host to Screen.\n"));
            ASSERTMSG(pulXlate,
                "Host8ToDevice: No translation table for SW color translation.\n");

                LL_BLTEXT(sizl.cx, sizl.cy);

                        while (sizl.cy--)
                        {
                                BYTE *p = pBits;

                                // We copy 4 pixels to fill an entire 32-bit DWORD.
                                for (i = 0; i < n; i++)
                                {
                                        BYTE data[4];

                                        data[0] = (BYTE) pulXlate[p[0]];
                                        data[1] = (BYTE) pulXlate[p[1]];
                                        data[2] = (BYTE) pulXlate[p[2]];
                                        data[3] = (BYTE) pulXlate[p[3]];
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], *(DWORD *)data);
                                        p += 4;
                                }

                #if !DRIVER_5465
                                // Now, write the extra DWORDS.
                                REQUIRE(lExtra);
                                for (i = 0; i < lExtra; i++)
                                {
                                        LL32(grHOSTDATA[0], 0);
                                }
                #endif

                                // Next line.
                                pBits += lDelta;
                        }
                }
   }
   return(TRUE);
}

/*****************************************************************************\
 * DoDeviceToHost8
 *
 * This routine performs a DeviceToHost for either monochrome or 8-bpp
 * destinations.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags.
\*****************************************************************************/
BOOL DoDeviceToHost8(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF
)
{
        POINTL ptlSrc;
        PPDEV  ppdev;
        SIZEL  sizl;
        PBYTE  pBits;
        #if !S2H_USE_ENGINE
        PBYTE  pjScreen;
        #endif
        LONG   lDelta;
        ULONG  i, n;

        // Determine the source type and calculate the offset.
        if (psoSrc->iType == STYPE_DEVBITMAP)
        {
                PDSURF pdsurf = (PDSURF)psoSrc->dhsurf;

                ppdev = pdsurf->ppdev;
                ptlSrc.x = pptlSrc->x + pdsurf->ptl.x;
                ptlSrc.y = pptlSrc->y + pdsurf->ptl.y;
        }
        else
        {
                ppdev = (PPDEV)psoSrc->dhpdev;
                ptlSrc.x = pptlSrc->x;
                ptlSrc.y = pptlSrc->y;
        }

        // Calculate the size of the blit.
        sizl.cx = prclTrg->right - prclTrg->left;
        sizl.cy = prclTrg->bottom - prclTrg->top;

        // Calculate the destination variables.
        lDelta = psoTrg->lDelta;
        pBits = (PBYTE)psoTrg->pvScan0 + (prclTrg->top * lDelta);

        #if S2H_USE_ENGINE
        // Setup the Laguna registers.
        REQUIRE(9);
        LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x20100000, 0);
        LL_OP0(0, 0);
        #else
        // Calculate the screen address.
        pjScreen = ppdev->pjScreen + ptlSrc.x + ptlSrc.y * ppdev->lDeltaScreen;

        // Wait for the hardware to become idle.
        while (LLDR_SZ(grSTATUS) != 0) ;
        #endif

        // Test for monochrome destination.
        if (psoTrg->iBitmapFormat == BMF_1BPP)
        {
                BYTE  data, leftMask, rightMask, fgColor;
                DWORD *pulXlate;
                LONG  leftCount, rightCount, leftSkip;
                #if S2H_USE_ENGINE
                BYTE  pixels[4];
                #endif

                // Calculate the monochrome masks.
                pBits += prclTrg->left >> 3;
                leftSkip = prclTrg->left & 7;
                leftCount = (8 - leftSkip) & 7;
                leftMask = 0xFF >> leftSkip;
                rightCount = prclTrg->right & 7;
                rightMask = 0xFF << (8 - rightCount);

                // If we only have pixels in one byte, we combine rightMask with
                // leftMask and set the routines to skip everything but the rightMask.
                if (leftCount > sizl.cx)
                {
                        rightMask &= leftMask;
                        leftMask = 0xFF;
                        n = 0;
                }
                else
                {
                        n = (sizl.cx - leftCount) >> 3;
                }

                // Lookup the foreground color in the translation table. We scan from
                // the back since in most cases it will be entry 255.
                pulXlate = pxlo->pulXlate;
                for (fgColor = 255; pulXlate[fgColor] != 1; fgColor--);

                #if S2H_USE_ENGINE
                // Start the blit.
                LL_OP1(ptlSrc.x - leftSkip, ptlSrc.y);
                LL_BLTEXT(sizl.cx + leftSkip, sizl.cy);
                #else
                pjScreen -= leftSkip;
                #endif

                while (sizl.cy--)
                {
                        PBYTE pDest = pBits;
                        #if !S2H_USE_ENGINE
                        PBYTE pSrc = pjScreen;
                        #endif

                        // If we have a left mask specified, we get the pixels and store
                        // them with the destination.
                        if (leftMask != 0xFF)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                *(ULONG *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (pixels[0] == fgColor) data |= 0x80;
                                if (pixels[1] == fgColor) data |= 0x40;
                                if (pixels[2] == fgColor) data |= 0x20;
                                if (pixels[3] == fgColor) data |= 0x10;
                                *(ULONG *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (pixels[0] == fgColor) data |= 0x08;
                                if (pixels[1] == fgColor) data |= 0x04;
                                if (pixels[2] == fgColor) data |= 0x02;
                                if (pixels[3] == fgColor) data |= 0x01;
                                #else
                                if (pSrc[0] == fgColor) data |= 0x80;
                                if (pSrc[1] == fgColor) data |= 0x40;
                                if (pSrc[2] == fgColor) data |= 0x20;
                                if (pSrc[3] == fgColor) data |= 0x10;
                                if (pSrc[4] == fgColor) data |= 0x08;
                                if (pSrc[5] == fgColor) data |= 0x04;
                                if (pSrc[6] == fgColor) data |= 0x02;
                                if (pSrc[7] == fgColor) data |= 0x01;
                                pSrc += 8;
                                #endif
                                *pDest++ = (*pDest & ~leftMask) | (data & leftMask);
                        }

                        // Translate all pixels that don't require masking.
                        for (i = 0; i < n; i++)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                *(ULONG *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (pixels[0] == fgColor) data |= 0x80;
                                if (pixels[1] == fgColor) data |= 0x40;
                                if (pixels[2] == fgColor) data |= 0x20;
                                if (pixels[3] == fgColor) data |= 0x10;
                                *(ULONG *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (pixels[0] == fgColor) data |= 0x08;
                                if (pixels[1] == fgColor) data |= 0x04;
                                if (pixels[2] == fgColor) data |= 0x02;
                                if (pixels[3] == fgColor) data |= 0x01;
                                #else
                                if (pSrc[0] == fgColor) data |= 0x80;
                                if (pSrc[1] == fgColor) data |= 0x40;
                                if (pSrc[2] == fgColor) data |= 0x20;
                                if (pSrc[3] == fgColor) data |= 0x10;
                                if (pSrc[4] == fgColor) data |= 0x08;
                                if (pSrc[5] == fgColor) data |= 0x04;
                                if (pSrc[6] == fgColor) data |= 0x02;
                                if (pSrc[7] == fgColor) data |= 0x01;
                                pSrc += 8;
                                #endif
                                *pDest++ = data;
                        }

                        // If we have a right mask specified, we get the pixels and store
                        // them with the destination.
                        if (rightMask != 0x00)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                *(ULONG *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (pixels[0] == fgColor) data |= 0x80;
                                if (pixels[1] == fgColor) data |= 0x40;
                                if (pixels[2] == fgColor) data |= 0x20;
                                if (pixels[3] == fgColor) data |= 0x10;
                                *(ULONG *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (pixels[0] == fgColor) data |= 0x08;
                                if (pixels[1] == fgColor) data |= 0x04;
                                if (pixels[2] == fgColor) data |= 0x02;
                                if (pixels[3] == fgColor) data |= 0x01;
                                #else
                                if (pSrc[0] == fgColor) data |= 0x80;
                                if (pSrc[1] == fgColor) data |= 0x40;
                                if (pSrc[2] == fgColor) data |= 0x20;
                                if (pSrc[3] == fgColor) data |= 0x10;
                                if (pSrc[4] == fgColor) data |= 0x08;
                                if (pSrc[5] == fgColor) data |= 0x04;
                                if (pSrc[6] == fgColor) data |= 0x02;
                                if (pSrc[7] == fgColor) data |= 0x01;
                                #endif
                                *pDest = (*pDest & ~rightMask) | (data & rightMask);
                        }

                        // Next line.
                        #if !S2H_USE_ENGINE
                        pjScreen += ppdev->lDeltaScreen;
                        #endif
                        pBits += lDelta;
                }
        }

        // We only support destination bitmaps with the same color depth and we
        // do not support any color translation.
        else if ( (psoTrg->iBitmapFormat != BMF_8BPP) ||
                          (pxlo && !(pxlo->flXlate & XO_TRIVIAL)) )
        {
                return(FALSE);
        }

        /*
                If the GetPixel routine is being called, we get here with both cx and
                cy set to 1 and the ROP to 0xCC (source copy). In this special case we
                read the pixel directly from memory. Of course, we must be sure the
                blit engine is finished working since it may still update the very
                pixel we are going to read! We could use the hardware for this, but it
                seems there is a HARDWARE BUG that doesn't seem to like the 1-pixel
                ScreenToHost very much.
        */
        #if S2H_USE_ENGINE
        else if ( (sizl.cx == 1) && (sizl.cy == 1) && (ulDRAWBLTDEF == 0x000000CC) )
        {
                // Wait for the hardware to become idle.
                while (LLDR_SZ(grSTATUS) != 0) ;

                // Get the pixel from screen.
                pBits[prclTrg->left] =
                        ppdev->pjScreen[ptlSrc.x + ptlSrc.y * ppdev->lDeltaScreen];
        }
        #endif

        else
        {
                #if S2H_USE_ENGINE
                // The hardware requires us to get QWORDS.
                BOOL fExtra = ((sizl.cx + 3) >> 2) & 1;
                #endif
                pBits += prclTrg->left;

                #if S2H_USE_ENGINE
                // Start the blit.
                LL_OP1(ptlSrc.x, ptlSrc.y);
                LL_BLTEXT(sizl.cx, sizl.cy);
                #endif

                while (sizl.cy--)
                {
                        #if S2H_USE_ENGINE
                        DWORD *p = (DWORD *)pBits;

                        // First, we get pixels in chunks of 4 so the 32-bit HOSTDATA is
                        // happy.
                        for (i = sizl.cx; i >= 4; i -= 4)
                        {
                                *p++ = LLDR_SZ(grHOSTDATA[0]);
                        }

                        // Then, we have to do the remainig pixel(s).
                        switch (i)
                        {
                                case 1:
                                        *(BYTE *)p = (BYTE)LLDR_SZ(grHOSTDATA[0]);
                                        break;

                                case 2:
                                        *(WORD *)p = (WORD)LLDR_SZ(grHOSTDATA[0]);
                                        break;

                                case 3:
                                        i = LLDR_SZ(grHOSTDATA[0]);
                                        ((WORD *)p)[0] = (WORD)i;
                                        ((BYTE *)p)[2] = (BYTE)(i >> 16);
                                        break;
                        }

                        // Get the extra pixel required for QWORD alignment.
                        if (fExtra)
                        {
                                LLDR_SZ(grHOSTDATA[0]);
                        }
                        #else
                        // Copy all pixels from screen to memory.
                        memcpy(pBits, pjScreen, sizl.cx);

                        // Next line.
                        pjScreen += ppdev->lDeltaScreen;
                        #endif
                        pBits += lDelta;
                }
        }
        return(TRUE);
}

/*****************************************************************************\
 *                                                                                                                                                       *
 *                                                                 1 6 - B P P                                                           *
 *                                                                                                                                                       *
\*****************************************************************************/

/*****************************************************************************\
 * DoHost16ToDevice
 *
 * This routine performs a HostToScreen or HostToDevice blit. The host data
 * can be either monochrome, 4-bpp, or 16-bpp. Color translation is only
 * supported for monochrome and 4-bpp modes.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags.
\*****************************************************************************/
BOOL DoHost16ToDevice(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF
)
{
        POINTL ptlDest, ptlSrc;
        SIZEL  sizl;
        PPDEV  ppdev;
        PBYTE  pBits;
        LONG   lDelta, i, n, lLeadIn, lExtra, i1;
        ULONG  *pulXlate;
        FLONG  flXlate;

        // Calculate te source offset.
        ptlSrc.x = pptlSrc->x;
        ptlSrc.y = pptlSrc->y;

        // Determine the destination type and calculate the destination offset.
        if (psoTrg->iType == STYPE_DEVBITMAP)
        {
                PDSURF pdsurf = (PDSURF) psoTrg->dhsurf;
                ptlDest.x = prclTrg->left + pdsurf->ptl.x;
                ptlDest.y = prclTrg->top + pdsurf->ptl.y;
                ppdev = pdsurf->ppdev;
        }
        else
        {
                ptlDest.x = prclTrg->left;
                ptlDest.y = prclTrg->top;
                ppdev = (PPDEV) psoTrg->dhpdev;
        }

        // Calculate the size of the blit.
    sizl.cx = prclTrg->right - prclTrg->left;
    sizl.cy = prclTrg->bottom - prclTrg->top;

        // Get the source variables and offset into source bits.
        lDelta = psoSrc->lDelta;
        pBits = (PBYTE)psoSrc->pvScan0 + (ptlSrc.y * lDelta);


        /*      -----------------------------------------------------------------------
                Test for monochrome source.
        */
        if (psoSrc->iBitmapFormat == BMF_1BPP)
        {
                ULONG  bgColor, fgColor;
#if SWAT7
                SIZEL  sizlTotal;
#endif

        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // Set background and foreground colors.
                if (pulXlate == NULL)
                {
                        bgColor = 0x00000000;
                        fgColor = 0xFFFFFFFF;
                }
                else
                {
                        bgColor = pulXlate[0];
                        fgColor = pulXlate[1];

                        // Expand the colors.
                        bgColor |= bgColor << 16;
                        fgColor |= fgColor << 16;
                }

                //
                // Special case: when we are expanding monochrome sources and we
                // already have a colored brush, we must make sure the monochrome color
                // translation can be achived by setting the saturation bit (expanding
                // 0's to 0 and 1's to 1). If the monochrome source also requires color
                // translation, we simply punt this blit back to GDI.
                //
                if (ulDRAWBLTDEF & 0x00040000)
                {
                        if ( (bgColor == 0x00000000) && (fgColor == 0xFFFFFFFF) )
                        {
                                // Enable saturation for source (OP1).
                                ulDRAWBLTDEF |= 0x00008000;
                        }
                        #if SOLID_CACHE
                        else if ( ((ulDRAWBLTDEF & 0x000F0000) == 0x00070000) &&
                                          ppdev->Bcache )
                        {
                                CacheSolid(ppdev);
                                ulDRAWBLTDEF ^= (0x00070000 ^ 0x00090000);
                                REQUIRE(4);
                                LL_BGCOLOR(bgColor, 2);
                                LL_FGCOLOR(fgColor, 2);
                        }
                        #endif
                        else
                        {
                                // Punt this call to the GDI.
                                return(FALSE);
                        }
                }
                else
                {
                        REQUIRE(4);
                        LL_BGCOLOR(bgColor, 2);
                        LL_FGCOLOR(fgColor, 2);
                }

                REQUIRE(9);
#if SWAT7
                // Setup the Laguna registers for the blit. We also set the bit swizzle
                // bit in the grCONTROL register.
                ppdev->grCONTROL |= SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10600000, 2);

                sizlTotal = sizl;
                while (sizlTotal.cx)
                {
                        sizl.cx = min(sizlTotal.cx, 864);
                        sizl.cy = sizlTotal.cy;
#endif
                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we must setup the source phase.
                lLeadIn = ptlSrc.x & 31;
                pBits += (ptlSrc.x >> 3) & ~3;
                n = (sizl.cx + lLeadIn + 31) >> 5;

#if !SWAT7
                // Setup the Laguna registers for the blit. We also set the bit swizzle
                // bit in the grCONTROL register.
                ppdev->grCONTROL |= SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10600000, 2);
#endif

                // Start the blit.
// added REQUIRE above
//              REQUIRE(7);
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // Copy all the bits to the screen, 32-bits at a time. We don't have to
                // worry about crossing any boundary since NT is always DWORD aligned.
                while (sizl.cy--)
                {
                        WRITE_STRING(pBits, n);
                        pBits += lDelta;
                }
#if SWAT7
                sizlTotal.cx -= sizl.cx;
                ptlSrc.x += sizl.cx;
                ptlDest.x += sizl.cx;

                // Reload pBits.
                pBits = (PBYTE) psoSrc->pvScan0 + (ptlSrc.y * lDelta);
                }
#endif

                // Disable the swizzle bit in the grCONTROL register.
                ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
        }

        /*      -----------------------------------------------------------------------
                Test for 4-bpp source.
        */
        else if (psoSrc->iBitmapFormat == BMF_4BPP)
        {
        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // Calculate the source parameters. We are going to BYTE adjust the
                // source, so we also set the source phase.
                lLeadIn = (ptlSrc.x & 1) * 2;
                pBits += ptlSrc.x >> 1;
                n = sizl.cx + (ptlSrc.x & 1);

        #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
        {
            if (MAKE_HD_INDEX(sizl.cx * 2, lLeadIn, ptlDest.x * 2) == 3788)
            {
                // We have a problem with the HOSTDATA TABLE.
                // Punt till we can figure it out.
                return FALSE;
            }
                    lExtra = ExtraDwordTable[
                                MAKE_HD_INDEX(sizl.cx * 2, lLeadIn, ptlDest.x * 2)];
        }
        else
        {
                lExtra = 0;
                }
        #endif

                // Start the blit.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // If there is no translation table, use the default translation table.
                if (pulXlate == NULL)
                {
                        pulXlate = ulXlate;
                }

                // Now we are ready to copy all the pixels to the hardware.
                while (sizl.cy--)
                {
                        BYTE  *p = pBits;

                        // First, we convert 2 pixels at a time to create a 32-bit value
                        // to write to the hardware.
                        for (i = n; i >= 2; i -= 2)
                        {
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], pulXlate[p[0] >> 4] |
                                                                        (pulXlate[p[0] & 0x0F] << 16));
                                p++;
                        }

                        // Now, write any remaining pixel.
                        if (i)
                        {
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], pulXlate[p[0] >> 4]);
                        }

            #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }
            #endif

                        // Next line.
                        pBits += lDelta;
                }
        }

        /*      -----------------------------------------------------------------------
                Test for 8-bpp source.
        */
        else if (psoSrc->iBitmapFormat == BMF_8BPP)
        {
        //
        // Attempt to load the translation table into the chip.
        // After this call:
        //   pulXlate == NULL if there is no color translation is required.
        //   pulXlate == translation table if color translation is required.
        //   UseHWxlate == FALSE if the hardware will do the xlate for us.
        //   UseHWxlate == TRUE if we must do the translation in software.
        //
                #if COLOR_TRANSLATE
        ULONG UseHWxlate = bCacheXlateTable(ppdev, &pulXlate, psoTrg, psoSrc,
                                                                                        pxlo, (BYTE)(ulDRAWBLTDEF&0xCC));
                #else
                if ( (pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL) )
                {
                        pulXlate = NULL;
                }
                else if (pxlo->flXlate & XO_TABLE)
                {
                        pulXlate = pxlo->pulXlate;
                }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }
                #endif

        //
        // NVH:  5465 Color XLATE bug!!!
        // Color translation is broken on the 5465 in 16, 24 and 32 bpp.
        //
#if COLOR_TRANSLATE
        if (UseHWxlate)
        {
            DWORD phase = ( ((DWORD)(pBits + ptlSrc.x)) & 3);
            if (XLATE_IS_BROKEN(sizl.cx, 2, phase))
                UseHWxlate = FALSE; // force SW translation.
        }

        if (UseHWxlate)
        {
            // Use Hardware color translation.

            DISPDBG((COPYBITS_DBG_LEVEL, "Host16ToDevice: "
            "Attempting HW color translation on 8bpp Host to 16bpp Screen.\n"));

                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we also set the source phase.
                pBits += ptlSrc.x;               // Start of source data on the host.
                    lLeadIn = (DWORD)pBits & 3;      // Source phase.
                pBits -= lLeadIn;                // Backup to DWORD boundry.
                n = (sizl.cx + lLeadIn + 3) >> 2;// Number of HOSTDATA per scanline.

                // Start the blit.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT_XLATE(8, sizl.cx, sizl.cy); // HW xlate.

                        while (sizl.cy--)
                        {
                                // Copy all data in 32-bit. We don't have to worry about
                                // crossing any boundaries, since within NT everything is DWORD
                                // aligned.
                                WRITE_STRING(pBits, n);
                                pBits += lDelta;
                        }
        }
        else
#endif
        {
            //
            // Use SW color translation.
            //
            DISPDBG((COPYBITS_DBG_LEVEL, "Host16ToDevice: "
            "Attempting SW color translation on 8bpp Host to 16bpp Screen.\n"));

            // To do 8bpp host to 16bpp screen we must have a translation table.
            ASSERTMSG(pulXlate,
                "Host16ToDevice: No translation table for color translation.\n");

            #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
                        {
                                if (MAKE_HD_INDEX(sizl.cx * 2, 0, ptlDest.x * 2) == 3788)
                                {
                                        // We have a problem with the HOSTDATA TABLE.
                                        // Punt till we can figure it out.
                                        return FALSE;
                                }
                                lExtra = ExtraDwordTable[
                                                MAKE_HD_INDEX(sizl.cx * 2, 0, ptlDest.x * 2)];
                        }
                        else
                        {
                                lExtra = 0;
                        }
            #endif

                // Calculate the source parameters.
                pBits += ptlSrc.x; // Start of source data on the host.

                // Start the blit.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
                LL_OP1_MONO(0, 0);
                    LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                while (sizl.cy--)
                {
                        BYTE *p = pBits;

                        // We need to copy 2 pixels at a time to create a 32-bit value
                        // for the HOSTDATA register.
                        for (i = sizl.cx; i >= 2; i -= 2)
                        {
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], pulXlate[p[0]] |
                                                (pulXlate[p[1]] << 16));
                                p += 2;
                        }

                        // Write any remainig pixels.
                        if (i)
                        {
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], pulXlate[p[0]]);
                        }

                #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }
                #endif

                        // Next line.
                        pBits += lDelta;
                }
        }
        }

        /*      -----------------------------------------------------------------------
                Source is in same color depth as screen.
        */
        else
        {
        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // If we have a translation table, punt it.
#if _WIN32_WINNT >= 0x0500
                if ( pulXlate || (flXlate & 0x0200) )
#else
                if ( pulXlate || (flXlate & 0x0010) )
#endif
                {
                        return(FALSE);
                }

                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we also set the source phase.
                pBits += ptlSrc.x * 2;
                lLeadIn = (DWORD)pBits & 3;
                pBits -= lLeadIn;
                n = ((sizl.cx * 2) + lLeadIn + 3) >> 2;

        #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
        {
            if (MAKE_HD_INDEX(sizl.cx * 2, lLeadIn, ptlDest.x * 2) == 3788)
            {
                // We have a problem with the HOSTDATA TABLE.
                // Punt till we can figure it out.
                return FALSE;
            }
                    lExtra = ExtraDwordTable[MAKE_HD_INDEX(sizl.cx * 2, lLeadIn, ptlDest.x * 2)];
        }
        else
            lExtra = 0;
        #endif

                // Setup the Laguna registers.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);

                // Start the blit.
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // Copy all data in 32-bit. We don't have to worry about crossing any
                // boundaries, since within NT everything is DWORD aligned.
                while (sizl.cy--)
                {
                        WRITE_STRING(pBits, n);

            #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[i], 0);
                        }
            #endif

                        // Next line.
                        pBits += lDelta;
                }
   }
   return(TRUE);
}

/*****************************************************************************\
 * DoDeviceToHost16
 *
 * This routine performs a DeviceToHost for either monochrome or 16-bpp
 * destinations.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags.
\*****************************************************************************/
BOOL DoDeviceToHost16(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF
)
{
        POINTL ptlSrc;
        PPDEV  ppdev;
        SIZEL  sizl;
        PBYTE  pBits;
        #if !S2H_USE_ENGINE
        PBYTE  pjScreen;
        #endif
        LONG   lDelta;
        ULONG  i, n;

        // Determine the source type and calculate the offset.
        if (psoSrc->iType == STYPE_DEVBITMAP)
        {
                PDSURF pdsurf = (PDSURF)psoSrc->dhsurf;
                ppdev = pdsurf->ppdev;
                ptlSrc.x = pptlSrc->x + pdsurf->ptl.x;
                ptlSrc.y = pptlSrc->y + pdsurf->ptl.y;
        }
        else
        {
                ppdev = (PPDEV)psoSrc->dhpdev;
                ptlSrc.x = pptlSrc->x;
                ptlSrc.y = pptlSrc->y;
        }

        // Calculate the size of the blit.
        sizl.cx = prclTrg->right - prclTrg->left;
        sizl.cy = prclTrg->bottom - prclTrg->top;

        // Calculate the destination variables.
        lDelta = psoTrg->lDelta;
        pBits = (PBYTE)psoTrg->pvScan0 + (prclTrg->top * lDelta);

        #if S2H_USE_ENGINE
        // Setup the Laguna registers.
        REQUIRE(9);
        LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x20100000, 0);
        LL_OP0(0, 0);
        #else
        // Calculate the screen address.
        pjScreen = ppdev->pjScreen + ptlSrc.x * 2 + ptlSrc.y * ppdev->lDeltaScreen;

        // Wait for the hardware to become idle.
        while (LLDR_SZ(grSTATUS) != 0) ;
        #endif

        // Test for monochrome destination.
        if (psoTrg->iBitmapFormat == BMF_1BPP)
        {
                BYTE  data, leftMask, rightMask;
                WORD  fgColor;
                DWORD *pulXlate;
                LONG  leftCount, rightCount, leftSkip;
                #if S2H_USE_ENGINE
                BYTE  pixels[4];
                #endif

                // Calculate the monochrome masks.
                pBits += prclTrg->left >> 3;
                leftSkip = prclTrg->left & 7;
                leftCount = (8 - leftSkip) & 7;
                leftMask = 0xFF >> leftSkip;
                rightCount = prclTrg->right & 7;
                rightMask = 0xFF << (8 - rightCount);

                // If we only have pixels in one byte, we combine rightMask with
                // leftMask and set the routines to skip everything but the rightMask.
                if (leftCount > sizl.cx)
                {
                        rightMask &= leftMask;
                        leftMask = 0xFF;
                        n = 0;
                }
                else
                {
                        n = (sizl.cx - leftCount) >> 3;
                }

                // Get the the foreground color from the translation table.
                pulXlate = XLATEOBJ_piVector(pxlo);
                fgColor = pulXlate ? (WORD) *pulXlate : 0;

                #if S2H_USE_ENGINE
                // Start the blit.
                LL_OP1(ptlSrc.x - leftSkip, ptlSrc.y);
                LL_BLTEXT(sizl.cx + leftSkip, sizl.cy);
                #else
                pjScreen -= leftSkip * 2;
                #endif

                while (sizl.cy--)
                {
                        PBYTE pDest = pBits;
                        #if !S2H_USE_ENGINE
                        PWORD pSrc = (WORD *)pjScreen;
                        #endif

                        // If we have a left mask specified, we get the pixels and store
                        // them with the destination.
                        if (leftMask != 0xFF)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x80;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x40;
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x20;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x10;
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x08;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x04;
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x02;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x01;
                                #else
                                if (pSrc[0] == fgColor) data |= 0x80;
                                if (pSrc[1] == fgColor) data |= 0x40;
                                if (pSrc[2] == fgColor) data |= 0x20;
                                if (pSrc[3] == fgColor) data |= 0x10;
                                if (pSrc[4] == fgColor) data |= 0x08;
                                if (pSrc[5] == fgColor) data |= 0x04;
                                if (pSrc[6] == fgColor) data |= 0x02;
                                if (pSrc[7] == fgColor) data |= 0x01;
                                pSrc += 8;
                                #endif
                                *pDest++ = (*pDest & ~leftMask) | (data & leftMask);
                        }

                        // Translate all pixels that don't require masking.
                        for (i = 0; i < n; i++)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x80;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x40;
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x20;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x10;
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x08;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x04;
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x02;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x01;
                                #else
                                if (pSrc[0] == fgColor) data |= 0x80;
                                if (pSrc[1] == fgColor) data |= 0x40;
                                if (pSrc[2] == fgColor) data |= 0x20;
                                if (pSrc[3] == fgColor) data |= 0x10;
                                if (pSrc[4] == fgColor) data |= 0x08;
                                if (pSrc[5] == fgColor) data |= 0x04;
                                if (pSrc[6] == fgColor) data |= 0x02;
                                if (pSrc[7] == fgColor) data |= 0x01;
                                pSrc += 8;
                                #endif
                                *pDest++ = data;
                        }

                        // If we have a right mask specified, we get the pixels and store
                        // them with the destination.
                        if (rightMask != 0x00)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x80;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x40;
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x20;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x10;
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x08;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x04;
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x02;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x01;
                                #else
                                if (pSrc[0] == fgColor) data |= 0x80;
                                if (pSrc[1] == fgColor) data |= 0x40;
                                if (pSrc[2] == fgColor) data |= 0x20;
                                if (pSrc[3] == fgColor) data |= 0x10;
                                if (pSrc[4] == fgColor) data |= 0x08;
                                if (pSrc[5] == fgColor) data |= 0x04;
                                if (pSrc[6] == fgColor) data |= 0x02;
                                if (pSrc[7] == fgColor) data |= 0x01;
                                #endif
                                *pDest = (*pDest & ~rightMask) | (data & rightMask);
                        }

                        // Next line.
                        #if !S2H_USE_ENGINE
                        pjScreen += ppdev->lDeltaScreen;
                        #endif
                        pBits += lDelta;
                }
        }

        // We only support destination bitmaps with the same color depth and we
        // do not support any color translation.
        else if ( (psoTrg->iBitmapFormat != BMF_16BPP) ||
                          (pxlo && !(pxlo->flXlate & XO_TRIVIAL)) )
        {
                return(FALSE);
        }

        /*
                If the GetPixel routine is being called, we get here with both cx and
                cy set to 1 and the ROP to 0xCC (source copy). In this special case we
                read the pixel directly from memory. Of course, we must be sure the
                blit engine is finished working since it may still update the very
                pixel we are going to read! We could use the hardware for this, but it
                seems there is a HARDWARE BUG that doesn't seem to like the 1-pixel
                ScreenToHost very much.
        */
        #if S2H_USE_ENGINE
        else if ( (sizl.cx == 1) && (sizl.cy == 1) && (ulDRAWBLTDEF == 0x000000CC) )
        {
                // Wait for the hardware to become idle.
                while (LLDR_SZ(grSTATUS) != 0) ;

                // Get the pixel from screen.
                *(WORD *)pBits[prclTrg->left] = *(WORD *)
                        &ppdev->pjScreen[ptlSrc.x * 2 + ptlSrc.y * ppdev->lDeltaScreen];
        }
        #endif

        else
        {
                #if S2H_USE_ENGINE
                // The hardware requires us to get QWORDS.
                BOOL fExtra = ((sizl.cx * 2 + 3) >> 2) & 1;
                #endif
                pBits += prclTrg->left * 2;

                #if S2H_USE_ENGINE
                // Start the blit.
                LL_OP1(ptlSrc.x, ptlSrc.y);
                LL_BLTEXT(sizl.cx, sizl.cy);
                #endif

                while (sizl.cy--)
                {
                        #if S2H_USE_ENGINE
                        DWORD *p = (DWORD *)pBits;

                        // First, we get pixels in chunks of 2 so the 32-bit HOSTDATA is
                        // happy.
                        for (i = sizl.cx; i >= 2; i -= 2)
                        {
                                *p++ = LLDR_SZ(grHOSTDATA[0]);
                        }

                        // Then, we have to do the remainig pixel.
                        if (i)
                        {
                                *(WORD *)p = (WORD)LLDR_SZ(grHOSTDATA[0]);
                        }

                        // Get the extra pixel required for QWORD alignment.
                        if (fExtra)
                        {
                                LLDR_SZ(grHOSTDATA[0]);
                        }
                        #else
                        // Copy all pixels from screen to memory.
                        memcpy(pBits, pjScreen, sizl.cx * 2);

                        // Next line.
                        pjScreen += ppdev->lDeltaScreen;
                        #endif
                        pBits += lDelta;
                }
        }
        return(TRUE);
}

/*****************************************************************************\
 *                                                                                                                                                       *
 *                                                                 2 4 - B P P                                                           *
 *                                                                                                                                                       *
\*****************************************************************************/

/*****************************************************************************\
 * DoHost24ToDevice
 *
 * This routine performs a HostToScreen or HostToDevice blit. The host data
 * can be either monochrome, 4-bpp, or 24-bpp. Color translation is only
 * supported for monochrome and 4-bpp modes.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags.
\*****************************************************************************/
BOOL DoHost24ToDevice(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF
)
{
        POINTL ptlDest, ptlSrc;
        SIZEL  sizl;
        PPDEV  ppdev;
        PBYTE  pBits;
        LONG   lDelta, i, n, lLeadIn, lExtra, i1;
        ULONG  *pulXlate;
        FLONG  flXlate;

        // Calculate te source offset.
        ptlSrc.x = pptlSrc->x;
        ptlSrc.y = pptlSrc->y;

        // Determine the destination type and calculate the destination offset.
        if (psoTrg->iType == STYPE_DEVBITMAP)
        {
                PDSURF pdsurf = (PDSURF) psoTrg->dhsurf;
                ptlDest.x = prclTrg->left + pdsurf->ptl.x;
                ptlDest.y = prclTrg->top + pdsurf->ptl.y;
                ppdev = pdsurf->ppdev;
        }
        else
        {
                ptlDest.x = prclTrg->left;
                ptlDest.y = prclTrg->top;
                ppdev = (PPDEV) psoTrg->dhpdev;
        }

        // Calculate the size of the blit.
    sizl.cx = prclTrg->right - prclTrg->left;
    sizl.cy = prclTrg->bottom - prclTrg->top;

        // Get the source variables and ofsfet into source bits.
        lDelta = psoSrc->lDelta;
        pBits = (PBYTE)psoSrc->pvScan0 + (ptlSrc.y * lDelta);


        /*      -----------------------------------------------------------------------
                Test for monochrome source.
        */
        if (psoSrc->iBitmapFormat == BMF_1BPP)
        {
                ULONG bgColor, fgColor;
#if SWAT7
                SIZEL sizlTotal;
#endif

        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // Set background and foreground colors.
                if (pulXlate == NULL)
                {
                        bgColor = 0x00000000;
                        fgColor = 0x00FFFFFF;
                }
                else
                {
                        bgColor = pulXlate[0] & 0x00FFFFFF;
                        fgColor = pulXlate[1] & 0x00FFFFFF;
                }

                //
                // Special case: when we are expanding monochrome sources and we
                // already have a colored brush, we must make sure the monochrome color
                // translation can be achived by setting the saturation bit (expanding
                // 0's to 0 and 1's to 1). If the monochrome source also requires color
                // translation, we simply punt this blit back to GDI.
                //
                if (ulDRAWBLTDEF & 0x00040000)
                {
                        if ( (bgColor == 0x00000000) && (fgColor == 0x00FFFFFF) )
                        {
                                // Enable saturation for source (OP1).
                                ulDRAWBLTDEF |= 0x00008000;
                        }
                        #if SOLID_CACHE
                        else if ( ((ulDRAWBLTDEF & 0x000F0000) == 0x00070000) &&
                                          ppdev->Bcache )
                        {
                                CacheSolid(ppdev);
                                ulDRAWBLTDEF ^= (0x00070000 ^ 0x00090000);
                                REQUIRE(4);
                                LL_BGCOLOR(bgColor, 2);
                                LL_FGCOLOR(fgColor, 2);
                        }
                        #endif
                        else
                        {
                                // Punt this call to the GDI.
                                return(FALSE);
                        }
                }
                else
                {
                        REQUIRE(4);
                        LL_BGCOLOR(bgColor, 2);
                        LL_FGCOLOR(fgColor, 2);
                }

                REQUIRE(9);
#if SWAT7
                // Setup the Laguna registers for the blit. We also set the bit swizzle
                // bit in the grCONTROL register.
                ppdev->grCONTROL |= SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10600000, 2);

                sizlTotal = sizl;
                while (sizlTotal.cx)
                {
                        sizl.cx = min(sizlTotal.cx, 864);
                        sizl.cy = sizlTotal.cy;
#endif
                // Calculate the source parameters. We are going to BYTE
                // adjust the source, so we must setup the source phase.
                lLeadIn = ptlSrc.x & 7;
                pBits += ptlSrc.x >> 3;
                n = (sizl.cx + lLeadIn + 7) >> 3;

#if !SWAT7
        //
        // Chip bug. Laguna locks with more than 15 dwords HOSTDATA
        //
        if (n > 120) // 15 qwords = 120 bytes
        {
            return FALSE;
        }

                // Setup the Laguna registers for the blit. We also set the bit swizzle
                // bit in the grCONTROL register.
                ppdev->grCONTROL |= SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10600000, 2);
#endif

                // Start the blit.
// added REQUIRE above
//              REQUIRE(7);
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // Copy all the bits to the screen, 32-bits at a time. We don't have to
                // worry about crossing any boundary since NT is always DWORD aligned.
                while (sizl.cy--)
                {
                        BYTE *p = pBits;
                        BYTE pixels[4];

                        // First, we draw 32-pixels at a time to keep HOSTDATA happy.
                        for (i = n; i >= 4; i -= 4)
                        {
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], *(DWORD *)p);
                                p += 4;
                        }

                        // Draw any remainig pixls.
                        switch (i)
                        {
                                case 1:
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], *p);
                                        break;

                                case 2:
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], *(WORD *)p);
                                        break;

                                case 3:
                                        pixels[0] = p[0];
                                        pixels[1] = p[1];
                                        pixels[2] = p[2];
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], *(DWORD *)pixels);
                                        break;
                        }

                        // Next line.
                        pBits += lDelta;
                }
#if SWAT7
                sizlTotal.cx -= sizl.cx;
                ptlSrc.x += sizl.cx;
                ptlDest.x += sizl.cx;

                #if 1 // SWAT: 08/08/97
                // Reload pBits.
                pBits = (PBYTE) psoSrc->pvScan0 + (ptlSrc.y * lDelta);
                #endif
                }
#endif

                // Disable the swizzle bit in the grCONTROL register.
                ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
        }

        /*      -----------------------------------------------------------------------
                Test for 4-bpp source.
        */
        else if (psoSrc->iBitmapFormat == BMF_4BPP)
        {
        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // Calculate the source parameters. We are going to BYTE adjust the
                // source, so we also set the source phase.
                lLeadIn = (ptlSrc.x & 1) * 3;
                pBits += ptlSrc.x >> 1;
                n = sizl.cx + (ptlSrc.x & 1);

        #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
        {
            if (MAKE_HD_INDEX(sizl.cx * 3, lLeadIn, ptlDest.x * 3) == 3788)
            {
                // We have a problem with the HOSTDATA TABLE.
                // Punt till we can figure it out.
                return FALSE;
            }
                lExtra = ExtraDwordTable[MAKE_HD_INDEX(sizl.cx * 3, lLeadIn, ptlDest.x * 3)];
        }
        else
            lExtra = 0;
        #endif

                // Start the blit.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // If there is no translation table, use the default translation table.
                if (pulXlate == NULL)
                {
                        pulXlate = ulXlate;
                }

                // Now we are ready to copy all the pixels to the hardware.
                while (sizl.cy--)
                {
                        BYTE  *p = pBits;
                        ULONG pixels[4];

                        // First, we convert 4 pixels at a time to create three 32-bit
                        // values to write to the hardware.
                        for (i = n; i >= 4; i -= 4)
                        {
                                pixels[0] = pulXlate[p[0] >> 4];
                                pixels[1] = pulXlate[p[0] & 0x0F];
                                pixels[2] = pulXlate[p[1] >> 4];
                                pixels[3] = pulXlate[p[1] & 0x0F];
                                // 1000
                                REQUIRE(3);
                                LL32(grHOSTDATA[0], pixels[0] | (pixels[1] << 24));
                                // 2211
                                LL32(grHOSTDATA[1], (pixels[1] >> 8) | (pixels[2] << 16));
                                // 3332
                                LL32(grHOSTDATA[2], (pixels[2] >> 16) | (pixels[3] << 8));
                                p += 2;
                        }

                        // Now, write any remaining pixels.
                        switch (i)
                        {
                                case 1:
                                        // x000
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], pulXlate[p[0] >> 4]);
                                        break;

                                case 2:
                                        pixels[0] = pulXlate[p[0] >> 4];
                                        pixels[1] = pulXlate[p[0] & 0x0F];
                                        // 1000
                                        REQUIRE(2);
                                        LL32(grHOSTDATA[0], pixels[0] | (pixels[1] << 24));
                                        // xx11
                                        LL32(grHOSTDATA[1], pixels[1] >> 8);
                                        break;

                                case 3:
                                        pixels[0] = pulXlate[p[0] >> 4];
                                        pixels[1] = pulXlate[p[0] & 0x0F];
                                        pixels[2] = pulXlate[p[1] >> 4];
                                        // 1000
                                        REQUIRE(3);
                                        LL32(grHOSTDATA[0], pixels[0] | (pixels[1] << 24));
                                        // 2211
                                        LL32(grHOSTDATA[1], (pixels[1] >> 8) | (pixels[2] << 16));
                                        // xxx2
                                        LL32(grHOSTDATA[2], pixels[2] >> 16);
                                        break;
                        }

            #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }
            #endif

                        // Next line.
                        pBits += lDelta;
                }
        }

        /*      -----------------------------------------------------------------------
                Test for 8-bpp source.
        */
        else if (psoSrc->iBitmapFormat == BMF_8BPP)
        {

        //
        // Attempt to load the translation table into the chip.
        // After this call:
        //   pulXlate == NULL if there is no color translation is required.
        //   pulXlate == translation table if color translation is required.
        //   UseHWxlate == FALSE if the hardware will do the xlate for us.
        //   UseHWxlate == TRUE if we must do the translation in software.
        //
                #if COLOR_TRANSLATE
        ULONG UseHWxlate = bCacheXlateTable(ppdev, &pulXlate, psoTrg, psoSrc,
                                                                                        pxlo, (BYTE)(ulDRAWBLTDEF&0xCC));
                #else
                if ( (pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL) )
                {
                        pulXlate = NULL;
                }
                else if (pxlo->flXlate & XO_TABLE)
                {
                        pulXlate = pxlo->pulXlate;
                }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }
                #endif

        // A translation table is required.
        // "Well, DUH!" you might say, but I've seen it missing before...
        if (!pulXlate)
        {
            DISPDBG((0, "\n\nHost24ToDevice: !!! WARNING !!! 8BPP source "
            "bitmap does not have a translation table.  Punting!\n\n"));
            return FALSE;
        }

#if COLOR_TRANSLATE
        //
        // NVH:  5465 Color XLATE bug!!!
        // Color translation is broken on the 5465 in 16, 24 and 32 bpp.
        //
        if (UseHWxlate)
        {
            DWORD phase = ( ((DWORD)(pBits + ptlSrc.x)) & 3);
            if (XLATE_IS_BROKEN(sizl.cx, 3, phase))
                UseHWxlate = FALSE; // force SW translation.
        }

        if (UseHWxlate)
        {
            // Use Hardware color translation.

            DISPDBG((COPYBITS_DBG_LEVEL, "Host24ToDevice: "
            "Attempting HW color translation on 8bpp Host to 24bpp Screen.\n"));

                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we also set the source phase.
                pBits += ptlSrc.x;               // Start of source data on the host.
            lLeadIn = (DWORD)pBits & 3;      // Source phase.
                pBits -= lLeadIn;                // Backup to DWORD boundry.
                n = (sizl.cx + lLeadIn + 3) >> 2;// Number of HOSTDATA per scanline.


                // Start the blit.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
                LL_OP1_MONO(lLeadIn, 0);
                    LL_OP0(ptlDest.x, ptlDest.y);
            LL_BLTEXT_XLATE(8, sizl.cx, sizl.cy); // HW xlate.


                        while (sizl.cy--)
                        {
                                // Copy all data in 32-bit. We don't have to worry about
                                // crossing any boundaries, since within NT everything is DWORD
                                // aligned.
                                WRITE_STRING(pBits, n);
                                pBits += lDelta;
                        }

        }
        else
#endif
        {
            //
            // Use SW color translation.
            //

                // Calculate the source parameters.
                pBits += ptlSrc.x;

            #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
            {
                if (MAKE_HD_INDEX(sizl.cx * 3, 0, ptlDest.x * 3) == 3788)
                {
                    // We have a problem with the HOSTDATA TABLE.
                    // Punt till we can figure it out.
                    return FALSE;
                }
                        lExtra = ExtraDwordTable[MAKE_HD_INDEX(sizl.cx * 3, 0, ptlDest.x * 3)];
            }
            else
            {
                lExtra = 0;
                        }
            #endif

                // Setup the Laguna registers.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);

                // Start the blit.
                LL_OP1_MONO(0, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                while (sizl.cy--)
                {
                        BYTE *p = pBits;

                        // We need to copy 4 pixels at a time to create three 32-bit values
                        // for the HOSTDATA register and stay in sync.
                        for (i = sizl.cx; i >= 4; i -= 4)
                        {
                                REQUIRE(3);
                                LL32(grHOSTDATA[0],
                                         pulXlate[p[0]] | (pulXlate[p[1]] << 24));
                                LL32(grHOSTDATA[1],
                                         (pulXlate[p[1]] >> 8) | (pulXlate[p[2]] << 16));
                                LL32(grHOSTDATA[2],
                                         (pulXlate[p[2]] >> 16) | (pulXlate[p[3]] << 8));
                                p += 4;
                        }

                        // Write any remainig pixels.
                        switch (i)
                        {
                                case 1:
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], pulXlate[p[0]]);
                                        break;

                                case 2:
                                        REQUIRE(2);
                                        LL32(grHOSTDATA[0],
                                                 pulXlate[p[0]] | (pulXlate[p[1]] << 24));
                                        LL32(grHOSTDATA[1], pulXlate[p[1]] >> 8);
                                        break;

                                case 3:
                                        REQUIRE(3);
                                        LL32(grHOSTDATA[0],
                                                 pulXlate[p[0]] | (pulXlate[p[1]] << 24));
                                        LL32(grHOSTDATA[1],
                                                 (pulXlate[p[1]] >> 8) | (pulXlate[p[2]] << 16));
                                        LL32(grHOSTDATA[2], pulXlate[p[2]] >> 16);
                                        break;
                        }

                #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }
                #endif

                        // Next line.
                        pBits += lDelta;
            }
                }
        }

        /*      -----------------------------------------------------------------------
                Source is in same color depth as screen.
        */
        else
        {
        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // If we have a translation table, punt it.
                if ( pulXlate || (flXlate & 0x10) )
                {
                        return(FALSE);
                }

                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we also set the source phase.
                pBits += ptlSrc.x * 3;
                lLeadIn = (DWORD)pBits & 3;
                pBits -= lLeadIn;
                n = (sizl.cx * 3 + lLeadIn + 3) >> 2;

        #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
        {
            if (MAKE_HD_INDEX(sizl.cx * 3, lLeadIn, ptlDest.x * 3) == 3788)
            {
                // We have a problem with the HOSTDATA TABLE.
                // Punt till we can figure it out.
                return FALSE;
            }
                lExtra = ExtraDwordTable[MAKE_HD_INDEX(sizl.cx * 3, lLeadIn, ptlDest.x * 3)];
        }
        else
            lExtra = 0;
        #endif

                // Setup the Laguna registers.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);

                // Start the blit.
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // Copy all data in 32-bit. We don't have to worry about crossing any
                // boundaries, since within NT everything is DWORD aligned.
                while (sizl.cy--)
                {
                        WRITE_STRING(pBits, n);

            #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }
            #endif

                        // Next line.
                        pBits += lDelta;
                }
   }
   return(TRUE);
}

/*****************************************************************************\
 * DoDeviceToHost24
 *
 * This routine performs a DeviceToHost for either monochrome or 24-bpp
 * destinations.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags.
\*****************************************************************************/
BOOL DoDeviceToHost24(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF
)
{
        POINTL ptlSrc;
        PPDEV  ppdev;
        SIZEL  sizl;
        PBYTE  pBits;
        #if !S2H_USE_ENGINE
        PBYTE  pjScreen;
        #endif
        LONG   lDelta;
        ULONG  i, n;

        // Determine the source type and calculate the offset.
        if (psoSrc->iType == STYPE_DEVBITMAP)
        {
                PDSURF pdsurf = (PDSURF)psoSrc->dhsurf;
                ppdev = pdsurf->ppdev;
                ptlSrc.x = pptlSrc->x + pdsurf->ptl.x;
                ptlSrc.y = pptlSrc->y + pdsurf->ptl.y;
        }
        else
        {
                ppdev = (PPDEV)psoSrc->dhpdev;
                ptlSrc.x = pptlSrc->x;
                ptlSrc.y = pptlSrc->y;
        }

        // Calculate the size of the blit.
        sizl.cx = prclTrg->right - prclTrg->left;
        sizl.cy = prclTrg->bottom - prclTrg->top;

        // Calculate the destination variables.
        lDelta = psoTrg->lDelta;
        pBits = (PBYTE)psoTrg->pvScan0 + (prclTrg->top * lDelta);

        #if S2H_USE_ENGINE
        // Setup the Laguna registers.
        REQUIRE(9);
        LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x20100000, 0);
        LL_OP0(0, 0);
        #else
        // Calculate the screen address.
        pjScreen = ppdev->pjScreen + ptlSrc.x * 3 + ptlSrc.y * ppdev->lDeltaScreen;

        // Wait for the hardware to become idle.
        while (LLDR_SZ(grSTATUS) != 0) ;
        #endif

        // Test for a monochrome destination.
        if (psoTrg->iBitmapFormat == BMF_1BPP)
        {
                BYTE  data, leftMask, rightMask;
                ULONG fgColor;
                DWORD *pulXlate;
                LONG  leftCount, rightCount, leftSkip;
                BYTE  pixels[12];

                // Calculate the monochrome masks.
                pBits += prclTrg->left >> 3;
                leftSkip = prclTrg->left & 7;
                leftCount = (8 - leftSkip) & 7;
                leftMask = 0xFF >> leftSkip;
                rightCount = prclTrg->right & 7;
                rightMask = 0xFF << (8 - rightCount);

                // If we only have pixels in one byte, we combine rightMask with
                // leftMask and set the routine to skip everything but the rightMask.
                if (leftCount > sizl.cx)
                {
                        rightMask &= leftMask;
                        leftMask = 0xFF;
                        n = 0;
                }
                else
                {
                        n = (sizl.cx - leftCount) >> 3;
                }

                // Get the foreground color from the translation table.
                pulXlate = XLATEOBJ_piVector(pxlo);
                fgColor = pulXlate ? *pulXlate : 0;

                #if S2H_USE_ENGINE
                // Start the blit.
                LL_OP1(ptlSrc.x - leftSkip, ptlSrc.y);
                LL_BLTEXT(sizl.cx + leftSkip, sizl.cy);
                #else
                pjScreen -= leftSkip * 3;
                #endif

                while (sizl.cy--)
                {
                        PBYTE pDest = pBits;
                        #if !S2H_USE_ENGINE
                        DWORD *pSrc = (DWORD *)pjScreen;
                        #endif

                        // If we have a leftMask specified, we get the pixels and store
                        // them in the destination.
                        if (leftMask != 0xFF)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                *(DWORD *)&pixels[0] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[4] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[8] = LLDR_SZ(grHOSTDATA[0]);
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x80;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x40;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x20;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x10;
                                *(DWORD *)&pixels[0] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[4] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[8] = LLDR_SZ(grHOSTDATA[0]);
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x08;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x04;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x02;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x01;
                                #else
                                *(DWORD *)&pixels[0] = pSrc[0];
                                *(DWORD *)&pixels[4] = pSrc[1];
                                *(DWORD *)&pixels[8] = pSrc[2];
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x80;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x40;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x20;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x10;
                                *(DWORD *)&pixels[0] = pSrc[3];
                                *(DWORD *)&pixels[4] = pSrc[4];
                                *(DWORD *)&pixels[8] = pSrc[5];
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x08;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x04;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x02;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x01;
                                pSrc += 6;
                                #endif
                                *pDest++ = (*pDest & ~leftMask) | (data & leftMask);
                        }

                        // Translate all pixels that don't require masking.
                        for (i = 0; i < n; i++)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                *(DWORD *)&pixels[0] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[4] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[8] = LLDR_SZ(grHOSTDATA[0]);
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x80;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x40;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x20;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x10;
                                *(DWORD *)&pixels[0] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[4] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[8] = LLDR_SZ(grHOSTDATA[0]);
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x08;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x04;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x02;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x01;
                                #else
                                *(DWORD *)&pixels[0] = pSrc[0];
                                *(DWORD *)&pixels[4] = pSrc[1];
                                *(DWORD *)&pixels[8] = pSrc[2];
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x80;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x40;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x20;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x10;
                                *(DWORD *)&pixels[0] = pSrc[3];
                                *(DWORD *)&pixels[4] = pSrc[4];
                                *(DWORD *)&pixels[8] = pSrc[5];
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x08;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x04;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x02;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x01;
                                pSrc += 6;
                                #endif
                                *pDest++ = data;
                        }

                        // If we have a rightMask specified, we get the pixels and store
                        // them in the destination.
                        if (rightMask != 0x00)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                *(DWORD *)&pixels[0] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[4] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[8] = LLDR_SZ(grHOSTDATA[0]);
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x80;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x40;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x20;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x10;
                                *(DWORD *)&pixels[0] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[4] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[8] = LLDR_SZ(grHOSTDATA[0]);
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x08;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x04;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x02;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x01;
                                #else
                                *(DWORD *)&pixels[0] = pSrc[0];
                                *(DWORD *)&pixels[4] = pSrc[1];
                                *(DWORD *)&pixels[8] = pSrc[2];
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x80;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x40;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x20;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x10;
                                *(DWORD *)&pixels[0] = pSrc[3];
                                *(DWORD *)&pixels[4] = pSrc[4];
                                *(DWORD *)&pixels[8] = pSrc[5];
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x08;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x04;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x02;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x01;
                                #endif
                                *pDest = (*pDest & ~rightMask) | (data & rightMask);
                        }

                        // Next line.
                        #if !S2H_USE_ENGINE
                        pjScreen += ppdev->lDeltaScreen;
                        #endif
                        pBits += lDelta;
                }
        }

        // We only support destination bitmaps with the same color depth and we
        // do not support any color translation.
        else if ( (psoTrg->iBitmapFormat != BMF_24BPP) ||
                          (pxlo && !(pxlo->flXlate & XO_TRIVIAL)) )
        {
                return(FALSE);
        }

        /*
                If the GetPixel routine is being called, we get here with both cx and
                cy set to 1 and the ROP to 0xCC (source copy). In this special case we
                read the pixel directly from memory. Of course, we must be sure the
                blit engine is finished working since it may still update the very
                pixel we are going to read! We could use the hardware for this, but it
                seems there is a HARDWARE BUG that doesn't seem like the 1-pixel
                ScreenToHost very much.
        */
        #if S2H_USE_ENGINE
        else if ( (sizl.cx == 1) && (sizl.cy == 1) && (ulDRAWBLTDEF == 0x000000CC) )
        {
                DWORD data;

                // Wait for the hardware to become idle.
                while (LLDR_SZ(grSTATUS) != 0) ;

                // Get the pixel from screen.
                pBits += prclTrg->left * 3;
                data = *(DWORD *)
                        &ppdev->pjScreen[ptlSrc.x * 3 + ptlSrc.y * ppdev->lDeltaScreen];
                *(WORD *)&pBits[0] = (WORD)data;
                *(BYTE *)&pBits[2] = (BYTE)(data >> 16);
        }
        #endif

        else
        {
                #if S2H_USE_ENGINE
                // The hardware requires us to get QWORDS.
                BOOL fExtra = ((sizl.cx * 3 + 3) >> 2) & 1;
                #endif
                pBits += prclTrg->left * 3;

                #if S2H_USE_ENGINE
                // Start the blit.
                LL_OP1(ptlSrc.x, ptlSrc.y);
                LL_BLTEXT(sizl.cx, sizl.cy);
                #endif

                while (sizl.cy--)
                {
                        #if S2H_USE_ENGINE
                        DWORD *p = (DWORD *)pBits;

                        // First, we get pixels in chunks of 4 so the 32-bit HOSTDATA is
                        // happy and we are still in phase.
                        for (i = sizl.cx; i >= 4; i -= 4)
                        {
                                *p++ = LLDR_SZ(grHOSTDATA[0]);
                                *p++ = LLDR_SZ(grHOSTDATA[0]);
                                *p++ = LLDR_SZ(grHOSTDATA[0]);
                        }

                        // Then, we have to do the remaining pixel(s).
                        switch (i)
                        {
                                case 1:
                                        i = LLDR_SZ(grHOSTDATA[0]);
                                        ((WORD *)p)[0] = (WORD)i;
                                        ((BYTE *)p)[2] = (BYTE)(i >> 16);
                                        break;

                                case 2:
                                        *p++ = LLDR_SZ(grHOSTDATA[0]);
                                        *(WORD *)p = (WORD)LLDR_SZ(grHOSTDATA[0]);
                                        break;

                                case 3:
                                        *p++ = LLDR_SZ(grHOSTDATA[0]);
                                        *p++ = LLDR_SZ(grHOSTDATA[0]);
                                        *(BYTE *)p = (BYTE)LLDR_SZ(grHOSTDATA[0]);
                                        break;
                        }

                        // Get the extra pixel required for QWORD alignment.
                        if (fExtra)
                        {
                                LLDR_SZ(grHOSTDATA[0]);
                        }
                        #else
                        // Copy all pixels from screen to memory.
                        memcpy(pBits, pjScreen, sizl.cx * 3);

                        // Next line.
                        pjScreen += ppdev->lDeltaScreen;
                        #endif
                        pBits += lDelta;
                }
        }
        return(TRUE);
}

/*****************************************************************************\
 *                                                                                                                                                       *
 *                                                                 3 2 - B P P                                                           *
 *                                                                                                                                                       *
\*****************************************************************************/

/*****************************************************************************\
 * DoHost32ToDevice
 *
 * This routine performs a HostToScreen or HostToDevice blit. The host data
 * can be either monochrome, 4-bpp, or 32-bpp. Color translation is only
 * supported for monochrome and 4-bpp modes.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags.
\*****************************************************************************/
BOOL DoHost32ToDevice(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF
)
{
        POINTL ptlDest, ptlSrc;
        SIZEL  sizl;
        PPDEV  ppdev;
        PBYTE  pBits;
        LONG   lDelta, i, n, lLeadIn, lExtra, i1;
        ULONG  *pulXlate;
        FLONG  flXlate;

        // Calculate te source offset.
        ptlSrc.x = pptlSrc->x;
        ptlSrc.y = pptlSrc->y;

        // Determine the destination type and calculate the destination offset.
        if (psoTrg->iType == STYPE_DEVBITMAP)
        {
                PDSURF pdsurf = (PDSURF) psoTrg->dhsurf;
                ptlDest.x = prclTrg->left + pdsurf->ptl.x;
                ptlDest.y = prclTrg->top + pdsurf->ptl.y;
                ppdev = pdsurf->ppdev;
        }
        else
        {
                ptlDest.x = prclTrg->left;
                ptlDest.y = prclTrg->top;
                ppdev = (PPDEV) psoTrg->dhpdev;
        }

        // Calculate the size of the blit.
    sizl.cx = prclTrg->right - prclTrg->left;
    sizl.cy = prclTrg->bottom - prclTrg->top;

        // Get the source variables and ofFset into source bits.
        lDelta = psoSrc->lDelta;
        pBits = (PBYTE)psoSrc->pvScan0 + (ptlSrc.y * lDelta);

        /*      -----------------------------------------------------------------------
                Test for monochrome source.
        */
        if (psoSrc->iBitmapFormat == BMF_1BPP)
        {
                ULONG  bgColor, fgColor;
#if SWAT7
                SIZEL  sizlTotal;
#endif

        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }


                // Set background and foreground colors.
                if (pulXlate == NULL)
                {
                        bgColor = 0x00000000;
                        fgColor = 0xFFFFFFFF;
                }
                else
                {
                        bgColor = pulXlate[0];
                        fgColor = pulXlate[1];
                }

                //
                // Special case: when we are expanding monochrome sources and we
                // already have a colored brush, we must make sure the monochrome color
                // translation can be achived by setting the saturation bit (expanding
                // 0's to 0 and 1's to 1). If the monochrome source also requires color
                // translation, we simply punt this blit back to GDI.
                //
                if (ulDRAWBLTDEF & 0x00040000)
                {
                        if ( (bgColor == 0x00000000) &&
                                 ((fgColor & 0x00FFFFFF) == 0x00FFFFFF) )
                        {
                                // Enable saturation for source (OP1).
                                ulDRAWBLTDEF |= 0x00008000;
                        }
                        #if SOLID_CACHE
                        else if ( ((ulDRAWBLTDEF & 0x000F0000) == 0x00070000) &&
                                          ppdev->Bcache )
                        {
                                CacheSolid(ppdev);
                                ulDRAWBLTDEF ^= (0x00070000 ^ 0x00090000);
                REQUIRE(4);
                                LL_BGCOLOR(bgColor, 2);
                                LL_FGCOLOR(fgColor, 2);
                        }
                        #endif
                        else
                        {
                                // Punt this call to the GDI.
                                return(FALSE);
                        }
                }
                else
                {
                        REQUIRE(4);
                        LL_BGCOLOR(bgColor, 2);
                        LL_FGCOLOR(fgColor, 2);
                }

                REQUIRE(9);
#if SWAT7
                // Setup the Laguna registers for the blit. We also set the bit swizzle
                // bit in the grCONTROL register.
                ppdev->grCONTROL |= SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10600000, 2);

                sizlTotal = sizl;
                while (sizlTotal.cx)
                {
                        sizl.cx = min(sizlTotal.cx, 864);
                        sizl.cy = sizlTotal.cy;
#endif
                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we must setup the source phase.
                lLeadIn = ptlSrc.x & 31;
                pBits += (ptlSrc.x >> 3) & ~3;
                n = (sizl.cx + lLeadIn + 31) >> 5;

#if !SWAT7
        //
        // Chip bug. Laguna locks with more than 14 dwords HOSTDATA
        //
        if (n > 28) // 14 qwords = 28 dwords
        {
            return FALSE;
        }

                // Setup the Laguna registers for the blit. We also set the bit swizzle
                // bit in the grCONTROL register.
                ppdev->grCONTROL |= SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10600000, 2);
#endif

                // Start the blit.
// added REQUIRE above
//              REQUIRE(7);
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // Copy all the bits to the screen, 32-bits at a time. We don't have to
                // worry about crossing any boundary since NT is always DWORD aligned.
                while (sizl.cy--)
                {
                        WRITE_STRING(pBits, n);
                        pBits += lDelta;
                }
#if SWAT7
                sizlTotal.cx -= sizl.cx;
                ptlSrc.x += sizl.cx;
                ptlDest.x += sizl.cx;

                // Reload pBits.
                pBits = (PBYTE) psoSrc->pvScan0 + (ptlSrc.y * lDelta);
                }
#endif

                // Disable the swizzle bit in the grCONTROL register.
                ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
        }

        /*      -----------------------------------------------------------------------
                Test for 4-bpp source.
        */
        else if (psoSrc->iBitmapFormat == BMF_4BPP)
        {
        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // Calculate the source parameters.
                pBits += ptlSrc.x >> 1;

        #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
        {
            if (MAKE_HD_INDEX(sizl.cx * 4, 0, ptlDest.x * 4) == 3788)
            {
                // We have a problem with the HOSTDATA TABLE.
                // Punt till we can figure it out.
                return FALSE;
            }
                lExtra = ExtraDwordTable[MAKE_HD_INDEX(sizl.cx * 4, 0, ptlDest.x * 4)];
        }
        else
            lExtra = 0;
        #endif

                // Start the blit.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
                LL_OP1_MONO(0, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // If there is no translation table, use the default translation table.
                if (pulXlate == NULL)
                {
                        pulXlate = ulXlate;
                }

                // Now we are ready to copy all the pixels to the hardware.
                while (sizl.cy--)
                {
                        BYTE  *p = pBits;

                        // First, we must align the source to a BYTE boundary.
                        if (ptlSrc.x & 1)
                        {
                                // We convert 2 pixels at a time to create two 32-bit values
                                // to write to the hardware.
                                for (i = sizl.cx; i >= 2; i -= 2)
                                {
                                        REQUIRE(2);
                                        LL32(grHOSTDATA[0], pulXlate[p[0] & 0x0F]);
                                        LL32(grHOSTDATA[1], pulXlate[p[1] >> 4]);
                                        p++;
                                }

                                // Now, write any remaining pixel.
                                if (i)
                                {
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], pulXlate[*p & 0x0F]);
                                }
                        }
                        else
                        {
                                // We convert 2 pixels at a time to create two 32-bit values
                                // to write to the hardware.
                                for (i = sizl.cx; i >= 2; i -= 2)
                                {
                                        REQUIRE(2);
                                        LL32(grHOSTDATA[0], pulXlate[p[0] >> 4]);
                                        LL32(grHOSTDATA[1], pulXlate[p[0] & 0x0F]);
                                        p++;
                                }

                                // Now, write any remaining pixel.
                                if (i)
                                {
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], pulXlate[*p >> 4]);
                                }
                        }

            #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }
            #endif

                        // Next line.
                        pBits += lDelta;
                }
        }

        /*      -----------------------------------------------------------------------
                Test for 8-bpp source.
        */
        else if (psoSrc->iBitmapFormat == BMF_8BPP)
        {

        //
        // Attempt to load the translation table into the chip.
        // After this call:
        //   pulXlate == NULL if there is no color translation is required.
        //   pulXlate == translation table if color translation is required.
        //   UseHWxlate == FALSE if the hardware will do the xlate for us.
        //   UseHWxlate == TRUE if we must do the translation in software.
        //
                #if COLOR_TRANSLATE
        ULONG UseHWxlate = bCacheXlateTable(ppdev, &pulXlate, psoTrg, psoSrc,
                                                                                        pxlo, (BYTE)(ulDRAWBLTDEF&0xCC));
                #else
                if ( (pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL) )
                {
                        pulXlate = NULL;
                }
                else if (pxlo->flXlate & XO_TABLE)
                {
                        pulXlate = pxlo->pulXlate;
                }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }
                #endif

        // A translation table is required.
        // "Well, DUH!" you might say, but I've seen it missing before...
        if (!pulXlate)
        {
            DISPDBG((0, "\n\nHost32ToDevice: !!! WARNING !!! 8BPP source "
            "bitmap does not have a translation table.  Punting!\n\n"));
            return FALSE;
        }

#if COLOR_TRANSLATE
        //
        // NVH:  5465 Color XLATE bug!!!
        // Color translation is broken on the 5465 in 16, 24 and 32 bpp.
        //
        if (UseHWxlate)
        {
            DWORD phase = ( ((DWORD)(pBits + ptlSrc.x)) & 3);
            if (XLATE_IS_BROKEN(sizl.cx, 4, phase))
                UseHWxlate = FALSE; // force SW translation.
        }

        if (UseHWxlate)
        {
            // Use Hardware color translation.

             DISPDBG((COPYBITS_DBG_LEVEL, "Host32ToDevice: "
            "Attempting HW color translation on 8bpp Host to 32bpp Screen.\n"));

                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we also set the source phase.
                pBits += ptlSrc.x;               // Start of source data on the host.
            lLeadIn = (DWORD)pBits & 3;      // Source phase.
                pBits -= lLeadIn;                // Backup to DWORD boundry.
                n = (sizl.cx + lLeadIn + 3) >> 2;// Number of HOSTDATA per scanline.

                // Start the blit.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
                LL_OP1_MONO(lLeadIn, 0);
                    LL_OP0(ptlDest.x, ptlDest.y);
            LL_BLTEXT_XLATE(8, sizl.cx, sizl.cy); // HW xlate.

                        while (sizl.cy--)
                        {
                                // Copy all data in 32-bit. We don't have to worry about
                                // crossing any boundaries, since within NT everything is DWORD
                                // aligned.
                                WRITE_STRING(pBits, n);
                                pBits += lDelta;
                        }

        }
        else
#endif
        {
            //
            // Use SW color translation.
            //
            DISPDBG((COPYBITS_DBG_LEVEL, "Host32ToDevice: "
            "Attempting SW color translation on 8bpp Host to 32bpp Screen.\n"));

            // To do 8bpp host to 32bpp screen we must have a translation table.
            ASSERTMSG(pulXlate,
                "Host32ToDevice: No translation table for color translation.\n");

                // Calculate the source parameters.
                pBits += ptlSrc.x;   // Start of source data on the host.

            #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
            {
                if (MAKE_HD_INDEX(sizl.cx * 4, 0, ptlDest.x * 4) == 3788)
                {
                    // We have a problem with the HOSTDATA TABLE.
                    // Punt till we can figure it out.
                    return FALSE;
                }
                        lExtra = ExtraDwordTable[MAKE_HD_INDEX(sizl.cx * 4, 0, ptlDest.x * 4)];
            }
            else
            {
                lExtra = 0;
                        }
            #endif

                // Setup the Laguna registers.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);

                // Start the blit.
                LL_OP1_MONO(0, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                while (sizl.cy--)
                {
                        BYTE *p = pBits;

                        // Copy the pixels.
                        for (i = sizl.cx; i > 0; i--)
                        {
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], pulXlate[*p]);
                                p++;
                        }

                #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }
                #endif

                        // Next line.
                        pBits += lDelta;
                }
        }
        }

        /*      -----------------------------------------------------------------------
                Source is in same color depth as screen.
        */
        else
        {
        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // If we have a translation table, punt it.
                if ( pulXlate || (flXlate & 0x10) )
                {
                        return(FALSE);
                }

                // Calculate the source parameters.
                pBits += ptlSrc.x * 4;

        #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
        {
            if (MAKE_HD_INDEX(sizl.cx * 4, 0, ptlDest.x * 4) == 3788)
            {
                // We have a problem with the HOSTDATA TABLE.
                // Punt till we can figure it out.
                return FALSE;
            }
                lExtra = ExtraDwordTable[MAKE_HD_INDEX(sizl.cx * 4, 0, ptlDest.x * 4)];
        }
        else
            lExtra = 0;
        #endif

                // Setup the Laguna registers.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);

                // Start the blit.
                LL_OP1_MONO(0, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                while (sizl.cy--)
                {
                        WRITE_STRING(pBits, sizl.cx);

            #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }
            #endif

                        // Next line.
                        pBits += lDelta;
                }
   }
   return(TRUE);
}

/*****************************************************************************\
 * DoDeviceToHost32
 *
 * This routine performs a DeviceToHost for either monochrome or 32-bpp
 * destinations.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags.
\*****************************************************************************/
BOOL DoDeviceToHost32(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF
)
{
        POINTL ptlSrc;
        PPDEV  ppdev;
        SIZEL  sizl;
        PBYTE  pBits;
        #if !S2H_USE_ENGINE
        PBYTE  pjScreen;
        #endif
        LONG   lDelta;
        ULONG  i, n;

        // Determine the source type and calculate the offset.
        if (psoSrc->iType == STYPE_DEVBITMAP)
        {
                PDSURF pdsurf = (PDSURF)psoSrc->dhsurf;
                ppdev = pdsurf->ppdev;
                ptlSrc.x = pptlSrc->x + pdsurf->ptl.x;
                ptlSrc.y = pptlSrc->y + pdsurf->ptl.y;
        }
        else
        {
                ppdev = (PPDEV)psoSrc->dhpdev;
                ptlSrc.x = pptlSrc->x;
                ptlSrc.y = pptlSrc->y;
        }

        // Calculate the size of the blit.
        sizl.cx = prclTrg->right - prclTrg->left;
        sizl.cy = prclTrg->bottom - prclTrg->top;

        // Calculate the destination variables.
        lDelta = psoTrg->lDelta;
        pBits = (PBYTE)psoTrg->pvScan0 + (prclTrg->top * lDelta);

        #if S2H_USE_ENGINE
        // Setup the Laguna registers.
        REQUIRE(9);
        LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x20100000, 0);
        LL_OP0(0, 0);
        #else
        // Calculate the screen address.
        pjScreen = ppdev->pjScreen + ptlSrc.x * 4 + ptlSrc.y * ppdev->lDeltaScreen;

        // Wait for the hardware to become idle.
        while (LLDR_SZ(grSTATUS) != 0) ;
        #endif

        // Test for a monochrome destination.
        if (psoTrg->iBitmapFormat == BMF_1BPP)
        {
                BYTE  data, leftMask, rightMask;
                ULONG fgColor;
                DWORD *pulXlate;
                LONG  leftCount, rightCount, leftSkip;

                // Calculate the monochrome masks.
                pBits += prclTrg->left >> 3;
                leftSkip = prclTrg->left & 7;
                leftCount = (8 - leftSkip) & 7;
                leftMask = 0xFF >> leftSkip;
                rightCount = prclTrg->right & 7;
                rightMask = 0xFF << (8 - rightCount);

                // If we only have pixels in one byte, we combine rightMask with
                // leftMask and set the routine to skip everything but the rightMask.
                if (leftCount > sizl.cx)
                {
                        rightMask &= leftMask;
                        leftMask = 0xFF;
                        n = 0;
                }
                else
                {
                        n = (sizl.cx - leftCount) >> 3;
                }

                // Get the foreground color from the translation table.
                pulXlate = XLATEOBJ_piVector(pxlo);
                fgColor = pulXlate ? *pulXlate : 0;

                #if S2H_USE_ENGINE
                // Start the blit.
                LL_OP1(ptlSrc.x - leftSkip, ptlSrc.y);
                LL_BLTEXT(sizl.cx + leftSkip, sizl.cy);
                #else
                pjScreen -= leftSkip * 4;
                #endif

                while (sizl.cy--)
                {
                        PBYTE pDest = pBits;
                        #if !S2H_USE_ENGINE
                        DWORD *pSrc = (DWORD *)pjScreen;
                        #endif

                        // If we have a left mask specified, we get the pixels and store
                        // them in the destination.
                        if (leftMask != 0xFF)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x80;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x40;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x20;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x10;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x08;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x04;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x02;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x01;
                                #else
                                if (pSrc[0] == fgColor) data |= 0x80;
                                if (pSrc[1] == fgColor) data |= 0x40;
                                if (pSrc[2] == fgColor) data |= 0x20;
                                if (pSrc[3] == fgColor) data |= 0x10;
                                if (pSrc[4] == fgColor) data |= 0x08;
                                if (pSrc[5] == fgColor) data |= 0x04;
                                if (pSrc[6] == fgColor) data |= 0x02;
                                if (pSrc[7] == fgColor) data |= 0x01;
                                pSrc += 8;
                                #endif
                                *pDest++ = (*pDest & ~leftMask) | (data & leftMask);
                        }

                        // Translate all pixels that don't require masking.
                        for (i = 0; i < n; i++)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x80;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x40;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x20;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x10;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x08;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x04;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x02;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x01;
                                #else
                                if (pSrc[0] == fgColor) data |= 0x80;
                                if (pSrc[1] == fgColor) data |= 0x40;
                                if (pSrc[2] == fgColor) data |= 0x20;
                                if (pSrc[3] == fgColor) data |= 0x10;
                                if (pSrc[4] == fgColor) data |= 0x08;
                                if (pSrc[5] == fgColor) data |= 0x04;
                                if (pSrc[6] == fgColor) data |= 0x02;
                                if (pSrc[7] == fgColor) data |= 0x01;
                                pSrc += 8;
                                #endif
                                *pDest++ = data;
                        }

                        // If we have a right mask specified, we get the pixels and store
                        // them in the destination.
                        if (rightMask != 0x00)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x80;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x40;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x20;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x10;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x08;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x04;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x02;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x01;
                                #else
                                if (pSrc[0] == fgColor) data |= 0x80;
                                if (pSrc[1] == fgColor) data |= 0x40;
                                if (pSrc[2] == fgColor) data |= 0x20;
                                if (pSrc[3] == fgColor) data |= 0x10;
                                if (pSrc[4] == fgColor) data |= 0x08;
                                if (pSrc[5] == fgColor) data |= 0x04;
                                if (pSrc[6] == fgColor) data |= 0x02;
                                if (pSrc[7] == fgColor) data |= 0x01;
                                #endif
                                *pDest = (*pDest & ~rightMask) | (data & rightMask);
                        }

                        // Next line.
                        #if !S2H_USE_ENGINE
                        pjScreen += ppdev->lDeltaScreen;
                        #endif
                        pBits += lDelta;
                }
        }

        // We only support destination bitmaps with the same color depth and we
        // do not support any color translation.
        else if ( (psoTrg->iBitmapFormat != BMF_32BPP) ||
                          (pxlo && !(pxlo->flXlate & XO_TRIVIAL)) )
        {
                return(FALSE);
        }

        /*
                If the GetPixel routine is being called, we get here with both cx and
                cy set to 1 and the ROP to 0xCC (source copy). In this special case we
                read the pixel directly from memory. Of course, we must be sure the
                blit engine is finished working since it may still update the very
                pixel we are going to read! We could use the hardware for this, but it
                seems there is a HARDWARE BUG that doesn't seem to like the 1-pixel
                ScreenToHost very much.
        */
        #if S2H_USE_ENGINE
        else if ( (sizl.cx == 1) && (sizl.cy == 1) && (ulDRAWBLTDEF == 0x000000CC) )
        {
                // Wait for the hardware to become idle.
                while (LLDR_SZ(grSTATUS) != 0) ;

                // Get the pixel from screen.
                *(DWORD *)pBits[prclTrg->left] = *(DWORD *)
                        &ppdev->pjScreen[ptlSrc.x * 4 + ptlSrc.y * ppdev->lDeltaScreen];
        }
        #endif

        else
        {
                #if S2H_USE_ENGINE
                // The hardware requires us to get QWORDS.
                BOOL fExtra = sizl.cx & 1;
                #endif
                pBits += prclTrg->left * 4;

                #if S2H_USE_ENGINE
                // Start the bit.
                LL_OP1(ptlSrc.x, ptlSrc.y);
                LL_BLTEXT(sizl.cx, sizl.cy);
                #endif

                while (sizl.cy--)
                {
                        #if S2H_USE_ENGINE
                        DWORD *p = (DWORD *)pBits;

                        // Copy all pixels from screen to memory.
                        for (i = sizl.cx; i >= 1; i -= 1)
                        {
                                *p++ = LLDR_SZ(grHOSTDATA[0]);
                        }

                        // Get the extra pixel required for QWORD alignment.
                        if (fExtra)
                        {
                                LLDR_SZ(grHOSTDATA[0]);
                        }
                        #else
                        // Copy all pixels from screen to memory.
                        memcpy(pBits, pjScreen, sizl.cx * 4);

                        // Next line.
                        pjScreen += ppdev->lDeltaScreen;
                        #endif
                        pBits += lDelta;
                }
        }
        return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\brush.c ===
/******************************Module*Header*******************************\
*
* Module Name: Brush.c
* Author: Noel VanHook
* Purpose: Handle calls to DrvRealizeBrush
*
* Copyright (c) 1995 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/BRUSH.C  $
*
*    Rev 1.29   Mar 04 1998 15:11:18   frido
* Added new shadow macros.
*
*    Rev 1.28   Feb 24 1998 13:19:16   frido
* Removed a few warning messages for NT 5.0.
*
*    Rev 1.27   Nov 03 1997 12:51:52   frido
* Added REQUIRE macros.
*
*    Rev 1.26   25 Aug 1997 16:01:22   FRIDO
* Removed resetting of brush unique ID counters in vInvalidateBrushCache.
*
*    Rev 1.25   08 Aug 1997 15:33:16   FRIDO
* Changed brush cache width to bytes for new memory manager.
*
*    Rev 1.24   06 Aug 1997 17:29:56   noelv
* Don't RIP on brush cache alloc failure.  This failure is normal for modes
* without enough offscreen memory for a cache.
*
*    Rev 1.23   09 Apr 1997 10:48:52   SueS
* Changed sw_test_flag to pointer_switch.
*
*    Rev 1.22   08 Apr 1997 12:12:32   einkauf
*
* add SYNC_W_3D to coordinate MCD/2D HW access
*
*    Rev 1.21   19 Feb 1997 13:06:20   noelv
* Added vInvalidateBrushCache()
*
*    Rev 1.20   17 Dec 1996 16:51:00   SueS
* Added test for writing to log file based on cursor at (0,0).
*
*    Rev 1.19   26 Nov 1996 10:18:22   SueS
* Changed WriteLogFile parameters for buffering.  Added test for null
* pointer in logging function.
*
*    Rev 1.18   13 Nov 1996 15:57:54   SueS
* Changed WriteFile calls to WriteLogFile.
*
*    Rev 1.17   22 Aug 1996 18:14:18   noelv
* Frido bug fix release 8-22.
*
*    Rev 1.6   22 Aug 1996 19:12:44   frido
* #1308 - Added extra checks for empty cache slots.
*
*    Rev 1.5   18 Aug 1996 15:19:58   frido
* #nbr - Added brush translation.
*
*    Rev 1.4   17 Aug 1996 14:03:10   frido
* Removed extraneous #include directives.
*
*    Rev 1.3   17 Aug 1996 13:12:12   frido
* New release from Bellevue.
* #1244 - Fixed brush rotation for off-screen bitmaps.
*
*    Rev 1.2   15 Aug 1996 12:26:40   frido
* Moved BRUSH_DBG_LEVEL down.
*
*    Rev 1.1   15 Aug 1996 11:45:14   frido
* Added precompiled header.
*
*    Rev 1.0   14 Aug 1996 17:16:16   frido
* Initial revision.
*
*    Rev 1.14   25 Jul 1996 15:55:24   bennyn
*
* Modified to support DirectDraw
*
*    Rev 1.13   04 Jun 1996 15:57:34   noelv
*
* Added debug code
*
*    Rev 1.12   28 May 1996 15:11:14   noelv
* Updated data logging.
*
*    Rev 1.11   16 May 1996 14:54:20   noelv
* Added logging code.
*
*    Rev 1.10   11 Apr 1996 09:25:16   noelv
* Fided debug messages.
*
*    Rev 1.9   10 Apr 1996 14:14:04   NOELV
*
* Frido release 27
*
*    Rev 1.19   08 Apr 1996 16:45:56   frido
* Added SolidBrush cache.
* Added new check for 32-bpp brushes.
*
*    Rev 1.18   01 Apr 1996 14:00:08   frido
* Added check for valid brush cache.
* Changed layout of brush cache.
*
*    Rev 1.17   30 Mar 1996 22:16:02   frido
* Refined checking for invalid translation flags.
*
*    Rev 1.16   27 Mar 1996 13:07:38   frido
* Added check for undocumented translation flags.
*
*    Rev 1.15   25 Mar 1996 12:03:06   frido
* Changed #ifdef LOG_CALLS into #if LOG_CALLS.
*
*    Rev 1.14   25 Mar 1996 11:50:16   frido
* Bellevue 102B03.
*
*    Rev 1.5   20 Mar 1996 16:20:06   noelv
* 32 bpp color brushes are broken in the chip
*
*    Rev 1.4   20 Mar 1996 16:09:32   noelv
*
* Updated data logging
*
*    Rev 1.3   05 Mar 1996 11:57:38   noelv
* Frido version 19
*
*    Rev 1.13   05 Mar 1996 00:56:30   frido
* Some changes here and there.
*
*    Rev 1.12   04 Mar 1996 23:48:50   frido
* Removed bug in realization of dithered brush.
*
*    Rev 1.11   04 Mar 1996 20:22:30   frido
* Removed bug in BLTDEF register with colored brushes.
*
*    Rev 1.10   28 Feb 1996 22:37:42   frido
* Added Optimize.h.
*
*    Rev 1.9   17 Feb 1996 21:45:28   frido
* Revamped brushing algorithmn.
*
*    Rev 1.8   13 Feb 1996 16:51:18   frido
* Changed the layout of the PDEV structure.
* Changed the layout of all brush caches.
* Changed the number of brush caches.
*
*    Rev 1.7   10 Feb 1996 21:44:32   frido
* Split monochrome and colored translation cache.
*
*    Rev 1.6   08 Feb 1996 00:19:24   frido
* Optimized the entire brushing for non-intel CPU's.
* Removed DrvRealizeBrush for i386 since it is now in assembly.
*
*    Rev 1.5   05 Feb 1996 17:35:32   frido
* Added translation cache.
*
*    Rev 1.4   05 Feb 1996 11:34:02   frido
* Added support for 4-bpp brushes.
*
*    Rev 1.3   03 Feb 1996 14:20:04   frido
* Use the compile switch "-Dfrido=0" to disable my extensions.
*
*    Rev 1.2   20 Jan 1996 22:13:14   frido
* Added dither cache.
* Optimized loading of brush cache bits.
*
\**************************************************************************/

/*

We have two versions of DrvRealizeBrush, a 'C' version and an 'ASM' version.
These must be both be kept up to date.  The ASM version is used for production
drivers. The C version is used for debugging, prototyping, data gathering and
anything else that requires rapid, non-performance-critical changes to the
driver.

Brushes:
=========
Here is a general feel for how brush information flows between NT and the
driver components.

    NT calls DrvBitBlt() with a drawing request.
    DrvBitBlt() determines it needs a brush and calls SetBrush().
    SetBrush() determins the brush has not been realized yet and calls NT
        (BRUSHOBJ_pvGetRbrush()).
    NT calls DrvRealizeBrush().
    DrvRealizeBrush() creates a BrushObject and returns it to NT.
    NT returns brush object to SetBrush().
    SetBrush calls CacheBrush() if the brush is not cached.
    SetBrush() sets up pattern on chip.
    SetBrush() returns DRAWDEF value to BitBlt.


There are 5 seperate brush caches maintained:  A mono cache, a color cache, a
dither cache, a 4bpp cache, and a solid cache.  We do not handle brushes with
masks.  Some of the code for this is in place, but work was stopped on it.

Realizing Brushes:
==================

When we realize a brush we keep a bit of information about it.

  ajPattern[0]   = The bitmap that makes up the pattern.
  nPatSize       = The size of the bitmap.
  iBitmapFormat  = BMF_1BPP, BMF_4BPP, etc.
  ulForeColor    = For mono brushes.
  ulBackColor    = For mono brushes.
  iType          = Type of brush.
  iUniq          = Unique value for brush.
  cache_slot     = Where we cached it last time we used it. It may still be
                   there, or it may have been ejected from the cache since we
                   used it last.
  cache_xy       = The off-screen location of the brush bits.
  cjMask         = Offset to mask bits in ajPattern[].


The memory for the brush data structure is managed by the operating system.
When we realize a brush, we tell NT how much memory we need to hold our brush
data, and NT gives us a pointer.  When NT discards the brush, it frees the
memory it gave us *without* notifing us first!  This means we can't keep lists
of pointers to realized brushes and access them at our leisure, because they
may not exist anymore.  This is a pain when caching brushes.  It would be nice
if we could track cached/not-cached states in the brush itself, but we have no
way of notifing a brush that it has been uncached, because NT way have already
unrealized the brush.

The solution to this is to keep brush ID information in the cache.  The realized
brush tracks where it is in the cache.  The cache tracks which realized brush is
in each slot.



Caching brushes:
================

        We allocate 3 128-byte wide rectangles, side by side. The
        layout of this brush cache region is:

        +----------------+----------------+----------------+
        |                |                |   MONOCHROME   |
        |     COLOR      |      4BPP      +----------------+
        |    BRUSHES     |    BRUSHES     |     DITHER     |
        |                |                |    BRUSHES     |
        |                |                +----------------+
        |                |                | SOLID BRUSHES  |
        +----------------+----------------+----------------+

Mono brushes use 1 bit per pixel (1 byte per scan line, 8 bytes per brush) and
are stored 16 to a line.  Replacement policy is round robin.  We work out way
through the cache table entries, and when the cache is full, we go back to 0 and
start again.

The pdev holds a counter that increments every time we cache a brush. We MOD
this counter with the number of table entries to find the next place to put a
brush.  When we store the brush, we store a unswizzled copy in the cache table
itself, and a swizzled copy in the cache.  After storing the brush, we give it a
'serial number' which is stored in both the cache, and the realized brush.  We
then copy the brushes X,Y address into the realized brush for easy access.  So,
for index I in the cache, things look like this:

Realized Brush
--------------
cache_slot  = I  - tells us which cache table entry to use;
cache_xy         - x,y address of brush in offscreen memory.  Copied from cache
                   table.
iUniq            - matches iUniq in CacheTable[I]

Cache Table [I]
---------------
xy        - x,y address of brush in offscreen memory.  Computed at init time.
ajPattern - brush bits.
iUniq     - matches iUniq in RealizedBrush


Now, in the future, if we are given this brush again, we first check cache_slot
in the realized brush to see where we cached it last time we used it.  Then we
compare iUniq values to see if our brush is *still* cached there.



Dither brushes use 1 byte per pixel (8 bytes per scan line, 64 bytes per brush)
        and are stored 2 to a line.

4bpp brushes use 1 DWORD per pixel (32 bytes per scan line, 256 bytes per brush)
        and use two lines per brush.

Solid brushes use 1 DWORD per pixel (32 bytes  scan line, 256 bytes per brush)
        and use two lines per brush.

Color brushes:
        8 bpp     - 1 byte per pixel, two brushes per scan line.
        16 bpp    - 2 bytes per pixel, 1 brush per scan line.
        24,32 bpp - 4 bytes per pixel, two scan lines per brush.

Brushes are put in the cache using direct frame buffer access.  To make using
cached brushes fast, we maintain a seperate cache table for each cache.  Each
entry in the cache table tracks the (x,y) address of the brush in a format
directly usable by the chip, and the linear address of the brush for storing the
brush quickly.



Initialization:
-----------------
Brush cache initialization is done during surface initialization.
        DrvEnableSurface() => binitSurf() => vInitBrushCache().




*/

#include "precomp.h"
#include "SWAT.h"
#define BRUSH_DBG_LEVEL 1

void vRealizeBrushBits(
        PPDEV     ppdev,
        SURFOBJ  *psoPattern,
        PBYTE     pbDest,
        PULONG    pulXlate,
        PRBRUSH   pRbrush);

BOOL CacheMono(PPDEV ppdev, PRBRUSH pRbrush);
BOOL Cache4BPP(PPDEV ppdev, PRBRUSH pRbrush);
BOOL CacheDither(PPDEV ppdev, PRBRUSH pRbrush);
BOOL CacheBrush(PPDEV ppdev, PRBRUSH pRbrush);

//
// These are test/debugging/information-gathering functions that
// get compiled out under a free build.
//

#if LOG_CALLS
void LogRealizeBrush(
        ULONG     acc,
        PPDEV     ppdev,
        SURFOBJ  *psoPattern,
        SURFOBJ  *psoMask,
        XLATEOBJ *pxlo
    );
#else
    #define LogRealizeBrush(acc, ppdev, psoPattern, psoMask, pxlo)
#endif

//
// These aren't part of the driver.  They are debugging support functions
// that can be inserted where needed.
//

// This dumps useful information about brushes that NT gives us.
void PrintBrush(SURFOBJ  *psoPattern);

// This dumps useful information about brushes we have realized.
void PrintRealizedBrush(PRBRUSH pRbrush);

//
// Mono brushes must be swizzled before they are stored away.
// We do this with this look up table.
//
BYTE Swiz[] = {
0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,
0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,
0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4,
0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC,
0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2,
0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA,
0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6,
0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE,
0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1,
0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,
0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5,
0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED,
0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3,
0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB,
0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7,
0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF,
0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
};






/**************************************************************************\
*                                                                          *
* DrvRealizeBrush                                                          *
*                                                                          *
\**************************************************************************/

//#nbr (begin)
#if USE_ASM && defined(i386)
BOOL i386RealizeBrush(
#else
BOOL DrvRealizeBrush(
#endif
//#nbr (end)
        BRUSHOBJ *pbo,
        SURFOBJ  *psoTarget,
        SURFOBJ  *psoPattern,
        SURFOBJ  *psoMask,
        XLATEOBJ *pxlo,
        ULONG    iHatch)
{
        PPDEV   ppdev;
        INT     cjPattern, // size of the brush pattern (in bytes).
            cjMask;    // size of the brush mask (in bytes).
        PRBRUSH pRbrush;   // Our brush structure.
        PULONG  pulXlate;  // Color translation table.
        FLONG   flXlate;   // Translation flags.
#if 1 //#nbr
        LONG    lDelta;
#endif

        DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: Entry.\n"));

        //
        // Reality check.
        //
        ASSERTMSG(psoTarget != 0,  "DrvRealizeBrush: No target.\n");

        //
        // Is the screen the target?
        //
        ppdev = (PPDEV) (psoTarget ? psoTarget->dhpdev : 0);

        if (!ppdev)
        {
                DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: punted (no pdev).\n"));
                LogRealizeBrush(1, ppdev, psoPattern, psoMask, pxlo);
                return FALSE;
        }

    SYNC_W_3D(ppdev);

    //
    // If we don't have a brush cache (maybe we're low on offscreen memory?)
    // then we can't do brushes.
    //
        if (ppdev->Bcache == NULL)
        {
                LogRealizeBrush(6, ppdev, psoPattern, psoMask, pxlo);
                return(FALSE);
        }

        if (iHatch & RB_DITHERCOLOR)
        {
                ULONG rgb = iHatch & 0x00FFFFFF;
                int       i;

                // Allocate the memory.
                pRbrush = (PRBRUSH) BRUSHOBJ_pvAllocRbrush(pbo, sizeof(RBRUSH));
                if (pRbrush == NULL)
                {
                        LogRealizeBrush(6, ppdev, psoPattern, psoMask, pxlo);
                        return(FALSE);
                }

                // Init the brush structure.
                pRbrush->nPatSize = 0;
                pRbrush->iBitmapFormat = BMF_8BPP;
                pRbrush->cjMask = 0;
                pRbrush->iType = BRUSH_DITHER;
                pRbrush->iUniq = rgb;

                // Lookup the dither in the dither cache.
                for (i = 0; i < NUM_DITHER_BRUSHES; i++)
                {
                        if (ppdev->Dtable[i].ulColor == rgb)
                        {
                                pRbrush->cache_slot = i * sizeof(ppdev->Dtable[i]);
                                pRbrush->cache_xy = ppdev->Dtable[i].xy;
                                LogRealizeBrush(0, ppdev, psoPattern, psoMask, pxlo);
                                return(TRUE);
                        }
                }

                // Create the dither and cache it.
                LogRealizeBrush(99, ppdev, psoPattern, psoMask, pxlo);
                return(CacheDither(ppdev, pRbrush));
        }

        ASSERTMSG(psoPattern != 0, "DrvRealizeBrush: No pattern.\n");

        // Is it an 8x8 brush?
        if ((psoPattern->sizlBitmap.cx != 8) || (psoPattern->sizlBitmap.cy != 8))
        {
                DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: punted (not 8x8).\n"));
                LogRealizeBrush(3, ppdev, psoPattern, psoMask, pxlo);
                return FALSE;
        }

        // Does it have a mask?
        // Some of the mask code is in place, but not all of it.
        if ((psoMask != NULL) && (psoMask->pvScan0 != psoPattern->pvScan0))
        {
                DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: punted (has a mask).\n"));
                LogRealizeBrush(4, ppdev, psoPattern, psoMask, pxlo);
                return FALSE;
        }

        // Is it a standard format brush?
        if (psoPattern->iType != STYPE_BITMAP)
        {
                DISPDBG((BRUSH_DBG_LEVEL,
                                 "DrvRealizeBrush: punted (not standard bitmap).\n"));
                LogRealizeBrush(2, ppdev, psoPattern, psoMask, pxlo);
                return FALSE;
        }

        //
        // Get the color translation.
        //
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
                pulXlate = XLATEOBJ_piVector(pxlo);
        }
    else
    {
        // Some kind of translation we don't handle.
        return FALSE;
    }


        // The hardware does not support colored bitmaps in 32-bpp.
        if ( (psoPattern->iBitmapFormat > BMF_1BPP) &&
                 (ppdev->iBitmapFormat == BMF_32BPP) )
        {
                LogRealizeBrush(5, ppdev, psoPattern, psoMask, pxlo);
                return(FALSE);
        }

        if (psoPattern->iBitmapFormat == BMF_4BPP)
        {
                int i;

                // Check if we support this bitmap.
                if ( (psoPattern->cjBits != XLATE_PATSIZE) ||
                         (pxlo->cEntries != XLATE_COLORS) )
                {
                        // We don't support other bitmaps than 8x8 and 16 translation
                        // entries.
                        LogRealizeBrush(10, ppdev, psoPattern, psoMask, pxlo);
                        return(FALSE);
                }

                // Allocate the brush.
                pRbrush = BRUSHOBJ_pvAllocRbrush(pbo, sizeof(RBRUSH) + XLATE_PATSIZE +
                                                                                 XLATE_COLORS * sizeof(ULONG));
                if (pRbrush == NULL)
                {
                LogRealizeBrush(6, ppdev, psoPattern, psoMask, pxlo);
                        return(FALSE);
                }

                //
                // Init the brush structure.
                //
                pRbrush->nPatSize       = XLATE_PATSIZE + XLATE_COLORS * sizeof(ULONG);
                pRbrush->iBitmapFormat  = BMF_4BPP;
                pRbrush->cjMask         = 0;
                pRbrush->iType          = BRUSH_4BPP;

                // Copy the 4-bpp pattern and translation palette to the brush.
                if (psoPattern->lDelta == 4)
                {
                        memcpy(pRbrush->ajPattern, psoPattern->pvBits, XLATE_PATSIZE);
                }
                else
                {
                        BYTE *pSrc = psoPattern->pvScan0;
                        for (i = 0; i < 8; i++)
                        {
                                ((DWORD *) pRbrush->ajPattern)[i] = *(DWORD *) pSrc;
                                pSrc += psoPattern->lDelta;
                        }
                }
                memcpy(pRbrush->ajPattern + XLATE_PATSIZE, pulXlate,
                           XLATE_COLORS * sizeof(ULONG));

                // Lookup the pattern and palette in the translation cache.
                for (i = 0; i < NUM_4BPP_BRUSHES; i++)
                {
                        if ((memcmp(ppdev->Xtable[i].ajPattern, pRbrush->ajPattern,
                                            XLATE_PATSIZE + XLATE_COLORS * sizeof(ULONG)) == 0)
#if 1 //#1308
                                && (ppdev->Xtable[i].iUniq != 0)
#endif
                        )
                        {
                                // We have a match!
                                pRbrush->iUniq = ppdev->Xtable[i].iUniq;
                                pRbrush->cache_slot = i * sizeof(ppdev->Xtable[i]);
                                pRbrush->cache_xy = ppdev->Xtable[i].xy;
                        LogRealizeBrush(0, ppdev, psoPattern, psoMask, pxlo);
                                return(TRUE);
                        }
                }

                // Cache the brush now.
            LogRealizeBrush(6, ppdev, psoPattern, psoMask, pxlo);
                return(Cache4BPP(ppdev, pRbrush));
        }

        if (psoPattern->iBitmapFormat == BMF_1BPP)
        {
                int       i;
                PBYTE pSrc;

                // Check if we support this bitmap.
                if (pulXlate == 0)
                {
                    LogRealizeBrush(11, ppdev, psoPattern, psoMask, pxlo);
                        return(FALSE);
                }

                // Allocate the brush.
                pRbrush = BRUSHOBJ_pvAllocRbrush(pbo, sizeof(RBRUSH) + 8);
                if (pRbrush == NULL)
                {
                    LogRealizeBrush(6, ppdev, psoPattern, psoMask, pxlo);
                        return(FALSE);
                }

                //
                // Init the brush structure.
                //
                pRbrush->nPatSize = 8;
                pRbrush->iBitmapFormat = BMF_1BPP;
                pRbrush->cjMask = 0;
                pRbrush->iType = BRUSH_MONO;

                // Copy the 4-bpp pattern and translation palette to the brush.
                pRbrush->ulBackColor = ExpandColor(pulXlate[0], ppdev->ulBitCount);
                pRbrush->ulForeColor = ExpandColor(pulXlate[1], ppdev->ulBitCount);
                pSrc = (PBYTE) psoPattern->pvScan0;
                for (i = 0; i < 8; i++)
                {
                        pRbrush->ajPattern[i] = *pSrc;
                        pSrc += psoPattern->lDelta;
                }

                // Lookup the pattern and palette in the translation cache.
                for (i = 0; i < NUM_MONO_BRUSHES; i++)
                {
                        if ((*(DWORD *) &ppdev->Mtable[i].ajPattern[0] ==
                                 *(DWORD *) &pRbrush->ajPattern[0]) &&
#if 1 //#1308
                                (ppdev->Mtable[i].iUniq != 0) &&
#endif
                                (*(DWORD *) &ppdev->Mtable[i].ajPattern[4] ==
                                 *(DWORD *) &pRbrush->ajPattern[4]) )
                        {
                                // We have a match!
                                pRbrush->iUniq = ppdev->Mtable[i].iUniq;
                                pRbrush->cache_slot = i * sizeof(ppdev->Mtable[i]);
                                pRbrush->cache_xy = ppdev->Mtable[i].xy;
                            LogRealizeBrush(0, ppdev, psoPattern, psoMask, pxlo);
                                return(TRUE);
                        }
                }

                // Cache the brush now.
            LogRealizeBrush(0, ppdev, psoPattern, psoMask, pxlo);
                return(CacheMono(ppdev, pRbrush));
        }

#if 1 //#nbr
        // How much memory do we need for the pattern?
        lDelta = (ppdev->iBytesPerPixel * 8);
        if (ppdev->iBytesPerPixel == 3)
        {
                lDelta += 8;
        }
        cjPattern = lDelta * 8;

        // Allocate the memory.
        pRbrush = BRUSHOBJ_pvAllocRbrush(pbo, sizeof(RBRUSH) + cjPattern);
        if (pRbrush == NULL)
        {
                DISPDBG((BRUSH_DBG_LEVEL,
                                 "DrvRealizeBrush: punted (Mem alloc failed).\n"));
                LogRealizeBrush(6, ppdev, psoPattern, psoMask, pxlo);
                return(FALSE);
        }

        // Initialize the brush fields.
        pRbrush->nPatSize          = cjPattern;
        pRbrush->iBitmapFormat = ppdev->iBitmapFormat;
        pRbrush->cjMask            = 0;
        pRbrush->iType             = BRUSH_COLOR;

        // Can we realize the bits directly?
        if ((psoPattern->iBitmapFormat == ppdev->iBitmapFormat) &&
                (flXlate & XO_TRIVIAL))
        {
                // Realize the brush bits.
                vRealizeBrushBits(ppdev, psoPattern, &pRbrush->ajPattern[0], pulXlate,
                                                  pRbrush);
        }
        else
        {
                HBITMAP  hBrush;
                SURFOBJ* psoBrush;
                RECTL    rclDst = {     0, 0, 8, 8 };
                BOOL     bRealized = FALSE;

                DISPDBG((BRUSH_DBG_LEVEL, "DrvRealizeBrush: Translating brush.\n"));

                // Create a bitmap wrapper for the brush bits.
                hBrush = EngCreateBitmap(psoPattern->sizlBitmap, lDelta,
                                                                 ppdev->iBitmapFormat, BMF_TOPDOWN,
                                                                 pRbrush->ajPattern);
                if (hBrush != 0)
                {
                        // Associate the bitmap wrapper with the device.
                        if (EngAssociateSurface((HSURF) hBrush, ppdev->hdevEng, 0))
                        {
                                // Lock the bitmap wrapper.
                                psoBrush = EngLockSurface((HSURF) hBrush);
                                if (psoBrush != NULL)
                                {
                                        // Copy the pattern bits to the bitmap wrapper.
                                        if (EngCopyBits(psoBrush, psoPattern, NULL, pxlo, &rclDst,
                                                                         (POINTL*) &rclDst))
                                        {
                                                // In 24-bpp, the brush bits have a different layout.
                                                if (ppdev->iBytesPerPixel == 3)
                                                {
                                                        INT    y;
                                                        ULONG* pulDst = (ULONG*) pRbrush->ajPattern;

                                                        // Walk through every line.
                                                        for (y = 0; y < 8; y++)
                                                        {
                                                                // Copy bytes 0-7 to bytes 25-31.
                                                                pulDst[6] = pulDst[0];
                                                                pulDst[7] = pulDst[1];
                                                                // Next line.
                                                                pulDst   += 8;
                                                        }
                                                }
                                                // Mark the brush as realized.
                                                bRealized = TRUE;
                                        }
                                        else
                                        {
                                                DISPDBG((BRUSH_DBG_LEVEL, "  EngCopyBits failed.\n"));
                                        }
                                        // Unlock the bitmap wrapper.
                                        EngUnlockSurface(psoBrush);
                                }
                                else
                                {
                                        DISPDBG((BRUSH_DBG_LEVEL, "  EngLockSurface failed.\n"));
                                }
                        }
                        else
                        {
                                DISPDBG((BRUSH_DBG_LEVEL, "  EngAssociateSurface failed.\n"));
                        }
                        // Delete the bitmap wrapper.
                        EngDeleteSurface((HSURF) hBrush);
                }
                else
                {
                        DISPDBG((BRUSH_DBG_LEVEL, "(EngCreateBitmap failed)\n"));
                }

                if (!bRealized)
                {
                        // The brush was not realized.
                        return(FALSE);
                }
        }
#else
        if (flXlate & 0x10)
        {
                // Punt to GDI.
                LogRealizeBrush(9, ppdev, psoPattern, psoMask, pxlo);
                return(FALSE);
        }

        // Is it a supported color depth?
        if (psoPattern->iBitmapFormat != ppdev->iBitmapFormat)
        {
                DISPDBG((BRUSH_DBG_LEVEL,
                                "DrvRealizeBrush: punted (unsupported color depth).\n"));
                LogRealizeBrush(5, ppdev, psoPattern, psoMask, pxlo);
                return FALSE;
        }

        //
        // We don't handle color xlates yet.
        // If there is an xlate table, punt it.
        //
        if ( pulXlate )
        {
                DISPDBG((BRUSH_DBG_LEVEL,
                         "DrvRealizeBrush: punted (Xlate required).\n"));
                LogRealizeBrush(9, ppdev, psoPattern, psoMask, pxlo);
                return FALSE;
        }

        //
        // Alloc memory from GDI for brush storage.
        //

        // How much memory to we need for the pattern?
        cjPattern = psoPattern->cjBits;
        if (psoPattern->iBitmapFormat == BMF_24BPP)
                cjPattern += 64;

        // We need memory for the mask too.
        // Check for mask bits equal to pattern bits.
        // If psoMask is NULL, the mask is never used, so no memory is needed.

        if ((psoMask != NULL) && (psoMask->pvScan0 != psoPattern->pvScan0))
                cjMask = psoMask->cjBits;
        else
                cjMask = 0;

        // Allocate the memory.
        pRbrush =
           (PRBRUSH) BRUSHOBJ_pvAllocRbrush(pbo,sizeof(RBRUSH)+cjPattern+cjMask);
        if (!pRbrush)
        {
                DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: punted (Mem alloc failed).\n"));
                LogRealizeBrush(6, ppdev, psoPattern, psoMask, pxlo);
                return (FALSE);
        }

        //
        // Init the brush structure.
        //
        pRbrush->nPatSize          = cjPattern;
        pRbrush->iBitmapFormat = psoPattern->iBitmapFormat;
        pRbrush->cjMask            = (cjMask ? cjPattern : 0);
        pRbrush->iType             = BRUSH_COLOR;

        //
        // Realize the brush and mask.  Actually we punted masks a while ago.
        //
        vRealizeBrushBits(ppdev, psoPattern, &pRbrush->ajPattern[0], pulXlate,
                                          pRbrush);
#endif

        //
        // Cache the brush now.
        //
        CacheBrush(ppdev, pRbrush);

        //
        // Dump brush data to the profiling file.
        // Gets compiled out under a free build.
        //
        LogRealizeBrush(0, ppdev, psoPattern, psoMask, pxlo);
        DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: Done.\n"));

        return (TRUE);

}



/***********************************************************************\
*                                                                       *
* vRealizeBrushBits()                                                   *
*                                                                       *
* Copies the brush pattern from GDI to our realized brush.              *
* Called by DrvRealizeBrush()                                           *
*                                                                       *
\***********************************************************************/

void vRealizeBrushBits(
        PPDEV     ppdev,
        SURFOBJ  *psoPattern,
        PBYTE     pbDest,
        PULONG    pulXlate,
        PRBRUSH   pRbrush
)
{
        PBYTE     pbSrc;
        INT i,j;
        LONG lDelta;


        //
        // Find the top scan line in the brush, and it's scan line delta
        // This works for both top down and bottom up brushes.
        //
        pbSrc = psoPattern->pvScan0;
        lDelta = (psoPattern->lDelta);


        //
        // At this point all brushs are 8x8.
        // Currently we only support mono brushes, and brushes with the same
        // color depth as the screen.  Color translations aren't supported.
        //
        // Mono brushes must be swizzled as we copy them.  We do this using
        // a 256 byte lookup table.
        //
        // We store the brushes in host memory as a linear string of bytes.
        // Before we use the brush we will cache it off screen memory in a
        // format that the BLT engine can use.
        //

        switch (psoPattern->iBitmapFormat)
        {
                case BMF_8BPP:
                        //
                        // Store the pattern as 64 consecutive bytes.
                        //

                        if (lDelta == 8)
                        {
                                memcpy(pbDest, pbSrc, 8 * 8);
                        }
                        else
                        {
                                // For each row in the pattern.
                                for (j = 0; j < 8; j++)
                                {
                                        // Copy the row.
                                        *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[0];
                                        *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[4];

                                        // Move to next row.
                                        pbSrc += lDelta;
                                }
                        }
                        return;

                case BMF_16BPP:
                        //
                        // Store the pattern as 128 consecutive bytes.
                        //
                        if (lDelta == 16)
                        {
                                memcpy(pbDest, pbSrc, 16 * 8);
                        }
                        else
                        {
                                // For each row in the pattern.
                                for (j = 0; j < 8; j++)
                                {
                                        // Copy the row.
                                        *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[0];
                                        *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[4];
                                        *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[8];
                                        *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[12];

                                        // Move to next row.
                                        pbSrc += lDelta;
                                }
                        }
                        return;

                case BMF_24BPP:
                        //
                        // Store the pattern as 256 consecutive bytes.
                        //
                        //
                        // Each row in the pattern needs 24 bytes.  The pattern is stored
                        // with 32 bytes per row though, with the last 8 bytes being a
                        // copy of the first 8 bytes, like so:
                        //
                        // RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RG
                        // 1   2   3   4   5   6   7   8   1   2   3
                        // \___________________________/   \________/
                        //             |                       |
                        //     pattern scan line        copy of first 8
                        //                              bytes of scan line
                        //

                        // For each row in the pattern.
                        for (j = 0; j < 8; j++)
                        {
                                //
                                // Copy the row.
                                //
                                for (i = 0; i < 24; i += sizeof(ULONG))
                                        *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[i];

                                //
                                // Pad the last 8 bytes with a copy of the first 8 bytes.
                                //
                                *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[0];
                                *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[4];

                                // Move to next row.
                                pbSrc += lDelta;
                        }
                        return;

                case BMF_32BPP:
                        //
                        // Store the pattern as 256 consecutive bytes.
                        //

                        if (lDelta == 32)
                        {
                                memcpy(pbDest, pbSrc, 32 * 8);
                        }
                        else
                        {
                                // For each row in the pattern.
                                for (j = 0; j < 8; j++)
                                {
                                        // Copy the row.
                                        for (i = 0; i < 32; i += sizeof(ULONG))
                                                *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[i];

                                        // Move to next row.
                                        pbSrc += lDelta;
                                }
                        }
                        return;
        }
}

// ===========================================================================+
//                                                                           ||
// ExpandColor()                                                             ||
// Expands a color value to 32 bits by replication.                          ||
// Called by vRealizeBrushBits()                                             ||
//                                                                           ||
// ===========================================================================+

ULONG ExpandColor(ULONG iSolidColor, ULONG ulBitCount)
{
        ULONG color;

        //
        // If the color is an 8 or 16 bit color, it needs to be
        // extended (by replication) to fill a 32 bit register.
        //

        switch (ulBitCount)
        {
                case 8: // For 8 bpp duplicate byte 0 into bytes 1,2,3.
                        color = iSolidColor & 0x00000000FF; // Clear upper 24 bits.
                        return ((color << 24) | (color << 16) | (color << 8) | color);

                case 16: // For 16 bpp, duplicate the low word into the high word.
                        color = (iSolidColor) & 0x0000FFFF; // Clear upper 16 bits.
                        return ((color << 16) | color);

                case 24: // For 24 bpp clear the upper 8 bits.
                        return (iSolidColor & 0x00FFFFFF);

                default: // For 32 bpp just use the color supplied by NT.
                        return (iSolidColor); // Color of fill
        }

}

/**************************************************************************\
 *                                                                                                                                                *
 *      CacheMono()                                                                                                                       *
 *      Cache a realized monochrome brush.                                                                        *
 *                                                                                                                                                *
\**************************************************************************/
BOOL CacheMono(PPDEV ppdev, PRBRUSH pRbrush)
{
        int   i;
        ULONG tbl_idx = ppdev->MNext % NUM_MONO_BRUSHES;
        PBYTE pdest;

        // Copy the monochrome pattern to the cache and off-screen.
        pdest = ppdev->Mtable[tbl_idx].pjLinear;
        for (i = 0; i < 8; i++)
        {
                ppdev->Mtable[tbl_idx].ajPattern[i] = pRbrush->ajPattern[i];
                pdest[i] = Swiz[pRbrush->ajPattern[i]];
        }

        // Store the new uniq ID in the cache slot.
        pRbrush->iUniq = ppdev->Mtable[tbl_idx].iUniq = ++ppdev->MNext;
        pRbrush->cache_slot = tbl_idx * sizeof(ppdev->Mtable[tbl_idx]);
        pRbrush->cache_xy = ppdev->Mtable[tbl_idx].xy;
        return(TRUE);
}

/**************************************************************************\
 *                                                                                                                                                *
 *      Cache4BPP()                                                                                                                       *
 *      Cache a realized 4-bpp brush.                                                                             *
 *                                                                                                                                                *
\**************************************************************************/
BOOL Cache4BPP(PPDEV ppdev, PRBRUSH pRbrush)
{
        ULONG tbl_idx = ppdev->XNext % NUM_4BPP_BRUSHES;
        int       i, j;
        PBYTE psrc, pdest;
        ULONG *pulPalette;

        // Copy the 4-bpp pattern to the cache.
        memcpy(ppdev->Xtable[tbl_idx].ajPattern, pRbrush->ajPattern,
                   XLATE_PATSIZE + XLATE_COLORS * sizeof(ULONG));

        psrc = ppdev->Xtable[tbl_idx].ajPattern;
        pulPalette = ppdev->Xtable[tbl_idx].ajPalette;
        pdest = ppdev->Xtable[tbl_idx].pjLinear;
        switch (ppdev->ulBitCount)
        {
                case 8:
                        for (i = 0; i < 8; i++)
                        {
                                for (j = 0; j < 4; j++)
                                {
                                        *pdest++ = (BYTE) pulPalette[psrc[j] >> 4];
                                        *pdest++ = (BYTE) pulPalette[psrc[j] & 0x0F];
                                }
                                psrc += 4;
                        }
                        break;

                case 16:
                        for (i = 0; i < 8; i++)
                        {
                                for (j = 0; j < 4; j++)
                                {
                                        *((WORD *)pdest)++ = (WORD) pulPalette[psrc[j] >> 4];
                                        *((WORD *)pdest)++ = (WORD) pulPalette[psrc[j] & 0x0F];
                                }
                                psrc += 4;
                        }
                        break;

                case 24:
                        for (i = 0; i < 4; i++)
                        {
                                for (j = 0; j < 4; j += 2)
                                {
                                        ULONG p1, p2, p3, p4;

                                        p1 = pulPalette[psrc[j] >> 4];
                                        p2 = pulPalette[psrc[j] & 0x0F];
                                        p3 = pulPalette[psrc[j + 1] >> 4];
                                        p4 = pulPalette[psrc[j + 1] & 0x0F];
                                        *((DWORD *)pdest)++ = p1 | (p2 << 24);
                                        *((DWORD *)pdest)++ = (p2 >> 8) | (p3 << 16);
                                        *((DWORD *)pdest)++ = (p3 >> 16) | (p4 << 8);
                                }
                                psrc += 4;
                                *((DWORD *)pdest)++ = *(DWORD *) &pdest[-24];
                                *((DWORD *)pdest)++ = *(DWORD *) &pdest[-24];
                        }
                        pdest += ppdev->lDeltaScreen - 4 * 8 * 4;
                        for (i = 0; i < 4; i++)
                        {
                                for (j = 0; j < 4; j += 2)
                                {
                                        ULONG p1, p2, p3, p4;

                                        p1 = pulPalette[psrc[j] >> 4];
                                        p2 = pulPalette[psrc[j] & 0x0F];
                                        p3 = pulPalette[psrc[j + 1] >> 4];
                                        p4 = pulPalette[psrc[j + 1] & 0x0F];
                                        *((DWORD *)pdest)++ = p1 | (p2 << 24);
                                        *((DWORD *)pdest)++ = (p2 >> 8) | (p3 << 16);
                                        *((DWORD *)pdest)++ = (p3 >> 16) | (p4 << 8);
                                }
                                psrc += 4;
                                *((DWORD *)pdest)++ = *(DWORD *) &pdest[-24];
                                *((DWORD *)pdest)++ = *(DWORD *) &pdest[-24];
                        }
                        break;

                case 32:
                        for (i = 0; i < 4; i++)
                        {
                                for (j = 0; j < 4; j++)
                                {
                                        *((DWORD *)pdest)++ = pulPalette[psrc[j] >> 4];
                                        *((DWORD *)pdest)++ = pulPalette[psrc[j] & 0x0F];
                                }
                                psrc += 4;
                        }
                        pdest += ppdev->lDeltaScreen - 4 * 8 * 4;
                        for (i = 0; i < 4; i++)
                        {
                                for (j = 0; j < 4; j++)
                                {
                                        *((DWORD *)pdest)++ = pulPalette[psrc[j] >> 4];
                                        *((DWORD *)pdest)++ = pulPalette[psrc[j] & 0x0F];
                                }
                                psrc += 4;
                        }
                        break;
        }

        // Store the new uniq ID in the cache slot.
        pRbrush->iUniq = ppdev->Xtable[tbl_idx].iUniq = ++ppdev->XNext;
        pRbrush->cache_slot = tbl_idx * sizeof(ppdev->Xtable[tbl_idx]);
        pRbrush->cache_xy = ppdev->Xtable[tbl_idx].xy;
        return(TRUE);
}

/**************************************************************************\
 *                                                                                                                                                *
 *      CacheDither()                                                                                                             *
 *      Cache a realized dither brush.                                                                            *
 *                                                                                                                                                *
\**************************************************************************/
BOOL CacheDither(PPDEV ppdev, PRBRUSH pRbrush)
{
        ULONG tbl_idx = ppdev->DNext++ % NUM_DITHER_BRUSHES;

        // Create the dither directly in off-screen memory.
        vDitherColor(pRbrush->iUniq, (ULONG *) ppdev->Dtable[tbl_idx].pjLinear);

        // Store the color in the cache slot.
        ppdev->Dtable[tbl_idx].ulColor = pRbrush->iUniq;
        pRbrush->cache_slot = tbl_idx * sizeof(ppdev->Dtable[tbl_idx]);
        pRbrush->cache_xy = ppdev->Dtable[tbl_idx].xy;
        return(TRUE);
}

/**************************************************************************\
 *                                                                                                                                                *
 *      CacheBrush()                                                                                                              *
 *      Cache a realized color brush.                                                                             *
 *                                                                                                                                                *
\**************************************************************************/
BOOL CacheBrush(PPDEV ppdev, PRBRUSH pRbrush)
{
        PBYTE psrc, pdest;
        ULONG tbl_idx = ppdev->CNext;

        if (++ppdev->CNext == ppdev->CLast)
        {
                ppdev->CNext = 0;
        }

        // Copy the brush bits to off-screen.
        psrc = pRbrush->ajPattern;
        pdest = ppdev->Ctable[tbl_idx].pjLinear;
        if (pRbrush->iBitmapFormat < BMF_24BPP)
        {
                memcpy(pdest, pRbrush->ajPattern, pRbrush->nPatSize);
        }
        else
        {
                memcpy(pdest, psrc, 32 * 4);
                memcpy(pdest + ppdev->lDeltaScreen, psrc + 32 * 4, 32 * 4);
        }

        ppdev->Ctable[tbl_idx].brushID = pRbrush;
        pRbrush->cache_slot = tbl_idx * sizeof(ppdev->Ctable[tbl_idx]);
        pRbrush->cache_xy = ppdev->Ctable[tbl_idx].xy;
        return(TRUE);
}

//--------------------------------------------------------------------------//
//                                                                          //
//  SetBrush()                                                              //
//  Used by op2BLT(), HostToScreenBLT() and ScreenToScreenBLT() in BITBLT.C //
//  to setup the chip to use the current brush.                             //
//                                                                          //
//--------------------------------------------------------------------------//
BOOL SetBrush(
                PPDEV     ppdev,
                ULONG     *bltdef, // local copy of the BLTDEF register.
                BRUSHOBJ  *pbo,
                POINTL    *pptlBrush)
{

        ULONG color;
        PRBRUSH pRbrush = 0;
        USHORT patoff_x, patoff_y;

        if (ppdev->bDirectDrawInUse)
                return(FALSE);

        //
        // See if the brush is really a solid color.
        //
        if (pbo->iSolidColor != 0xFFFFFFFF)  // It's a solid brush.
        {
                // Expand the color to a full 32 bit DWORD.
                switch (ppdev->ulBitCount)
                {
                        case 8:
                                color = pbo->iSolidColor & 0x000000FF;
                                color |= color << 8;
                                color |= color << 16;
                                break;

                        case 16:
                                color = pbo->iSolidColor & 0x0000FFFF;
                                color |= color << 16;
                                break;

                        case 24:
                                color = pbo->iSolidColor & 0x00FFFFFF;
                                break;

                        case 32:
                                color = pbo->iSolidColor;
                                break;
                }

                #if SOLID_CACHE
                        ppdev->Stable[ppdev->SNext].ulColor = color;
                #endif

                // Load the fg and bg color registers.
                REQUIRE(2);
                LL_BGCOLOR(color, 2);

                // Set the operation
                *bltdef |= 0x0007;   // OP2=FILL.

                return TRUE;  // That's it!
        }

        //
        // It's not a solid color, it's a pattern.
        //
        // Get the pointer to our drivers realization of the brush.
        if (pbo->pvRbrush != NULL)
        {
                pRbrush = pbo->pvRbrush;
        }
        else // we haven't realized it yet, so do so now.
        {
                pRbrush = BRUSHOBJ_pvGetRbrush(pbo);
                if (pRbrush == NULL)
                {
                        return(FALSE);  // Fail if we do not handle the brush.
                }
        }

        //
        // Set pattern offset.
        // NT specifies patttern offset as which pixel on the screen to align
        // with pattern(0,0).  Laguna specifies pattern offset as which pixel
        // of the pattern to align with screen(0,0).  Only the lowest three
        // bits are significant, so we can ignore any overflow when converting.
        // Also, even though PATOFF is a reg_16, we can't do byte wide writes
        // to it.  We have to write both PATOFF.pt.X and PATOFF.pt.Y in a single
        // 16 bit write.
        //
#if 1 //#1244
        patoff_x = (USHORT)(-(pptlBrush->x + ppdev->ptlOffset.x) & 7);
        patoff_y = (USHORT)(-(pptlBrush->y + ppdev->ptlOffset.y) & 7);
#else
        patoff_x = ((pptlBrush->x - 1) ^ 0x07) & 0x07;
        patoff_y = ((pptlBrush->y - 1) ^ 0x07) & 0x07;
#endif
        REQUIRE(1);
        LL16(grPATOFF.w, (patoff_y << 8) | patoff_x);

        //
        // What kind of brush is it?
        //
        if (pRbrush->iType == BRUSH_MONO) // Monochrome brush.
        {
                DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: Using MONO Brush.\n"));
                #define mb ((MC_ENTRY*)(((BYTE*)ppdev->Mtable) + pRbrush->cache_slot))
                if (mb->iUniq != pRbrush->iUniq)
                {
                        CacheMono(ppdev, pRbrush);
                }

                // Load the fg and bg color registers.
                REQUIRE(6);
                LL_FGCOLOR(pRbrush->ulForeColor, 0);
                LL_BGCOLOR(pRbrush->ulBackColor, 0);

                LL32(grOP2_opMRDRAM, pRbrush->cache_xy);
                *bltdef |= 0x000D;
                return(TRUE);
        }
        else if (pRbrush->iType == BRUSH_4BPP) // 4-bpp brush.
        {
                DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: Using 4bpp Brush.\n"));
                #define xb ((XC_ENTRY*)(((BYTE*)ppdev->Xtable) + pRbrush->cache_slot))
                if (xb->iUniq != pRbrush->iUniq)
                {
                        Cache4BPP(ppdev, pRbrush);
                }
                REQUIRE(2);
                LL32(grOP2_opMRDRAM, pRbrush->cache_xy);
                *bltdef |= 0x0009;
                return(TRUE);
        }
        else if (pRbrush->iType == BRUSH_DITHER) // Dither brush.
        {
                DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: Using dither Brush.\n"));
                #define db ((DC_ENTRY*)(((BYTE*)ppdev->Dtable) + pRbrush->cache_slot))
                if (db->ulColor != pRbrush->iUniq)
                {
                        CacheDither(ppdev, pRbrush);
                }
                REQUIRE(2);
                LL32(grOP2_opMRDRAM, pRbrush->cache_xy);
                *bltdef |= 0x0009;
                return(TRUE);
        }
        else // Color brush.
        {
                DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: Using color Brush.\n"));
                #define cb ((BC_ENTRY*)(((BYTE*)ppdev->Ctable) + pRbrush->cache_slot))
                if (cb->brushID != pRbrush)
                {
                        CacheBrush(ppdev, pRbrush);
                }
                REQUIRE(2);
                LL32(grOP2_opMRDRAM, pRbrush->cache_xy);
                *bltdef |= 0x0009;
                return(TRUE);
        }
}



// ==========================================================================+
//                                                                          ||
// vInitBrushCache()                                                        ||
// Called by bInitSURF in SCREEN.C                                          ||
// Allocate some off screen memory to cache brushes in.                     ||
// Initialize the brush caching tables.                                     ||
//                                                                          ||
// ==========================================================================+
void vInitBrushCache(
                PPDEV ppdev
)
{
        SIZEL sizel;
        int i;
        ULONG x, y;

        //
        // NOTE: The size and location of the brush cache itself
        //       is in pixel coordinates.  The offsets of the
        //       individual brushes within the cache are BYTE offsets.
        //

        //
        // We need to allocate a 128 BYTE wide rectangle.
        // The offscreen memory manager wants the size of the requested
        // rectangle in PIXELS.  So firure out how many pixels are in 128 bytes.
        //
        /*
                We are going to allocate 3 128-byte wide rectangles, side by side. The
                layout of this brush cache region is:

                +----------------+----------------+----------------+
                |                |                |   MONOCHROME   |
                |     COLOR      |      4BPP      +----------------+
                |    BRUSHES     |    BRUSHES     |     DITHER     |
                |                |                |    BRUSHES     |
                +----------------+----------------+----------------+
        */
        sizel.cy = max(max(NUM_COLOR_BRUSHES / 2,
                                           NUM_4BPP_BRUSHES * 2),
                                           NUM_MONO_BRUSHES / 16 + NUM_DITHER_BRUSHES / 2 + 2);
#if MEMMGR
        sizel.cx = 128 * 3;
#else
        sizel.cx = (128 * 3) / ppdev->iBytesPerPixel;
#endif

        //
        // Allocate the offscreen memory
        //
        DISPDBG((BRUSH_DBG_LEVEL,"Allocating the brush cache.\n"));
        ppdev->Bcache =  AllocOffScnMem(ppdev, &sizel, 0, 0);

        // Did the allocate succeed?
        if (! ppdev->Bcache)
        {
                //
                // We failed to allocate a brush cache.
                // Return while the entire cache is still marked as as unusable,
                // This will cause anything needing a brush to punt.
                //
                return;
        }

        //
        // Init the cache table.
        // The X offests of all the brushes in the cache are BYTE
        // offsets.
        //

        // Init the monochrome cache table. The x offsets are bit offsets.
    // Brushes are stored 16 to a row.
        for (i = 0; i < NUM_MONO_BRUSHES; i++)
        {
                x = ppdev->Bcache->x + (128 * 2) + (i % 16) * 8; // byte offset
                y = ppdev->Bcache->y + (i / 16);
                ppdev->Mtable[i].xy = (y << 16) | (x << 3); // convert to bit offset
                ppdev->Mtable[i].pjLinear = ppdev->pjScreen
                                                                  + x + (y * ppdev->lDeltaScreen);
                ppdev->Mtable[i].iUniq = 0;
        }
        ppdev->MNext = 0;

        // Init the 4-bpp cache table. The x offsets are byte offsets.
        // Each brush takes 2 rows.
        for (i = 0; i < NUM_4BPP_BRUSHES; i++)
        {
                x = ppdev->Bcache->x + (128 * 1);
                y = ppdev->Bcache->y + (i * 2);
                ppdev->Xtable[i].xy = (y << 16) | x;
                ppdev->Xtable[i].pjLinear = ppdev->pjScreen
                                                                  + x + (y * ppdev->lDeltaScreen);
                ppdev->Xtable[i].iUniq = 0;
        }
        ppdev->XNext = 0;

        // Init the dither cache table. The x offsets are byte offsets.
        // Two brushes per row.
        for (i = 0; i < NUM_DITHER_BRUSHES; i++)
        {
                x = ppdev->Bcache->x + (128 * 2) + (i % 2) * 64;
                y = ppdev->Bcache->y + (i / 2) + (NUM_MONO_BRUSHES / 16);
                ppdev->Dtable[i].xy = (y << 16) | x;
                ppdev->Dtable[i].pjLinear = ppdev->pjScreen
                                                                  + x + (y * ppdev->lDeltaScreen);
                ppdev->Dtable[i].ulColor = (ULONG) -1;
        }
        ppdev->DNext = 0;

        #if SOLID_CACHE
                // Solid brush cache is for using a mono brush with a mono source.
                // The mono brush is converted to a solid color brush.
                // Each brush takes two rows.
                for (i = 0; i < NUM_SOLID_BRUSHES; i++)
                {
                        x = ppdev->Bcache->x + (128 * 2);
                        y = ppdev->Bcache->y + (i * 2) + (NUM_MONO_BRUSHES / 16)
                          + (NUM_DITHER_BRUSHES / 2);
                        ppdev->Stable[i].xy = (y << 16) | x;
                        ppdev->Stable[i].pjLinear = ppdev->pjScreen
                                                                          + x + (y * ppdev->lDeltaScreen);
                }
                ppdev->SNext = 0;
        #endif

        // Init the color cache table. The x offsets are byte offsets.
        switch (ppdev->ulBitCount)
        {
                case 8: // 8-bpp
                        ppdev->CLast = NUM_8BPP_BRUSHES;
                        for (i = 0; i < NUM_8BPP_BRUSHES; i++)
                        {
                                x = ppdev->Bcache->x + (i % 2) * 64;
                                y = ppdev->Bcache->y + (i / 2);
                                ppdev->Ctable[i].xy = (y << 16) | x;
                                ppdev->Ctable[i].pjLinear = ppdev->pjScreen
                                                                                  + x + (y * ppdev->lDeltaScreen);
                                ppdev->Ctable[i].brushID = 0;
                        }
                        break;

                case 16: // 16-bpp
                        ppdev->CLast = NUM_16BPP_BRUSHES;
                        for (i = 0; i < NUM_16BPP_BRUSHES; i++)
                        {
                                x = ppdev->Bcache->x;
                                y = ppdev->Bcache->y + i;
                                ppdev->Ctable[i].xy = (y << 16) | x;
                                ppdev->Ctable[i].pjLinear = ppdev->pjScreen
                                                                                  + x + (y * ppdev->lDeltaScreen);
                                ppdev->Ctable[i].brushID = 0;
                        }
                        break;

                default: // 24-bpp or 32-bpp
                        ppdev->CLast = NUM_TC_BRUSHES;
                        for (i = 0; i < NUM_TC_BRUSHES; i++)
                        {
                                x = ppdev->Bcache->x;
                                y = ppdev->Bcache->y + (i * 2);
                                ppdev->Ctable[i].xy = (y << 16) | x;
                                ppdev->Ctable[i].pjLinear = ppdev->pjScreen
                                                                                  + x + (y * ppdev->lDeltaScreen);
                                ppdev->Ctable[i].brushID = 0;
                        }
                        break;
        }
        ppdev->CNext = 0;
}

// ==========================================================================+
//                                                                          ||
// vInvalidateBrushCache()                                                  ||
//                                                                          ||
// Invalidate the brush caching tables.                                     ||
//                                                                          ||
// ==========================================================================+
void vInvalidateBrushCache(PPDEV ppdev)
{
    ULONG i;

        // Invalidate the entire monochrome brush cache.
        for (i = 0; i < NUM_MONO_BRUSHES; i++)
        {
                ppdev->Mtable[i].iUniq = 0;
                memset(ppdev->Mtable[i].ajPattern, 0,
                           sizeof(ppdev->Mtable[i].ajPattern));
        }
//      ppdev->MNext = 0;

        // Invalidate the entire 4-bpp brush cache.
        for (i = 0; i < NUM_4BPP_BRUSHES; i++)
        {
                ppdev->Xtable[i].iUniq = 0;
                memset(ppdev->Xtable[i].ajPattern, 0,
                           sizeof(ppdev->Xtable[i].ajPattern));
        }
//      ppdev->XNext = 0;

        // Invalidate the entire dither brush cache.
        for (i = 0; i < NUM_DITHER_BRUSHES; i++)
        {
                ppdev->Dtable[i].ulColor = (ULONG) -1;
        }
//      ppdev->DNext = 0;

        // Invalidate the entire color brush cache.
        for (i = 0; i < (int) ppdev->CLast; i++)
        {
                ppdev->Ctable[i].brushID = 0;
        }
//      ppdev->CNext = 0;
}


#if LOG_CALLS
/* --------------------------------------------------------------------*\
|                                                                       |
| Dump information on what brushes are requested from GDI to the        |
| profiling file.  Allows us to track what gets accellerated and        |
| what gets punted.  This function gets compiled out under a free       |
| build.                                                                |
|                                                                       |
\*---------------------------------------------------------------------*/

extern long lg_i;
extern char lg_buf[256];

void LogRealizeBrush(
ULONG     acc,
PPDEV     ppdev,
SURFOBJ  *psoPattern,
SURFOBJ  *psoMask,
XLATEOBJ *pxlo
)
{

    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    lg_i = sprintf(lg_buf,"DrvRealizeBrush: ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    // Did we realize it?  If not, why?
    switch (acc)
    {
        case  0: lg_i = sprintf(lg_buf,"(Realized) ");                   break;
        case  1: lg_i = sprintf(lg_buf,"(Punted - No PDEV) ");           break;
        case  2: lg_i = sprintf(lg_buf,"(Punted - Not STYPE_BITMAP) ");  break;
        case  3: lg_i = sprintf(lg_buf,"(Punted - Not 8x8) ");           break;
        case  4: lg_i = sprintf(lg_buf,"(Punted - Has mask) ");          break;
        case  5: lg_i = sprintf(lg_buf,"(Punted - Bad color depth) ");   break;
        case  6: lg_i = sprintf(lg_buf,"(Punted - ALLOC failed) ");      break;
        case  7: lg_i = sprintf(lg_buf,"(Punted - Color Bottom-Up) ");   break;
        case  8: lg_i = sprintf(lg_buf,"(Punted - No 1BPP Xlate) ");     break;
        case  9: lg_i = sprintf(lg_buf,"(Punted - Has Color Xlate) ");   break;
        case 10: lg_i = sprintf(lg_buf,"(Punted - 4bpp format) ");         break;
        case 11: lg_i = sprintf(lg_buf,"(Punted - 1bpp XLATE) ");          break;
        case 99: lg_i = sprintf(lg_buf,"(Dithered) ");             break;
        default: lg_i = sprintf(lg_buf,"(STATUS UNKNOWN) ");             break;
    }
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    if (psoPattern == NULL)
    {
        lg_i = sprintf(lg_buf,"FMT=NULL");
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }
    else
    {
        switch (psoPattern->iBitmapFormat)
        {
            case BMF_1BPP :  lg_i = sprintf(lg_buf,"FMT=1_bpp ");      break;
            case BMF_4BPP :  lg_i = sprintf(lg_buf,"FMT=4_bpp ");      break;
            case BMF_8BPP :  lg_i = sprintf(lg_buf,"FMT=8_bpp ");      break;
            case BMF_16BPP:  lg_i = sprintf(lg_buf,"FMT=16bpp ");      break;
            case BMF_24BPP:  lg_i = sprintf(lg_buf,"FMT=24bpp ");      break;
            case BMF_32BPP:  lg_i = sprintf(lg_buf,"FMT=32bpp ");      break;
            case BMF_4RLE :  lg_i = sprintf(lg_buf,"FMT=4_rle ");      break;
            case BMF_8RLE :  lg_i = sprintf(lg_buf,"FMT=8_rle ");      break;
            default:         lg_i = sprintf(lg_buf,"FMT=OTHER ");      break;
        }
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

        lg_i = sprintf(lg_buf,"CX=%d CY=%d ", psoPattern->sizlBitmap.cx, psoPattern->sizlBitmap.cy);
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    }

    lg_i = sprintf(lg_buf,"MASK=%s ",
                                ((psoMask == NULL) ? "NONE":
                                ((psoMask->pvScan0 == psoPattern->pvScan0) ? "SAME" : "DIFF")));
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    if (pxlo == NULL)
    {
        lg_i = sprintf(lg_buf,"XLAT=NONE ");
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }
    else
    {
        if (pxlo->flXlate & XO_TRIVIAL)
        {
            lg_i = sprintf(lg_buf,"XLAT=TRIVIAL ");
            WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
        }
        if (pxlo->flXlate & XO_TABLE)
        {
            lg_i = sprintf(lg_buf,"XLAT=TABLE ");
            WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
        }
        if (pxlo->flXlate & XO_TO_MONO)
        {
            lg_i = sprintf(lg_buf,"XLAT=TO_MONO ");
            WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
        }

        switch (pxlo->iSrcType)
        {
            case PAL_INDEXED:   lg_i = sprintf(lg_buf,"SRCPAL=INDEXED  "); break;
            case PAL_BITFIELDS: lg_i = sprintf(lg_buf,"SRCPAL=BITFIELD "); break;
            case PAL_RGB:       lg_i = sprintf(lg_buf,"SRCPAL=R_G_B    "); break;
            case PAL_BGR:       lg_i = sprintf(lg_buf,"SRCPAL=B_G_R    "); break;
            default:            lg_i = sprintf(lg_buf,"SRCPAL=NONE     "); break;
        }
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

        switch (pxlo->iDstType)
        {
            case PAL_INDEXED:  lg_i = sprintf(lg_buf,"DSTPAL=INDEXED  "); break;
            case PAL_BITFIELDS:lg_i = sprintf(lg_buf,"DSTPAL=BITFIELD "); break;
            case PAL_RGB:      lg_i = sprintf(lg_buf,"DSTPAL=R_G_B    "); break;
            case PAL_BGR:      lg_i = sprintf(lg_buf,"DSTPAL=B_G_R    "); break;
            default:           lg_i = sprintf(lg_buf,"DSTPAL=NONE     "); break;
        }
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }

    lg_i = sprintf(lg_buf,"\r\n");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

}
#endif

#if SOLID_CACHE
/******************************************************************************
 *                                                                                                                                                        *
 * Name:                CacheSolid                                                                                                        *
 *                                                                                                                                                        *
 * Function:    Convert a solid color into a colored brush for use when a         *
 *                              monochrome source blt requires a solid brush. This will speed *
 *                              up WinBench 96 tests 5 and 9.                                                             *
 *                                                                                                                                                        *
 ******************************************************************************/
void CacheSolid(PPDEV ppdev)
{
        PBYTE pjBrush = ppdev->Stable[ppdev->SNext].pjLinear;
        ULONG color = ppdev->Stable[ppdev->SNext].ulColor;
        int   i, j;

        switch (ppdev->iBitmapFormat)
        {
                case BMF_8BPP:
                        for (i = 0; i < 64; i += 4)
                        {
                                // Remember, the color is already expanded!
                                *(ULONG *) &pjBrush[i] = color;
                        }
                        break;

                case BMF_16BPP:
                        for (i = 0; i < 128; i += 4)
                        {
                                // Remember, the color is already expanded!
                                *(ULONG *) &pjBrush[i] = color;
                        }
                        break;

                case BMF_24BPP:
                        for (j = 0; j < 4; j++)
                        {
                                for (i = 0; i < 24; i += 3)
                                {
                                        *(ULONG *) &pjBrush[i] = color;
                                }
                                *(ULONG *) &pjBrush[i + 0] = *(ULONG *) &pjBrush[0];
                                *(ULONG *) &pjBrush[i + 4] = *(ULONG *) &pjBrush[4];
                                pjBrush += 32;
                        }
                        pjBrush += ppdev->lDeltaScreen - 128;
                        for (j = 0; j < 4; j++)
                        {
                                for (i = 0; i < 24; i += 3)
                                {
                                        *(ULONG *) &pjBrush[i] = color;
                                }
                                *(ULONG *) &pjBrush[i + 0] = *(ULONG *) &pjBrush[0];
                                *(ULONG *) &pjBrush[i + 4] = *(ULONG *) &pjBrush[4];
                                pjBrush += 32;
                        }
                        break;

                case BMF_32BPP:
                        for (i = 0; i < 128; i += 4)
                        {
                                *(ULONG *) &pjBrush[i] = color;
                        }
                        pjBrush += ppdev->lDeltaScreen;
                        for (i = 0; i < 128; i += 4)
                        {
                                *(ULONG *) &pjBrush[i] = color;
                        }
                        break;
        }

        REQUIRE(2);
        LL32(grOP2_opMRDRAM, ppdev->Stable[ppdev->SNext].xy);
        ppdev->SNext = (ppdev->SNext + 1) % NUM_SOLID_BRUSHES;
}
#endif

#if DBG

//
// The rest of this file is debugging functions.
//

/* --------------------------------------------------------------------*\
|                                                                       |
| PrintBrush()                                                          |
| Dump a 1 bpp brush as 'X's and ' 's to the debuger so we can see what |
| it looks like.                                                        |
|                                                                       |
| We don't currently use this, but it can be useful to have for         |
| debugging purposes.                                                   |
|                                                                       |
\*---------------------------------------------------------------------*/
void PrintBrush(
        SURFOBJ  *psoPattern
)
{
        int i,j;
        char c;

        // Only do this for 1bpp brushes.
        if (psoPattern->iBitmapFormat != BMF_1BPP)
                return;

        DISPDBG((BRUSH_DBG_LEVEL,"Brush information:\n"));

        DISPDBG((BRUSH_DBG_LEVEL,"Brush delta is %d bytes.\n",psoPattern->lDelta));
        DISPDBG((BRUSH_DBG_LEVEL,"Brush uses %d bytes.\n",psoPattern->cjBits));
        DISPDBG((BRUSH_DBG_LEVEL,"Brush bits are at 0x%08X.\n",psoPattern->pvBits));
        DISPDBG((BRUSH_DBG_LEVEL,"Scan 0 is at 0x%08X.\n",psoPattern->pvScan0));
        if (psoPattern->fjBitmap & BMF_TOPDOWN)
                        DISPDBG((BRUSH_DBG_LEVEL,"Brush is top down.\n",psoPattern->pvScan0));
        else
                        DISPDBG((BRUSH_DBG_LEVEL,"Brush is bottom up.\n",psoPattern->pvScan0));


        DISPDBG((BRUSH_DBG_LEVEL,"PATTERN:\n"));

        for (i=0; i<8; ++i)
        {
            c = (unsigned char)((long*)psoPattern->pvBits)[i];

            DISPDBG((BRUSH_DBG_LEVEL,"'"));
            for (j=7; (7>=j && j>=0) ; --j)
            {
                 if (c&1)
                        DISPDBG((BRUSH_DBG_LEVEL,"X"));
                 else
                        DISPDBG((BRUSH_DBG_LEVEL," "));
                 c = c >> 1;
            }
            DISPDBG((BRUSH_DBG_LEVEL,"'\n"));
        }

}


//
// ===========================================================================
// Dumps all kind of cool stuff about realized brushes to the debugger.
//
// Here's the realized brush structure:
/*

typedef struct {
        ULONG   nPatSize;
        ULONG   iBitmapFormat;
        ULONG   ulForeColor;
        ULONG   ulBackColor;
        ULONG   isCached;           // 1 if this brush is cached, 0 if not.
        ULONG   cache_slot;         // Slot number of cache table entry.
        ULONG   cache_x;            // These are the (x,y) location of
        ULONG   cache_y;            // the cached brush from screen(0,0)
        ULONG   cjMask;             // offset to mask bits in ajPattern[]
        BYTE    ajPattern[1];       // pattern bits followed by mask bits
} RBRUSH, *PRBRUSH;

*/
// ============================================================================
//
void PrintRealizedBrush(
        PRBRUSH pRbrush)
{
        int i,j;
        char c;

        // Only do this for 1bpp brushes.
        if (pRbrush->iBitmapFormat != BMF_1BPP)
                return;

        DISPDBG((BRUSH_DBG_LEVEL,"\nRealized brush information:\n"));

        DISPDBG((BRUSH_DBG_LEVEL,"Brush colors:  FG = 0x%08X  BG = 0x%08X \n",
                                pRbrush->ulForeColor, pRbrush->ulForeColor));

        DISPDBG((BRUSH_DBG_LEVEL,"Brush pattern size is  %d bytes.\n",
                                pRbrush->nPatSize));

        DISPDBG((BRUSH_DBG_LEVEL,"PATTERN:\n"));

        for (i=0; i<8; ++i)
        {
                c = pRbrush->ajPattern[i];

                DISPDBG((BRUSH_DBG_LEVEL,"'"));
                for (j=7; (7>=j && j>=0) ; --j)
                {
                         if (c&1)
                                        DISPDBG((BRUSH_DBG_LEVEL,"X"));
                         else
                                        DISPDBG((BRUSH_DBG_LEVEL," "));
                         c = c >> 1;
                }
                DISPDBG((BRUSH_DBG_LEVEL,"'\n"));
        }

                DISPDBG((BRUSH_DBG_LEVEL,"\n"));

}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\ddflip.c ===
/***************************************************************************
*
*                ******************************************
*                * Copyright (c) 1996, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:  Laguna I (CL-GD546x) -
*
* FILE:     ddflip.c
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This module implements the DirectDraw FLIP components
*           for the Laguna NT driver.
*
* MODULES:
*           vGetDisplayDuration()
*           vUpdateFlipStatus()
*           DdFlip()
*           DdWaitForVerticalBlank()
*           DdGetFlipStatus()
*
* REVISION HISTORY:
*   7/12/96     Benny Ng      Initial version
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/ddflip.c  $
* 
*    Rev 1.10   16 Sep 1997 15:04:06   bennyn
* 
* Modified for NT DD overlay
* 
*    Rev 1.9   29 Aug 1997 17:42:20   RUSSL
* Added 65 overlay support
*
*    Rev 1.8   11 Aug 1997 14:07:58   bennyn
*
* Enabled GetScanLine() (for PDR 10254)
*
****************************************************************************
****************************************************************************/
/*----------------------------- INCLUDES ----------------------------------*/
#include "precomp.h"

//
// This file isn't used in NT 3.51
//
#ifndef WINNT_VER35

/*----------------------------- DEFINES -----------------------------------*/
//#define DBGBRK
#define DBGLVL        1

#define CSL           0x00C4
#define CSL_5464      0x0140

/*--------------------- STATIC FUNCTION PROTOTYPES ------------------------*/

/*--------------------------- ENUMERATIONS --------------------------------*/

/*----------------------------- TYPEDEFS ----------------------------------*/

/*-------------------------- STATIC VARIABLES -----------------------------*/

/*-------------------------- GLOBAL FUNCTIONS -----------------------------*/

#if DRIVER_5465 && defined(OVERLAY)
// CurrentVLine is in ddinline.h for overlay
#else
/***************************************************************************
*
* FUNCTION:     CurrentVLine
*
* DESCRIPTION:
*
****************************************************************************/
static __inline int CurrentVLine (PDEV* ppdev)
{
  WORD   cline;
  PBYTE  pMMReg = (PBYTE) ppdev->pLgREGS_real;
  PWORD  pCSL;
  BYTE   tmpb;


  // on 5462 there is no CurrentScanLine register
  // on RevAA of 5465 it's busted
  if ((CL_GD5462 == ppdev->dwLgDevID) ||
     ((CL_GD5465 == ppdev->dwLgDevID) && (0 == ppdev->dwLgDevRev)))
     return 0;

  if (IN_VBLANK)
     return 0;

  // read current scanline
  if (ppdev->dwLgDevID == CL_GD5464)
     pCSL = (PWORD) (pMMReg + CSL_5464);
  else
     pCSL = (PWORD) (pMMReg + CSL);

  cline = *pCSL & 0x0FFF;

  // if scanline doubling is enabled, divide current scanline by 2
  tmpb = (BYTE) LLDR_SZ (grCR9);
  if (0x80 & tmpb)
     cline /= 2;

  // if current scanline is past end of visible screen return 0
  if (cline >= ppdev->cyScreen)
    return 0;
  else
    return cline;
}
#endif

/****************************************************************************
* FUNCTION NAME: vGetDisplayDuration
*
* DESCRIPTION:   Get the length, in EngQueryPerformanceCounter() ticks,
*                of a refresh cycle.
*                (Based on S3 DirectDraw code)
****************************************************************************/
#define NUM_VBLANKS_TO_MEASURE      1
#define NUM_MEASUREMENTS_TO_TAKE    8

VOID vGetDisplayDuration(PFLIPRECORD pflipRecord)
{
  LONG        i,  j;
  LONGLONG    li, liMin;
  LONGLONG    aliMeasurement[NUM_MEASUREMENTS_TO_TAKE + 1];

  DISPDBG((DBGLVL, "DDraw - vGetDisplayDuration\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  memset(pflipRecord, 0, sizeof(FLIPRECORD));

  // Warm up EngQUeryPerformanceCounter to make sure it's in the working set
  EngQueryPerformanceCounter(&li);

  // Unfortunately, since NT is a proper multitasking system, we can't
  // just disable interrupts to take an accurate reading.  We also can't
  // do anything so goofy as dynamically change our thread's priority to
  // real-time.
  //
  // So we just do a bunch of short measurements and take the minimum.
  //
  // It would be 'okay' if we got a result that's longer than the actual
  // VBlank cycle time -- nothing bad would happen except that the app
  // would run a little slower.  We don't want to get a result that's
  // shorter than the actual VBlank cycle time -- that could cause us
  // to start drawing over a frame before the Flip has occured.
  while(IN_VBLANK);
  while(IN_DISPLAY);

  for (i = 0; i < NUM_MEASUREMENTS_TO_TAKE; i++)
  {
    // We're at the start of the VBlank active cycle!
    EngQueryPerformanceCounter(&aliMeasurement[i]);

    // Okay, so life in a multi-tasking environment isn't all that
    // simple.  What if we had taken a context switch just before
    // the above EngQueryPerformanceCounter call, and now were half
    // way through the VBlank inactive cycle?  Then we would measure
    // only half a VBlank cycle, which is obviously bad.  The worst
    // thing we can do is get a time shorter than the actual VBlank
    // cycle time.
    //
    // So we solve this by making sure we're in the VBlank active
    // time before and after we query the time.  If it's not, we'll
    // sync up to the next VBlank (it's okay to measure this period --
    // it will be guaranteed to be longer than the VBlank cycle and
    // will likely be thrown out when we select the minimum sample).
    // There's a chance that we'll take a context switch and return
    // just before the end of the active VBlank time -- meaning that
    // the actual measured time would be less than the true amount --
    // but since the VBlank is active less than 1% of the time, this
    // means that we would have a maximum of 1% error approximately
    // 1% of the times we take a context switch.  An acceptable risk.
    //
    // This next line will cause us wait if we're no longer in the
    // VBlank active cycle as we should be at this point:
    while(IN_DISPLAY);

    for (j = 0; j < NUM_VBLANKS_TO_MEASURE; j++)
    {
      while(IN_VBLANK);
      while(IN_DISPLAY);
    };
  };

  EngQueryPerformanceCounter(&aliMeasurement[NUM_MEASUREMENTS_TO_TAKE]);

  // Use the minimum:
  liMin = aliMeasurement[1] - aliMeasurement[0];

  for (i = 2; i <= NUM_MEASUREMENTS_TO_TAKE; i++)
  {
    li = aliMeasurement[i] - aliMeasurement[i - 1];

    if (li < liMin)
       liMin = li;
  };

  // Round the result:
  pflipRecord->liFlipDuration
      = (DWORD) (liMin + (NUM_VBLANKS_TO_MEASURE / 2)) / NUM_VBLANKS_TO_MEASURE;

  pflipRecord->liFlipTime = aliMeasurement[NUM_MEASUREMENTS_TO_TAKE];
  pflipRecord->bFlipFlag  = FALSE;
  pflipRecord->fpFlipFrom = 0;
} // getDisplayDuration


/****************************************************************************
* FUNCTION NAME: vUpdateFlipStatus
*
* DESCRIPTION:   Checks and sees if the most recent flip has occurred.
*                (Based on S3 DirectDraw code)
****************************************************************************/
HRESULT vUpdateFlipStatus(PFLIPRECORD pflipRecord, FLATPTR fpVidMem)
{
  LONGLONG liTime;

  DISPDBG((DBGLVL, "DDraw - vUpdateFlipStatus\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  // see if a flip has happened recently
  if ((pflipRecord->bFlipFlag) &&
      ((fpVidMem == 0xFFFFFFFF) || (fpVidMem == pflipRecord->fpFlipFrom)))
  {
    if ((IN_VBLANK))
    {
       if (pflipRecord->bWasEverInDisplay)
          pflipRecord->bHaveEverCrossedVBlank = TRUE;
    }
    else if (!(IN_DISPLAYENABLE))
    {
       if (pflipRecord->bHaveEverCrossedVBlank)
       {
          pflipRecord->bFlipFlag = FALSE;

          return(DD_OK);
       };
       pflipRecord->bWasEverInDisplay = TRUE;
    };

    EngQueryPerformanceCounter(&liTime);

    if (liTime - pflipRecord->liFlipTime <= pflipRecord->liFlipDuration)
    {
        return(DDERR_WASSTILLDRAWING);
    };

    pflipRecord->bFlipFlag = FALSE;
  };

  return(DD_OK);
} // updateFlipStatus


/****************************************************************************
* FUNCTION NAME: DdFlip
*
* DESCRIPTION:
*                (Based on S3 DirectDraw code)
****************************************************************************/
DWORD DdFlip(PDD_FLIPDATA lpFlip)
{
  DRIVERDATA* pDriverData;
  PDEV*       ppdev;
  HRESULT     ddrval;

  ULONG       ulMemoryOffset;
  ULONG       ulLowOffset;
  ULONG       ulMiddleOffset;
  ULONG       ulHighOffset;
  BYTE        tmpb;

  DISPDBG((DBGLVL, "DDraw - DdFlip\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  ppdev = (PDEV*) lpFlip->lpDD->dhpdev;
  pDriverData = (DRIVERDATA*) &ppdev->DriverData;

  SYNC_W_3D(ppdev);

#if DRIVER_5465 && defined(OVERLAY)
  if (DDSCAPS_OVERLAY & lpFlip->lpSurfCurr->ddsCaps.dwCaps)
    return pDriverData->OverlayTable.pfnFlip(ppdev,lpFlip);
#endif

  // Is the current flip still in progress?
  // Don't want a flip to work until after the last flip is done,
  // so we ask for the general flip status.
  ddrval = vUpdateFlipStatus(&ppdev->flipRecord, 0xFFFFFFFF);

  if ((ddrval != DD_OK) || (DrawEngineBusy(pDriverData)))
  {
     lpFlip->ddRVal = DDERR_WASSTILLDRAWING;
     return(DDHAL_DRIVER_HANDLED);
  };

  // everything is OK, do the flip here
  {
    DWORD dwOffset;

    // Determine the offset to the new area.
    dwOffset = lpFlip->lpSurfTarg->lpGbl->fpVidMem >> 2;

    // Make sure that the border/blanking period isn't active; wait if
    // it is.  We could return DDERR_WASSTILLDRAWING in this case, but
    // that will increase the odds that we can't flip the next time:
    while (IN_DISPLAYENABLE)
        ;

    // Flip the primary surface by changing CRD, CRC, CR1B and CR1D
    // Do CRD last because the start address is double buffered and
    // will take effect after CRD is updated.

    // need bits 19 & 20 of address in bits 3 & 4 of CR1D
    tmpb = (BYTE) LLDR_SZ (grCR1D);
    tmpb = (tmpb & ~0x18) | (BYTE3FROMDWORD(dwOffset) & 0x18);
    LL8(grCR1D, tmpb);

    // need bits 16, 17 & 18 of address in bits 0, 2 & 3 of CR1B
	 tmpb = (BYTE) LLDR_SZ (grCR1B);
    tmpb = (tmpb & ~0x0D) |
           ((((BYTE3FROMDWORD(dwOffset) & 0x06) << 1) |
              (BYTE3FROMDWORD(dwOffset) & 0x01)));
    LL8(grCR1B, tmpb);

    // bits 8-15 of address go in CRC
    LL8(grCRC, BYTE2FROMDWORD(dwOffset));
    // bits 0-7 of address go in CRD
    LL8(grCRD, BYTE1FROMDWORD(dwOffset));
  };

  // remember where/when we were when we did the flip
  EngQueryPerformanceCounter(&ppdev->flipRecord.liFlipTime);

  ppdev->flipRecord.bFlipFlag              = TRUE;
  ppdev->flipRecord.bHaveEverCrossedVBlank = FALSE;
  ppdev->flipRecord.bWasEverInDisplay      = FALSE;

  ppdev->flipRecord.fpFlipFrom = lpFlip->lpSurfCurr->lpGbl->fpVidMem;

  lpFlip->ddRVal = DD_OK;

  return(DDHAL_DRIVER_HANDLED);
} // Flip


/****************************************************************************
* FUNCTION NAME: DdWaitForVerticalBlank
*
* DESCRIPTION:
****************************************************************************/
DWORD DdWaitForVerticalBlank(PDD_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank)
{
  PDEV*  ppdev;

  DISPDBG((DBGLVL, "DDraw - DdWaitForVerticalBlank\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  ppdev = (PDEV*) lpWaitForVerticalBlank->lpDD->dhpdev;

  lpWaitForVerticalBlank->ddRVal = DD_OK;

  switch (lpWaitForVerticalBlank->dwFlags)
  {
    case DDWAITVB_I_TESTVB:
      // If TESTVB, it's just a request for the current vertical blank
      // status:
      lpWaitForVerticalBlank->bIsInVB = IN_VBLANK;
      return(DDHAL_DRIVER_HANDLED);

    case DDWAITVB_BLOCKBEGIN:
      // If BLOCKBEGIN is requested, we wait until the vertical blank
      // is over, and then wait for the display period to end:
      while(IN_VBLANK);
      while(IN_DISPLAY);
      return(DDHAL_DRIVER_HANDLED);

    case DDWAITVB_BLOCKEND:
      // If BLOCKEND is requested, we wait for the vblank interval to end:
      while(IN_DISPLAY);
      while(IN_VBLANK);
      return(DDHAL_DRIVER_HANDLED);

    default:
      return DDHAL_DRIVER_NOTHANDLED;
  };  // end switch

  return(DDHAL_DRIVER_NOTHANDLED);
} // WaitForVerticalBlank


/****************************************************************************
* FUNCTION NAME: DdGetFlipStatus
*
* DESCRIPTION:   If the display has gone through one refresh cycle since
*                the flip occurred, we return DD_OK.  If it has not gone
*                through one refresh cycle we return DDERR_WASSTILLDRAWING
*                to indicate that this surface is still busy "drawing" the
*                flipped page. We also return DDERR_WASSTILLDRAWING if the
*                bltter is busy and the caller wanted to know if they could
*                flip yet.
****************************************************************************/
DWORD DdGetFlipStatus(PDD_GETFLIPSTATUSDATA lpGetFlipStatus)
{
  DRIVERDATA* pDriverData;
  PDEV*  ppdev;

  ppdev = (PDEV*) lpGetFlipStatus->lpDD->dhpdev;
  pDriverData = (DRIVERDATA*) &ppdev->DriverData;

  DISPDBG((DBGLVL, "DDraw - DdGetFlipStatus\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  SYNC_W_3D(ppdev);

#if DRIVER_5465 && defined(OVERLAY)
  if (DDSCAPS_OVERLAY & lpGetFlipStatus->lpDDSurface->ddsCaps.dwCaps)
  {
    DWORD   dwVWIndex;
    LP_SURFACE_DATA  pSurfaceData = (LP_SURFACE_DATA) lpGetFlipStatus->lpDDSurface->dwReserved1;

    dwVWIndex = GetVideoWindowIndex(pSurfaceData->dwOverlayFlags);

    lpGetFlipStatus->ddRVal =
        pDriverData->OverlayTable.pfnGetFlipStatus(ppdev,
                                                   lpGetFlipStatus->lpDDSurface->lpGbl->fpVidMem,
                                                   dwVWIndex);
  }
  else
#endif
  {
    // We don't want a flip to work until after the last flip is done,
    // so we ask for the general flip status.
    lpGetFlipStatus->ddRVal = vUpdateFlipStatus(&ppdev->flipRecord, 0xFFFFFFFF);
  }

  // Check if the bltter is busy if someone wants to know if they can flip
  if (lpGetFlipStatus->dwFlags == DDGFS_CANFLIP)
  {
     if ((lpGetFlipStatus->ddRVal == DD_OK) && DrawEngineBusy(pDriverData))
        lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;
  }

  return(DDHAL_DRIVER_HANDLED);

} // GetFlipStatus


// #ifdef  DDDRV_GETSCANLINE  /************/
/****************************************************************************
* FUNCTION NAME: GetScanLine
*
* DESCRIPTION:
*                (Based on Laguna Win95 DirectDraw code)
****************************************************************************/
DWORD GetScanLine(PDD_GETSCANLINEDATA lpGetScanLine)
{
  PDEV*   ppdev;

  ppdev  = (PDEV*) lpGetScanLine->lpDD->dhpdev;

  // If a vertical blank is in progress the scan line is in
  // indeterminant. If the scan line is indeterminant we return
  // the error code DDERR_VERTICALBLANKINPROGRESS.
  // Otherwise we return the scan line and a success code

  SYNC_W_3D(ppdev);   // if 3D context(s) active, make sure 3D engine idle before continuing...

  if (IN_VBLANK)
  {
     lpGetScanLine->ddRVal = DDERR_VERTICALBLANKINPROGRESS;
  }
  else
  {
     lpGetScanLine->dwScanLine = CurrentVLine(ppdev);
     lpGetScanLine->ddRVal = DD_OK;
  };

  return DDHAL_DRIVER_HANDLED;

} // GetScanLine

// #endif // DDDRV_GETSCANLINE ************

#endif // ! ver 3.51



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\displist.c ===
/******************************Module*Header*******************************\
*
* Module Name: displist.c
* Author: Goran Devic, Mark Einkauf
* Purpose: General output to Laguna3D 
*
* Copyright (c) 1997 Cirrus Logic, Inc.
*
\**************************************************************************/

#define OPENGL_MCD

#include "precomp.h"
#include "mcdhw.h"
#include "mcdutil.h"

/*********************************************************************
*   Defines
**********************************************************************/
#define DL_MIN_SIZE       (8 * KB)  // Minimum size of the d-list
#define DL_MAX_SIZE    (4096 * KB)  // Maximum size of the d-list

#define DL_SAFETY_MARGIN  (1 * KB)  // Margin when building d-list (b)

//WARNING!!! Any change to DL_START_OFFSET must be made in polys.c also!!!
#define DL_START_OFFSET    20       // 5 dwords offset for dlist
//WARNING!!! Any change to DL_START_OFFSET must be made in polys.c also!!!

/*********************************************************************
*   Include Files
**********************************************************************/



/*********************************************************************
*   Local Functions
**********************************************************************/

/*********************************************************************
*
*   DWORD _InitDisplayList( LL_DeviceState * DC )
*
*       Allocates memory and initializes display list structure.
*       Two display lists are created.
*
*   Where:
*
*       DC is the device context structure to be initialized
*       DC->dwDisplayListLen is the size of the display list
*           to be allocated (in bytes).
*
*   Returns:
*
*       LL_OK (0) if initialization succeeds
*       error_code if initialization fails
*
**********************************************************************/
DWORD _InitDisplayList( PDEV *ppdev, DWORD dwListLen )
{
    int i;
    
#if 0
    // The user requested DC->dwDisplayListLen bytes of system memory
    // to be used for device display list.  That memory will be
    // allocated and stay locked.  But first, we subdivide it at
    // several chunks for display list multibuffering.
    //
    
    // Sanity check
    //
    if( dwListLen < DL_MIN_SIZE || dwListLen > DL_MAX_SIZE )
        return( LLE_INI_DL_LEN );


    // Subdivide display list and allocate each chunk
    //
    chunk_size = (dwListLen / NUM_DL) & ~3;
    
    for( i=0; i<NUM_DL; i++ )
    {
        // Allocate memory for a display list
        //

        if( (LL_State.DL[i].hMem = AllocSystemMemory( chunk_size )) == 0 )
            return( LLE_INI_ALLOC_DL );
            
        // Get the linear and physical address of a display list
        //
        LL_State.DL[i].pdwLinPtr = (DWORD *) GetLinearAddress( LL_State.DL[i].hMem );
        LL_State.DL[i].dwPhyPtr  = GetPhysicalAddress( LL_State.DL[i].hMem );

        // Set the length and the parametarization pointer to point to the
        // offset of 20: 16 bytes are reserved for jump table, additional 4 bytes
        // for a semaphore.
        //
        LL_State.DL[i].dwLen = chunk_size;
        LL_State.DL[i].pdwNext = LL_State.DL[i].pdwLinPtr + DL_START_OFFSET/4;
        LL_State.DL[i].pdwStartOutPtr = LL_State.DL[i].pdwNext;//only used in coproc mode

        // Clear the jump table and a semaphore
        //
        LL_State.DL[i].pdwNext[0] = IDLE;
        LL_State.DL[i].pdwNext[1] = IDLE;
        LL_State.DL[i].pdwNext[2] = IDLE;
        LL_State.DL[i].pdwNext[3] = IDLE;
        LL_State.DL[i].pdwNext[4] = 0;
        
        // Set the safety margin for the parametarization routines
        //
        LL_State.DL[i].dwMargin = (DWORD)LL_State.DL[i].pdwLinPtr + chunk_size - DL_SAFETY_MARGIN;
        
        // Temporary fix for non-flushing TLB
        *(DWORD *)((DWORD)LL_State.DL[i].pdwLinPtr + chunk_size - 16) = BRANCH + DL_START_OFFSET;


        DEB2("Display list: %d\n", i );
        DEB2("\tLength = %d b\n", LL_State.DL[i].dwLen );
        DEB2("\tMemory handle = %08Xh\n", LL_State.DL[i].hMem );
        DEB2("\tLinear memory = %08Xh\n", LL_State.DL[i].pdwLinPtr );
        DEB2("\tPhysical memory = %08Xh\n", LL_State.DL[i].dwPhyPtr );
        DEB2("\tSafety margin = %08Xh\n", LL_State.DL[i].dwMargin );
    }

    // Set the current display list to the first one.  This one will be
    // used with parametarizations
    //
    LL_State.dwCdl = 0;
    LL_State.pDL = &LL_State.DL[0];
    *(LL_State.pRegs + PF_BASE_ADDR_3D) = LL_State.DL[0].dwPhyPtr;

#else 

	// MCD_TEMP - reduced InitDisplayList function to get running quickly - 1 DList only

    ppdev->LL_State.DL[0].pdwLinPtr = ppdev->temp_DL_chunk;

    // Set the length and the parametarization pointer to point to the
    // offset of 20: 16 bytes are reserved for jump table, additional 4 bytes
    // for a semaphore.
    //
    ppdev->LL_State.DL[0].dwLen = dwListLen;
    ppdev->LL_State.DL[0].pdwNext = ppdev->LL_State.DL[0].pdwLinPtr + DL_START_OFFSET/4;
    ppdev->LL_State.DL[0].pdwStartOutPtr = ppdev->LL_State.DL[0].pdwNext;//only used in coproc mode

	ppdev->LL_State.pDL = &ppdev->LL_State.DL[ 0 ];
    ppdev->LL_State.pDL->pdwNext = ppdev->LL_State.pDL->pdwLinPtr + DL_START_OFFSET/4;
	ppdev->LL_State.pDL->pdwStartOutPtr = ppdev->LL_State.pDL->pdwNext;//only used in coproc mode
	
#endif			

    return( LL_OK );
}



#ifndef OPENGL_MCD

/*********************************************************************
*
*   void _CloseDisplayList()
*
*       Cleans up the memory allocations for display list(s).
*       This function is to be called at closing the library.
*
**********************************************************************/
void _CloseDisplayList()
{
    int i;
    

    // Loop through and free each chunk of the display list
    //
    for( i=0; i<NUM_DL; i++ )
    {
        // Free memory and reset pointers just to be safe
        //
        FreeSystemMemory( LL_State.DL[i].hMem );
        memset( &LL_State.DL[i], 0, sizeof(TDisplayList) );
    }

    LL_State.pDL = NULL;
}



/*********************************************************************
*
*   Batch cell instruction: LL_IDLE
*
*   Stores IDLE Laguna 3D microinstruction.
*
*   Every batch array that is sent to the LL_Execute() must have this
*   operation terminating it.
*
*   Example:
*
*       pBatch->bOp = LL_IDLE;
*
**********************************************************************/
DWORD * fnIdle( DWORD * pdwNext, LL_Batch * pBatch )
{
    if( !LL_State.fIndirectMode )
        *pdwNext++ = IDLE;

    return( pdwNext );
}


/*********************************************************************
*
*   Batch cell instruction: LL_NOP
*
*   Does nothing.
*
**********************************************************************/
DWORD * fnNop( DWORD * pdwNext, LL_Batch * pBatch )
{
    return( pdwNext );
}


/*********************************************************************
*
*   Batch cell instruction: LL_RAW_DATA
*
*   Copies raw data to the display list.  The pointer to data (DWORD *)
*   is pVert, number of dwords to be copied is in wCount.
*
*   Note: All the data must fit into a display list.  No explicit checking
*   is done.  Keep your data stream short!
*
*   Example:
*
*       pBatch->wCount = 2;                         // 2 integers of data
*       pBatch->pVert = (DWORD *) &MyData[0];       // Starting data address
*
**********************************************************************/
DWORD * fnRawData( DWORD * pdwNext, LL_Batch * pBatch )
{
    register int count;
    register DWORD * dwPtr;
    
   
    dwPtr = (DWORD *)pBatch->pVert;
    
    for( count = pBatch->wCount; count>0; count-- )
    {
        *pdwNext++ = *dwPtr++;
    }

    return( pdwNext );
}

#endif // ndef OPENGL_MCD

/*********************************************************************
*
*   DWORD * _RunLaguna( DWORD *pdwNext )
*
*       Spins off Laguna 3D and resets the parametarization pointers
*       to the next available d-list
*
*       The function will take into account the rendering mode that
*       was set to either processor or coprocessor indirect.
*       In the later case it will sense the instructions that can
*       not be executed in that mode and it will do them directly.
*
*   Where:
*
*       pdwNext is the pointer to a current display list to the next
*       available space.
*
*   Returns:
*
*       Offset in the new d-list to start building
*
**********************************************************************/
void _RunLaguna( PDEV *ppdev, DWORD *pdwNext )
{
    DWORD instr;
    int len;
    int address, offset, update_offset;
    int event;
    volatile int status;

    // Two rendering modes are supported: processor direct mode and
    // coprocessor indirect mode.
    //
    // MCD_TEMP - RunLaguna only supporting coprocessor mode now
  //if( ppdev->LL_State.fIndirectMode )
    {
        
        DWORD *pSrc, *pDest;

        // Co-processor indirect mode: use host data port to program
        // the hardware
        //
        pSrc = ppdev->LL_State.pDL->pdwStartOutPtr;
        pDest = ppdev->LL_State.pRegs + HOST_3D_DATA_PORT;

        // Assumption: On the entry of this loop pSrc points to the valid
        // instruction.
        //
        while( pdwNext != pSrc )
        {
            // The display list is examined for the instructions that
            // can not be executed in coprocessor mode.  That involves
            // partially disassembling each instruction and tracing the
            // number of parameters.
            //
            // All this work is done so that WRITE_DEV_REGS and READ_DEV_REGS
            // may be detected and simulated.  Other instructions such as
            // branches, idle, return, waits and interrupts are ignored.
            //
            /* Get the next instruction */

            instr = *pSrc;
            update_offset = 0;

            /* Switch on the instruction opcode */

    #if 1 // 1 here for good RM sound
      {
          int i;            
          status = *(volatile *)(ppdev->LL_State.pRegs + PF_STATUS_3D);
          while (status & 0x200)
          {
            //i=10;  
            //while (i--) { /* don't read in tight loop*/ }    
              status = *(volatile *)(ppdev->LL_State.pRegs + PF_STATUS_3D);
          }
      }  
    #endif          
        
            USB_TIMEOUT_FIX(ppdev) 

            switch( instr >> 27 )
            {
                case 0x00:              /* Draw point opcode */
                case 0x01:              /* Draw line opcode */
                case 0x02:              /* Draw poly opcode */
                case 0x03:              /* Write register opcode */

                    /* Get the amount of data for this opcode */
                    
                    len = (instr & 0x3F) + 1;

                    /* Send data to the host data area */

                    while( len-- )
                        *pDest = *pSrc++;

                    break;

                case 0x05:              /* Write device opcode (Simulated) */

                    /* Step past the instruction opcode */

                    pSrc++;

                    /* Get the amount of data for this opcode */
                    
                    len = instr & 0x3F;

                    /* Switch on the module selected */

                    switch( (instr >> 21) & 0x1F )
                    {
                        case 0x00:              /* VGA register set */

                            /* Setup the device address and offset */

                            address = (int) (((BYTE *) ppdev->LL_State.pRegs) + 0x0000);
                            offset = (instr >> 6) & 0x0FF;

                            break;

                        case 0x01:              /* VGA frame buffer */

                            /* Setup the device address and offset */

                            address = 0xA0000;
                            offset = (instr >> 6) & 0x7FF;

                            break;

                        case 0x02:              /* Video port */

                            /* Setup the device address and offset */

                            address = (int) (((BYTE *) ppdev->LL_State.pRegs) + 0x0100);
                            offset = (instr >> 6) & 0x07F;

                            break;

                        case 0x03:              /* Local peripheral bus */

                            /* Setup the device address and offset */

                            address = (int) (((BYTE *) ppdev->LL_State.pRegs) + 0x0180);
                            offset = (instr >> 6) & 0x07F;

                            break;

                        case 0x04:              /* Miscellaneous */

                            /* Setup the device address and offset */

                            address = (int) (((BYTE *) ppdev->LL_State.pRegs) + 0x0200);
                            offset = (instr >> 6) & 0x0FF;

                            break;

                        case 0x05:              /* 2D engine registers */

                            /* Setup the device address and offset */

                            address = (int) (((BYTE *) ppdev->LL_State.pRegs) + 0x0400);
                            offset = (instr >> 6) & 0x3FF;

                            break;

                        case 0x06:              /* 2D host data */

                            /* Setup the device address and offset */

                            address = (int) (((BYTE *) ppdev->LL_State.pRegs) + 0x0800);
                            offset = (instr >> 6) & 0x7FF;

                            break;

                        case 0x07:              /* Frame buffer */

                            /* Setup the device address and offset */

                            address = (int) ppdev->LL_State.pFrame;
                            offset = (instr >> 6) & 0x7FF;

                            break;

                        case 0x08:              /* ROM memory */

                            /* Setup the device address and offset */

                            address = 0xC0000;
                            offset = (instr >> 6) & 0x7FF;

                            break;

                        case 0x09:              /* 3D engine registers */

                            /* Setup the device address and offset */

                            address = (int) (((BYTE *) ppdev->LL_State.pRegs) + 0x4000);
                            offset = (instr >> 6) & 0x1FF;

                            break;

                        case 0x0A:              /* 3D host XY registers */

                            /* Setup the device address and offset */

                            address = (int) (((BYTE *) ppdev->LL_State.pRegs) + 0x4200);
                            offset = (instr >> 6) & 0x0FF;
                            update_offset = 4;

                            break;

                        case 0x0B:              /* 3D host data */

                            /* Setup the device address and offset */

                            address = (int) (((BYTE *) ppdev->LL_State.pRegs) + 0x4800);
                            offset = (instr >> 6) & 0x3FF;

                            break;

                        default:                /* Unknown module */

                            /* Setup the device address and offset */
                            //printf("RL:WriteDev, unknown mod instr=%x\n",instr);
                            address = (int)NULL;
                            offset = (int)NULL;

                            break;
                    }
                    /* If this device supported, send the data */

                    if ( address )
                    {
                        /* Send data to the device */

                        while( len-- )
                        {
                            *(DWORD *)( address + offset ) = *pSrc++;
                            offset += update_offset;
                        }

                    }
                    else
                        pSrc += len;

                    break;

                case 0x0D:              /* Control opcode */

                    /* Step past the instruction opcode */

                    pSrc++;

                    /* Switch on the sub-opcode value */

                    switch( (instr >> 22) & 0x0F )
                    {
                        case 0:                 /* Idle sub-opcode */

                            /* Force exit from display list */

                            pSrc = pdwNext;

                            break;

                        case 5:                 /* Clear sub-opcode */

                            *pDest = instr;

                            break;
                    }
                    break;

                case 0x0E:              /* Wait opcode */
                    {
                    int wait_time_out;

                    /* Step past the instruction opcode */

                    pSrc++;

                    /* Get the wait event mask */

                    event = instr & 0x3FF;

                    if (event == EV_BUFFER_SWITCH)
                        wait_time_out=100000;
                    else                            
                        wait_time_out=5000000;


                    /* Switch on the wait opcode sub-type (AND/OR/NAND/NOR) */

                    switch( (instr >> 24) & 0x03 )
                    {
                        case 0:                 /* Wait OR sub-opcode */

                            /* Wait for requested event to happen */

                            do
                            {
                                status = (*(volatile *)(ppdev->LL_State.pRegs + PF_STATUS_3D) & 0x3FF) ^ 0x3E0;
                            } while((!(status & event)) && wait_time_out--);

                            break;

                        case 1:                 /* Wait NOR sub-code */

                            /* Wait for requested event to happen */

                            do
                            {
                                status = (*(volatile *)(ppdev->LL_State.pRegs + PF_STATUS_3D) & 0x3FF) ^ 0x01F;
                            } while((!(status & event)) && wait_time_out--);

                            break;

                        case 2:                 /* Wait AND sub-opcode */

                            /* Wait for requested events to happen */

                            do
                            {
                                status = (*(volatile *)(ppdev->LL_State.pRegs + PF_STATUS_3D) & 0x3FF) ^ 0x3E0;
                            } while(((status & event) != event) && wait_time_out--);

                            break;

                        case 3:                 /* Wait NAND sub-opcode */

                            /* Wait for requested events to happen */

                            do
                            {
                                status = (*(volatile *)(ppdev->LL_State.pRegs + PF_STATUS_3D) & 0x3FF) ^ 0x01F;
                            } while(((status & event) != event) && wait_time_out--);

                            break;
                    }
                  //if (wait_time_out <= 0) printf("WAIT TIMED OUT, instr = %x, ev=%x stat=%x\n",instr,event,status); 
                    }
                    break;

                default:                /* Unknown/unhandled opcode (Skip) */

                    //printf("RL:WriteDev, unknown opcode, instr=%x\n",instr);
                    /* Step past the instruction opcode */

                    pSrc++;

                    break;
            }
        }

    }

#if 0 // MCD_TEMP - no processor mode support yet
    else
    {

        // Check for valid address to put IDLE
        //
        if( ((int)pdwNext < (int)ppdev->LL_State.pDL->pdwLinPtr) || 
            ((int)pdwNext - (int)ppdev->LL_State.pDL->pdwLinPtr >= chunk_size - 16) )
        {
            //printf("DISPLAY LIST OVERRUN\n");

            goto proceed;    
        }

        // Stuff IDLE since this must be the end of current display list
        //
        *pdwNext = IDLE;


        // If Laguna is still busy with the previous d-list, poll
        // it until it is idle.
        //
        DEB("Entering 3D Engine Busy wait state...\n");
        LL_Wait();

        // We have to set the base address of the display list
        // This address is used as a base address when
        // fetching display list instructions
        //
        *(ppdev->LL_State.pRegs + PF_BASE_ADDR_3D) = ppdev->LL_State.pDL->dwPhyPtr;
        inp(0x80);
        inp(0x80);
        DEB2("New base: PF_BASE_ADDR_3D: %08X\n", *(ppdev->LL_State.pRegs + PF_BASE_ADDR_3D) );

        // Start the execution of the display list from the offset 0
        //
//      *(ppdev->LL_State.pRegs + PF_INST_3D) = BRANCH + DL_START_OFFSET;
        // No!  Temporary fix the prefetch bug and jump to the
        // top of the display list where the real branch(0)
        // instruction was stored during the display list initialization
        //
        DEB4("Issuing BRANCH %08X (->%08X ->%08X)\n", BRANCH + chunk_size - 16,
            *(DWORD *)((int)ppdev->LL_State.pDL->pdwLinPtr + chunk_size - 16),
            *(ppdev->LL_State.pDL->pdwLinPtr + 5) );

        if( *(DWORD *)((int)ppdev->LL_State.pDL->pdwLinPtr + chunk_size - 16) != BRANCH + DL_START_OFFSET )
        {
            //printf("BRANCH LOCATION CONTAINS INVALID DATA!\n");
            goto proceed;
        }

        *(ppdev->LL_State.pRegs + PF_INST_3D) = BRANCH + chunk_size - 16;
        inp(0x80);
        inp(0x80);
    }

proceed:

#endif // 0 - no processor mode support yet

#if 0
    // Set the active display list index to the next in an array
    //
    if( ++ppdev->LL_State.dwCdl >= NUM_DL )
        ppdev->LL_State.dwCdl = 0;


    // Reset the parametarization pointer to the beginning
    // of the next display list
    //
    ppdev->LL_State.pDL = &ppdev->LL_State.DL[ ppdev->LL_State.dwCdl ];
    ppdev->LL_State.pDL->pdwNext = ppdev->LL_State.pDL->pdwLinPtr + DL_START_OFFSET/4;
    ppdev->LL_State.pDL->pdwStartOutPtr = ppdev->LL_State.pDL->pdwNext;//only used in coproc mode

    return( ppdev->LL_State.pDL->pdwNext );
#else // 0
    // MCD_TEMP - ppdev->LL_State.pDL remains same always since only 1 DList

    ppdev->LL_State.pDL->pdwNext = ppdev->LL_State.pDL->pdwLinPtr + DL_START_OFFSET/4;
    ppdev->LL_State.pDL->pdwStartOutPtr = ppdev->LL_State.pDL->pdwNext;//only used in coproc mode
#endif // 0

}


#ifndef OPENGL_MCD

/*********************************************************************
*
*   void LL_Execute( LL_Batch * pBatch )
*
*       Builds the display list from the batch array and executes it.
*       This function is the main executing function.  If the batch
*       array cannot be completely fit into the available display
*       list, it will be processed in multiple pieces.
*
**********************************************************************/
void LL_Execute( LL_Batch * pBatch )
{
    register DWORD *pdwNext;

    // First we build the current display list
    //
    pdwNext = LL_State.pDL->pdwNext;

    do
    {
        // Build the current display list until IDLE instruction
        //
      //printf("bOp=%x\n",pBatch->bOp);
        pdwNext = (fnList[ pBatch->bOp ])( pdwNext, pBatch );

    } while( (pBatch++)->bOp != LL_IDLE );

    // Spin off the d-list that was just built and prepare to render 
    // to the next available d-list
    //
    (void)_RunLaguna( pdwNext );

}


/*********************************************************************
*
*   void LL_QueueOp( LL_Batch *pBatch )
*
*       Queues the operation.  This function supports programming the
*       l3d without using the arrays of batch cells and vertex cells.
*       Instead of building a batch command, all the parameters that
*       are to be set in a batch are passed in this function.
*
*   Where:
*
*       pBatch->bOp is the operation (eg. LL_LINE)
*       pBatch->wCount is the generic count
*       pBatch->dwFlags are the operation flags
*       pBatch->wBuf is the buffer/texture designator
*       pBatch->pVert is the pointer to a vertex array defining the operation
*
**********************************************************************/
void LL_QueueOp( LL_Batch *pBatch )
{
    // We continue building the current display list
    // If instruction was IDLE, spin-off the current d-list
    //
    if( pBatch->bOp == LL_IDLE )
        (void)_RunLaguna( LL_State.pDL->pdwNext );
    else
        LL_State.pDL->pdwNext = (fnList[ pBatch->bOp ])( LL_State.pDL->pdwNext, pBatch );
}


/*********************************************************************
*
*   void LL_SetRenderingMode( DWORD dwMode )
*
*       Sets the rendering mode: coprocessor indirect or processor
*       mode.  By default, library will use processor mode and build
*       display list to execute it.
*
*   Where:
*
*       dwMode is one of LL_PROCESSOR_MODE
*                        LL_COPROCESSOR_MODE
*
*
**********************************************************************/
void LL_SetRenderingMode( DWORD dwMode )
{
    LL_State.fIndirectMode = dwMode;

    DEB2("Rendering mode set to: %sPROCESSOR\n", dwMode?"CO":"" );

    LL_Wait();
}



/*********************************************************************
*
*   void DumpDisplayList( DWORD *pPtr, DWORD dwLen )
*
*       Dumps the content of the display list to the file.  This function
*       can be used by a software developer for debugging.
*
*       The display list disassembler (sldis.exe) may be used to 
*       disassemble the display list:
*
*           sldis -i9 < list00.pci > list00.out
*
*   Where:
*
*       pPtr is the starting address to dump
*       dwLen is the number of dwords to dump
*
**********************************************************************/
void DumpDisplayList( DWORD *pPtr, DWORD dwLen )
{
    static int count = 0;
    static char *sName = "List00.pci";
    FILE *fp;
    DWORD i;

#ifndef CGL

//    if( count == 5 )
//        count = 4;

    sprintf(&sName[4], "%02X.pci", count++ );
    printf("Temp Name: %s\nSize:%d dwords", sName, dwLen );

    if( (fp=fopen(sName, "w" ))==NULL )
        return;

    for( i=0; i<dwLen; i++ )
    {
        fprintf(fp, "%08X  %08X\n", pPtr, *pPtr );

        pPtr++;
    }

    fclose(fp);
    fflush(NULL);
#else // CGL's DLL - no file io allowed
    printf("Temp Name: %s\nSize:%d dwords\n", sName, dwLen );
    for( i=0; i<dwLen; i++ )
    {
        printf("%08X  %08X\n", pPtr, *pPtr );flushall();

        pPtr++;
    }
#endif

}


/*********************************************************************
*
*   void LL_Wait()
*
*       Waits for enging to become not busy.  Use this call when
*       switching from display list mode to direct programming
*       mode to ensure that the engine is idle.
*
*
**********************************************************************/
void LL_Wait()
{
    DWORD dwValue;
    int delay;
    volatile DWORD dwCount;

#define MAX_COUNT 1000000
#define DELAY_COUNT  100


    dwCount = 0;

    // Poll the 3D engine to finish rendering
    //
    do
    {
        dwValue = *(volatile *)(LL_State.pRegs + PF_STATUS_3D);

        DEB2("LL_Wait... PF_STATUS_3D: %08X\n", dwValue );
        DEB2("LL_Wait... PF_INST_3D: %08X\n", *(LL_State.pRegs + PF_INST_3D) );

        // wait before polling again to give PCI a breather, unless 
        // the last read shows everything idle
        for( delay = 0; 
            (delay<DELAY_COUNT) && (dwValue & LL_State.dwWaitMode); 
             delay++ ) { /*inp(0x80);*/ }

        if( dwCount++ == MAX_COUNT )
            _ShutDown("Laguna does not respond (PF_STATUS is %08X)", dwValue );

    } while(dwValue & LL_State.dwWaitMode );
}

void LL_Wait2()
{
    DWORD dwValue;
    int delay;
    volatile DWORD dwCount;

    dwCount = 0;

    // Poll the 3D engine to finish rendering
    //
    do
    {
        dwValue = *(volatile *)(LL_State.pRegs + PF_STATUS_3D);

        DEB2("LL_Wait... PF_STATUS_3D: %08X\n", dwValue );
        DEB2("LL_Wait... PF_INST_3D: %08X\n", *(LL_State.pRegs + PF_INST_3D) );

        // wait before polling again to give PCI a breather, unless 
        // the last read shows everything idle
        for( delay = 0; 
            (delay<DELAY_COUNT) && (dwValue & LL_State.dwWaitMode); 
             delay++ ) inp(0x80);

        if( dwCount++ == MAX_COUNT )
            _ShutDown("Laguna does not respond (PF_STATUS is %08X)", dwValue );

    } while(dwValue & LL_State.dwWaitMode );
}

void LL_Wait3()
{
    DWORD dwValue;
    int delay;
    volatile DWORD dwCount;

    dwCount = 0;

    // Poll the 3D engine to finish rendering
    //
    do
    {
        dwValue = *(volatile *)(LL_State.pRegs + PF_STATUS_3D);

        if (dwValue & LL_State.dwWaitMode) {printf("WARNING: 3rd wait busy, val=%08x\n",dwValue);}

        DEB2("LL_Wait... PF_STATUS_3D: %08X\n", dwValue );
        DEB2("LL_Wait... PF_INST_3D: %08X\n", *(LL_State.pRegs + PF_INST_3D) );

        // wait before polling again to give PCI a breather, unless 
        // the last read shows everything idle
        for( delay = 0; 
            (delay<DELAY_COUNT) && (dwValue & LL_State.dwWaitMode); 
             delay++ ) inp(0x80);

        if( dwCount++ == MAX_COUNT )
            _ShutDown("Laguna does not respond (PF_STATUS is %08X)", dwValue );

    } while(dwValue & LL_State.dwWaitMode );
}

#endif // ndef OPENGL_MCD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\enable.c ===
/******************************Module*Header*******************************\
 *
 * Module Name: enable.c
 *
 * This module contains the functions that enable and disable the
 * driver, the pdev, and the surface.
 *
 * Copyright (c) 1995,1996 Cirrus Logic, Inc.
 *
 * $Log:   X:/log/laguna/nt35/displays/cl546x/ENABLE.C  $
* 
*    Rev 1.46   Jan 20 1998 11:44:38   frido
* The fDataStreaming flag has changed its value from 1 into 0x80000000.
* 
*    Rev 1.45   Nov 04 1997 10:12:24   frido
* Added IOCtl call to Miniport to get the AGPDataStreaming value.
* 
*    Rev 1.44   Nov 03 1997 15:21:46   frido
* Added REQUIRE macros.
* 
*    Rev 1.43   16 Oct 1997 09:55:04   bennyn
* 
* Added bPrevModeDDOutOfVideoMem to DrvResetPDEV
* 
*    Rev 1.42   08 Aug 1997 17:24:00   FRIDO
* Added support for new memory manager.
* 
*    Rev 1.41   02 Jul 1997 15:56:00   noelv
* Added LgMatchDriverToChip() function.  Moved driver/chip match from bin
* from binitSurface to DrvEnablePdev()
* 
*    Rev 1.40   29 Apr 1997 16:28:40   noelv
* 
* Merged in new SWAT code.
* SWAT: 
* SWAT:    Rev 1.3   24 Apr 1997 11:37:28   frido
* SWAT: NT140b09 merge.
* SWAT: 
* SWAT:    Rev 1.2   18 Apr 1997 00:15:02   frido
* SWAT: NT140b07 merge.
* SWAT: 
* SWAT:    Rev 1.1   09 Apr 1997 17:32:34   frido
* SWAT: Called vAssertModeText in DrvAssertMode.
* 
*    Rev 1.39   09 Apr 1997 10:50:40   SueS
* Changed sw_test_flag to pointer_switch.
* 
*    Rev 1.38   09 Apr 1997 07:52:38   noelv
* Disabled the MCD code for NT 3.51
* 
*    Rev 1.37   08 Apr 1997 12:21:24   einkauf
* 
* new hooks for MCD when reset; add SYNC/IDLE for MCD/2D coordination
* 
*    Rev 1.36   21 Mar 1997 10:59:12   noelv
* 
* Combined the loggong flags into one ENABLE_LOGFILE flag.
* Removed PROFILE_DRIVER flag
* Added code to initialize QfreeData
* 
*    Rev 1.35   26 Feb 1997 13:19:42   noelv
* 
* Disable MCD code for NT 3.5x
* 
*    Rev 1.34   26 Feb 1997 09:22:10   noelv
* 
* Changed initial debugging message for 5465
* Added init code for MCD
* 
*    Rev 1.33   19 Feb 1997 13:15:32   noelv
* 
* Added translation table cache
* 
*    Rev 1.32   28 Jan 1997 16:18:42   bennyn
* Commented out "DrvEnableSurface failed bInitSurf" message
* 
*    Rev 1.31   06 Jan 1997 11:04:28   SueS
* Enabled DrvLineTo, since it's been fixed.
* 
*    Rev 1.30   18 Dec 1996 11:38:22   noelv
* 
* Unhooked DrvLineTo, 'cause it's broken.
* 
*    Rev 1.29   17 Dec 1996 16:53:24   SueS
* Added test for writing to log file based on cursor at (0,0).
* 
*    Rev 1.28   27 Nov 1996 11:32:44   noelv
* Disabled Magic Bitmap.  Yeah!!!
* 
*    Rev 1.27   26 Nov 1996 10:16:58   SueS
* Changed WriteLogFile parameters for buffering.
* 
*    Rev 1.26   13 Nov 1996 16:58:14   SueS
* Changed WriteFile calls to WriteLogFile.
* 
*    Rev 1.25   13 Nov 1996 08:17:18   noelv
* 
* Disabled test blt.
* 
*    Rev 1.24   07 Nov 1996 16:11:54   bennyn
* 
* Restore lost version (add drvresetPDEV support)
* 
*    Rev 1.23   31 Oct 1996 11:15:40   noelv
* 
* Split common buffer into two buffers.
* 
*    Rev 1.22   24 Oct 1996 14:40:38   noelv
* Demo bus master capabilities of 5464
* 
*    Rev 1.20   06 Sep 1996 08:55:02   noelv
* Hooked DrvStrokeAndFillPath and DrvStretchBlt when doinng analysis.
* 
*    Rev 1.19   20 Aug 1996 11:03:24   noelv
* Bugfix release from Frido 8-19-96
* 
*    Rev 1.3   18 Aug 1996 22:48:36   frido
* #lineto - Added DrvLineTo.
* 
*    Rev 1.2   15 Aug 1996 12:09:34   frido
* Fixed NT 3.51/4.0 in DrvEnablePDEV.
* 
*    Rev 1.1   15 Aug 1996 11:42:40   frido
* Added precompiled header.
* 
*    Rev 1.0   14 Aug 1996 17:16:20   frido
* Initial revision.
* 
*    Rev 1.18   07 Aug 1996 09:34:04   noelv
* 
* re-hooked textout
* 
*    Rev 1.17   25 Jul 1996 15:57:44   bennyn
* 
* Modified for DirectDraw
* 
*    Rev 1.16   12 Jul 1996 09:38:22   bennyn
* Added getdisplayduration call for DirectDraw
* 
*    Rev 1.15   11 Jul 1996 15:53:50   bennyn
* 
* Added DirectDraw support
* 
*    Rev 1.14   17 May 1996 12:55:34   bennyn
* Fixed the problem NT40 allocate 400x90 twice
* 
*    Rev 1.13   16 May 1996 14:54:22   noelv
* Added logging code.
* 
*    Rev 1.12   01 May 1996 12:06:44   bennyn
* 
* Fixed resolution change bug for NT 4.0
* 
*    Rev 1.11   01 May 1996 10:59:10   bennyn
* 
* Modified for NT4.0
* 
*    Rev 1.10   25 Apr 1996 22:39:50   noelv
* Cleaned up data logging.
 * 
 *    Rev 1.9   04 Apr 1996 13:20:14   noelv
 * Frido release 26
 * 
 *    Rev 1.13   02 Apr 1996 09:08:36   frido
 * Bellevue lg102b04 release.
 * 
 *    Rev 1.12   28 Mar 1996 20:02:18   frido
 * Added new comments.
 * 
 *    Rev 1.11   28 Mar 1996 20:01:00   frido
 * Fixed bouncing screeen when cursor is disabled.
 * 
 *    Rev 1.10   25 Mar 1996 12:05:34   frido
 * Changed #ifdef LOG_CALLS into #if LOG_CALLS.
 * Removed warning message.
 * 
 *    Rev 1.9   25 Mar 1996 11:52:46   frido
 * Bellevue 102B03.
 * 
 *    Rev 1.5   12 Mar 1996 15:45:28   noelv
 * Added support for data logging and stroke and fill.
 * 
 *    Rev 1.8   12 Mar 1996 16:50:14   frido
 * Added stroke and fill stuff.
 * 
 *    Rev 1.7   29 Feb 1996 20:23:24   frido
 * Added bEnable flag in PPDEV.
 * 
 *    Rev 1.6   29 Feb 1996 19:25:08   frido
 * Turned HOOK_TEXTOUT flags back on for 16-bpp modes and higher.
 * 
 *    Rev 1.5   27 Feb 1996 16:38:10   frido
 * Added device bitmap store/restore.
 * 
 *    Rev 1.4   24 Feb 1996 01:24:18   frido
 * Added device bitmaps.
 * 
 *    Rev 1.3   03 Feb 1996 13:40:24   frido
 * Use the compile switch "-Dfrido=0" to disable my extensions.
 * 
 *    Rev 1.2   23 Jan 1996 15:14:26   frido
 * Added call to DrvDestroyFont.
 *
\**************************************************************************/

#include "precomp.h"
#include "SWAT.h"
#include "CLIOCtl.h"

// The driver function table with all function index/address pairs

static DRVFN gadrvfn[] =
{
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode         },
    {   INDEX_DrvSetPalette,            (PFN) DrvSetPalette         },
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor        },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes           },

//
//  Laguna Functions:
//
   {   INDEX_DrvMovePointer,           (PFN) DrvMovePointer        },
   {   INDEX_DrvSetPointerShape,       (PFN) DrvSetPointerShape    },
   {   INDEX_DrvSynchronize,           (PFN) DrvSynchronize        },
   {   INDEX_DrvStretchBlt,            (PFN) DrvStretchBlt         },
   {   INDEX_DrvSaveScreenBits,        (PFN) DrvSaveScreenBits     },
   {   INDEX_DrvRealizeBrush,          (PFN) DrvRealizeBrush       },
   {   INDEX_DrvPaint,                 (PFN) DrvPaint              },
   {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt             },
   {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits           },
   {   INDEX_DrvTextOut,               (PFN) DrvTextOut            },
   {   INDEX_DrvDestroyFont,           (PFN) DrvDestroyFont	       },
   {   INDEX_DrvCreateDeviceBitmap,    (PFN) DrvCreateDeviceBitmap },
   {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DrvDeleteDeviceBitmap },
   {   INDEX_DrvFillPath,              (PFN) DrvFillPath           },
   {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath         },
#ifdef WINNT_VER40
   {   INDEX_DrvGetDirectDrawInfo,     (PFN) DrvGetDirectDrawInfo  },
   {   INDEX_DrvEnableDirectDraw,      (PFN) DrvEnableDirectDraw   },
   {   INDEX_DrvDisableDirectDraw,     (PFN) DrvDisableDirectDraw  },
   {   INDEX_DrvLineTo,                (PFN) DrvLineTo             },
   {   INDEX_DrvResetPDEV,             (PFN) DrvResetPDEV          },
   #define LGHOOK_LINETO HOOK_LINETO
#else
   #define LGHOOK_LINETO 0
#endif


//
// We don't accelerate DrvStrokeAndFillPath or DrvStrethcBlt.  
// But we do want to hook them if we're doing driver analysis.
//
#if NULL_STROKEFILL 
   {   INDEX_DrvStrokeAndFillPath,     (PFN) DrvStrokeAndFillPath  },
   #define LGHOOK_STROKEANDFILLPATH HOOK_STROKEANDFILLPATH
#else
   #define LGHOOK_STROKEANDFILLPATH 0
#endif

#if NULL_STRETCH 
   {   INDEX_DrvStretchBlt,            (PFN) DrvStretchBlt         },
   #define LGHOOK_STRETCHBLT HOOK_STRETCHBLT
#else
   #define LGHOOK_STRETCHBLT 0
#endif    
};


//
// Define the functions you want to hook for 8/16/24/32 pel formats
// We do not need to set HOOK_SYNCHRONIZEACCESS because we only support a
// single surface at the moment.  GDI only permits one thread to draw to
// a surface at a time.
// When we impliment device bitmaps, we may need to set this.
//
#define HOOKS_BMF8BPP (HOOK_BITBLT | HOOK_PAINT | HOOK_COPYBITS | HOOK_TEXTOUT \
		      | HOOK_STROKEPATH | LGHOOK_LINETO | HOOK_FILLPATH \
		      | LGHOOK_STROKEANDFILLPATH | LGHOOK_STRETCHBLT \
		      | HOOK_SYNCHRONIZE | HOOK_SYNCHRONIZEACCESS )

#define HOOKS_BMF16BPP  HOOKS_BMF8BPP
#define HOOKS_BMF24BPP  HOOKS_BMF8BPP
#define HOOKS_BMF32BPP  HOOKS_BMF8BPP


#if DRIVER_5465
    #define _DISP_ "CL5465.DLL"
#else
    #define _DISP_ "CL546x.DLL"
#endif

/******************************Public*Routine******************************\
* DrvEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
\**************************************************************************/

BOOL DrvEnableDriver(
ULONG iEngineVersion,
ULONG cj,
PDRVENABLEDATA pded)
{
// Engine Version is passed down so future drivers can support previous
// engine versions.  A next generation driver can support both the old
// and new engine conventions if told what version of engine it is
// working with.  For the first version the driver does nothing with it.

    iEngineVersion;

// Fill in as much as we can.

#ifdef WINNT_VER40
    #if DRIVER_5465
        DISPDBG((1, " ==> Cirrus Logic 5465 DISPLAY DRIVER for NT 4.0.\n"));
    #else // if DRIVER_5465
        DISPDBG((1, " ==> Cirrus Logic 546x DISPLAY DRIVER for NT 4.0.\n"));
    #endif // if DRIVER_5465
#else
    #if DRIVER_5465
        DISPDBG((1, " ==> Cirrus Logic 5465 DISPLAY DRIVER for NT 3.5x.\n"));
    #else // if DRIVER_5465
        DISPDBG((1, " ==> Cirrus Logic 546x DISPLAY DRIVER for NT 3.5x.\n"));
    #endif // if DRIVER_5465
#endif

    if (cj >= sizeof(DRVENABLEDATA))
	pded->pdrvfn = gadrvfn;

    if (cj >= (sizeof(ULONG) * 2))
	pded->c = sizeof(gadrvfn) / sizeof(DRVFN);

// DDI version this driver was targeted for is passed back to engine.
// Future graphic's engine may break calls down to old driver format.

    if (cj >= sizeof(ULONG))
	pded->iDriverVersion = DDI_DRIVER_VERSION_NT4;

    return(TRUE);
}

/******************************Public*Routine******************************\
* DrvDisableDriver
*
* Tells the driver it is being disabled. Release any resources allocated in
* DrvEnableDriver.
*
\**************************************************************************/

VOID DrvDisableDriver(VOID)
{
    DISPDBG((1, _DISP_ " DrvDisableDriver\n"));
    return;
}

/******************************Public*Routine******************************\
* DrvEnablePDEV
*
* DDI function, Enables the Physical Device.
*
* Return Value: device handle to pdev.
*
\**************************************************************************/

DHPDEV DrvEnablePDEV(
DEVMODEW   *pDevmode,       // Pointer to DEVMODE
PWSTR       pwszLogAddress, // Logical address
ULONG       cPatterns,      // number of patterns
HSURF      *ahsurfPatterns, // return standard patterns
ULONG       cjGdiInfo,      // Length of memory pointed to by pGdiInfo
ULONG      *pGdiInfo,       // Pointer to GdiInfo structure
ULONG       cjDevInfo,      // Length of following PDEVINFO structure
DEVINFO    *pDevInfo,       // physical device information structure
#ifdef WINNT_VER40
HDEV		hdev,
#else
PWSTR       pwszDataFile,   // DataFile - not used
#endif
PWSTR       pwszDeviceName, // DeviceName - not used
HANDLE      hDriver)        // Handle to base driver
{
    GDIINFO GdiInfo;
    DEVINFO DevInfo;
    PPDEV   ppdev = (PPDEV) NULL;

    DISPDBG((1, _DISP_ " DrvEnablePDEV: Entry.\n"));

    // Allocate a physical device structure.
    #ifdef WINNT_VER40
        ppdev = (PPDEV) MEM_ALLOC(FL_ZERO_MEMORY, sizeof(PDEV), ALLOC_TAG);
    #else
        ppdev = (PPDEV) MEM_ALLOC(LMEM_FIXED | LMEM_ZEROINIT, sizeof(PDEV));
    #endif

    if (ppdev == (PPDEV) NULL)
    {
        RIP(_DISP_ " DrvEnablePDEV failed MEM_ALLOC\n");
        return((DHPDEV) 0);
    }

    // Save the screen handle in the PDEV.
    ppdev->hDriver = hDriver;
    ppdev->pjScreen = 0;

   	//
    // Verify the driver matches the chip.
    //
    if (!LgMatchDriverToChip(ppdev))
    {
        #if DRIVER_5465
            DISPDBG((1," Chip doesn't match CL5465 driver.  Failing.\n"));
        #else
            DISPDBG((1," Chip doesn't match CL546x driver.  Failing.\n"));
        #endif
        goto error_free;
    }

    // Init MCD.
    #ifndef WINNT_VER35
        ppdev->hMCD = NULL;
        ppdev->NumMCDContexts = 0;
    #endif

    // Initialize the offscreen manager initial flag to FALSE
    ppdev->OFM_init = FALSE;

    // Initialize the color translation caches to NULL
    ppdev->XlateCache = NULL;

    // Initialize the pofmMagic to NULL
    #if WINBENCH96
        ppdev->pofmMagic = NULL;
    #endif

	#if DATASTREAMING
	{
		ULONG	ulReturn;
		BOOL	fDataStreaming = FALSE;

		if (! DEVICE_IO_CTRL(ppdev->hDriver,
							 IOCTL_GET_AGPDATASTREAMING,
							 NULL,
							 0,
							 (PVOID) &fDataStreaming,
							 sizeof(fDataStreaming),
							 &ulReturn,
							 NULL) )
		{
                        DISPDBG( (1, _DISP_ " DrvEnablePDEV: failed to get "
					  "AGPDataStreaming flag\n") );
			fDataStreaming = FALSE;	// default to OFF
		}
		ppdev->dwDataStreaming = fDataStreaming ? 0x80000000 : 0;
	}
	#endif

    // Get the current screen mode information.  Set up device caps and devinfo.
    if (!bInitPDEV(ppdev, pDevmode, &GdiInfo, &DevInfo))
    {
        DISPDBG((1,_DISP_ " DrvEnablePDEV: bInitPDEV failed\n"));
        goto error_free;
    }

    // Initialize palette information.
    if (!bInitPaletteInfo(ppdev, &DevInfo))
    {
        RIP(_DISP_ " DrvEnablePDEV: failed bInitPalette\n");
        goto error_free;
    }

    // Initialize device standard patterns.
    if (!bInitPatterns(ppdev, min(cPatterns, HS_DDI_MAX)))
    {
        RIP(_DISP_ " DrvEnablePDEV: failed bInitPatterns\n");
        vDisablePatterns(ppdev);
        vDisablePalette(ppdev);
        goto error_free;
    }

    // Copy the devinfo into the engine buffer.
    memcpy(pDevInfo, &DevInfo, min(sizeof(DEVINFO), cjDevInfo));

    // Set the ahsurfPatterns array to handles each of the standard
    // patterns that were just created.
    memcpy((PVOID)ahsurfPatterns, ppdev->ahbmPat, ppdev->cPatterns*sizeof(HBITMAP));

    // Set the pdevCaps with GdiInfo we have prepared to the list of caps for this
    // pdev.
    memcpy(pGdiInfo, &GdiInfo, min(cjGdiInfo, sizeof(GDIINFO)));

    #if ENABLE_LOG_FILE
    {
        char buf[256];
        int i1;

        #if ENABLE_LOG_SWITCH
            if (pointer_switch == 1)
        #endif
        {
           DISPDBG((1, _DISP_ " Creating log file.\n"));
           CreateLogFile(ppdev->hDriver, &ppdev->TxtBuffIndex);
           ppdev->pmfile = ppdev->hDriver;   // handle to the miniport

           if (ppdev->pmfile == (HANDLE)-1)  // INVALID_HANDLE_VALUE
 	       RIP( _DISP_ " Couldn't create log file!\n");

           i1 = sprintf(buf, _DISP_ " Log file opened.\r\n");
           WriteLogFile(ppdev->pmfile, buf, i1, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
        }

    }
    #endif
    #if LOG_QFREE
    {
        int i;
        for (i=0; i<32; ++i)
            QfreeData[i] = 0;
    }
    #endif

    DISPDBG((1, _DISP_ " DrvEnablePDEV: Succeeded.\n"));
    return((DHPDEV) ppdev);

    // Error case for failure.
error_free:
    MEMORY_FREE(ppdev);
    DISPDBG((1, _DISP_ " DrvEnablePDEV: Failed.\n"));
    return((DHPDEV) 0);
}

/******************************Public*Routine******************************\
* DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV  hdev)
{
    DISPDBG((1, _DISP_ " DrvCompletePDEV\n"));
    ((PPDEV) dhpdev)->hdevEng = hdev;
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
\**************************************************************************/

VOID DrvDisablePDEV(
DHPDEV dhpdev)
{
    PPDEV ppdev;

    DISPDBG((1, _DISP_ " DrvDisablePDEV\n"));

    ppdev = (PPDEV) dhpdev;

    vDisablePalette((PPDEV) dhpdev);
    vDisablePatterns((PPDEV) dhpdev);

    MEMORY_FREE(dhpdev);
}

/******************************Public*Routine******************************\
* DrvEnableSurface
*
* Enable the surface for the device.  Hook the calls this driver supports.
*
* Return: Handle to the surface if successful, 0 for failure.
*
\**************************************************************************/

HSURF DrvEnableSurface(
DHPDEV dhpdev)
{
    PPDEV ppdev;
    HSURF hsurf;
    SIZEL sizl;
    ULONG ulBitmapType;
    FLONG flHooks;

    DISPDBG((1, _DISP_ " DrvEnableSurface Entry.\n"));

    // Create engine bitmap around frame buffer.

    ppdev = (PPDEV) dhpdev;


    if (!bInitSURF(ppdev, TRUE))
    {
        // Comments out this message because new two drivers model will break
        // here every time from power-up.
        //	RIP(_DISP_ " DrvEnableSurface failed bInitSURF\n");
        goto ReturnFailure;
    }

#ifdef WINNT_VER40
	ppdev->pvTmpBuffer = MEM_ALLOC(0, TMP_BUFFER_SIZE, ALLOC_TAG);
#else
	ppdev->pvTmpBuffer = VirtualAlloc(NULL, TMP_BUFFER_SIZE, MEM_RESERVE |
									  MEM_COMMIT, PAGE_READWRITE);
#endif

	if (ppdev->pvTmpBuffer == NULL)
	{
                DISPDBG((1, _DISP_ " DrvEnableSurface - Failed VirtualAlloc"));
		goto ReturnFailure;
	}

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    if (ppdev->ulBitCount == 8)
    {
	if (!bInit256ColorPalette(ppdev)) {
	    RIP(_DISP_ " DrvEnableSurface failed to init the 8bpp palette\n");
		goto ReturnFailure;
	}
	ulBitmapType = BMF_8BPP;
	flHooks = HOOKS_BMF8BPP;
    }
    else if (ppdev->ulBitCount == 16)
    {
	ulBitmapType = BMF_16BPP;
	flHooks = HOOKS_BMF16BPP;
    }
    else if (ppdev->ulBitCount == 24)
    {
	ulBitmapType = BMF_24BPP;
	flHooks = HOOKS_BMF24BPP;
    }
    else
    {
	ulBitmapType = BMF_32BPP;
	flHooks = HOOKS_BMF32BPP;
    }

    hsurf = (HSURF) EngCreateBitmap(sizl,
				    ppdev->lDeltaScreen,
				    ulBitmapType,
				    (ppdev->lDeltaScreen > 0) ? BMF_TOPDOWN : 0,
					(PVOID) (ppdev->pjScreen));

    if (hsurf == (HSURF) 0)
    {
	RIP(_DISP_ " DrvEnableSurface failed EngCreateBitmap\n");
		goto ReturnFailure;
    }

	ppdev->bEnable = TRUE;

    if (!EngAssociateSurface(hsurf, ppdev->hdevEng, flHooks))
    {
	RIP(_DISP_ " DrvEnableSurface failed EngAssociateSurface\n");
	EngDeleteSurface(hsurf);
		goto ReturnFailure;
    }

    ppdev->hsurfEng = hsurf;
    ppdev->iBitmapFormat = ulBitmapType;

    if (!bEnableText(ppdev))
	goto ReturnFailure;

#ifdef WINNT_VER40
   // Accurately measure the refresh rate for DirectDraw use
   vGetDisplayDuration(&ppdev->flipRecord);
#endif


    //
    // Demo HostToScreen BLT
    //
    #if BUS_MASTER
    if (ppdev->BufLength)
    {
        unsigned long i;
        unsigned long temp;
        DWORD *bufD = (DWORD *)ppdev->Buf1VirtAddr;


        //
        // init the buffer.
        //
        for (i=0; i<ppdev->BufLength/4; ++i)
            bufD[i] = 0x87654321;

        DISPDBG((1, _DISP_ " bInitSurf: \n\n **** TestBLT **** \n"));

        // Enable the HOST XY unit.
        LL32(grHXY_HOST_CRTL_3D, 1);

        // Write host address.
        LL32(grHXY_BASE1_ADDRESS_PTR_3D, ppdev->Buf1PhysAddr);

        // Offset into host buffer is 0
        LL32(grHXY_BASE1_OFFSET0_3D, 0);
        LL32(grHXY_BASE1_OFFSET1_3D, 0);

        // Setup 2D engine.
		REQUIRE(8);
        LL16 (grBLTDEF, 0x1020);  // OP1 is host, RES is screen 
        LL16 (grDRAWDEF, 0xCC);   // SRCCPY

        // Source and destination XY address.
        LL16 (grOP1_opRDRAM.pt.X, 0); // source phase
        LL16 (grOP0_opRDRAM.pt.X, 0); // Destination x = 0;
        LL16 (grOP0_opRDRAM.pt.Y, 0); // Destination y = 0;

        // Size of destination rectangle.
        // This starts the 2D engine.
        LL16 (grMBLTEXT_EX.pt.X, 128);  // Width
        LL16 (grBLTEXT_EX.pt.Y, 16);    // Height

        // Write the length of the host data (in bytes)
        // This starts the Host XY unit.
        LL32(grHXY_BASE1_LENGTH_3D, ppdev->BufLength);


        //
        // Wait until HOST XY unit goes idle.
        //
        do {
            temp = LLDR_SZ (grPF_STATUS_3D);
        } while (temp & 0x80);

        DISPDBG((1, _DISP_ "        PF_STATUS: 0x%08X\n", temp));

    }
    #endif

    DISPDBG((1, _DISP_ " DrvEnableSurface Exit.\n"));
    return(hsurf);

ReturnFailure:
    DrvDisableSurface((DHPDEV) ppdev);

    DISPDBG((1, _DISP_ " Failed DrvEnableSurface"));

    return(0);
}

/******************************Public*Routine******************************\
* DrvDisableSurface
*
* Free resources allocated by DrvEnableSurface.  Release the surface.
*
\**************************************************************************/

VOID DrvDisableSurface(
DHPDEV dhpdev)
{
    PPDEV ppdev;

    DISPDBG((1, _DISP_ " DrvDisableSurface Entry.\n"));

    ppdev = (PPDEV) dhpdev;

    ENSURE_3D_IDLE(ppdev);  

#ifdef WINNT_VER40
	MEMORY_FREE(((PPDEV) dhpdev)->pvTmpBuffer);
#else
	VirtualFree(((PPDEV) dhpdev)->pvTmpBuffer, 0, MEM_RELEASE);
#endif

    // Close the offscreen manager
    CloseOffScnMem((PPDEV) dhpdev);

#ifdef WINNT_VER40
   if (ppdev->CShsem != NULL)
   	EngDeleteSemaphore(ppdev->CShsem);
#else
    DeleteCriticalSection(&ppdev->PtrCritSec);
#endif

    EngDeleteSurface(((PPDEV) dhpdev)->hsurfEng);
    vDisableSURF((PPDEV) dhpdev);
    ((PPDEV) dhpdev)->hsurfEng = (HSURF) 0;
}

/******************************Public*Routine******************************\
* DrvAssertMode
*
* This asks the device to reset itself to the mode of the pdev passed in.
*
\**************************************************************************/

#ifdef WINNT_VER40
BOOL APIENTRY DrvAssertMode(
#else
VOID DrvAssertMode(
#endif

DHPDEV dhpdev,
BOOL bEnable)
{
    PPDEV   ppdev = (PPDEV) dhpdev;
    ULONG   ulReturn;

    DISPDBG((1, _DISP_ " DrvAssertMode, en=%d\n",bEnable));

    ENSURE_3D_IDLE(ppdev);

    #ifndef WINNT_VER35
    if (ppdev->hMCD)
    {
        ppdev->pAssertModeMCD(ppdev,bEnable);
    }
    #endif

	ppdev->bEnable = bEnable;
    if (bEnable)
    {
    // The screen must be reenabled, reinitialize the device to clean state.

	    bInitSURF(ppdev, FALSE);

		#if SWAT3
		// Enable font cache.
		vAssertModeText(ppdev, TRUE);
		#endif
    }
    else
    {
	POFMHDL pofm, pofmNext;

	#if (HW_PRESET_BUG)
	    //
	    // Disable the HW cursor for real, since we are leaving graphics mode.
	    //
	    ULONG ultmp = LLDR_SZ (grCursor_Control);
	    ultmp &= 0xFFFE;
	    LL16 (grCursor_Control, ultmp);
	#endif

	#if 1 // SWAT3 - font cache removal is now in vAssertMoveText.
	// Disable font cache.
	vAssertModeText(ppdev, FALSE);
	#endif

	#if MEMMGR
	{
		// Hostify all device bitmaps.
		extern void HostifyAllBitmaps(PPDEV ppdev);
		HostifyAllBitmaps(ppdev);
	}
	#else
	// We have to move all off-screen device bitmaps to memory.
	for (pofm = ppdev->OFM_UsedQ; pofm; pofm = pofmNext)
	{
	    pofmNext = pofm->nexthdl;

	    if ( (pofm->pdsurf) && (pofm->pdsurf->pofm) )
	    {
	    	if (!bCreateDibFromScreen(ppdev, pofm->pdsurf))
	    	{
	    	    RIP("Error moving off-screen bitmap to DIB");
	    	    break;
	    	}
	    }
	}
	#endif
        // We must give up the display.
        // Call the kernel driver to reset the device to a known state.

	if (!DEVICE_IO_CTRL(ppdev->hDriver,
			     IOCTL_VIDEO_RESET_DEVICE,
			     NULL,
			     0,
			     NULL,
			     0,
			     &ulReturn,
			     NULL))
	{
	    RIP(_DISP_ " DrvAssertMode failed IOCTL");
	}
    }

#ifdef WINNT_VER40
    return TRUE;
#else
    return;
#endif
}

/******************************Public*Routine******************************\
* DrvGetModes
*
* Returns the list of available modes for the device.
*
\**************************************************************************/

ULONG DrvGetModes(
HANDLE hDriver,
ULONG cjSize,
DEVMODEW *pdm)

{

    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation, pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;

    DISPDBG((1, _DISP_ " DrvGetModes: Entry.\n"));

    cModes = getAvailableModes(hDriver,
			       (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
			       &cbModeSize);

    if (cModes == 0)
    {
            DISPDBG((1, _DISP_ " DrvGetModes failed to get mode information"));
        return 0;
    }

    if (pdm == NULL)
    {
	cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
	//
	// Now copy the information for the supported modes back into the output
	// buffer
	//

	cbOutputSize = 0;

	pVideoTemp = pVideoModeInformation;

	do
	{
	    if (pVideoTemp->Length != 0)
	    {
		if (cOutputModes == 0)
		{
		    break;
		}

		//
		// Zero the entire structure to start off with.
		//

		memset(pdm, 0, sizeof(DEVMODEW));

		//
		// Set the name of the device to the name of the DLL.
		//

		memcpy(&(pdm->dmDeviceName), L"cl546x", sizeof(L"cl546x"));

		pdm->dmSpecVersion = DM_SPECVERSION;
		pdm->dmDriverVersion = DM_SPECVERSION;

		//
		// We currently do not support Extra information in the driver
		//

		pdm->dmDriverExtra = DRIVER_EXTRA_SIZE;

		pdm->dmSize = sizeof(DEVMODEW);
		pdm->dmBitsPerPel = pVideoTemp->NumberOfPlanes *
				    pVideoTemp->BitsPerPlane;
		pdm->dmPelsWidth = pVideoTemp->VisScreenWidth;
		pdm->dmPelsHeight = pVideoTemp->VisScreenHeight;
		pdm->dmDisplayFrequency = pVideoTemp->Frequency;

#ifdef WINNT_VER40
	   pdm->dmDisplayFlags = 0;
	   pdm->dmFields = DM_BITSPERPEL       |
                      DM_PELSWIDTH        |
                      DM_PELSHEIGHT       |
                      DM_DISPLAYFREQUENCY |
                      DM_DISPLAYFLAGS     ;
#else
		if (pVideoTemp->AttributeFlags & VIDEO_MODE_INTERLACED)
		{
		    pdm->dmDisplayFlags |= DM_INTERLACED;
		}
#endif

		//
		// Go to the next DEVMODE entry in the buffer.
		//

		cOutputModes--;

		pdm = (LPDEVMODEW) ( ((ULONG)pdm) + sizeof(DEVMODEW) +
						   DRIVER_EXTRA_SIZE);

		cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

	    }

	    pVideoTemp = (PVIDEO_MODE_INFORMATION)
		(((PUCHAR)pVideoTemp) + cbModeSize);

	} while (--cModes);
    }

    MEMORY_FREE(pVideoModeInformation);

    DISPDBG((1, _DISP_ " DrvGetModes: Exit.\n"));
    return cbOutputSize;

}


/**************************************************************************\
* DrvResetPDEV
*
\**************************************************************************/

BOOL DrvResetPDEV(DHPDEV dhpdevOld, DHPDEV dhpdevNew)
{
    PPDEV ppdevOld, ppdevNew;

    DISPDBG((1, _DISP_ " DrvResetPDEV:\n"));

    ppdevOld = (PPDEV) dhpdevOld;
    ppdevNew = (PPDEV) dhpdevNew;

#ifndef WINNT_VER35

    ENSURE_3D_IDLE(ppdevOld);

    ppdevNew->iUniqueness = ppdevOld->iUniqueness + 1;
    ppdevNew->pAllocOffScnMem = AllocOffScnMem;
    ppdevNew->pFreeOffScnMem = FreeOffScnMem;

    ppdevNew->bPrevModeDDOutOfVideoMem = ppdevOld->bPrevModeDDOutOfVideoMem;

#endif // ndef WINNT_VER35

    return (TRUE);
};


/* ===========================================================================
*	LgMatchDriverToChip()                                                 
*
*	This driver code base compiles into several different DLLs, based on
*	what C Preprocessor symbols are defined at compile time.  This allows us
*	to build several different chip specific drivers from a single code base.
*
*	This function checks the Laguna chip ID and returns TRUE if the chip is
*	one supported by this DLL.
*
* ========================================================================== */
BOOL LgMatchDriverToChip(
    PPDEV ppdev
)
{
 	DWORD returnedDataLength;
	WORD DeviceID;
	VIDEO_PUBLIC_ACCESS_RANGES   VideoAccessRanges[2];
	BYTE *pLgREGS_PCI_ID;

	// Get a pointer to the HW registers.
	if (!DEVICE_IO_CTRL(ppdev->hDriver,
					 IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES,
					 NULL,                      // input buffer
					 0,
					 (PVOID) VideoAccessRanges, // output buffer
					 sizeof (VideoAccessRanges),
					 &returnedDataLength,
					 NULL))
	{
		RIP(_DISP_  "LgMatchDriverToChip - QUERY_PUBLIC_ACCESS_RANGES ioctl failed!\n");
		return (FALSE);
	}
	pLgREGS_PCI_ID = ((BYTE *)VideoAccessRanges[0].VirtualAddress) + 0x302;

    //Get the chip id.
    DeviceID =  *(WORD *)pLgREGS_PCI_ID;
        DISPDBG((1,_DISP_ " MatchDriverToChip: Chip ID is 0x%08X.\n",DeviceID));

	// Does this driver instance support this chip?
    #if DRIVER_5465
        // This is the 5465 driver.  Fail if not a 5465 or later.
        if (DeviceID < CL_GD5465)
        {
            return FALSE;
        }
    #else
        // This is the 546x driver.  Fail if a 5465 or later.
        if (DeviceID >= CL_GD5465)
        {
            return FALSE;
        }
	#endif

	return TRUE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\hdtable.c ===
/*
* HDTABLE.C
* This table helps us get around the Hostdata bug in the Laguna chip.
*
* Copyright (c) 1995 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/HDTABLE.C  $
* 
*    Rev 1.4   Dec 17 1997 11:03:14   frido
* Added logging information.
* Fixed "last line incomplete" error.
*
*/

#include "precomp.h"

#if !DRIVER_5465
/* the ExtraDwodTable is indexed by as follows (verilog notation)
*       index[15:00] =    bltext [10:0] dst_phase [2:0] src_phase [1:0] 
*
*       index[15:05] =    bltext [10:00]
*       index[04:02] = dst_phase [02:00]
*       index[01:00] = src_phase [01:00]
*/

unsigned char ExtraDwordTable[0x10000] = 
{
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,
0,0,0,0,0,0,0,0,2,2,0,1,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,
0,0,0,0,2,0,1,1,2,0,0,1,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,2,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\escape.c ===
/****************************************************************************
*****************************************************************************
*
*                ******************************************
*                * Copyright (c) 1995, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:	Laguna I (CL-GD5462) - 
*
* FILE:		escape.c
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This module Handles escapes
*
* MODULES:
*           DrvEscape()
*
* REVISION HISTORY:
*   11/16/95     Benny Ng      Initial version
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/ESCAPE.C  $
* 
*    Rev 1.14   Dec 10 1997 13:32:12   frido
* Merged from 1.62 branch.
* 
*    Rev 1.13.1.0   Nov 10 1997 11:34:08   phyang
* Added 5 escape functions for utilities to update registry values.
* 
*    Rev 1.13   10 Sep 1997 10:40:36   noelv
* Modified QUERYESCSUPPORT to only return TRUE for escapes we actually suppor
* It was returning TRUE all the time.
* 
*    Rev 1.12   20 Aug 1997 15:49:42   bennyn
* 
* Added IS_CIRRUS_DRIVER escape support
*
****************************************************************************
****************************************************************************/

/*----------------------------- INCLUDES ----------------------------------*/
#include "precomp.h"
#include "clioctl.h"

/*----------------------------- DEFINES -----------------------------------*/
//#define DBGBRK

#define ESC_DBG_LVL 1


#if 0   // MCD not working good
#if ( DRIVER_5465 && !defined(WINNT_VER35) )
    #define CLMCD_ESCAPE_SUPPORTED
#endif
#endif// 0 MCD not working good



#ifdef CLMCD_ESCAPE_SUPPORTED
//    #define CLMCDDLLNAME	    "CLMCD.DLL"
//    #define CLMCDINITFUNCNAME   "CLMCDInit"

MCDRVGETENTRYPOINTSFUNC CLMCDInit(PPDEV ppdev);

#endif // def CLMCD_ESCAPE_SUPPORTED


/*--------------------- STATIC FUNCTION PROTOTYPES ------------------------*/

/*--------------------------- ENUMERATIONS --------------------------------*/

/*----------------------------- TYPEDEFS ----------------------------------*/

#ifdef CLMCD_ESCAPE_SUPPORTED

typedef BOOL (*MCDRVGETENTRYPOINTSFUNC)(MCDSURFACE *pMCDSurface, MCDDRIVER *pMCDDriver);
typedef POFMHDL (*ALLOCOFFSCNMEMFUNC)(PPDEV ppdev, PSIZEL surf, ULONG alignflag, POFM_CALLBACK pcallback);
typedef BOOL    (*FREEOFFSCNMEMFUNC)(PPDEV ppdev, OFMHDL *hdl);
//typedef MCDRVGETENTRYPOINTSFUNC (*CLMCDINITFUNC)(PPDEV);

#endif // def CLMCD_ESCAPE_SUPPORTED


/*-------------------------- STATIC VARIABLES -----------------------------*/


/****************************************************************************
* FUNCTION NAME: DrvEscape()
*
* DESCRIPTION:   Driver escape entry point.
*
* REVISION HISTORY:
*   11/16/95     Benny Ng      Initial version
****************************************************************************/
ULONG APIENTRY DrvEscape(SURFOBJ *pso,
                         ULONG   iEsc,
                         ULONG   cjIn,
                         PVOID   pvIn,
                         ULONG   cjOut,
                         PVOID   pvOut)

{
  PPDEV ppdev = (PPDEV) pso->dhpdev;
  DWORD returnedDataLength = 0;
  ULONG retval = FALSE;

  PMMREG_ACCESS pInMRAccess;
  PMMREG_ACCESS pMRAccess;
  BYTE  *pbAddr;
  WORD  *pwAddr;
  DWORD *pdwAddr;

  DISPDBG((ESC_DBG_LVL, "DrvEscape-Entry.\n"));   

  switch (iEsc)
  {


    //
    // Prior to using an Escape, an application will ask us 
    // if we support it first.  Return TRUE if we can handle 
    // the requested escape.
    //
    case QUERYESCSUPPORT:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: QUERY_ESCAPE_SUPPORTED. "
          "Requested escape is 0x%X.\n", *((ULONG *)pvIn) ));   

      switch ( *((ULONG *)pvIn) )
      {
        case QUERYESCSUPPORT:
        case IS_CIRRUS_DRIVER:
        case GET_VIDEO_MEM_SIZE:
        case CRTC_READ:
        case GET_BIOS_VERSION:
        case GET_PCI_VEN_DEV_ID:
        case GET_EDID_DATA:
        #ifdef CLMCD_ESCAPE_SUPPORTED // OpenGL MCD Interface
            case MCDFUNCS:
        #endif
        case CIRRUS_ESCAPE_FUNCTION:
        #if (!(WINNT_VER35)) && DRIVER_5465 // NT 4.0+ and 5465+
            case ID_LGPM_SETHWMODULESTATE:
            case ID_LGPM_GETHWMODULESTATE:
        #endif
        case BIOS_CALL_REQUEST:
        case GET_CL_MMAP_ADDR:
            DISPDBG((ESC_DBG_LVL, 
              "DrvEscape: We support the requested escape.\n"));   
            retval = TRUE;

        default:
            DISPDBG((ESC_DBG_LVL, 
              "DrvEscape: We DO NOT support the requested escape.\n"));   
            retval = FALSE;
      }
      break;

    };  // case QUERYESCSUPPORT


    case SET_AGPDATASTREAMING:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: SET_AGPDATASTREAMING.\n"));   
      retval = FALSE;
      if (cjIn == sizeof(BYTE))
      {
         if (DEVICE_IO_CTRL(ppdev->hDriver,
                             IOCTL_SET_AGPDATASTREAMING,
                             pvIn,
                             sizeof(BYTE),
                             NULL,
                             0,
                             &returnedDataLength,
                             NULL))
         {
            retval = TRUE;
         };
      };
      break;
    }  // end case SET_AGPDATASTREAMING


    case SET_DDCCONTROLFLAG:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: SET_DDCCONTROLFLAG.\n"));   
      retval = FALSE;
      if (cjIn == sizeof(DWORD))
      {
         if (DEVICE_IO_CTRL(ppdev->hDriver,
                             IOCTL_SET_DDCCONTROLFLAG,
                             pvIn,
                             sizeof(DWORD),
                             NULL,
                             0,
                             &returnedDataLength,
                             NULL))
         {
            retval = TRUE;
         };
      };
      break;
    }  // end case SET_DDCCONTROLFLAG


    case SET_NONDDCMONITOR_DATA:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: SET_NONDDCMONITOR_DATA.\n"));   
      retval = FALSE;
      if (cjIn == 128)
      {
         if (DEVICE_IO_CTRL(ppdev->hDriver,
                             IOCTL_SET_NONDDCMONITOR_DATA,
                             pvIn,
                             128,
                             NULL,
                             0,
                             &returnedDataLength,
                             NULL))
         {
            retval = TRUE;
         };
      };
      break;
    }  // end case SET_NONDDCMONITOR_DATA


    case SET_NONDDCMONITOR_BRAND:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: SET_NONDDCMONITOR_BRAND.\n"));   
      retval = FALSE;
      if (cjIn > 0)
      {
         if (DEVICE_IO_CTRL(ppdev->hDriver,
                             IOCTL_SET_NONDDCMONITOR_BRAND,
                             pvIn,
                             cjIn,
                             NULL,
                             0,
                             &returnedDataLength,
                             NULL))
         {
            retval = TRUE;
         };
      };
      break;
    }  // end case SET_NONDDCMONITOR_BRAND


    case SET_NONDDCMONITOR_MODEL:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: SET_NONDDCMONITOR_MODEL.\n"));   
      retval = FALSE;
      if (cjIn > 0)
      {
         if (DEVICE_IO_CTRL(ppdev->hDriver,
                             IOCTL_SET_NONDDCMONITOR_MODEL,
                             pvIn,
                             cjIn,
                             NULL,
                             0,
                             &returnedDataLength,
                             NULL))
         {
            retval = TRUE;
         };
      };
      break;
    }  // end case SET_NONDDCMONITOR_MODEL


    case IS_CIRRUS_DRIVER:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: IS_CIRRUS_DRIVER.\n"));   
      retval = TRUE;
      break;
    }  // end case IS_CIRRUS_DRIVER



    case GET_VIDEO_MEM_SIZE:
    {
      BYTE  btmp;
      PBYTE pOut = (PBYTE) pvOut;

      DISPDBG((ESC_DBG_LVL, "DrvEscape: GET_VIDEO_MEM_SIZE.\n"));   
      if (cjOut == sizeof(BYTE))
      {
         btmp = ppdev->lTotalMem/0x10000;
         *pOut = btmp;
         retval = TRUE;
      };
      break;
    }  // end case GET_VIDEO_MEM_SIZE



    case CRTC_READ:
    {
      BYTE  bindex;
      PBYTE pMMReg = (PBYTE) ppdev->pLgREGS_real;
      PBYTE pIn  = (PBYTE) pvIn;
      PBYTE pOut = (PBYTE) pvOut;

      DISPDBG((ESC_DBG_LVL, "DrvEscape: CRTC_READ.\n"));   
      if ((cjIn  == sizeof(BYTE)) &&
          (cjOut == sizeof(BYTE)))
      {
         bindex = (*pIn) * 4;
         pMMReg = pMMReg + bindex;
         *pOut = *pMMReg;
         retval = TRUE;
      };
      break;
    }  // end case CRTC_READ


    case GET_BIOS_VERSION:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: GET_BIOS_VERSION.\n"));   
      if (cjOut == sizeof(WORD))
      {
         if (DEVICE_IO_CTRL(ppdev->hDriver,
                             IOCTL_GET_BIOS_VERSION,
                             NULL,
                             0,
                             pvOut,
                             sizeof(WORD),
                             &returnedDataLength,
                             NULL))
         {
            retval = TRUE;
         };
      };
      break;
    }  // end case GET_BIOS_VERSION



    case GET_PCI_VEN_DEV_ID:
    {
      ULONG  ultmp;
      PULONG pOut = (PULONG) pvOut;

      DISPDBG((ESC_DBG_LVL, "DrvEscape: GET_PCI_VEN_DEV_ID.\n"));   
      if (cjOut == sizeof(DWORD))
      {
         ultmp = ppdev->dwLgVenID;
         ultmp = (ultmp << 16) | (ppdev->dwLgDevID & 0xFFFF);
         *pOut = ultmp;
         retval = TRUE;
      };
      break;
    }  // end case GET_PCI_VEN_DEV_ID



    case GET_EDID_DATA:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: GET_EDID_DATA.\n"));   
      if (cjOut == 132)
      {
         if (DEVICE_IO_CTRL(ppdev->hDriver,
                            IOCTL_GET_EDID_DATA,
                            NULL,
                            0,
                            pvOut,
                            132,
                            &returnedDataLength,
                            NULL))
         {
            retval = TRUE;
         };
      };
      break;
    }  // end case GET_EDID_DATA



    #ifdef CLMCD_ESCAPE_SUPPORTED
	// OpenGL Mini-Client Driver Interface
    case MCDFUNCS:
    {
	 	DISPDBG((ESC_DBG_LVL, "DrvEscape-MCDFUNC start\n"));   
        if (!ppdev->hMCD) {
            WCHAR uDllName[50];
            UCHAR dllName[50];
            ULONG nameSize;

            {
                HANDLE      hCLMCD;

//                // load and initialize the dll containing MCD support for display driver
//                EngMultiByteToUnicodeN(uDllName, sizeof(uDllName), &nameSize,
//                                       CLMCDDLLNAME, sizeof(CLMCDDLLNAME));
//
//                if (hCLMCD = EngLoadImage(uDllName))

                  {

//                    CLMCDINITFUNC pCLMCDInit =  EngFindImageProcAddress(hCLMCD,
//                                                     (LPSTR)CLMCDINITFUNCNAME);

//                    if (pCLMCDInit)

                      {

                        // Enable 3D engine - if enable fails, don't continue loading MCD dll
                        if (LgPM_SetHwModuleState(ppdev, MOD_3D, ENABLE))
                        {

                            DRVENABLEDATA temp;

                            // MCD dispdriver dll init returns ptr to MCDrvGetEntryPoints,
                            //  which is passed to init proc for MCD helper lib a few lines down...
//                            MCDRVGETENTRYPOINTSFUNC pMCDGetEntryPoints = (*pCLMCDInit)(ppdev);
                            MCDRVGETENTRYPOINTSFUNC pMCDGetEntryPoints = CLMCDInit(ppdev);


                            ppdev->pAllocOffScnMem = AllocOffScnMem;
                            ppdev->pFreeOffScnMem = FreeOffScnMem;

                            // after MCD display driver dll loaded, load MCD helper lib (MSFT supplied)
                
                            EngMultiByteToUnicodeN(uDllName, sizeof(uDllName), &nameSize,
                                                   MCDENGDLLNAME, sizeof(MCDENGDLLNAME));

                            if (ppdev->hMCD = EngLoadImage(uDllName)) {
                                MCDENGINITFUNC pMCDEngInit =  EngFindImageProcAddress(ppdev->hMCD,
                                                                 (LPSTR)MCDENGINITFUNCNAME);

                                if (pMCDEngInit) {
                                    (*pMCDEngInit)(pso, pMCDGetEntryPoints);
                                    ppdev->pMCDFilterFunc = EngFindImageProcAddress(ppdev->hMCD,
                                                                (LPSTR)MCDENGESCFILTERNAME);

                                }
                            }

                            
                        }
                        
                    }
                }
            }


        }

        if (ppdev->pMCDFilterFunc) {
        #ifdef DBGBRK                           
            DBGBREAKPOINT();
        #endif
            if ((*ppdev->pMCDFilterFunc)(pso, iEsc, cjIn, pvIn,			   
                                         cjOut, pvOut, &retval))
			{
        	 	DISPDBG((ESC_DBG_LVL, "DrvEscape-MCDFilterFunc SUCCESS, retval=%x\n",retval));   
                return retval;
			}
      	 	DISPDBG((ESC_DBG_LVL, "DrvEscape-MCDFilterFunc FAILED\n"));   
        }
    }
    break;
    #endif // def CLMCD_ESCAPE_SUPPORTED



    case CIRRUS_ESCAPE_FUNCTION:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: CIRRUS_ESCAPE_FUNCTION.\n"));   
      if ((cjIn  == sizeof(VIDEO_X86_BIOS_ARGUMENTS)) &&
          (cjOut == sizeof(VIDEO_X86_BIOS_ARGUMENTS)))
      {
         VIDEO_POWER_MANAGEMENT  inPM;
         BOOL bCallFail = FALSE;

         VIDEO_X86_BIOS_ARGUMENTS *pinregs  = (VIDEO_X86_BIOS_ARGUMENTS *) pvIn;
         VIDEO_X86_BIOS_ARGUMENTS *poutregs = (VIDEO_X86_BIOS_ARGUMENTS *) pvOut;

         poutregs->Eax = 0x014F;
         poutregs->Ebx = pinregs->Ebx;
         poutregs->Ecx = pinregs->Ecx;
 
         if (pinregs->Eax == 0x4F10)
         {
            if (pinregs->Ebx == 0x0001)
               inPM.PowerState = VideoPowerOn;
            else if (pinregs->Ebx == 0x0101)
               inPM.PowerState = VideoPowerStandBy;
            else if (pinregs->Ebx == 0x0201)
               inPM.PowerState = VideoPowerSuspend;
             else if (pinregs->Ebx == 0x0401)
               inPM.PowerState = VideoPowerOff;
             else
               bCallFail = TRUE;


             if (!bCallFail)
             {
                if (DEVICE_IO_CTRL(ppdev->hDriver,
                                   IOCTL_VIDEO_SET_POWER_MANAGEMENT,
                                   &inPM,
                                   sizeof(VIDEO_POWER_MANAGEMENT),
                                   NULL,
                                   0,
                                   &returnedDataLength,
                                   NULL))
                {
                   poutregs->Eax = 0x004F;
                   retval = TRUE;
                };
             };  // endif (!bCallFail)
         };  // endif (pinregs->Eax == 0x4F10)
      };

      break;
    };  // case CIRRUS_ESCAPE_FUNCTION



    #if (!(WINNT_VER35)) && DRIVER_5465 // NT 4.0+ and 5465+
    case ID_LGPM_SETHWMODULESTATE:
    {
       ULONG state;
       DISPDBG((ESC_DBG_LVL, "DrvEscape: ID_LGPM_SETHWMODULESTATE.\n"));   

       if (ppdev->dwLgDevID >= CL_GD5465)
       {
          if ((cjIn  == sizeof(LGPM_IN_STRUCT)) &&
              (cjOut == sizeof(LGPM_OUT_STRUCT)))
          {
             LGPM_IN_STRUCT  *pIn  = (LGPM_IN_STRUCT *) pvIn;
             LGPM_OUT_STRUCT *pOut = (LGPM_OUT_STRUCT *) pvOut;

             retval = TRUE;

             pOut->status = FALSE;
             pOut->retval = 0;

             pOut->status = LgPM_SetHwModuleState(ppdev, pIn->arg1, pIn->arg2);
          };
       }; // endif (ppdev->dwLgDevID >= CL_GD5465)
      break;
    };  // case ID_LGPM_SETHWMODULESTATE
    #endif



    #if (!(WINNT_VER35)) && DRIVER_5465 // NT 4.0+ and 5465+
    case ID_LGPM_GETHWMODULESTATE:
    {
        ULONG state;
        DISPDBG((ESC_DBG_LVL, "DrvEscape: ID_LGPM_GETHWMODULESTATE.\n"));   

        if (ppdev->dwLgDevID >= CL_GD5465)
        {
          if ((cjIn  == sizeof(LGPM_IN_STRUCT)) &&
              (cjOut == sizeof(LGPM_OUT_STRUCT)))
          {
             LGPM_IN_STRUCT  *pIn  = (LGPM_IN_STRUCT *) pvIn;
             LGPM_OUT_STRUCT *pOut = (LGPM_OUT_STRUCT *) pvOut;

             retval = TRUE;

             pOut->status = FALSE;
             pOut->retval = 0;

             pOut->status = LgPM_GetHwModuleState(ppdev, pIn->arg1, &state);
             pOut->retval = state;
          };

        }; // endif (ppdev->dwLgDevID >= CL_GD5465)
        break;
    };  // case ID_LGPM_GETHWMODULESTATE
    #endif



    case BIOS_CALL_REQUEST:
    {
        if ((cjIn  == sizeof(VIDEO_X86_BIOS_ARGUMENTS)) &&
            (cjOut == sizeof(VIDEO_X86_BIOS_ARGUMENTS)))
        {
         if (DEVICE_IO_CTRL(ppdev->hDriver,
                             IOCTL_CL_BIOS,
                             pvIn,
                             cjIn,
                             pvOut,
                             cjOut,
                             &returnedDataLength,
                             NULL))
            retval = TRUE;
        };

        DISPDBG((ESC_DBG_LVL, "DrvEscape-BIOS_CALL_REQUEST\n"));

        #ifdef DBGBRK
          DbgBreakPoint();
        #endif

      break;
    }; // end case BIOS_CALL_REQUEST



    case GET_CL_MMAP_ADDR:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: GET_CL_MMAP_ADDR.\n"));   
      if ((cjIn != sizeof(MMREG_ACCESS)) || (cjOut != sizeof(MMREG_ACCESS)))
         break;

      pInMRAccess = (MMREG_ACCESS *) pvIn;
      pMRAccess   = (MMREG_ACCESS *) pvOut;

      pMRAccess->Offset = pInMRAccess->Offset;
      pMRAccess->ReadVal = pInMRAccess->ReadVal;
      pMRAccess->WriteVal = pInMRAccess->WriteVal;
      pMRAccess->RdWrFlag = pInMRAccess->RdWrFlag;
      pMRAccess->AccessType = pInMRAccess->AccessType;

      pbAddr = (BYTE *) ppdev->pLgREGS;
      pbAddr = pbAddr + pMRAccess->Offset;

      if (pMRAccess->RdWrFlag == READ_OPR)  // Read operation
      {
         pMRAccess->WriteVal = 0;
         retval = TRUE;

         if (pMRAccess->AccessType == BYTE_ACCESS)
         {
            pMRAccess->ReadVal = (*pbAddr) & 0xFF;
         }
         else if (pMRAccess->AccessType == WORD_ACCESS)
         {
            pwAddr = (WORD *)pbAddr;
            pMRAccess->ReadVal = (*pwAddr) & 0xFFFF;
         }
         else if (pMRAccess->AccessType == DWORD_ACCESS)
         {
            pdwAddr = (DWORD *)pbAddr;
            pMRAccess->ReadVal = *pdwAddr;
         }
         else
         {
            pMRAccess->ReadVal = 0;
            retval = FALSE;
         };
      }
      else if (pMRAccess->RdWrFlag == WRITE_OPR)  // Write operation
      {
         retval = TRUE;

         if (pMRAccess->AccessType == BYTE_ACCESS)
         {
            pMRAccess->ReadVal = (*pbAddr) & 0xFF;
            *pbAddr = (BYTE) (pMRAccess->WriteVal & 0xFF);
         }
         else if (pMRAccess->AccessType == WORD_ACCESS)
         {
            pwAddr = (WORD *)pbAddr;
            pMRAccess->ReadVal = (*pwAddr) & 0xFFFF;
            *pwAddr = (WORD) (pMRAccess->WriteVal & 0xFFFF);
         }
         else if (pMRAccess->AccessType == DWORD_ACCESS)
         {
            pdwAddr = (DWORD *)pbAddr;
            pMRAccess->ReadVal = *pdwAddr;
            *pdwAddr = pMRAccess->WriteVal;
         }
         else
         {
            pMRAccess->ReadVal = 0;
            pMRAccess->WriteVal = 0;
            retval = FALSE;
         };
      };

        DISPDBG((ESC_DBG_LVL, "DrvEscape-GET_CL_MMAP_ADDR\n"));
        DISPDBG((ESC_DBG_LVL, "DrvEscape-rd=%x, wr=%x\n",
                        pMRAccess->ReadVal, pMRAccess->WriteVal));
        #ifdef DBGBRK
          DbgBreakPoint();
        #endif

        break;
    }; // IOCTL_CL_GET_MMAP_ADDR



    default:

        DISPDBG((ESC_DBG_LVL, 
            "DrvEscape:  default - Escape not handled.\n"));   
        DISPDBG((ESC_DBG_LVL, 
            "DrvEscape: Requested escape is 0x%X.\n",iEsc ));   
        DISPDBG((ESC_DBG_LVL, "DrvEscape:  Returning FALSE.\n"));   

        retval = FALSE;
        break;

  };  // end switch


  DISPDBG((ESC_DBG_LVL, "DrvEscape-Exit.\n"));   

  return (retval);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\fastfill.c ===
/******************************Module*Header*******************************\
* Module Name: fastfill.c
*
* Draws fast solid-coloured, unclipped, non-complex rectangles.
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

#define RIGHT 0
#define LEFT  1

#define FASTFILL_DBG_LEVEL 1

typedef struct _EDGEDATA {
    LONG      x;                // Current x position
    LONG      dx;               // # pixels to advance x on each scan
    LONG      lError;           // Current DDA error
    LONG      lErrorUp;         // DDA error increment on each scan
    LONG      lErrorDown;       // DDA error adjustment
    POINTFIX* pptfx;            // Points to start of current edge
    LONG      dptfx;            // Delta (in bytes) from pptfx to next point
    LONG      cy;               // Number of scans to go for this edge
} EDGEDATA;                         /* ed, ped */

/******************************Public*Routine******************************\
* BOOL bMmFastFill
*
* Draws a non-complex, unclipped polygon.  'Non-complex' is defined as
* having only two edges that are monotonic increasing in 'y'.  That is,
* the polygon cannot have more than one disconnected segment on any given
* scan.  Note that the edges of the polygon can self-intersect, so hourglass
* shapes are permissible.  This restriction permits this routine to run two
* simultaneous DDAs, and no sorting of the edges is required.
*
* Note that NT's fill convention is different from that of Win 3.1 or 4.0.
* With the additional complication of fractional end-points, our convention
* is the same as in 'X-Windows'.  But a DDA is a DDA is a DDA, so once you
* figure out how we compute the DDA terms for NT, you're golden.
*
* This routine handles patterns only when the S3 hardware patterns can be
* used.  The reason for this is that once the S3 pattern initialization is
* done, pattern fills appear to the programmer exactly the same as solid
* fills (with the slight difference that different registers and commands
* are used).  Handling 'vIoFillPatSlow' style patterns in this routine
* would be non-trivial...
*
* We take advantage of the fact that the S3 automatically advances the
* current 'y' to the following scan whenever a rectangle is output so that
* we have to write to the accelerator three times for every scan: one for
* the new 'x', one for the new 'width', and one for the drawing command.
*
* This routine is in no way the ultimate convex polygon drawing routine
* (what can I say, I was pressed for time when I wrote this :-).  Some
* obvious things that would make it faster:
*
*    1) Write it in Asm and amortize the FIFO checking costs (check out
*       i386\fastfill.asm for a version that does this).
*
*    2) Take advantage of any hardware such as the ATI's SCAN_TO_X
*       command, or any built-in trapezoid support (note that with NT
*       you may get non-integer end-points, so you must be able to
*       program the trapezoid DDA terms directly).
*
*    3) Do some rectangle coalescing when both edges are y-major.  This
*       could permit removal of my vertical-edges special case.  I
*       was also thinking of special casing y-major left edges on the
*       S3, because the S3 leaves the current 'x' unchanged on every blt,
*       so a scan that starts on the same 'x' as the one above it
*       would require only two commands to the accelerator (obviously,
*       this only helps when we're not overdriving the accelerator).
*
*    4) Make the non-complex polygon detection faster.  If I could have
*       modified memory before the start of after the end of the buffer,
*       I could have simplified the detection code.  But since I expect
*       this buffer to come from GDI, I can't do that.  Another thing
*       would be to have GDI give a flag on calls that are guaranteed
*       to be convex, such as 'Ellipses' and 'RoundRects'.  Note that
*       the buffer would still have to be scanned to find the top-most
*       point.
*
*    5) Special case integer points.  Unfortunately, for this to be
*       worth-while would require GDI to give us a flag when all the
*       end-points of a path are integers, which it doesn't do.
*
*    6) Add rectangular clipping support.
*
*    7) Implement support for a single sub-path that spans multiple
*       path data records, so that we don't have to copy all the points
*       to a single buffer like we do in 'fillpath.c'.
*
*    8) Use 'ebp' and/or 'esp' as a general register in the inner loops
*       of the Asm loops, and also Pentium-optimize the code.  It's safe
*       to use 'esp' on NT because it's guaranteed that no interrupts
*       will be taken in our thread context, and nobody else looks at the
*       stack pointer from our context.
*
*    9) Do the fill bottom-up instead of top-down.  With the S3, we have
*       to only set 'cur_y' once because each drawing command automatically
*       advances 'cur_y' (unless the polygon has zero pels lit on a scan),
*       so we set this right at the beginning.  But for an integer end-point
*       polygon, unless the top edge is horizontal, no pixels are lit on
*       that first scan (so at the beginning of almost every integer
*       polygon, we go through the 'zero width' logic and again set
*       'cur_y').  We could avoid this extra work by building the polygon
*       from bottom to top: for the bottom-most point B in a polygon, it
*       is guaranteed that any scan with lit pixels will be no lower than
*       'ceiling(B.y) - 1'.  Unfortunately, building bottom-up makes the
*       fractional-DDA calculations a little more complex, so I didn't do it.
*
*       Building bottom-up would also improve the polygon score in version
*       3.11 of a certain benchmark, because it has a big rectangle at the
*       top of every polygon -- we would get better processing overlap
*       because we wouldn't have to wait around for the accelerator to
*       finish drawing the big rectangle.
*
*   10) Make a better guess in the initialization as to which edge is the
*       'left' edge, and which is the 'right'.  As it is, we immediately
*       go through the swap-edges logic for half of all polygons when we
*       start to run the DDA.  The reason why I didn't implement better-guess
*       code is because it would have to look at the end-point of the top
*       edges, and to get at the end-points we have to watch that we don't
*       wrap around the ends of the points buffer.
*
*   11) Lots of other things I haven't thought of.
*
* NOTE: Unlike the x86 Asm version, this routine does NOT assume that it
*       has 16 FIFO entries available.
*
* Returns TRUE if the polygon was drawn; FALSE if the polygon was complex.
*
\**************************************************************************/

BOOL bMmFastFill(
PDEV*       ppdev,
LONG        cEdges,         // Includes close figure edge
POINTFIX*   pptfxFirst,
ULONG       ulHwForeMix,
ULONG       ulHwBackMix,
ULONG       iSolidColor,
BRUSHOBJ*  pbo)
{
    LONG      yTrapezoid;   // Top scan for next trapezoid
    LONG      cyTrapezoid;  // Number of scans in current trapezoid
    LONG      y;            // Current Y Location
    LONG      yStart;       // y-position of start point in current edge
    LONG      dM;           // Edge delta in FIX units in x direction
    LONG      dN;           // Edge delta in FIX units in y direction
    LONG      i;
    POINTFIX* pptfxLast;    // Points to the last point in the polygon array
    POINTFIX* pptfxTop;     // Points to the top-most point in the polygon
    POINTFIX* pptfxOld;     // Start point in current edge
    POINTFIX* pptfxScan;    // Current edge pointer for finding pptfxTop
    LONG      cScanEdges;   // Number of edges scanned to find pptfxTop
                            //  (doesn't include the closefigure edge)
    LONG      iEdge;
    LONG      lQuotient;
    LONG      lRemainder;

    EDGEDATA  aed[2];       // DDA terms and stuff
    EDGEDATA* ped;

    DISPDBG((FASTFILL_DBG_LEVEL,"bMmFastFill %x %x %x\n", ulHwForeMix, ulHwBackMix, ppdev->uBLTDEF << 16 | ulHwForeMix,
       ppdev->uBLTDEF << 16 | ulHwForeMix));

    REQUIRE(5);

    // Set up BltDef and DrawDef
    LL_DRAWBLTDEF(ppdev->uBLTDEF << 16 | ulHwForeMix, 2);

    /////////////////////////////////////////////////////////////////
    // See if the polygon is 'non-complex'

    pptfxScan = pptfxFirst;
    pptfxTop  = pptfxFirst;                 // Assume for now that the first
                                            //  point in path is the topmost
    pptfxLast = pptfxFirst + cEdges - 1;

    // 'pptfxScan' will always point to the first point in the current
    // edge, and 'cScanEdges' will the number of edges remaining, including
    // the current one:

    cScanEdges = cEdges - 1;     // The number of edges, not counting close figure

    if ((pptfxScan + 1)->y > pptfxScan->y)
    {
        // Collect all downs:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFillingCheck;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        // Collect all downs:

        pptfxTop = pptfxScan;

        do {
            if ((pptfxScan + 1)->y > pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        DISPDBG((FASTFILL_DBG_LEVEL,"False Exit %s %d\n", __FILE__, __LINE__));
        return(FALSE);
    }
    else
    {
        // Collect all ups:

        do {
            pptfxTop++;                 // We increment this now because we
                                        //  want it to point to the very last
                                        //  point if we early out in the next
                                        //  statement...
            if (--cScanEdges == 0)
                goto SetUpForFilling;
        } while ((pptfxTop + 1)->y <= pptfxTop->y);

        // Collect all downs:

        pptfxScan = pptfxTop;
        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if ((pptfxScan + 1)->y < pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        DISPDBG((FASTFILL_DBG_LEVEL,"False Exit %s %d\n", __FILE__, __LINE__));
        return(FALSE);
    }

SetUpForFillingCheck:

    // We check to see if the end of the current edge is higher
    // than the top edge we've found so far:

    if ((pptfxScan + 1)->y < pptfxTop->y)
        pptfxTop = pptfxScan + 1;

SetUpForFilling:

    /////////////////////////////////////////////////////////////////
    // Some Initialization

    yTrapezoid = (pptfxTop->y + 15) >> 4;
    DISPDBG((FASTFILL_DBG_LEVEL, "%d yTrapezoid init %x\n", __LINE__, yTrapezoid));

    // Make sure we initialize the DDAs appropriately:

    aed[LEFT].cy  = 0;
    aed[RIGHT].cy = 0;

    // For now, guess as to which is the left and which is the right edge:

    aed[LEFT].dptfx  = -(LONG) sizeof(POINTFIX);
    aed[RIGHT].dptfx = sizeof(POINTFIX);
    aed[LEFT].pptfx  = pptfxTop;
    aed[RIGHT].pptfx = pptfxTop;

    if (iSolidColor != -1)
    {
        /////////////////////////////////////////////////////////////////
        // Setup the hardware for solid colours

        // Let's set the Foreground Register here since they are
        switch (ppdev->ulBitCount)
        {
                case 8: // For 8 bpp duplicate byte 0 into bytes 1,2,3.
                        iSolidColor = (iSolidColor & 0xFF) | (iSolidColor << 8);

                case 16: // For 16 bpp, duplicate the low word into the high word.
                        iSolidColor = (iSolidColor & 0xFFFF) | (iSolidColor << 16);
        }

        DISPDBG((FASTFILL_DBG_LEVEL,"FASTFILL: Set Color %x.\n", iSolidColor));
        LL_BGCOLOR(iSolidColor, 2);
    }
    else
    {
        /////////////////////////////////////////////////////////////////
        // Setup for patterns
    }
        y = yTrapezoid;
        DISPDBG((FASTFILL_DBG_LEVEL, "%d New y %x\n", __LINE__, y));
// done above   REQUIRE(1);
        LL16(grOP0_opRDRAM.pt.Y, y + ppdev->ptlOffset.y);

NewTrapezoid:

    /////////////////////////////////////////////////////////////////
    // DDA initialization

    for (iEdge = 1; iEdge >= 0; iEdge--)
    {
        ped = &aed[iEdge];
        if (ped->cy == 0)
        {
            // Need a new DDA:

            do {
                cEdges--;
                if (cEdges < 0)
                {
                    DISPDBG((FASTFILL_DBG_LEVEL,"True Exit %s %d\n", __FILE__, __LINE__));
                    return(TRUE);
                }
                // Find the next left edge, accounting for wrapping:

                pptfxOld = ped->pptfx;
                ped->pptfx = (POINTFIX*) ((BYTE*) ped->pptfx + ped->dptfx);

                if (ped->pptfx < pptfxFirst)
                    ped->pptfx = pptfxLast;
                else if (ped->pptfx > pptfxLast)
                    ped->pptfx = pptfxFirst;

                // Have to find the edge that spans yTrapezoid:

                ped->cy = ((ped->pptfx->y + 15) >> 4) - yTrapezoid;

                // With fractional coordinate end points, we may get edges
                // that don't cross any scans, in which case we try the
                // next one:

            } while (ped->cy <= 0);

            // 'pptfx' now points to the end point of the edge spanning
            // the scan 'yTrapezoid'.

            dN = ped->pptfx->y - pptfxOld->y;
            dM = ped->pptfx->x - pptfxOld->x;

            ASSERTDD(dN > 0, "Should be going down only");

            // Compute the DDA increment terms:

            if (dM < 0)
            {
                dM = -dM;
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = -1;
                    ped->lErrorUp = dN - dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = -lQuotient;     // - dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                    if (ped->lErrorUp > 0)
                    {
                        ped->dx--;
                        ped->lErrorUp = dN - ped->lErrorUp;
                    }
                }
            }
            else
            {
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = 0;
                    ped->lErrorUp = dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = lQuotient;      // dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                }
            }

            ped->lErrorDown = dN; // DDA limit
            ped->lError     = -1; // Error is initially zero (add dN - 1 for
                                  //  the ceiling, but subtract off dN so that
                                  //  we can check the sign instead of comparing
                                  //  to dN)

            ped->x = pptfxOld->x;
            yStart = pptfxOld->y;

            if ((yStart & 15) != 0)
            {
                // Advance to the next integer y coordinate

                for (i = 16 - (yStart & 15); i != 0; i--)
                {
                    ped->x      += ped->dx;
                    ped->lError += ped->lErrorUp;
                    if (ped->lError >= 0)
                    {
                        ped->lError -= ped->lErrorDown;
                        ped->x++;
                    }
                }
            }

            if ((ped->x & 15) != 0)
            {
                ped->lError -= ped->lErrorDown * (16 - (ped->x & 15));
                ped->x += 15;       // We'll want the ceiling in just a bit...
            }

            // Chop off those fractional bits:

            ped->x      >>= 4;
            ped->lError >>= 4;
        }
    }

    cyTrapezoid = min(aed[LEFT].cy, aed[RIGHT].cy); // # of scans in this trap
    DISPDBG((FASTFILL_DBG_LEVEL, "%d cyTrapezoid =  %d\n",
                        __LINE__, cyTrapezoid));

    aed[LEFT].cy  -= cyTrapezoid;
    aed[RIGHT].cy -= cyTrapezoid;
    yTrapezoid    += cyTrapezoid;                   // Top scan in next trap

    // If the left and right edges are vertical, simply output as
    // a rectangle:

    if (((aed[LEFT].lErrorUp | aed[RIGHT].lErrorUp) == 0) &&
        ((aed[LEFT].dx       | aed[RIGHT].dx) == 0) &&
        (cyTrapezoid > 1))
    {
        LONG lWidth;

        /////////////////////////////////////////////////////////////////
        // Vertical-edge special case

    ContinueVertical:

        lWidth = aed[RIGHT].x - aed[LEFT].x - 1;
                DISPDBG((FASTFILL_DBG_LEVEL, "%d lWidth %x %x %x cyTrapezoid %x \n",
                                __LINE__, lWidth, aed[RIGHT].x, aed[LEFT].x, cyTrapezoid));
        if (lWidth >= 0)
        {
                DISPDBG((FASTFILL_DBG_LEVEL,"%d New x %x\n",__LINE__, aed[LEFT].x));
                REQUIRE(5);
//              REQUIRE(4);
                LL16(grOP0_opRDRAM.pt.X, aed[LEFT].x + ppdev->ptlOffset.x);
                LL_BLTEXT(lWidth + 1, cyTrapezoid);
                DISPDBG((FASTFILL_DBG_LEVEL, "DO a Blt %x\n",(cyTrapezoid << 16) | (lWidth + 1)));
                y += cyTrapezoid;
                DISPDBG((FASTFILL_DBG_LEVEL,"%d New y %x\n", __LINE__, y));
                LL16(grOP0_opRDRAM.pt.Y, y + ppdev->ptlOffset.y);
        }
        else if (lWidth == -1)
        {
            // If the rectangle was too thin to light any pels, we still
            // have to advance the y current position:
            y = yTrapezoid - cyTrapezoid + 1;
            DISPDBG((FASTFILL_DBG_LEVEL, "%d New y %x yTrap %x cyTrap %x\n",
                                __LINE__, y, yTrapezoid, cyTrapezoid));
            REQUIRE(1);
            LL16(grOP0_opRDRAM.pt.Y, y + ppdev->ptlOffset.y);
        }
        else
        {
            LONG      lTmp;
            POINTFIX* pptfxTmp;

            SWAP(aed[LEFT].x,          aed[RIGHT].x,          lTmp);
            SWAP(aed[LEFT].cy,         aed[RIGHT].cy,         lTmp);
            SWAP(aed[LEFT].dptfx,      aed[RIGHT].dptfx,      lTmp);
            SWAP(aed[LEFT].pptfx,      aed[RIGHT].pptfx,      pptfxTmp);
            goto ContinueVertical;
        }

        goto NewTrapezoid;
    }

    while (TRUE)
    {
        LONG lWidth;

        /////////////////////////////////////////////////////////////////
        // Run the DDAs

        // The very first time through, make sure we set x:

        lWidth = aed[RIGHT].x - aed[LEFT].x - 1;
        if (lWidth >= 0)
        {
            DISPDBG((FASTFILL_DBG_LEVEL,"%d New x %x\n", __LINE__, aed[LEFT].x));
            REQUIRE(5);
//          REQUIRE(4);
            LL16(grOP0_opRDRAM.pt.X, aed[LEFT].x + ppdev->ptlOffset.x);
            LL_BLTEXT(lWidth + 1, 1);
            DISPDBG((FASTFILL_DBG_LEVEL,"%d New y %x\n", __LINE__, y+1));
            LL16(grOP0_opRDRAM.pt.Y, ++y + ppdev->ptlOffset.y);

    ContinueAfterZero:

            // Advance the right wall:

            aed[RIGHT].x      += aed[RIGHT].dx;
            aed[RIGHT].lError += aed[RIGHT].lErrorUp;

            if (aed[RIGHT].lError >= 0)
            {
                aed[RIGHT].lError -= aed[RIGHT].lErrorDown;
                aed[RIGHT].x++;
            }

            // Advance the left wall:

            aed[LEFT].x      += aed[LEFT].dx;
            aed[LEFT].lError += aed[LEFT].lErrorUp;

            if (aed[LEFT].lError >= 0)
            {
                aed[LEFT].lError -= aed[LEFT].lErrorDown;
                aed[LEFT].x++;
            }

            cyTrapezoid--;
            if (cyTrapezoid == 0)
                goto NewTrapezoid;
        }
        else if (lWidth == -1)
        {
            y = yTrapezoid - cyTrapezoid + 1;
            DISPDBG((FASTFILL_DBG_LEVEL, "%d New y %x yTrap %x cyTrap %x\n",
                                __LINE__, y, yTrapezoid, cyTrapezoid));
            REQUIRE(1);
            LL16(grOP0_opRDRAM.pt.Y, (y + ppdev->ptlOffset.y) );
            goto ContinueAfterZero;
        }
        else
        {
            // We certainly don't want to optimize for this case because we
            // should rarely get self-intersecting polygons (if we're slow,
            // the app gets what it deserves):

            LONG      lTmp;
            POINTFIX* pptfxTmp;

            SWAP(aed[LEFT].x,          aed[RIGHT].x,          lTmp);
            SWAP(aed[LEFT].dx,         aed[RIGHT].dx,         lTmp);
            SWAP(aed[LEFT].lError,     aed[RIGHT].lError,     lTmp);
            SWAP(aed[LEFT].lErrorUp,   aed[RIGHT].lErrorUp,   lTmp);
            SWAP(aed[LEFT].lErrorDown, aed[RIGHT].lErrorDown, lTmp);
            SWAP(aed[LEFT].cy,         aed[RIGHT].cy,         lTmp);
            SWAP(aed[LEFT].dptfx,      aed[RIGHT].dptfx,      lTmp);
            SWAP(aed[LEFT].pptfx,      aed[RIGHT].pptfx,      pptfxTmp);

            continue;
        }
    }
    DISPDBG((FASTFILL_DBG_LEVEL,"Eof Exit %s %d\n", __FILE__, __LINE__));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\disp\cl5465\dev2dev.c ===
/******************************Module*Header*******************************\
* Module Name: DEV2DEV.c
*
* Author: Noel VanHook
* 
* Purpose: Handle device to device BLTs. 
*
* Copyright (c) 1997 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/dev2dev.c  $
* 
*    Rev 1.11   Mar 04 1998 15:13:52   frido
* Added new shadow macros.
* 
*    Rev 1.10   Jan 22 1998 16:20:10   frido
* Added 16-bit striping code.
* 
*    Rev 1.9   Jan 21 1998 13:46:52   frido
* Fixed the striping code since this is really the first time we check it.
* 
*    Rev 1.8   Jan 20 1998 11:43:26   frido
* Guess what? Striping was not turned on!
* 
*    Rev 1.7   Dec 10 1997 13:32:12   frido
* Merged from 1.62 branch.
* 
*    Rev 1.6.1.2   Dec 05 1997 13:34:26   frido
* PDR#11043. When using a brush, striping should use pixels instead of
* bytes, so now there is an intelligent switcher in place.
* 
*    Rev 1.6.1.1   Nov 18 1997 15:14:56   frido
* Added striping for 24-bpp.
* 
*    Rev 1.6.1.0   Nov 10 1997 13:39:26   frido
* PDR#10893: Inside DoDeviceToDeviceWithXlate the source pointer
* was not updated after each access.
* 
*    Rev 1.6   Nov 04 1997 13:40:56   frido
* I removed a little too much code in DoDeviceToDevice. The result was
* a very slow screen-to-screen blits since everything was punted back to
* GDI.
* 
*    Rev 1.5   Nov 04 1997 09:49:18   frido
* Added COLOR_TRANSLATE switches around hardware color translation code.
* 
*    Rev 1.4   Nov 03 1997 15:20:06   frido
* Added REQUIRE macros.
* 
*    Rev 1.3   15 Oct 1997 12:03:00   noelv
* Pass rop code to CacheXlateTable().
* 
*    Rev 1.2   02 Oct 1997 09:48:22   noelv
* 
* Hardwre color translation only works with CC rop code.
* 
*    Rev 1.1   19 Feb 1997 13:14:22   noelv
* 
* Fixed LL_BLTEXT_XLATE()
* 
*    Rev 1.0   06 Feb 1997 10:35:48   noelv
* Initial revision.
*
\**************************************************************************/

#include "precomp.h"

#define DEV2DEV_DBG_LEVEL 0

//
// Set to 1 to stripe screen to screen operations along tile boundries.
// Set to 0 to do screen to screen operations in a few BLTs as possible.
//
// on the 62, 64 and 65 striping is faster than not striping.
//
#define STRIPE_SCR2SCR 1

//
// internal prototypes.
//
BOOL DoDeviceToDeviceWithXlate(
    SURFOBJ  *psoTrg,
    SURFOBJ  *psoSrc,
    ULONG    *pulXlate,
    RECTL    *prclTrg,
    POINTL   *pptlSrc,
    ULONG    ulDRAWBLTDEF
);





/*****************************************************************************\
 * DoDeviceToDevice
 *
 * This routine performs a ScreenToScreen, DeviceToScreen or ScreenToDevice
 * blit.  If there is a color translation table, we will attempt to use
 * the hardware color translator.  If we can't (or don't have one) we will
 * pass the call to DoDeviceToDeviceWithXlate, which will do the color
 * translation is software.
 *
 * On entry:    psoTrg          Pointer to target surface object.
 *              psoSrc          Pointer to source surface object.
 *              pxlo            Pointer to translation object.
 *              prclTrg         Destination rectangle.
 *              pptlSrc         Source offset.
 *              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                              The ROP and the brush flags.
\*****************************************************************************/
BOOL DoDeviceToDevice(
    SURFOBJ  *psoTrg,
    SURFOBJ  *psoSrc,
    XLATEOBJ *pxlo,
    RECTL    *prclTrg,
    POINTL   *pptlSrc,
    ULONG    ulDRAWBLTDEF
)
{
    POINTL ptlSrc, ptlDest;
    SIZEL  sizl;
    PPDEV  ppdev;
    LONG   tileSize, maxStripeWidth;
    ULONG* pulXlate;
	BOOL   fStripePixels;
	BOOL   fFirst = TRUE;

    //
    // Determine the source type and adjust the source offset.
    //
    if (psoSrc->iType == STYPE_DEVBITMAP)
    {
        // Source is a device bitmap.
        PDSURF pdsurf = (PDSURF) psoSrc->dhsurf;
        ptlSrc.x = pptlSrc->x + pdsurf->ptl.x;
        ptlSrc.y = pptlSrc->y + pdsurf->ptl.y;
        ppdev = pdsurf->ppdev;
    }
    else
    {
        // Source is the screen.
        ptlSrc.x = pptlSrc->x;
        ptlSrc.y = pptlSrc->y;
        ppdev = (PPDEV) psoSrc->dhpdev;
    }


    //
    // Determine the destination type and adjust the destination offset.
    //
    if (psoTrg->iType == STYPE_DEVBITMAP)
    {
        PDSURF pdsurf = (PDSURF) psoTrg->dhsurf;
        ptlDest.x = prclTrg->left + pdsurf->ptl.x;
        ptlDest.y = prclTrg->top + pdsurf->ptl.y;
    }
    else
    {
        ptlDest.x = prclTrg->left;
        ptlDest.y = prclTrg->top;
    }


    //
    // Is there a translation table?
    // If so, we will attempt to load it into the chip.  This also
    // points pulXlate at the color translation table, if there is one.
    //
	#if COLOR_TRANSLATE
    if (! bCacheXlateTable(ppdev, &pulXlate, psoTrg, psoSrc, pxlo,
						   (BYTE)(ulDRAWBLTDEF&0xCC)) )
	#else
	if ( (pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL) )
	{
		pulXlate = NULL;
	}
	else if (pxlo->flXlate & XO_TABLE)
	{
		pulXlate = pxlo->pulXlate;
	}
	else
	{
		pulXlate = XLATEOBJ_piVector(pxlo);
	}

	if (pulXlate != NULL)
	#endif
    {
        // We must do software color translation.
        return DoDeviceToDeviceWithXlate(psoTrg, psoSrc, pulXlate, prclTrg,
										 pptlSrc, ulDRAWBLTDEF);
    }

    //
    // if pulXlate == NULL, there is no color translation required.
    // if pulXlate != NULL, we will do hardware translation.
    //

    //
    // We only do screen to screen color translation in 8 bpp.
    //
    ASSERTMSG( ((pulXlate == NULL) || (ppdev->iBitmapFormat == BMF_8BPP)),
            "DoDeviceToDevice: Xlate with non-8bpp.\n");
    if ((pulXlate) && (ppdev->iBitmapFormat != BMF_8BPP))
    {
        return FALSE;
    }


    // Calculate the size of the blit.
    sizl.cx = prclTrg->right - prclTrg->left;
    sizl.cy = prclTrg->bottom - prclTrg->top;

	fStripePixels = (ulDRAWBLTDEF & 0x000F0000) | (pulXlate != NULL);

	if (fStripePixels)
	{
	    // Calculate the number of pixels per tile and per SRAM line.
	    switch (ppdev->iBitmapFormat)
	    {
	        case BMF_8BPP:
	            tileSize = ppdev->lTileSize;
	            maxStripeWidth = 120;
	            break;

	        case BMF_16BPP:
	            tileSize = ppdev->lTileSize / 2;
	            maxStripeWidth = 120 / 2;
	            break;

	        case BMF_24BPP:
	            tileSize = ppdev->cxScreen;
	            maxStripeWidth = max(ptlDest.x - ptlSrc.x, 120 / 3);
	            break;

	        case BMF_32BPP:
	            tileSize = ppdev->lTileSize / 4;
	            maxStripeWidth = 120 / 4;
	            break;
	    }
	}
	else
	{
		// Convert everything to bytes.
		ptlSrc.x *= ppdev->iBytesPerPixel;
		ptlDest.x *= ppdev->iBytesPerPixel;
		sizl.cx *= ppdev->iBytesPerPixel;
		tileSize = ppdev->lTileSize;
		maxStripeWidth = 120;
	}

    // Test vertical direction of blitting and set grDRAWBLTDEF register
    // accordingly.
    if (ptlSrc.y < ptlDest.y)
    {
        ptlSrc.y += sizl.cy - 1;
        ptlDest.y += sizl.cy - 1;
		ulDRAWBLTDEF |= 0x90100000;
    }
    else
    {
        ulDRAWBLTDEF |= 0x10100000;
    }

    // Test horizontal direction of blitting.
    if ( (ptlSrc.x >= ptlDest.x) || (ptlSrc.y != ptlDest.y) )
    {
		if (ptlSrc.x >= ptlDest.x)
		{
	        // Blit to left.
	        while (sizl.cx > 0)
	        {
	            // Calculate the width of this blit.
	            LONG cx = sizl.cx;

	            // Calculate how many pixels it is to the next source tile
	            // boundary. Use lesser value.
	            cx = min(cx, tileSize - (ptlSrc.x % tileSize));

	            // Calculate how many pixels it is to the next destination tile
	            // boundary. Use lesser value.
	            cx = min(cx, tileSize - (ptlDest.x % tileSize));

	            // Perform the blit.
				if (fFirst)
				{
					fFirst = FALSE;

					REQUIRE(9);
					LL_DRAWBLTDEF(ulDRAWBLTDEF, 0);

					if (fStripePixels)
					{
			            LL_OP1(ptlSrc.x, ptlSrc.y);
			            LL_OP0(ptlDest.x, ptlDest.y);

			            if (pulXlate) // launch a color xlate BLT
			                LL_BLTEXT_XLATE(8, cx, sizl.cy);
			            else // Launch a regular BLT
			                LL_BLTEXT(cx, sizl.cy);
					}
					else
					{
						LL_OP1_MONO(ptlSrc.x, ptlSrc.y);
						LL_OP0_MONO(ptlDest.x, ptlDest.y);
						LL_MBLTEXT(cx, sizl.cy);
					}
				}
				else if (pulXlate)
				{
					REQUIRE(7);
		            LL_OP1(ptlSrc.x, ptlSrc.y);
		            LL_OP0(ptlDest.x, ptlDest.y);
					LL_BLTEXT_XLATE(8, cx, sizl.cy);
				}
				else
				{
					REQUIRE(4);
					if (fStripePixels)
					{
						LL16(grOP1_opRDRAM.PT.X, ptlSrc.x);
						LL16(grOP0_opRDRAM.PT.X, ptlDest.x);
						LL16(grBLTEXT_XEX.PT.X, cx);
					}
					else
					{
						LL16(grOP1_opMRDRAM.PT.X, ptlSrc.x);
						LL16(grOP0_opMRDRAM.PT.X, ptlDest.x);
						LL16(grMBLTEXT_XEX.PT.X, cx);
					}
				}

	            // Adjust the coordinates.
	            ptlSrc.x += cx;
	            ptlDest.x += cx;
	            sizl.cx -= cx;
	        }
		}
		else
		{
	        // Blit to right.
			ptlSrc.x += sizl.cx;
			ptlDest.x += sizl.cx;
	        while (sizl.cx > 0)
	        {
	            // Calculate the width of this blit.
	            LONG cx = sizl.cx;

	            // Calculate how many pixels it is to the next source tile
	            // boundary. Use lesser value.
				if ((ptlSrc.x % tileSize) == 0)
				{
					cx = min(cx, tileSize);
				}
				else
				{
	            	cx = min(cx, ptlSrc.x % tileSize);
				}

	            // Calculate how many pixels it is to the next destination tile
	            // boundary. Use lesser value.
				if ((ptlDest.x % tileSize) == 0)
				{
					cx = min(cx, tileSize);
				}
				else
				{
	            	cx = min(cx, ptlDest.x % tileSize);
				}

	            // Perform the blit.
				if (fFirst)
				{
					fFirst = FALSE;

					REQUIRE(9);
					LL_DRAWBLTDEF(ulDRAWBLTDEF, 0);

					if (fStripePixels)
					{
		    	        LL_OP1(ptlSrc.x - cx, ptlSrc.y);
		        	    LL_OP0(ptlDest.x - cx, ptlDest.y);

			            if (pulXlate) // launch a color xlate BLT
			                LL_BLTEXT_XLATE(8, cx, sizl.cy);
			            else // Launch a regular BLT
		    	            LL_BLTEXT(cx, sizl.cy);
					}
					else
					{
						LL_OP1_MONO(ptlSrc.x - cx, ptlSrc.y);
						LL_OP0_MONO(ptlDest.x - cx, ptlDest.y);
						LL_MBLTEXT(cx, sizl.cy);
					}
				}
				else if (pulXlate)
				{
					REQUIRE(7);
		            LL_OP1(ptlSrc.x - cx, ptlSrc.y);
		            LL_OP0(ptlDest.x - cx, ptlDest.y);
					LL_BLTEXT_XLATE(8, cx, sizl.cy);
				}
				else
				{
					REQUIRE(4);
					if (fStripePixels)
					{
						LL16(grOP1_opRDRAM.PT.X, ptlSrc.x - cx);
						LL16(grOP0_opRDRAM.PT.X, ptlDest.x - cx);
						LL16(grBLTEXT_XEX.PT.X, cx);
					}
					else
					{
						LL16(grOP1_opMRDRAM.PT.X, ptlSrc.x - cx);
						LL16(grOP0_opMRDRAM.PT.X, ptlDest.x - cx);
						LL16(grMBLTEXT_XEX.PT.X, cx);
					}
				}

	            // Adjust the coordinates.
	            ptlSrc.x -= cx;
	            ptlDest.x -= cx;
	            sizl.cx -= cx;
	        }
		}
    }

    else
    {
        // Blit using SRAM.
        ptlSrc.x += sizl.cx;
        ptlDest.x += sizl.cx;

        while (sizl.cx > 0)
        {
            // Calculate the width of this blit. We must never overrun a single
            // SRAM cache line.
            LONG cx = min(sizl.cx, maxStripeWidth);

            // Calculate how many pixels it is to the next source tile
            // boundary. Use lesser value.
            cx = min(cx, ((ptlSrc.x - 1) % tileSize) + 1);

            // Calculate how many pixels it is to the next destination tile
            // boundary. Use lesser value.
            cx = min(cx, ((ptlDest.x - 1) % tileSize) + 1);

            // Do the blit.
			if (fFirst)
			{
				REQUIRE(9);
				LL_DRAWBLTDEF(ulDRAWBLTDEF, 0);
				if (fStripePixels)
				{
	        	    LL_OP1(ptlSrc.x - cx, ptlSrc.y);
	            	LL_OP0(ptlDest.x - cx, ptlDest.y);

					if (pulXlate) // Launch a color xlate BLT
	    	            LL_BLTEXT_XLATE(8, cx, sizl.cy);
		            else // Launch a regular BLT
		                LL_BLTEXT(cx, sizl.cy);
				}
				else
				{
					LL_OP1_MONO(ptlSrc.x - cx, ptlSrc.y);
					LL_OP0_MONO(ptlDest.x - cx, ptlDest.y);
					LL_MBLTEXT(cx, sizl.cy);
				}
			}
			else if (pulXlate)
			{
				REQUIRE(7);
	            LL_OP1(ptlSrc.x - cx, ptlSrc.y);
	            LL_OP0(ptlDest.x - cx, ptlDest.y);
				LL_BLTEXT_XLATE(8, cx, sizl.cy);
			}
			else
			{
				REQUIRE(4);
				if (fStripePixels)
				{
					LL16(grOP1_opRDRAM.PT.X, ptlSrc.x - cx);
					LL16(grOP0_opRDRAM.PT.X, ptlDest.x - cx);
					LL16(grBLTEXT_XEX.PT.X, cx);
				}
				else
				{
					LL16(grOP1_opMRDRAM.PT.X, ptlSrc.x - cx);
					LL16(grOP0_opMRDRAM.PT.X, ptlDest.x - cx);
					LL16(grMBLTEXT_XEX.PT.X, cx);
				}
			}

            // Adjust the coordinates.
            ptlSrc.x -= cx;
            ptlDest.x -= cx;
            sizl.cx -= cx;
        }
    }

    return(TRUE);
}







/*****************************************************************************\
 * DoDeviceToDeviceWithXlate
 *
 * This routine performs a ScreenToScreen, DeviceToScreen or ScreenToDevice
 * blit when there is a color translation table.
 * Color translation is done in software.
 *
 *
 * On entry:    psoTrg          Pointer to target surface object.
 *              psoSrc          Pointer to source surface object.
 *              pulXlate        Translation table.
 *              prclTrg         Destination rectangle.
 *              pptlSrc         Source offset.
 *              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                              the ROP and the brush flags.
\*****************************************************************************/
BOOL DoDeviceToDeviceWithXlate(
    SURFOBJ  *psoTrg,
    SURFOBJ  *psoSrc,
    ULONG