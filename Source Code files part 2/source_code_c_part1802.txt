eviceID())
        {
            ReportCmdLineError(hwndStub, IDS_NO_DEVICEID);
            return;
        }
        
        DeviceProblemWizard(hwndStub, 
                            CmdLine.GetMachineName(), 
                            CmdLine.GetDeviceID()
                            );
    }

    catch (CMemoryException* e)
    {
        e->ReportError();
        e->Delete();
        return;
    }
}

STDAPI_(int)
DeviceProblemWizardA(
    HWND hwndParent,
    LPCSTR MachineName,
    LPCSTR DeviceId
    )
{
    try
    {
        CTString tstrMachineName(MachineName);
        CTString tstrDeviceId(DeviceId);
        return DeviceProblemWizard(hwndParent, tstrMachineName, tstrDeviceId);
    }

    catch(CMemoryException* e)
    {
        e->Delete();
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return 0;
}

STDAPI_(int)
DeviceProblemWizardW(
    HWND hwndParent,
    LPCWSTR  MachineName,
    LPCWSTR  DeviceId
    )
{
    try
    {
        CTString tstrMachineName(MachineName);
        CTString tstrDeviceId(DeviceId);
        return DeviceProblemWizard(hwndParent, tstrMachineName, tstrDeviceId);
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return 0;
}

int
DeviceProblemWizard(
    HWND hwndParent,
    LPCTSTR MachineName,
    LPCTSTR DeviceId
    )
{
    DWORD Problem, Status;

    try
    {
        if (!DeviceId)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return 0;
        }

        CMachine TheMachine(MachineName);

        // create the machine just for this device
        if (!TheMachine.Initialize(hwndParent, DeviceId))
        {
            return 0;
        }

        PVOID Context;
        CDevice* pDevice;
        if (!TheMachine.GetFirstDevice(&pDevice, Context))
        {
            SetLastError(SPAPI_E_NO_SUCH_DEVINST);
            return 0;
        }

        if (pDevice->GetStatus(&Status, &Problem)) {

            // if the device is a phantom device, use the CM_PROB_DEVICE_NOT_THERE
            if (pDevice->IsPhantom()) {

                Problem = CM_PROB_PHANTOM;
            }

            // if the device is not started and no problem is assigned to it
            // fake the problem number to be failed start.
            if (!(Status & DN_STARTED) && !Problem && pDevice->IsRAW()) {

                Problem = CM_PROB_FAILED_START;
            }
        }

        CProblemAgent* pProblemAgent = new CProblemAgent(pDevice, Problem, TRUE);

        if (pProblemAgent) {

            pProblemAgent->FixIt(hwndParent);
        }

        return TRUE;
    }

    catch(CMemoryException* e)
    {
        e->Delete();
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return 0;
}

// This API creates a property sheet and asks the given device's property
// provider to add any advanced pages to the property sheet.
// The purpose of this API is for application to manage device advanced
// properties. Standard device property pages(General, Driver, Resource,
// Power, Bus) are not added.
//
// INPUT:
//  hwndParent -- the caller's window handle to be used as the owner
//            window of any widnows this function may create
//  MachineName -- optional machine name. If given, it must be in
//             its fully qualified form. NULL means local machine
//  DeviceId     -- device id.
// OUTPUT:
//  See PropertySheet API for the return value
//
STDAPI_(int)
DeviceAdvancedPropertiesA(
    HWND hwndParent,
    LPTSTR MachineName,
    LPTSTR DeviceId
    )
{
    try
    {
        CTString tstrMachineName(MachineName);
        CTString tstrDeviceID(DeviceId);
        
        return DeviceAdvancedProperties(hwndParent, 
                                        (LPCTSTR)tstrMachineName,
                                        (LPCTSTR)tstrDeviceID
                                        );
    }

    catch (CMemoryException* e)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        e->Delete();
    }

    return 0;
}

STDAPI_(int)
DeviceAdvancedPropertiesW(
    HWND hwndParent,
    LPCWSTR MachineName,
    LPCWSTR DeviceId
    )
{
    try
    {
        CTString tstrMachineName(MachineName);
        CTString tstrDeviceID(DeviceId);
    
        return DeviceAdvancedProperties(hwndParent, 
                                        (LPCTSTR)tstrMachineName,
                                        (LPCTSTR)tstrDeviceID
                                        );
    }

    catch (CMemoryException* e)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        e->Delete();
    }

    return 0;
}

int DeviceAdvancedProperties(
    HWND hwndParent,
    LPCTSTR MachineName,
    LPCTSTR DeviceId
    )
{
    if (!DeviceId)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return -1;
    }

    CMachine TheMachine(MachineName);
    CDevice* pDevice;
    PVOID    Context;
    
    try
    {
        if (TheMachine.Initialize(hwndParent, DeviceId) &&
            TheMachine.GetFirstDevice(&pDevice, Context))
        {

            TheMachine.EnableRefresh(FALSE);

            CPropSheetData& psd = pDevice->m_psd;
        
            //initialize CPropSheetData without ConsoleHandle
            if (psd.Create(g_hInstance, hwndParent, MAX_PROP_PAGES, 0l))
            {
                psd.m_psh.pszCaption = pDevice->GetDisplayName();
                if (TheMachine.DiGetClassDevPropertySheet(*pDevice, &psd.m_psh,
                                       MAX_PROP_PAGES,
                                       TheMachine.IsLocal() ?
                                            DIGCDP_FLAG_ADVANCED :
                                            DIGCDP_FLAG_REMOTE_ADVANCED))
                {
                    int Result = (int)psd.DoSheet();
                    
                    if (-1 != Result)
                    {
                        // merge restart/reboot flags
                        DWORD DiFlags = TheMachine.DiGetFlags(*pDevice);
                        
                        if (DI_NEEDREBOOT & DiFlags)
                        {
                            Result |= ID_PSREBOOTSYSTEM;
                        }

                        if (DI_NEEDRESTART & DiFlags)
                        {
                            Result |= ID_PSRESTARTWINDOWS;
                        }
                    }
            
                    return Result;
                }
            }
        }
    }

    catch (CMemoryException* e)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        e->Delete();
    }

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\api.h ===
#ifndef __API_H__
#define __API_H__

/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    api.h

Abstract:

    header file for api.cpp

    Note that no other file can #include "api.h" because the file contains
    definitions, not just declarations.

Author:

    William Hsieh (williamh) created

Revision History:


--*/



// Exported APIs

// This function launches Device Manager as a separate process.
// This function is provided for any application who wants to
// launch Device Manager but do not want to know the detail about
// MMC.
//
// INPUT: HWND hwndParent     -- the Window Handle of the caller.
//    HINSTANCE hInstance -- The caller's module instance handle
//    LPCTSTR lpMachineName -- optional machine name. NULL for local machine.
//    int nCmdShow      -- controlling how the Device Manager window
//                 to be shown. Refer to Windows API
//                 reference manual for detail.
//  OUTPUT: TRUE if the process is created successfully.
//      FALSE if the process is not created. Use GetLastError()
//        API to retreive error code.

BOOL
DeviceManager_ExecuteA(
    HWND      hwndStub,
    HINSTANCE hAppInstance,
    LPCSTR    lpMachineName,
    int       nCmdShow
    );

STDAPI_(BOOL)
DeviceManager_ExecuteW(
    HWND      hwndStub,
    HINSTANCE hAppInstance,
    LPCWSTR   lpMachineName,
    int       nCmdShow
    );

BOOL
DeviceManager_Execute(
    HWND      hwndStub,
    HINSTANCE hAppInstance,
    LPCTSTR   lpMachineName,
    int       nCmdShow
    );




// This API parses the given command line, creates a property sheet
// for the device ID specified in the command line and
// displays the property sheet.
//
// The command line syntax is:
// /deviceid <DeviceID> [/machinename <Machine Name>] [/showdevicetree]
//
// <DeviceID> specifiec the target device
// <MachineName> specifies the optional computer name.
// ShowDeviceTree, if specifies indicates that device tree should be displayed.
//
STDAPI_(void)
DeviceProperties_RunDLLA(
    HWND hwndStub,
    HINSTANCE hAppInstance,
    LPSTR lpCmdLine,
    int   nCmdShow
    );

STDAPI_(void)
DeviceProperties_RunDLLW(
    HWND hwndStub,
    HINSTANCE hAppInstance,
    LPWSTR lpCmdLine,
    int   nCmdShow
    );

// This function creates and display a property sheet for the given device
// if a valid device id is given. It can also display the device tree
// in the same time(with or without property sheet display).
//
// INPUT: HWND hwndParent  -- the Window Handle of the caller.
//    LPCTSTR MachineName -- optional machine name. If not specified
//               local machine is used.
//    LPCTSTR DeviceId    -- the device ID. Must be provided if
//               ShowDeviceTree is FALSE, otherwise,
//               this function returns 0 and the last
//               error is ERROR_INVALID_PARAMETER
//    DWORD Flags --
//    BOOL ShowDeviceTree -- TRUE if to shwo device tree
//  OUTPUT:
//  0 if error, call GetLastError API to retrieve the error code.
//  1 if succeeded.
//  This function will not return to the caller until the property
//  sheet(or the device tree, if requested) dismissed.
STDAPI_(int)
DevicePropertiesExA(
    HWND hwndParent,
    LPCSTR MachineName,
    LPCSTR DeviceID,
    DWORD Flags,
    BOOL ShowDeviceTree
    );

STDAPI_(int)
DevicePropertiesExW(
    HWND hwndParent,
    LPCWSTR MachineName,
    LPCWSTR DeviceID,
    DWORD Flags,
    BOOL ShowDeviceTree
    );

STDAPI_(int)
DevicePropertiesA(
    HWND hwndParent,
    LPCSTR MachineName,
    LPCSTR DeviceID,
    BOOL ShowDeviceTree
    );

STDAPI_(int)
DevicePropertiesW(
    HWND hwndParent,
    LPCWSTR MachineName,
    LPCWSTR DeviceID,
    BOOL ShowDeviceTree
    );

//
// DevicePropertiesEx Flags
//
#define DEVPROP_SHOW_RESOURCE_TAB       0x00000001
#define DEVPROP_LAUNCH_TROUBLESHOOTER   0x00000002
#define DEVPROP_BITS                    0x00000003


// This function returns the appropriate problem text based on the given
// device and problem number.
//
// INPUT: HMACHINE hMachine   -- Machine handle, NULL for local machine
//    DEVNODE DevNode     -- The device. This paramter is required.
//    ULONG ProblemNumber -- The CM problem number
//    LPTSTR Buffer       -- Buffer to receive the text.
//    UINT   BufferSize   -- Buffer size in chars
//  OUTPUT:
//  0 if the function failed. Call GetLastError API to retreive the
//                error code.
//  <> 0 The required buffer size in chars to receive the text.
//     not including the NULL termianted char.
//     The caller should check this value to decide it has provided
//     enough buffer. ERROR_INSUFFICIENT_BUFFER is not set
//     in this function


STDAPI_(UINT)
DeviceProblemTextA(
    HMACHINE hMachine,
    DEVNODE DevNode,
    ULONG ProblemNumber,
    LPSTR Buffer,
    UINT   BufferSize
    );

STDAPI_(UINT)
DeviceProblemTextW(
    HMACHINE hMachine,
    DEVNODE DevNode,
    ULONG ProblemNumber,
    LPWSTR Buffer,
    UINT   BufferSize
    );



// This function prints the machine's hardware report
//
// INPUT: LPCTSTR MachineName   -- The machine name. NULL for local machine
//    LPCTSTR FileName  -- The file name to which the report
//                 will be written to. If the file already
//                 exist, this function return FALSE.
//                 The caller should delete the file and
//                 call the function again.
//    int     ReportType    -- 0 -- print system summary
//                 1 -- print selected classes
//                 2 -- print all
//    DWORD   ClassGuids    -- number of class guid are in ClassGuidList
//                 Only required if ReportType is 1
//    LPGUID  ClassGuidList -- class guid list. Only required if
//                 ReportType is 1.
//  OUTPUT:
//  TRUE if the function succeeded.
//  FLASE if the function failed. GetLastError() returns the error code
//
//
//
//                error code.
//  <> 0 The required buffer size in chars to receive the text.
//     not including the NULL termianted char.
//     The caller should check this value to decide it has provided
//     enough buffer. ERROR_INSUFFICIENT_BUFFER is not set
//     in this function
STDAPI_(BOOL)
DeviceManagerPrintA(
    LPCSTR MachineName,
    LPCSTR FileName,
    int    ReportType,
    DWORD   ClassGuids,
    LPGUID  ClassGuidList
    );

STDAPI_(BOOL)
DeviceManagerPrintW(
    LPCWSTR MachineName,
    LPCWSTR FileName,
    int     ReportType,
    DWORD   ClassGuids,
    LPGUID  ClassGuidList
    );

BOOL
DeviceManagerDoPrint(
    LPCTSTR MachineName,
    LPCTSTR FileName,
    int     ReportType,
    DWORD   ClassGuids,
    LPGUID  ClassGuidList
    );
//////////////////////////////////////////////////////////////////////////
////////
////////
///////
const TCHAR*    MMC_FILE = TEXT("mmc.exe");
const TCHAR*    DEVMGR_MSC_FILE = TEXT("devmgmt.msc");
const TCHAR*    MMC_COMMAND_LINE = TEXT(" /s ");
const TCHAR*    DEVMGR_MACHINENAME_OPTION = TEXT(" /dmmachinename %s");
const TCHAR*    DEVMGR_DEVICEID_OPTION = TEXT(" /dmdeviceid %s");
const TCHAR*    DEVMGR_COMMAND_OPTION = TEXT(" /dmcommand %s");
const TCHAR*    DEVMGR_CMD_PROPERTY  = TEXT("property");

const TCHAR*    RUNDLL_MACHINENAME     = TEXT("machinename");
const TCHAR*    RUNDLL_DEVICEID        = TEXT("deviceid");
const TCHAR*    RUNDLL_SHOWDEVICETREE  = TEXT("showdevicetree");
const TCHAR*    RUNDLL_FLAGS           = TEXT("flags");


void
ReportCmdLineError(
    HWND hwndParent,
    int  ErrorStringID,
    LPCTSTR Caption = NULL
    );
BOOL AddPageCallback(
    HPROPSHEETPAGE hPage,
    LPARAM lParam
    );

int
PropertyRunDeviceTree(
    HWND hwndParent,
    LPCTSTR MachineName,
    LPCTSTR DeviceID
    );



int
DevicePropertiesEx(
    HWND hwndParent,
    LPCTSTR MachineName,
    LPCTSTR DeviceID,
    DWORD Flags,
    BOOL ShowDeviceTree
    );

void
DeviceProperties_RunDLL(
    HWND hwndStub,
    HINSTANCE hAppInstance,
    LPCTSTR lpCmdLine,
    int    nCmdShow
    );

int
DeviceAdvancedPropertiesA(
    HWND hwndParent,
    LPCSTR MachineName,
    LPCSTR DeviceId
    );

STDAPI_(int)
DeviceAdvancedPropertiesW(
    HWND hwndParent,
    LPCWSTR MachineName,
    LPCWSTR DeviceId
    );
int
DeviceAdvancedProperties(
    HWND hwndParent,
    LPCTSTR MachineName,
    LPCTSTR DeviceId
    );



void
DeviceProblenWizard_RunDLLA(
    HWND hwndStub,
    HINSTANCE hAppInstance,
    LPCTSTR lpCmdLine,
    int    nCmdShow
    );

void
DeviceProblenWizard_RunDLLW(
    HWND hwndStub,
    HINSTANCE hAppInstance,
    LPCTSTR lpCmdLine,
    int    nCmdShow
    );

void
DeviceProblenWizard_RunDLL(
    HWND hwndStub,
    HINSTANCE hAppInstance,
    LPCTSTR lpCmdLine,
    int    nCmdShow
    );


// This function brings up the troubleshooter for the specified 
// DeviceId.
//
// INPUT: HWND hwndParent  -- the Window Handle of the caller.
//    LPCTSTR MachineName -- optional machine name. If not specified
//               local machine is used.
//    LPCTSTR DeviceId    -- the device ID. Must be provided.
//  OUTPUT:
//  0 if error, call GetLastError API to retrieve the error code.
//  1 if succeeded.

STDAPI_(int)
DeviceProblemWizardA(
    HWND      hwndParent,
    LPCSTR    MachineName,
    LPCSTR    DeviceId
    );

STDAPI_(int)
DeviceProblemWizardW(
    HWND    hwndParent,
    LPCWSTR MachineName,
    LPCWSTR DeviceId
    );

int
DeviceProblemWizard(
    HWND hwndParent,
    LPCTSTR MachineName,
    LPCTSTR DeviceId
    );

// Object to parse command line passed in the lpCmdLine parameter
// passed in DeviceProperties_RunDLL APIs
//
class CRunDLLCommandLine : public CCommandLine
{
public:
    CRunDLLCommandLine() : m_ShowDeviceTree(FALSE), m_Flags(0), m_WaitMachineName(FALSE),
        m_WaitDeviceID(FALSE), m_WaitFlags(FALSE)
    {}
    virtual void ParseParam(LPCTSTR Param, BOOL bFlag, BOOL bLast)
    {
        if (bFlag)
        {
            if (!lstrcmpi(RUNDLL_MACHINENAME, Param))
            {
                m_WaitMachineName = TRUE;
            }
            if (!lstrcmpi(RUNDLL_DEVICEID, Param))
            {
                m_WaitDeviceID = TRUE;
            }
            if (!lstrcmpi(RUNDLL_SHOWDEVICETREE, Param))
            {
                m_ShowDeviceTree = TRUE;
            }
            if (!lstrcmpi(RUNDLL_FLAGS, Param)) {
                m_WaitFlags = TRUE;
            }
        }
        else
        {
            if (m_WaitMachineName)
            {
                m_strMachineName = Param;
                m_WaitMachineName = FALSE;
            }
            if (m_WaitDeviceID)
            {
                m_strDeviceID = Param;
                m_WaitDeviceID = FALSE;
            }
            if (m_WaitFlags) {
                m_Flags = (DWORD)StrToInt(Param);
                m_WaitFlags = FALSE;
            }
        }
    }
    LPCTSTR GetMachineName()
    {
        return (m_strMachineName.IsEmpty()) ? NULL : (LPCTSTR)m_strMachineName;
    }
    LPCTSTR GetDeviceID()
    {
        return (m_strDeviceID.IsEmpty()) ? NULL : (LPCTSTR)m_strDeviceID;
    }
    BOOL  ToShowDeviceTree()
    {
        return m_ShowDeviceTree;
    }
    DWORD GetFlags()
    {
        return m_Flags;
    }

private:
    BOOL    m_WaitMachineName;
    BOOL    m_WaitDeviceID;
    BOOL    m_WaitFlags;
    String  m_strDeviceID;
    String  m_strMachineName;
    BOOL    m_ShowDeviceTree;
    DWORD   m_Flags;
};

//
// Object to return the corresponding LPTSTR for the given
// string.
//

class CTString
{
public:
    CTString(LPCWSTR pWString);
    CTString(LPCSTR pString);
    ~CTString()
    {
        if (m_Allocated && m_pTString)
        {
            delete [] m_pTString;
        }
    }
    operator LPCTSTR()
    {
        return (LPCTSTR)m_pTString;
    }
private:
    LPTSTR  m_pTString;
    BOOL    m_Allocated;
};


CTString::CTString(
    LPCWSTR pWString
    )
{
    m_pTString = NULL;
    m_Allocated = FALSE;
#ifdef UNICODE
    m_pTString = (LPTSTR)pWString;
#else
    int wLen = pWString ? wcslen(pWString) : 0;
    
    if (wLen)
    {
        int tLen;
        tLen = WideCharToMultiByte(CP_ACP, 0, pWString, wLen, NULL, 0, NULL, NULL);
        
        if (tLen)
        {
            m_pTString = new TCHAR[tLen + 1];
            WideCharToMultiByte(CP_ACP, 0, pWString, wLen, m_pTString, tLen, NULL, NULL);
            m_pTString[tLen] = _T('\0');
        }
        
        m_Allocated = TRUE;
    }
#endif
}

CTString::CTString(
    LPCSTR pAString
    )
{
    m_pTString = NULL;
    m_Allocated = FALSE;
#ifndef UNICODE
    m_pTString = (LPTSTR)pAString;
#else
    int aLen = pAString ? strlen(pAString) : 0;
    if (aLen)
    {
        int tLen;
        tLen = MultiByteToWideChar(CP_ACP, 0, pAString, aLen, NULL, 0);
        
        if (tLen)
        {
            m_pTString = new TCHAR[tLen + 1];
            MultiByteToWideChar(CP_ACP, 0, pAString, aLen, m_pTString, tLen);
            m_pTString[tLen] = _T('\0');
        }
        
        m_Allocated = TRUE;
    }
#endif
}
#endif // __API_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\clsgenpg.h ===
// clsgenpg.h : header file
//

#ifndef __CLSGENPG_H__
#define __CLSGENPG_H__

/*++

Copyright (C) 1997-  Microsoft Corporation

Module Name:

    clsgenpg.h

Abstract:

    header file for clsgenpg.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "proppage.h"

#define IDH_DISABLEHELP	(DWORD(-1))

class CClassGeneralPage : public CPropSheetPage
{
public:
    CClassGeneralPage() : m_pClass(NULL),
			  CPropSheetPage(g_hInstance, IDD_CLSGEN_PAGE)
	{}
    virtual BOOL OnInitDialog(LPPROPSHEETPAGE ppsp);
    virtual void UpdateControls(LPARAM lParam = 0);
    virtual BOOL OnHelp(LPHELPINFO pHelpInfo);
    virtual BOOL OnContextMenu(HWND hWnd, WORD xPos, WORD yPos);
    virtual UINT DestroyCallback();

    HPROPSHEETPAGE Create(CClass* pClass);

private:
    CClass* m_pClass;
};

#endif // __CLSGENPG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\ccookie.h ===
#ifndef __CCOOKIE__H__
#define __CCOOKIE_H__
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    ccookie.h

Abstract:

    definition and implementation for CCookie class

Author:

    William Hsieh (williamh) created

Revision History:


--*/



class CCookie;
class CResultItem;
class CScopeItem;

class CCookie
{
public:
    CCookie(COOKIE_TYPE ct)
    : m_pScopeItem(NULL), m_pResultItem(NULL), m_Type(ct),
      m_pChild(NULL), m_pSibling(NULL), m_pParent(NULL),
      m_Flags(0), m_lParam(0)
      {
      }

    ~CCookie()
    {
        // delete the subtree
        if (m_pChild)
        delete m_pChild;
        if (m_pSibling)
        delete m_pSibling;
    }
    void SetScopeItem(CScopeItem* pScopeItem)
    {
        // can only set it onece or memory leak could occur
        ASSERT(NULL == m_pScopeItem);
        m_pScopeItem = pScopeItem;

    }
    void SetResultItem(CResultItem* pResultItem)
    {
        // can only set once or memory leak could occur
        ASSERT(NULL == m_pResultItem);
        m_pResultItem = pResultItem;

    }
    COOKIE_TYPE GetType()
    {
        return m_Type;
    }
    CScopeItem* GetScopeItem()
    {
        return m_pScopeItem;
    }
    CResultItem* GetResultItem()
    {
        return m_pResultItem;
    }
    CCookie* GetChild()
    {
        return m_pChild;
    }
    CCookie* GetSibling()
    {
        return m_pSibling;
    }
    CCookie* GetParent()
    {
        return m_pParent;
    }
    void SetChild(CCookie* pCookie)
    {
        m_pChild = pCookie;
    }
    void SetSibling(CCookie* pCookie)
    {
        m_pSibling = pCookie;
    }
    void SetParent(CCookie* pCookie)
    {
        m_pParent = pCookie;
    }
    BOOL IsScopeItem()
    {
        return (!m_pResultItem && m_pScopeItem);
    }
    DWORD IsFlagsOn(DWORD Flags)
    {
        return (m_Flags & Flags);
    }
    void TurnOnFlags(DWORD Flags)
    {
        m_Flags |= Flags;
    }
    void TurnOffFlags(DWORD Flags)
    {
        m_Flags &= ~Flags;
    }
    LPARAM      m_lParam;
private:
    COOKIE_TYPE     m_Type;
    CScopeItem*     m_pScopeItem;
    CResultItem*    m_pResultItem;
    CCookie*        m_pParent;
    CCookie*        m_pSibling;
    CCookie*        m_pChild;
    DWORD       m_Flags;
};
#endif // __CCOOKIE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\cfolder.h ===
#ifndef __CFOLDER_H__
#define __CFOLDER_H__
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    cfolder.h

Abstract:

    header file for cfolder.cpp.

Author:

    William Hsieh (williamh) created

Revision History:


--*/

class CFolder;
class CResultView;
class CViewTreeByType;
class CViewTreeByConnection;
class CViewResourceTree;
class CComponent;

const int IMAGE_INDEX_START = 20;
const int IMAGE_INDEX_DEVMGR    = IMAGE_INDEX_START;
const int OPEN_IMAGE_INDEX_DEVMGR = IMAGE_INDEX_DEVMGR;

typedef enum tagViewType {
    VIEW_DEVICESBYTYPE = 0,
    VIEW_DEVICESBYCONNECTION,
    VIEW_RESOURCESBYTYPE,
    VIEW_RESOURCESBYCONNECTION,
    VIEW_NONE
}VIEWTYPE, *PVIEWTYPE;

typedef struct tagMMCMenuItem {
    int     idName;
    int     idStatusBar;
    long    lCommandId;
    VIEWTYPE Type;
}MMCMENUITEM, *PMMCMENUITEM;

const VIEWTYPE VIEW_FIRST = VIEW_DEVICESBYTYPE;
const VIEWTYPE VIEW_LAST = VIEW_RESOURCESBYCONNECTION;

const int TOTAL_VIEWS = VIEW_LAST - VIEW_FIRST + 1;
const int TOTAL_RESOURCE_TYPES = 4;

extern const MMCMENUITEM ViewDevicesMenuItems[];

typedef struct tagDevMgrFolderStates {
    COOKIE_TYPE Type;
    VIEWTYPE    CurViewType;
    BOOL        ShowHiddenDevices;
}DEVMGRFOLDER_STATES, *PDEVMGRFOLDER_STATES;

typedef DWORD FOLDER_SIGNATURE;

const FOLDER_SIGNATURE_DEVMGR  = 0x00FF00FF;

//
// This is the class created and maintained by IComponentData
//
class CScopeItem {
public:
    CScopeItem(COOKIE_TYPE ct, int iImage, int iOpenImage, int iNameStringId, int iDescStringId, int iDisplayNameFormatId)
    {
        m_iImage = iImage;
        m_iOpenImage = iOpenImage;
        m_iNameStringId = iNameStringId;
        m_iDescStringId = iDescStringId;
        m_Enumerated = FALSE;
        m_hScopeItem = NULL;
        m_Type = ct;
    }
    virtual CFolder* CreateFolder(CComponent* pComponent);
    virtual HRESULT AddMenuItems(LPCONTEXTMENUCALLBACK pCallback, long* pInsertionAllowed);
    virtual HRESULT MenuCommand(long lCommandId);
    virtual HRESULT QueryPagesFor();
    virtual HRESULT CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                        LONG_PTR handle);
    virtual ~CScopeItem();
    virtual BOOL Create();
    HRESULT GetDisplayInfo(LPSCOPEDATAITEM pScopeDataItem);
    void SetScopeItemID(HSCOPEITEM hScopeItem)
    {
        m_hScopeItem = hScopeItem;
    }
    const int   GetImageIndex() const
    {
        return m_iImage;
    }
    const int   GetOpenImageIndex() const
    {
        return m_iOpenImage;
    }
    const TCHAR* GetNameString()    const
    {
        return(LPCTSTR)m_strName;
    }
    const TCHAR* GetDescString() const
    {
        return(LPCTSTR)m_strDesc;
    }
    operator HSCOPEITEM()
    {
        return m_hScopeItem;
    }
    BOOL EnumerateChildren(int Index, CScopeItem** ppChild);
    int  GetChildCount()
    {
        return m_listChildren.GetCount();
    }
    COOKIE_TYPE GetType()
    {
        return m_Type;
    }
    void SetHandle(HSCOPEITEM hScopeItem)
    {
        m_hScopeItem = hScopeItem;
    }

    BOOL IsEnumerated()
    {
        return m_Enumerated;
    }
    void Enumerated()
    {
        m_Enumerated = TRUE;
    }
    HRESULT Reset();

protected:
    CCookie* FindSelectedCookieData(CResultView** ppResultView);
    int        m_iNameStringId;
    int        m_iDescStringId;
    int        m_iImage;
    int        m_iOpenImage;
    String    m_strName;
    String    m_strDesc;
    BOOL       m_Enumerated;
    HSCOPEITEM m_hScopeItem;
    COOKIE_TYPE m_Type;
    CList<CFolder*, CFolder*> m_listFolder;
    CList<CScopeItem*, CScopeItem*> m_listChildren;
};


// While ScopeItem objects are created and managed by CComponentData,
// CFolder objects are created and managed by CComponent class.
// CComponent objects are created and managed by CComponentData.
// A CComponent object is created when a new window is created.
// For each CScopeItem, CComponent creates a CFolder object to
// represent that CScopeItem in the CComponent's window.
// CFolder is responsible for painting the result pane that represents
// the visual states of its associated CScopeItem.
//
class CFolder {
public:
    CFolder(CScopeItem* pScopeItem, CComponent* pComponent);
    virtual ~CFolder();

    virtual HRESULT Compare(MMC_COOKIE cookieA, MMC_COOKIE cookieB, int nCol, int* pnResult);
    virtual HRESULT GetDisplayInfo(LPRESULTDATAITEM pResultDataItem);
    virtual HRESULT AddMenuItems(CCookie* pCookie, LPCONTEXTMENUCALLBACK pCallback, long* pInsertionAllowed);
    virtual HRESULT MenuCommand(CCookie* pCookie, long lCommandId);
    virtual HRESULT QueryPagesFor(CCookie* pCookie);
    virtual HRESULT CreatePropertyPages(CCookie* pCookie, LPPROPERTYSHEETCALLBACK lpProvider,
                                        LONG_PTR handle);
    virtual HRESULT OnShow(BOOL fShow);
    virtual HRESULT GetResultViewType(LPOLESTR* ppViewType, long* pViewOptions);
    virtual CResultView* GetCurResultView()
    {
        return m_pCurView;
    }
    virtual int GetPersistDataSize()
    {
        return sizeof(DEVMGRFOLDER_STATES);
    }
    virtual HRESULT GetPersistData(PBYTE pBuffer, int BufferSize);
    virtual HRESULT SetPersistData(PBYTE pData, int Size);
    LPCTSTR GetNameString()
    {
        return m_pScopeItem->GetNameString();
    }
    LPCTSTR GetDescString()
    {
        return m_pScopeItem->GetDescString();
    }
    FOLDER_SIGNATURE GetSignature()
    {
        return m_Signature;
    }
    virtual HRESULT tvNotify(HWND hwndTV, CCookie* pCookie, TV_NOTIFY_CODE Code, LPARAM arg, LPARAM param);
    virtual HRESULT MachinePropertyChanged(CMachine* pMachine);
    virtual HRESULT OnOcxNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    virtual HRESULT OnRestoreView(BOOL* pfHandled);
    virtual HRESULT OnSelect()
    {
        // If the folder is selected, reset the console verbs.
        if (m_bSelect)
            return S_FALSE;
        else
            return S_OK;
    }
    ULONG AddRef()
    {
        return ++m_Ref;
    }
    ULONG Release()
    {
        ASSERT(m_Ref);
        --m_Ref;

        if (!m_Ref) {
            delete this;
            return 0;
        }
        return m_Ref;
    }
    virtual HRESULT Reset();
    BOOL ShowHiddenDevices()
    {
        return m_ShowHiddenDevices;
    }
    BOOL SelectView(VIEWTYPE ViewType, BOOL fShowHiddenDevices);
    HRESULT DoProperties(HWND hwndParent, CCookie* pCookie);
    CComponent*     m_pComponent;
    CScopeItem*     m_pScopeItem;
    CMachine*       m_pMachine;
    BOOL            m_bSelect;          // Saved by MMCN_SELECT for MenuCommand

protected:
    FOLDER_SIGNATURE m_Signature;
    BOOL        m_Show;
    String      m_strScratch;
    LPOLESTR    m_pOleTaskString;
    ULONG       m_Ref;

private:
    CViewTreeByType*        m_pViewTreeByType;
    CViewTreeByConnection*  m_pViewTreeByConnection;
    CViewResourceTree*      m_pViewResourcesByType;
    CViewResourceTree*      m_pViewResourcesByConnection;
    CResultView*            m_pCurView;
    VIEWTYPE                m_CurViewType;
    BOOL                    m_ShowHiddenDevices;
    BOOL                    m_FirstTimeOnShow;
};

class CResultView {
public:
    CResultView(int DescStringId) :
        m_DescStringId(DescStringId),
        m_pFolder(NULL),
        m_pMachine(NULL),
        m_pCookieComputer(NULL),
        m_pIDMTVOCX(NULL),
        m_hwndTV(NULL),
        m_pSelectedCookie(NULL),
        m_SelectOk(FALSE),
        m_pSelectedItem(NULL)
    {
        String stringWorking, stringProblem, stringDisabled, stringForced;

        stringWorking.LoadString(g_hInstance, IDS_ANNOTATION_WORKING);
        stringProblem.LoadString(g_hInstance, IDS_ANNOTATION_PROBLEM);
        stringDisabled.LoadString(g_hInstance, IDS_ANNOTATION_DISABLED);
        stringForced.LoadString(g_hInstance, IDS_ANNOTATION_FORCED);

        m_stringAnnotationMap.Format(TEXT("A:2:%d:%s:%d:%s:%d:%s:%d:%s:"),
            0,
            (LPTSTR)stringWorking,
            (IDI_PROBLEM_OVL - IDI_CLASSICON_OVERLAYFIRST + 1),
            (LPTSTR)stringProblem,
            (IDI_DISABLED_OVL - IDI_CLASSICON_OVERLAYFIRST + 1),
            (LPTSTR)stringDisabled,
            (IDI_FORCED_OVL - IDI_CLASSICON_OVERLAYFIRST + 1),
            (LPTSTR)stringForced);
    }
    virtual ~CResultView();
    virtual HRESULT GetDisplayInfo(LPRESULTDATAITEM pResultDataItem)
    {
        return S_OK;
    }
    virtual HRESULT OnShow(BOOL fShow);
    LPCTSTR GetStartupDeviceId();
    LPCTSTR GetStartupCommand();
    void SetFolder(CFolder* pFolder)
    {
        m_pFolder = pFolder;
    }
    int GetDescriptionStringID()
    {
        return m_DescStringId;
    }
    virtual CCookie* GetSelectedCookie()
    {
        return m_pSelectedCookie;
    }
    void SetSelectOk(BOOL fSelect)
    {
        m_SelectOk = fSelect;
    }
    HRESULT MachinePropertyChanged(CMachine* pMachine);
    void SaveTreeStates(CCookie* pCookieStart);
    void DestroySavedTreeStates();
    void RestoreSavedTreeState(CCookie* pCookie);
    BOOL DisplayTree();
    HRESULT GetResultViewType(LPOLESTR* ppViewType, long* pViewOptions);
    HRESULT AddMenuItems(CCookie* pCookie, LPCONTEXTMENUCALLBACK pCallback,
                         long* pInsertionAllowed, BOOL fContextMenu);
    HRESULT MenuCommand(CCookie* pCookie, long lCommandId);
    HRESULT QueryPagesFor(CCookie* pCookie);
    HRESULT CreatePropertyPages(CCookie* pCookie, LPPROPERTYSHEETCALLBACK pProvider, LONG_PTR handle);
    HRESULT tvNotify(HWND hwndTV, CCookie* pCookie, TV_NOTIFY_CODE Code, LPARAM arg, LPARAM param);
    HRESULT OnOcxNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    HRESULT DoProperties(HWND hwndParent, CCookie* pCookie);
    HRESULT DoContextMenu(HWND hwndParent, CCookie* pCookie, POINT* pPoint);
    HRESULT DoPrint();

protected:
    BOOL    DisplaySubtree(HTREEITEM htiParent, CCookie* pCookieStart, BOOL* pReportProblem = NULL);
    HRESULT UpdateConsoleVerbs(CCookie* pCookie);
    CFolder*    m_pFolder;
    int         m_DescStringId;
    CMachine*   m_pMachine;
    CCookie*    m_pCookieComputer;
    IDMTVOCX*   m_pIDMTVOCX;
    CCookie*    m_pSelectedCookie;
    BOOL        m_SelectOk;
    HWND        m_hwndTV;
    CList<CItemIdentifier*, CItemIdentifier*> m_listExpandedItems;
    CItemIdentifier*        m_pSelectedItem;
    String      m_stringAnnotationMap;

private:
    HRESULT RemoveDevice(CDevice* pDevice);
};

class CViewDeviceTree : public CResultView {
public:
    CViewDeviceTree(int DescStringId)
        : CResultView(DescStringId)
        {}
    virtual ~CViewDeviceTree() {}
    virtual HRESULT OnShow(BOOL fShow);
    virtual BOOL  CreateDeviceTree();

protected:
private:
};

class CViewTreeByType : public CViewDeviceTree {
public:
    CViewTreeByType()
        : CViewDeviceTree(IDS_STATUS_DEVICES_BYTYPE)
        {}
    virtual BOOL CreateDeviceTree();
};

class CViewTreeByConnection : public CViewDeviceTree {
public:
    CViewTreeByConnection()
        : CViewDeviceTree(IDS_STATUS_DEVICES_BYCONN)
        {}
    virtual BOOL CreateDeviceTree();
private:
    BOOL CreateSubtree(CCookie* pCookieParent, CCookie* pCookieSibling, CDevice* pDeviceStart);
};

class CViewResourceTree : public CResultView {
public:
    CViewResourceTree(int DescStringId)
    : CResultView(DescStringId)
    {
        int i;

        for (i = 0; i < TOTAL_RESOURCE_TYPES; i++) {
            m_pResourceList[i] = NULL;
            m_pResourceType[i] = NULL;
        }
    }
    ~CViewResourceTree();
    virtual HRESULT OnShow(BOOL fShow);
protected:
    private:
    void    CreateResourceTree();
    void    CreateResourceSubtree(CCookie* pCookieParent,
                                  CCookie* pCookieSibling,
                                  CDevice* pDevice, CCookie** ppLastCookie = NULL);
    BOOL    InsertCookieToTree(CCookie* pCookie, CCookie* pCookieStart,
                               BOOL ForcedInsert);
    void    DestroyResourceTree();
    CResourceList*  m_pResourceList[TOTAL_RESOURCE_TYPES];
    CResourceType*  m_pResourceType[TOTAL_RESOURCE_TYPES];
};

typedef BOOL (CALLBACK* PROPSHEET_PROVIDER_PROC)(
                                                PSP_PROPSHEETPAGE_REQUEST   PropPageRequest,
                                                LPFNADDPROPSHEETPAGE    lpfnAddPropPageProc,
                                                LPARAM          lParam
                                                );

class CPropPageProvider {
public:
    CPropPageProvider() : m_hDll(NULL)
    {}
    virtual ~CPropPageProvider()
    {
        if (m_hDll)
            FreeLibrary(m_hDll);
    }
    virtual BOOL EnumPages(CDevice* pDevice, CPropSheetData* ppsd) = 0;
protected:
    HMODULE m_hDll;
};

class CBusPropPageProvider : public CPropPageProvider {
public:
    virtual BOOL EnumPages(CDevice* pDevice, CPropSheetData* ppsd);
};

#endif // __CFOLDER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\cdriver.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    CDriver.cpp

Abstract:

    This module implements CDriver and CService classes

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "devmgr.h"
#include "cdriver.h"

const TCHAR*  tszStringFileInfo = TEXT("StringFileInfo\\%04X%04X\\");
const TCHAR*  tszFileVersion = TEXT("FileVersion");
const TCHAR*  tszLegalCopyright = TEXT("LegalCopyright");
const TCHAR*  tszCompanyName = TEXT("CompanyName");
const TCHAR*  tszTranslation = TEXT("VarFileInfo\\Translation");
const TCHAR*  tszStringFileInfoDefault = TEXT("StringFileInfo\\040904B0\\");


BOOL
CDriver::Create(
    CDevice* pDevice,
    PSP_DRVINFO_DATA pDrvInfoData
    )
{
    HKEY hKey;
    TCHAR InfPath[MAX_PATH];
    TCHAR InfName[MAX_PATH];

    ASSERT(pDevice);

    m_pDevice = pDevice;
    m_OnLocalMachine  = pDevice->m_pMachine->IsLocal();

    CMachine* pMachine = m_pDevice->m_pMachine;

    ASSERT(pMachine);

    //
    // We can't get the digital signer on remote machines
    //
    if (!m_OnLocalMachine) {
        return TRUE;
    }

    m_hSDBDrvMain = SdbInitDatabase(SDB_DATABASE_MAIN_DRIVERS, NULL);

    //
    // Open drvice's driver registry key to get the InfPath
    //
    hKey = pMachine->DiOpenDevRegKey(*m_pDevice, DICS_FLAG_GLOBAL,
                 0, DIREG_DRV, KEY_READ);

    if (INVALID_HANDLE_VALUE != hKey) {

        DWORD regType;
        DWORD Len = sizeof(InfName);
        CSafeRegistry regDrv(hKey);

        //
        // Get the inf path from the driver key
        //
        if (regDrv.GetValue(REGSTR_VAL_INFPATH,
                            &regType,
                            (PBYTE)InfName,
                            &Len)) {


            if (GetSystemWindowsDirectory(InfPath, ARRAYLEN(InfPath))) {

                if (lstrlen(InfPath))
                {
                    //
                    // Tack on an extra back slash if one is needed
                    //
                    if (_T('\\') != InfPath[lstrlen(InfPath) - 1])
                    {
                        lstrcat(InfPath, TEXT("\\"));
                    }

                    lstrcat(InfPath, TEXT("INF\\"));
                    lstrcat(InfPath, InfName);

                    pMachine->GetDigitalSigner(InfPath, m_DigitalSigner);
                }
            }
        }
    }

    return TRUE;
}

BOOL
CDriver::BuildDriverList(
    PSP_DRVINFO_DATA pDrvInfoData,
    BOOL             bFunctionAndFiltersOnly
    )
{
    SP_DRVINFO_DATA DrvInfoData;
    HSPFILEQ hFileQueue = INVALID_HANDLE_VALUE;
    SP_DEVINSTALL_PARAMS DevInstParams;

    //
    // If we already built up the list of driver files then we don't need
    // to do it again.
    //
    if (m_DriverListBuilt) {
        return m_listDriverFile.GetCount();
    }

    ASSERT(m_pDevice);

    if (!m_OnLocalMachine) {
        AddFunctionAndFilterDrivers(m_pDevice);
        return m_listDriverFile.GetCount();
    }

    CMachine* pMachine = m_pDevice->m_pMachine;
    ASSERT(pMachine);

    hFileQueue = SetupOpenFileQueue();

    //
    // Only build up the list of files from the INF if bFunctionAndFiltersOnly
    // is not TRUE.
    //
    if (!bFunctionAndFiltersOnly) {
        DevInstParams.cbSize = sizeof(DevInstParams);

        if (!pDrvInfoData) {

            pMachine->DiGetDeviceInstallParams(*m_pDevice, &DevInstParams);

            //
            // Set the DI_FLAGSEX_INSTALLEDDRIVER flag before calling SetupDiBuildDriverInfoList.
            // This will have it only put the installed driver into the list.
            //
            DevInstParams.FlagsEx |= (DI_FLAGSEX_INSTALLEDDRIVER |
                                      DI_FLAGSEX_ALLOWEXCLUDEDDRVS);

            if (pMachine->DiSetDeviceInstallParams(*m_pDevice,
                               &DevInstParams) &&
                pMachine->DiBuildDriverInfoList(*m_pDevice,
                                                SPDIT_CLASSDRIVER)) {


                DrvInfoData.cbSize = sizeof(DrvInfoData);

                //
                // There should only be one driver in this list.  If there isn't any
                // drivers in this list then there must not be a driver currently
                // installed on this device.
                //
                if (pMachine->DiEnumDriverInfo(*m_pDevice, SPDIT_CLASSDRIVER, 0, &DrvInfoData)) {

                    //
                    // Set this as the selected driver
                    //
                    pMachine->DiSetSelectedDriver(*m_pDevice, &DrvInfoData);

                    pDrvInfoData = &DrvInfoData;

                } else {

                    //
                    // We did not find a match...so just destroy it.
                    //
                    pMachine->DiDestroyDriverInfoList(*m_pDevice,
                                                      SPDIT_CLASSDRIVER);

                    pDrvInfoData = NULL;
                }
            }
        }

        if (pDrvInfoData) {


            //
            // Get a list of all the files installed for this device
            //
            if (INVALID_HANDLE_VALUE != hFileQueue) {

                DevInstParams.FileQueue = hFileQueue;
                DevInstParams.Flags |= DI_NOVCP;

                if (pMachine->DiSetDeviceInstallParams(*m_pDevice, &DevInstParams) &&
                    pMachine->DiCallClassInstaller(DIF_INSTALLDEVICEFILES, *m_pDevice)) {
                    //
                    // Dereference the file queue so that we can close it
                    //
                    DevInstParams.FileQueue = NULL;
                    DevInstParams.Flags &= ~DI_NOVCP;
                    pMachine->DiSetDeviceInstallParams(*m_pDevice, &DevInstParams);
                }
            }

            if (pDrvInfoData == &DrvInfoData) {
                pMachine->DiDestroyDriverInfoList(*m_pDevice, SPDIT_CLASSDRIVER);
            }
        }
    }

    //
    // Add the funtion and device and class upper and lower filters, sometimes
    // these aren't added via the INF file directly so this makes sure they
    // show up in the list.
    //
    AddFunctionAndFilterDrivers(m_pDevice, hFileQueue);

    if (hFileQueue != INVALID_HANDLE_VALUE) {
        //
        // Scan the file queue.
        //
        DWORD ScanResult;
        SetupScanFileQueue(hFileQueue,
                           SPQ_SCAN_USE_CALLBACK_SIGNERINFO,
                           NULL,
                           ScanQueueCallback,
                           (PVOID)this,
                           &ScanResult
                           );

        //
        // Close the file queue
        //
        SetupCloseFileQueue(hFileQueue);
    }

    m_DriverListBuilt = TRUE;

    return m_listDriverFile.GetCount();
}

void
CDriver::AddDriverFile(
    CDriverFile* pNewDrvFile
    )
{
    //
    // Check to see if this driver already exists in the list.
    //
    POSITION pos = m_listDriverFile.GetHeadPosition();

    while (NULL != pos) {
        CDriverFile* pDrvFile = m_listDriverFile.GetNext(pos);

        if (lstrcmpi(pDrvFile->GetFullPathName(), pNewDrvFile->GetFullPathName()) == 0) {
            //
            // This file already exists in the list so just return without
            // adding it.
            //
            return;
        }
    }

    m_listDriverFile.AddTail(pNewDrvFile);
}

void
CDriver::AddFunctionAndFilterDrivers(
    CDevice* pDevice,
    HSPFILEQ hFileQueue
    )
{
    TCHAR ServiceName[MAX_PATH];
    ULONG BufferLen;
    HKEY hKey;
    DWORD regType;

    //
    // Get the function driver
    //
    if (pDevice->m_pMachine->DiGetDeviceRegistryProperty(*pDevice,
                     SPDRP_SERVICE,
                     NULL,
                     (PBYTE)ServiceName,
                     sizeof(ServiceName),
                     NULL
                     )) {
        CreateFromService(pDevice, ServiceName, hFileQueue);
    }

    //
    // Add the upper and lower device filters
    //
    for (int i = 0; i<2; i++) {
        BufferLen = 0;
        pDevice->m_pMachine->DiGetDeviceRegistryProperty(
                *pDevice,
                i ? SPDRP_LOWERFILTERS : SPDRP_UPPERFILTERS,
                NULL,
                NULL,
                BufferLen,
                &BufferLen
                );

        if (BufferLen != 0) {
            PTSTR Buffer = new TCHAR[BufferLen+2];

            if (Buffer) {
                ZeroMemory(Buffer, BufferLen+2);

                if (pDevice->m_pMachine->DiGetDeviceRegistryProperty(
                        *pDevice,
                        i ? SPDRP_LOWERFILTERS : SPDRP_UPPERFILTERS,
                        NULL,
                        (PBYTE)Buffer,
                        BufferLen,
                        &BufferLen
                        )) {
                    for (PTSTR SingleItem = Buffer; *SingleItem; SingleItem += (lstrlen(SingleItem) + 1)) {
                        CreateFromService(pDevice, SingleItem, hFileQueue);
                    }
                }

                delete Buffer;
            }
        }
    }

    //
    // Add the upper and lower class filters
    //
    GUID ClassGuid;
    pDevice->ClassGuid(ClassGuid);
    hKey = m_pDevice->m_pMachine->DiOpenClassRegKey(&ClassGuid, KEY_READ, DIOCR_INSTALLER);

    if (INVALID_HANDLE_VALUE != hKey) {

        CSafeRegistry regClass(hKey);

        for (int i = 0; i<2; i++) {
            BufferLen = 0;
            regClass.GetValue(i ? REGSTR_VAL_LOWERFILTERS : REGSTR_VAL_UPPERFILTERS,
                              &regType,
                              NULL,
                              &BufferLen
                              );
            if (BufferLen != 0) {
                PTSTR Buffer = new TCHAR[BufferLen+2];

                if (Buffer) {
                    ZeroMemory(Buffer, BufferLen+2);

                    if (regClass.GetValue(i ? REGSTR_VAL_LOWERFILTERS : REGSTR_VAL_UPPERFILTERS,
                              &regType,
                              (PBYTE)Buffer,
                              &BufferLen
                              )) {
                        for (PTSTR SingleItem = Buffer; *SingleItem; SingleItem += (lstrlen(SingleItem) + 1)) {
                            CreateFromService(pDevice, SingleItem, hFileQueue);
                        }
                    }

                    delete Buffer;
                }
            }
        }
    }

}

void
CDriver::CreateFromService(
    CDevice* pDevice,
    PCTSTR ServiceName,
    HSPFILEQ hFileQueue
    )
{
    SC_HANDLE hscManager = NULL;
    SC_HANDLE hscService = NULL;

    if (!ServiceName) {
        return;
    }

    try
    {
        BOOL ComposePathNameFromServiceName = TRUE;

        // open default database on local machine for now
        hscManager = OpenSCManager(m_OnLocalMachine ? NULL : pDevice->m_pMachine->GetMachineFullName(),
                       NULL, GENERIC_READ);

        if (NULL != hscManager)
        {
            hscService =  OpenService(hscManager, ServiceName, GENERIC_READ);
            if (NULL != hscService)
            {
                QUERY_SERVICE_CONFIG qsc;
                DWORD BytesRequired;

                // first, probe for buffer size
                if (!QueryServiceConfig(hscService, NULL, 0, &BytesRequired) &&
                    ERROR_INSUFFICIENT_BUFFER == GetLastError())
                {
                    TCHAR FullPath[MAX_PATH];
                    BufferPtr<BYTE> BufPtr(BytesRequired);
                    LPQUERY_SERVICE_CONFIG pqsc;
                    pqsc = (LPQUERY_SERVICE_CONFIG)(PBYTE)BufPtr;
                    DWORD Size;

                    if (QueryServiceConfig(hscService, pqsc, BytesRequired, &Size) &&
                        pqsc->lpBinaryPathName &&
                        (TEXT('\0') != pqsc->lpBinaryPathName[0]))
                    {
                        ComposePathNameFromServiceName = FALSE;

                        //
                        // Make sure we have a valid full path.
                        //
                        if (GetFullPathFromImagePath(pqsc->lpBinaryPathName,
                                                     FullPath,
                                                     ARRAYLEN(FullPath))) {

                            if (hFileQueue != INVALID_HANDLE_VALUE) {
                                //
                                // Add the file to the queue.
                                //
                                TCHAR TargetPath[MAX_PATH];
                                lstrcpy(TargetPath, FullPath);
                                PTSTR p = (PTSTR)StrRChr(TargetPath, NULL, TEXT('\\'));
                                if (p) {
                                    *p = TEXT('\0');
                                }

                                SetupQueueCopy(hFileQueue,
                                               NULL,
                                               NULL,
                                               MyGetFileTitle(FullPath),
                                               NULL,
                                               NULL,
                                               TargetPath,
                                               NULL,
                                               0
                                               );
                            } else {
                                //
                                // No file queue was passed in so just manually
                                // add this to our list of driver files.
                                //
                                SafePtr<CDriverFile> DrvFilePtr;
                                CDriverFile* pDrvFile = new CDriverFile();
                                DrvFilePtr.Attach(pDrvFile);

                                //
                                // We will set the GetWin32Error to 0xFFFFFFFF which will
                                // cause the UI to say 'not available' for the
                                // signature.
                                //
                                if (pDrvFile->Create(FullPath,
                                                     m_OnLocalMachine,
                                                     0xFFFFFFFF,
                                                     NULL,
                                                     m_hSDBDrvMain))
                                {
                                    AddDriverFile(pDrvFile);
                                    DrvFilePtr.Detach();
                                }
                            }
                        }
                    }
                }

                CloseServiceHandle(hscService);
                hscService = NULL;
            }

            CloseServiceHandle(hscManager);
            hscManager = NULL;
        }

        if (ComposePathNameFromServiceName)
        {
            TCHAR FullPathName[MAX_PATH];
            TCHAR SysDir[MAX_PATH];
            
            if ((GetSystemDirectory(SysDir, ARRAYLEN(SysDir)) != 0) &&
                SUCCEEDED(StringCchCopy(FullPathName, ARRAYLEN(FullPathName), SysDir)) &&
                SUCCEEDED(StringCchCat(FullPathName, ARRAYLEN(FullPathName), TEXT("\\drivers\\"))) &&
                SUCCEEDED(StringCchCat(FullPathName, ARRAYLEN(FullPathName), ServiceName)) &&
                SUCCEEDED(StringCchCat(FullPathName, ARRAYLEN(FullPathName), TEXT(".sys")))) {
    
                if (hFileQueue != INVALID_HANDLE_VALUE) {
                    //
                    // Add the file to the queue.
                    //
                    TCHAR TargetPath[MAX_PATH];
                    lstrcpy(TargetPath, FullPathName);
                    PTSTR p = (PTSTR)StrRChr(TargetPath, NULL, TEXT('\\'));
                    if (p) {
                        *p = TEXT('\0');
                    }
    
                    SetupQueueCopy(hFileQueue,
                                   NULL,
                                   NULL,
                                   MyGetFileTitle(FullPathName),
                                   NULL,
                                   NULL,
                                   TargetPath,
                                   NULL,
                                   0
                                   );
                } else {
                    //
                    // No file queue was passed in so just manually
                    // add this to our list of driver files.
                    //
                    SafePtr<CDriverFile> DrvFilePtr;
                    CDriverFile* pDrvFile = new CDriverFile();
                    DrvFilePtr.Attach(pDrvFile);
    
                    //
                    // We will set the GetWin32Error to 0xFFFFFFFF which will
                    // cause the UI to say 'not available' for the
                    // signature.
                    //
                    if (pDrvFile->Create(FullPathName,
                                         m_OnLocalMachine,
                                         0xFFFFFFFF,
                                         NULL,
                                         m_hSDBDrvMain))
                    {
                        AddDriverFile(pDrvFile);
                        DrvFilePtr.Detach();
                    }
                }
            }
        }
    }

    catch (CMemoryException* e)
    {
        if (hscService)
        {
            CloseServiceHandle(hscService);
        }

        if (hscManager)
        {
            CloseServiceHandle(hscManager);
        }
        throw;
    }
}

CDriver::~CDriver()
{
    if (!m_listDriverFile.IsEmpty())
    {
        POSITION pos = m_listDriverFile.GetHeadPosition();

        while (NULL != pos) {
            CDriverFile* pDrvFile = m_listDriverFile.GetNext(pos);
            delete pDrvFile;
        }

        m_listDriverFile.RemoveAll();
    }

    if (m_hSDBDrvMain) {
        SdbReleaseDatabase(m_hSDBDrvMain);
    }
}

BOOL
CDriver::operator ==(
    CDriver& OtherDriver
    )
{
    CDriverFile* pThisDrvFile;
    CDriverFile* pOtherDrvFile;
    BOOL DrvFileFound = FALSE;
    PVOID ThisContext, OtherContext;
    if (GetFirstDriverFile(&pThisDrvFile, ThisContext))
    {
        do {

            DrvFileFound = FALSE;

            if (OtherDriver.GetFirstDriverFile(&pOtherDrvFile, OtherContext))
            {
                do {
                    if (*pThisDrvFile == *pOtherDrvFile)
                    {
                        DrvFileFound = TRUE;
                        break;
                    }

                } while (OtherDriver.GetNextDriverFile(&pOtherDrvFile, OtherContext));
            }

        } while (DrvFileFound && GetNextDriverFile(&pThisDrvFile, ThisContext));

        return DrvFileFound;
    }

    else
    {
        // if both do not have driver file, they are equal.
        return !OtherDriver.GetFirstDriverFile(&pOtherDrvFile, OtherContext);
    }
}

//
// Can not throw a exception from this function because it is a callback
//
UINT
CDriver::ScanQueueCallback(
    PVOID Context,
    UINT  Notification,
    UINT_PTR  Param1,
    UINT_PTR  Param2
    )
{
    try
    {
        if (SPFILENOTIFY_QUEUESCAN_SIGNERINFO == Notification && Param1)
        {
            CDriver* pDriver = (CDriver*)Context;

            if (pDriver)
            {
                SafePtr<CDriverFile> DrvFilePtr;
                CDriverFile* pDrvFile = new CDriverFile();
                DrvFilePtr.Attach(pDrvFile);

                //
                // When creating the CDriver set the Win32Error to 0xFFFFFFFF
                // if the user is loged in as a guest.  This is because we
                // cannot tell if a file is digitally signed if the user is
                // a guest.  If the user is not a guest then use the Win32Error
                // returned from setupapi.
                //
                if (pDrvFile->Create((LPCTSTR)((PFILEPATHS_SIGNERINFO)Param1)->Target,
                                     pDriver->IsLocal(),
                                     pDriver->m_pDevice->m_pMachine->IsUserAGuest()
                                       ? 0xFFFFFFFF
                                       : ((PFILEPATHS_SIGNERINFO)Param1)->Win32Error,
                                     ((PFILEPATHS_SIGNERINFO)Param1)->DigitalSigner,
                                     pDriver->m_hSDBDrvMain
                                     ))
                {
                    pDriver->AddDriverFile(pDrvFile);
                    DrvFilePtr.Detach();
                }
            }
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    return NO_ERROR;
}

BOOL
CDriver::GetFirstDriverFile(
    CDriverFile** ppDrvFile,
    PVOID&  Context
    )
{
    ASSERT(ppDrvFile);

    if (!m_listDriverFile.IsEmpty())
    {
        POSITION pos = m_listDriverFile.GetHeadPosition();
        *ppDrvFile = m_listDriverFile.GetNext(pos);
        Context = pos;
        return TRUE;
    }

    Context = NULL;
    *ppDrvFile = NULL;

    return FALSE;
}

BOOL
CDriver::GetNextDriverFile(
    CDriverFile** ppDrvFile,
    PVOID&  Context
    )
{
    ASSERT(ppDrvFile);

    POSITION pos = (POSITION)Context;

    if (NULL != pos)
    {
        *ppDrvFile = m_listDriverFile.GetNext(pos);
        Context = pos;
        return TRUE;
    }

    *ppDrvFile = NULL;
    return FALSE;
}

void
CDriver::GetDriverSignerString(
    String& strDriverSigner
    )
{
    if (m_DigitalSigner.IsEmpty()) {

        strDriverSigner.LoadString(g_hInstance, IDS_NO_DIGITALSIGNATURE);

    } else {

        strDriverSigner = m_DigitalSigner;
    }
}

BOOL
CDriver::GetFullPathFromImagePath(
    LPCTSTR ImagePath,
    LPTSTR  FullPath,
    UINT    FullPathLength
    )
{
    TCHAR OriginalCurrentDirectory[MAX_PATH];
    LPTSTR pRelativeString;
    LPTSTR lpFilePart;

    if (!ImagePath || (ImagePath[0] == TEXT('\0'))) {
        return FALSE;
    }

    //
    // If we aren't on a local machine then just return the file name and not
    // the full path.
    //
    if (!m_OnLocalMachine) {
        lstrcpyn(FullPath, MyGetFileTitle(ImagePath), FullPathLength);
        return TRUE;
    }

    //
    // First check if the ImagePath happens to be a valid full path.
    //
    if (GetFileAttributes(ImagePath) != 0xFFFFFFFF) {
        ::GetFullPathName(ImagePath, FullPathLength, FullPath, &lpFilePart);
        return TRUE;
    }

    pRelativeString = (LPTSTR)ImagePath;

    //
    // If the ImagePath starts with "\SystemRoot" or "%SystemRoot%" then
    // remove those values.
    //
    if (StrCmpNI(ImagePath, TEXT("\\SystemRoot\\"), lstrlen(TEXT("\\SystemRoot\\"))) == 0) {
        pRelativeString += lstrlen(TEXT("\\SystemRoot\\"));
    } else if (StrCmpNI(ImagePath, TEXT("%SystemRoot%\\"), lstrlen(TEXT("%SystemRoot%\\"))) == 0) {
        pRelativeString += lstrlen(TEXT("%SystemRoot%\\"));
    }

    //
    // At this point pRelativeString should point to the image path relative to
    // the windows directory.
    //
    if (!GetSystemWindowsDirectory(FullPath, FullPathLength)) {
        return FALSE;
    }

    if (!GetCurrentDirectory(ARRAYLEN(OriginalCurrentDirectory), OriginalCurrentDirectory)) {
        OriginalCurrentDirectory[0] = TEXT('\0');
    }

    if (!SetCurrentDirectory(FullPath)) {
        return FALSE;
    }

    ::GetFullPathName(pRelativeString, FullPathLength, FullPath, &lpFilePart);

    if (OriginalCurrentDirectory[0] != TEXT('\0')) {
        SetCurrentDirectory(OriginalCurrentDirectory);
    }

    return TRUE;
}

BOOL
CDriverFile::Create(
    LPCTSTR ServiceName,
    BOOL LocalMachine,
    DWORD Win32Error,
    LPCTSTR DigitalSigner,
    HSDB hSDBDrvMain
    )
{
    if (!ServiceName || (TEXT('\0') == ServiceName[0]))
    {
        return FALSE;
    }

    m_Win32Error = Win32Error;

    if (DigitalSigner) {
        m_strDigitalSigner = DigitalSigner;
    }

    //
    // For remote machine, we can not verify if the driver file exits.
    // we only show the driver name.
    //
    if (LocalMachine) {
        m_Attributes = GetFileAttributes(ServiceName);

        if (0xFFFFFFFF != m_Attributes) {
            m_strFullPathName = ServiceName;

        } else {
            //
            // The driver is a service. Do not search for the current director --
            // GetFullPathName is useless here.
            // Search for Windows dir and System directory
            //
            TCHAR BaseDir[MAX_PATH];

            BaseDir[0] = TEXT('\0');

            if (GetSystemWindowsDirectory(BaseDir, ARRAYLEN(BaseDir))) {

                int Len;

                Len = lstrlen(BaseDir);

                if (Len)
                {
                    if (_T('\\') != BaseDir[Len - 1])
                    {
                        lstrcat(BaseDir, TEXT("\\"));
                    }

                    lstrcat(BaseDir, MyGetFileTitle(ServiceName));
                    m_Attributes = GetFileAttributes(BaseDir);
                }

                if (0xFFFFFFFF == m_Attributes)
                {
                    if (GetSystemDirectory(BaseDir, ARRAYLEN(BaseDir))) {

                        Len = lstrlen(BaseDir);

                        if (Len)
                        {
                            if (_T('\\') != BaseDir[Len - 1])
                            {
                                lstrcat(BaseDir, TEXT("\\"));
                            }

                            lstrcat(BaseDir, MyGetFileTitle(ServiceName));
                            m_Attributes = GetFileAttributes(BaseDir);
                        }
                    }
                }

                //
                // hopeless, we could find the path
                //
                if (0xFFFFFFFF == m_Attributes)
                {
                    return FALSE;
                }

                m_strFullPathName = BaseDir;

            } else {

                return FALSE;
            }
        }

        m_HasVersionInfo = GetVersionInfo();
    }

    else {
        m_strFullPathName = ServiceName;

        //
        //we do not have version info
        //
        m_HasVersionInfo = FALSE;
    }

    if (!m_strFullPathName.IsEmpty() && hSDBDrvMain != NULL) {
        TAGREF tagref = TAGREF_NULL;
        HAPPHELPINFOCONTEXT hAppHelpInfoContext = NULL;
        SDBENTRYINFO entryinfo;
        DWORD cbSize;

        tagref = SdbGetDatabaseMatch(hSDBDrvMain,
                                     (LPTSTR)m_strFullPathName,
                                     INVALID_HANDLE_VALUE,
                                     NULL,
                                     0
                                     );

        if (tagref != TAGREF_NULL) {
            //
            // This driver is in the database.
            //
            m_IsDriverBlocked = TRUE;

            //
            // Call SdbReadDriverInformation to get the database GUID and the
            // driver GUID for this entry.
            //
            ZeroMemory(&entryinfo, sizeof(entryinfo));
            if (SdbReadDriverInformation(hSDBDrvMain,
                                         tagref,
                                         &entryinfo)) {
                //
                // Open up the App help information database and query for the
                // html link.
                //
                hAppHelpInfoContext = SdbOpenApphelpInformation(&(entryinfo.guidDB),
                                                                &(entryinfo.guidID));

                if (hAppHelpInfoContext) {

                    cbSize = 0;
                    PBYTE pBuffer = NULL;

                    cbSize = SdbQueryApphelpInformation(hAppHelpInfoContext,
                                                        ApphelpHelpCenterURL,
                                                        NULL,
                                                        0);

                    if (cbSize &&
                        (pBuffer = new BYTE[cbSize])) {

                        cbSize = SdbQueryApphelpInformation(hAppHelpInfoContext,
                                                            ApphelpHelpCenterURL,
                                                            (LPVOID)pBuffer,
                                                            cbSize);

                        if (cbSize) {
                            m_strHtmlHelpID = (LPTSTR)pBuffer;
                        }

                        delete pBuffer;
                    }

                    SdbCloseApphelpInformation(hAppHelpInfoContext);
                }
            }
        }
    }


    return TRUE;
}
BOOL
CDriverFile::GetVersionInfo()
{
    DWORD Size, dwHandle;

    Size = GetFileVersionInfoSize((LPTSTR)(LPCTSTR)m_strFullPathName, &dwHandle);

    if (!Size)
    {
        return FALSE;
    }

    BufferPtr<BYTE> BufPtr(Size);
    PVOID pVerInfo = BufPtr;

    if (GetFileVersionInfo((LPTSTR)(LPCTSTR)m_strFullPathName, dwHandle, Size,
                pVerInfo))
    {
        // get VarFileInfo\Translation
        PVOID pBuffer;
        UINT Len;
        String strStringFileInfo;

        if (!VerQueryValue(pVerInfo, (LPTSTR)tszTranslation, &pBuffer, &Len))
        {
            strStringFileInfo = tszStringFileInfoDefault;
        }

        else
        {
            strStringFileInfo.Format(tszStringFileInfo, *((WORD*)pBuffer),
                         *(((WORD*)pBuffer) + 1));
        }

        String str;
        str = strStringFileInfo + tszFileVersion;

        if (VerQueryValue(pVerInfo, (LPTSTR)(LPCTSTR)str, &pBuffer, &Len))
        {
            m_strVersion = (LPTSTR)pBuffer;
            str = strStringFileInfo + tszLegalCopyright;

            if (VerQueryValue(pVerInfo, (LPTSTR)(LPCTSTR)str, &pBuffer, &Len))
            {
                m_strCopyright = (LPTSTR)pBuffer;
                str = strStringFileInfo + tszCompanyName;

                if (VerQueryValue(pVerInfo, (LPTSTR)(LPCTSTR)str, &pBuffer, &Len))
                {
                    m_strProvider = (LPTSTR)pBuffer;
                }
            }
        }
    }

    return TRUE;
}


BOOL
CDriverFile::operator ==(
    CDriverFile& OtherDrvFile
    )
{
    return \
       m_HasVersionInfo == OtherDrvFile.HasVersionInfo() &&
       (GetFullPathName() == OtherDrvFile.GetFullPathName() ||
        (GetFullPathName() && OtherDrvFile.GetFullPathName() &&
         !lstrcmpi(GetFullPathName(), OtherDrvFile.GetFullPathName())
        )
       ) &&
       (GetProvider() == OtherDrvFile.GetProvider() ||
        (GetProvider() && OtherDrvFile.GetProvider() &&
         !lstrcmpi(GetProvider(), OtherDrvFile.GetProvider())
        )
       ) &&
       (GetCopyright() == OtherDrvFile.GetCopyright() ||
        (GetCopyright() && OtherDrvFile.GetCopyright() &&
         !lstrcmpi(GetCopyright(), OtherDrvFile.GetCopyright())
        )
       ) &&
       (GetVersion() == OtherDrvFile.GetVersion() ||
        (GetVersion() && OtherDrvFile.GetVersion() &&
         !lstrcmpi(GetVersion(), OtherDrvFile.GetVersion())
        )
       );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\cnode.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    cnode.cpp

Abstract:

    This module implements CDevice, CClass, CResource and CComputer classes.

Author:

    William Hsieh (williamh) created

Revision History:


--*/
#include "devmgr.h"
#include "cdriver.h"
#include "hwprof.h"
#include "sysinfo.h"
#include <initguid.h>
#include <mountmgr.h>
#include <devguid.h>
#include <wdmguid.h>


//
// CClass implementation
//
CClass::CClass(
    CMachine* pMachine,
    GUID* pGuid
    )
{
    m_Guid = *pGuid;
    ASSERT(pMachine);
    ASSERT(pGuid);

    HKEY hKey = NULL;

    m_NoDisplay = FALSE;
    m_pMachine = pMachine;
    m_TotalDevices = 0;
    m_TotalHiddenDevices = 0;
    m_pDevInfoList = NULL;
    m_pos = NULL;

    if (!m_pMachine->DiGetClassFriendlyNameString(pGuid, m_strDisplayName)) 
    {
        m_strDisplayName.LoadString(g_hInstance, IDS_UNKNOWN);
    }
    
    m_pMachine->DiGetClassImageIndex(pGuid, &m_iImage);

    hKey = m_pMachine->DiOpenClassRegKey(pGuid, KEY_READ, DIOCR_INSTALLER);

    if (INVALID_HANDLE_VALUE != hKey) 
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_NODISPLAYCLASS, NULL, NULL, NULL, NULL)) 
        {
            m_NoDisplay = TRUE;
        }
        
        RegCloseKey(hKey);
    }
}

CDevInfoList*
CClass::GetDevInfoList(
    HWND hwndParent
    )
{
    if (!m_pDevInfoList) 
    {
        HDEVINFO hDevInfo = m_pMachine->DiCreateDeviceInfoList(&m_Guid, hwndParent);

        if (hDevInfo && INVALID_HANDLE_VALUE != hDevInfo) 
        {
            m_pDevInfoList = new CDevInfoList(hDevInfo, hwndParent);
        }
    }
    
    return m_pDevInfoList;
}

inline
CItemIdentifier*
CClass::CreateIdentifier()
{
    return new CClassIdentifier(*this);
}

CClass::~CClass()
{
    m_listDevice.RemoveAll();

    if (m_pDevInfoList)
    {
        delete m_pDevInfoList;
    }
}

HICON
CClass::LoadIcon()
{
    HICON hClassIcon;

    if (!m_pMachine->DiLoadClassIcon(&m_Guid, &hClassIcon, NULL))
    {
        return NULL;
    }
    
    return hClassIcon;
}

void
CClass::AddDevice(CDevice* pDevice)
{
    ASSERT(pDevice);

    m_listDevice.AddTail(pDevice);
    m_TotalDevices++;

    // Every device under a NoDisplay class is a hidden device
    if (m_NoDisplay || pDevice->IsHidden()) {
    
        m_TotalHiddenDevices++;
    }
}

BOOL
CClass::GetFirstDevice(
    CDevice** ppDevice,
    PVOID&    Context
    )
{
    ASSERT(ppDevice);

    if (!m_listDevice.IsEmpty()) 
    {
        POSITION pos;

        pos = m_listDevice.GetHeadPosition();
        *ppDevice = m_listDevice.GetNext(pos);
        Context = pos;

        return TRUE;
    }
    
    *ppDevice = NULL;

    return FALSE;
}

BOOL
CClass::GetNextDevice(
    CDevice** ppDevice,
    PVOID&    Context
    )
{
    ASSERT(ppDevice);

    POSITION pos = (POSITION)(Context);

    if(NULL != pos) 
    {
        *ppDevice = m_listDevice.GetNext(pos);
        Context = pos;
        return TRUE;
    }
    
    *ppDevice = NULL;

    return FALSE;
}

void
CClass::PropertyChanged()
{
    HKEY hKey = NULL;

    if (!m_pMachine->DiGetClassFriendlyNameString(&m_Guid, m_strDisplayName))
    {
        m_strDisplayName.LoadString(g_hInstance, IDS_UNKNOWN);
    }
    
    m_pMachine->DiGetClassImageIndex(&m_Guid, &m_iImage);

    if (m_pDevInfoList) 
    {
        delete m_pDevInfoList;
        m_pDevInfoList = NULL;
    }
    
    hKey = m_pMachine->DiOpenClassRegKey(&m_Guid, KEY_READ, DIOCR_INSTALLER);

    if (INVALID_HANDLE_VALUE != hKey) 
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_NODISPLAYCLASS, NULL, NULL, NULL, NULL))
        {
            m_NoDisplay = TRUE;
        }
        
        RegCloseKey(hKey);
    }
}

// CDevice implementation
//
CDevice::CDevice(
    CMachine* pMachine,
    CClass* pClass,
    PSP_DEVINFO_DATA pDevData
    )
{
    ASSERT(pMachine && pDevData && pClass);
    
    m_DevData = *pDevData;
    m_pClass = pClass;
    m_pMachine = pMachine;
    m_pSibling = NULL;
    m_pParent = NULL;
    m_pChild = NULL;

    if (!m_pMachine->CmGetDescriptionString(m_DevData.DevInst, m_strDisplayName))
    {
        m_strDisplayName.LoadString(g_hInstance, IDS_UNKNOWN_DEVICE);
    }
    
    m_pMachine->CmGetDeviceIDString(m_DevData.DevInst, m_strDeviceID);
    m_iImage = m_pClass->GetImageIndex();
}

inline
CItemIdentifier*
CDevice::CreateIdentifier()
{
    return new CDeviceIdentifier(*this);
}

void
CDevice::PropertyChanged()
{
    if (!m_pMachine->CmGetDescriptionString(m_DevData.DevInst, m_strDisplayName))
    {
        m_strDisplayName.LoadString(g_hInstance, IDS_UNKNOWN_DEVICE);
    }
    
    m_pMachine->CmGetDeviceIDString(m_DevData.DevInst, m_strDeviceID);
    m_iImage = m_pClass->GetImageIndex();
}

HICON
CDevice::LoadClassIcon()
{
    HICON hClassIcon;
    hClassIcon = NULL;

    if (m_pMachine->DiLoadClassIcon(&m_DevData.ClassGuid, &hClassIcon, NULL))
    {
        return hClassIcon;
    }

    return NULL;
}

BOOL
CDevice::GetStatus(
    DWORD* pStatus,
    DWORD* pProblem
    )
{
    return  m_pMachine->CmGetStatus(m_DevData.DevInst, pProblem, pStatus);
}

BOOL
CDevice::GetCapabilities(
    DWORD* pCapabilities
    )
{
    return m_pMachine->CmGetCapabilities(m_DevData.DevInst, pCapabilities);
}

BOOL
CDevice::GetPowerCapabilities(
    DWORD* pCapabilities
    )
{
    CM_POWER_DATA CmPowerData;
    ULONG Size;

    Size = sizeof(CmPowerData);
    if (m_pMachine->CmGetRegistryProperty(m_DevData.DevInst,
                                          CM_DRP_DEVICE_POWER_DATA,
                                          &CmPowerData,
                                          &Size
                                          ) == CR_SUCCESS) {

        *pCapabilities = CmPowerData.PD_Capabilities;
        return TRUE;
    }

    *pCapabilities = 0;
    return FALSE;
}

BOOL
CDevice::IsRAW()
{
    DWORD Capabilities;
    
    return (m_pMachine->CmGetCapabilities(m_DevData.DevInst, &Capabilities) &&
            (CM_DEVCAP_RAWDEVICEOK & Capabilities));
}

BOOL
CDevice::IsHidden()
{
    CClass *pClass = GetClass();

    //
    // A device is hidden if one of the following are TRUE:
    //
    // - It's class is a NoDisplayClass
    // - It has the DN_NO_SHOW_IN_DM Status flag set
    // - It is a Phantom devnode
    //
    return (NoShowInDM() || IsPhantom() || pClass->NoDisplay());
}

BOOL
CDevice::IsPhantom()
{
    DWORD Status, Problem;

    return !m_pMachine->CmGetStatus(m_DevData.DevInst, &Problem, &Status) &&
            (CR_NO_SUCH_VALUE == m_pMachine->GetLastCR() ||
            CR_NO_SUCH_DEVINST == m_pMachine->GetLastCR());
}

BOOL
CDevice::NoShowInDM()
{
    DWORD Status, Problem;
    Status = 0;
    GetStatus(&Status, &Problem);
    return (Status & DN_NO_SHOW_IN_DM);
}

BOOL
CDevice::IsUninstallable(
    )
/*++

    This function determins whether a device can be uninstalled. A device
    cannot be uninstalled if it is a ROOT device and it does not have
    the DN_DISABLEABLE DevNode status bit set.
    
Return Value:
    TRUE if the device can be uninstalled.
    FALSE if the device cannot be uninstalled.    
    
--*/
{
    DWORD Status, Problem;

    if (GetStatus(&Status, &Problem) &&
        !(Status & DN_DISABLEABLE) &&
         (Status & DN_ROOT_ENUMERATED)) {

        return FALSE;
    }
    
    return TRUE;
}

BOOL
CDevice::IsDisableable(
    )
/*++

    This function determins whether a device can be disabled or not by 
    checking the DN_DISABLEABLE DevNode status bit.
    
    A device that is currently Hardware Disabled cannot be software disabled.
    
Return Value:
    TRUE if the device can be disabled.
    FALSE if the device cannot be disabled.    

--*/
{
    DWORD Status, Problem;

    if (GetStatus(&Status, &Problem) &&
        (Status & DN_DISABLEABLE) &&
        (CM_PROB_HARDWARE_DISABLED != Problem)) {

        return TRUE;
    }

    return FALSE;
}

BOOL
CDevice::IsDisabled(
    )
/*++

    A device is disabled if it has the problem CM_PROB_DISABLED.  
    
Return Value:    
    TRUE if device is disabled.
    FALSE if device is NOT disabled.
    
--*/
{
    DWORD Status, Problem;

    if (GetStatus(&Status, &Problem)) 
    {
        return ((Status & DN_HAS_PROBLEM) && (CM_PROB_DISABLED == Problem));
    }

    return FALSE;
}

BOOL
CDevice::IsStateDisabled(
    )
/*++

    A device state is disabled if it has the CONFIGFLAG_DISABLED ConfigFlag
    set or the CSCONFIGFLAG_DISABLED Config Specific ConfigFlag disabled in 
    the current profile.
    
    Note that a device disabled State has nothing to do with whether the device
    is currently physically disabled or not.  The disabled state is just a registry
    flag that tells Plug and Play what to do with the device the next time it is 
    started.
    
Return Value:    
    TRUE if device's state is disabled.
    FALSE if device's state is NOT disabled.
    
--*/
{
    ULONG hwpfCurrent;
    DWORD Flags;

    //
    // Check if the device state is globally disabled by checking it's ConfigFlags
    //
    GetConfigFlags(&Flags);
    if (Flags & CONFIGFLAG_DISABLED) {
        return TRUE;
    }

    //
    // Check if the device state is disabled in the current hardware profile by 
    // checking it's Config Specific ConfigFlags.
    //
    if (m_pMachine->CmGetCurrentHwProfile(&hwpfCurrent) &&
        m_pMachine->CmGetHwProfileFlags(m_DevData.DevInst, hwpfCurrent, &Flags) &&
        (Flags & CSCONFIGFLAG_DISABLED)) {
        return TRUE;
    }

    return FALSE;
}

BOOL
CDevice::IsStarted()
{
    DWORD Status, Problem;    
    
    //
    // Check to see if the DN_STARTED devnode status flag is set.
    //
    if (GetStatus(&Status, &Problem) &&
        (Status & DN_STARTED))
    {
        return TRUE;
    }
    
    return FALSE;
}

BOOL
CDevice::HasProblem(
    )
/*++

    This function returns whether a device has a problem or not.
    
Return Value:    
    TRUE if device has a problem.
    FALSE if device does not have a problem.
    
--*/
{
    DWORD Status, Problem;    
    
    if (GetStatus(&Status, &Problem))
    {
        //
        // If the DN_HAS_PROBLEM or DN_PRIVATE_PROBLEM status bits are set
        // then this device has a problem, unless the problem is CM_PROB_MOVED.
        //
        if ((Status & DN_PRIVATE_PROBLEM) ||
            ((Status & DN_HAS_PROBLEM) && (Problem != CM_PROB_MOVED)))
        {
            return TRUE;
        }

        //
        // If the device is not started and RAW capable then it also has a problem
        //
        if (!(Status & DN_STARTED) && IsRAW()) 
        {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
CDevice::NeedsRestart(
    )
/*++

    This function returns whether a device needs a restart or not.  It checks the
    DN_NEED_RESTART Status flag.  
    
Return Value:    
    TRUE if device needs the computer to be restarted for it to work properly.
    FALSE if device does not need the computer to be restarted.
    
--*/
{
    DWORD Status, Problem;

    if (GetStatus(&Status, &Problem)) 
    {
        return (Status & DN_NEED_RESTART);
    }

    return FALSE;
}

CDevice*
CDevice::FindMFParent()
{
    if (!IsMFChild())
    {
        return NULL;
    }
    
    ASSERT(m_pParent);

    CDevice* pDevice = m_pParent;

    while (pDevice->IsMFChild())
    {
        pDevice = pDevice->GetParent();
    }
    
    return pDevice;
}

BOOL
CDevice::IsMFChild(
    )
{
    DWORD Status, Problem;
    Status = 0;
    GetStatus(&Status, &Problem);
    return (Status & DN_MF_CHILD);
}

BOOL
CDevice::IsSpecialMFChild(
    )
{
    if (IsMFChild()) 
    {
        DWORD Flags;

        if (GetConfigFlags(&Flags))
        {
            return (Flags & CONFIGFLAG_CANTSTOPACHILD);
        }
    }
    
    return FALSE;
}

// This function determines if the device is a pnp device
// INPUT:
//  None
// OUTPUT:
//  TRUE if the device is a pnp device
//  FLASE if the device is not a pnp device or undetermined
BOOL
CDevice::IsPnpDevice()
{
    // A device is pnp device if the device id is not led
    // by "root" and DN_ROOT_ENUMERATED is not set
    // in its status.
    if (!m_strDeviceID.IsEmpty()) 
    {
        // unfortunately, we do not have lstrcmpin library function
        TCHAR DeviceId[MAX_DEVICE_ID_LEN + 1];
        int len = lstrlen(REGSTR_KEY_ROOTENUM);

        lstrcpyn(DeviceId, (LPCTSTR)m_strDeviceID, len);
        DeviceId[len] = _T('\0');

        if (lstrcmpi(DeviceId, REGSTR_KEY_ROOTENUM)) 
        {
            // the device id does not start with "root"
            // check the status
            DWORD Problem, Status;

            if (GetStatus(&Status, &Problem))
            {
                return !(Status & DN_ROOT_ENUMERATED);
            }
        }
    }
    
    return FALSE;
}

BOOL
CDevice::IsBiosDevice()
{
    // A device is bios enumerated if its device id
    // is led by "root" and its status does not
    // have DN_ROOT_ENUMERATED
    if (!m_strDeviceID.IsEmpty()) 
    {
        TCHAR DeviceId[MAX_DEVICE_ID_LEN + 1];
        int len = lstrlen(REGSTR_KEY_ROOTENUM);
        
        lstrcpyn(DeviceId, (LPCTSTR)m_strDeviceID, len);
        DeviceId[len] = _T('\0');

        if (!lstrcmpi(DeviceId, REGSTR_KEY_ROOTENUM)) 
        {
            // the device id starts with "root"
            // check the status
            DWORD Problem, Status;

            if (GetStatus(&Status, &Problem)) 
            {
                return !(Status & DN_ROOT_ENUMERATED);
            }
        }
    }
    
    return FALSE;
}

BOOL
CDevice::IsPCMCIA()
{
    ASSERT(m_pClass);

    // if the device's class is PCMCIA, it is a PCMCIA device
    if (IsEqualGUID(*m_pClass, GUID_DEVCLASS_PCMCIA))
    {
        return TRUE;
    }
    
    // if the device has ancestor(s), it is a PCMCIA if one of
    // its ancestor is PCMCIA
    if (m_pParent)
    {
        return m_pParent->IsPCMCIA();
    }
    
    return FALSE;
}

BOOL
CDevice::IsPCIDevice()
{
    GUID BusGuid;
    CONFIGRET ConfigRet;

    if (m_pMachine->CmGetBusGuid(GetDevNode(), &BusGuid) &&
        IsEqualGUID(BusGuid, GUID_BUS_TYPE_PCI)) {

        return TRUE;
    }

    return FALSE;
}

BOOL
CDevice::GetConfigFlags(
    DWORD* pFlags
    )
{
    return m_pMachine->CmGetConfigFlags(m_DevData.DevInst, pFlags);
}

BOOL
CDevice::GetConfigSpecificConfigFlags(
    DWORD* pCSStatus
    )
{
    ULONG hwpfCurrent;

    if (m_pMachine->CmGetCurrentHwProfile(&hwpfCurrent) &&
        m_pMachine->CmGetHwProfileFlags(m_DevData.DevInst, hwpfCurrent, pCSStatus)) {
        
        return TRUE;
    }

    return FALSE;
}

BOOL
CDevice::GetKnownLogConf(LOG_CONF* plc, DWORD* plcType)
{
    return m_pMachine->CmGetKnownLogConf(m_DevData.DevInst, plc, plcType);
}

BOOL
CDevice::HasResources()
{
    return m_pMachine->CmHasResources(m_DevData.DevInst);
}

void
CDevice::GetMFGString(
    String& strMFG
    )
{
    m_pMachine->CmGetMFGString(m_DevData.DevInst, strMFG);

    if (strMFG.IsEmpty()) 
    {
        strMFG.LoadString(g_hInstance, IDS_UNKNOWN);
    }
}

void
CDevice::GetProviderString(
    String& strProvider
    )
{
    m_pMachine->CmGetProviderString(m_DevData.DevInst, strProvider);
    
    if (strProvider.IsEmpty()) {
    
        strProvider.LoadString(g_hInstance, IDS_UNKNOWN);
    }
}

void
CDevice::GetDriverDateString(
    String& strDriverDate
    )
{
    FILETIME ft;

    strDriverDate.Empty();

    //
    // First try to get the driver date FileTime data from the registry,
    // this way we can localize the date.
    //
    if (m_pMachine->CmGetDriverDateData(m_DevData.DevInst, &ft)) {

        SYSTEMTIME SystemTime;
        TCHAR DriverDate[MAX_PATH];

        DriverDate[0] = TEXT('\0');

        if (FileTimeToSystemTime(&ft, &SystemTime)) {

            if (GetDateFormat(LOCALE_USER_DEFAULT,
                          DATE_SHORTDATE,
                          &SystemTime,
                          NULL,
                          DriverDate,
                          sizeof(DriverDate)/sizeof(TCHAR)
                          ) != 0) {

                strDriverDate = DriverDate;
            }
        }

    } else {
    
        //
        // We couldn't get the FileTime data so just get the DriverDate string
        // from the registry.
        //
        m_pMachine->CmGetDriverDateString(m_DevData.DevInst, strDriverDate);
    }

    if (strDriverDate.IsEmpty()) {
    
        strDriverDate.LoadString(g_hInstance, IDS_NOT_AVAILABLE);
    }
}

void
CDevice::GetDriverVersionString(
    String& strDriverVersion
    )
{
    m_pMachine->CmGetDriverVersionString(m_DevData.DevInst, strDriverVersion);

    if (strDriverVersion.IsEmpty()) {
    
        strDriverVersion.LoadString(g_hInstance, IDS_NOT_AVAILABLE);
    }
}

LPCTSTR
CDevice::GetClassDisplayName()
{
    if (m_pClass)
    {
        return m_pClass->GetDisplayName();
    }
    
    else
    {
        return NULL;
    }
}

BOOL
CDevice::NoChangeUsage()
{
    SP_DEVINSTALL_PARAMS dip;
    dip.cbSize = sizeof(dip);

    if (m_pMachine->DiGetDeviceInstallParams(&m_DevData, &dip))
    {
        return (dip.Flags & DI_PROPS_NOCHANGEUSAGE);
    }
    
    else
    {
        return TRUE;
    }
}

CDriver*
CDevice::CreateDriver()
{
    SP_DRVINFO_DATA DrvInfoData;
    PSP_DRVINFO_DATA pDrvInfoData;
    CDriver* pDriver = NULL;

    DrvInfoData.cbSize = sizeof(DrvInfoData);

    // If the device has a selected driver, use it. Otherwise,
    // we pass a NULL drvinfodata so that CDriver will search
    // for the device driver key or service to create
    // a list of driver files.
    if (m_pMachine->DiGetSelectedDriver(&m_DevData, &DrvInfoData))
    {
        pDrvInfoData = &DrvInfoData;
    }
    
    else
    {
        pDrvInfoData = NULL;
    }

    pDriver = new CDriver();

    if (!pDriver) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    // if we have a selected driver and we failed to
    // to create the driver, retry it without the selected driver
    //
    if (pDrvInfoData && pDriver->Create(this, pDrvInfoData)) {

        return pDriver;
    }

    pDriver->Create(this, NULL);

    return pDriver;
}

BOOL
CDevice::HasDrivers()
{
    HKEY hKey;
    BOOL HasDriverKey, HasServiceKey;
    CDriver DeviceDriver;
    BOOL Result;

    HasDriverKey = FALSE;

    if (m_pMachine->IsLocal()) 
    {
        // open drvice's driver registry key
        hKey = m_pMachine->DiOpenDevRegKey(&m_DevData, DICS_FLAG_GLOBAL,
                        0, DIREG_DRV, KEY_ALL_ACCESS);
                        
        HasDriverKey = INVALID_HANDLE_VALUE != hKey;

        if (INVALID_HANDLE_VALUE != hKey) 
        {
            RegCloseKey(hKey);
        }
    }
    
    DWORD Size = 0;

    m_pMachine->DiGetDeviceRegistryProperty(&m_DevData, SPDRP_SERVICE,
                        NULL, NULL, 0, &Size);

    HasServiceKey = (0 != Size);

    if (HasServiceKey || HasDriverKey) 
    {
        // either we have a driver or a service key.
        // try to find out if we can find any valid driver files.
        Result = DeviceDriver.Create(this);
    }
    
    else 
    {
        if (m_pMachine->IsLocal() && g_HasLoadDriverNamePrivilege) 
        {
            // If the target machine is local and the user has the
            // administrator privilege, we need the driver page
            // for users to update the drivers.
            //
            Result = TRUE;
        }
        
        else 
        {
            Result = FALSE;
        }
    }
    
    return Result;
}

DWORD
CDevice::EnableDisableDevice(
    HWND hDlg,
    BOOL Enabling
    )
{
    BOOL Disabling = !Enabling;
    BOOL Canceled;
    Canceled = FALSE;
    DWORD RestartFlags = 0;
    DWORD ConfigFlags;
    HCURSOR hCursorOld = NULL;
    BOOL Refresh = FALSE;

    //
    // Disable refreshing the TREE while we are enabling/disabling this device
    //
    m_pMachine->EnableRefresh(FALSE);

    if (!GetConfigFlags(&ConfigFlags)) {
        ConfigFlags = 0;
    }

    //
    // Only want the disabled bit
    //
    ConfigFlags &= CONFIGFLAG_DISABLED;

    CHwProfileList* pHwProfileList = new CHwProfileList();
    
    if (!pHwProfileList) {
        goto clean0;
    }

    pHwProfileList->Create(this, ConfigFlags);

    //
    // Get the current profile
    //
    CHwProfile* phwpf;

    if (!(pHwProfileList->GetCurrentHwProfile(&phwpf))) {
        goto clean0;
    }

    //
    // Can only enable a device that is currently disabled
    //
    if (IsStateDisabled() && Enabling) {
        phwpf->SetEnablePending();
    }

    //
    // Can only disable a device that is currently enabled
    //
    else if (!IsStateDisabled() && Disabling) {
        phwpf->SetDisablePending();
    }

    //
    // If we don't have a valid enable or disable then exit
    //
    if (!(phwpf->IsEnablePending()) && !(phwpf->IsDisablePending())) {
        goto clean0;
    }

    //
    // This device is not a boot device so just display the normal disable
    // warning to the user.
    //
    if (Disabling) {
        int MsgBoxResult;
        TCHAR szText[MAX_PATH];
        DWORD Size;
        
        Size = LoadResourceString(IDS_WARN_NORMAL_DISABLE, szText, ARRAYLEN(szText));
        MsgBoxResult = MessageBox(hDlg, 
                                  szText,
                                  GetDisplayName(),
                                  MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON2
                                  );

        if (IDYES != MsgBoxResult) {
            goto clean0;
        }
    }

    hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    // If this isn't a live devnode then we need to do a manual refresh if we
    // are diabling the device.
    // 
    Refresh = (!Enabling &&
               (IsPhantom() || 
                HasProblem() || 
                !IsStarted()));

    m_pMachine->DiTurnOnDiFlags(*this, DI_NODI_DEFAULTACTION);

    SP_PROPCHANGE_PARAMS pcp;
    pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;

    //
    // Now ask the class installer if the device can be specifically enabled/disabled
    //
    pcp.Scope = DICS_FLAG_CONFIGSPECIFIC;
    pcp.StateChange = DICS_DISABLE;
    
    if (phwpf->IsEnablePending()) {
        pcp.StateChange = DICS_ENABLE;
    }
    
    pcp.HwProfile = phwpf->GetHwProfile();

    m_pMachine->DiSetClassInstallParams(*this,
                                        &pcp.ClassInstallHeader,
                                        sizeof(pcp)
                                        );
            
    m_pMachine->DiCallClassInstaller(DIF_PROPERTYCHANGE, *this);
    Canceled = (ERROR_CANCELLED == GetLastError());
    
    //
    // class installer has not objection of our enabling/disabling,
    // do real enabling/disabling.
    //
    if (!Canceled) {
        if (phwpf->IsDisablePending()) {
            pcp.StateChange = DICS_DISABLE;
            pcp.Scope = DICS_FLAG_CONFIGSPECIFIC;
            pcp.HwProfile = phwpf->GetHwProfile();
            m_pMachine->DiSetClassInstallParams(*this,
                                                &pcp.ClassInstallHeader,
                                                sizeof(pcp)
                                                );
                    
            m_pMachine->DiChangeState(*this);
        }
                    
        else {
            //
            // We are enabling the device,
            // do a specific enabling then a globally enabling.
            // the globally enabling will start the device
            // The implementation here is different from
            // Win9x which does a global enabling, a config
            // specific enabling and then a start.
            //
            pcp.Scope = DICS_FLAG_CONFIGSPECIFIC;
            pcp.HwProfile = phwpf->GetHwProfile();
            m_pMachine->DiSetClassInstallParams(*this,
                                                &pcp.ClassInstallHeader,
                                                sizeof(pcp)
                                                );
                        
            m_pMachine->DiChangeState(*this);

            //
            // This call will start the device is it not started.
            //
            pcp.Scope = DICS_FLAG_GLOBAL;
            m_pMachine->DiSetClassInstallParams(*this,
                                                &pcp.ClassInstallHeader,
                                                sizeof(pcp)
                                                );
                        
            m_pMachine->DiChangeState(*this);
        }
                    
        if (phwpf->IsEnablePending()) {
            phwpf->ResetEnablePending();
        }
        
        else if (phwpf->IsDisablePending()) {
            phwpf->ResetDisablePending();
        }

        //
        // signal that the property of the device is changed.
        //
        m_pMachine->DiTurnOnDiFlags(*this, DI_PROPERTIES_CHANGE);

        //
        // See if we need a restart.
        //
        RestartFlags |= (m_pMachine->DiGetFlags(*this)) & (DI_NEEDRESTART | DI_NEEDREBOOT);

        if (NeedsRestart()) {
            RestartFlags |= DI_NEEDRESTART;
        }
    }

    //
    // Remove class install parameters, this also reset
    // DI_CLASSINATLLPARAMS
    //
    m_pMachine->DiSetClassInstallParams(*this, NULL, 0);

    m_pMachine->DiTurnOffDiFlags(*this, DI_NODI_DEFAULTACTION);

clean0:
    if (pHwProfileList) {
        delete pHwProfileList;
    }

    //
    // Enable the tree for refreshing.
    // We will only schedule a refresh ourselves if the device was not started 
    // before we tried to disable it, and we are not going to prompt for a reboot.
    // In all other cases we should get a WM_DEVICECHANGE which will cause us
    // to refresh our tree.
    //
    if (Refresh && !NeedsRestart()) {
        m_pMachine->ScheduleRefresh();
    }

    m_pMachine->EnableRefresh(TRUE);

    if (hCursorOld != NULL) {
        SetCursor(hCursorOld);
    }

    return RestartFlags;
}

BOOL
CDevice::operator ==(
    CDevice& OtherDevice
    )
{
    return \
        (*m_pClass == *(OtherDevice.GetClass())) &&
        !lstrcmpi(m_strDeviceID, OtherDevice.GetDeviceID()) &&
        !lstrcmpi(m_strDisplayName, OtherDevice.GetDisplayName());
}

//
// CComputer implementation
//

CComputer::CComputer(
    CMachine* pMachine,
    DEVNODE dnRoot
    )
{
    ASSERT(pMachine);
    ASSERT(!GetChild() && !GetParent() && !GetSibling());
    
    m_pMachine = pMachine;
    m_strDisplayName.Empty();
    m_strDisplayName = pMachine->GetMachineDisplayName();
    m_iImage = pMachine->GetComputerIconIndex();
    m_dnRoot = dnRoot;
}

inline
CItemIdentifier*
CComputer::CreateIdentifier()
{
    return new CComputerIdentifier(*this);
}


CResource::CResource(
    CDevice* pDevice,
    RESOURCEID ResType,
    DWORDLONG dlBase,
    DWORDLONG dlLen,
    BOOL Forced,
    BOOL Free
    )
{
    m_pChild = NULL;
    m_pSibling = NULL;
    m_pParent =  NULL;
    m_ResType = ResType;
    m_dlBase = dlBase;
    m_dlLen = dlLen;
    m_Forced = Forced;
    m_dlEnd = m_dlBase + m_dlLen - 1;
    m_Allocated = !Free;
    ASSERT(pDevice);
    m_pDevice = pDevice;
    m_iImage = pDevice->GetImageIndex();
    ASSERT(ResType >= ResType_Mem && ResType <= ResType_IRQ);

    m_strDisplayName.Empty();
    m_strDisplayName = pDevice->GetDisplayName();

    if (ResType_IRQ == m_ResType)
    {
        String strBus;

        strBus.LoadString(g_hInstance, 
                          pDevice->IsPCIDevice() ? IDS_PCI : IDS_ISA
                          );

        m_strViewName.Format(TEXT("%2d    "), m_dlBase);
        m_strViewName = strBus + m_strViewName;
    }
    
    else if (ResType_DMA == m_ResType)
    {
        m_strViewName.Format(TEXT("%2d    " ), m_dlBase);
    }
    
    else 
    {
#ifdef _WIN64
        m_strViewName.Format(TEXT("[%016I64X - %016I64X]  "), m_dlBase, m_dlEnd);
#else
        m_strViewName.Format(TEXT("[%08lX - %08lX]  "), (ULONG)m_dlBase, (ULONG)m_dlEnd);
#endif
    }
    
    if (m_Allocated) 
    {
        m_strViewName += pDevice->GetDisplayName();
    }
}

void
CResource::GetRangeString(
    String& strRange
    )
{
    if (ResType_IRQ == m_ResType ||
        ResType_DMA == m_ResType)
    {
        strRange.Format(TEXT("%2d"), m_dlBase);
    }
    
    else 
    {
        strRange.Format(TEXT("[%08lX - %08lX]"), (ULONG)m_dlBase, (ULONG)m_dlEnd);
    }
}

BOOL
CResource::operator <=(
    const CResource& resSrc
    )
{
    DWORDLONG dlBase, dlLen;

    resSrc.GetValue(&dlBase, &dlLen);

    if (m_dlBase < dlBase)
        return TRUE;
    
    // if this resource contain the given resource,
    // we are smaller!
    if (m_dlBase == dlBase)
        return (m_dlBase + m_dlLen > dlBase + dlLen);
    
    return FALSE;
}

BOOL
CResource::EnclosedBy(
    const CResource& resSrc
    )
{
    DWORDLONG dlBase, dlLen;
    resSrc.GetValue(&dlBase, &dlLen);
    return m_dlBase >= dlBase && m_dlBase + m_dlLen <= dlBase + dlLen;
}


CResourceType::CResourceType(
    CMachine* pMachine,
    RESOURCEID ResType
    )
{
    int iStringID;

    m_ResType = ResType;
    m_pChild = NULL;
    m_pSibling = NULL;
    m_pParent =  NULL;
    m_pMachine = pMachine;
    ASSERT(ResType >= ResType_Mem && ResType <= ResType_IRQ);

    switch (ResType)
    {
    case ResType_IRQ:
        iStringID = IDS_VIEW_RESOURCE_IRQ;
        break;
    
    case ResType_IO:
        iStringID = IDS_VIEW_RESOURCE_IO;
        break;
    
    case ResType_DMA:
        iStringID = IDS_VIEW_RESOURCE_DMA;
        break;
    
    case ResType_Mem:
        iStringID = IDS_VIEW_RESOURCE_MEM;
        break;
    
    default:
        iStringID = IDS_UNKNOWN;
        break;
    }

    m_strDisplayName.Empty();
    m_strDisplayName.LoadString(g_hInstance, iStringID);
    m_iImage = pMachine->GetResourceIconIndex();
}

inline
CItemIdentifier*
CResourceType::CreateIdentifier()
{
    return new CResourceTypeIdentifier(*this);
}


// This function creates CResourceList object to contain the designated
// resources for the given device.
// INPUT:
//      pDevice -- the device
//      ResType  -- what type of resource
//      LogConfType -- what type of logconf
// OUTPUT:
//      NONE.
//
// This function may throw CMemoryException
//
CResourceList::CResourceList(
    CDevice* pDevice,
    RESOURCEID ResType,
    ULONG LogConfType,
    ULONG AltLogConfType
    )
{
    ASSERT(ResType_All != ResType);
    ASSERT(BOOT_LOG_CONF == LogConfType ||
           FORCED_LOG_CONF == LogConfType ||
           ALLOC_LOG_CONF == LogConfType);
    ASSERT(pDevice);

    LOG_CONF lc;
    RES_DES rd, rdPrev;
    rdPrev;
    RESOURCEID ResId;
    BOOL Forced;
    CMachine* pMachine = pDevice->m_pMachine;
    ASSERT(pMachine);

    rdPrev = 0;

    // even though we have a valid logconf, it does not mean
    // GetNextResDes would succeed because the ResType is not
    // ResType_All.
    if (pMachine->CmGetFirstLogConf(pDevice->GetDevNode(), &lc, LogConfType)) 
    {
        if (pMachine->CmGetNextResDes(&rd, lc, ResType, &ResId)) 
        {
            ULONG DataSize;
            DWORDLONG dlBase, dlLen;
            
            do 
            {
                DataSize = pMachine->CmGetResDesDataSize(rd);

                if (DataSize) 
                {
                    BufferPtr<BYTE> DataPtr(DataSize);

                    if (pMachine->CmGetResDesData(rd, DataPtr, DataSize)) 
                    {
                        // need this to use a different image overlay for
                        // forced allocated resource
                        Forced = pMachine->CmGetFirstLogConf(pDevice->GetDevNode(),
                                NULL, FORCED_LOG_CONF);
                        
                        if (ExtractResourceValue(ResType, DataPtr, &dlBase, &dlLen)) 
                        {
                            SafePtr<CResource> ResPtr;
                            CResource* pRes;
    
                            pRes = new CResource(pDevice, ResType, dlBase,
                                                 dlLen, Forced, FALSE);
                                                 
                            if (pRes) 
                            {
                                ResPtr.Attach(pRes);
                                InsertResourceToList(pRes);
                                ResPtr.Detach();
                            }
                        }
                    }
                }
                
                if (rdPrev)
                {
                    pMachine->CmFreeResDesHandle(rdPrev);
                }
                
                rdPrev = rd;

            } while (pMachine->CmGetNextResDes(&rd, rdPrev, ResType, &ResId));
            
            //free the last resource descriptor handle
            pMachine->CmFreeResDesHandle(rd);
        }

        pMachine->CmFreeLogConfHandle(lc);
    }
}



// This function creates CResourceList object to contain the designated
// resources for the given machine.
// INPUT:
//  pMachine -- the machine
//  ResType  -- what type of resource
//  LogConfType -- what type of logconf
// OUTPUT:
//  NONE.
//
// This function may throw CMemoryException
//
CResourceList::CResourceList(
    CMachine* pMachine,
    RESOURCEID ResType,
    ULONG LogConfType,
    ULONG AltLogConfType
    )
{
    ASSERT(ResType_All != ResType);
    ASSERT(BOOT_LOG_CONF == LogConfType ||
           FORCED_LOG_CONF == LogConfType ||
           ALLOC_LOG_CONF == LogConfType ||
           ALL_LOG_CONF == LogConfType);

    ASSERT(pMachine);

    if (pMachine->GetNumberOfDevices()) 
    {
        ASSERT(pMachine->m_pComputer && pMachine->m_pComputer->GetChild());

        CDevice* pFirstDevice;

        pFirstDevice = pMachine->m_pComputer->GetChild();
        CreateSubtreeResourceList(pFirstDevice, ResType, LogConfType, AltLogConfType);
    }
}

//
// This function extracts resource value from the provided buffer
//
// INPUT:
//  ResType     -- resource type the data contain
//  pData       -- the raw data
//  pdlBase     -- buffer to hold the base of the value
//  pdlLen      -- buffer to hold the length of the value
//
// OUTPUT:
//  TRUE if this is a valid resource descriptor or FALSE if we should ignore it.
//  
// NOTE:
//  If the return value is FALSE then pdlBase and pdlLen are not filled in.
//
BOOL
CResourceList::ExtractResourceValue(
    RESOURCEID ResType,
    PVOID pData,
    DWORDLONG* pdlBase,
    DWORDLONG* pdlLen
    )
{
    BOOL bValidResDes = TRUE;

    ASSERT(pData && pdlBase && pdlLen);

    switch (ResType)
    {
    case ResType_Mem:
        if (pMemResData(pData)->MEM_Header.MD_Alloc_Base <= pMemResData(pData)->MEM_Header.MD_Alloc_End) {
        
            *pdlBase = pMemResData(pData)->MEM_Header.MD_Alloc_Base;
            *pdlLen = pMemResData(pData)->MEM_Header.MD_Alloc_End -
                *pdlBase + 1;
        } else {
            //
            // If base > end then ignore this resource descriptor
            //
            *pdlBase = 0;
            *pdlLen = 0;
            bValidResDes = FALSE;
        }
        break;
            
    case ResType_IRQ:
        *pdlBase = pIRQResData(pData)->IRQ_Header.IRQD_Alloc_Num;
        // IRQ len is always 1
        *pdlLen = 1;
        break;
            
    case ResType_DMA:
        *pdlBase = pDMAResData(pData)->DMA_Header.DD_Alloc_Chan;
        // DMA len is always 1
        *pdlLen = 1;
        break;
            
    case ResType_IO:
        if (pIOResData(pData)->IO_Header.IOD_Alloc_Base <= pIOResData(pData)->IO_Header.IOD_Alloc_End) {
        
            *pdlBase = pIOResData(pData)->IO_Header.IOD_Alloc_Base;
            *pdlLen = pIOResData(pData)->IO_Header.IOD_Alloc_End -
                *pdlBase + 1;
        } else {
            //
            // If base > end then ignore this resource descriptor
            //
            *pdlBase = 0;
            *pdlLen = 0;
            bValidResDes = FALSE;
        }
        break;
          
    default:
        ASSERT(FALSE);
        *pdlBase = 0;
        *pdlLen = 0;
        break;
    }

    return bValidResDes;
}


//
//This function creates resources for the given subtree rooted at
//the given device
//
//INPUT:
//  pDevice -- the root device of the subtree
//  ResType -- resource type to be created
//  LogConfType -- logconf type to be created from
//
//OUTPUT:
//  NONE
//
// This function may throw CMemoryException
//
void
CResourceList::CreateSubtreeResourceList(
    CDevice* pDeviceStart,
    RESOURCEID ResType,
    ULONG LogConfType,
    ULONG AltLogConfType
    )
{
    LOG_CONF lc;
    RES_DES rd, rdPrev;
    RESOURCEID ResId;
    BOOL Forced;
    CMachine* pMachine = pDeviceStart->m_pMachine;
    ASSERT(pMachine);

    while (pDeviceStart) 
    {
        //
        // We will try to get a LogConf for either the LogConfType (which defaults to
        // ALLOC_LOG_CONF) or the AltLogConfType (which defaults to BOOT_LOG_CONF).
        // We need to do this because on Win2000 a device that only has a BOOT_LOG_CONF
        // will still consume those resources, even if it does not have an ALLOC_LOG_CONF.
        // So we need to first check the ALLOC_LOG_CONF and if that fails check the
        // BOOT_LOG_CONF.
        //
        if (pMachine->CmGetFirstLogConf(pDeviceStart->GetDevNode(), &lc, LogConfType) ||
            pMachine->CmGetFirstLogConf(pDeviceStart->GetDevNode(), &lc, AltLogConfType)) 
        {
            rdPrev = 0;

            if (pMachine->CmGetNextResDes(&rd, lc, ResType, &ResId)) 
            {
                ULONG DataSize;
                DWORDLONG dlBase, dlLen;

                do 
                {
                    DataSize = pMachine->CmGetResDesDataSize(rd);

                    if (DataSize) 
                    {
                        // need this to use a different image overlay for
                        // forced allocated resource
                        Forced = pMachine->CmGetFirstLogConf(pDeviceStart->GetDevNode(),
                                NULL, FORCED_LOG_CONF);
                                
                        BufferPtr<BYTE> DataPtr(DataSize);
                        
                        if (pMachine->CmGetResDesData(rd, DataPtr, DataSize)) 
                        {
                            if (ExtractResourceValue(ResType, DataPtr, &dlBase, &dlLen))
                            {
                                SafePtr<CResource> ResPtr;
                                
                                CResource* pRes;
                                
                                pRes = new CResource(pDeviceStart, ResType, dlBase,
                                        dlLen, Forced, FALSE);
                                ResPtr.Attach(pRes);
                                InsertResourceToList(pRes);
                                ResPtr.Detach();
                            }
                        }
                    }
                    
                    if (rdPrev)
                        pMachine->CmFreeResDesHandle(rdPrev);
                    
                    rdPrev = rd;
                    
                }while (pMachine->CmGetNextResDes(&rd, rdPrev, ResType, &ResId));
                
                //free the last resource descriptor handle
                pMachine->CmFreeResDesHandle(rd);
            }
            
            pMachine->CmFreeLogConfHandle(lc);
        }
        
        if (pDeviceStart->GetChild())
            CreateSubtreeResourceList(pDeviceStart->GetChild(), ResType, LogConfType, AltLogConfType);
        
        pDeviceStart = pDeviceStart->GetSibling();
    }
}


// This function creates a resource tree
// INPUT:
//  ppResRoot   -- buffer to receive the tree root
//
BOOL
CResourceList::CreateResourceTree(
    CResource** ppResRoot
    )
{
    ASSERT(ppResRoot);

    *ppResRoot = NULL;

    if (!m_listRes.IsEmpty()) 
    {
        POSITION pos = m_listRes.GetHeadPosition();
        CResource* pResFirst;

        pResFirst = m_listRes.GetNext(pos);
        *ppResRoot = pResFirst;

        while (NULL != pos) 
        {
            CResource* pRes = m_listRes.GetNext(pos);
            InsertResourceToTree(pRes, pResFirst, TRUE);
        }
    }
    
    return TRUE;
}

BOOL
CResourceList::InsertResourceToTree(
    CResource* pRes,
    CResource* pResRoot,
    BOOL       ForcedInsert
    )
{
    CResource* pResLast;

    while (pResRoot) 
    {
        if (pRes->EnclosedBy(*pResRoot)) 
        {
            // this resource is either the pResRoot child or grand child
            // figure out which one it is
            if (!pResRoot->GetChild()) 
            {
                pResRoot->SetChild(pRes);
                pRes->SetParent(pResRoot);
            }
            
            else if (!InsertResourceToTree(pRes, pResRoot->GetChild(), FALSE)) 
            {
                // the Resource is not a grand child of pResRoot.
                // search for the last child of pResRoot
                CResource* pResSibling;
                pResSibling = pResRoot->GetChild();

                while (pResSibling->GetSibling()) 
                    pResSibling = pResSibling->GetSibling();
                
                pResSibling->SetSibling(pRes);
                pRes->SetParent(pResRoot);
            }
            
            return TRUE;
        }
        
        pResLast = pResRoot;
        pResRoot = pResRoot->GetSibling();
    }
    
    if (ForcedInsert) 
    {
        // when we reach here, pResLast is the last child
        pResLast->SetSibling(pRes);
        pRes->SetParent(pResLast->GetParent());
        return TRUE;
    }
    
    return FALSE;
}


CResourceList::~CResourceList()
{
    if (!m_listRes.IsEmpty()) 
    {
        POSITION pos = m_listRes.GetHeadPosition();

        while (NULL != pos) 
        {
            delete m_listRes.GetNext(pos);
        }
        
        m_listRes.RemoveAll();
    }
}

BOOL
CResourceList::GetFirst(
    CResource** ppRes,
    PVOID&      Context
    )
{
    ASSERT(ppRes);

    if (!m_listRes.IsEmpty()) 
    {
        POSITION pos = m_listRes.GetHeadPosition();
        *ppRes = m_listRes.GetNext(pos);
        Context = pos;
        return TRUE;
    }
    
    Context = NULL;
    *ppRes = NULL;

    return FALSE;
}

BOOL
CResourceList::GetNext(
    CResource** ppRes,
    PVOID&      Context
    )
{
    ASSERT(ppRes);

    POSITION pos = (POSITION)Context;

    if (NULL != pos) 
    {
        *ppRes = m_listRes.GetNext(pos);
        Context = pos;
        return TRUE;
    }
    
    *ppRes = NULL;
    return FALSE;
}

//
// This function inserts the given resource to class's resource list
// The resources are kept in accending sorted order
void
CResourceList::InsertResourceToList(
    CResource* pRes
    )
{
    POSITION pos;
    CResource* pSrc;
    DWORDLONG dlBase, dlLen;
    pRes->GetValue(&dlBase, &dlLen);

    pos = m_listRes.GetHeadPosition();

    while (NULL != pos) 
    {
        POSITION posSave = pos;
        pSrc = m_listRes.GetNext(pos);

        if (*pRes <= *pSrc) 
        {
            m_listRes.InsertBefore(posSave, pRes);
            return;
        }
    }
    
    m_listRes.AddTail(pRes);
}


inline
CItemIdentifier*
CResource::CreateIdentifier()
{
    return new CResourceIdentifier(*this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\cfolder.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    cfolder.cpp

Abstract:

    This module implements CFolder and its releated classes.

Author:

    William Hsieh (williamh) created

Revision History:


--*/
#include "devmgr.h"
#include "clsgenpg.h"
#include "devgenpg.h"
#include "devdrvpg.h"
#include "devpopg.h"
#include "devdetpg.h"
#include "hwprof.h"
#include "devrmdlg.h"
#include "printer.h"
#include <devguid.h>
#include <initguid.h>
#include <oleacc.h>


const TCHAR* OCX_TREEVIEW = TEXT("{CD6C7868-5864-11D0-ABF0-0020AF6B0B7A}");

const MMCMENUITEM ViewDevicesMenuItems[TOTAL_VIEWS] =
{
    {IDS_VIEW_DEVICESBYTYPE, IDS_MENU_STATUS_DEVBYTYPE, IDM_VIEW_DEVICESBYTYPE, VIEW_DEVICESBYTYPE},
    {IDS_VIEW_DEVICESBYCONNECTION, IDS_MENU_STATUS_DEVBYCONNECTION, IDM_VIEW_DEVICESBYCONNECTION, VIEW_DEVICESBYCONNECTION},
    {IDS_VIEW_RESOURCESBYTYPE, IDS_MENU_STATUS_RESBYTYPE, IDM_VIEW_RESOURCESBYTYPE, VIEW_RESOURCESBYTYPE},
    {IDS_VIEW_RESOURCESBYCONNECTION, IDS_MENU_STATUS_RESBYCONNECTION, IDM_VIEW_RESOURCESBYCONNECTION, VIEW_RESOURCESBYCONNECTION}
};

const RESOURCEID ResourceTypes[TOTAL_RESOURCE_TYPES] =
{
    ResType_Mem,
    ResType_IO,
    ResType_DMA,
    ResType_IRQ
};


///////////////////////////////////////////////////////////////////
/// CScopeItem implementations
///

BOOL
CScopeItem::Create()
{
    m_strName.LoadString(g_hInstance, m_iNameStringId);
    m_strDesc.LoadString(g_hInstance, m_iDescStringId);
    return TRUE;
}

HRESULT
CScopeItem::GetDisplayInfo(
                          LPSCOPEDATAITEM pScopeDataItem
                          )
{
    if (!pScopeDataItem) {
        return E_INVALIDARG;
    }

    if (SDI_STR & pScopeDataItem->mask) {
        pScopeDataItem->displayname = (LPTSTR)(LPCTSTR)m_strName;
    }

    if (SDI_IMAGE & pScopeDataItem->mask) {
        pScopeDataItem->nImage = m_iImage;
    }

    if (SDI_OPENIMAGE & pScopeDataItem->mask) {
        pScopeDataItem->nOpenImage = m_iOpenImage;
    }

    return S_OK;
}

BOOL
CScopeItem::EnumerateChildren(
                             int Index,
                             CScopeItem** ppScopeItem
                             )
{
    if (!ppScopeItem || Index >= m_listChildren.GetCount()) {
        return FALSE;
    }

    POSITION pos = m_listChildren.FindIndex(Index);
    *ppScopeItem = m_listChildren.GetAt(pos);

    return TRUE;
}

HRESULT
CScopeItem::Reset()
{
    //
    // We have not enumerated!
    //
    m_Enumerated = FALSE;

    //
    // If there are folder created from this scope item,
    // walk through all of them and tell each one
    // to reset the cached machine object
    //
    HRESULT hr = S_OK;

    if (!m_listFolder.IsEmpty()) {
        CFolder* pFolder;
        POSITION pos = m_listFolder.GetHeadPosition();

        while (NULL != pos) {
            pFolder = m_listFolder.GetNext(pos);
            hr = pFolder->Reset();
        }
    }

    return hr;
}

CCookie*
CScopeItem::FindSelectedCookieData(
                                  CResultView** ppResultView
                                  )
{
    CFolder* pFolder;
    CResultView* pResultView;

    //
    // This routine returns the Selected Cookie in the result view if it has
    // the focus.  This is done by locating the folder from the scopeitem.
    // If the folder is not selected, the current result view is accessed to
    // get the current selected cookie.  If any of these fail a NULL value is
    // returned.  Optionally the current CResultView class is returned.
    //
    POSITION pos = m_listFolder.GetHeadPosition();

    while (NULL != pos) {
        pFolder = m_listFolder.GetNext(pos);

        if (this == pFolder->m_pScopeItem) {
            if (!pFolder->m_bSelect &&
                (pResultView = pFolder->GetCurResultView()) != NULL) {
                if (ppResultView) {
                    *ppResultView = pResultView;
                }

                return pResultView->GetSelectedCookie();
            }
        }
    }

    return NULL;
}

CScopeItem::~CScopeItem()
{
    if (!m_listChildren.IsEmpty()) {
        CScopeItem* pChild;
        POSITION pos;

        pos = m_listChildren.GetHeadPosition();

        while (NULL != pos) {
            pChild = m_listChildren.GetNext(pos);
            delete pChild;
        }

        m_listChildren.RemoveAll();
    }

    if (!m_listFolder.IsEmpty()) {
        POSITION pos;
        pos = m_listFolder.GetHeadPosition();

        while (NULL != pos) {
            //
            // DO NOT delete it!!!!
            //
            (m_listFolder.GetNext(pos))->Release();
        }

        m_listFolder.RemoveAll();
    }
}

CFolder*
CScopeItem::CreateFolder(
                        CComponent* pComponent
                        )
{
    ASSERT(pComponent);

    CFolder* pFolder;
    pFolder = new CFolder(this, pComponent);

    if (pFolder) {
        m_listFolder.AddTail(pFolder);
        pFolder->AddRef();
    }

    else {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return pFolder;
}

HRESULT
CScopeItem::AddMenuItems(
                        LPCONTEXTMENUCALLBACK pCallback,
                        long* pInsertionAllowed
                        )
{
    CCookie* pSelectedCookie;
    CResultView* pResultView;

    if ((pSelectedCookie = FindSelectedCookieData(&pResultView)) != NULL) {
        //
        // Add menu items for the Action menu.
        //
        return pResultView->AddMenuItems(pSelectedCookie, pCallback,
                                         pInsertionAllowed, FALSE);
    }

    else {
        return S_OK;
    }
}

HRESULT
CScopeItem::MenuCommand(
                       long lCommandId
                       )
{
    CCookie* pSelectedCookie;
    CResultView* pResultView;

    if ((pSelectedCookie = FindSelectedCookieData(&pResultView)) != NULL) {
        //
        // Handle menu requests for the Action menu.
        //
        return pResultView->MenuCommand(pSelectedCookie, lCommandId);
    }

    else {
        return S_OK;
    }
}

HRESULT
CScopeItem::QueryPagesFor()
{
    //
    // We do not have property pages for scope item
    //
    CCookie* pSelectedCookie;

    if ((pSelectedCookie = FindSelectedCookieData(NULL)) != NULL) {
        return S_OK;
    }

    else {
        return S_FALSE;
    }
}

HRESULT
CScopeItem::CreatePropertyPages(
                               LPPROPERTYSHEETCALLBACK lpProvider,
                               LONG_PTR handle
                               )
{
    CCookie* pSelectedCookie;
    CResultView* pResultView;

    if ((pSelectedCookie = FindSelectedCookieData(&pResultView)) != NULL) {
        return pResultView->CreatePropertyPages(pSelectedCookie, lpProvider, handle);
    }

    else {
        return S_OK;
    }
}


///////////////////////////////////////////////////////////////////
/// CFolder implementations
///

CFolder::CFolder(
                CScopeItem* pScopeItem,
                CComponent* pComponent
                )
{
    ASSERT(pScopeItem && pComponent);

    m_pScopeItem = pScopeItem;
    m_pComponent = pComponent;
    m_Show = FALSE;
    m_pMachine = NULL;
    m_bSelect = FALSE;
    m_pOleTaskString = NULL;
    m_Ref = 0;
    m_FirstTimeOnShow = TRUE;
    m_Signature = FOLDER_SIGNATURE_DEVMGR;
    m_pViewTreeByType = NULL;
    m_pViewTreeByConnection = NULL;
    m_pViewResourcesByType = NULL;
    m_pViewResourcesByConnection = NULL;
    m_CurViewType = VIEW_DEVICESBYTYPE;
    m_pCurView = m_pViewTreeByType;
    m_ShowHiddenDevices = FALSE;
}

CFolder::~CFolder()
{
    if (m_pViewTreeByType) {
        delete m_pViewTreeByType;
    }

    if (m_pViewTreeByConnection) {
        delete m_pViewTreeByConnection;
    }

    if (m_pViewResourcesByType) {
        delete m_pViewResourcesByType;
    }

    if (m_pViewResourcesByConnection) {
        delete m_pViewResourcesByConnection;
    }
}

HRESULT
CFolder::Compare(
                MMC_COOKIE cookieA,
                MMC_COOKIE cookieB,
                int  nCol,
                int* pnResult
                )
{
    ASSERT(pnResult);

    //
    // We do not have anything in the result pane, thus
    // comparision makes no sense.
    //
    *pnResult = 0;

    return S_OK;
}

HRESULT
CFolder::GetDisplayInfo(
                       LPRESULTDATAITEM pResultDataItem
                       )
{
    if (!pResultDataItem) {
        return E_POINTER;
    }

    ASSERT(m_pScopeItem);

    //
    // This only take care of scope pane item(displaying scope pane node
    // on the result pane). The derived classes should take care of
    // result items.
    //
    if (RDI_STR & pResultDataItem->mask) {
        if (0 == pResultDataItem->nCol) {
            if (m_pOleTaskString)
                FreeOleTaskString(m_pOleTaskString);
            m_pOleTaskString = AllocOleTaskString(m_pScopeItem->GetNameString());

            if (m_pOleTaskString) {
                pResultDataItem->str = m_pOleTaskString;
            }

            else {
                m_strScratch = m_pScopeItem->GetNameString();
                pResultDataItem->str = (LPTSTR)(LPCTSTR)m_strScratch;
            }
        }

        else if (2 == pResultDataItem->nCol) {
            if (m_pOleTaskString) {
                FreeOleTaskString(m_pOleTaskString);
            }

            m_pOleTaskString = AllocOleTaskString(m_pScopeItem->GetDescString());

            if (m_pOleTaskString) {
                pResultDataItem->str = m_pOleTaskString;
            }

            else {
                m_strScratch = m_pScopeItem->GetDescString();
                pResultDataItem->str = (LPTSTR)(LPCTSTR)m_strScratch;
            }
        }

        else {
            return S_FALSE;
        }
    }

    if (RDI_IMAGE & pResultDataItem->mask) {
        pResultDataItem->nImage = m_pScopeItem->GetImageIndex();
    }

    return S_OK;
}

HRESULT
CFolder::AddMenuItems(
                     CCookie* pCookie,
                     LPCONTEXTMENUCALLBACK pCallback,
                     long* pInsertionAllowed
                     )
{
    ASSERT(pCookie);

    HRESULT hr = S_OK;

    //
    // If the cookie points to a scope item, add view menu items
    //
    if (NULL == pCookie->GetResultItem()) {

        ASSERT(m_pScopeItem == pCookie->GetScopeItem());

        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW) {
            long Flags;

            for (int i = 0; i < TOTAL_VIEWS; i++) {
                if (m_CurViewType == ViewDevicesMenuItems[i].Type) {
                    Flags = MF_ENABLED | MF_CHECKED | MFT_RADIOCHECK;
                }

                else {
                    Flags = MF_ENABLED;
                }

                hr = AddMenuItem(pCallback,
                                 ViewDevicesMenuItems[i].idName,
                                 ViewDevicesMenuItems[i].idStatusBar,
                                 ViewDevicesMenuItems[i].lCommandId,
                                 CCM_INSERTIONPOINTID_PRIMARY_VIEW,
                                 Flags,
                                 0);
                if (FAILED(hr)) {
                    break;
                }
            }

            //
            // Add "Show hidden devices" menu item
            //
            if (SUCCEEDED(hr)) {
                hr = AddMenuItem(pCallback, 0, 0, 0, CCM_INSERTIONPOINTID_PRIMARY_VIEW,
                                 MF_ENABLED, CCM_SPECIAL_SEPARATOR);

                if (SUCCEEDED(hr)) {
                    if (m_ShowHiddenDevices) {
                        Flags = MF_ENABLED | MF_CHECKED;
                    }

                    else {
                        Flags = MF_ENABLED;
                    }

                    hr = AddMenuItem(pCallback, IDS_SHOW_ALL, IDS_MENU_STATUS_HIDDEN_DEVICES, IDM_SHOW_ALL,
                                     CCM_INSERTIONPOINTID_PRIMARY_VIEW, Flags, 0);
                }
            }
        }
    }

    else {
        if (m_pCurView) {
            //
            // Add menu items for the Context menu in the result pane.
            //
            hr = m_pCurView->AddMenuItems(pCookie, pCallback,
                                          pInsertionAllowed, TRUE);
        }

        else {
            hr = S_OK;
        }
    }

    return hr;
}

HRESULT
CFolder::MenuCommand(
                    CCookie* pCookie,
                    long lCommandId
                    )
{
    if (NULL == pCookie->GetResultItem()) {
        ASSERT(m_pScopeItem == pCookie->GetScopeItem());

        //
        // Convert menu id to view type;
        //
        VIEWTYPE ViewType = m_CurViewType;
        BOOL fShowHiddenDevices = m_ShowHiddenDevices;

        switch (lCommandId) {
        case IDM_VIEW_DEVICESBYTYPE:
            ViewType = VIEW_DEVICESBYTYPE;
            break;

        case IDM_VIEW_DEVICESBYCONNECTION:
            ViewType = VIEW_DEVICESBYCONNECTION;
            break;

        case IDM_VIEW_RESOURCESBYTYPE:
            ViewType = VIEW_RESOURCESBYTYPE;
            break;

        case IDM_VIEW_RESOURCESBYCONNECTION:
            ViewType = VIEW_RESOURCESBYCONNECTION;
            break;

        case IDM_SHOW_ALL:
            fShowHiddenDevices = !fShowHiddenDevices;
            break;

        default:
            //not view menu. do nothing
            return S_OK;
            break;
        }

        if (!SelectView(ViewType, fShowHiddenDevices)) {
            return HRESULT_FROM_WIN32(GetLastError());
        }

        //
        // Reselect the scopeitem
        //
        return m_pComponent->m_pConsole->SelectScopeItem(*m_pScopeItem);
    }

    else {
        if (m_pCurView) {
            //
            // Handle menu requests for the Context menu in the result pane.
            //
            return m_pCurView->MenuCommand(pCookie, lCommandId);
        }

        else {
            return S_OK;
        }
    }
}

HRESULT
CFolder::QueryPagesFor(
                      CCookie* pCookie
                      )
{
    //
    // We do not have property pages for scope item
    //
    if (NULL == pCookie->GetResultItem()) {
        ASSERT(m_pScopeItem == pCookie->GetScopeItem());

        return S_FALSE;
    }

    //
    // The cookie points to result item, let the current
    // view handle it
    //
    if (m_pCurView) {
        return m_pCurView->QueryPagesFor(pCookie);
    }

    else {
        return S_FALSE;
    }
}

HRESULT
CFolder::CreatePropertyPages(
                            CCookie* pCookie,
                            LPPROPERTYSHEETCALLBACK lpProvider,
                            LONG_PTR handle
                            )
{
    if (NULL == pCookie->GetResultItem()) {
        ASSERT(m_pScopeItem == pCookie->GetScopeItem());

        return S_OK;
    }

    if (m_pCurView) {
        return m_pCurView->CreatePropertyPages(pCookie, lpProvider, handle);
    }

    else {
        return S_OK;
    }
}

BOOL
CFolder::SelectView(
                   VIEWTYPE ViewType,
                   BOOL     fShowHiddenDevices
                   )
{
    CResultView* pNewView;

    if (m_CurViewType == ViewType &&
        m_ShowHiddenDevices == fShowHiddenDevices &&
        m_pCurView) {
        return TRUE;
    }

    switch (ViewType) {
    case VIEW_DEVICESBYTYPE:
        if (!m_pViewTreeByType) {
            m_pViewTreeByType = new CViewTreeByType();

            if (m_pViewTreeByType) {

                m_pViewTreeByType->SetFolder(this);
            }
        }

        pNewView = m_pViewTreeByType;
        break;

    case VIEW_DEVICESBYCONNECTION:
        if (!m_pViewTreeByConnection) {
            m_pViewTreeByConnection = new CViewTreeByConnection();

            if (m_pViewTreeByConnection) {

                m_pViewTreeByConnection->SetFolder(this);
            }
        }

        pNewView = m_pViewTreeByConnection;
        break;

    case VIEW_RESOURCESBYTYPE:
        if (!m_pViewResourcesByType) {
            m_pViewResourcesByType = new CViewResourceTree(IDS_STATUS_RESOURCES_BYTYPE);

            if (m_pViewResourcesByType) {

                m_pViewResourcesByType->SetFolder(this);
            }
        }

        pNewView = m_pViewResourcesByType;
        break;

    case VIEW_RESOURCESBYCONNECTION:
        if (!m_pViewResourcesByConnection) {
            m_pViewResourcesByConnection = new CViewResourceTree(IDS_STATUS_RESOURCES_BYCONN);

            if (m_pViewResourcesByConnection) {

                m_pViewResourcesByConnection->SetFolder(this);
            }
        }

        pNewView = m_pViewResourcesByConnection;
        break;

    default:
        pNewView = NULL;
        break;
    }

    if (pNewView) {
        //
        // Let the view know that it is being diselected.
        //
        if (m_pCurView) {
            if (m_CurViewType != ViewType) {
                m_pComponent->SetDirty();
            }
        }

        //
        // Let the new active view know that it is being selected.
        //
        m_pCurView = pNewView;
        m_CurViewType = ViewType;
        m_ShowHiddenDevices = fShowHiddenDevices;
    }

    return TRUE;
}

HRESULT
CFolder::OnShow(
               BOOL fShow
               )
{
    if (fShow && !m_pMachine) {

        ASSERT(m_pComponent);

        if (!m_pComponent->AttachFolderToMachine(this, &m_pMachine)) {
            
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }

    m_Show = fShow;

    if (m_pMachine) {

        if (!SelectView(m_CurViewType, m_ShowHiddenDevices)) {
            
            return E_UNEXPECTED;
        }

        if (m_pCurView) {
            
            if (m_FirstTimeOnShow && m_Show) {
                
                TCHAR WarningMsg[MAX_PATH * 3];
                int ReturnValue;

                //
                // Subsequent calls are not the first time anymore.
                //
                m_FirstTimeOnShow = FALSE;

                //
                // This is the first time we show the folder.
                // Put up a message box to warn user if
                // (1) The machine is a remote machine or
                // (2) The user does not have the Adminstator privilege.
                // (3) We can not connect to the remote machine
                //
                ASSERT(m_pComponent && m_pComponent->m_pConsole);

                //
                // Connect to a remote machine
                //
                if (!m_pMachine->IsLocal()) {
                    
                    String strMsg;

                    //
                    // Display a warning if we cannot connect to the remote machine
                    //
                    if (!VerifyMachineName(m_pMachine->GetRemoteMachineFullName())) {

                        TCHAR WarningFormat[MAX_PATH * 3];
                        LPVOID lpLastError = NULL;

                        if (LoadString(g_hInstance,
                                       IDS_INVALID_COMPUTER_NAME,
                                       WarningFormat,
                                       ARRAYLEN(WarningFormat)
                                       ) &&
                            FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                          FORMAT_MESSAGE_FROM_SYSTEM | 
                                          FORMAT_MESSAGE_IGNORE_INSERTS,
                                          NULL,
                                          GetLastError(),
                                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                          (LPTSTR)&lpLastError,
                                          0,
                                          NULL)) {

                            StringCchPrintf(WarningMsg,
                                            ARRAYLEN(WarningMsg),
                                            WarningFormat, 
                                            m_pMachine->GetMachineDisplayName(), 
                                            lpLastError
                                            );

                            m_pComponent->m_pConsole->MessageBox((LPCTSTR)WarningMsg,
                                                                 (LPCTSTR)g_strDevMgr,
                                                                 MB_ICONERROR | MB_OK,
                                                                 &ReturnValue);
                        }

                        if (lpLastError) {

                            LocalFree(lpLastError);
                        }
                        
                        //
                        // Otherwise display a warning that we are connect to a remote machine and
                        // device manager will run in a neutered mode.
                        //
                    } else {

                        strMsg.LoadString(g_hInstance, IDS_REMOTE_WARNING2);
                        ::LoadString(g_hInstance, IDS_REMOTE_WARNING1, WarningMsg, ARRAYLEN(WarningMsg));
                        lstrcat(WarningMsg, (LPCTSTR)strMsg);
                        m_pComponent->m_pConsole->MessageBox(WarningMsg,
                                                             (LPCTSTR)g_strDevMgr,
                                                             MB_ICONEXCLAMATION | MB_OK,
                                                             &ReturnValue);
                    }
                }

                //
                // Running local
                //
                else if (!g_HasLoadDriverNamePrivilege) {
                    
                    ::LoadString(g_hInstance, IDS_NOADMIN_WARNING, WarningMsg, ARRAYLEN(WarningMsg));
                    m_pComponent->m_pConsole->MessageBox(WarningMsg,
                                                         (LPCTSTR)g_strDevMgr,
                                                         MB_ICONEXCLAMATION | MB_OK,
                                                         &ReturnValue);
                }
            }

            return m_pCurView->OnShow(fShow);
        }
    }

    return S_OK;
}

HRESULT
CFolder::OnRestoreView(
                      BOOL* pfHandled
                      )
{
    ASSERT(pfHandled);

    if (!pfHandled) {
        return E_INVALIDARG;
    }

    HRESULT hr = OnShow(TRUE);

    if (SUCCEEDED(hr)) {
        *pfHandled = TRUE;
    }

    return hr;
}

HRESULT
CFolder::GetResultViewType(
                          LPOLESTR* ppViewType,
                          long*     pViewOptions
                          )
{
    ASSERT(pViewOptions);

    if (!SelectView(m_CurViewType, m_ShowHiddenDevices)) {
        return E_UNEXPECTED;
    }

    if (m_pCurView) {
        return m_pCurView->GetResultViewType(ppViewType, pViewOptions);
    }

    *pViewOptions  = MMC_VIEW_OPTIONS_NONE;

    return S_FALSE;
}

HRESULT
CFolder::Reset()
{
    //
    // Delete all views so that we will create new ones
    // when OnShow is called.
    //
    if (m_pViewTreeByType) {
        delete m_pViewTreeByType;
        m_pViewTreeByType = NULL;
    }

    if (m_pViewTreeByConnection) {
        delete m_pViewTreeByConnection;
        m_pViewTreeByConnection = NULL;
    }

    if (m_pViewResourcesByType) {
        delete m_pViewResourcesByType;
        m_pViewResourcesByType = NULL;
    }

    if (m_pViewResourcesByConnection) {
        delete m_pViewResourcesByConnection;
        m_pViewResourcesByConnection = NULL;
    }

    m_pCurView = NULL;
    m_FirstTimeOnShow = TRUE;
    m_pMachine = NULL;

    return S_OK;
}

HRESULT
CFolder::MachinePropertyChanged(
                               CMachine* pMachine
                               )
{
    //
    // Ignore the tvNotify(SELCHANGED) messages while the tree is changed.
    //
    if (m_pCurView) {
        m_pCurView->SetSelectOk(FALSE);
    }

    if (pMachine) {
        m_pMachine = pMachine;
    }

    if (m_pViewTreeByType) {
        m_pViewTreeByType->MachinePropertyChanged(pMachine);
    }

    if (m_pViewTreeByConnection) {
        m_pViewTreeByConnection->MachinePropertyChanged(pMachine);
    }

    if (m_pViewResourcesByType) {
        m_pViewResourcesByType->MachinePropertyChanged(pMachine);
    }

    if (m_pViewResourcesByConnection) {
        m_pViewResourcesByConnection->MachinePropertyChanged(pMachine);
    }

    if (m_pCurView) {
        m_pCurView->SetSelectOk(TRUE);
    }

    if (m_Show && pMachine) {
        OnShow(TRUE);
    }

    return S_OK;
}

HRESULT
CFolder::GetPersistData(
                       PBYTE pBuffer,
                       int BufferSize
                       )
{
    DEVMGRFOLDER_STATES states;
    states.Type = COOKIE_TYPE_SCOPEITEM_DEVMGR;
    states.CurViewType = m_CurViewType;
    states.ShowHiddenDevices = m_ShowHiddenDevices;

    if (BufferSize && !pBuffer) {
        return E_INVALIDARG;
    }

    if (BufferSize >= sizeof(states)) {
        ::memcpy(pBuffer, &states, sizeof(states));
        return S_OK;
    }

    return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
}

HRESULT
CFolder::SetPersistData(
                       PBYTE pData,
                       int Size
                       )
{
    if (!pData) {
        return E_POINTER;
    }

    if (!Size) {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    PDEVMGRFOLDER_STATES pStates = (PDEVMGRFOLDER_STATES)pData;

    if (COOKIE_TYPE_SCOPEITEM_DEVMGR == pStates->Type) {
        if ((VIEW_DEVICESBYTYPE == pStates->CurViewType) ||
            (VIEW_DEVICESBYCONNECTION == pStates->CurViewType) ||
            (VIEW_RESOURCESBYTYPE == pStates->CurViewType) ||
            (VIEW_RESOURCESBYCONNECTION == pStates->CurViewType)) {
            m_CurViewType = pStates->CurViewType;

            if (m_pCurView) {
                m_pCurView->OnShow(TRUE);
            }

            m_ShowHiddenDevices = pStates->ShowHiddenDevices;

            return S_OK;
        }
    }

    return E_UNEXPECTED;
}

HRESULT
CFolder::tvNotify(
                 HWND hwndTV,
                 CCookie* pCookie,
                 TV_NOTIFY_CODE Code,
                 LPARAM arg,
                 LPARAM param
                 )
{
    if (m_pCurView) {
        return m_pCurView->tvNotify(hwndTV, pCookie, Code, arg, param);
    }

    else {
        return S_FALSE;
    }
}

HRESULT
CFolder::OnOcxNotify(
                    MMC_NOTIFY_TYPE event,
                    LPARAM arg,
                    LPARAM param
                    )
{
    if (m_pCurView) {
        return m_pCurView->OnOcxNotify(event, arg, param);
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////
//// CResultView implementations
////

CResultView::~CResultView()
{
    if (m_pCookieComputer) {
        if (m_pIDMTVOCX) {
            m_pIDMTVOCX->DeleteAllItems();
        }

        delete m_pCookieComputer;
    }

    if (m_pIDMTVOCX) {
        m_pIDMTVOCX->Release();
    }

    DestroySavedTreeStates();
}

HRESULT
CResultView::OnShow(
                   BOOL fShow
                   )
{
    if (!fShow) {
        return S_OK;
    }

    SafeInterfacePtr<IUnknown> pUnk;
    HRESULT hr;
    CComponent* pComponent = m_pFolder->m_pComponent;
    ASSERT(pComponent);
    ASSERT(pComponent->m_pConsole);

    hr  = S_OK;

    if (NULL == m_pIDMTVOCX) {
        hr = pComponent->m_pConsole->QueryResultView(&pUnk);

        if (SUCCEEDED(hr)) {
            //
            // Get our OCX private interface
            //
            hr = pUnk->QueryInterface(IID_IDMTVOCX, (void**)&m_pIDMTVOCX);
        }

        if (SUCCEEDED(hr)) {
            m_pIDMTVOCX->Connect(pComponent, (MMC_COOKIE)this);
            m_hwndTV = m_pIDMTVOCX->GetWindowHandle();
            m_pIDMTVOCX->SetActiveConnection((MMC_COOKIE)this);
            
            //
            // Set up the annotation map for screen readers.
            //
            IAccPropServices *pAccPropSvc = NULL;
            hr = CoCreateInstance(CLSID_AccPropServices, 
                                  NULL,
                                  CLSCTX_SERVER,
                                  IID_IAccPropServices,
                                  (void**)&pAccPropSvc);
            
            if ((hr == S_OK) && pAccPropSvc) {
                //TRACE((TEXT("%s"), (LPTSTR)m_stringAnnotationMap));
                pAccPropSvc->SetHwndPropStr(m_hwndTV, OBJID_CLIENT, 0, PROPID_ACC_DESCRIPTIONMAP, (LPTSTR)m_stringAnnotationMap);
                pAccPropSvc->Release();
            }
            
            DisplayTree();

            String strStartupCommand;
            String strStartupDeviceId;

            strStartupCommand = GetStartupCommand();
            strStartupDeviceId = GetStartupDeviceId();

            if (!strStartupCommand.IsEmpty() && !strStartupDeviceId.IsEmpty() &&
                !strStartupCommand.CompareNoCase(DEVMGR_COMMAND_PROPERTY)) {
                hr = DoProperties(m_hwndTV, m_pSelectedCookie);
            }
        }
    }

    else {
        m_pIDMTVOCX->SetActiveConnection((MMC_COOKIE)this);

        if (!DisplayTree()) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return hr;
}

inline
LPCTSTR
CResultView::GetStartupDeviceId()
{
    return m_pFolder->m_pComponent->GetStartupDeviceId();
}

inline
LPCTSTR
CResultView::GetStartupCommand()
{
    return m_pFolder->m_pComponent->GetStartupCommand();
}

//
// This function is called when  machine states have changed.
//
// INPUT:
//      pMachine -- if NULL, the machine is being destroy.
//
// OUTPUT:
//      stanard OLE return code
HRESULT
CResultView::MachinePropertyChanged(
                                   CMachine* pMachine
                                   )
{
    if (pMachine) {
        m_pMachine = pMachine;
    }

    else {
        //
        // pMachine is NULL, the CMachine we associated with is being destroyed.
        //
        if (m_pCookieComputer) {
            ASSERT(!m_pSelectedItem && m_listExpandedItems.IsEmpty());

            //
            // Save the expanded states
            //
            SaveTreeStates(m_pCookieComputer);

            m_pIDMTVOCX->DeleteAllItems();
            m_pIDMTVOCX->SetImageList(TVSIL_NORMAL, NULL);

            delete m_pCookieComputer;

            //
            // Reset these because they are no longer valid.
            //
            m_pCookieComputer = NULL;
        }
    }

    return S_OK;
}

//
// This function saves the subtree states rooted by pCookieStart.
// It creates an identifier for each expanded node and inserts
// the identifier to the class memember, m_listExpandedItems.
//
// It also saves the selected cookie by creating an identifier and
// saving it in m_pSelectedItem.
//
// This function may throw CMemoryException
//
// INPUT:
//      pCookieStart -- subtree root
// OUTPUT:
//      NONE
void
CResultView::SaveTreeStates(
                           CCookie* pCookieStart
                           )
{
    CItemIdentifier* pItem;

    //
    // If we have a selected item, create an identifier for it
    //
    if (m_pSelectedCookie) {
        m_pSelectedItem = m_pSelectedCookie->GetResultItem()->CreateIdentifier();
        m_pSelectedCookie = NULL;
    }

    while (pCookieStart) {
        if (pCookieStart->IsFlagsOn(COOKIE_FLAGS_EXPANDED)) {
            pItem = pCookieStart->GetResultItem()->CreateIdentifier();
            m_listExpandedItems.AddTail(pItem);
        }

        if (pCookieStart->GetChild()) {
            SaveTreeStates(pCookieStart->GetChild());
        }

        pCookieStart = pCookieStart->GetSibling();
    }
}

void
CResultView::DestroySavedTreeStates()
{
    if (!m_listExpandedItems.IsEmpty()) {
        POSITION pos;
        pos = m_listExpandedItems.GetHeadPosition();

        while (NULL != pos) {
            delete m_listExpandedItems.GetNext(pos);
        }

        m_listExpandedItems.RemoveAll();
    }

    if (m_pSelectedItem) {
        delete m_pSelectedItem;
        m_pSelectedItem = NULL;
    }
}

//
// This function restores the expanded and selected state for the cookie.
//
// INPUT:
//      pCookie -- cookie to restore states for
// OUTPUT:
//      NONE
void
CResultView::RestoreSavedTreeState(
                                  CCookie* pCookie
                                  )
{
    //
    // If the cookie was expanded before, mark it so that DisplayTree
    // will expand it.
    //
    if (!m_listExpandedItems.IsEmpty()) {
        POSITION pos = m_listExpandedItems.GetHeadPosition();
        CItemIdentifier* pItem;

        while (NULL != pos) {
            pItem = m_listExpandedItems.GetNext(pos);

            if (*pItem == *pCookie) {
                pCookie->TurnOnFlags(COOKIE_FLAGS_EXPANDED);
                break;
            }
        }
    }

    if (m_pSelectedItem && (*m_pSelectedItem == *pCookie)) {
        m_pSelectedCookie = pCookie;
    }
}

BOOL
CResultView::DisplayTree()
{
    BOOL Result = FALSE;

    ASSERT(m_pIDMTVOCX);

    ::SendMessage(m_hwndTV, WM_SETREDRAW, FALSE, 0L);

    //
    // Ignore the tvNotify(SELCHANGED) messages while the tree is changed.
    //
    SetSelectOk(FALSE);

    m_pIDMTVOCX->DeleteAllItems();

    //
    // Only display the tree if there is something to display
    //
    if (m_pCookieComputer) {

        m_pIDMTVOCX->SetImageList(TVSIL_NORMAL, m_pMachine->DiGetClassImageList());
        m_pIDMTVOCX->SetStyle(TVS_HASBUTTONS | TVS_HASLINES | TVS_LINESATROOT);

        BOOL HasProblem = FALSE;

        //
        // Walks down the tree started from m_pCookieComputer
        //
        Result = DisplaySubtree(NULL, m_pCookieComputer, &HasProblem);

        if (HasProblem && Result) {
            m_pIDMTVOCX->Expand(TVE_EXPAND, (HTREEITEM)m_pCookieComputer->m_lParam);
        }

        //
        // If we have a pre-selected item, use it. Otherwise, use computer
        // as the selected node.
        //
        HTREEITEM hSelectedItem = (m_pSelectedCookie && m_pSelectedCookie->m_lParam) ?
                                  (HTREEITEM)m_pSelectedCookie->m_lParam :
                                  (HTREEITEM)m_pCookieComputer->m_lParam;
        SetSelectOk(TRUE);

        if (hSelectedItem) {
            m_pIDMTVOCX->SelectItem(TVGN_CARET, hSelectedItem);
            m_pIDMTVOCX->EnsureVisible(hSelectedItem);
        }
    }

    ::SendMessage(m_hwndTV, WM_SETREDRAW, TRUE, 0L);
    InvalidateRect(m_hwndTV, NULL, TRUE);

    return Result;
}

//
// This function walks through the given cookie subtree rooted by pCookie
// and insert each node into the TreeView OCX.
// INPUT:
//      htiParent -- HTREEITEM for the new cookie to be inserted
//                   if NULL is given, TVI_ROOT is assumed.
//      pCookie   -- the subtree root cookie to be displayed.
// OUTPUT:
//      none.
//
BOOL
CResultView::DisplaySubtree(
                           HTREEITEM htiParent,
                           CCookie* pCookie,
                           BOOL* pReportProblem
                           )
{
    TV_INSERTSTRUCT ti;
    CResultItem* pRltItem;
    HTREEITEM hti;
    BOOL bResource;
    BOOL fShowHiddenDevices = m_pFolder->ShowHiddenDevices();

    while (pCookie) {
        pRltItem = pCookie->GetResultItem();
        ti.item.state = INDEXTOOVERLAYMASK(0);
        bResource = FALSE;

        //
        // The cookie is not yet in the treeview.
        //
        pCookie->m_lParam = 0;

        if (COOKIE_TYPE_RESULTITEM_DEVICE == pCookie->GetType()) {
            DWORD Status, Problem;
            CDevice* pDevice = (CDevice*)pRltItem;

            //
            // This is a hidden device and we are not showing hidden devices
            //
            // Note that we need to special case these devices because they
            // are not shown in the tree view, but their visible children are shown.
            //
            if (!fShowHiddenDevices && pDevice->IsHidden()) {

                //
                // If the cookie has children, display them
                //
                CCookie* pCookieChild = pCookie->GetChild();
                BOOL ChildProblem = FALSE;

                if (pCookieChild) {
                    DisplaySubtree(htiParent, pCookieChild, &ChildProblem);
                }

                //
                // Continue on with the next device. This will skip all of the display
                // code below.
                //
                pCookie = pCookie->GetSibling();
                continue;
            }

            //
            // If the device is disabled then set the OVERLAYMASK to the Red X
            //
            if (pDevice->IsDisabled()) {
                ti.item.state = INDEXTOOVERLAYMASK(IDI_DISABLED_OVL - IDI_CLASSICON_OVERLAYFIRST + 1);
                *pReportProblem = TRUE;
            }

            //
            // If the device has a problem then set the OVERLAYMASK to the Yellow !
            //
            else if (pDevice->HasProblem()) {
                ti.item.state = INDEXTOOVERLAYMASK(IDI_PROBLEM_OVL - IDI_CLASSICON_OVERLAYFIRST + 1);
                *pReportProblem = TRUE;
            }

            //
            // if the device does not present, then set the state to TVIS_CUT. This grays out
            // the icon a bit so it looks like a ghost icon.
            //
            else if (pDevice->IsPhantom()) {
                ti.item.state = TVIS_CUT;
            }
        }

        else if (COOKIE_TYPE_RESULTITEM_CLASS == pCookie->GetType()) {
            CClass* pClass = (CClass*)pRltItem;

            //
            // If we don't have any devices to show for this class, or this
            // is a NoDisplayClass and we are not showing hidden devices,
            // then just get our next sibling and continue without showing
            // this class.
            //
            if ((0 == pClass->GetNumberOfDevices(fShowHiddenDevices)) ||
                (!fShowHiddenDevices && pClass->NoDisplay())) {

                //
                // Continue on with the next device. This will skip all of the display
                // code below.
                //
                pCookie = pCookie->GetSibling();
                continue;
            }
        }

        //
        // Is this a resource?
        //
        else if (COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY == pCookie->GetType() ||
                 COOKIE_TYPE_RESULTITEM_RESOURCE_IO == pCookie->GetType() ||
                 COOKIE_TYPE_RESULTITEM_RESOURCE_DMA == pCookie->GetType() ||
                 COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ == pCookie->GetType()) {
            bResource = TRUE;

            //
            // If this is a FORCED CONFIG resource then overlay the forced
            // config icon
            //
            if (((CResource*)pCookie->GetResultItem())->IsForced()) {
                ti.item.state = INDEXTOOVERLAYMASK(IDI_FORCED_OVL-IDI_CLASSICON_OVERLAYFIRST+1);
            }
        }


        ti.hParent = (htiParent != NULL) ? htiParent : TVI_ROOT;
        ti.hInsertAfter = TVI_SORT;
        ti.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_STATE;
        ti.item.iImage = ti.item.iSelectedImage = pRltItem->GetImageIndex();

        if (bResource) {
            ti.item.pszText = (LPTSTR)((CResource*)pRltItem)->GetViewName();
        }

        else {
            ti.item.pszText = (LPTSTR)pRltItem->GetDisplayName();
        }

        ti.item.lParam = (LPARAM)pCookie;
        ti.item.stateMask = TVIS_OVERLAYMASK | TVIS_CUT;
        hti = m_pIDMTVOCX->InsertItem(&ti);

        //
        // Save the HTREEITEM
        //
        pCookie->m_lParam = (LPARAM)hti;

        if (NULL != hti) {
            //
            // If the cookie has children, display them
            //
            CCookie* pCookieChild = pCookie->GetChild();
            BOOL ChildProblem = FALSE;

            if (pCookieChild) {
                if (bResource && htiParent &&
                    GetDescriptionStringID() == IDS_STATUS_RESOURCES_BYTYPE) {
                    //
                    // This is a child of a resource being viewed by type,
                    // so the tree needs to be flattened.  This is done by
                    // using the same parent.
                    //
                    DisplaySubtree(htiParent, pCookieChild, &ChildProblem);
                }

                else {
                    DisplaySubtree(hti, pCookieChild, &ChildProblem);
                }
            }

            //
            // If any of the device's children have a problem, or if
            // it was previously expanded, then expand it.
            //
            if (ChildProblem || pCookie->IsFlagsOn(COOKIE_FLAGS_EXPANDED)) {
                m_pIDMTVOCX->Expand(TVE_EXPAND, hti);
            }

            //
            // Propogate the child's problem state back to the parent
            //
            *pReportProblem |= ChildProblem;
        }

        pCookie = pCookie->GetSibling();
    }

    return TRUE;
}

HRESULT
CResultView::GetResultViewType(
                              LPOLESTR* ppViewType,
                              long*     pViewOptions
                              )
{
    ASSERT(ppViewType && pViewOptions);

    //
    // The caller is responsible for freeing the memory we allocated.
    //
    LPOLESTR polestr;
    polestr = AllocOleTaskString(OCX_TREEVIEW);

    if (!polestr) {
        return E_OUTOFMEMORY;
    }

    *ppViewType = polestr;

    //
    // We have not list view options
    //
    *pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

    return S_OK;
}

HRESULT
CResultView::AddMenuItems(
                         CCookie* pCookie,
                         LPCONTEXTMENUCALLBACK pCallback,
                         long*   pInsertionAllowed,
                         BOOL fContextMenu                   // True if for result view context menu
                         )
{
    HRESULT hr = S_OK;
    CDevice* pDevice = NULL;

    if (CCM_INSERTIONALLOWED_TOP & *pInsertionAllowed) {
        switch (pCookie->GetType()) {
        case COOKIE_TYPE_RESULTITEM_DEVICE:
        case COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ:
        case COOKIE_TYPE_RESULTITEM_RESOURCE_DMA:
        case COOKIE_TYPE_RESULTITEM_RESOURCE_IO:
        case COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY:
            if (m_pMachine->IsLocal() && g_HasLoadDriverNamePrivilege) {
                if (COOKIE_TYPE_RESULTITEM_DEVICE == pCookie->GetType()) {
                    pDevice = (CDevice*) pCookie->GetResultItem();
                } else {
                    //
                    // This is a resource item, get the pointer for the device
                    // object from the resource object.
                    //
                    CResource* pResource = (CResource*) pCookie->GetResultItem();
                    if (pResource) {
                        pDevice = pResource->GetDevice();
                    }
                }

                if (pDevice == NULL) {
                    break;
                }
                
                CClass* pClass = pDevice->GetClass();

                //
                // All devices can have their driver's updated except for legacy devices.
                //
                if (!IsEqualGUID(*pClass, GUID_DEVCLASS_LEGACYDRIVER)) {
                    hr = AddMenuItem(pCallback, IDS_UPDATEDRIVER, 
                                     IDS_MENU_STATUS_UPDATEDRIVER, IDM_UPDATEDRIVER,
                                     CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                     MF_ENABLED, 0);
                }

                //
                // Only show the Enable/Disable menu item if the device
                // can be disabled.
                //
                if (pDevice->IsDisableable()) {
                    if (pDevice->IsStateDisabled()) {
                        hr = AddMenuItem(pCallback, IDS_ENABLE, 
                                         IDS_MENU_STATUS_ENABLE, IDM_ENABLE,
                                         CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                         MF_ENABLED, 0);
                    } else {
                        hr = AddMenuItem(pCallback, IDS_DISABLE, 
                                         IDS_MENU_STATUS_DISABLE, IDM_DISABLE,
                                         CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                         MF_ENABLED, 0);
                    }
                }

                //
                // Only show the uninstall menu item if the device can be
                // uninstalled.
                //
                if (SUCCEEDED(hr) &&
                    pDevice->IsUninstallable()) {
                    hr = AddMenuItem(pCallback, IDS_REMOVE, 
                                     IDS_MENU_STATUS_REMOVE, IDM_REMOVE,
                                     CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                     MF_ENABLED, 0);
                }
            }

            // FALL THROUGH........

        case COOKIE_TYPE_RESULTITEM_CLASS:
            if (g_HasLoadDriverNamePrivilege) {

                if (SUCCEEDED(hr)) {
                    hr = AddMenuItem(pCallback, 0, 0, 0,
                                     CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                     MF_ENABLED, CCM_SPECIAL_SEPARATOR);
                }
                if (SUCCEEDED(hr)) {
                    hr = AddMenuItem(pCallback, IDS_REFRESH,
                                     IDS_MENU_STATUS_SCAN_CHANGES, IDM_REFRESH,
                                     CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                     MF_ENABLED, 0);
                }
            }

            if (fContextMenu) {
                if (SUCCEEDED(hr)) {
                    hr = AddMenuItem(pCallback, 0, 0, 0,
                                     CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                     MF_ENABLED, CCM_SPECIAL_SEPARATOR);
                }
                if (SUCCEEDED(hr)) {
                    hr = AddMenuItem(pCallback, IDS_PROPERTIES, 
                                     IDS_MENU_STATUS_PROPERTIES, IDM_PROPERTIES,
                                     CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                     MF_DEFAULT, CCM_SPECIAL_DEFAULT_ITEM);
                }
            }

            break;

        case COOKIE_TYPE_RESULTITEM_COMPUTER:
        case COOKIE_TYPE_RESULTITEM_RESTYPE:
            if (g_HasLoadDriverNamePrivilege) {
            
                hr = AddMenuItem(pCallback, IDS_REFRESH,
                                 IDS_MENU_STATUS_SCAN_CHANGES, IDM_REFRESH,
                                 CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                 MF_ENABLED, 0);
            }
            break;

        default:
            break;
        }
    }

    return hr;
}

// This function handles menu command for the device tree.
//
// INPUT: pCookie  -- the cookie
//        lCommandId -- the command. See AddMenuItems for valid command
//                      id for each type of cookie.
//
// OUTPUT:  HRESULT S_OK if succeeded.
//                  S_XXX error code.

HRESULT
CResultView::MenuCommand(
                        CCookie* pCookie,
                        long     lCommandId
                        )
{
    HRESULT hr = S_OK;

    //TRACE1(TEXT("Menu command, commandid = %lx\n"), lCommandId);
    ASSERT(pCookie);

    CResultItem* pResultItem = pCookie->GetResultItem();
    ASSERT(pResultItem);

    CDevice* pDevice = NULL;

    switch (pCookie->GetType()) {
    case COOKIE_TYPE_RESULTITEM_DEVICE:
        pDevice = (CDevice*)pResultItem;
        break;

    case COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ:
    case COOKIE_TYPE_RESULTITEM_RESOURCE_DMA:
    case COOKIE_TYPE_RESULTITEM_RESOURCE_IO:
    case COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY:
        CResource* pResource = (CResource*)pResultItem;
        if (pResource) {
            pDevice = pResource->GetDevice();
        }
        break;
    }

    switch (lCommandId) {
    case IDM_UPDATEDRIVER:
        if (pDevice) {
            BOOL Installed;
            DWORD RestartFlags = 0;
            DWORD Status = 0, Problem = 0;

            //
            // If the device has the DN_WILL_BE_REMOVED flag set and the user is
            // attempting to update the driver then we will prompt them for a 
            // reboot and include text in the prompt that explains this device
            // is in the process of being removed.
            //
            if (pDevice->GetStatus(&Status, &Problem) &&
                (Status & DN_WILL_BE_REMOVED)) {

                PromptForRestart(m_hwndTV, DI_NEEDRESTART, IDS_WILL_BE_REMOVED_NO_UPDATE_DRIVER);
            
            } else {
                //
                // Disable Refreshing while the Update Driver Wizard is up.
                //
                pDevice->m_pMachine->EnableRefresh(FALSE);
    
                HCURSOR hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
    
                Installed = pDevice->m_pMachine->InstallDevInst(m_hwndTV, pDevice->GetDeviceID(), TRUE, &RestartFlags);
    
                if (hCursorOld) {
                    SetCursor(hCursorOld);
                }
    
                //
                // Prompt for a restart if one is needed.  If the user does NOT answer
                // YES to the restart dialog then schedule a refresh since we might not
                // get one from a WM_DEVICECHANGE.
                //
                if (m_pMachine->IsLocal()) {
                    if (PromptForRestart(NULL, RestartFlags) == IDNO) {
                        pDevice->m_pMachine->ScheduleRefresh();
                    }
                }
    
                //
                // Enable Refreshing now that we are done updating the driver.
                //
                pDevice->m_pMachine->EnableRefresh(TRUE);
            }
        }
        break;

    case IDM_ENABLE:
    case IDM_DISABLE:
        if (pDevice) {
            DWORD RestartFlags = 0;
            DWORD Status = 0, Problem = 0;
            
            //
            // If the device has the DN_WILL_BE_REMOVED flag set and the user is
            // attempting to enable/disable the driver then we will prompt them for a 
            // reboot and include text in the prompt that explains this device
            // is in the process of being removed.
            //
            if (pDevice->GetStatus(&Status, &Problem) &&
                (Status & DN_WILL_BE_REMOVED)) {

                PromptForRestart(m_hwndTV, DI_NEEDRESTART, IDS_WILL_BE_REMOVED_NO_CHANGE_SETTINGS);
            
            } else {

                RestartFlags = pDevice->EnableDisableDevice(m_hwndTV,
                                                            (lCommandId == IDM_ENABLE));
    
                //
                // Update the toolbar buttons since the device just changed.
                //
                m_pFolder->m_pComponent->UpdateToolbar(pCookie);
    
                //
                // Prompt for a Restart if we are running locally.  
                // The PromptForRestart() API checks the flags to determine
                // if a restart is actually needed.
                //
                if (m_pMachine->IsLocal()) {
                    if (PromptForRestart(NULL, RestartFlags) == IDNO) {
                        m_pMachine->ScheduleRefresh();
                    }
                }
            }
        }
        break;

    case IDM_REMOVE:
        if (pDevice) {
            hr = RemoveDevice(pDevice);
        }
        break;

    case IDM_REFRESH:
        //
        // This will force every attached folder to recreate
        // its machine data
        //
        ASSERT(m_pMachine);

        if (!m_pMachine->Reenumerate()) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        break;

    case IDM_PROPERTIES:
        hr = DoProperties(m_hwndTV, pCookie);
        break;

    default:
        hr = S_OK;
        break;
    }

    return hr;
}

// This function reports if property pages are available for the
// given cookie. Returning S_FALSE,  the cookie's "properties" menu
// item will not displayed.
//
// INPUT: pCookie  -- the cookie
//
// OUTPUT:  HRESULT S_OK if pages are available for the cookie.
//                  S_FALSE if no pages are available for the cookie.
HRESULT
CResultView::QueryPagesFor(
                          CCookie* pCookie
                          )
{
    ASSERT(pCookie);

    if (COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ == pCookie->GetType() ||
        COOKIE_TYPE_RESULTITEM_RESOURCE_DMA == pCookie->GetType() ||
        COOKIE_TYPE_RESULTITEM_RESOURCE_IO == pCookie->GetType() ||
        COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY == pCookie->GetType() ||
        COOKIE_TYPE_RESULTITEM_CLASS == pCookie->GetType() ||
        COOKIE_TYPE_RESULTITEM_DEVICE == pCookie->GetType()) {
        return S_OK;
    }

    return S_FALSE;
}

// This function creates property page(s) for the given cookie.
//
// INPUT: pCookie  -- the cookie
//        lpProvider -- interface pointer to IPROPERTYSHEETCALLBACK
//                      used to add HPROPSHEETPAGE to the property sheet.
//        handle     -- handle for property change notification
//                      The handle is required for MMCPropertyChangeNotify
//                      API.
// OUTPUT:  HRESULT S_OK if succeeded.
//                  S_FALSE if no pages are added.
//                  S_XXX error code.
HRESULT
CResultView::CreatePropertyPages(
                                CCookie* pCookie,
                                LPPROPERTYSHEETCALLBACK lpProvider,
                                LONG_PTR    handle
                                )
{
//
// Design issue:
// We depend on the general page to do some houeskeeping works on the
// property sheet which is owned  and controlled by MMC running in a
// separate thread. General page is always the first page and its window
// is always created. If we need to subclass the property sheet someday,
// having our own General page always assure that we will get the window
// handle to the property sheet.
//
// The most important housekeeping work the General page does is to inform the
// associate device or class when a property sheet is being created
// or destroyed. A device can not be removed if it has a property sheet
// running. The machine can not refresh the device tree if there are property
// sheet(s) running on any devices/classes it contains. Property sheets
// created by a folder should be canceled when the folder is being
// destroyed.
//
// So far, no class installers have attempted to add their own General
// page and I believe it will be true in the future because 1). the page
// is too complicated and overloaded with features(and hard to implement) and
// 2). no major gains can be obtained by implementing a new one.
// To warn the developers who does their own General page,we will have a
// message box warn them about this and proceed with OUR general page.
//
    ASSERT(pCookie);

    CPropSheetData* ppsd = NULL;
    CMachine* pNewMachine = NULL;

    switch (pCookie->GetType()) {
    case COOKIE_TYPE_RESULTITEM_CLASS:
        CClass* pClass;
        pClass = (CClass*) pCookie->GetResultItem();
        ASSERT(pClass);
        
        //
        // Create a new CMachine object that just contains this specific device
        // and it's class.  We need to do this since the CDevice and CClass of 
        // the cookie that was passed into this API will get destroyed whenever
        // we get a WM_DEVICECHANGE notification.
        //
        PVOID Context;
        pNewMachine = new CMachine(m_pMachine->GetMachineFullName());

        CClass* pNewClass;

        if (pNewMachine->Initialize(NULL, NULL, *pClass) &&
            pNewMachine->GetFirstClass(&pNewClass, Context) &&
            pNewClass) {

            pNewMachine->m_ParentMachine = m_pMachine;
            m_pMachine->AttachChildMachine(pNewMachine);
            pNewMachine->SetPropertySheetShouldDestroy();

            ppsd = &pNewClass->m_psd;
    
            if (ppsd->Create(g_hInstance, m_hwndTV, MAX_PROP_PAGES, handle)) {
                CDevInfoList* pClassDevInfo;
    
                //
                // The CDevInfoList object is maintained by the CClass
                // object.
                //
                pClassDevInfo = pNewClass->GetDevInfoList();
    
                if (pClassDevInfo && pClassDevInfo->DiGetClassDevPropertySheet(NULL, 
                                                                               &ppsd->m_psh, 
                                                                               MAX_PROP_PAGES, 
                                                                               pNewMachine->IsLocal() ?
                                                                               DIGCDP_FLAG_ADVANCED : 
                                                                               DIGCDP_FLAG_REMOTE_ADVANCED)) {
                    if (pClassDevInfo->DiGetFlags(NULL) & DI_GENERALPAGE_ADDED) {
                        TCHAR szText[MAX_PATH];
                        LoadResourceString(IDS_GENERAL_PAGE_WARNING, szText,
                                           ARRAYLEN(szText));
    
                        int ReturnValue;
                        m_pFolder->m_pComponent->m_pConsole->MessageBox(
                                                                       szText, pNewClass->GetDisplayName(),
                                                                       MB_ICONEXCLAMATION | MB_OK, &ReturnValue);
                        //
                        // fall through to create our general page.
                        //
                    }
    
                    SafePtr<CClassGeneralPage> GenPagePtr;
                    CClassGeneralPage* pGenPage;
                    pGenPage = new CClassGeneralPage;
    
                    if (pGenPage) {
                        GenPagePtr.Attach(pGenPage);
                        HPROPSHEETPAGE hPage = pGenPage->Create(pNewClass);
    
                        //
                        // General page has to be the first page
                        //
                        if (ppsd->InsertPage(hPage, 0)) {
                            GenPagePtr.Detach();
                        } else {
                            ::DestroyPropertySheetPage(hPage);
                        }
                    }
                }
            }
        }
        break;

    case COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ:
    case COOKIE_TYPE_RESULTITEM_RESOURCE_DMA:
    case COOKIE_TYPE_RESULTITEM_RESOURCE_IO:
    case COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY:
    case COOKIE_TYPE_RESULTITEM_DEVICE:
        CDevice* pDevice;
        CDevice* pNewDevice;

        pNewDevice = NULL;

        if (COOKIE_TYPE_RESULTITEM_DEVICE == pCookie->GetType()) {
            pDevice = (CDevice*) pCookie->GetResultItem();
        } else {
            //
            // This is a resource item, get the pointer for the device
            // object from the resource object.
            //
            CResource* pResource = (CResource*) pCookie->GetResultItem();
            ASSERT(pResource);
            pDevice = pResource->GetDevice();
        }
        ASSERT(pDevice);

        //
        // Create a new CMachine object that just contains this specific device
        // and it's class.  We need to do this since the CDevice and CClass of 
        // the cookie that was passed into this API will get destroyed whenever
        // we get a WM_DEVICECHANGE notification.
        //
        PVOID DeviceContext;
        pNewMachine = new CMachine(m_pMachine->GetMachineFullName());

        if (pNewMachine->Initialize(NULL, pDevice->GetDeviceID()) &&
            pNewMachine->GetFirstDevice(&pNewDevice, DeviceContext) &&
            pNewDevice) {

            pNewMachine->m_ParentMachine = m_pMachine;
            m_pMachine->AttachChildMachine(pNewMachine);
            pNewMachine->SetPropertySheetShouldDestroy();

            ppsd = &pNewDevice->m_psd;
    
            if (ppsd->Create(g_hInstance, m_hwndTV, MAX_PROP_PAGES, handle)) {
    
                //
                // Add any class/device specific property pages
                //
                pNewMachine->DiGetClassDevPropertySheet(*pNewDevice, 
                                                        &ppsd->m_psh, 
                                                        MAX_PROP_PAGES, 
                                                        pNewMachine->IsLocal() ?
                                                            DIGCDP_FLAG_ADVANCED :
                                                            DIGCDP_FLAG_REMOTE_ADVANCED);
    
                //
                // Add the general tab
                //
                DWORD DiFlags = pNewMachine->DiGetFlags(*pNewDevice);
                DWORD DiFlagsEx = pNewMachine->DiGetExFlags(*pNewDevice);
                SafePtr<CDeviceGeneralPage> GenPagePtr;
    
                if (DiFlags & DI_GENERALPAGE_ADDED) {
                    TCHAR szText[MAX_PATH];
                    LoadResourceString(IDS_GENERAL_PAGE_WARNING, szText,
                                       ARRAYLEN(szText));
    
                    int ReturnValue;
                    m_pFolder->m_pComponent->m_pConsole->MessageBox(
                                                                   szText, pNewDevice->GetDisplayName(),
                                                                   MB_ICONEXCLAMATION | MB_OK, &ReturnValue);
                    //
                    // fall through to create our general page.
                    //
                }
    
                CDeviceGeneralPage* pGenPage = new CDeviceGeneralPage;
    
                if (pGenPage) {
                    GenPagePtr.Attach(pGenPage);
                    HPROPSHEETPAGE hPage = pGenPage->Create(pNewDevice);
    
                    if (hPage) {
                        //
                        // General page has to be the first page
                        //
                        if (ppsd->InsertPage(hPage, 0)) {
                            GenPagePtr.Detach();
                        } else {
                            ::DestroyPropertySheetPage(hPage);
                        }
                    }
                }
    
                //
                // Add the driver tab
                //
                SafePtr<CDeviceDriverPage> DrvPagePtr;
    
                if (!(DiFlags & DI_DRIVERPAGE_ADDED)) {
                    CDeviceDriverPage* pPage = new CDeviceDriverPage;
    
                    if (pPage) {
                        DrvPagePtr.Attach(pPage);
                        HPROPSHEETPAGE hPage = pPage->Create(pNewDevice);
    
                        if (hPage) {
                            if (ppsd->InsertPage(hPage)) {
                                DrvPagePtr.Detach();
                            } else {
                                ::DestroyPropertySheetPage(hPage);
                            }
                        }
                    }
                }
    
    
                //
                // add the details tab
                //
                // If the environment variable DEVMGR_SHOW_DETAILS does exist and it
                // is not 0 then we will show the details tab
                //
                TCHAR Buffer[MAX_PATH];
                DWORD BufferLen;
    
                if (((BufferLen = ::GetEnvironmentVariable(TEXT("DEVMGR_SHOW_DETAILS"),
                                                           Buffer,
                                                           sizeof(Buffer)/sizeof(TCHAR))) != 0) &&
                    ((BufferLen > 1) ||
                     (lstrcmp(Buffer, TEXT("0"))))) {
    
                    SafePtr<CDeviceDetailsPage> DetailsPagePtr;
    
                    CDeviceDetailsPage* pDetailsPage = new CDeviceDetailsPage;
                    DetailsPagePtr.Attach(pDetailsPage);
                    HPROPSHEETPAGE hPage = pDetailsPage->Create(pNewDevice);
    
                    if (hPage) {
                        if (ppsd->InsertPage(hPage)) {
                            DetailsPagePtr.Detach();
                        } else {
                            ::DestroyPropertySheetPage(hPage);
                        }
                    }
                }
    
                //
                // Add the resource tab
                //
                if (pNewDevice->HasResources() && !(DiFlags & DI_RESOURCEPAGE_ADDED)) {
                    pNewMachine->DiGetExtensionPropSheetPage(*pNewDevice,
                                                            AddPropPageCallback,
                                                            SPPSR_SELECT_DEVICE_RESOURCES,
                                                            (LPARAM)ppsd
                                                           );
                }
    
#ifndef _WIN64
                //
                // Add the power management tab
                //
                if (pNewMachine->IsLocal() && !(DiFlagsEx & DI_FLAGSEX_POWERPAGE_ADDED)) {
                    //
                    // Check if the device support power management
                    //
                    CPowerShutdownEnable ShutdownEnable;
                    CPowerWakeEnable WakeEnable;
    
                    if (ShutdownEnable.Open(pNewDevice->GetDeviceID()) || WakeEnable.Open(pNewDevice->GetDeviceID())) {
                        ShutdownEnable.Close();
                        WakeEnable.Close();
                        SafePtr<CDevicePowerMgmtPage> PowerMgmtPagePtr;
                        CDevicePowerMgmtPage* pPowerPage = new CDevicePowerMgmtPage;
    
                        if (pPowerPage) {
                            PowerMgmtPagePtr.Attach(pPowerPage);
                            HPROPSHEETPAGE hPage = pPowerPage->Create(pNewDevice);
    
                            if (hPage) {
                                if (ppsd->InsertPage(hPage)) {
                                    PowerMgmtPagePtr.Detach();
                                } else {
                                    ::DestroyPropertySheetPage(hPage);
                                }
                            }
                        }
                    }
                }
#endif
    
                //
                // Add any Bus specific property pages if this is the local machine
                //
                if (pNewMachine->IsLocal()) {
                    CBusPropPageProvider* pBusPropPageProvider = new CBusPropPageProvider();
    
                    if (pBusPropPageProvider) {
                        SafePtr<CBusPropPageProvider> ProviderPtr;
                        ProviderPtr.Attach(pBusPropPageProvider);
    
                        if (pBusPropPageProvider->EnumPages(pNewDevice, ppsd)) {
                            ppsd->AddProvider(pBusPropPageProvider);
                            ProviderPtr.Detach();
                        }
                    }
                }
            }
        }
        break;

    default:
        break;
    }

    HPROPSHEETPAGE hPage;

    if (ppsd &&
        ppsd->m_psh.nPages) {
        PROPSHEETHEADER& psh = ppsd->m_psh;

        for (UINT Index = 0; Index < psh.nPages; Index++) {
            lpProvider->AddPage(psh.phpage[Index]);
        }
        return S_OK;
    }

    //
    // If we didn't add any pages then we need to delete the new CMachine we
    // created.
    //
    if (pNewMachine) {

        delete pNewMachine;
    }

    //
    // No pages are added, return S_FALSE so that the responsible
    // Component can do its clean up
    //
    return S_FALSE;
}

// This function handles notification codes from the TV OCX.
//
//  INPUT:
//      hwndTV  -- the Window handle of the TV OCX.
//      pCookie -- the cookie
//      Code    -- notification code.
//      arg     -- argument to the given notification code.
//      param   -- another parameter to the given notificaton code.
//
//  OUTPUT:
//      HRESULT -- S_OK if this function has processed the notification
//                 and the caller should not do any further processing.
//                 S_FALSE if the caller should do more processing.
HRESULT
CResultView::tvNotify(
                     HWND hwndTV,
                     CCookie* pCookie,
                     TV_NOTIFY_CODE Code,
                     LPARAM arg,
                     LPARAM param
                     )
{
    HRESULT hr;

    if (m_hwndTV != hwndTV) {
        return S_FALSE;
    }

    //
    // Presume that we do not handle the notification
    //
    hr = S_FALSE;

    switch (Code) {
    case TV_NOTIFY_CODE_DBLCLK:
        if ((TVHT_ONITEM & param) &&
            (COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ == pCookie->GetType() ||
             COOKIE_TYPE_RESULTITEM_RESOURCE_DMA == pCookie->GetType() ||
             COOKIE_TYPE_RESULTITEM_RESOURCE_IO == pCookie->GetType() ||
             COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY == pCookie->GetType() ||
             COOKIE_TYPE_RESULTITEM_DEVICE == pCookie->GetType())) {
            if (SUCCEEDED(DoProperties(hwndTV, pCookie)))
                hr = S_OK;
        }
        break;

    case TV_NOTIFY_CODE_CONTEXTMENU:
        if (SUCCEEDED(DoContextMenu(hwndTV, pCookie, (POINT*)param)))
            hr = S_OK;
        break;

    case TV_NOTIFY_CODE_EXPANDED:
        if (TVE_EXPAND & param) {
            //TRACE1(TEXT("CResultView::tvNotify, TurnOnFlags(EXPANDED) Cookie = %lx\n"), pCookie);
            pCookie->TurnOnFlags(COOKIE_FLAGS_EXPANDED);
        } else if (TVE_COLLAPSE & param) {
            //TRACE1(TEXT("CResultView:tvNotify, TurnOffFlags(EXPANDED) Cookie = %lx\n"), pCookie);
            pCookie->TurnOffFlags(COOKIE_FLAGS_EXPANDED);
        }
        ASSERT(S_FALSE == hr);
        break;

    case TV_NOTIFY_CODE_FOCUSCHANGED:
        // gaining the focus, set the console verbs and toolbar buttons
        if (param) {
            //TRACE((TEXT("CResultView::tvNotify -> TV_NOTIFY_CODE_FOCUSCHANGED, SelCookie = %lx"), pCookie));
            UpdateConsoleVerbs(pCookie);
            m_pFolder->m_pComponent->UpdateToolbar(pCookie);
        }
        break;

    case TV_NOTIFY_CODE_SELCHANGED:
        if (m_SelectOk) {
            // These messages are ignored while the tree is being changed.
            m_pSelectedCookie = pCookie;

            //TRACE((TEXT("CResultView::tvNotify -> TV_NOTIFY_CODE_SELCHANGED, SelCookie = %lx"), pCookie));

            UpdateConsoleVerbs(pCookie);
            m_pFolder->m_pComponent->UpdateToolbar(pCookie);
        }

        break;

    case TV_NOTIFY_CODE_KEYDOWN:
        if (VK_RETURN == param) {
            if (COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ == pCookie->GetType() ||
                COOKIE_TYPE_RESULTITEM_RESOURCE_DMA == pCookie->GetType() ||
                COOKIE_TYPE_RESULTITEM_RESOURCE_IO == pCookie->GetType() ||
                COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY == pCookie->GetType() ||
                COOKIE_TYPE_RESULTITEM_DEVICE == pCookie->GetType() ||
                COOKIE_TYPE_RESULTITEM_CLASS == pCookie->GetType()) {
                if (SUCCEEDED(DoProperties(hwndTV, pCookie)))
                    hr = S_OK;
            }
        }

        else if (VK_DELETE == param &&
                 COOKIE_TYPE_RESULTITEM_DEVICE == pCookie->GetType()) {
            
            //
            // Remove the selected device
            //
            CDevice* pDevice = (CDevice*)pCookie->GetResultItem();
            RemoveDevice(pDevice);
        }
        break;

    case TV_NOTIFY_CODE_RCLICK:
    case TV_NOTIFY_CODE_CLICK:
        if (pCookie && pCookie->m_lParam) {
            m_pIDMTVOCX->SelectItem(TVGN_CARET, (HTREEITEM)pCookie->m_lParam);
        }

    case TV_NOTIFY_CODE_GETDISPINFO:
    default:
        ASSERT(S_FALSE == hr);
        break;
    }

    return hr;
}

//
// This function updates console verbs based on the selected cookie type.
//
HRESULT
CResultView::UpdateConsoleVerbs(
                               CCookie* pCookie
                               )
{
    BOOL bPropertiesEnabled = FALSE;
    BOOL bPrintEnabled = FALSE;

    if (!m_pFolder->m_bSelect) {

        switch (pCookie->GetType()) {
        
        case COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ:
        case COOKIE_TYPE_RESULTITEM_RESOURCE_DMA:
        case COOKIE_TYPE_RESULTITEM_RESOURCE_IO:
        case COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY:
        case COOKIE_TYPE_RESULTITEM_CLASS:
        case COOKIE_TYPE_RESULTITEM_DEVICE:
            bPropertiesEnabled = TRUE;
            bPrintEnabled = TRUE;
            break;
    
        case COOKIE_TYPE_RESULTITEM_COMPUTER:
            bPrintEnabled = TRUE;
            break;
    
        default:
            break;
        }
    }

    //
    // Only show the Print button/Action menu item when a something is selected.
    //
    if (bPrintEnabled) {

        m_pFolder->m_pComponent->m_pConsoleVerb->SetVerbState(MMC_VERB_PRINT, HIDDEN, FALSE);
        m_pFolder->m_pComponent->m_pConsoleVerb->SetVerbState(MMC_VERB_PRINT, ENABLED, TRUE);

    } else {

        m_pFolder->m_pComponent->m_pConsoleVerb->SetVerbState(MMC_VERB_PRINT, HIDDEN, TRUE);
    }

    //
    // Only show the properties button/Action menu item when a device/class is selected.
    //
    if (bPropertiesEnabled) {
        
        m_pFolder->m_pComponent->m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, FALSE);
        m_pFolder->m_pComponent->m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
        m_pFolder->m_pComponent->m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
    
    } else {

        m_pFolder->m_pComponent->m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);
        m_pFolder->m_pComponent->m_pConsoleVerb->SetDefaultVerb(MMC_VERB_NONE);
    }

    return S_OK;
}

HRESULT
CResultView::OnOcxNotify(
                        MMC_NOTIFY_TYPE event,
                        LPARAM arg,
                        LPARAM param
                        )
{
    HRESULT hr = S_OK;
    TV_ITEM TI;

    switch (event) {
    case MMCN_BTN_CLICK:
        if ((MMC_CONSOLE_VERB)param == MMC_VERB_PROPERTIES) {
            ASSERT(m_pIDMTVOCX);
            TI.hItem = m_pIDMTVOCX->GetSelectedItem();

            if (TI.hItem) {
                TI.mask = TVIF_PARAM;
                hr =  m_pIDMTVOCX->GetItem(&TI);

                if (SUCCEEDED(hr)) {
                    hr = DoProperties(m_hwndTV,  (CCookie*)TI.lParam);
                }
            }
        }
        break;

    case MMCN_PRINT:
        hr = DoPrint();
        break;

    case MMCN_SELECT:
        ASSERT(m_pIDMTVOCX);
        TI.hItem = m_pIDMTVOCX->GetSelectedItem();

        if (TI.hItem) {
            TI.mask = TVIF_PARAM;
            hr = m_pIDMTVOCX->GetItem(&TI);

            if (SUCCEEDED(hr)) {
                hr = UpdateConsoleVerbs((CCookie*)TI.lParam);    
            }
        }
        break;

    default:
        break;
    }

    return hr;
}

// This function creates the propperty sheet for the given cookie.
// INPUT:
//      hwndTV  -- the window handle to the TV OCX, used as the parent
//                 window of the property sheet.
//      pCookie -- the cookie.
// OUTPUT:
//      HRESULT S_OK if the function succeeded.
//              S_FALSE if no property sheet will be created.
//              S_XXXX other error.
HRESULT
CResultView::DoProperties(
                         HWND hwndTV,
                         CCookie* pCookie
                         )
{
    HRESULT hr;

    //
    // If a property sheet is aleady up for the node, bring the
    // property sheet to the foreground.
    //
    HWND hWnd = NULL;

    if (COOKIE_TYPE_RESULTITEM_DEVICE == pCookie->GetType()) {
        CDevice* pDevice = (CDevice*)pCookie->GetResultItem();
        ASSERT(pDevice);
        hWnd = pDevice->m_pMachine->GetDeviceWindowHandle(pDevice->GetDeviceID());
    }

    else if (COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ == pCookie->GetType() ||
             COOKIE_TYPE_RESULTITEM_RESOURCE_DMA == pCookie->GetType() ||
             COOKIE_TYPE_RESULTITEM_RESOURCE_IO == pCookie->GetType() ||
             COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY == pCookie->GetType()) {
        //
        // This is a resource item, get the pointer for the device
        // object from the resource object.
        //
        CResource* pResource = (CResource*) pCookie->GetResultItem();
        ASSERT(pResource);
        CDevice* pDevice = pResource->GetDevice();
        ASSERT(pDevice);
        hWnd = pDevice->m_pMachine->GetDeviceWindowHandle(pDevice->GetDeviceID());
    }

    else if (COOKIE_TYPE_RESULTITEM_CLASS == pCookie->GetType()) {
        CClass* pClass = (CClass*)pCookie->GetResultItem();
        ASSERT(pClass);
        hWnd = pClass->m_pMachine->GetClassWindowHandle(*pClass);
    }

    if (hWnd) {
        //
        // Notify the property sheet that it should go to foreground
        // Do not call SetForegroundWindow here because the subclassed
        // treeview control will grab the focus right after
        // we have brought the property sheet to foreground.
        //
        ::PostMessage(hWnd, PSM_QUERYSIBLINGS, QSC_TO_FOREGROUND, 0L);
        return S_OK;
    }

    //
    // No property sheet is up for this cookie, create a brand new property
    // sheet for it.
    //
    SafeInterfacePtr<IComponent> pComponent;
    SafeInterfacePtr<IPropertySheetProvider> pSheetProvider;
    SafeInterfacePtr<IDataObject> pDataObject;
    SafeInterfacePtr<IExtendPropertySheet> pExtendSheet;
    pComponent.Attach((IComponent*) m_pFolder->m_pComponent);

    if (FAILED(pComponent->QueryInterface(IID_IExtendPropertySheet, (void**) &pExtendSheet)) ||
        FAILED(pComponent->QueryDataObject((MMC_COOKIE)pCookie, CCT_RESULT, &pDataObject)) ||
        FAILED(m_pFolder->m_pComponent->m_pConsole->QueryInterface(IID_IPropertySheetProvider,
                                                                   (void**) &pSheetProvider)) ||
        S_OK == pSheetProvider->FindPropertySheet((MMC_COOKIE)pCookie, pComponent, pDataObject) ||
        S_OK != pExtendSheet->QueryPagesFor(pDataObject)) {
        return S_FALSE;
    }

    hr = pSheetProvider->CreatePropertySheet(
                                            pCookie->GetResultItem()->GetDisplayName(),
                                            TRUE, // not wizard
                                            (MMC_COOKIE)pCookie, pDataObject,
                                            MMC_PSO_NOAPPLYNOW  // do not want the apply button
                                            );
    if (SUCCEEDED(hr)) {
        HWND hNotifyWindow;

        if (!SUCCEEDED(m_pFolder->m_pComponent->m_pConsole->GetMainWindow(&hNotifyWindow)))
            hNotifyWindow = NULL;

        hNotifyWindow = FindWindowEx(hNotifyWindow, NULL, TEXT("MDIClient"), NULL);
        hNotifyWindow = FindWindowEx(hNotifyWindow, NULL, TEXT("MMCChildFrm"), NULL);
        hNotifyWindow = FindWindowEx(hNotifyWindow, NULL, TEXT("MMCView"), NULL);
        hr = pSheetProvider->AddPrimaryPages(pComponent, TRUE, hNotifyWindow, FALSE);

        if (SUCCEEDED(hr)) {
            pSheetProvider->AddExtensionPages();
            hr = pSheetProvider->Show((LONG_PTR)hwndTV, 0);
        } else {
            //
            // Failed to add primary Component's property page, destroy
            // the property sheet
            //
            pSheetProvider->Show(-1, 0);
        }
    }

    return hr;
}

// This function creates a context menu for the given cookie
// INPUT:
//      hwndTV  -- the TV OCX window, as the window the context menu to be
//                 attached to.
//      pCookie -- the cookie
//      pPoint  -- the location where the context menu should anchor in
//                 screen coordinate.
HRESULT
CResultView::DoContextMenu(
                          HWND hwndTV,
                          CCookie* pCookie,
                          POINT* pPoint
                          )
{
    HRESULT hr = S_FALSE;
    CMachine *pMachine = NULL;

    //
    // ISSUE: JasonC 8/14/99
    //
    // If we have a valid cookie then we need to get the CMachine for the given
    // cookie if there is one.  Then we need to disable refreshing while the
    // context menu is being displayed.  The reason for this is that if we
    // refresh while the menu is displayed but before the user chooses an option
    // then the cookie is no longer valid.  The real problem here is that we rebuild
    // all of the classes on a refresh which makes any cookie floating around invalid.
    // I am sure that there is more of these bugs lurking around in the code and this
    // needs to be addressed by a better overall change after NT 5.0.
    //
    if (pCookie) {
        CDevice *pDevice;
        CResource *pResource;
        CClass *pClass;

        switch (pCookie->GetType()) {
        
        case COOKIE_TYPE_RESULTITEM_DEVICE:
            pDevice = (CDevice*)pCookie->GetResultItem();
            if (pDevice) {
                pMachine = pDevice->m_pMachine;
            }
            break;

        case COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ:
        case COOKIE_TYPE_RESULTITEM_RESOURCE_DMA:
        case COOKIE_TYPE_RESULTITEM_RESOURCE_IO:
        case COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY:
            pResource = (CResource*)pCookie->GetResultItem();
            if (pResource) {
                pDevice = pResource->GetDevice();

                if (pDevice) {
                    pMachine = pDevice->m_pMachine;
                }
            }
            break;

        case COOKIE_TYPE_RESULTITEM_CLASS:
            pClass = (CClass*)pCookie->GetResultItem();
            if (pClass) {
                pMachine = pClass->m_pMachine;
            }
            break;

        default:
            pMachine = NULL;
        }
    }

    //
    // Disable Refreshing while the context menu is up.
    //
    if (pMachine) {
        pMachine->EnableRefresh(FALSE);
    }

    SafeInterfacePtr<IDataObject> pDataObject;
    SafeInterfacePtr<IContextMenuProvider> pMenuProvider;
    SafeInterfacePtr<IComponent> pComponent;
    pComponent.Attach((IComponent*)m_pFolder->m_pComponent);
    m_hwndTV = hwndTV;

    if (FAILED(pComponent->QueryDataObject((MMC_COOKIE)pCookie, CCT_RESULT, &pDataObject)) ||
        FAILED(m_pFolder->m_pComponent->m_pConsole->QueryInterface(IID_IContextMenuProvider,
                                                                   (void**)&pMenuProvider))) {
        hr = S_FALSE;
        goto clean0;
    }

    pMenuProvider->EmptyMenuList();
    CONTEXTMENUITEM MenuItem;
    MenuItem.strName = NULL;
    MenuItem.strStatusBarText = NULL;
    MenuItem.lCommandID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
    MenuItem.lInsertionPointID = 0;
    MenuItem.fFlags = 0;
    MenuItem.fSpecialFlags = CCM_SPECIAL_INSERTION_POINT;

    if (SUCCEEDED(pMenuProvider->AddItem(&MenuItem)) &&
        SUCCEEDED(pMenuProvider->AddPrimaryExtensionItems(pComponent,
                                                          pDataObject)) &&
        SUCCEEDED(pMenuProvider->AddThirdPartyExtensionItems(pDataObject))) {
        long Selected;
        pMenuProvider->ShowContextMenu(hwndTV, pPoint->x, pPoint->y, &Selected);
        hr = S_OK;
        goto clean0;
    }

    clean0:

    //
    // Enable Refreshing again now that the context menu is gone
    //
    if (pMachine) {
        pMachine->EnableRefresh(TRUE);
    }

    return hr;
}

HRESULT
CResultView::DoPrint()
{
    DWORD ReportTypeEnableMask;
    ReportTypeEnableMask = REPORT_TYPE_MASK_ALL;
    HTREEITEM hSelectedItem;
    CCookie* pCookie = NULL;

    m_pMachine->EnableRefresh(FALSE);

    if (m_pIDMTVOCX) {

        hSelectedItem = m_pIDMTVOCX->GetSelectedItem();

        if (hSelectedItem) {

            TV_ITEM TI;
            TI.hItem = hSelectedItem;
            TI.mask = TVIF_PARAM;

            if (SUCCEEDED(m_pIDMTVOCX->GetItem(&TI))) {

                pCookie = (CCookie*)TI.lParam;
            }
        }
    }

    if (!pCookie || (COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ != pCookie->GetType() &&
                     COOKIE_TYPE_RESULTITEM_RESOURCE_DMA != pCookie->GetType() &&
                     COOKIE_TYPE_RESULTITEM_RESOURCE_IO != pCookie->GetType() &&
                     COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY != pCookie->GetType() &&
                     COOKIE_TYPE_RESULTITEM_DEVICE != pCookie->GetType() &&
                     COOKIE_TYPE_RESULTITEM_CLASS != pCookie->GetType())) {

        ReportTypeEnableMask &= ~(REPORT_TYPE_MASK_CLASSDEVICE);
    }

    if (!g_PrintDlg.PrintDlg(m_pMachine->OwnerWindow(), ReportTypeEnableMask)) {

        m_pMachine->EnableRefresh(TRUE);
        return S_OK;
    }

    if (!g_PrintDlg.HDC()) {

        m_pMachine->EnableRefresh(TRUE);
        return E_OUTOFMEMORY;
    }

    //
    // Create the printer
    //
    CPrinter  ThePrinter(m_pMachine->OwnerWindow(), g_PrintDlg.HDC());
    TCHAR DocTitle[MAX_PATH];
    LoadString(g_hInstance, IDS_PRINT_DOC_TITLE, DocTitle, ARRAYLEN(DocTitle));
    int PrintStatus;

    switch (g_PrintDlg.ReportType()) {
    case REPORT_TYPE_SUMMARY:
        PrintStatus = ThePrinter.StartDoc(DocTitle);

        if (PrintStatus) {
            
            ThePrinter.SetPageTitle(IDS_PRINT_SUMMARY_PAGE_TITLE);
            PrintStatus = ThePrinter.PrintResourceSummary(*m_pMachine);
        }
        break;

    case REPORT_TYPE_CLASSDEVICE:
        ASSERT(pCookie);
        PrintStatus = ThePrinter.StartDoc(DocTitle);

        if (PrintStatus) {

            ThePrinter.SetPageTitle(IDS_PRINT_CLASSDEVICE_PAGE_TITLE);

            if (COOKIE_TYPE_RESULTITEM_CLASS == pCookie->GetType()) {
                
                PrintStatus = ThePrinter.PrintClass((CClass*)pCookie->GetResultItem());

            } else {
                
                CDevice* pDevice;

                if (COOKIE_TYPE_RESULTITEM_DEVICE == pCookie->GetType()) {
                    
                    pDevice = (CDevice*) pCookie->GetResultItem();
                
                } else {
                    
                    //
                    // This is a resource item, get the pointer for the
                    // device object from the resource object.
                    //
                    CResource* pResource = (CResource*) pCookie->GetResultItem();
                    ASSERT(pResource);
                    pDevice = pResource->GetDevice();
                }

                ASSERT(pDevice);
                PrintStatus = ThePrinter.PrintDevice(pDevice);
            }
        }
        break;

    case REPORT_TYPE_SUMMARY_CLASSDEVICE:
        PrintStatus = ThePrinter.StartDoc(DocTitle);

        if (PrintStatus) {
            
            ThePrinter.SetPageTitle(IDS_PRINT_SUMMARY_CLASSDEVICE_PAGE_TITLE);
            PrintStatus = ThePrinter.PrintAll(*m_pMachine);
        }
        break;

    default:
        ASSERT(FALSE);
        break;
    }

    //
    // Flush the last page
    //
    ThePrinter.FlushPage();

    if (PrintStatus) {

        ThePrinter.EndDoc();
    
    } else {

        ThePrinter.AbortDoc();
    }

    m_pMachine->EnableRefresh(TRUE);

    return S_OK;
}

HRESULT
CResultView::RemoveDevice(
                         CDevice* pDevice
                         )
{
    //
    // Must be an admin and on the local machine to remove a device.
    //
    if (!m_pMachine->IsLocal() || !g_HasLoadDriverNamePrivilege) {
        //
        // Must be an admin and on the local machine to remove a device.
        //
        return S_FALSE;
    }

    //
    // Make sure the device can be uninstalled
    //
    if (!pDevice->IsUninstallable()) {

        return S_FALSE;
    }

    //
    // Make sure there is no property sheet up for this device.
    // If it does exist, show a message box for the user and bring up
    // the property sheet to the foreground if the user
    // agree to do so.
    //
    HWND hwndPropSheet;
    hwndPropSheet = pDevice->m_psd.GetWindowHandle();
    int MsgBoxResult;
    TCHAR szText[MAX_PATH];

    if (hwndPropSheet) {
        LoadResourceString(IDS_PROPSHEET_WARNING, szText, ARRAYLEN(szText));
        MsgBoxResult = m_pFolder->m_pComponent->MessageBox(szText,
                                                           pDevice->GetDisplayName(),
                                                           MB_ICONEXCLAMATION | MB_OKCANCEL);

        if (IDOK == MsgBoxResult) {
            SetForegroundWindow(hwndPropSheet);
        }

        //
        // Can not wait for the property sheet because it is running
        // in a separate thread.
        //
        return S_OK;
    }

    BOOL Refresh = (pDevice->IsPhantom() || 
                    pDevice->HasProblem() || 
                    !pDevice->IsStarted());

    CRemoveDevDlg TheDlg(pDevice);

    //
    // Before removing device, disable refresh. This effectively disables
    // device change notification processing. While we are in the middle
    // of removing device, it is not a good idea to process any
    // device change notification. When the removal is done,
    // we will re-enable the refresh.
    //
    m_pMachine->EnableRefresh(FALSE);

    if (IDOK == TheDlg.DoModal(m_hwndTV, (LPARAM) &TheDlg)) {
        DWORD DiFlags;
        DiFlags = m_pMachine->DiGetFlags(*pDevice);

        //
        // We don't check to see if we are running locally at this
        // point because we won't let the user remove the device in
        // the first place if we are not running locally.
        //
        if (PromptForRestart(NULL, DiFlags, IDS_REMOVEDEV_RESTART) == IDNO) {

            Refresh = TRUE;
        }

        //
        // Enable refresh since we disabled it in the beginning.
        //
        // We only need to force a refresh here if the device that
        // was removed was a Phantom device or a device that is not
        // started.  This is because Phantom devices don't have kernel
        // devnodes and so they won't generate a WM_DEVICECHANGE like 
        // live started devnodes will.
        //
        if (Refresh) {

            m_pMachine->ScheduleRefresh();
        }

        m_pMachine->EnableRefresh(TRUE);
    }

    else {
        m_pMachine->EnableRefresh(TRUE);
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////
//// CViewDeviceTree implementations
////

HRESULT
CViewDeviceTree::OnShow(
                       BOOL fShow
                       )
{
    if (!fShow) {
        return S_OK;
    }

    if (!m_pCookieComputer) {
        CreateDeviceTree();
    }

    return CResultView::OnShow(fShow);
}

// This function creates a the root device for the device tree.
// INPUT:
//      NONE.
// OUTPUT:
//      TRUE if the device is created(Rooted at m_pCookieComputer).
//      FALSE if the device is not created.
BOOL
CViewDeviceTree::CreateDeviceTree()
{
    ASSERT(NULL == m_pCookieComputer);
    m_pMachine = m_pFolder->m_pMachine;

    //
    // We shouldn't be here if there is not a machine created.
    //
    ASSERT(m_pMachine);

    CComputer* pComputer = m_pMachine->m_pComputer;

    //
    // Make sure there is at least a computer
    //
    if (pComputer) {
        m_pCookieComputer = new CCookie(COOKIE_TYPE_RESULTITEM_COMPUTER);

        if (m_pCookieComputer) {

            m_pCookieComputer->SetResultItem(pComputer);
            m_pCookieComputer->SetScopeItem(m_pFolder->m_pScopeItem);

            //
            // Make sure that the computer is expanded and selected.
            //
            m_pCookieComputer->TurnOnFlags(COOKIE_FLAGS_EXPANDED);

            //
            // If there was no selection, choose the computer
            //
            if (!m_pSelectedItem || (*m_pSelectedItem == *m_pCookieComputer)) {
                m_pSelectedCookie = m_pCookieComputer;
            }

            return TRUE;
        }
    }

    return FALSE;
}

/////////////////////////////////////////////////////////////////////
//// CViewTreeByType implementations
////

// This function creates a "view-by-type: device tree rooted at
// m_pCookieComputer.
//
// INPUT:
//      NONE.
// OUTPUT:
//      TRUE if the tree is created successfully.
//      FALSE if tree is not created.
BOOL
CViewTreeByType::CreateDeviceTree()
{
    if (!CViewDeviceTree::CreateDeviceTree()) {
        return FALSE;
    }

    ASSERT(m_pCookieComputer);
    CClass* pClass;
    CDevice* pDevice;
    CDevice* pDeviceLast;
    CCookie* pCookieClass;
    CCookie* pCookieClassParent;
    CCookie* pCookieClassSibling;
    CCookie* pCookieDevice;
    CCookie* pCookieDeviceParent;
    CCookie* pCookieDeviceSibling;

    //
    // Do not have sibling at this moment;
    //
    pCookieClassSibling = NULL;

    //
    // All classes are children of computer
    //
    pCookieClassParent = m_pCookieComputer;

    pCookieDeviceParent;
    pCookieDeviceSibling;
    String strStartupDeviceId;
    strStartupDeviceId = GetStartupDeviceId();
    PVOID ContextClass, ContextDevice;

    if (m_pMachine->GetFirstClass(&pClass, ContextClass)) {
        do {
            //
            // We do not display a class if it does not have any
            // devices in it.
            //
            if (pClass->GetNumberOfDevices(TRUE)) {
                pCookieClass = new CCookie(COOKIE_TYPE_RESULTITEM_CLASS);
                pCookieClass->SetResultItem(pClass);
                pCookieClass->SetScopeItem(m_pFolder->m_pScopeItem);

                //
                // If the class was expanded before, mark it
                // so that DisplayTree will expand it
                //
                RestoreSavedTreeState(pCookieClass);

                //
                // No sibling: this is the first child
                //
                if (pCookieClassParent && !pCookieClassSibling) {
                    pCookieClassParent->SetChild(pCookieClass);
                }

                pCookieClass->SetParent(pCookieClassParent);

                if (pCookieClassSibling) {
                    pCookieClassSibling->SetSibling(pCookieClass);
                }

                pCookieClassSibling = pCookieClass;

                //
                // Classes are parent of devices
                //
                pCookieDeviceParent = pCookieClass;
                pCookieDeviceSibling = NULL;

                if (pClass->GetFirstDevice(&pDevice, ContextDevice)) {
                    do {
                        pCookieDevice = new CCookie(COOKIE_TYPE_RESULTITEM_DEVICE);
                        pCookieDevice->SetResultItem(pDevice);
                        pCookieDevice->SetScopeItem(m_pFolder->m_pScopeItem);

                        if (!strStartupDeviceId.IsEmpty() &&
                            !strStartupDeviceId.CompareNoCase(pDevice->GetDeviceID())) {
                            m_pSelectedCookie = pCookieDevice;
                        } else {
                            if (m_pSelectedItem && (*m_pSelectedItem == *pCookieDevice)) {
                                m_pSelectedCookie = pCookieDevice;
                            }
                        }

                        //
                        // No sibling: this is the first child
                        //
                        if (pCookieDeviceParent && !pCookieDeviceSibling) {
                            pCookieDeviceParent->SetChild(pCookieDevice);
                        }

                        pCookieDevice->SetParent(pCookieDeviceParent);

                        if (pCookieDeviceSibling) {
                            pCookieDeviceSibling->SetSibling(pCookieDevice);
                        }

                        pCookieDeviceSibling = pCookieDevice;

                    } while (pClass->GetNextDevice(&pDevice, ContextDevice));
                }
            }

        } while (m_pMachine->GetNextClass(&pClass, ContextClass));
    }

    DestroySavedTreeStates();

    return TRUE;
}

/////////////////////////////////////////////////////////////////////
//// CViewTreeByConnection implementations
////

BOOL
CViewTreeByConnection::CreateDeviceTree()
{
    if (!CViewDeviceTree::CreateDeviceTree()) {
        return FALSE;
    }

    ASSERT(m_pCookieComputer);
    CComputer* pComputer = (CComputer*)m_pCookieComputer->GetResultItem();
    CDevice* pDeviceStart = pComputer->GetChild();
    ASSERT(pDeviceStart);

    //
    // Collect all the normal devices.
    //
    CreateSubtree(m_pCookieComputer, NULL, pDeviceStart);

    //
    // Add phantom devices to m_pCookieComputer subtree.
    //
    PVOID Context;

    if (m_pMachine->GetFirstDevice(&pDeviceStart, Context)) {
        //
        // Locate the end of the CookieComputer Sibling list to add the
        // phantom devices to.
        //
        CCookie* pCookieSibling = NULL;
        CCookie* pNext = m_pCookieComputer->GetChild();

        while (pNext != NULL) {
            pCookieSibling = pNext;
            pNext = pCookieSibling->GetSibling();
        }

        do {
            if (pDeviceStart->IsPhantom()) {
                CCookie* pCookie;
                pCookie = new CCookie(COOKIE_TYPE_RESULTITEM_DEVICE);
                pCookie->SetResultItem(pDeviceStart);
                pCookie->SetScopeItem(m_pFolder->m_pScopeItem);

                if (pCookieSibling) {
                    pCookieSibling->SetSibling(pCookie);
                } else {
                    m_pCookieComputer->SetChild(pCookie);
                }

                pCookie->SetParent(m_pCookieComputer);
                pCookieSibling = pCookie;

                //
                // See if we have to expand the node
                //
                RestoreSavedTreeState(pCookie);
            }

        } while (m_pMachine->GetNextDevice(&pDeviceStart, Context));
    }

    DestroySavedTreeStates();

    return TRUE;
}

//
//This function creates a cookie subtree by walking down the
//a device subtree led by the given pDeviceStart
//INPUT:
//  pCookieParent -- the parent of the newly created subtree
//  pCookieSibling -- the sibling of the newly create subtree
//  pDeviceStart   -- the device to start with
//
//OUTPUT:
//  TRUE if the subtree is created and inserted successfully.
//
// This function may throw CMemoryException
//
BOOL
CViewTreeByConnection::CreateSubtree(
                                    CCookie* pCookieParent,
                                    CCookie* pCookieSibling,
                                    CDevice* pDeviceStart
                                    )
{
    CCookie* pCookie;
    CDevice* pDeviceChild;
    String strStartupDeviceId;
    CClass*  pClass;
    strStartupDeviceId = GetStartupDeviceId();

    while (pDeviceStart) {
        pClass = pDeviceStart->GetClass();

        pCookie = new CCookie(COOKIE_TYPE_RESULTITEM_DEVICE);

        if (pCookie) {
            pCookie->SetResultItem(pDeviceStart);
            pCookie->SetScopeItem(m_pFolder->m_pScopeItem);

            if (!strStartupDeviceId.IsEmpty() &&
                !strStartupDeviceId.CompareNoCase(pDeviceStart->GetDeviceID())) {
                m_pSelectedCookie = pCookie;
            }

            //
            // No sibling: this is the first child
            //
            if (pCookieParent && !pCookieSibling) {
                pCookieParent->SetChild(pCookie);
            }

            pCookie->SetParent(pCookieParent);

            if (pCookieSibling) {
                pCookieSibling->SetSibling(pCookie);
            }

            //
            // See if we have to expand the node
            //
            RestoreSavedTreeState(pCookie);

            pDeviceChild = pDeviceStart->GetChild();

            if (pDeviceChild) {
                CreateSubtree(pCookie, NULL, pDeviceChild);
            }

            pCookieSibling = pCookie;

        }

        pDeviceStart = pDeviceStart->GetSibling();
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////
//// CViewResourceTree implementations
////

CViewResourceTree::~CViewResourceTree()
{
    int i;

    //
    // Destroy all the CResource objects
    //
    for (i = 0; i < TOTAL_RESOURCE_TYPES; i++) {
        if (m_pResourceList[i]) {
            delete m_pResourceList[i];
            m_pResourceList[i] = NULL;
        }

        if (m_pResourceType[i]) {
            delete m_pResourceType[i];
            m_pResourceType[i] = NULL;
        }
    }
}

//
// This functions handle MMC standard MMCN_SHOW command
//
// This function may throw CMemoryException
//
HRESULT
CViewResourceTree::OnShow(
                         BOOL fShow
                         )
{
    if (!fShow) {
        return S_OK;
    }

    if (!m_pCookieComputer) {
        CreateResourceTree();
    }

    return CResultView::OnShow(fShow);
}

//
// This function creates resource lists and cookie trees.
// The resources are recorded in the member m_pResourceList[]
// and the cookie tree is rooted at m_pCookieComputer[];
//
// This function may throw CMemoryException
//
void
CViewResourceTree::CreateResourceTree()
{
    int i;
    CCookie* pCookieTypeSibling = NULL;

    ASSERT(!m_pCookieComputer);
    m_pMachine = m_pFolder->m_pMachine;
    ASSERT(m_pMachine);

    m_pCookieComputer = new CCookie(COOKIE_TYPE_RESULTITEM_COMPUTER);

    if (!m_pCookieComputer) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return;
    }

    m_pCookieComputer->SetResultItem(m_pMachine->m_pComputer);
    m_pCookieComputer->SetScopeItem(m_pFolder->m_pScopeItem);
    m_pCookieComputer->TurnOnFlags(COOKIE_FLAGS_EXPANDED);

    //
    // If no selected item recorded, default to the computer node
    //
    if (!m_pSelectedItem || (*m_pSelectedItem == *m_pCookieComputer)) {
        m_pSelectedCookie = m_pCookieComputer;
    }

    //
    // Check each resource type (mem, io, dma, irq) and create a result item
    // if resources exist for the resource type.
    //
    for (i = 0; i < TOTAL_RESOURCE_TYPES; i++) {
        RESOURCEID ResType = ResourceTypes[i];

        //
        // If there is an existing m_pResourceList then delete it.
        //
        if (m_pResourceList[i]) {
            delete m_pResourceList[i];    
        }

        m_pResourceList[i] = new CResourceList(m_pMachine, ResType);

        PVOID Context;
        CResource* pRes;

        if (m_pResourceList[i] && 
            m_pResourceList[i]->GetFirst(&pRes, Context)) {
            //
            // Resource items exist, create the resource type result item.
            //
            CCookie* pCookieFirst = NULL;

            //
            // If there is an existing m_pResourceType then delete it.
            //
            if (m_pResourceType[i]) {
                delete m_pResourceType[i];
            }

            m_pResourceType[i] = new CResourceType(m_pMachine, ResType);

            CCookie* pCookieType = new CCookie(COOKIE_TYPE_RESULTITEM_RESTYPE);

            if (pCookieType) {
                pCookieType->SetResultItem(m_pResourceType[i]);
                pCookieType->SetScopeItem(m_pFolder->m_pScopeItem);
                pCookieType->SetParent(m_pCookieComputer);

                if (pCookieTypeSibling) {
                    pCookieTypeSibling->SetSibling(pCookieType);
                } else {
                    m_pCookieComputer->SetChild(pCookieType);
                }
                pCookieTypeSibling = pCookieType;

                RestoreSavedTreeState(pCookieType);

                //
                // Create the resource result item for each resource.
                //
                while (pRes) {
                    CCookie* pCookie = new CCookie(CookieType(ResType));
                    pCookie->SetResultItem(pRes);
                    pCookie->SetScopeItem(m_pFolder->m_pScopeItem);

                    if (pCookieFirst) {
                        InsertCookieToTree(pCookie, pCookieFirst, TRUE);
                    } else {
                        pCookieFirst = pCookie;
                        pCookieType->SetChild(pCookie);
                        pCookie->SetParent(pCookieType);
                    }
                    RestoreSavedTreeState(pCookie);

                    //
                    // Get the next resource item.
                    //
                    m_pResourceList[i]->GetNext(&pRes, Context);
                }
            }
        }
    }

    //
    // The saved tree states have been merged into the newly
    // create cookie tree. destroy the states
    //
    DestroySavedTreeStates();
}

//
// This function insert the given cookie into a existing cookie subtree
// rooted at pCookieRoot.  If the resource is I/O or MEMORY then the cookie is
// inserted as a child of any resource it is enclosed by.
//
//INPUT:
//     pCookie -- the cookie to be inserted.
//     pCookieRoot -- the subtree root cookie
//     ForcedInsert -- TRUE to insert the cookie as the sibling of
//                     of pCookieRoot.
//OUTPUT:
//  None
BOOL
CViewResourceTree::InsertCookieToTree(
                                     CCookie* pCookie,
                                     CCookie* pCookieRoot,
                                     BOOL     ForcedInsert
                                     )
{
    CResource* pResRef;
    CResource* pResThis = (CResource*)pCookie->GetResultItem();
    CCookie* pCookieLast;
    BOOL Result = FALSE;

    while (pCookieRoot) {
        //
        // Only check for enclosed resources for I/O and MEMORY.
        //
        if (COOKIE_TYPE_RESULTITEM_RESOURCE_IO == pCookie->GetType() ||
            COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY == pCookie->GetType()) {
            pResRef = (CResource*)pCookieRoot->GetResultItem();

            if (pResThis->EnclosedBy(*pResRef)) {
                //
                // This cookie is either the pCookieRoot child or grand child
                // figure out which one it is
                //
                if (!pCookieRoot->GetChild()) {
                    pCookieRoot->SetChild(pCookie);
                    pCookie->SetParent(pCookieRoot);
                } else if (!InsertCookieToTree(pCookie, pCookieRoot->GetChild(), FALSE)) {
                    //
                    // The cookie is not a grand child of pCookieRoot.
                    // search for the last child of pCookieRoot
                    //
                    CCookie* pCookieSibling;
                    pCookieSibling = pCookieRoot->GetChild();

                    while (pCookieSibling->GetSibling()) {
                        pCookieSibling = pCookieSibling->GetSibling();
                    }

                    pCookieSibling->SetSibling(pCookie);
                    pCookie->SetParent(pCookieRoot);
                }

                return TRUE;
            }
        }

        pCookieLast = pCookieRoot;
        pCookieRoot = pCookieRoot->GetSibling();
    }

    if (ForcedInsert) {
        //
        // When we reach here, pCookieLast is the last child
        //
        pCookieLast->SetSibling(pCookie);
        pCookie->SetParent(pCookieLast->GetParent());
        return TRUE;
    }

    return FALSE;
}

/////////////////////////////////////////////////////////////////////
//// CBusPropPageProvider implementations
////

//
// This function loads the bus property sheet pages provider
// to enumerate pages for the device
// INPUT:
//      pDevice -- object represents the device
//      ppsd    -- object represents where property pages should be added
// OUTPUT:
//      TRUE if succeeded.
//      FLASE if no pages are added.
BOOL
CBusPropPageProvider::EnumPages(
                               CDevice* pDevice,
                               CPropSheetData* ppsd
                               )
{
    ASSERT(!m_hDll);

    //
    // Enum bus property pages if there are any
    // if the a bus guid can not be found on the device, no bus property pages
    //
    String strBusGuid;

    if (pDevice->m_pMachine->CmGetBusGuidString(pDevice->GetDevNode(), strBusGuid)) {
        CSafeRegistry regDevMgr;
        CSafeRegistry regBusTypes;
        CSafeRegistry regBus;

        if (regDevMgr.Open(HKEY_LOCAL_MACHINE, REG_PATH_DEVICE_MANAGER) &&
            regBusTypes.Open(regDevMgr, REG_STR_BUS_TYPES) &&
            regBus.Open(regBusTypes, strBusGuid)) {
            String strEnumPropPage;

            if (regBus.GetValue(REGSTR_VAL_ENUMPROPPAGES_32, strEnumPropPage)) {
                PROPSHEET_PROVIDER_PROC PropPageProvider;

                if (LoadEnumPropPage32(strEnumPropPage, &m_hDll, (FARPROC*)&PropPageProvider)) {
                    SP_PROPSHEETPAGE_REQUEST PropPageRequest;
                    PropPageRequest.cbSize = sizeof(PropPageRequest);
                    PropPageRequest.DeviceInfoSet = (HDEVINFO)*(pDevice->m_pMachine);
                    PropPageRequest.DeviceInfoData = *pDevice;
                    PropPageRequest.PageRequested = SPPSR_ENUM_ADV_DEVICE_PROPERTIES;

                    if (PropPageProvider(&PropPageRequest,
                                         (LPFNADDPROPSHEETPAGE)AddPropPageCallback,
                                         (LPARAM)ppsd
                                        ))
                        return TRUE;
                }
            }
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\cdriver.h ===
#ifndef _CDRIVER_H__
#define _CDRIVER_H__

/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    cdriver.h

Abstract:

    header file for cdriver.cpp. Defined CDriverFile, CDriver and CService

Author:

    William Hsieh (williamh) created

Revision History:


--*/
class CDriverFile
{
public:
    CDriverFile() : m_Win32Error(ERROR_FILE_NOT_FOUND), m_Attributes(0xFFFFFFFF),
        m_IsDriverBlocked(FALSE)
    {};
    BOOL Create(LPCTSTR ServiceName, 
                BOOL LocalMachine, 
                DWORD Win32Error = ERROR_FILE_NOT_FOUND,
                LPCTSTR pszDigitalSigner = NULL,
                HSDB hSDBDrvMain = NULL);
    LPCTSTR GetProvider()
    {
        return m_strProvider.IsEmpty() ? NULL : (LPCTSTR)m_strProvider;
    }
    LPCTSTR GetCopyright(void)
    {
        return m_strCopyright.IsEmpty() ? NULL : (LPCTSTR)m_strCopyright;

    }
    LPCTSTR GetVersion(void)
    {
        return m_strVersion.IsEmpty() ? NULL : (LPCTSTR)m_strVersion;
    }
    LPCTSTR GetFullPathName(void)
    {
        return m_strFullPathName.IsEmpty() ? NULL : (LPCTSTR)m_strFullPathName;
    }
    BOOL HasVersionInfo()
    {
        return m_HasVersionInfo;
    }
    DWORD GetWin32Error()
    {
        return m_Win32Error;
    }
    DWORD GetAttributes()
    {
        return m_Attributes;
    }
    LPCTSTR GetDigitalSigner(void)
    {
        return m_strDigitalSigner.IsEmpty() ? NULL : (LPCTSTR)m_strDigitalSigner;
    }
    BOOL IsDriverBlocked()
    {
        return m_IsDriverBlocked;
    }
    LPCTSTR GetBlockedDriverHtmlHelpID(void)
    {
        return m_strHtmlHelpID.IsEmpty() ? NULL : (LPCTSTR)m_strHtmlHelpID;
    }
    BOOL operator ==(CDriverFile& OtherDrvFile);

private:
    BOOL    GetVersionInfo();
    String  m_strFullPathName;
    String  m_strProvider;
    String  m_strCopyright;
    String  m_strVersion;
    String  m_strDigitalSigner;
    String  m_strHtmlHelpID;
    BOOL    m_HasVersionInfo;
    BOOL    m_IsDriverBlocked;
    DWORD   m_Win32Error;
    DWORD   m_Attributes;
};

class CDriver
{
// do we have to keep HDEVINFO and SP_DEVINFO_DATA here?????
public:
    CDriver() : m_pDevice(NULL), m_OnLocalMachine(TRUE), m_DriverListBuilt(FALSE),
        m_hSDBDrvMain(NULL)
    {};
    ~CDriver();
    BOOL Create(SC_HANDLE hscManager, LPTSTR tszServiceName);
    BOOL Create(CDevice* pDevice, PSP_DRVINFO_DATA pDrvInfoData = NULL);
    BOOL GetFirstDriverFile(CDriverFile** ppDrvFile, PVOID& Context);
    BOOL GetNextDriverFile(CDriverFile** ppDrvFile, PVOID& Context);
    void AddDriverFile(CDriverFile* pDrvFile);
    BOOL IsLocal()
    {
        return m_OnLocalMachine;
    }
    int GetCount()
    {
        return m_listDriverFile.GetCount();
    }
    BOOL BuildDriverList(PSP_DRVINFO_DATA pDrvInfoData, BOOL bFunctionAndFiltersOnly = FALSE);
    void GetDriverSignerString(String& strDriverSigner);
    BOOL operator ==(CDriver& OtherDriver);

private:
    // call back must be a static function(because of the hidden this parameter
    static UINT ScanQueueCallback(PVOID Context, UINT Notification, UINT_PTR Param1, UINT_PTR Param2);
    void AddFunctionAndFilterDrivers(CDevice* pDevice, HSPFILEQ hFileQueue = INVALID_HANDLE_VALUE);
    void CreateFromService(CDevice* pDevice, PCTSTR ServiceName, HSPFILEQ hFileQueue = INVALID_HANDLE_VALUE);
    BOOL GetFullPathFromImagePath(LPCTSTR ImagePath, LPTSTR FullPath, UINT FullPathLength);
    CList<CDriverFile*,CDriverFile* > m_listDriverFile;
    CDevice* m_pDevice;
    BOOL m_OnLocalMachine;
    BOOL m_DriverListBuilt;
    String m_DigitalSigner;
    HSDB m_hSDBDrvMain;
};

#endif // _CDRIVER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\clsgenpg.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    clsgenpg.cpp

Abstract:

    This module implements CClassGeneralPage -- class general property page

Author:

    William Hsieh (williamh) created

Revision History:


--*/
// clsgenpg.cpp : implementation file
//

#include "devmgr.h"
#include "clsgenpg.h"

// help topic ids
const DWORD g_a108HelpIDs[]=
{
    IDC_CLSGEN_DESC, IDH_DISABLEHELP,
    IDC_CLSGEN_ICON, IDH_DISABLEHELP,
    IDC_CLSGEN_NAME, IDH_DISABLEHELP,
    0, 0,
};

BOOL
CClassGeneralPage::OnInitDialog(
    LPPROPSHEETPAGE ppsp
    )
{
    // notify CPropSheetData about the page creation
    // the controls will be initialize in UpdateControls virtual function.
    m_pClass->m_psd.PageCreateNotify(m_hDlg);
    return CPropSheetPage::OnInitDialog(ppsp);
}

UINT
CClassGeneralPage::DestroyCallback()
{
    // the property sheet is going away, consolidate the changes on the
    // device.
    // We do this because this is the page we are sure will be created --
    // this page is ALWAYS the first page.
    //

    // The DevInfoList returned from GetDevInfoList() function
    // is maintained by the class object during its lifetime.
    // we must NOT release the object.
    CDevInfoList* pClassDevInfo = m_pClass->GetDevInfoList();

    if (pClassDevInfo)
    {
        if (pClassDevInfo->DiGetExFlags(NULL) & DI_FLAGSEX_PROPCHANGE_PENDING)
        {
            //
            // property change pending, issue a DICS_PROPERTYCHANGE to the
            // class installer. A DICS_PROPCHANGE would basically remove the
            // device subtree and reenumerate it. If each property page issues
            // its own DICS_PROPCHANGE command, the device subtree would
            // be removed/reenumerate several times even though one is enough.
            // A property page sets DI_FLAGEX_PROPCHANGE_PENDING when it needs
            // a DICS_PROPCHANGE command to be issued.
            //
            SP_PROPCHANGE_PARAMS pcp;
            pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
            pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;

            pcp.Scope = DICS_FLAG_GLOBAL;
            pcp.StateChange = DICS_PROPCHANGE;
            pClassDevInfo->DiSetClassInstallParams(NULL,
                                                   &pcp.ClassInstallHeader,
                                                   sizeof(pcp)
                                                   );
                                                   
            pClassDevInfo->DiCallClassInstaller(DIF_PROPERTYCHANGE, NULL);
            pClassDevInfo->DiTurnOnDiFlags(NULL, DI_PROPERTIES_CHANGE);
            pClassDevInfo->DiTurnOffDiExFlags(NULL, DI_FLAGSEX_PROPCHANGE_PENDING);
        }
        
        DWORD RestartFlags = pClassDevInfo->DiGetFlags();

        //
        // Do not use our window handle(or its parent) as the parent
        // to the newly create dialog because they are in "detroyed state".
        // WM_CLOSE does not help either.
        // NULL window handle(Desktop) should be okay here.
        //
        // We only want to prompt for a reboot if device manager is connected
        // to the local machine.
        //
        if (RestartFlags && m_pClass->m_pMachine->IsLocal())
        {
            if (PromptForRestart(NULL, RestartFlags) == IDNO) {

                if (m_pClass->m_pMachine->m_ParentMachine) {

                    m_pClass->m_pMachine->m_ParentMachine->ScheduleRefresh();

                } else {
                    
                    m_pClass->m_pMachine->ScheduleRefresh();
                }
            }
        }

        // notify CPropSheetData that the property sheet is going away
        m_pClass->m_psd.PageDestroyNotify(m_hDlg);
        if (RestartFlags & DI_PROPERTIES_CHANGE)
        {
            // Class properties changed. We need to refresh the machine.
            // Since we are running in a separate thread, we can not
            // call the refresh function, instead, we schedule it.
            // This must be done before enabling refresh.
            //
            m_pClass->m_pMachine->ScheduleRefresh();
        }
    }

    //
    // Destory the CMachine.
    //
    CMachine* pMachine;
    pMachine = m_pClass->m_pMachine;

    if (pMachine->ShouldPropertySheetDestroy()) {
    
        delete pMachine;
    }

    return CPropSheetPage::DestroyCallback();
}

void
CClassGeneralPage::UpdateControls(
    LPARAM lParam
    )
{
    if (lParam)
        m_pClass = (CClass*)lParam;

    HICON hClassIcon = m_pClass->LoadIcon();
    if (hClassIcon)
    {
        HICON hIconOld;
        m_IDCicon = IDC_CLSGEN_ICON;    // Save for cleanup in OnDestroy.
        hIconOld = (HICON)SendDlgItemMessage(m_hDlg, IDC_CLSGEN_ICON, STM_SETICON,
                                               (WPARAM)hClassIcon,
                                               0
                                               );

        if (NULL != hIconOld)
            DestroyIcon(hIconOld);
    }
    
    SetDlgItemText(m_hDlg, IDC_CLSGEN_NAME, m_pClass->GetDisplayName());
}

HPROPSHEETPAGE
CClassGeneralPage::Create(
    CClass* pClass
    )
{
    m_pClass = pClass;
    m_psp.lParam = (LPARAM) this;
    
    return CreatePage();
}



BOOL
CClassGeneralPage::OnHelp(
    LPHELPINFO pHelpInfo
    )
{
    WinHelp((HWND)pHelpInfo->hItemHandle, DEVMGR_HELP_FILE_NAME, HELP_WM_HELP,
            (ULONG_PTR)g_a108HelpIDs);
            
    return FALSE;
}


BOOL
CClassGeneralPage::OnContextMenu(
    HWND hWnd,
    WORD xPos,
    WORD yPos
    )
{
    WinHelp(hWnd, DEVMGR_HELP_FILE_NAME, HELP_CONTEXTMENU,
            (ULONG_PTR)g_a108HelpIDs);
            
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\compdata.h ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    compdata.h

Abstract:

    header file defines CComponentData class

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#ifndef __COMPDATA_H_
#define __COMPDATA_H_

extern const WCHAR* const DM_COMPDATA_SIGNATURE;

class CComponent;

class CComponentData :
    public IComponentData,
    public IExtendPropertySheet,
    public IExtendContextMenu,
    public IPersistStream,
    public ISnapinHelp
{
public:
    CComponentData();
    ~CComponentData();

    //
    // IUNKNOWN interface
    //
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);

    //
    // IComponentData interface
    //
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
    STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)();
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM* pScopeDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

    //
    // IExtendPropertySheet
    //
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, LPDATAOBJECT lpDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

    //
    // IExtendContextMenu
    //
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK lpCallbackUnknown,
                long* pInsertionAllowed);
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

    //
    // IPersistStream
    //
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream* pStm);
    STDMETHOD(Save)(IStream* pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);
    STDMETHOD(GetClassID)(CLSID* pClassID);
    virtual const CLSID& GetCoClassID() = 0;
    virtual BOOL IsPrimarySnapin() = 0;

    //
    //ISnapinHelp
    //
    STDMETHOD(GetHelpTopic)(LPOLESTR* lpCompileHelpFile);

    //
    // Helper functions
    //
    CCookie*    GetActiveCookie(MMC_COOKIE cookie)
    {
        return (NULL == cookie) ? m_pCookieRoot : (CCookie*)cookie;
    }
    CScopeItem* FindScopeItem(MMC_COOKIE cookie);
    BOOL InitializeMachine()
    {
        ASSERT(m_pMachine);
        
        if (m_pMachine)
        {
            return m_pMachine->Initialize(m_hwndMain, NULL);
        }

        return FALSE;
    }
    String m_strMachineName;
    CMachine*   m_pMachine;
    COOKIE_TYPE m_ctRoot;
    String     m_strStartupDeviceId;
    String     m_strStartupCommand;
    void SetDirty()
    {
        m_IsDirty = TRUE;
    }
    LPCONSOLENAMESPACE  m_pScope;
    LPCONSOLE       m_pConsole;
    HWND            m_hwndMain;

private:
    //
    // Event notification functions
    //
    HRESULT OnDelete(MMC_COOKIE cookie, MMC_COOKIE arg, LPARAM param);
    HRESULT OnExpand(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);
    HRESULT OnRename(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnContextMenu(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnProperties(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnBtnClick(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT CreateScopeItems();
    HRESULT CreateCookieSubtree(CScopeItem* pScopeItem, CCookie* pCookieParent);
    HRESULT LoadScopeIconsForScopePane();
    HRESULT ResetScopeItem(CScopeItem* pScopeItem);
    HRESULT DoStartupProperties(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle,
                    LPDATAOBJECT pDataObject);


    BOOL            m_IsDirty;
    CCookie*        m_pCookieRoot;
    CScopeItem*     m_pScopeItemRoot;
    ULONG           m_Ref;
};

//
// Primary snapin
//
class CComponentDataPrimary : public CComponentData
{
public:
    virtual const CLSID& GetCoClassID()
    {
        return CLSID_DEVMGR;
    }
    virtual BOOL IsPrimarySnapin()
    {
        return TRUE;
    }
};

//
// Extension snapin
//
class CComponentDataExtension : public CComponentData
{
public:
    virtual const CLSID& GetCoClassID()
    {
        return CLSID_DEVMGR_EXTENSION;
    }
    virtual BOOL IsPrimarySnapin()
    {
        return FALSE;
    }
};

typedef struct tagCompDataPersistInfo
{
    DWORD       Size;
    WCHAR       Signature[16];
    COOKIE_TYPE RootCookie;
    WCHAR       ComputerFullName[MAX_PATH + 3];
} COMPDATA_PERSISTINFO, *PCOMPDATA_PERSISTINFO;

#endif      //__COMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\componet.h ===
#ifndef __COMPONET_H_
#define __COMPONET_H_

/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    componet.h

Abstract:

    header file defines CComponent class

Author:

    William Hsieh (williamh) created

Revision History:


--*/


class CComponent :
public IComponent,
public IResultDataCompare,
public IExtendContextMenu,
public IExtendControlbar,
public IExtendPropertySheet,
public IPersistStream,
public ISnapinCallback {
public:
    CComponent(CComponentData* pComponentData);
    ~CComponent();

    //
    // IUNKNOWN
    //
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);

public:
    //
    // IComponent interface members
    //
    STDMETHOD(Initialize)(LPCONSOLE pConsole);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, MMC_COOKIE param);
    STDMETHOD(Destroy)(MMC_COOKIE cookie);
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie,  LPOLESTR* ppViewType, long* pViewOptions);
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                               LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM* pResultDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

    //
    // IResultDataCompare interface member
    //
    STDMETHOD(Compare)(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult);

    //
    // IExtendContextMenu
    //
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
                            LPCONTEXTMENUCALLBACK pCallbackUnknown,
                            long* pInsertionAllowed
                           );
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

    //
    // IExtendControlbar
    //
    STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar);
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);

    //
    // IExtendPropertySheet
    //
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, LPDATAOBJECT lpDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

    //
    // IPersistStream
    //
    STDMETHOD(GetClassID)(CLSID* pClassId);
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream* pStm);
    STDMETHOD(Save)(IStream* pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);

    //
    // ISnapinCallback
    //
    STDMETHOD(tvNotify)(HWND hwndTV, MMC_COOKIE cookie, TV_NOTIFY_CODE Code, LPARAM arg, LPARAM param);

protected:
    HRESULT OnShow(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnMinimize(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnResultItemClick(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnResultItemDblClick(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnProperties(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnViewChange(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnBtnClick(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnSelect(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnActivate(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnAddImages(MMC_COOKIE cookie, IImageList* pIImageList, HSCOPEITEM hScopeItem);
    HRESULT OnOcxNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    HRESULT OnRestoreView(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnContextHelp(MMC_COOKIE cookie, LPARAM arg, LPARAM param);

    //
    // Helper functions
    //
    HRESULT DoPropertySheet(MMC_COOKIE cookie);

public:
    void SetDirty()
    {
        m_Dirty = TRUE;
    }
    HRESULT UpdateToolbar(CCookie* pCookie);
    HRESULT CreateFolderList(CCookie* pCookie);
    CScopeItem* FindScopeItem(MMC_COOKIE cookie)
    {
        return m_pComponentData->FindScopeItem(cookie);
    }
    CCookie* GetActiveCookie(MMC_COOKIE cookie)
    {
        return m_pComponentData->GetActiveCookie(cookie);
    }
    CMachine* GetMachine()
    {
        return m_pComponentData->m_pMachine;
    }
    LPCTSTR GetStartupDeviceId()
    {
        return m_pComponentData->m_strStartupDeviceId;
    }
    LPCTSTR GetStartupCommand()
    {
        return m_pComponentData->m_strStartupCommand;
    }
    HRESULT LoadScopeIconsForResultPane(IImageList* pIImageList);

    int MessageBox(LPCTSTR Msg, LPCTSTR Caption, DWORD Flags);
    BOOL AttachFolderToMachine(CFolder* pFolder, CMachine** ppMachine);

    LPCONSOLE       m_pConsole;         // Console's Interface
    LPHEADERCTRL    m_pHeader;          // Result pane's header control interface

    LPRESULTDATA    m_pResult;          // Interface pointer to the result pane
    LPCONSOLEVERB   m_pConsoleVerb;     //
    LPPROPERTYSHEETPROVIDER m_pPropSheetProvider;
    LPDISPLAYHELP   m_pDisplayHelp;
    LPTOOLBAR       m_pToolbar;         // Toolbar for view
    LPCONTROLBAR    m_pControlbar;      // Control bar to hold toolbar

private:
    CFolder* FindFolder(MMC_COOKIE cookie);
    BOOL DestroyFolderList(MMC_COOKIE cookie);
    HRESULT SaveFolderPersistData(CFolder* pFolder, IStream* pStm, BOOL fClearDirty);
    HRESULT LoadFolderPersistData(CFolder* pFolder, IStream* pStm);
    void DetachAllFoldersFromMachine();
    CComponentData* m_pComponentData;
    CFolder*        m_pCurFolder;
    CList<CFolder*, CFolder*> m_listFolder;
    CList<String*, String*> m_listDescBarText;
    DWORD       m_DescBarTextSP;
    BOOL        m_Dirty;
    BOOL        m_MachineAttached;
    ULONG       m_Ref;
};

#endif  // __COMPONET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\componet.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    componet.cpp

Abstract:

    This module implemets CComponent class

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "devmgr.h"
#include "factory.h"
#include <devguid.h>

//
// ctor and dtor
//

CComponent::CComponent(
    CComponentData* pComponentData
    )
{
    m_pComponentData = pComponentData;
    m_pHeader = NULL;
    m_pConsole = NULL;
    m_pResult = NULL;
    m_pConsoleVerb = NULL;
    m_pCurFolder = NULL;
    m_pPropSheetProvider = NULL;
    m_pDisplayHelp = NULL;
    m_MachineAttached = FALSE;
    m_Dirty = FALSE;
    m_pControlbar = NULL;
    m_pToolbar = NULL;
    
    //
    // Increment object count(used by CanUnloadNow)
    //
    ::InterlockedIncrement(&CClassFactory::s_Objects);
    m_Ref = 1;
}

CComponent::~CComponent()
{
    //
    // Decrement object count(used by CanUnloadNow)
    //
    ::InterlockedDecrement(&CClassFactory::s_Objects);
}

//
// IUNKNOWN interface
//
ULONG
CComponent::AddRef()
{
    ::InterlockedIncrement((LONG*)&m_Ref);
    return m_Ref;
}

ULONG
CComponent::Release()
{
    ::InterlockedDecrement((LONG*)&m_Ref);
    
    if (!m_Ref)
    {
        delete this;
        return 0;
    }
    
    return m_Ref;
}

STDMETHODIMP
CComponent::QueryInterface(
    REFIID  riid,
    void**  ppv
    )
{
    if (!ppv)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown*)(IComponent*)this;
    }
    
    else if (IsEqualIID(riid, IID_IComponent))
    {
        *ppv = (IComponent*)this;
    }
    
    else if (IsEqualIID(riid, IID_IResultDataCompare))
    {
        *ppv = (IResultDataCompare*)this;
    }
    
    else if (IsEqualIID(riid, IID_IExtendContextMenu))
    {
        *ppv = (IExtendContextMenu*)this;
    }
    
    else if (IsEqualIID(riid, IID_IExtendControlbar))
    {
        *ppv = (IExtendControlbar*)this;
    }
    
    else if (IsEqualIID(riid, IID_IExtendPropertySheet))
    {
        *ppv = (IExtendPropertySheet*)this;
    }

    else if (IsEqualIID(riid, IID_IPersistStream))
    {
        *ppv = (IPersistStream*)this;
    }

    else if (IsEqualIID(riid, IID_ISnapinCallback))
    {
        *ppv = (ISnapinCallback*)this;
    }
    
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }
    
    if (SUCCEEDED(hr))
    {
        AddRef();
    }
    
    return hr;
}


//
// IComponent interface implementation
//
STDMETHODIMP
CComponent::GetResultViewType(
    MMC_COOKIE cookie,
    LPOLESTR* ppViewType,
    long* pViewOptions
    )
{

    if (!ppViewType || !pViewOptions)
    {
        return E_INVALIDARG;
    }

    HRESULT hr;

    try
    {
        CFolder* pFolder;
        pFolder = FindFolder(cookie);
        
        if (pFolder)
        {
            return pFolder->GetResultViewType(ppViewType, pViewOptions);
        }

        else
        {
            return S_OK;
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_pComponentData->m_hwndMain, 0, 0, 0);
        return S_FALSE;
    }
}

STDMETHODIMP
CComponent::Initialize(
    LPCONSOLE lpConsole
    )
{
    HRESULT hr;

    if (!lpConsole)
    {
        return E_INVALIDARG;
    }

    m_pConsole = lpConsole;
    lpConsole->AddRef();

    hr = lpConsole->QueryInterface(IID_IHeaderCtrl, (void**)&m_pHeader);

    if (SUCCEEDED(hr))
    {
        lpConsole->SetHeader(m_pHeader);
        hr = lpConsole->QueryInterface(IID_IResultData, (void**)&m_pResult);
    }
    
    if (SUCCEEDED(hr))
    {
        hr = lpConsole->QueryConsoleVerb(&m_pConsoleVerb);
    }
    
    if (SUCCEEDED(hr))
    {
        hr = lpConsole->QueryInterface(IID_IPropertySheetProvider,
                                       (void**)&m_pPropSheetProvider);
    }
    
    if (SUCCEEDED(hr))
    {
        hr = lpConsole->QueryInterface(IID_IDisplayHelp, (void**)&m_pDisplayHelp);
    }

    if (FAILED(hr))
    {
        TRACE((TEXT("CComponent::Initialize failed\n")));
    }

    return hr;
}

#if DBG
TCHAR *mmcNotifyStr[] = {
    TEXT("UNKNOWN"),
    TEXT("ACTIVATE"),
    TEXT("ADD_IMAGES"),
    TEXT("BTN_CLICK"),
    TEXT("CLICK"),
    TEXT("COLUMN_CLICK"),
    TEXT("CONTEXTMENU"),
    TEXT("CUTORMOVE"),
    TEXT("DBLCLICK"),
    TEXT("DELETE"),
    TEXT("DESELECT_ALL"),
    TEXT("EXPAND"),
    TEXT("HELP"),
    TEXT("MENU_BTNCLICK"),
    TEXT("MINIMIZED"),
    TEXT("PASTE"),
    TEXT("PROPERTY_CHANGE"),
    TEXT("QUERY_PASTE"),
    TEXT("REFRESH"),
    TEXT("REMOVE_CHILDREN"),
    TEXT("RENAME"),
    TEXT("SELECT"),
    TEXT("SHOW"),
    TEXT("VIEW_CHANGE"),
    TEXT("SNAPINHELP"),
    TEXT("CONTEXTHELP"),
    TEXT("INITOCX"),
    TEXT("FILTER_CHANGE"),
    TEXT("FILTERBTN_CLICK"),
    TEXT("RESTORE_VIEW"),
    TEXT("PRINT"),
    TEXT("PRELOAD"),
    TEXT("LISTPAD"),
    TEXT("EXPANDSYNC")
    };
#endif

STDMETHODIMP
CComponent::Notify(
    LPDATAOBJECT lpDataObject,
    MMC_NOTIFY_TYPE event,
    LPARAM arg,
    LPARAM param
    )
{
    HRESULT hr;

    INTERNAL_DATA tID;

#if DBG
    UINT i = event - MMCN_ACTIVATE + 1;
    if (event > MMCN_EXPANDSYNC || event < MMCN_ACTIVATE)
    {
        i = 0;
    }
    //TRACE((TEXT("Componet:Notify, event = %lx %s\n"), event, mmcNotifyStr[i]));
#endif

    try
    {
        if (DOBJ_CUSTOMOCX == lpDataObject)
        {
            return OnOcxNotify(event, arg, param);
        }

        hr = ExtractData(lpDataObject, CDataObject::m_cfSnapinInternal,
                         (PBYTE)&tID, sizeof(tID));

        if (SUCCEEDED(hr))
        {
            switch(event)
            {
            case MMCN_ACTIVATE:
                hr = OnActivate(tID.cookie, arg, param);
                break;

            case MMCN_VIEW_CHANGE:
                hr = OnViewChange(tID.cookie, arg, param);
                break;

            case MMCN_SHOW:
                hr = OnShow(tID.cookie, arg, param);
                break;

            case MMCN_CLICK:
                hr = OnResultItemClick(tID.cookie, arg, param);
                break;
                
            case MMCN_DBLCLICK:
                hr = OnResultItemDblClick(tID.cookie, arg, param);
                break;
                
            case MMCN_MINIMIZED:
                hr = OnMinimize(tID.cookie, arg, param);
                break;
                
            case MMCN_BTN_CLICK:
                hr = OnBtnClick(tID.cookie, arg, param);
                break;
                
            case MMCN_SELECT:
                hr = OnSelect(tID.cookie, arg, param);
                break;
                
            case MMCN_ADD_IMAGES:
                hr = OnAddImages(tID.cookie, (IImageList*)arg, param);
                break;
                
            case MMCN_RESTORE_VIEW:
                hr = OnRestoreView(tID.cookie, arg, param);
                break;
                
            case MMCN_CONTEXTHELP:
                hr = OnContextHelp(tID.cookie, arg, param);
                break;
                
            default:
                    hr = S_OK;
                    break;
            }
        }
        
        else
        {
            if (MMCN_ADD_IMAGES == event)
            {
                OnAddImages(0, (IImageList*)arg, (HSCOPEITEM)param);
            }
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_pComponentData->m_hwndMain, 0, 0, 0);
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

STDMETHODIMP
CComponent::Destroy(
    MMC_COOKIE cookie
    )
{
    //
    // cookie must point to the static node
    //
    ASSERT(0 == cookie);

    try
    {
        DetachAllFoldersFromMachine();
        DestroyFolderList(cookie);

        if (m_pToolbar)
        {
            m_pToolbar->Release();
        }
        
        if (m_pControlbar)
        {
            m_pControlbar->Release();
        }

        //
        // Release the interfaces that we QI'ed
        //
        if (m_pConsole != NULL)
        {
            //
            // Tell the console to release the header control interface
            //
            m_pConsole->SetHeader(NULL);
            m_pHeader->Release();

            m_pResult->Release();

            m_pConsoleVerb->Release();

            m_pDisplayHelp->Release();

            //
            // Release the IFrame interface last
            //
            m_pConsole->Release();
        }

        if (m_pPropSheetProvider)
        {
            m_pPropSheetProvider->Release();
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_pComponentData->m_hwndMain, 0, 0, 0);
    }
    
    return S_OK;
}

STDMETHODIMP
CComponent::QueryDataObject(
    MMC_COOKIE cookie,
    DATA_OBJECT_TYPES type,
    LPDATAOBJECT* ppDataObject
    )
{

    try
    {
        ASSERT(m_pComponentData);
        
        //
        // Delegate to IComponentData
        //
        return m_pComponentData->QueryDataObject(cookie, type, ppDataObject);
    }
    
    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_pComponentData->m_hwndMain, 0, 0, 0);
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP
CComponent::GetDisplayInfo(
    LPRESULTDATAITEM pResultDataItem
    )
{
    try
    {
        CFolder* pFolder = FindFolder(pResultDataItem->lParam);
        
        if (pFolder)
        {
            return pFolder->GetDisplayInfo(pResultDataItem);
        }
        
        else
        {
            return S_OK;
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_pComponentData->m_hwndMain, 0, 0, 0);
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP
CComponent::CompareObjects(
    LPDATAOBJECT lpDataObjectA,
    LPDATAOBJECT lpDataObjectB
    )
{
    try
    {
        ASSERT(m_pComponentData);
        
        //
        // Delegate to ComponentData
        //
        return m_pComponentData->CompareObjects(lpDataObjectA, lpDataObjectB);
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_pComponentData->m_hwndMain, 0, 0, 0);
        return E_OUTOFMEMORY;
    }
}

///////////////////////////////////////////////////////////////////////////
/// IResultDataCompare implementation
///

// This compare is used to sort the item's in the listview.
// lUserParam - user param passed in when IResultData::Sort() was called.
// cookieA    -- first item
// cookieB    -- second item
// pnResult contains the column on entry. This function has the compared
// result in the location pointed by this parameter.
// the valid compare results are:
// -1 if cookieA  "<" cookieB
// 0  if cookieA "==" cookieB
// 1 if cookieA ">" cookieB
//
//

STDMETHODIMP
CComponent::Compare(
    LPARAM lUserParam,
    MMC_COOKIE cookieA,
    MMC_COOKIE cookieB,
    int* pnResult
    )
{
    if (!pnResult)
    {
        return E_INVALIDARG;
    }

    HRESULT hr;
    
    try
    {
        int nCol = *pnResult;
        CFolder* pFolder = (CFolder*)lUserParam;
        
        if (pFolder)
        {
            hr = pFolder->Compare(cookieA, cookieB, nCol, pnResult);
        }

        else
        {
            hr = m_pCurFolder->Compare(cookieA, cookieB, nCol, pnResult);
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_pComponentData->m_hwndMain, 0, 0, 0);
        hr =  E_OUTOFMEMORY;
    }
    
    return hr;
}

////////////////////////////////////////////////////////////////////////////
/// Snapin's IExtendContextMenu implementation -- delegate to IComponentData
////
// Note that IComponentData also has its own IExtendContextMenu
// interface implementation. The difference is that
// IComponentData only deals with scope items while we only
// deal with result item except for cutomer view menu.
//
//
STDMETHODIMP
CComponent::AddMenuItems(
    LPDATAOBJECT lpDataObject,
    LPCONTEXTMENUCALLBACK pCallback,
    long*   pInsertionAllowed
    )
{
    HRESULT hr;
    INTERNAL_DATA tID;
    
    try
    {
        //
        // If lpDataObject is DOBJ_CUSTOMOCX then the user is viewing
        // the Action menu.
        //
        if (DOBJ_CUSTOMOCX == lpDataObject) 
        {
            ASSERT(m_pCurFolder);

            hr = m_pCurFolder->m_pScopeItem->AddMenuItems(pCallback, pInsertionAllowed);
        }

        //
        // If we have a valid cookie then the user is using the context menu
        // or the View menu
        //
        else
        {
            hr = ExtractData(lpDataObject, CDataObject::m_cfSnapinInternal,
                             reinterpret_cast<BYTE*>(&tID), sizeof(tID)
                             );

            if (SUCCEEDED(hr))
            {
                ASSERT(m_pCurFolder);

                hr = m_pCurFolder->AddMenuItems(GetActiveCookie(tID.cookie),
                                            pCallback, pInsertionAllowed
                                            );
            }
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_pComponentData->m_hwndMain, 0, 0, 0);
        hr  = E_OUTOFMEMORY;
    }
    
    return hr;
}

STDMETHODIMP
CComponent::Command(
    long nCommandID,
    LPDATAOBJECT lpDataObject
    )
{
    INTERNAL_DATA tID;

    HRESULT hr;
    try
    {
        //
        // Menu item from the Action menu
        //
        if (DOBJ_CUSTOMOCX == lpDataObject) 
        {
            ASSERT(m_pCurFolder);

            hr = m_pCurFolder->m_pScopeItem->MenuCommand(nCommandID);
        }

        //
        // Context menu item or View menu item
        //
        else
        {
            hr = ExtractData(lpDataObject, CDataObject::m_cfSnapinInternal,
                              (PBYTE)&tID, sizeof(tID));
            if (SUCCEEDED(hr))
            {
                ASSERT(m_pCurFolder);
                
                hr = m_pCurFolder->MenuCommand(GetActiveCookie(tID.cookie), nCommandID);
            }
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_pComponentData->m_hwndMain, 0, 0, 0);
        hr =  E_OUTOFMEMORY;
    }
    
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
// IExtendControlbar implementation
//

MMCBUTTON g_SnapinButtons[] =
{
    { 0, IDM_REFRESH,      TBSTATE_ENABLED, TBSTYLE_BUTTON, (BSTR)IDS_BUTTON_REFRESH,      (BSTR)IDS_TOOLTIP_REFRESH },
    { 0, 0,                TBSTATE_ENABLED, TBSTYLE_SEP,    NULL,                          NULL },
    { 4, IDM_UPDATEDRIVER, TBSTATE_ENABLED, TBSTYLE_BUTTON, (BSTR)IDS_BUTTON_UPDATEDRIVER, (BSTR)IDS_TOOLTIP_UPDATEDRIVER },
    { 2, IDM_REMOVE,       TBSTATE_ENABLED, TBSTYLE_BUTTON, (BSTR)IDS_BUTTON_REMOVE,       (BSTR)IDS_TOOLTIP_REMOVE },
    { 1, IDM_ENABLE,       TBSTATE_ENABLED, TBSTYLE_BUTTON, (BSTR)IDS_BUTTON_ENABLE,       (BSTR)IDS_TOOLTIP_ENABLE },
    { 3, IDM_DISABLE,      TBSTATE_ENABLED, TBSTYLE_BUTTON, (BSTR)IDS_BUTTON_DISABLE,      (BSTR)IDS_TOOLTIP_DISABLE },
};

#define CBUTTONS_ARRAY          ARRAYLEN(g_SnapinButtons)

String* g_astrButtonStrings = NULL;    // dynamic array of Strings
BOOL g_bLoadedStrings = FALSE;


STDMETHODIMP
CComponent::SetControlbar(
    LPCONTROLBAR pControlbar
    )
{
    if (pControlbar != NULL)
    {
        //
        // Hold on to the controlbar interface.
        //
        if (m_pControlbar)
        {
            m_pControlbar->Release();
        }

        m_pControlbar = pControlbar;
        m_pControlbar->AddRef();

        HRESULT hr = S_FALSE;

        if (!m_pToolbar)
        {
            //
            // Create the Toolbar
            //
            hr = m_pControlbar->Create(TOOLBAR, this,
                                       reinterpret_cast<LPUNKNOWN*>(&m_pToolbar));
            ASSERT(SUCCEEDED(hr));

            //
            // Add the bitmap
            //
            HBITMAP hBitmap = ::LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_TOOLBAR));
            hr = m_pToolbar->AddBitmap(4, hBitmap, 16, 16, RGB(255, 0, 255));
            ASSERT(SUCCEEDED(hr));

            if (!g_bLoadedStrings)
            {
                //
                // Load strings
                //
                g_astrButtonStrings = new String[2*CBUTTONS_ARRAY];
                
                for (UINT i = 0; i < CBUTTONS_ARRAY; i++)
                {
                    if (NULL != g_SnapinButtons[i].lpButtonText &&
                        g_astrButtonStrings[i*2].LoadString(g_hInstance,
                                (UINT)((ULONG_PTR)g_SnapinButtons[i].lpButtonText)))
                    {
                        g_SnapinButtons[i].lpButtonText =
                            const_cast<BSTR>((LPCTSTR)(g_astrButtonStrings[i*2]));
                    }
                    
                    else
                    {
                        g_SnapinButtons[i].lpButtonText = NULL;
                    }

                    if (NULL != g_SnapinButtons[i].lpTooltipText &&
                        g_astrButtonStrings[(i*2)+1].LoadString(g_hInstance,
                                (UINT)((ULONG_PTR)g_SnapinButtons[i].lpTooltipText)))
                    {
                        g_SnapinButtons[i].lpTooltipText =
                                const_cast<BSTR>((LPCTSTR)(g_astrButtonStrings[(i*2)+1]));
                    }
                    
                    else
                    {
                        g_SnapinButtons[i].lpTooltipText = NULL;
                    }
                }

                g_bLoadedStrings = TRUE;
            }

            //
            // Add the buttons to the toolbar
            //
            hr = m_pToolbar->AddButtons(CBUTTONS_ARRAY, g_SnapinButtons);
            ASSERT(SUCCEEDED(hr));
        }
    }

    return S_OK;
}

STDMETHODIMP
CComponent::ControlbarNotify(
    MMC_NOTIFY_TYPE event,
    LPARAM arg,
    LPARAM param
    )
{
    switch (event)
    {
    case MMCN_BTN_CLICK:
        //
        // arg - Data object of the currently selected scope or result pane item.
        // param - CmdID of the button.
        //
        switch (param)
        {
        case IDM_REFRESH:
        case IDM_ENABLE:
        case IDM_REMOVE:
        case IDM_DISABLE:
        case IDM_UPDATEDRIVER:

            //
            // The arg parameter is supposed to be the data object of the
            // currently selected scope or result pane item, but it seems
            // to always passes 0xFFFFFFFF. So the ScopeItem MenuCommand is
            // used because it uses the selected cookie instead.
            //
            // Handle toolbar button requests.
            //
            return m_pCurFolder->m_pScopeItem->MenuCommand((LONG)param);

        default:
            break;
        }

        break;

    case MMCN_SELECT:
        //
        // param - Data object of the item being selected.
        // For select, if the cookie has toolbar items attach the toolbar.
        // Otherwise detach the toolbar.
        //

        HRESULT hr;

        if (LOWORD(arg))
        {
            //
            // LOWORD(arg) being set indicated this is for the scope pane item.
            //
            if (HIWORD(arg))
            {
                //
                // Detach the Controlbar.
                //
                hr = m_pControlbar->Detach(reinterpret_cast<LPUNKNOWN>(m_pToolbar));
                ASSERT(SUCCEEDED(hr));
            }

            else
            {
                //
                // Attach the Controlbar.
                //
                hr = m_pControlbar->Attach(TOOLBAR,
                                           reinterpret_cast<LPUNKNOWN>(m_pToolbar));
                ASSERT(SUCCEEDED(hr));
            }
        }
        break;

    default:
        break;
    }

    return S_OK;
}

//
// This function updates the toolbar buttons based on the selected cookie type.
//
HRESULT
CComponent::UpdateToolbar(
    CCookie* pCookie
    )
{
    if (!m_pToolbar)
    {
        return S_OK;
    }

    //
    // Everything is hidden by default
    //
    BOOL fRemoveHidden = TRUE;
    BOOL fRefreshHidden = TRUE;
    BOOL fUpdateHidden = TRUE;
    BOOL fDisableHidden = TRUE;
    BOOL fEnableHidden = TRUE;

    switch (pCookie->GetType())
    {
    case COOKIE_TYPE_RESULTITEM_DEVICE:
    case COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ:
    case COOKIE_TYPE_RESULTITEM_RESOURCE_DMA:
    case COOKIE_TYPE_RESULTITEM_RESOURCE_IO:
    case COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY:
        if(m_pComponentData->m_pMachine->IsLocal() && g_HasLoadDriverNamePrivilege)
        {
            CDevice* pDevice = NULL;
            CClass* pClass;
            UINT index;

            if (COOKIE_TYPE_RESULTITEM_DEVICE == pCookie->GetType()) {
                pDevice = (CDevice*)pCookie->GetResultItem();
            } else {
                //
                // This is a resource item, get the pointer for the device
                // object from the resource object.
                //
                CResource* pResource = (CResource*) pCookie->GetResultItem();
                if (pResource) {
                    pDevice = pResource->GetDevice();
                }
            }

            if (pDevice)
            {
                pClass = pDevice->GetClass();

                //
                // Device can be disabled
                //
                if (pDevice->IsDisableable()) {
            
                    if (pDevice->IsStateDisabled()) {

                        fEnableHidden = FALSE;
                
                    } else {

                        fDisableHidden = FALSE;
                    }
                }

                //
                // Device cannot be disabled
                //
                else
                {
                    //
                    // Hide both the enable and disable buttons in case the
                    // previously selected node was a device.
                    //
                    m_pToolbar->SetButtonState(IDM_ENABLE, HIDDEN, TRUE);
                    m_pToolbar->SetButtonState(IDM_DISABLE, HIDDEN, TRUE);
                }

                //
                // Only show the uninstall button if the device can be uninstalled.
                //
                if (pDevice->IsUninstallable()) {
            
                    fRemoveHidden = FALSE;
                }

                //
                // Display Update Driver button for everything except legacy drivers.
                //
                fUpdateHidden = IsEqualGUID(*pClass, GUID_DEVCLASS_LEGACYDRIVER) ? TRUE : FALSE;

                //
                // Display refresh (Scan...) button.
                //
                fRefreshHidden = FALSE;
            }
            break;
        }
        else
        {
            //
            // Must be an admin and on the local machine to remove or
            // enable/disable a device.
            //
            //
            // Fall through to hide the remove and enable/disable buttons.
            //
        }


    case COOKIE_TYPE_RESULTITEM_COMPUTER:
    case COOKIE_TYPE_RESULTITEM_CLASS:
    case COOKIE_TYPE_RESULTITEM_RESTYPE:
        
        //
        // Display refresh (enumerate) button if the user has SE_LOAD_DRIVER_NAME privileges
        //
        if (g_HasLoadDriverNamePrivilege) {
        
            fRefreshHidden = FALSE;
        }

        break;

    default:
        break;
    }
    
    //
    // Hide or show the buttons
    //
    m_pToolbar->SetButtonState(IDM_REMOVE, HIDDEN, fRemoveHidden);
    m_pToolbar->SetButtonState(IDM_REFRESH, HIDDEN, fRefreshHidden);
    m_pToolbar->SetButtonState(IDM_UPDATEDRIVER, HIDDEN, fUpdateHidden);
    m_pToolbar->SetButtonState(IDM_DISABLE, HIDDEN, fDisableHidden);
    m_pToolbar->SetButtonState(IDM_ENABLE, HIDDEN, fEnableHidden);

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//// Snapin's IExtendPropertySheet implementation
////

STDMETHODIMP
CComponent::QueryPagesFor(
    LPDATAOBJECT lpDataObject
    )
{
    HRESULT hr;

    if (!lpDataObject)
    {
        return E_INVALIDARG;
    }

    INTERNAL_DATA tID;
    
    try
    {
        hr = ExtractData(lpDataObject, CDataObject::m_cfSnapinInternal,
                         reinterpret_cast<BYTE*>(&tID), sizeof(tID)
                         );
        
        if (SUCCEEDED(hr))
        {
            ASSERT(m_pCurFolder);
            hr = m_pCurFolder->QueryPagesFor(GetActiveCookie(tID.cookie));
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_pComponentData->m_hwndMain, 0, 0, 0);
        hr  = S_FALSE;
    }

    return hr;
}

STDMETHODIMP
CComponent::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle,
    LPDATAOBJECT lpDataObject
    )
{
    HRESULT hr;

    if (!lpProvider || !lpDataObject)
    {
        return E_INVALIDARG;
    }

    INTERNAL_DATA tID;
    
    try
    {
        hr = ExtractData(lpDataObject, CDataObject::m_cfSnapinInternal,
                         reinterpret_cast<BYTE*>(&tID), sizeof(tID)
                         );
        
        if (SUCCEEDED(hr))
        {
            ASSERT(m_pCurFolder);
            hr = m_pCurFolder->CreatePropertyPages(GetActiveCookie(tID.cookie),
                                           lpProvider, handle
                                           );
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_pComponentData->m_hwndMain, 0, 0, 0);
        hr =  E_OUTOFMEMORY;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Snapin's IPersistStream implementation

STDMETHODIMP
CComponent::GetClassID(
    CLSID* pClassID
    )
{
    if(!pClassID)
    {
        return E_POINTER;
    }

    *pClassID = m_pComponentData->GetCoClassID();
    return S_OK;
}

STDMETHODIMP
CComponent::IsDirty()
{
    return m_Dirty ? S_OK : S_FALSE;
}

STDMETHODIMP
CComponent::GetSizeMax(
    ULARGE_INTEGER* pcbSize
    )
{
    if (!pcbSize)
    {
        return E_INVALIDARG;
    }

    //         total folders        folder signature
    int Size =  sizeof(int) + m_listFolder.GetCount() * sizeof(FOLDER_SIGNATURE)
                + sizeof(CLSID);
    
    CFolder* pFolder;
    POSITION pos = m_listFolder.GetHeadPosition();
    
    while (NULL != pos)
    {
        pFolder = m_listFolder.GetNext(pos);
        ASSERT(pFolder);
        Size += pFolder->GetPersistDataSize();
    }
    
    ULISet32(*pcbSize, Size);
    return S_OK;
}


// save data format

STDMETHODIMP
CComponent::Save(
    IStream* pStm,
    BOOL fClearDirty
    )
{
    HRESULT hr = S_OK;

    SafeInterfacePtr<IStream> StmPtr(pStm);

    int Count, Index;
    POSITION pos;
    CLSID clsid;
    try
    {
        //
        // write out CLSID
        //
        hr = pStm->Write(&CLSID_DEVMGR, sizeof(CLSID), NULL);
        if (SUCCEEDED(hr))
        {
            Count = m_listFolder.GetCount();
            CFolder* pFolder;
            
            //
            // write out folder count
            //
            hr = pStm->Write(&Count, sizeof(Count), NULL);
            
            if (SUCCEEDED(hr) && Count)
            {
                pos = m_listFolder.GetHeadPosition();
                
                while (NULL != pos)
                {
                    pFolder = m_listFolder.GetNext(pos);
                    
                    //
                    // write folder signature
                    //
                    FOLDER_SIGNATURE Signature = pFolder->GetSignature();
                    hr = pStm->Write(&Signature, sizeof(Signature), NULL);
                    
                    if (SUCCEEDED(hr))
                    {
                        hr = SaveFolderPersistData(pFolder, pStm, fClearDirty);
                    }
                    
                    if (FAILED(hr))
                    {
                        break;
                    }
                }
            }
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_pComponentData->m_hwndMain, 0, 0, 0);
        hr =  E_OUTOFMEMORY;
    }

    if (fClearDirty)
    {
        m_Dirty = FALSE;
    }

    return hr;
}

STDMETHODIMP
CComponent::Load(
    IStream* pStm
    )
{
    HRESULT hr = S_OK;

    CLSID clsid;
    SafeInterfacePtr<IStream> StmPtr(pStm);

    ASSERT(pStm);

    //
    // Read the clsid
    //
    try
    {
        hr = pStm->Read(&clsid, sizeof(clsid), NULL);
        if (SUCCEEDED(hr) && clsid ==  CLSID_DEVMGR)
        {
            CFolder* pFolder;
            int FolderCount;

            //
            // Folder list must be create before Load.
            // DO NOT rely on that IComponent::Initialize comes before IStream::Load
            //
            ASSERT(m_listFolder.GetCount());

            //
            // Load folder count
            //
            hr = pStm->Read(&FolderCount, sizeof(FolderCount), NULL);
            if (SUCCEEDED(hr))
            {
                ASSERT(m_listFolder.GetCount() == FolderCount);
                
                //
                // Get folder signature
                // go through every folder
                //
                for (int i = 0; i < FolderCount; i++)
                {
                    FOLDER_SIGNATURE Signature;
                    hr = pStm->Read(&Signature, sizeof(Signature), NULL);
                    
                    if (SUCCEEDED(hr))
                    {
                        POSITION pos;
                        pos = m_listFolder.GetHeadPosition();
                        
                        while (NULL != pos)
                        {
                            pFolder = m_listFolder.GetNext(pos);
                            
                            if (pFolder->GetSignature() == Signature)
                            {
                                hr = LoadFolderPersistData(pFolder, pStm);
                                break;
                            }
                        }
                    }
                }
            }
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_pComponentData->m_hwndMain, 0, 0, 0);
        hr = E_OUTOFMEMORY;
    }
    
    m_Dirty = FALSE;
    
    return hr;
}

HRESULT
CComponent::SaveFolderPersistData(
    CFolder* pFolder,
    IStream* pStm,
    BOOL fClearDirty
    )
{
    HRESULT hr = S_OK;
    int Size;
    SafeInterfacePtr<IStream> StmPtr(pStm);

    try
    {
        Size = pFolder->GetPersistDataSize();
        
        //
        // Always write the length even though it can be 0.
        //
        hr = pStm->Write(&Size, sizeof(Size), NULL);
        
        if (SUCCEEDED(hr) && Size)
        {
            BufferPtr<BYTE> Buffer(Size);
            pFolder->GetPersistData(Buffer, Size);
            hr = pStm->Write(Buffer, Size, NULL);
        }
    }
    
    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_pComponentData->m_hwndMain, 0, 0, 0);
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

HRESULT
CComponent::LoadFolderPersistData(
    CFolder* pFolder,
    IStream* pStm
    )
{
    HRESULT hr = S_OK;

    SafeInterfacePtr<IStream> StmPtr(pStm);

    int Size = 0;
    hr = pStm->Read(&Size, sizeof(Size), NULL);
    
    if (SUCCEEDED(hr) && Size)
    {
        BufferPtr<BYTE> Buffer(Size);
        hr = pStm->Read(Buffer, Size, NULL);
        
        if (SUCCEEDED(hr))
        {
            hr = pFolder->SetPersistData(Buffer, Size);
        }
    }

    return hr;
}

//
// This function attaches the given folder the the machine created
// by the component data. The machine notifies every attached folder
// when there are state changes in the machine.
//
// INPUT:
//      pFolder     -- the folder to be attached
//      ppMachind   -- to receive a pointer to the machine
// OUTPUT:
//      TRUE if the folder is attached successfully.
//      FALSE if the attachment failed.
//
//
BOOL
CComponent::AttachFolderToMachine(
    CFolder* pFolder,
    CMachine** ppMachine
    )
{
    if (!pFolder)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    // Initialize the machine.
    if (m_pComponentData->InitializeMachine())
    {
        *ppMachine = m_pComponentData->m_pMachine;
        (*ppMachine)->AttachFolder(pFolder);
        return TRUE;
    }
    
    return FALSE;
}

//
// This function detaches all the component's folders from the machine
//
void
CComponent::DetachAllFoldersFromMachine()
{
    if (m_pComponentData->m_pMachine)
    {
        CMachine* pMachine = m_pComponentData->m_pMachine;

        CFolder* pFolder;
        POSITION pos = m_listFolder.GetHeadPosition();
        
        while (NULL != pos)
        {
            pFolder = m_listFolder.GetNext(pos);
            pMachine->DetachFolder(pFolder);
        }
    }
}

HRESULT
CComponent::CreateFolderList(
    CCookie* pCookie
    )
{
    CCookie* pCookieChild;
    CScopeItem* pScopeItem;
    CFolder* pFolder;

    ASSERT(pCookie);

    HRESULT hr = S_OK;
    
    do
    {
        pScopeItem = pCookie->GetScopeItem();
        ASSERT(pScopeItem);
        pFolder =  pScopeItem->CreateFolder(this);
        
        if (pFolder)
        {
            m_listFolder.AddTail(pFolder);
            pFolder->AddRef();
            pCookieChild = pCookie->GetChild();
            
            if (pCookieChild)
            {
                hr = CreateFolderList(pCookieChild);
            }

            pCookie = pCookie->GetSibling();
        }

        else
        {
           hr = E_OUTOFMEMORY;
        }

    } while (SUCCEEDED(hr) && pCookie);
    
    return hr;
}

BOOL
CComponent::DestroyFolderList(
    MMC_COOKIE cookie
    )
{
    if (!m_listFolder.IsEmpty())
    {
        POSITION pos = m_listFolder.GetHeadPosition();
        
        while (NULL != pos)
        {
            CFolder* pFolder = m_listFolder.GetNext(pos);
            
            //
            // DONOT delete it!!!!!!!
            //
            pFolder->Release();
        }

        m_listFolder.RemoveAll();
    }

    return TRUE;
}

CFolder*
CComponent::FindFolder(
    MMC_COOKIE cookie
    )
{
    CCookie* pCookie = GetActiveCookie(cookie);
    CFolder* pFolder;
    POSITION pos = m_listFolder.GetHeadPosition();
    
    while (NULL != pos)
    {
        pFolder = m_listFolder.GetNext(pos);
        
        if (pCookie->GetScopeItem() == pFolder->m_pScopeItem)
        {
            return pFolder;
        }
    }

    return NULL;
}

int
CComponent::MessageBox(
    LPCTSTR Msg,
    LPCTSTR Caption,
    DWORD Flags
    )
{
    int Result;
    ASSERT(m_pConsole);
    
    if (SUCCEEDED(m_pConsole->MessageBox(Msg, Caption, Flags, &Result)))
    {
        return Result;
    }

    else
    {
        return IDCANCEL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\cnode.h ===
#ifndef __CNODE_H__
#define __CNODE_H__
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    cnode.h

Abstract:

    header file for cnode.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/


class CResultItem;
class CResultComputer;
class CResultClass;
class CResultDevice;
class CDriverList;
class CDriver;
class CHwProfile;
class CMachine;
class CItemIdentifier;
class CDeviceIdentifier;
class CClassIdentifier;
class CComputerIdentifier;
class CResourceIdentifier;
class CResourceTypeIdentifier;

#define ALL_LOG_CONF        BOOT_LOG_CONF + ALLOC_LOG_CONF + FORCED_LOG_CONF

inline
COOKIE_TYPE CookieType(RESOURCEID ResType)
{
    if (ResType_Mem == ResType)
    {
        return COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY;
    }

    else if (ResType_IO == ResType)
    {
        return COOKIE_TYPE_RESULTITEM_RESOURCE_IO;
    }

    else if (ResType_DMA == ResType)
    {
        return COOKIE_TYPE_RESULTITEM_RESOURCE_DMA;
    }

    else if (ResType_IRQ == ResType)
    {
        return COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ;
    }

    else
    {
        ASSERT(FALSE);
        return COOKIE_TYPE_UNKNOWN;
    }
}

///
/// class to represent a result pane item
///

class CResultItem
{

public:
    CResultItem() : m_pMachine(NULL)
    {}

    virtual ~CResultItem() {};
    LPCTSTR GetDisplayName() const
    {
        return (LPCTSTR)m_strDisplayName;
    }

    int GetImageIndex()
    {
        return m_iImage;
    }
    virtual CItemIdentifier* CreateIdentifier() = 0;
    CMachine*   m_pMachine;

protected:
    int     m_iImage;
    String  m_strDisplayName;
};



class CClass : public CResultItem
{
public:
    CClass(CMachine* pMachine, LPGUID pGuid);

    virtual ~CClass();
    BOOL GetFirstDevice(CDevice** ppDevice, PVOID& pContext);
    BOOL GetNextDevice(CDevice** ppDevice, PVOID& Context);
    operator GUID&()
    {
        return m_Guid;
    }
    operator LPGUID()
    {
        return &m_Guid;
    }
    BOOL operator ==(const CClass& OtherClass)
    {
        return IsEqualGUID(m_Guid, (GUID&)OtherClass);
    }
    CDevInfoList* GetDevInfoList(HWND hwndParent = NULL);
    HICON LoadIcon();
    void AddDevice(CDevice* pDevice);
    int GetNumberOfDevices(BOOL Hidden = FALSE)
    {
            return Hidden ? m_TotalDevices :
                 m_TotalDevices - m_TotalHiddenDevices;
    }
    BOOL NoDisplay()
    {
        return m_NoDisplay;
    }
    virtual CItemIdentifier* CreateIdentifier();
    void PropertyChanged();

    CPropSheetData m_psd;

private:
    CClass(const CClass& ClassSrc);
    CClass& operator=(const CClass& ClassSrc);
    GUID    m_Guid;
    CList<CDevice*, CDevice*> m_listDevice;
    BOOL    m_NoDisplay;
    POSITION    m_pos;
    CDevInfoList* m_pDevInfoList;
    int     m_TotalDevices;
    int     m_TotalHiddenDevices;
};

class CDevice : public CResultItem
{
public:
    CDevice() : m_pClass(NULL), m_pSibling(NULL), m_pChild(NULL),
        m_pParent(NULL), m_bLaunchTroubleShooter(FALSE)
    {}
    CDevice(CMachine* pMachine, CClass* pClass, PSP_DEVINFO_DATA pDevData);

    operator SP_DEVINFO_DATA&()
    {
        return m_DevData;
    }
    operator PSP_DEVINFO_DATA()
    {
        return &m_DevData;
    }
    BOOL operator ==(LPCTSTR DeviceID)
    {
        return (0 == m_strDeviceID.CompareNoCase(DeviceID));
    }

    BOOL operator ==(CDevice& OtherDevice);

    CDevice* GetChild()
    {
        return m_pChild;
    }
    CDevice* GetParent()
    {
        return m_pParent;
    }
    CDevice* GetSibling()
    {
        return m_pSibling;
    }
    void SetChild(CDevice* pDevice)
    {
        m_pChild = pDevice;
    }
    void SetParent(CDevice* pDevice)
    {
        m_pParent = pDevice;
    }
    void SetSibling(CDevice* pDevice)
    {
        m_pSibling = pDevice;
    }
    CClass* GetClass()
    {
        return m_pClass;
    }
    virtual DEVNODE GetDevNode()
    {
        return m_DevData.DevInst;
    }
    LPCTSTR GetDeviceID() const
    {
        return (m_strDeviceID.IsEmpty()) ? NULL : (LPCTSTR)m_strDeviceID;
    }
    void SetClass(CClass* pClass)
    {
        m_pClass = pClass;
    }
    BOOL IsHidden();
    BOOL IsPhantom();
    BOOL NoShowInDM();
    BOOL IsPCMCIA();
    BOOL IsPCIDevice();
    BOOL IsPnpDevice();
    BOOL IsBiosDevice();

    BOOL GetMFG(TCHAR* pBuffer, DWORD Size, DWORD* pRequiredSize)
    {
        return m_pMachine->DiGetDeviceMFGString(&m_DevData, pBuffer, Size, pRequiredSize);
    }

    virtual CItemIdentifier* CreateIdentifier();
    CDevice* FindMFParent();
    HICON LoadClassIcon();
    BOOL GetStatus(DWORD* pStatus, DWORD* pProblem);
    BOOL GetCapabilities(DWORD* pCapabilities);
    BOOL GetPowerCapabilities(DWORD* pCapabilities);
    BOOL IsRAW();
    BOOL IsUninstallable();
    BOOL IsDisableable();
    BOOL IsDisabled();
    BOOL IsStateDisabled();
    BOOL IsStarted();
    BOOL IsMFChild();
    BOOL IsSpecialMFChild();
    BOOL HasProblem();
    BOOL NeedsRestart();
    BOOL GetConfigFlags(DWORD* pFlags);
    BOOL GetConfigSpecificConfigFlags(DWORD* pCSStatus);
    BOOL GetKnownLogConf(LOG_CONF* plc, DWORD* plcType);
    BOOL HasResources();
    void GetMFGString(String& strMFG);
    void GetProviderString(String& strMFG);
    void GetDriverDateString(String& strMFG);
    void GetDriverVersionString(String& strMFG);
    LPCTSTR  GetClassDisplayName();
    void ClassGuid(GUID& ClassGuid)
    {
        ASSERT(m_pClass);
        ClassGuid = *m_pClass;
    }
    BOOL  NoChangeUsage();
    CDriver* CreateDriver();
    BOOL    HasDrivers();
    DWORD EnableDisableDevice(HWND hDlg, BOOL Enabling);
    void PropertyChanged();
    CPropSheetData m_psd;
    BOOL m_bLaunchTroubleShooter;

private:
    CDevice(const CDevice& DeviceSrc);
    CDevice& operator=(const CDevice& DeviceSrc);

    CDevice*        m_pParent;
    CDevice*        m_pSibling;
    CDevice*        m_pChild;
    String      m_strDeviceID;
    SP_DEVINFO_DATA m_DevData;
    CClass*     m_pClass;
};

class CComputer : public CDevice
{
public:
    CComputer(CMachine* pMachine, DEVNODE dnRoot);
    virtual DEVNODE GetDevNode()
    {
        return m_dnRoot;
    }
    virtual CItemIdentifier* CreateIdentifier();

private:
    DEVNODE m_dnRoot;
    CComputer(const CComputer& ComputerSrc);
    CComputer& operator=(const CComputer& ComputerSrc);
};

class CResource : public CResultItem
{
public:
    CResource(CDevice* pDevice, RESOURCEID ResType, DWORDLONG dlBase, DWORDLONG dlLen,
          BOOL Forced, BOOL Free = FALSE);
    BOOL IsForced()
    {
        return m_Forced;
    }
    void GetValue(DWORDLONG* pdlBase, DWORDLONG* pdlLen) const
    {
        ASSERT(pdlBase && pdlLen);
        *pdlBase = m_dlBase;
        *pdlLen = m_dlLen;
    }
    virtual CItemIdentifier* CreateIdentifier();

    void GetRangeString(String& strRange);
    LPCTSTR GetViewName()
    {
            return (LPCTSTR)m_strViewName;
    }

    CDevice* GetDevice()
    {
        return m_pDevice;
    }
    CResource* GetChild()
    {
        return m_pChild;
    }
    CResource* GetSibling()
    {
        return m_pSibling;
    }
    CResource* GetParent()
    {
        return m_pParent;
    }
    void SetChild(CResource* pRes)
    {
        m_pChild = pRes;
    }
    void SetParent(CResource* pRes)
    {
        m_pParent = pRes;
    }
    void SetSibling(CResource* pRes)
    {
        m_pSibling = pRes;
    }
    BOOL operator <=(const CResource& resSrc);
    BOOL SameRange(const CResource& resSrc);
    BOOL EnclosedBy(const CResource& resSrc);
    RESOURCEID ResType()
    {
        return m_ResType;
    }
    CDevice*    m_pDevice;  // BUGBUG - this should not be public

private:
    CResource(const CResource& resSrc);
    CResource& operator=(const CResource& resSrc);
    RESOURCEID  m_ResType;
    DWORDLONG   m_dlBase;
    DWORDLONG   m_dlEnd;
    DWORDLONG   m_dlLen;
    BOOL    m_Forced;
    CResource*  m_pChild;
    CResource*  m_pSibling;
    CResource*  m_pParent;
//    COOKIE_TYPE m_CookieType;
    BOOL    m_Allocated;
    String      m_strViewName;
};

#define pIRQResData(pData) ((IRQ_RESOURCE*)pData)
#define pDMAResData(pData) ((DMA_RESOURCE*)pData)
#define pMemResData(pData) ((MEM_RESOURCE*)pData)
#define pIOResData(pData)  ((IO_RESOURCE*)pData)


class CResourceType : public CResultItem
{
public:
    CResourceType(CMachine* pMachine, RESOURCEID ResType);

    virtual CItemIdentifier* CreateIdentifier();

    CResource* GetChild()
    {
        return m_pChild;
    }
    CResourceType* GetSibling()
    {
        return m_pSibling;
    }
    CComputer* GetParent()
    {
        return m_pParent;
    }
    void SetChild(CResource* pRes)
    {
        m_pChild = pRes;
    }
    void SetParent(CComputer* pComp)
    {
        m_pParent = pComp;
    }
    void SetSibling(CResourceType* pResT)
    {
        m_pSibling = pResT;
    }
    RESOURCEID GetResType()
    {
        return m_ResType;
    }

private:
    CResourceType(const CResourceType& resSrc);
    CResourceType& operator=(const CResourceType& resSrc);
    RESOURCEID  m_ResType;
    CResource*  m_pChild;
    CResourceType*  m_pSibling;
    CComputer*  m_pParent;
};


class CResourceList
{
public:
    CResourceList(CDevice* pDevice, RESOURCEID ResType, 
                  ULONG LogConfType = ALLOC_LOG_CONF, ULONG AltLogConfType = BOOT_LOG_CONF);
    CResourceList(CMachine* pMachine, RESOURCEID ResType, 
                  ULONG LogConfType = ALLOC_LOG_CONF, ULONG AltLogConfType = BOOT_LOG_CONF);
    ~CResourceList();
    int GetCount()
    {
        return m_listRes.GetCount();
    }
    BOOL GetFirst(CResource** ppRes, PVOID& pContext);
    BOOL GetNext(CResource** ppRes, PVOID& Context);
    BOOL CreateResourceTree(CResource** ppRoot);
    static BOOL ExtractResourceValue(RESOURCEID ResType, PVOID pData,
                     DWORDLONG* pdlBase, DWORDLONG* pdlLen);
private:
    BOOL InsertResourceToTree(CResource* pRes, CResource* pResRoot, BOOL ForcedInsert);
    CResourceList(const CResourceList& Src);
    CResourceList& operator=(const CResourceList& Src);

    void CreateSubtreeResourceList(CDevice* pDeviceStart, RESOURCEID ResType, 
                                   ULONG LogConfType, ULONG AltLogConfType);
    CList<CResource*, CResource*> m_listRes;
    void InsertResourceToList(CResource* pRes);
#define pIRQResData(pData) ((IRQ_RESOURCE*)pData)
#define pDMAResData(pData) ((DMA_RESOURCE*)pData)
#define pMemResData(pData) ((MEM_RESOURCE*)pData)
#define pIOResData(pData)  ((IO_RESOURCE*)pData)
};


class CItemIdentifier
 {
public:
    CItemIdentifier()
    {}
    virtual ~CItemIdentifier()
    {}
    virtual BOOL operator==(CCookie& Cookie) = 0;
};


class CClassIdentifier : public CItemIdentifier
{
public:
    CClassIdentifier(CClass& Class)
    {
        m_Guid = (GUID&)Class;
    }
    virtual BOOL operator==(CCookie& Cookie)
    {
        return COOKIE_TYPE_RESULTITEM_CLASS == Cookie.GetType() &&
           IsEqualGUID(m_Guid, *((CClass*)Cookie.GetResultItem()));
    }

private:
    GUID    m_Guid;
};

class CDeviceIdentifier : public CItemIdentifier
{
public:
    CDeviceIdentifier(CDevice& Device)
    {
        ASSERT(Device.GetDeviceID());
        m_strDeviceId = Device.GetDeviceID();
    }
    virtual BOOL operator==(CCookie& Cookie)
    {
        return COOKIE_TYPE_RESULTITEM_DEVICE == Cookie.GetType() &&
           !lstrcmpi(m_strDeviceId, ((CDevice*)Cookie.GetResultItem())->GetDeviceID());
    }

private:
    String  m_strDeviceId;
};

class CResourceIdentifier : public CItemIdentifier
{
public:
    CResourceIdentifier(CResource& Res)
    {
        m_CookieType = CookieType(Res.ResType());
        m_strDisplayName = Res.GetDisplayName();
    }
    virtual BOOL operator==(CCookie& Cookie)
    {
        return m_CookieType == Cookie.GetType() &&
           !lstrcmpi((LPCTSTR)m_strDisplayName, Cookie.GetResultItem()->GetDisplayName());
    }

private:
    COOKIE_TYPE     m_CookieType;
    String      m_strDisplayName;
};

class CResourceTypeIdentifier : public CItemIdentifier
{
public:
    CResourceTypeIdentifier(CResourceType& ResType)
    {
        m_ResType = ResType.GetResType();
    }
    virtual BOOL operator==(CCookie& Cookie)
    {
        return COOKIE_TYPE_RESULTITEM_RESTYPE == Cookie.GetType() &&
           m_ResType == ((CResourceType*)Cookie.GetResultItem())->GetResType();
    }

private:
    RESOURCEID      m_ResType;
};

class CComputerIdentifier : public CItemIdentifier
{
public:
    CComputerIdentifier(CComputer& Computer)
    {
    ASSERT(Computer.GetDisplayName());
    m_strName = Computer.GetDisplayName();
    }
    virtual BOOL operator==(CCookie& Cookie)
    {
    return COOKIE_TYPE_RESULTITEM_COMPUTER == Cookie.GetType() &&
           !lstrcmpi((LPCTSTR)m_strName, Cookie.GetResultItem()->GetDisplayName());

    }

private:
    String  m_strName;
};


#endif // __CNODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\compdata.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    compdata.cpp

Abstract:

    This module implemets CComponentData class

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "devmgr.h"
#include "factory.h"
#include "genpage.h"

const WCHAR* const DM_COMPDATA_SIGNATURE = L"Device Manager";

CComponentData::CComponentData()
{
    m_pScope = NULL;
    m_pConsole = NULL;
    m_pCookieRoot = NULL;
    m_pScopeItemRoot = NULL;
    
    //
    // Static scope item default to device manager
    //
    m_ctRoot = COOKIE_TYPE_SCOPEITEM_DEVMGR;
    m_hwndMain = NULL;
    m_pMachine = NULL;
    m_IsDirty = FALSE;
    
    //
    // Increment object count(used by CanUnloadNow)
    //
    ::InterlockedIncrement(&CClassFactory::s_Objects);
    m_Ref = 1;
}

CComponentData::~CComponentData()
{

    //
    // All QIed interfaces should be released during
    // Destroy method
    //
    ASSERT(NULL == m_pScope);
    ASSERT(NULL == m_pConsole);
    ASSERT(NULL == m_pCookieRoot);
    
    //
    // decrement object count(used by CanUnloadNow)
    //
    ::InterlockedDecrement(&CClassFactory::s_Objects);

}

//
// IUnknown interface
//
ULONG
CComponentData::AddRef()
{
    ::InterlockedIncrement((LONG*)&m_Ref);
    return m_Ref;
}

ULONG
CComponentData::Release()
{
    ::InterlockedDecrement((LONG*)&m_Ref);
    
    if (!m_Ref)
    {
        delete this;
        return 0;
    }

    return m_Ref;
}

STDMETHODIMP
CComponentData::QueryInterface(
    REFIID  riid,
    void**  ppv
    )
{
    if (!ppv)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;


    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown*)(IComponentData*)this;
    }
    
    else if (IsEqualIID(riid, IID_IComponentData))
    {
        *ppv = (IComponentData*)this;
    }
    
    else if (IsEqualIID(riid, IID_IExtendContextMenu))
    {
        *ppv = (IExtendContextMenu*)this;
    }
    
    else if (IsEqualIID(riid, IID_IExtendPropertySheet))
    {
        *ppv = (IExtendPropertySheet*)this;
    }
    
    else if (IsEqualIID(riid, IID_IPersistStream))
    {
        *ppv = (IPersistStream*)this;
    }
    
    else if (IsEqualIID(riid, IID_ISnapinHelp))
    {
        *ppv = (ISnapinHelp*)this;
    }
    
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }
    
    if (SUCCEEDED(hr))
    {
        AddRef();
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//  IComponentData implementation
///

STDMETHODIMP
CComponentData::Initialize(
    LPUNKNOWN pUnknown
    )
{
    if (!pUnknown)
    {
        return E_INVALIDARG;
    }

    HRESULT hr;
    
    try
    {
        //
        // This function should be called only once.
        //
        ASSERT(NULL == m_pScope);
    
        //
        // Get the IConsoleNameSpace interface
        //
        hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (void**)&m_pScope);
        if (SUCCEEDED(hr))
        {
            hr = pUnknown->QueryInterface(IID_IConsole, (void**)&m_pConsole);
            
            if (SUCCEEDED(hr))
            {
                //
                // Retreive the console main window. It will be used
                // as the parent window of property sheets and
                // parent handle for setupapi calls
                //
                m_pConsole->GetMainWindow(&m_hwndMain);
                LoadScopeIconsForScopePane();
            }
            else
            {
                //
                // Unable to the IConsole Interface
                //
                m_pScope->Release();
            }
        }
    }
    
    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_hwndMain, 0, 0, 0);
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

// This function creates a new CComponent
// A Component will be created when a new "window" is being created.
//
STDMETHODIMP
CComponentData::CreateComponent(
    LPCOMPONENT* ppComponent
    )
{
    HRESULT hr;

    if (!ppComponent)
    {
        return E_INVALIDARG;
    }

    try
    {
        CComponent* pComponent = new CComponent(this);
        
        //
        // Return the IComponent interface
        //
        hr = pComponent->QueryInterface(IID_IComponent, (void**)ppComponent);
        pComponent->Release();
        
        if (SUCCEEDED(hr))
        {
            hr = CreateScopeItems();
    
            if (SUCCEEDED(hr))
            {
                hr = pComponent->CreateFolderList(m_pCookieRoot);
            }
            else
            {
                pComponent->Release();
                *ppComponent = NULL;
            }
        }
    }
    
    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_hwndMain, 0, 0, 0);
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

STDMETHODIMP
CComponentData::Notify(
    LPDATAOBJECT lpDataObject,
    MMC_NOTIFY_TYPE event,
    LPARAM    arg,
    LPARAM    param
    )
{
    HRESULT hr;
    try
    {
        //
        // On MMCN_PROPERTY_CHANGE event, lpDataObject is invalid
        // Donot touch it.
        //
        if (MMCN_PROPERTY_CHANGE == event)
        {
            PPROPERTY_CHANGE_INFO pPCI = (PPROPERTY_CHANGE_INFO) param;
            
            if (pPCI && PCT_STARTUP_INFODATA == pPCI->Type)
            {
                PSTARTUP_INFODATA pSI = (PSTARTUP_INFODATA)&pPCI->InfoData;
                ASSERT(pSI->Size == sizeof(STARTUP_INFODATA));
                
                if (pSI->MachineName[0] != _T('\0'))
                {
                    m_strMachineName = pSI->MachineName;
                }
                
                m_ctRoot = pSI->ct;
                SetDirty();
            }

            return S_OK;
        }

        else if (MMCN_EXPAND == event)
        {
            return OnExpand(lpDataObject, arg, param);
        }
        
        else if (MMCN_REMOVE_CHILDREN == event)
        {
            //
            // This is basically a hack!!!!
            // When the target computer is switched in Computer Management
            // snapin(we are an extention to it), we basically get
            // a MMCN_REMOVE_CHILDREN followed by MMCN_EXPAND.
            // The right thing for MMC to do is to create a new IComponent
            // for each new machine so that each IComponent can maintain
            // its own states(thus, its own folders).
            // Well, it is not a perfect world and we are forced to use
            // the old IComponent. So here we notify each scope node
            // which in turns will notify all the CFolders.
            //
            // After reset, each folder does not attach to any CMachine object
            // (thus, its m_pMachine will be NULL). Each folder will attach
            // to the new machine object when its OnShow method is called
            // the very "first" time.
            //
            if (!IsPrimarySnapin() && m_pScopeItemRoot)
            {
                ResetScopeItem(m_pScopeItemRoot);
            }

            return S_OK;
        }
    
        ASSERT(m_pScope);
        INTERNAL_DATA tID;
        hr = ExtractData(lpDataObject, CDataObject::m_cfSnapinInternal,
                 (PBYTE)&tID, sizeof(tID));
    
    
        if (SUCCEEDED(hr))
        {
            switch (event) {
            case MMCN_DELETE:
                hr = OnDelete(tID.cookie, arg, param);
                break;
            case MMCN_RENAME:
                hr = OnRename(tID.cookie, arg, param);
                break;
            case MMCN_CONTEXTMENU:
                hr = OnContextMenu(tID.cookie, arg, param);
                break;
            case MMCN_BTN_CLICK:
                hr = OnBtnClick(tID.cookie, arg, param);
                break;
            default:
                hr = S_OK;
                break;
            }
        }
    }
    
    catch(CMemoryException* e)
    {
        e->Delete();
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


STDMETHODIMP
CComponentData::GetDisplayInfo(
    SCOPEDATAITEM* pScopeDataItem
    )
{
    if (!pScopeDataItem)
    {
        return E_INVALIDARG;
    }

    try
    {
        //
        // IComponentData::GetDisplayInfo only deals with scope pane items.
        // Snapin's IComponent::GetDisplayInfo will deal with result pane items
        //
        CCookie* pCookie = (CCookie*) pScopeDataItem->lParam;
        ASSERT(pCookie);
        return pCookie->GetScopeItem()->GetDisplayInfo(pScopeDataItem);
    }
    
    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_hwndMain, 0, 0, 0);
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP
CComponentData::Destroy()
{
    if (m_pCookieRoot) 
    {
        delete m_pCookieRoot;
        m_pCookieRoot = NULL;
    }

    if (m_pScopeItemRoot) 
    {
        delete m_pScopeItemRoot;
    }

    if (m_pScope) 
    {
        m_pScope->Release();
        m_pScope = NULL;
    }
    
    if (m_pConsole)
    {
        m_pConsole->Release();
        m_pConsole = NULL;
    }

    return S_OK;
}

STDMETHODIMP
CComponentData::QueryDataObject(
    MMC_COOKIE cookie,
    DATA_OBJECT_TYPES type,
    LPDATAOBJECT* ppDataObject
    )
{
    CDataObject* pDataObject;
    COOKIE_TYPE  ct;
    CCookie* pCookie;

    try
    {
        pCookie = GetActiveCookie(cookie);
        
        if (NULL == pCookie)
        {
            ct = m_ctRoot;
        }
        else
        {
            ct = pCookie->GetType();
        }
    
        pDataObject = new CDataObject;
        pDataObject->Initialize(type, ct, pCookie, m_strMachineName);
        pDataObject->AddRef();
        *ppDataObject = pDataObject;
    }
    
    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_hwndMain, 0, 0, 0);
        return E_OUTOFMEMORY;
    }
    
    return S_OK;
}

STDMETHODIMP
CComponentData::CompareObjects(
    LPDATAOBJECT lpDataObjectA,
    LPDATAOBJECT lpDataObjectB
    )
{
    HRESULT hr;
    
    try
    {
        INTERNAL_DATA tID_A, tID_B;
        hr = ExtractData(lpDataObjectA, CDataObject::m_cfSnapinInternal,
                 (PBYTE)&tID_A, sizeof(tID_A));
        
        if (SUCCEEDED(hr))
        {
            hr = ExtractData(lpDataObjectB, CDataObject::m_cfSnapinInternal,
                     (PBYTE)&tID_B, sizeof(tID_B));
            
            if (SUCCEEDED(hr))
            {
                hr = (tID_A.ct == tID_B.ct && tID_A.cookie == tID_B.cookie &&
                       tID_A.dot == tID_B.dot) ? S_OK : S_FALSE;
            }
        }
    }
    
    catch(CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_hwndMain, 0, 0, 0);
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}



///////////////////////////////////////////////////////////////////
//// IExtendPropertySheet implementation
////
STDMETHODIMP
CComponentData::QueryPagesFor(
    LPDATAOBJECT lpDataObject
    )
{
    HRESULT hr;

    if (!lpDataObject)
    {
        return E_INVALIDARG;
    }

    try
    {
        INTERNAL_DATA tID;
        hr = ExtractData(lpDataObject, CDataObject::m_cfSnapinInternal,
                 (PBYTE)&tID, sizeof(tID));
        
        if (SUCCEEDED(hr))
        {
            CScopeItem* pScopeItem;
            pScopeItem = FindScopeItem(tID.cookie);
            
            if (CCT_SNAPIN_MANAGER == tID.dot && COOKIE_TYPE_SCOPEITEM_DEVMGR == tID.ct)
            {
                hr = S_OK;
            }

            else if (pScopeItem)
            {
                hr = pScopeItem->QueryPagesFor();
            }
            
            else
            {
                hr = S_FALSE;
            }
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_hwndMain, 0, 0, 0);
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

STDMETHODIMP
CComponentData::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle,
    LPDATAOBJECT lpDataObject
    )
{
    if (!lpProvider || !lpDataObject)
    {
        return E_INVALIDARG;
    }

    HRESULT hr;

    try
    {
        INTERNAL_DATA tID;
        hr = ExtractData(lpDataObject, CDataObject::m_cfSnapinInternal,
                 reinterpret_cast<BYTE*>(&tID), sizeof(tID)
                 );
        
        if (SUCCEEDED(hr))
        {
            CScopeItem* pScopeItem = FindScopeItem(tID.cookie);
            if (CCT_SNAPIN_MANAGER == tID.dot && COOKIE_TYPE_SCOPEITEM_DEVMGR == tID.ct)
            {
                hr = DoStartupProperties(lpProvider, handle, lpDataObject);
            }
            
            else if (pScopeItem)
            {
                hr = pScopeItem->CreatePropertyPages(lpProvider, handle);
            }

            else
            {
                hr = S_OK;
            }
        }
    }
    
    catch(CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_hwndMain, 0, 0, 0);
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}


////////////////////////////////////////////////////////////
//// IExtendContextMenu implemantation
////
STDMETHODIMP
CComponentData::AddMenuItems(
    LPDATAOBJECT lpDataObject,
    LPCONTEXTMENUCALLBACK pCallbackUnknown,
    long *pInsertionAllowed
    )
{
    if (!lpDataObject || !pCallbackUnknown || !pInsertionAllowed)
    {
        return E_INVALIDARG;
    }

    return S_OK;
}

STDMETHODIMP
CComponentData::Command(
    long nCommandID,
    LPDATAOBJECT lpDataObject
    )
{
    if (!lpDataObject)
    {
        return E_INVALIDARG;
    }

    return S_OK;
}

HRESULT
CComponentData::CreateCookieSubtree(
    CScopeItem* pScopeItem,
    CCookie* pCookieParent
    )
{
    ASSERT(pScopeItem);

    CScopeItem* pChild;
    CCookie* pCookieSibling;
    pCookieSibling = NULL;
    int Index = 0;

    while (pScopeItem->EnumerateChildren(Index, &pChild))
    {
        CCookie* pCookie;
        
        pCookie =  new CCookie(pChild->GetType());
        
        if (pCookie) {
        
            pCookie->SetScopeItem(pChild);
            
            if (!pCookieSibling)
            {
                pCookieParent->SetChild(pCookie);
            }
            else
            {
                pCookieSibling->SetSibling(pCookie);
            }
            
            pCookie->SetParent(pCookieParent);
            
            if (pChild->GetChildCount())
            {
                CreateCookieSubtree(pChild, pCookie);
            }
            
            pCookieSibling = pCookie;
        }

        Index++;
    }

    return S_OK;
}
////////////////////////////////////////////////////////////
/// IPersistStream implementation
///
STDMETHODIMP
CComponentData::GetClassID(
    CLSID* pClassID
    )
{
    if(!pClassID)
    {
        return E_INVALIDARG;
    }

    *pClassID = GetCoClassID();
    return S_OK;
}

STDMETHODIMP
CComponentData::IsDirty()
{
    return m_IsDirty ? S_OK : S_FALSE;
}



STDMETHODIMP
CComponentData::Load(
    IStream* pStm
    )
{
    HRESULT hr;
    SafeInterfacePtr<IStream> StmPtr(pStm);

    //
    // Fix up the MachineName that we got from the command line if there was one.
    // We need to prepend "\\" to the MachineName if it does not start with two
    // backslashes, and then we will verify the machine name by calling CM_Connect_Machine
    // to verify that this user has access to that machine.  If they do not then we
    // will set the MachineName to NULL.
    //
    if (!g_strStartupMachineName.IsEmpty())
    {
        if (_T('\\') != g_strStartupMachineName[0])
        {
            g_strStartupMachineName = TEXT("\\\\") + g_strStartupMachineName;
        }

        if (!VerifyMachineName(g_strStartupMachineName))
        {
            g_strStartupMachineName.Empty();
        }
    }

    COMPDATA_PERSISTINFO Info;
    ULONG BytesRead;

    ASSERT(pStm);
    
    //
    // Read the persist data and verify that we have the right data
    //
    hr = pStm->Read(&Info, sizeof(Info), &BytesRead);
        
    if (SUCCEEDED(hr) && 
        (BytesRead >= sizeof(Info)) &&
        (Info.Size >= sizeof(Info)) &&
        (!wcscmp(Info.Signature, DM_COMPDATA_SIGNATURE)))
    {
        try
        {
            m_ctRoot = Info.RootCookie;
            m_strMachineName.Empty();

            if (UNICODE_NULL != Info.ComputerFullName[0])
            {
#ifdef UNICODE
                m_strMachineName = Info.ComputerFullName;
#else
                CHAR ComputerNameA[MAX_PATH + 3];
                WideCharToMultiByte(CP_ACP, 0, Info.ComputerFullName, -1,
                    ComputerNameA, sizeof(ComputerNameA) / sizeof(CHAR), NULL, ULL);
                m_strMachineName = ComputerNameA;
#endif
            }
    
            if (COOKIE_TYPE_SCOPEITEM_DEVMGR == m_ctRoot)
            {
                //
                // Parameters from command line has the priority
                //
                if (!g_strStartupMachineName.IsEmpty())
                {
                    m_strMachineName = g_strStartupMachineName;
                }
                
                m_strStartupDeviceId = g_strStartupDeviceId;
                m_strStartupCommand = g_strStartupCommand;
            }
    
            hr = CreateScopeItems();
            if (SUCCEEDED(hr))
            {
                if (!m_pMachine)
                {
                    if (!g_MachineList.CreateMachine(m_hwndMain, m_strMachineName, &m_pMachine))
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
            }
        }

        catch(CMemoryException* e)
        {
            e->Delete();
            MsgBoxParam(m_hwndMain, 0, 0, 0);
            hr = E_OUTOFMEMORY;
        }
    }

    m_IsDirty = FALSE;

    return hr;
}

STDMETHODIMP
CComponentData::Save(
    IStream* pStm,
    BOOL fClearDirty
    )
{
    SafeInterfacePtr<IStream> StmPtr(pStm);

    HRESULT hr;

    try
    {
        COMPDATA_PERSISTINFO Info;
        Info.Size = sizeof(Info);
        Info.RootCookie = m_ctRoot;
        wcscpy(Info.Signature, DM_COMPDATA_SIGNATURE);
    
        //
        // Assuming it is on local machine. The machine name is saved
        // in UNICODE
        //
        Info.ComputerFullName[0] = UNICODE_NULL;
        if (m_strMachineName.GetLength())
#ifdef UNICODE
            wcscpy(Info.ComputerFullName, m_strMachineName);
#else
            MultiByteToWideChar((CP_ACP, 0, chBuffer, -1, Info.ComputerFullName,
                     sizeof(Info.ComputerFullName) / sizeof(WCHAR));
#endif
        
            hr = pStm->Write(&Info, sizeof(Info), NULL);
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_hwndMain, 0, 0, 0);
        hr = E_OUTOFMEMORY;
    }

    if (fClearDirty)
    {
        m_IsDirty = FALSE;
    }
    
    return hr;
}

STDMETHODIMP
CComponentData::GetSizeMax(
    ULARGE_INTEGER* pcbSize
    )
{
    if (!pcbSize)
    {
        return E_INVALIDARG;
    }

    int len;
    len = sizeof(m_ctRoot) + sizeof(len) +  (m_strMachineName.GetLength() + 1) * sizeof(TCHAR);
    ULISet32(*pcbSize, len);
    
    return S_OK;
}

//
// Method to support html help.
//
//
STDMETHODIMP
CComponentData::GetHelpTopic(
    LPOLESTR* lpCompileHelpFile
    )
{
    if (!lpCompileHelpFile)
    {
        return E_INVALIDARG;
    }

    *lpCompileHelpFile = NULL;
    UINT Size;
    TCHAR HelpFile[MAX_PATH];
    
    Size = GetSystemWindowsDirectory(HelpFile, ARRAYLEN(HelpFile));
    
    if (Size && Size < ARRAYLEN(HelpFile))
    {
        StrCatN(HelpFile, DEVMGR_HTML_HELP_FILE_NAME, ARRAYLEN(HelpFile));
        *lpCompileHelpFile = AllocOleTaskString(HelpFile);
    }

    return S_OK;
}

CScopeItem*
CComponentData::FindScopeItem(
    MMC_COOKIE cookie
    )
{
    CCookie* pCookie = GetActiveCookie(cookie);
    if (pCookie)
    return pCookie->GetScopeItem();
    return NULL;
}

//
// This function loads icons for the scope items
//
HRESULT
CComponentData::LoadScopeIconsForScopePane()
{
    ASSERT(m_pScope);
    ASSERT(m_pConsole);

    LPIMAGELIST lpScopeImage;
    HRESULT hr;
    
    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);
    
    if (SUCCEEDED(hr))
    {
        HICON hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_DEVMGR));
        
        if (hIcon)
        {
            hr = lpScopeImage->ImageListSetIcon((PLONG_PTR)hIcon, IMAGE_INDEX_DEVMGR);
            DestroyIcon(hIcon);
        }
        
        hr = lpScopeImage->Release();
    }

    return hr;
}

//
// This function create the startup wizard property sheet
//
// INPUT:
//  lpProvider -- Interface for us to add pages
//  handle     -- notify console handle
//  lpDataObject -- the data object
//
// OUTPUT:
//   standard OLE HRESULT

HRESULT
CComponentData::DoStartupProperties(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle,
    LPDATAOBJECT lpDataObject
    )
{
    CGeneralPage* pGenPage;
    HPROPSHEETPAGE hPage;
    
    pGenPage = new CGeneralPage();

    if (pGenPage) 
    {
        hPage = pGenPage->Create(handle);
        
        if (hPage)
        {
            lpProvider->AddPage(hPage);
            
            //
            // If no console handle is provided, we have to use
            // our call back function
            //
            if(!handle)
            {
                pGenPage->SetOutputBuffer(&m_strMachineName, &m_ctRoot);
            }
    
            return S_OK;
        }
    
        else
        {
            throw &g_MemoryException;
        }
    }

    else
    {
        throw &g_MemoryException;
    }

    return E_OUTOFMEMORY;
}

//
// This function creates all the necessary classes represent
// our scope items
//
HRESULT
CComponentData::CreateScopeItems()
{
    //
    // All classes are linked by cookie with m_pCookieRoot
    // points to the "root" scope item
    //
    if (!m_pScopeItemRoot)
    {
        switch (m_ctRoot)
        {
        case COOKIE_TYPE_SCOPEITEM_DEVMGR:
            m_pScopeItemRoot = new CScopeItem(COOKIE_TYPE_SCOPEITEM_DEVMGR,
                                              IMAGE_INDEX_DEVMGR,
                                              OPEN_IMAGE_INDEX_DEVMGR,
                                              IDS_NAME_DEVMGR,
                                              IDS_DESC_DEVMGR,
                                              IDS_DISPLAYNAME_SCOPE_DEVMGR);
            break;
            
        default:
            ASSERT(FALSE);
            break;
        }
        
        if (m_pScopeItemRoot->Create())
        {
            //
            // Bind scope items and cookies together.
            // Cookies know its scopeitem.
            // Scopeitems do not know cookies.
            //
            m_pCookieRoot = new CCookie(m_ctRoot);
            
            if (m_pCookieRoot)
            {
                ASSERT(m_pScopeItemRoot->GetType() == m_ctRoot);
                m_pCookieRoot->SetScopeItem(m_pScopeItemRoot);
                CreateCookieSubtree(m_pScopeItemRoot, m_pCookieRoot);
            }
        }
    }
    
    return S_OK;
}


//
// This function resets the given scopeitem.
//
HRESULT
CComponentData::ResetScopeItem(
    CScopeItem* pScopeItem
    )
{
    HRESULT hr = S_OK;
    
    if (pScopeItem)
    {
        CScopeItem* pChild;
        int Index;
        Index = 0;
        
        while (SUCCEEDED(hr) && pScopeItem->EnumerateChildren(Index, &pChild))
        {
            hr = ResetScopeItem(pChild);
            Index++;
        }
        
        if (SUCCEEDED(hr))
        {
            return pScopeItem->Reset();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\dataobj.h ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    dataobj.h

Abstract:

    header file defines CDataObject class

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#ifndef _DATAOBJ_H
#define _DATAOBJ_H


class CDataObject;
class CDataObjectRoot;
class CDataObjectDeviceTreeByType;
class CDataObjectDeviceTreeByConnection;
class CCookie;


class CDataObject : public IDataObject
{
public:
    CDataObject() : m_Ref(1)
    {}
    ~CDataObject()
    {}

// IUnknown interface
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);

//  IDataObject interface
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc);
    virtual HRESULT Initialize(DATA_OBJECT_TYPES Type, COOKIE_TYPE ct, CCookie* pCookie, String& strMachineName);

// Not Implemented
private:
    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };


public:

// Clipboard formats that are required by the console
    static unsigned int    m_cfNodeType;
    static unsigned int    m_cfNodeTypeString;  
    static unsigned int    m_cfDisplayName;
    static unsigned int    m_cfSnapinInternal;
    static unsigned int    m_cfCoClass;
    static unsigned int    m_cfMachineName;
    static unsigned int    m_cfClassGuid;
    static unsigned int    m_cfDeviceID;
protected:
    COOKIE_TYPE        m_ct;
    CCookie*           m_pCookie;
    int            m_idsNodeName;
private:
    DATA_OBJECT_TYPES      m_Type;
    String         m_strMachineName;
    ULONG          m_Ref;
};

extern HRESULT ExtractData(IDataObject* pIDataObject, unsigned int cfClipFormat,
               BYTE* pBuffer, DWORD cbBuffer
               );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\dataobj.cpp ===
/*++

Copyright (C) 1997-2001  Microsoft Corporation

Module Name:

    dataobj.cpp

Abstract:

    header file defines CDataObject class

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "devmgr.h"
#include "DataObj.h"


unsigned int CDataObject::m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CDataObject::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);
unsigned int CDataObject::m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME);
unsigned int CDataObject::m_cfCoClass        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
unsigned int CDataObject::m_cfSnapinInternal    = RegisterClipboardFormat(SNAPIN_INTERNAL);
unsigned int CDataObject::m_cfMachineName    = RegisterClipboardFormat(MMC_SNAPIN_MACHINE_NAME);
unsigned int CDataObject::m_cfClassGuid      = RegisterClipboardFormat(DEVMGR_SNAPIN_CLASS_GUID);
unsigned int CDataObject::m_cfDeviceID       = RegisterClipboardFormat(DEVMGR_SNAPIN_DEVICE_ID);

//
// IUnknown interface implementation
//

ULONG
CDataObject::AddRef()
{
    ::InterlockedIncrement((LONG*)&m_Ref);
    return m_Ref;
}

ULONG
CDataObject::Release()
{
    ::InterlockedDecrement((LONG*)&m_Ref);
    if (!m_Ref) {
        delete this;
        return 0;
    }
    return m_Ref;
}

STDMETHODIMP
CDataObject::QueryInterface(
                           REFIID riid,
                           void** ppv
                           )
{
    if (!ppv)
        return E_INVALIDARG;
    HRESULT hr = S_OK;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = (IUnknown*)this;
    else if (IsEqualIID(riid, IID_IDataObject)) {
        *ppv = this;
    } else {
        hr = E_NOINTERFACE;
    }
    if (SUCCEEDED(hr))
        AddRef();
    else
        *ppv = NULL;
    return hr;
}

HRESULT
CDataObject::Initialize(
                       DATA_OBJECT_TYPES Type,
                       COOKIE_TYPE      ct,
                       CCookie* pCookie,
                       String& strMachineName
                       )
{
    try {
        m_strMachineName = strMachineName;
        m_pCookie = pCookie;
        m_Type = Type;
        m_ct = ct;
    } catch (CMemoryException* e) {
        e->Delete();
        return E_OUTOFMEMORY;
    }
    return S_OK;

}


STDMETHODIMP
CDataObject::GetDataHere(
                        LPFORMATETC lpFormatetc,
                        LPSTGMEDIUM lpMedium
                        )
{
    HRESULT hr = S_OK;

    try {
        const CLIPFORMAT cf = lpFormatetc->cfFormat;
        hr = DV_E_FORMATETC;
        SafeInterfacePtr<IStream> StreamPtr;

        if (TYMED_HGLOBAL == lpMedium->tymed) {
            ULONG ulWritten;
            hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &StreamPtr);

            if (S_OK == hr) {
                const NODEINFO* pni = &NodeInfo[m_ct];
                ASSERT(pni->ct == m_ct);

                if (cf == m_cfNodeType) {
                    const GUID* pGuid = &pni->Guid;
                    hr = StreamPtr->Write(pGuid, sizeof(GUID), &ulWritten);
                } else if (cf == m_cfNodeTypeString) {
                    const TCHAR *pszGuid = pni->GuidString;
                    hr = StreamPtr->Write(pszGuid,
                                          (wcslen(pszGuid) + 1) * sizeof(TCHAR),
                                          &ulWritten
                                         );
                } else if (cf == m_cfDisplayName) {
                    if (pni->idsFormat) {
                        String strDisplayName;
                        TCHAR Format[LINE_LEN];
                        TCHAR LocalMachine[LINE_LEN];
                        ::LoadString(g_hInstance, pni->idsFormat, Format, sizeof(Format)/sizeof(TCHAR));
                        LPCTSTR MachineName = m_strMachineName;

                        if (m_strMachineName.IsEmpty()) {
                            ::LoadString(g_hInstance, IDS_LOCAL_MACHINE, LocalMachine,
                                         sizeof(LocalMachine) / sizeof(TCHAR));
                            MachineName = LocalMachine;
                        }

                        strDisplayName.Format(Format, MachineName);
                        hr = StreamPtr->Write(strDisplayName,
                                              (strDisplayName.GetLength() + 1) * sizeof(TCHAR),
                                              &ulWritten
                                             );
                    }
                } else if (cf == m_cfSnapinInternal) {
                    INTERNAL_DATA tID;
                    tID.ct = m_ct;
                    tID.dot = m_Type;
                    tID.cookie = (MMC_COOKIE)m_pCookie;
                    hr = StreamPtr->Write(&tID,
                                          sizeof(INTERNAL_DATA),
                                          &ulWritten
                                         );
                } else if (cf == m_cfCoClass) {
                    hr = StreamPtr->Write(&CLSID_DEVMGR,
                                          sizeof(CLSID),
                                          &ulWritten
                                         );
                } else if (cf == m_cfMachineName) {
                    if (!m_strMachineName.IsEmpty()) {
                        hr = StreamPtr->Write((LPCTSTR)m_strMachineName,
                                              (m_strMachineName.GetLength()+1) * sizeof(TCHAR),
                                              NULL);
                    } else {
                        TCHAR Nothing[1];
                        Nothing[0] = _T('\0');
                        hr = StreamPtr->Write(Nothing, sizeof(Nothing), NULL);
                    }
                } else if (cf == m_cfClassGuid) {
                    if (COOKIE_TYPE_RESULTITEM_CLASS == m_pCookie->GetType()) {
                        CClass* pClass = (CClass*)m_pCookie->GetResultItem();
                        ASSERT(pClass);
                        LPGUID pClassGuid = *pClass;
                        hr = StreamPtr->Write(pClassGuid, sizeof(GUID), NULL);
                    }
                } else if (cf == m_cfDeviceID) {
                    if (COOKIE_TYPE_RESULTITEM_DEVICE == m_pCookie->GetType()) {
                        CDevice* pDevice = (CDevice*)m_pCookie->GetResultItem();
                        ASSERT(pDevice);
                        LPCTSTR DeviceID = pDevice->GetDeviceID();

                        hr = StreamPtr->Write(DeviceID,
                                              (wcslen(DeviceID) + 1) * sizeof(TCHAR),
                                              NULL
                                             );
                    }
                } else {
                    hr = DV_E_FORMATETC;
                }
            }
        }
    } catch (CMemoryException* e) {
        e->Delete();
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


STDMETHODIMP
CDataObject::GetData(
                    LPFORMATETC lpFormatetc,
                    LPSTGMEDIUM lpMedium
                    )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDataObject::EnumFormatEtc(
                          DWORD dwDirection,
                          LPENUMFORMATETC* ppEnumFormatEtc
                          )
{
    return E_NOTIMPL;
}




HRESULT ExtractData(
                   IDataObject* pIDataObject,
                   unsigned int cfClipFormat,
                   BYTE*    pBuffer,
                   DWORD    cbBuffer
                   )
{

    if (NULL == pIDataObject || NULL == pBuffer)
        return E_POINTER;

    HRESULT hr = S_OK;
    FORMATETC FormatEtc = {(CLIPFORMAT)cfClipFormat, NULL, DVASPECT_CONTENT, -1 , TYMED_HGLOBAL};
    STGMEDIUM StgMedium = {TYMED_HGLOBAL, NULL};

    StgMedium.hGlobal = ::GlobalAlloc(GMEM_SHARE, cbBuffer);
    if (NULL == StgMedium.hGlobal) {
        ASSERT(FALSE);
        hr = E_OUTOFMEMORY;
    } else {
        hr = pIDataObject->GetDataHere(&FormatEtc, &StgMedium);
        if (SUCCEEDED(hr)) {
            BYTE* pData = reinterpret_cast<BYTE*>(::GlobalLock(StgMedium.hGlobal));
            if (NULL == pData) {
                ASSERT(FALSE);
                hr = E_UNEXPECTED;
            } else {
                ::memcpy(pBuffer, pData, cbBuffer);
                ::GlobalUnlock(StgMedium.hGlobal);
            }
        }
        ::GlobalFree(StgMedium.hGlobal);
    }
    return hr;
}

#if 0

/////////////////////////////////////////////////////////////////////
////
/// Helper functions to extact data from the given IDataObject
///

HRESULT ExtractData(IDataObject* piDataObject,
                    unsigned int cfClipFormat,
                    BYTE*    pBuffer,
                    DWORD    cbBuffer
                   );
HRESULT ExtractString(IDataObject* piDataObject,
                      unsigned int cfClipFormat,
                      String* pstr,
                      DWORD    cchMax
                     );



HRESULT
ExtractData(
           IDataObject* piDataObject,
           unsigned int cfClipFormat,
           BYTE*    pBuffer,
           DWORD    cbBuffer
           )
{
    HRESULT hr = S_OK;
    FORMATETC Formatetc = {cfClipFormat, NULL, DVASPET_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM Stgmedium = {TYMED_HGLOBAL, NULL};
    Stgmedium.hGlobal = ::GlobalAlloc(GMEM_SHARE, cbBuffer);

    if (NULL == Stgmedium.hGlobal) {
        ASSERT(FASLE);
        AfxThrowMemoryException();
        hr = E_OUTOFMEMORY;
        return hr;
    }
    hr = piDataObject->GetDataHere(&Formatetc, &Stgmedium);
    if (FAILED(hr)) {
        ASSERT(FALSE);
        return hr;
    }
    BYTE* pData = reinterpret_cast<BYTE*>(::GlobalLock(Stgmedium.hGlobal));
    if (NULL == pData) {
        ASSERT(FALSE);
        hr = E_UNEXPECTED;
    }
    ::memcpy(pBuffer, pData, cbBuffer);
    return hr;
}

HRESULT
ExtractString(
             IDataObject* piDataObject,
             unsigned int cfClipFormat,
             String* pstr
             DWORD   cbMax
             )
{
    FORMATETC Formatetc = {cfClipFormat, NULL, DVASPET_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM Stgmedium = {TYMED_HGLOBAL, NULL};
    Stgmedium.hGlobal = ::GlobalAlloc(GMEM_SHARE, cbBuffer);

    if (NULL == Stgmedium.hGlobal) {
        ASSERT(FASLE);
        AfxThrowMemoryException();
        hr = E_OUTOFMEMORY;
        return hr;
    }
    HRESULT hr = piDataObject->GetDataHere(&Formatetc, &Stgmedium);
    if (FAILED(hr)) {
        ASSERT(FALSE);
        return hr;
    }
    LPTSTR pszData = reinterpret_cast<LPTSTR>(::GlobalLock(Stgmedium.hGlobal));
    if (NULL == pszData) {
        ASSERT(FALSE);
        return E_UNEXPECTTED;
    }
    USES_CONVERSION;
    *pstr = OLE2T(pszData);
    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\devdrvpg.h ===
// devdrvpg.h : header file
//

#ifndef __DEVDRVPG_H__
#define __DEVDRVPG_H__

/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    devdrvpg.h

Abstract:

    header file for devdrvpg.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "proppage.h"

//
// help topic ids
//
#define IDH_DISABLEHELP (DWORD(-1))
#define idh_devmgr_driver_copyright     106130  // Driver: "" (Static)
#define idh_devmgr_devdrv_details       400400  // Driver: "Driver Details..." (Button)
#define idh_devmgr_driver_change_driver 106140  // Driver: "&Change Driver..." (Button)
#define	idh_devmgr_rollback_button	    106129  // Driver: "Roll Back Driver..." (Button)
#define idh_devmgr_devdrv_uninstall     400500  // Driver: "&Uninstall" (Button)
#define idh_devmgr_driver_driver_files  106100  // Driver: "" (ListBox)
#define idh_devmgr_driver_provider      106110  // Driver: "" (Static)
#define idh_devmgr_driver_file_version  106120  // Driver: "" (Static)
#define idh_devmgr_driver_provider_main 106122  // Driver tab static
#define idh_devmgr_driver_date_main     106124  // Driver tab static
#define idh_devmgr_driver_version_main  106126  // Driver tab static
#define idh_devmgr_digital_signer       106127  // Driver tab static- digital signer



class CDeviceDriverPage : public CPropSheetPage
{
public:
    CDeviceDriverPage() :
        m_pDriver(NULL), m_pDevice(NULL), m_hwndDigitalSignerTip(NULL),
        CPropSheetPage(g_hInstance, IDD_DEVDRV_PAGE)
        {}

    ~CDeviceDriverPage();
    HPROPSHEETPAGE Create(CDevice* pDevice)
    {
        ASSERT(pDevice);
        m_pDevice = pDevice;
        
        // override PROPSHEETPAGE structure here...
        m_psp.lParam = (LPARAM)this;
        return CreatePage();
    }
    BOOL UpdateDriver(CDevice* pDevice, 
                      HWND hDlg,
                      BOOL *pfChanged = NULL,
                      DWORD *pdwReboot = NULL
                      );
    BOOL RollbackDriver(CDevice* pDevice, 
                        HWND hDlg,
                        BOOL *pfChanged = NULL,
                        DWORD *pdwReboot = NULL
                        );
    BOOL UninstallDrivers(CDevice* pDevice, 
                          HWND hDlg,
                          BOOL *pfUninstalled = NULL
                          );

protected:
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    virtual void UpdateControls(LPARAM lParam = 0);
    virtual BOOL OnHelp(LPHELPINFO pHelpInfo);
    virtual BOOL OnContextMenu(HWND hWnd, WORD xPos, WORD yPos);
    BOOL LaunchTroubleShooter(CDevice* pDevice, HWND hDlg, BOOL *pfChanged);

private:
    void InitializeDriver();
    CDriver*    m_pDriver;
    CDevice*    m_pDevice;
    HWND        m_hwndDigitalSignerTip;
};

/////////////////////////////////////////////////////////////////////////////
// CDriverFilesDlg dialog

class CDriverFilesDlg : public CDialog
{
public:
    CDriverFilesDlg(CDevice* pDevice, CDriver* pDriver)
        : CDialog(IDD_DRIVERFILES),
          m_pDriver(pDriver), 
          m_pDevice(pDevice),
          m_ImageList(NULL)
        {}
    virtual BOOL OnInitDialog();
    virtual void OnCommand(WPARAM wParam, LPARAM lParam);
    virtual BOOL OnNotify(LPNMHDR pnmhdr);
    virtual BOOL OnDestroy();
    virtual BOOL OnHelp(LPHELPINFO pHelpInfo);
    virtual BOOL OnContextMenu(HWND hWnd, WORD xPos, WORD yPos);

private:
    void ShowCurDriverFileDetail();
    void LaunchHelpForBlockedDriver();
    CDriver*    m_pDriver;
    CDevice*    m_pDevice;
    HIMAGELIST  m_ImageList;
};


#endif // _DEVDRVPG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\devdetpg.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    devdetpg.cpp

Abstract:

    This module implements CDeviceDetailsPage -- device details
    property page

Author:

    Jason Cobb (JasonC) created

Revision History:


--*/

#include "devmgr.h"
#include "devdetpg.h"
#include <wmidata.h>

extern "C" {
#include <initguid.h>
#include <wdmguid.h>
}


//
// help topic ids
//
const DWORD g_a15HelpIDs[]=
{
    IDC_DEVDETAILS_DESC,  IDH_DISABLEHELP,
    IDC_DEVDETAILS_ICON,  IDH_DISABLEHELP,
    0,0

};

BOOL
CDeviceDetailsPage::OnInitDialog(
    LPPROPSHEETPAGE ppsp
    )
{
    try {

        m_hwndDetailsList = GetDlgItem(m_hDlg, IDC_DEVDETAILS_LIST);
        
        String DetailsType;
        for (int i = DETAILS_DEVICEINSTANCEID; i < DETAILS_MAX; i++) {
    
            DetailsType.LoadString(g_hInstance, IDS_DETAILS_DEVICEINSTANCEID + i);
            SendDlgItemMessage(m_hDlg, IDC_DEVDETAILS_COMBO, CB_ADDSTRING, 0, (LPARAM)(LPTSTR)DetailsType);
        }

        SendDlgItemMessage(m_hDlg, IDC_DEVDETAILS_COMBO, CB_SETCURSEL, 0, 0);

        LV_COLUMN lvcCol;
        lvcCol.mask = LVCF_FMT | LVCF_WIDTH;
        lvcCol.fmt = LVCFMT_LEFT;
        lvcCol.iSubItem = 0;
        ListView_InsertColumn(m_hwndDetailsList, 0, &lvcCol);

        ListView_SetExtendedListViewStyle(m_hwndDetailsList, LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);

        UpdateDetailsText();
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        // report memory error
        MsgBoxParam(m_hDlg, 0, 0, 0);
    }

    return TRUE;
}

BOOL
CDeviceDetailsPage::OnCommand(
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (LOWORD(wParam)) {
    
    case IDC_DEVDETAILS_COMBO:
        if (CBN_SELCHANGE == HIWORD(wParam)) {

            UpdateDetailsText();
        }
        break;
    }

    return FALSE;
}

BOOL 
CDeviceDetailsPage::OnNotify(
    LPNMHDR pnmhdr
    )
{
    if (pnmhdr->idFrom == IDC_DEVDETAILS_LIST) {

        if (pnmhdr->code == LVN_KEYDOWN) {

            LPNMLVKEYDOWN pnmlvKeyDown = (LPNMLVKEYDOWN)pnmhdr;

            if (::GetKeyState(VK_CONTROL)) {
                
                switch (pnmlvKeyDown->wVKey) {
                
                case 'C':
                case 'c':
                case VK_INSERT:
                    CopyToClipboard();
                    break;

                case 'A':
                case 'a':
                    ListView_SetSelectionMark(m_hwndDetailsList, 0);
                    ListView_SetItemState(m_hwndDetailsList, -1, LVIS_SELECTED, LVIS_SELECTED);
                    break;
                }
            }
        }
    }

    return FALSE;
}

//
// This function refreshes every control in the dialog. It may be called
// when the dialog is being initialized
//
void
CDeviceDetailsPage::UpdateControls(
    LPARAM lParam
    )
{
    if (lParam) {

        m_pDevice = (CDevice*)lParam;
    }

    try {

        HICON hIconOld;
        m_IDCicon = IDC_DEVDETAILS_ICON;  // Save for cleanup in OnDestroy.
        hIconOld = (HICON)SendDlgItemMessage(m_hDlg, IDC_DEVDETAILS_ICON, STM_SETICON,
                                      (WPARAM)(m_pDevice->LoadClassIcon()),
                                      0
                                      );
        if (hIconOld)
        {
            DestroyIcon(hIconOld);
        }

        SetDlgItemText(m_hDlg, IDC_DEVDETAILS_DESC, m_pDevice->GetDisplayName());

    }
    catch (CMemoryException* e)
    {
        e->Delete();
        // report memory error
        MsgBoxParam(m_hDlg, 0, 0, 0);
    }
}

BOOL
CDeviceDetailsPage::OnHelp(
    LPHELPINFO pHelpInfo
    )
{
    WinHelp((HWND)pHelpInfo->hItemHandle, DEVMGR_HELP_FILE_NAME, HELP_WM_HELP,
            (ULONG_PTR)g_a15HelpIDs);
    return FALSE;
}


BOOL
CDeviceDetailsPage::OnContextMenu(
    HWND hWnd,
    WORD xPos,
    WORD yPos
    )
{
    WinHelp(hWnd, DEVMGR_HELP_FILE_NAME, HELP_CONTEXTMENU,
            (ULONG_PTR)g_a15HelpIDs);
    return FALSE;
}

void
CDeviceDetailsPage::UpdateDetailsText()
{
    int CurSel = (int)SendDlgItemMessage(m_hDlg, IDC_DEVDETAILS_COMBO, CB_GETCURSEL, 0, 0);

    if (CurSel != CB_ERR) {

        ListView_DeleteAllItems(m_hwndDetailsList);
        
        switch(CurSel) {
        case DETAILS_DEVICEINSTANCEID:
            LVITEM lv;
            ZeroMemory(&lv, sizeof(LVITEM));
            lv.mask = LVIF_TEXT;
            lv.pszText = (LPTSTR)m_pDevice->GetDeviceID();
            ListView_InsertItem(m_hwndDetailsList, &lv);
            break;

        case DETAILS_HARDWAREIDS:
            DisplayMultiSzString(SPDRP_HARDWAREID);
            break;

        case DETAILS_COMPATIDS:
            DisplayMultiSzString(SPDRP_COMPATIBLEIDS);
            break;

        case DETAILS_DEVICEUPPERFILTERS:
            DisplayMultiSzString(SPDRP_UPPERFILTERS);
            break;

        case DETAILS_DEVICELOWERFILTERS:
            DisplayMultiSzString(SPDRP_LOWERFILTERS);
            break;

        case DETAILS_CLASSUPPERFILTERS:
        case DETAILS_CLASSLOWERFILTERS:
            DisplayClassFilters(CurSel);
            break;

        case DETAILS_ENUMERATOR:
            DisplayString(SPDRP_ENUMERATOR_NAME);
            break;

        case DETAILS_SERVICE:
            DisplayString(SPDRP_SERVICE);
            break;

        case DETAILS_DEVNODE_FLAGS:
        case DETAILS_CAPABILITIES:
        case DETAILS_CONFIGFLAGS:
        case DETAILS_CSCONFIGFLAGS:
        case DETAILS_POWERCAPABILITIES:
            DisplayDevnodeFlags(CurSel);
            break;

        case DETAILS_EJECTIONRELATIONS:
        case DETAILS_REMOVALRELATIONS:
        case DETAILS_BUSRELATIONS:
            DisplayRelations(CurSel);
            break;

        case DETAILS_MATCHINGID:
            DisplayMatchingId();
            break;

        case DETAILS_CLASSINSTALLER:
            DisplayClassInstaller();
            break;
        
        case DETAILS_CLASSCOINSTALLERS:
            DisplayClassCoInstallers();
            break;

        case DETAILS_DEVICECOINSTALLERS:
            DisplayDeviceCoInstallers();
            break;

        case DETAILS_FIRMWAREREVISION:
            DisplayFirmwareRevision();
            break;

        case DETAILS_CURRENTPOWERSTATE:
            DisplayCurrentPowerState();
            break;

        case DETAILS_POWERSTATEMAPPINGS:
            DisplayPowerStateMappings();
            break;
        }

        ListView_SetColumnWidth(m_hwndDetailsList, 0, LVSCW_AUTOSIZE_USEHEADER);
    }
}

void
CDeviceDetailsPage::DisplayMultiSzString(
    DWORD Property
    )
{
    TCHAR TempBuffer[REGSTR_VAL_MAX_HCID_LEN];
    ULONG TempBufferLen;
    LPTSTR SingleItem = NULL;
    LVITEM lv;

    TempBufferLen = sizeof(TempBuffer);

    if (m_pDevice->m_pMachine->DiGetDeviceRegistryProperty(
            *m_pDevice, 
            Property,
            NULL, 
            (PBYTE)TempBuffer,
            TempBufferLen, 
            &TempBufferLen
            ) &&
        (TempBufferLen > 2 * sizeof(TCHAR))) {

        ZeroMemory(&lv, sizeof(LVITEM));
        lv.mask = LVIF_TEXT;
        lv.iItem = 0;

        for (SingleItem = TempBuffer; *SingleItem; SingleItem += (lstrlen(SingleItem) + 1)) {

            lv.pszText = SingleItem;
            ListView_InsertItem(m_hwndDetailsList, &lv);

            lv.iItem++;
        }
    }
}

void
CDeviceDetailsPage::DisplayString(
    DWORD Property
    )
{
    TCHAR TempBuffer[MAX_PATH];
    ULONG TempBufferLen;
    LVITEM lv;

    TempBufferLen = sizeof(TempBuffer);

    if (m_pDevice->m_pMachine->DiGetDeviceRegistryProperty(
            *m_pDevice, 
            Property,
            NULL, 
            (PBYTE)TempBuffer,
            TempBufferLen, 
            &TempBufferLen
            ) &&
        (TempBufferLen > 2 * sizeof(TCHAR))) {

        ZeroMemory(&lv, sizeof(LVITEM));
        lv.mask = LVIF_TEXT;
        lv.iItem = 0;
        lv.pszText = TempBuffer;
        ListView_InsertItem(m_hwndDetailsList, &lv);
    }
}

void
CDeviceDetailsPage::DisplayDevnodeFlags(
    DWORD StatusType
    )
{
    DWORD Flags, Problem;
    LVITEM lv;
    UINT StatusStringId;
    int NumFlags;
    String stringDevnodeFlags;

    ZeroMemory(&lv, sizeof(LVITEM));
    lv.mask = LVIF_TEXT;
    lv.iItem = 0;

    Flags = NumFlags = 0;

    switch(StatusType) {
    case DETAILS_CAPABILITIES:
        m_pDevice->GetCapabilities(&Flags);
        StatusStringId = IDS_CM_DEVCAP_LOCKSUPPORTED;
        NumFlags = NUM_CM_DEVCAP_FLAGS;
        break;

    case DETAILS_DEVNODE_FLAGS:
        m_pDevice->GetStatus(&Flags, &Problem);
        StatusStringId = IDS_DN_ROOT_ENUMERATED;
        NumFlags = NUM_DN_STATUS_FLAGS;
        break;

    case DETAILS_CONFIGFLAGS:
        m_pDevice->GetConfigFlags(&Flags);
        StatusStringId = IDS_CONFIGFLAG_DISABLED;
        NumFlags = NUM_CONFIGFLAGS;
        break;

    case DETAILS_CSCONFIGFLAGS:
        m_pDevice->GetConfigSpecificConfigFlags(&Flags);
        StatusStringId = IDS_CSCONFIGFLAG_DISABLED;
        NumFlags = NUM_CSCONFIGFLAGS;
        break;

    case DETAILS_POWERCAPABILITIES:
        m_pDevice->GetPowerCapabilities(&Flags);
        StatusStringId = IDS_PDCAP_D0_SUPPORTED;
        NumFlags = NUM_POWERCAPABILITIES;
        break;
    }

    for (int i = 0; i < NumFlags; i++) {

        if (Flags & 1<<i) {

            stringDevnodeFlags.LoadString(g_hInstance, StatusStringId + i);
            lv.pszText = (LPTSTR)stringDevnodeFlags;
            ListView_InsertItem(m_hwndDetailsList, &lv);

            lv.iItem++;
        }
    }
}

void
CDeviceDetailsPage::DisplayRelations(
    DWORD RelationType
    )
{
    DWORD FilterFlags = 0;
    ULONG RelationsSize = 0;
    LVITEM lv;
    LPTSTR DeviceIdRelations, CurrDevId;

    switch(RelationType) {
    case DETAILS_EJECTIONRELATIONS:
        FilterFlags = CM_GETIDLIST_FILTER_EJECTRELATIONS;
        break;
    case DETAILS_REMOVALRELATIONS:
        FilterFlags = CM_GETIDLIST_FILTER_REMOVALRELATIONS;
        break;
    case DETAILS_BUSRELATIONS:
        FilterFlags = CM_GETIDLIST_FILTER_BUSRELATIONS;
        break;
    }
    
    if ((CM_Get_Device_ID_List_Size_Ex(&RelationsSize,
                                       m_pDevice->GetDeviceID(),
                                       FilterFlags,
                                       m_pDevice->m_pMachine->GetHMachine()
                                       ) == CR_SUCCESS) && 
        (RelationsSize > 2 * sizeof(TCHAR))) {

        if (DeviceIdRelations = (LPTSTR)LocalAlloc(LPTR, RelationsSize * sizeof(TCHAR))) {

            
            if ((CM_Get_Device_ID_List_Ex(m_pDevice->GetDeviceID(),
                                          DeviceIdRelations,
                                          RelationsSize,
                                          FilterFlags,
                                          m_pDevice->m_pMachine->GetHMachine()
                                          ) == CR_SUCCESS) &&
            (*DeviceIdRelations)) {

                ZeroMemory(&lv, sizeof(LVITEM));
                lv.mask = LVIF_TEXT;
                lv.iItem = 0;

                for (CurrDevId = DeviceIdRelations; *CurrDevId; CurrDevId += lstrlen(CurrDevId) + 1) {
                
                    lv.pszText = CurrDevId;
                    ListView_InsertItem(m_hwndDetailsList, &lv);

                    lv.iItem++;
                }
            }

            LocalFree(DeviceIdRelations);
        }
    }
}

void
CDeviceDetailsPage::DisplayMatchingId(
    VOID
    )
{
    HKEY hKey;    
    TCHAR TempBuffer[MAX_PATH];
    ULONG TempBufferLen;
    DWORD regType;
    LVITEM lv;

    //
    // Open drvice's driver registry key to get the MatchingDeviceId string
    //
    hKey = m_pDevice->m_pMachine->DiOpenDevRegKey(*m_pDevice, DICS_FLAG_GLOBAL,
                 0, DIREG_DRV, KEY_READ);

    if (INVALID_HANDLE_VALUE != hKey) {

        CSafeRegistry regDrv(hKey);
        TempBufferLen = sizeof(TempBuffer);

        //
        // Get the MatchingDeviceId from the driver key
        //
        if (regDrv.GetValue(REGSTR_VAL_MATCHINGDEVID, 
                            &regType,
                            (PBYTE)TempBuffer,
                            &TempBufferLen) &&
            (TempBufferLen > 2 * sizeof(TCHAR))) {

            ZeroMemory(&lv, sizeof(LVITEM));
            lv.mask = LVIF_TEXT;
            lv.iItem = 0;
            lv.pszText = TempBuffer;
            ListView_InsertItem(m_hwndDetailsList, &lv);
        }
    }
}

void
CDeviceDetailsPage::CopyToClipboard(
    void
    )
{
    String stringClipboardData;
    TCHAR singleItem[REGSTR_VAL_MAX_HCID_LEN];

    stringClipboardData.Empty();

    //
    // Enumerate through all of the items and add the selected ones to the clipboard.
    //
    for (int index = 0;
         index != -1, index < ListView_GetItemCount(m_hwndDetailsList);
         index ++) {
    
        //
        // If this item is selected then add it to the clipboard.
        //
        if (ListView_GetItemState(m_hwndDetailsList, index, LVIS_SELECTED) & LVIS_SELECTED) {

            ListView_GetItemText(m_hwndDetailsList, index, 0, singleItem, sizeof(singleItem));
            
            if (stringClipboardData.IsEmpty()) {
                stringClipboardData = (LPCTSTR)singleItem;
            } else {
                stringClipboardData += (LPCTSTR)singleItem;
            }
    
            stringClipboardData += (LPCTSTR)TEXT("\r\n");
        }
    }

    if (!stringClipboardData.IsEmpty()) {

        HGLOBAL hMem = GlobalAlloc(GPTR, (stringClipboardData.GetLength() + 1) * sizeof(TCHAR));
        
        if (hMem) {
            
            memcpy(hMem, (LPTSTR)stringClipboardData, (stringClipboardData.GetLength() + 1) * sizeof(TCHAR));

            if (OpenClipboard(m_hDlg)) {
                
                EmptyClipboard();
                SetClipboardData(CF_UNICODETEXT, hMem);
                CloseClipboard();
            } else {
                
                GlobalFree(hMem);
            }
        }
    }
}

void
CDeviceDetailsPage::DisplayClassInstaller(
    VOID
    )
{
    HKEY hKey;    
    TCHAR TempBuffer[MAX_PATH];
    ULONG TempBufferLen;
    DWORD regType;
    LVITEM lv;
    PTSTR StringPtr;

    GUID ClassGuid;
    m_pDevice->ClassGuid(ClassGuid);

    //
    // Open Classes registry key
    //
    hKey = m_pDevice->m_pMachine->DiOpenClassRegKey(&ClassGuid, KEY_READ, DIOCR_INSTALLER);

    if (INVALID_HANDLE_VALUE != hKey) {

        CSafeRegistry regClass(hKey);
        TempBufferLen = sizeof(TempBuffer);

        //
        // Get the Installer32 from the driver key
        //
        if (regClass.GetValue(REGSTR_VAL_INSTALLER_32, 
                            &regType,
                            (PBYTE)TempBuffer,
                            &TempBufferLen) &&
            (TempBufferLen > 2 * sizeof(TCHAR))) {

            ZeroMemory(&lv, sizeof(LVITEM));
            lv.mask = LVIF_TEXT;
            lv.iItem = 0;
            lv.pszText = TempBuffer;
            ListView_InsertItem(m_hwndDetailsList, &lv);
        }
    }
}

void
CDeviceDetailsPage::DisplayClassCoInstallers(
    VOID
    )
{
    TCHAR GuidString[MAX_GUID_STRING_LEN];
    DWORD regType, cbSize;
    LVITEM lv;
    CSafeRegistry regCoDeviceInstallers;
    PTSTR coinstallers;

    //
    // Get the string form of the class GUID, because that will be the name of
    // the multi-sz value entry under HKLM\System\CCS\Control\CoDeviceInstallers
    // where class-specific co-installers will be registered
    //
    GUID ClassGuid;
    m_pDevice->ClassGuid(ClassGuid);
    if (GuidToString(&ClassGuid, GuidString, ARRAYLEN(GuidString))) {

        if (regCoDeviceInstallers.Open(HKEY_LOCAL_MACHINE, REGSTR_PATH_CODEVICEINSTALLERS)) {

            //
            // Get the size of the coinstaller value
            //
            cbSize = 0;
            if (regCoDeviceInstallers.GetValue(GuidString, &regType, NULL, &cbSize) &&
                (cbSize > (2 * sizeof(TCHAR))) &&
                (regType == REG_MULTI_SZ)) {

                //
                // Allocate memory to hold the coinstaller values.  First we will tack on some extra
                // space at the end of the buffer in case someone forgot to double NULL terminate
                // the multi_sz string.
                //
                coinstallers = (LPTSTR)LocalAlloc(LPTR, (cbSize + (2 * sizeof(TCHAR))));

                if (coinstallers) {

                    if (regCoDeviceInstallers.GetValue(GuidString, 
                                                       &regType,
                                                       (PBYTE)coinstallers, 
                                                       &cbSize
                                                       )) {

                        ZeroMemory(&lv, sizeof(LVITEM));
                        lv.mask = LVIF_TEXT;
                        lv.iItem = 0;

                        for (PTSTR p = coinstallers; *p; p += (lstrlen(p) + 1)) {

                            lv.pszText = p;
                            ListView_InsertItem(m_hwndDetailsList, &lv);

                            lv.iItem++;
                        }
                    }

                    LocalFree(coinstallers);
                }
            }
        }
    }
}

void
CDeviceDetailsPage::DisplayDeviceCoInstallers(
    VOID
    )
{
    DWORD regType, cbSize;
    LVITEM lv;
    HKEY hKey;
    PTSTR coinstallers;

    //
    // Open drvice's driver registry key to get the Installer32 string
    //
    hKey = m_pDevice->m_pMachine->DiOpenDevRegKey(*m_pDevice, DICS_FLAG_GLOBAL,
                 0, DIREG_DRV, KEY_READ);

    if (INVALID_HANDLE_VALUE != hKey) {

        CSafeRegistry regCoDeviceInstallers(hKey);
    
        //
        // Get the size of the coinstaller value
        //
        cbSize = 0;
        if (regCoDeviceInstallers.GetValue(REGSTR_VAL_COINSTALLERS_32, &regType, NULL, &cbSize) &&
            (cbSize > (2 * sizeof(TCHAR))) &&
            (regType == REG_MULTI_SZ)) {

            //
            // Allocate memory to hold the coinstaller values.  First we will tack on some extra
            // space at the end of the buffer in case someone forgot to double NULL terminate
            // the multi_sz string.
            //
            coinstallers = (LPTSTR)LocalAlloc(LPTR, (cbSize + (2 * sizeof(TCHAR))));

            if (coinstallers) {

                if (regCoDeviceInstallers.GetValue(REGSTR_VAL_COINSTALLERS_32, 
                                                   &regType,
                                                   (PBYTE)coinstallers, 
                                                   &cbSize
                                                   )) {

                    ZeroMemory(&lv, sizeof(LVITEM));
                    lv.mask = LVIF_TEXT;
                    lv.iItem = 0;

                    for (PTSTR p = coinstallers; *p; p += (lstrlen(p) + 1)) {

                        lv.pszText = p;
                        ListView_InsertItem(m_hwndDetailsList, &lv);

                        lv.iItem++;
                    }
                }

                LocalFree(coinstallers);
            }
        }
    }
}

void
CDeviceDetailsPage::DisplayFirmwareRevision(
    VOID
    )
{
    WMIHANDLE   hWmiBlock;
    TCHAR       DevInstId[MAX_DEVICE_ID_LEN + 2];
    LVITEM lv;

    WmiDevInstToInstanceName(DevInstId, ARRAYLEN(DevInstId), (PTCHAR)m_pDevice->GetDeviceID(), 0);

    ULONG Error;
    GUID Guid = DEVICE_UI_FIRMWARE_REVISION_GUID;
    Error = WmiOpenBlock(&Guid, 0, &hWmiBlock);
    
    if (ERROR_SUCCESS == Error) {

        ULONG BufferSize = 0;
        
        Error = WmiQuerySingleInstance(hWmiBlock,
                                       DevInstId,
                                       &BufferSize,
                                       NULL
                                       );

        if (BufferSize && (ERROR_INSUFFICIENT_BUFFER == Error)) {
            
            BYTE* pWmiInstData = new BYTE[BufferSize];

            if (pWmiInstData) {
            
                Error = WmiQuerySingleInstance(hWmiBlock, 
                                               DevInstId,
                                               &BufferSize, 
                                               pWmiInstData
                                               );

                if (ERROR_SUCCESS == Error &&
                    ((PWNODE_SINGLE_INSTANCE)pWmiInstData)->SizeDataBlock) {
    
                    //
                    // The buffer that is returned using the fine UNICODE_STRING format
                    // where the first ULONG is the length of the string and the string
                    // is NOT NULL terminated.
                    //
                    TCHAR FirmwareRevision[MAX_PATH];
                    PTCHAR WmiBuffer = ((LPTSTR)(pWmiInstData + ((PWNODE_SINGLE_INSTANCE)pWmiInstData)->DataBlockOffset));

                    ZeroMemory(FirmwareRevision, MAX_PATH);
                    ULONG Len = *WmiBuffer++;
                    memcpy(FirmwareRevision, WmiBuffer, Len);


                    ZeroMemory(&lv, sizeof(LVITEM));
                    lv.mask = LVIF_TEXT;
                    lv.iItem = 0;
                    lv.pszText = FirmwareRevision;
                    ListView_InsertItem(m_hwndDetailsList, &lv);
                }

                delete [] pWmiInstData;
            }
        }

        WmiCloseBlock(hWmiBlock);
    }
}

void
CDeviceDetailsPage::DisplayCurrentPowerState(
    VOID
    )
{
    CM_POWER_DATA   CmPowerData;
    ULONG ulSize;
    INT PowerStringId;
    LVITEM lv;
    String stringCurrentPowerState;

    ulSize = sizeof(CmPowerData);
    if (m_pDevice->m_pMachine->CmGetRegistryProperty(m_pDevice->GetDevNode(),
                                                     CM_DRP_DEVICE_POWER_DATA,
                                                     &CmPowerData,
                                                     &ulSize
                                                     ) == CR_SUCCESS) {

        PowerStringId = IDS_POWERSTATE_UNSPECIFIED + CmPowerData.PD_MostRecentPowerState;

        if (CmPowerData.PD_MostRecentPowerState > PowerDeviceD3) {
            PowerStringId = IDS_POWERSTATE_UNSPECIFIED;
        }

        stringCurrentPowerState.LoadString(g_hInstance, PowerStringId);

        ZeroMemory(&lv, sizeof(LVITEM));
        lv.mask = LVIF_TEXT;
        lv.iItem = 0;
        lv.pszText = (LPTSTR)stringCurrentPowerState;
        ListView_InsertItem(m_hwndDetailsList, &lv);
    }
}

void
CDeviceDetailsPage::DisplayPowerStateMappings(
    VOID
    )
{
    CM_POWER_DATA   CmPowerData;
    ULONG ulSize;
    LVITEM lv;
    INT PowerStringId;
    String stringPowerStateMapping;
    String stringPowerState;

    ulSize = sizeof(CmPowerData);
    if (m_pDevice->m_pMachine->CmGetRegistryProperty(m_pDevice->GetDevNode(),
                                                     CM_DRP_DEVICE_POWER_DATA,
                                                     &CmPowerData,
                                                     &ulSize
                                                     ) == CR_SUCCESS) {
        for (int i=PowerSystemWorking; i<=PowerSystemShutdown; i++) {
            stringPowerStateMapping.Format(TEXT("S%d -> "), (i-1));

            PowerStringId = IDS_POWERSTATE_UNSPECIFIED + CmPowerData.PD_PowerStateMapping[i];

            if (CmPowerData.PD_PowerStateMapping[i] > PowerDeviceD3) {
                PowerStringId = IDS_POWERSTATE_UNSPECIFIED;
            }

            stringPowerState.LoadString(g_hInstance, PowerStringId);

            stringPowerStateMapping+=stringPowerState;

            ZeroMemory(&lv, sizeof(LVITEM));
            lv.mask = LVIF_TEXT;
            lv.iItem = ListView_GetItemCount(m_hwndDetailsList);
            lv.pszText = (LPTSTR)stringPowerStateMapping;
            ListView_InsertItem(m_hwndDetailsList, &lv);
        }
    }
}

void
CDeviceDetailsPage::DisplayClassFilters(
    DWORD ClassFilter
    )
{
    HKEY hKey;    
    ULONG BufferLen;
    DWORD regType;
    LVITEM lv;

    GUID ClassGuid;
    m_pDevice->ClassGuid(ClassGuid);

    //
    // Open Classes registry key
    //
    hKey = m_pDevice->m_pMachine->DiOpenClassRegKey(&ClassGuid, KEY_READ, DIOCR_INSTALLER);

    if (INVALID_HANDLE_VALUE != hKey) {

        CSafeRegistry regClass(hKey);

        //
        // Determine how much space we need.
        //
        BufferLen = 0;
        regClass.GetValue((ClassFilter == DETAILS_CLASSLOWERFILTERS)
                            ? REGSTR_VAL_LOWERFILTERS
                            : REGSTR_VAL_UPPERFILTERS, 
                          &regType,
                          NULL,
                          &BufferLen);

        if (BufferLen != 0) {

            PBYTE Buffer = new BYTE[BufferLen + (2 * sizeof(TCHAR))];            

            if (Buffer) {
                ZeroMemory(Buffer, BufferLen + (2 * sizeof(TCHAR)));

                if (regClass.GetValue((ClassFilter == DETAILS_CLASSLOWERFILTERS)
                                        ? REGSTR_VAL_LOWERFILTERS
                                        : REGSTR_VAL_UPPERFILTERS,
                                      &regType,
                                      (PBYTE)Buffer,
                                      &BufferLen)) {

                    ZeroMemory(&lv, sizeof(LVITEM));
                    lv.mask = LVIF_TEXT;
                    lv.iItem = 0;

                    for (PTSTR SingleItem = (PTSTR)Buffer; *SingleItem; SingleItem += (lstrlen(SingleItem) + 1)) {

                        lv.pszText = SingleItem;
                        ListView_InsertItem(m_hwndDetailsList, &lv);

                        lv.iItem++;
                    }
                }

                delete Buffer;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\devdetpg.h ===
// devdetpg.h : header file
//

#ifndef __DEVDETPG_H__
#define __DEVDETPG_H__

/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    devdetpg.h

Abstract:

    header file for devdetpg.cpp

Author:

    Jason Cobb (JasonC) created

Revision History:


--*/

#include "proppage.h"
#include "wmium.h"
#include "wdmguid.h"


//
// help topic ids
//
#define IDH_DISABLEHELP (DWORD(-1))

#define NUM_DN_STATUS_FLAGS     32
#define NUM_CM_DEVCAP_FLAGS     10
#define NUM_CONFIGFLAGS         14
#define NUM_CSCONFIGFLAGS       3
#define NUM_POWERCAPABILITIES   9

typedef enum tagDetailsTypes {
 
    DETAILS_DEVICEINSTANCEID = 0,
    DETAILS_HARDWAREIDS,
    DETAILS_COMPATIDS,           
    DETAILS_MATCHINGID,          
    DETAILS_SERVICE,             
    DETAILS_ENUMERATOR,          
    DETAILS_CAPABILITIES,        
    DETAILS_DEVNODE_FLAGS,       
    DETAILS_CONFIGFLAGS,         
    DETAILS_CSCONFIGFLAGS,       
    DETAILS_EJECTIONRELATIONS,   
    DETAILS_REMOVALRELATIONS,    
    DETAILS_BUSRELATIONS,        
    DETAILS_DEVICEUPPERFILTERS,        
    DETAILS_DEVICELOWERFILTERS,
    DETAILS_CLASSUPPERFILTERS,        
    DETAILS_CLASSLOWERFILTERS,
    DETAILS_CLASSINSTALLER,
    DETAILS_CLASSCOINSTALLERS,
    DETAILS_DEVICECOINSTALLERS,
    DETAILS_FIRMWAREREVISION,
    DETAILS_CURRENTPOWERSTATE,
    DETAILS_POWERCAPABILITIES,
    DETAILS_POWERSTATEMAPPINGS,
    DETAILS_MAX,

} DETAILSTYPES, *PDETAILSTYPES;

class CDeviceDetailsPage : public CPropSheetPage
{
public:
    CDeviceDetailsPage() :
        m_pDevice(NULL),
        m_hwndDetailsList(NULL),
        CPropSheetPage(g_hInstance, IDD_DEVDETAILS_PAGE)
        {}
    ~CDeviceDetailsPage()
        {}
    HPROPSHEETPAGE Create(CDevice* pDevice)
    {
        ASSERT(pDevice);
        m_pDevice = pDevice;
        m_psp.lParam = (LPARAM)this;
        return CreatePage();
    }

protected:
    virtual BOOL OnInitDialog(LPPROPSHEETPAGE ppsp);
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    virtual BOOL OnNotify(LPNMHDR pnmhdr);
    virtual void UpdateControls(LPARAM lParam = 0);
    virtual BOOL OnHelp(LPHELPINFO pHelpInfo);
    virtual BOOL OnContextMenu(HWND hWnd, WORD xPos, WORD yPos);
private:
    void UpdateDetailsText();
    void DisplayMultiSzString(DWORD Property);
    void DisplayString(DWORD Property);
    void DisplayDevnodeFlags(DWORD StatusType);
    void DisplayRelations(DWORD RelationType);
    void DisplayMatchingId();
    void DisplayClassInstaller();
    void DisplayClassCoInstallers();
    void DisplayDeviceCoInstallers();
    void DisplayFirmwareRevision();
    void DisplayCurrentPowerState();
    void DisplayPowerStateMappings();
    void DisplayClassFilters(DWORD ClassFilter);
    void CopyToClipboard();
    CDevice*    m_pDevice;
    HWND        m_hwndDetailsList;
};

#endif // _DEVDETPG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\devdrvpg.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    devdrvpg.cpp

Abstract:

    This module implements CDeviceDriverPage -- device driver property page

Author:

    William Hsieh (williamh) created

Revision History:


--*/
// devdrvpg.cpp : implementation file
//

#include "devmgr.h"
#include "devdrvpg.h"
#include "cdriver.h"
#include "tswizard.h"
#include "devrmdlg.h"

//
// help topic ids
//
// BUGBUG: JasonC 3/23/2000
// Add context help for driver rollback button.
//
const DWORD g_a106HelpIDs[]=
{
    IDC_DEVDRV_ICON,                    IDH_DISABLEHELP,                    // Driver: "" (Static)
    IDC_DEVDRV_DESC,                    IDH_DISABLEHELP,                    // Driver: "" (Static)
    IDC_DEVDRV_TITLE_DRIVERPROVIDER,    idh_devmgr_driver_provider_main,
    IDC_DEVDRV_DRIVERPROVIDER,          idh_devmgr_driver_provider_main,
    IDC_DEVDRV_TITLE_DRIVERDATE,        idh_devmgr_driver_date_main,
    IDC_DEVDRV_DRIVERDATE,              idh_devmgr_driver_date_main,
    IDC_DEVDRV_TITLE_DRIVERVERSION,     idh_devmgr_driver_version_main,
    IDC_DEVDRV_DRIVERVERSION,           idh_devmgr_driver_version_main,
    IDC_DEVDRV_TITLE_DRIVERSIGNER,      idh_devmgr_digital_signer,
    IDC_DEVDRV_DRIVERSIGNER,            idh_devmgr_digital_signer,
    IDC_DEVDRV_DETAILS,                 idh_devmgr_devdrv_details,          // Driver: "Driver Details" (Button)
    IDC_DEVDRV_DETAILS_TEXT,            idh_devmgr_devdrv_details,          // Driver: "Driver Details" (Button)
    IDC_DEVDRV_UNINSTALL,               idh_devmgr_devdrv_uninstall,        // Driver: "Uninstall" (Button)
    IDC_DEVDRV_UNINSTALL_TEXT,          idh_devmgr_devdrv_uninstall,        // Driver: "Uninstall" (Button)
    IDC_DEVDRV_CHANGEDRIVER,            idh_devmgr_driver_change_driver,    // Driver: "&Change Driver..." (Button)
    IDC_DEVDRV_CHANGEDRIVER_TEXT,       idh_devmgr_driver_change_driver,    // Driver: "&Change Driver..." (Button)
    IDC_DEVDRV_ROLLBACK,                idh_devmgr_rollback_button,         // Driver: "Roll Back Driver..." (Button)
    IDC_DEVDRV_ROLLBACK_TEXT,           idh_devmgr_rollback_button,         // Driver: "Roll Back Driver..." (Button)
    0, 0
};

CDeviceDriverPage::~CDeviceDriverPage()
{
    if (m_pDriver) {

        delete m_pDriver;
    }
}

BOOL
CDeviceDriverPage::OnCommand(
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (BN_CLICKED == HIWORD(wParam)) {

        switch (LOWORD(wParam)) {

            case IDC_DEVDRV_DETAILS:
            {
                //
                // We first need to call CDriver::BuildDriverList to build up a list
                // of drivers for this device.  This can take some time so we will put
                // up the busy cursor.
                //
                HCURSOR hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

                CDriver* pDriver;
                pDriver = m_pDevice->CreateDriver();

                if (pDriver) {
                
                    pDriver->BuildDriverList(NULL);
    
                    SetCursor(hCursorOld);
    
                    //
                    // Show driver file details
                    //
                    if (pDriver->GetCount() > 0) {
                    
    
                        if (pDriver) {
                        
                            CDriverFilesDlg DriverFilesDlg(m_pDevice, pDriver);
                            DriverFilesDlg.DoModal(m_hDlg, (LPARAM)&DriverFilesDlg);
                        }
    
                    } else {
    
                        //
                        // No driver files are loaded for this device
                        //
                        String strNoDrivers;
                        strNoDrivers.LoadString(g_hInstance, IDS_DEVDRV_NODRIVERFILE);
                        MessageBox(m_hDlg, strNoDrivers, m_pDevice->GetDisplayName(), MB_OK);
                        return FALSE;
                    }

                    delete pDriver;
                    pDriver = NULL;
                }
    
                break;
            }


            case IDC_DEVDRV_UNINSTALL:
            {
                BOOL fChanged;
                BOOL Refresh = (m_pDevice->IsPhantom() || 
                                m_pDevice->HasProblem() ||
                                !m_pDevice->IsStarted());

                if (UninstallDrivers(m_pDevice, m_hDlg, &fChanged) && fChanged) {

                    //
                    // Enable refresh since we disabled it in the beginning.
                    //
                    // We only need to force a refresh here if the device that
                    // was removed was a Phantom device.  This is because Phantom
                    // devices don't have kernel mode devnodes and so they won't
                    // generate a WM_DEVICECHANGE like live devnodes will.
                    //
                    if (Refresh) {

                        m_pDevice->m_pMachine->ScheduleRefresh();
                    }

                    ::DestroyWindow(GetParent(m_hDlg));
                }

                break;
            }

            case IDC_DEVDRV_CHANGEDRIVER:
            {
                BOOL fChanged;
                DWORD Reboot = 0;

                if (UpdateDriver(m_pDevice, m_hDlg, &fChanged, &Reboot) && fChanged) {

                    //
                    // ISSUE: JasonC 2/7/00
                    //
                    // A refresh on m_pDevice->m_pMachine is necessary here.
                    // Since we are running on a different thread and each
                    // property page may have cached the HDEVINFO and the
                    // SP_DEVINFO_DATA, refresh on the CMachine object can not
                    // be done here. The problem is worsen by the fact that
                    // user can go back to the device tree and work on the tree
                    // while this property sheet is still up.
                    // It would be nice if MMC would support modal dialog boxes! 
                    //
                    m_pDevice->PropertyChanged();
                    m_pDevice->GetClass()->PropertyChanged();
                    m_pDevice->m_pMachine->DiTurnOnDiFlags(*m_pDevice, DI_PROPERTIES_CHANGE);
                    UpdateControls();
                    PropSheet_SetTitle(GetParent(m_hDlg), PSH_PROPTITLE, m_pDevice->GetDisplayName());
                    PropSheet_CancelToClose(GetParent(m_hDlg));

                    if (Reboot & (DI_NEEDRESTART | DI_NEEDREBOOT)) {
                    
                        m_pDevice->m_pMachine->DiTurnOnDiFlags(*m_pDevice, DI_NEEDREBOOT);
                    }
                }

                break;
            }

        case IDC_DEVDRV_ROLLBACK:
        {
            BOOL fChanged;
            DWORD Reboot = 0;

            if (RollbackDriver(m_pDevice, m_hDlg, &fChanged, &Reboot) && fChanged) {

                //
                // ISSUE: JasonC 2/7/00
                //
                // A refresh on m_pDevice->m_pMachine is necessary here.
                // Since we are running on a different thread and each
                // property page may have cached the HDEVINFO and the
                // SP_DEVINFO_DATA, refresh on the CMachine object can not
                // be done here. The problem is worsen by the fact that
                // user can go back to the device tree and work on the tree
                // while this property sheet is still up.
                // It would be nice if MMC would support modal dialog boxes! 
                //
                m_pDevice->PropertyChanged();
                m_pDevice->GetClass()->PropertyChanged();
                m_pDevice->m_pMachine->DiTurnOnDiFlags(*m_pDevice, DI_PROPERTIES_CHANGE);
                UpdateControls();
                PropSheet_SetTitle(GetParent(m_hDlg), PSH_PROPTITLE, m_pDevice->GetDisplayName());
                PropSheet_CancelToClose(GetParent(m_hDlg));

                if (Reboot & (DI_NEEDRESTART | DI_NEEDREBOOT)) {

                    m_pDevice->m_pMachine->DiTurnOnDiFlags(*m_pDevice, DI_NEEDREBOOT);
                }
            }

            break;
        }

            default:
                break;
        }
    }

    return FALSE;
}

//
// This function uninstalls the drivers for the given device
// INPUT:
//  pDevice -- the object represent the device
//  hDlg    -- the property page window handle
//  pfChanged   -- optional buffer to receive if drivers
//                 were uninstalled.
// OUTPUT:
//  TRUE    -- function succeeded.
//  FALSE   -- function failed.
//
BOOL
CDeviceDriverPage::UninstallDrivers(
    CDevice* pDevice,
    HWND hDlg,
    BOOL *pfUninstalled
    )
{
    BOOL Return = FALSE;
    int MsgBoxResult;
    TCHAR szText[MAX_PATH];
    CMachine *pMachine;

    if (pDevice->m_pMachine->m_ParentMachine) {
        pMachine = pDevice->m_pMachine->m_ParentMachine;
    } else {
        pMachine = pDevice->m_pMachine;
    }

    if(!pDevice->m_pMachine->IsLocal() || !g_HasLoadDriverNamePrivilege) {
        //
        // Must be an admin and on the local machine to remove a device.
        //
        return FALSE;
    }

    BOOL Refresh = (pDevice->IsPhantom() || 
                    pDevice->HasProblem() || 
                    !pDevice->IsStarted());

    pMachine->EnableRefresh(FALSE);
    
    CRemoveDevDlg   TheDlg(pDevice);

    if (IDOK == TheDlg.DoModal(hDlg, (LPARAM) &TheDlg)) {

        DWORD DiFlags;
        DiFlags = pDevice->m_pMachine->DiGetFlags(*pDevice);
        
        //
        // We don't check to see if the device manager is connected to the local
        // machine because if it wasn't we would not have allowed the user to
        // get this far since we don't allow them to remove a device if it
        // is not connected to the local machine.
        //
        if (PromptForRestart(hDlg, DiFlags, IDS_REMOVEDEV_RESTART) == IDNO) {
            Refresh = TRUE;
        }

        if (Refresh) {
            pMachine->ScheduleRefresh();
        }
        
        Return = TRUE;
    }

    pMachine->EnableRefresh(TRUE);

    return Return;
}

BOOL
CDeviceDriverPage::LaunchTroubleShooter(
    CDevice* pDevice,
    HWND hDlg,
    BOOL *pfChanged
    )
{
    BOOL fChanged = FALSE;
    DWORD Status, Problem = 0;
    CProblemAgent*  ProblemAgent;
    
    if (pDevice->GetStatus(&Status, &Problem) || pDevice->IsPhantom())
    {
        //
        // if the device is a phantom device, use the CM_PROB_DEVICE_NOT_THERE
        //
        if (pDevice->IsPhantom())
        {
            Problem = CM_PROB_DEVICE_NOT_THERE;
            Status = DN_HAS_PROBLEM;
        }

        //
        // if the device is not started and no problem is assigned to it
        // fake the problem number to be failed start.
        //
        if (!(Status & DN_STARTED) && !Problem && pDevice->IsRAW())
        {
            Problem = CM_PROB_FAILED_START;
        }
    }

    ProblemAgent = new CProblemAgent(pDevice, Problem, FALSE);

    if (ProblemAgent) {
    
        fChanged = ProblemAgent->FixIt(GetParent(hDlg));

        delete ProblemAgent;
    }

    if (pfChanged) {

        *pfChanged = fChanged;
    }

    return TRUE;
}

//
// This function updates drivers for the given device
// INPUT:
//  pDevice -- the object represent the device
//  hDlg    -- the property page window handle
//  pfChanged   -- optional buffer to receive if driver changes
//                 have occured.
// OUTPUT:
//  TRUE    -- function succeeded.
//  FALSE   -- function failed.
//
BOOL
CDeviceDriverPage::RollbackDriver(
    CDevice* pDevice,
    HWND hDlg,
    BOOL *pfChanged,
    DWORD *pdwReboot
    )
{
    HCURSOR hCursorOld;
    BOOL RollbackSuccessful = FALSE;
    DWORD RollbackError = ERROR_CANCELLED;
    DWORD Status = 0, Problem = 0;

    //
    // Verify that the process has Admin credentials and that we are running on the local
    // machine.
    //
    if (!pDevice || !pDevice->m_pMachine->IsLocal() || !g_HasLoadDriverNamePrivilege) {

        ASSERT(FALSE);
        return FALSE;
    }

    hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
    
    //
    // If the device has the DN_WILL_BE_REMOVED flag set and the user is
    // attempting to roll back the driver then we will prompt them for a 
    // reboot and include text in the prompt that explains this device
    // is in the process of being removed.
    //
    if (pDevice->GetStatus(&Status, &Problem) &&
        (Status & DN_WILL_BE_REMOVED)) {

        if (PromptForRestart(m_hDlg, DI_NEEDRESTART, IDS_WILL_BE_REMOVED_NO_ROLLBACK_DRIVER) == IDYES) {

            ::DestroyWindow(GetParent(m_hDlg));
        }

        return FALSE;
    }

    //
    // First check to see if there are any drivers to Rollback
    //
    CSafeRegistry regRollback;
    TCHAR RollbackSubkeyName[MAX_PATH + 1];
    TCHAR ReinstallString[MAX_PATH];        
    BOOL bFoundMatch = FALSE;
    int index = 0;

    ReinstallString[0] = TEXT('\0');
    RollbackSubkeyName[0] = TEXT('\0');

    if (regRollback.Open(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Reinstall"))) {

        DWORD SubkeySize = ARRAYLEN(RollbackSubkeyName);
        
        while (!bFoundMatch && regRollback.EnumerateSubkey(index, RollbackSubkeyName, &SubkeySize)) {

            CSafeRegistry regRollbackSubkey;

            if (regRollbackSubkey.Open(regRollback, RollbackSubkeyName)) {

                DWORD regType, cbSize;
                LPTSTR DeviceInstanceIds;

                cbSize = 0;

                if (regRollbackSubkey.GetValue(TEXT("DeviceInstanceIds"), &regType, NULL, &cbSize)) {

                    //
                    // Allocate memory to hold the DeviceInstanceIds
                    //
                    DeviceInstanceIds = (LPTSTR)LocalAlloc(LPTR, cbSize);

                    if (DeviceInstanceIds) {

                        ZeroMemory(DeviceInstanceIds, cbSize);

                        if (regRollbackSubkey.GetValue(TEXT("DeviceInstanceIds"), &regType,
                                                       (PBYTE)DeviceInstanceIds, &cbSize)) {
                    
                        
                            //
                            // Compare the list of DeviceInstanceIds in this registry key with this
                            // devices DeviceInstanceId
                            //
                            for (LPTSTR p = DeviceInstanceIds; *p; p += (lstrlen(p) + 1)) {
        
                                if (!lstrcmpi(p, pDevice->GetDeviceID())) {
        
                                    bFoundMatch = TRUE;

                                    cbSize = sizeof(ReinstallString);
                                    regRollbackSubkey.GetValue(TEXT("ReinstallString"), &regType, 
                                                               (PBYTE)ReinstallString, &cbSize);
                                    
                                    break;
                                }
                            }
                        }

                        LocalFree(DeviceInstanceIds);
                    }
                }
            }

            SubkeySize = ARRAYLEN(RollbackSubkeyName);
            index++;
        }
    }

    if (bFoundMatch) {

        //
        // Check the ReinstallString path to verify that a backup directory actually exists.
        // We first need to strip the INF name off of the end of the path.
        //
        PTSTR p;

        //
        // Assume that the directory does NOT exist
        //
        bFoundMatch = FALSE;

        if (ReinstallString[0] != TEXT('\0')) {
        
            p = StrRChr(ReinstallString, NULL, TEXT('\\'));
    
            if (p) {
    
                *p = 0;
            
                WIN32_FIND_DATA findData;
                HANDLE FindHandle;
                UINT OldMode;

                OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

                FindHandle = FindFirstFile(ReinstallString, &findData);

                if(FindHandle != INVALID_HANDLE_VALUE) {

                    FindClose(FindHandle);
                    bFoundMatch = TRUE;
                
                } else {

                    //
                    // The directory does not exist.  Make sure we clean out the registry key
                    //
                    regRollback.DeleteSubkey(RollbackSubkeyName);
                }

                SetErrorMode(OldMode);
            }
        }
    }

    if (bFoundMatch) {

        //
        // We found a match, lets ask the user if they want to rollback the drivers
        //
        String strYesRollback;
        strYesRollback.LoadString(g_hInstance, IDS_DEVDRV_YESROLLBACK);
        
        if (MessageBox(hDlg, strYesRollback, pDevice->GetDisplayName(), MB_YESNO) == IDYES) {

            RollbackSuccessful = pDevice->m_pMachine->RollbackDriver(hDlg, RollbackSubkeyName, 0x3, pdwReboot);

            if (!RollbackSuccessful) {
            
                RollbackError = GetLastError();
            }
        }
    
    } else {

        //
        // We could not find a drivers backup for this device.  Lets ask the user if they want
        // to start the troubleshooter.
        //
        String strNoRollback;
        strNoRollback.LoadString(g_hInstance, IDS_DEVDRV_NOROLLBACK);
        
        if (MessageBox(hDlg, strNoRollback, pDevice->GetDisplayName(), MB_YESNO) == IDYES) {

            LaunchTroubleShooter(pDevice, hDlg, pfChanged);
        }
    }
    
    if (hCursorOld) {

        SetCursor(hCursorOld);
    }

    //
    // We will assume that something changed when we called InstallDevInst()
    // unless it returned FALSE and GetLastError() == ERROR_CANCELLED
    //
    if (pfChanged) {

        *pfChanged = TRUE;

        if (!bFoundMatch || (!RollbackSuccessful && (ERROR_CANCELLED == RollbackError))) {

            *pfChanged = FALSE;
        }
    }

    return TRUE;
}

//
// This function updates drivers for the given device
// INPUT:
//  pDevice -- the object represent the device
//  hDlg    -- the property page window handle
//  pfChanged   -- optional buffer to receive if driver changes
//                 have occured.
// OUTPUT:
//  TRUE    -- function succeeded.
//  FALSE   -- function failed.
//
BOOL
CDeviceDriverPage::UpdateDriver(
    CDevice* pDevice,
    HWND hDlg,
    BOOL *pfChanged,
    DWORD *pdwReboot
    )
{
    BOOL Installed = FALSE;
    DWORD InstallError = ERROR_SUCCESS;
    DWORD Status = 0, Problem = 0;

    //
    // Must be an admin and on the local machine to update a device.
    //
    if (!pDevice || !pDevice->m_pMachine->IsLocal() || !g_HasLoadDriverNamePrivilege) {

        ASSERT(FALSE);
        return FALSE;
    }

    //
    // If the device has the DN_WILL_BE_REMOVED flag set and the user is
    // attempting to update the driver then we will prompt them for a 
    // reboot and include text in the prompt that explains this device
    // is in the process of being removed.
    //
    if (pDevice->GetStatus(&Status, &Problem) &&
        (Status & DN_WILL_BE_REMOVED)) {

        if (PromptForRestart(m_hDlg, DI_NEEDRESTART, IDS_WILL_BE_REMOVED_NO_UPDATE_DRIVER) == IDYES) {

            ::DestroyWindow(GetParent(m_hDlg));
        }

        return FALSE;
    }

    Installed = pDevice->m_pMachine->InstallDevInst(hDlg, pDevice->GetDeviceID(), TRUE, pdwReboot);

    if (!Installed) {

        InstallError = GetLastError();
    }

    //
    // We will assume that something changed when we called InstallDevInst()
    // unless it returned FALSE and GetLastError() == ERROR_CANCELLED
    //
    if (pfChanged) {

        *pfChanged = TRUE;

        if (!Installed && (ERROR_CANCELLED == InstallError)) {
            *pfChanged = FALSE;
        }
    }

    return TRUE;
}

void
CDeviceDriverPage::InitializeDriver()
{
    if (m_pDriver) {
        delete m_pDriver;
        m_pDriver = NULL;
    }

    m_pDriver = m_pDevice->CreateDriver();
}

void
CDeviceDriverPage::UpdateControls(
    LPARAM lParam
    )
{
    if (lParam) {

        m_pDevice = (CDevice*) lParam;
    }

    try {
        //
        // Calling PropertyChanged() will update the display name for the device.  We need
        // to do this in case a 3rd party property sheet did something that could change
        // the device's display name.
        //
        m_pDevice->PropertyChanged();

        //
        // If we are not running locally then don't bother showing the driver
        // details since we can't get a list of the drivers and we can't get
        // any information about the driver.
        //
        if (!m_pDevice->m_pMachine->IsLocal()) {
            
            ::EnableWindow(GetControl(IDC_DEVDRV_DETAILS), FALSE);
            ::EnableWindow(GetControl(IDC_DEVDRV_DETAILS_TEXT), FALSE);
        }

        //
        // can not change driver on remote machine or the user
        // has no Administrator privilege.
        //
        if (!m_pDevice->m_pMachine->IsLocal() || !g_HasLoadDriverNamePrivilege) {

            ::EnableWindow(GetControl(IDC_DEVDRV_CHANGEDRIVER), FALSE);
            ::EnableWindow(GetControl(IDC_DEVDRV_CHANGEDRIVER_TEXT), FALSE);
            ::EnableWindow(GetControl(IDC_DEVDRV_ROLLBACK), FALSE);
            ::EnableWindow(GetControl(IDC_DEVDRV_ROLLBACK_TEXT), FALSE);
            ::EnableWindow(GetControl(IDC_DEVDRV_UNINSTALL), FALSE);
            ::EnableWindow(GetControl(IDC_DEVDRV_UNINSTALL_TEXT), FALSE);
        }

        //
        // Hide the uninstall button if the device cannot be uninstalled
        //
        else if (!m_pDevice->IsUninstallable()) {

            ::EnableWindow(GetControl(IDC_DEVDRV_UNINSTALL), FALSE);
            ::EnableWindow(GetControl(IDC_DEVDRV_UNINSTALL_TEXT), FALSE);
        }

        HICON hIconOld;
        m_IDCicon = IDC_DEVDRV_ICON;    // Save for cleanup in OnDestroy.
        hIconOld = (HICON)SendDlgItemMessage(m_hDlg, IDC_DEVDRV_ICON, STM_SETICON,
                        (WPARAM)(m_pDevice->LoadClassIcon()),
                        0
                        );

        if (hIconOld) {
            DestroyIcon(hIconOld);
        }

        InitializeDriver();

        SetDlgItemText(m_hDlg, IDC_DEVDRV_DESC, m_pDevice->GetDisplayName());

        String strDriverProvider, strDriverDate, strDriverVersion, strDriverSigner;
        m_pDevice->GetProviderString(strDriverProvider);
        SetDlgItemText(m_hDlg, IDC_DEVDRV_DRIVERPROVIDER, strDriverProvider);
        m_pDevice->GetDriverDateString(strDriverDate);
        SetDlgItemText(m_hDlg, IDC_DEVDRV_DRIVERDATE, strDriverDate);
        m_pDevice->GetDriverVersionString(strDriverVersion);
        SetDlgItemText(m_hDlg, IDC_DEVDRV_DRIVERVERSION, strDriverVersion);
        
        if (m_pDriver) {
            m_pDriver->GetDriverSignerString(strDriverSigner);
        }
        
        //
        // If we could not get a digital signature string or then just display 
        // Unknown for the Digital Signer.
        //
        if (strDriverSigner.IsEmpty()) {
            strDriverSigner.LoadString(g_hInstance, IDS_UNKNOWN);
        }

        SetDlgItemText(m_hDlg, IDC_DEVDRV_DRIVERSIGNER, strDriverSigner);
        AddToolTips(m_hDlg, IDC_DEVDRV_DRIVERSIGNER, (LPTSTR)strDriverSigner, &m_hwndDigitalSignerTip);
    }

    catch (CMemoryException* e) {

        e->Delete();
        // report memory error
        MsgBoxParam(m_hDlg, 0, 0, 0);
    }
}

BOOL
CDeviceDriverPage::OnHelp(
    LPHELPINFO pHelpInfo
    )
{
    WinHelp((HWND)pHelpInfo->hItemHandle, DEVMGR_HELP_FILE_NAME, HELP_WM_HELP,
        (ULONG_PTR)g_a106HelpIDs);

    return FALSE;
}


BOOL
CDeviceDriverPage::OnContextMenu(
    HWND hWnd,
    WORD xPos,
    WORD yPos
    )
{
    WinHelp(hWnd, DEVMGR_HELP_FILE_NAME, HELP_CONTEXTMENU,
        (ULONG_PTR)g_a106HelpIDs);

    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Driver Files
//
const DWORD g_a110HelpIDs[]=
{
    IDC_DRIVERFILES_ICON,           IDH_DISABLEHELP,                // Driver: "" (Icon)
    IDC_DRIVERFILES_DESC,           IDH_DISABLEHELP,                // Driver: "" (Static)
    IDC_DRIVERFILES_FILES,          IDH_DISABLEHELP,                // Driver: "Provider:" (Static)
    IDC_DRIVERFILES_FILELIST,       idh_devmgr_driver_driver_files, // Driver: "" (ListBox)
    IDC_DRIVERFILES_TITLE_PROVIDER, idh_devmgr_driver_provider,     // Driver: "Provider:" (Static)
    IDC_DRIVERFILES_PROVIDER,       idh_devmgr_driver_provider,     // Driver: "" (Static)
    IDC_DRIVERFILES_TITLE_COPYRIGHT,idh_devmgr_driver_copyright,    // Driver: "Copyright:" (Static)
    IDC_DRIVERFILES_COPYRIGHT,      idh_devmgr_driver_copyright,    // Driver: "" (Static)
    IDC_DRIVERFILES_TITLE_DIGITALSIGNER, IDH_DISABLEHELP,
    IDC_DRIVERFILES_DIGITALSIGNER,  IDH_DISABLEHELP,
    IDC_DRIVERFILES_TITLE_VERSION,  idh_devmgr_driver_file_version, // Driver: "Version:" (Static)
    IDC_DRIVERFILES_VERSION,        idh_devmgr_driver_file_version, // Driver: "File Version:" (Static)
    0, 0
};

BOOL CDriverFilesDlg::OnInitDialog()
{
    int SignedIndex = 0, BlankIndex = 0, DriverBlockIndex = 0;

    try {

        HICON hIcon;
        hIcon = (HICON)SendDlgItemMessage(m_hDlg, IDC_DRIVERFILES_ICON, STM_SETICON,
                                             (WPARAM)(m_pDevice->LoadClassIcon()), 0);

        if (hIcon) {
        
            DestroyIcon(hIcon);
        }

        SetDlgItemText(m_hDlg, IDC_DRIVERFILES_DESC, m_pDevice->GetDisplayName());

        //
        // Create the ImageList that contains the signed and blank images.
        //
        // NOTE: On BiDi builds we need to set the ILC_MIRROR flag so that the
        // signed/unsigned icons are not mirrored.
        //
        m_ImageList = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
                                       GetSystemMetrics(SM_CYSMICON),
                                       ILC_MASK |
                                       (GetWindowLong(GetParent(m_hDlg), GWL_EXSTYLE) & WS_EX_LAYOUTRTL)
                                         ? ILC_MIRROR
                                         : 0,
                                       1,
                                       1
                                       );   

        if (m_ImageList) {
        
            ImageList_SetBkColor(m_ImageList, GetSysColor(COLOR_WINDOW));
            
            if ((hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_BLANK))) != NULL) {
            
                BlankIndex =  ImageList_AddIcon(m_ImageList, hIcon);
                DestroyIcon(hIcon);
            }
    
            if ((hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_SIGNED))) != NULL) {
            
                SignedIndex = ImageList_AddIcon(m_ImageList, hIcon);
                DestroyIcon(hIcon);
            }

            if ((hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_DRIVERBLOCK))) != NULL) {
            
                DriverBlockIndex = ImageList_AddIcon(m_ImageList, hIcon);
                DestroyIcon(hIcon);
            }
        }

        //
        //Initialize the list of drivers
        //
        LV_COLUMN lvcCol;
        LV_ITEM lviItem;
        CDriverFile* pDrvFile;
        PVOID Context;
        HWND hwndFileList = GetDlgItem(m_hDlg, IDC_DRIVERFILES_FILELIST);

        //
        // Insert a single column for this list.
        //
        lvcCol.mask = LVCF_FMT | LVCF_WIDTH;
        lvcCol.fmt = LVCFMT_LEFT;
        lvcCol.iSubItem = 0;
        ListView_InsertColumn(hwndFileList, 0, (LV_COLUMN FAR *)&lvcCol);

        ListView_SetExtendedListViewStyle(hwndFileList, LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);

        if (m_ImageList) {

            ListView_SetImageList(hwndFileList, m_ImageList, LVSIL_SMALL);
        }

        ListView_DeleteAllItems(hwndFileList);

        if (m_pDriver && m_pDriver->GetFirstDriverFile(&pDrvFile, Context)) {

            do {

                ASSERT(pDrvFile);
                LPCTSTR pFullPathName;
                pFullPathName = pDrvFile->GetFullPathName();
                if (pFullPathName) {

                    lviItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
                    lviItem.iSubItem = 0;
                    lviItem.lParam = (LPARAM)pDrvFile;
                    lviItem.iItem = ListView_GetItemCount(hwndFileList);
                    lviItem.pszText = (LPTSTR)pFullPathName;

                    if (m_ImageList) {

                        if (pDrvFile->IsDriverBlocked()) {
                            //
                            // If the driver is blocked then it gets a special
                            // icon.
                            //
                            lviItem.iImage = DriverBlockIndex;
                        } else {
                            //
                            // If the driver is not blocked then show an icon 
                            // if the driver is digitally signed.
                            //
                            lviItem.iImage = (pDrvFile->GetWin32Error() == NO_ERROR) ? 
                                SignedIndex : BlankIndex;
                        }
                    }

                    ListView_InsertItem(hwndFileList, &lviItem);
                }

            } while (m_pDriver->GetNextDriverFile(&pDrvFile, Context));

            if (ListView_GetItemCount(hwndFileList) >= 1) {

                ListView_SetItemState(hwndFileList,
                                      0,
                                      LVIS_SELECTED | LVIS_FOCUSED,
                                      LVIS_SELECTED | LVIS_FOCUSED
                                      );
                ListView_EnsureVisible(hwndFileList, 0, FALSE);
                ListView_SetColumnWidth(hwndFileList, 0, LVSCW_AUTOSIZE_USEHEADER);

                ShowCurDriverFileDetail();

            } else {

                //
                // nothing on the driver file list, disable it
                //
                ::EnableWindow(GetControl(IDC_DRIVERFILES_FILELIST), FALSE);
            }
        }
    }

    catch (CMemoryException* e) {

        e->Delete();
        return FALSE;
    }

    return TRUE;
}

void
CDriverFilesDlg::OnCommand(
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (BN_CLICKED == HIWORD(wParam)) {

        if (IDOK == LOWORD(wParam)) {

            EndDialog(m_hDlg, IDOK);

        } else if (IDCANCEL == LOWORD(wParam)) {

            EndDialog(m_hDlg, IDCANCEL);
        }
    }
}

BOOL 
CDriverFilesDlg::OnNotify(
    LPNMHDR pnmhdr
    )
{
    switch (pnmhdr->code) {
    case LVN_ITEMCHANGED:
        ShowCurDriverFileDetail();
        break;

    case NM_RETURN:
    case NM_CLICK:
        if (pnmhdr->idFrom == IDS_DRIVERFILES_BLOCKDRIVERLINK) {
            LaunchHelpForBlockedDriver();
        }
        break;
    }

    return FALSE;
}

BOOL
CDriverFilesDlg::OnDestroy()
{
    HICON hIcon;

    if(hIcon = (HICON)SendDlgItemMessage(m_hDlg, IDC_DRIVERFILES_ICON, STM_GETICON, 0, 0)) {
        DestroyIcon(hIcon);
    }

    if (m_ImageList) {
        ImageList_Destroy(m_ImageList);
    }
    return FALSE;
}

BOOL
CDriverFilesDlg::OnHelp(
    LPHELPINFO pHelpInfo
    )
{
    WinHelp((HWND)pHelpInfo->hItemHandle, DEVMGR_HELP_FILE_NAME, HELP_WM_HELP,
        (ULONG_PTR)g_a110HelpIDs);
    return FALSE;
}


BOOL
CDriverFilesDlg::OnContextMenu(
    HWND hWnd,
    WORD xPos,
    WORD yPos
    )
{
    WinHelp(hWnd, DEVMGR_HELP_FILE_NAME, HELP_CONTEXTMENU,
            (ULONG_PTR)g_a110HelpIDs);

    return FALSE;
}

void
CDriverFilesDlg::ShowCurDriverFileDetail()
{
    HWND hwndFileList = GetDlgItem(m_hDlg, IDC_DRIVERFILES_FILELIST);
    LVITEM lvItem;
    LPCTSTR  pString;

    lvItem.mask = LVIF_PARAM;
    lvItem.iSubItem = 0;
    lvItem.iItem = ListView_GetNextItem(hwndFileList,
                                        -1,
                                        LVNI_SELECTED
                                        );

    if (lvItem.iItem != -1) {

        try {
        
            ListView_GetItem(hwndFileList, &lvItem);

            CDriverFile* pDrvFile = (CDriverFile*)lvItem.lParam;
    
            ASSERT(pDrvFile);
    
            TCHAR TempString[LINE_LEN];
            LPCTSTR pFullPathName;
            pFullPathName = pDrvFile->GetFullPathName();
    
            if (!pFullPathName || (pDrvFile->GetAttributes() == 0xFFFFFFFF)) {
    
                //
                // This is the case when the file is not present on the system
                //
                LoadResourceString(IDS_NOT_PRESENT, TempString, ARRAYLEN(TempString));
                SetDlgItemText(m_hDlg, IDC_DRIVERFILES_VERSION, TempString);
                SetDlgItemText(m_hDlg, IDC_DRIVERFILES_PROVIDER, TempString);
                SetDlgItemText(m_hDlg, IDC_DRIVERFILES_COPYRIGHT, TempString);
                SetDlgItemText(m_hDlg, IDC_DRIVERFILES_DIGITALSIGNER, TempString);
                ShowWindow(GetControl(IDS_DRIVERFILES_BLOCKDRIVERLINK), FALSE);

            } else { 
                if (!pDrvFile->HasVersionInfo()) {
                    //
                    // This is the case when the file is present but it does not have
                    // version information.
                    //
                    LoadResourceString(IDS_UNKNOWN, TempString, ARRAYLEN(TempString));
                    SetDlgItemText(m_hDlg, IDC_DRIVERFILES_VERSION, TempString);
                    SetDlgItemText(m_hDlg, IDC_DRIVERFILES_PROVIDER, TempString);
                    SetDlgItemText(m_hDlg, IDC_DRIVERFILES_COPYRIGHT, TempString);
                } else {
                    //
                    // Show the file version information.
                    //
                    TempString[0] = _T('\0');

                    pString = pDrvFile->GetVersion();
                    if (!pString && _T('\0') == TempString[0]) {

                        LoadResourceString(IDS_NOT_AVAILABLE, TempString, ARRAYLEN(TempString));
                        pString = TempString;
                    }

                    SetDlgItemText(m_hDlg, IDC_DRIVERFILES_VERSION, (LPTSTR)pString);

                    pString = pDrvFile->GetProvider();
                    if (!pString && _T('\0') == TempString[0]) {

                        LoadResourceString(IDS_NOT_AVAILABLE, TempString, ARRAYLEN(TempString));
                        pString = TempString;
                    }

                    SetDlgItemText(m_hDlg, IDC_DRIVERFILES_PROVIDER, (LPTSTR)pString);

                    pString = pDrvFile->GetCopyright();
                    if (!pString && _T('\0') == TempString[0]) {

                        LoadResourceString(IDS_NOT_AVAILABLE, TempString, ARRAYLEN(TempString));
                        pString = TempString;
                    }

                    SetDlgItemText(m_hDlg, IDC_DRIVERFILES_COPYRIGHT, (LPTSTR)pString);
                }
            
                //
                // Show the digital signer if the file is signed.
                //
                pString = pDrvFile->GetDigitalSigner();
                if (!pString) {
                    TempString[0] = _T('\0');

                    LoadResourceString(((pDrvFile->GetWin32Error() != 0) &&
                                        (pDrvFile->GetWin32Error() != 0xFFFFFFFF) &&
                                        (pDrvFile->GetWin32Error() != ERROR_DRIVER_BLOCKED))
                                           ?  IDS_NO_DIGITALSIGNATURE
                                           :  IDS_NOT_AVAILABLE, 
                                        TempString, 
                                        ARRAYLEN(TempString));
                    pString = TempString;
                }

                SetDlgItemText(m_hDlg, IDC_DRIVERFILES_DIGITALSIGNER, (LPTSTR)pString);

                //
                // Show the block driver link if this driver is blocked and it
                // has a block driver html help ID.
                //
                ShowWindow(GetControl(IDS_DRIVERFILES_BLOCKDRIVERLINK), 
                           pDrvFile->GetBlockedDriverHtmlHelpID()
                             ? TRUE
                             : FALSE);
            }
        }
        
        catch (CMemoryException* e) {

            e->Delete();
            // report memory error
            MsgBoxParam(m_hDlg, 0, 0, 0);
        }

    } else {

        // no selection
        SetDlgItemText(m_hDlg, IDC_DRIVERFILES_VERSION, TEXT(""));
        SetDlgItemText(m_hDlg, IDC_DRIVERFILES_PROVIDER, TEXT(""));
        SetDlgItemText(m_hDlg, IDC_DRIVERFILES_COPYRIGHT, TEXT(""));
        SetDlgItemText(m_hDlg, IDC_DRIVERFILES_DIGITALSIGNER, TEXT(""));
    }
}

void
CDriverFilesDlg::LaunchHelpForBlockedDriver()
{
    HWND hwndFileList = GetDlgItem(m_hDlg, IDC_DRIVERFILES_FILELIST);
    LVITEM lvItem;
    LPCTSTR pHtmlHelpID;
    String strHcpLink;

    lvItem.mask = LVIF_PARAM;
    lvItem.iSubItem = 0;
    lvItem.iItem = ListView_GetNextItem(hwndFileList,
                                        -1,
                                        LVNI_SELECTED
                                        );

    if (lvItem.iItem != -1) {

        try {
        
            ListView_GetItem(hwndFileList, &lvItem);

            CDriverFile* pDrvFile = (CDriverFile*)lvItem.lParam;
            ASSERT(pDrvFile);

            if ((pHtmlHelpID = pDrvFile->GetBlockedDriverHtmlHelpID()) != NULL) {
                strHcpLink.Format(TEXT("HELPCTR.EXE -url %s"), pHtmlHelpID);

                TRACE((TEXT("launching %s"), pHtmlHelpID));

                ShellExecute(m_hDlg,
                             TEXT("open"),
                             TEXT("HELPCTR.EXE"),
                             (LPTSTR)strHcpLink,
                             NULL,
                             SW_SHOWNORMAL);
            }
        }
        
        catch (CMemoryException* e) {

            e->Delete();
            // report memory error
            MsgBoxParam(m_hDlg, 0, 0, 0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\devgenpg.h ===
// devgenpg.h : header file
//

#ifndef __DEVGENPG_H__
#define __DEVGENPG_H__

/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    devgenpg.h

Abstract:

    header file for devgenpg.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "proppage.h"
//#include "tshooter.h"

//
// help topic ids
//
#define IDH_DISABLEHELP (DWORD(-1))
#define idh_devmgr_general_devicetype   103100  // General: "" (Static)
#define idh_devmgr_general_manufacturer 103110  // General: "" (Static)
#define idh_devmgr_general_hardware_revision    103120  // General: "Not Available" (Static)
#define idh_devmgr_general_device_status    103130  // General: "" (Static)
#define idh_devmgr_general_device_usage 103140  // General: "List1" (SysListView32)
#define idh_devmgr_general_location 103160
#define idh_devmgr_general_trouble  103150  // troubelshooting button

class CHwProfileList;
class CProblemAgent;

const int LVIS_GCNOCHECK = INDEXTOSTATEIMAGEMASK(1);
const int LVIS_GCCHECK = INDEXTOSTATEIMAGEMASK(2);

extern const int CMProblemNumberToStringID[];

#define DI_NEEDPOWERCYCLE   0x400000L

#define DEVICE_ENABLE           0
#define DEVICE_DISABLE          1
#define DEVICE_DISABLE_GLOBAL   2

class CDeviceGeneralPage : public CPropSheetPage
{
public:
    CDeviceGeneralPage() :
    m_pDevice(NULL),
    m_pHwProfileList(NULL),
    m_RestartFlags(0),
    m_pProblemAgent(NULL),
    m_hwndLocationTip(NULL),
    CPropSheetPage(g_hInstance, IDD_DEVGEN_PAGE)
    {}
    ~CDeviceGeneralPage();
    HPROPSHEETPAGE Create(CDevice* pDevice);
    virtual BOOL OnInitDialog(LPPROPSHEETPAGE ppsp);
    virtual BOOL OnApply(void);
    virtual BOOL OnLastChanceApply(void);
    virtual BOOL OnQuerySiblings(WPARAM wParam, LPARAM lParam);
    virtual void UpdateControls(LPARAM lParam = 0);
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    virtual BOOL OnHelp(LPHELPINFO pHelpInfo);
    virtual BOOL OnContextMenu(HWND hWnd, WORD xPos, WORD yPos);
    virtual UINT  DestroyCallback();

private:
    void UpdateHwProfileStates();
    CHwProfileList* m_pHwProfileList;
    DWORD   m_hwpfCur;
    CDevice* m_pDevice;
    int     m_CurrentDeviceUsage;
    int     m_SelectedDeviceUsage;
    DWORD   m_RestartFlags;
    CProblemAgent*  m_pProblemAgent;
    HWND    m_hwndLocationTip;
};


#endif // __DEVGENPG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\devgenpg.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    devgenpg.cpp

Abstract:

    This module implements CDeviceGeneralPage -- device general property page

Author:

    William Hsieh (williamh) created

Revision History:


--*/
// devgenpg.cpp : implementation file
//

#include "devmgr.h"
#include "hwprof.h"
#include "devgenpg.h"
#include "tswizard.h"
#include "utils.h"

//
// help topic ids
//

const DWORD g_a103HelpIDs[]=
{
    IDC_DEVGEN_TITLE_TYPE, idh_devmgr_general_devicetype,
    IDC_DEVGEN_TITLE_MFG, idh_devmgr_general_manufacturer,
    IDC_DEVGEN_STATUSGROUP, IDH_DISABLEHELP,
    IDC_DEVGEN_ICON, IDH_DISABLEHELP, // General: "" (Static)
    IDC_DEVGEN_DESC, IDH_DISABLEHELP,   // General: "" (Static)
    IDC_DEVGEN_USAGETEXT, IDH_DISABLEHELP,  // General: "Place a check mark next to the configuration(s) where this device should be used." (Static)
    IDC_DEVGEN_TYPE, idh_devmgr_general_devicetype, // General: "" (Static)
    IDC_DEVGEN_MFG, idh_devmgr_general_manufacturer,    // General: "" (Static)
    IDC_DEVGEN_STATUS, idh_devmgr_general_device_status,    // General: "" (Static)
    IDC_DEVGEN_PROFILELIST, idh_devmgr_general_device_usage,    // General: "Dropdown Combo" (SysListView32)
    IDC_DEVGEN_TITLE_LOCATION, idh_devmgr_general_location, // General:  location
    IDC_DEVGEN_LOCATION, idh_devmgr_general_location,     // General:  location
    IDC_DEVGEN_TROUBLESHOOTING, idh_devmgr_general_trouble, // General: troubleshooting
    0, 0
};

CDeviceGeneralPage::~CDeviceGeneralPage()
{
    if (m_pHwProfileList) {

        delete m_pHwProfileList;
    }

    if (m_pProblemAgent) {

        delete m_pProblemAgent;
    }
}

HPROPSHEETPAGE
CDeviceGeneralPage::Create(
    CDevice* pDevice
    )
{
    ASSERT(pDevice);

    if (pDevice)
    {
        m_pDevice = pDevice;
        
        // override PROPSHEETPAGE structure here...
        m_psp.lParam = (LPARAM)this;
        
        pDevice->m_pMachine->DiTurnOffDiExFlags(*pDevice, DI_FLAGSEX_PROPCHANGE_PENDING);
        return  CreatePage();
    }
    
    return NULL;
}

BOOL
CDeviceGeneralPage::OnInitDialog(
    LPPROPSHEETPAGE ppsp
    )
{
    m_pDevice->m_pMachine->AttachPropertySheet(m_hDlg);


    // notify property sheet data that the property sheet is up
    m_pDevice->m_psd.PageCreateNotify(m_hDlg);

    return CPropSheetPage::OnInitDialog(ppsp);
}

BOOL 
CDeviceGeneralPage::OnApply()
{
    try
    {
        HWND hwndCB = GetControl(IDC_DEVGEN_PROFILELIST);
        
        m_SelectedDeviceUsage = ComboBox_GetCurSel(hwndCB);

        if ((-1 != m_SelectedDeviceUsage) && 
            (m_SelectedDeviceUsage != m_CurrentDeviceUsage)) {

            //
            // User is changing the device usage
            //
            UpdateHwProfileStates();
            SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
            return TRUE;
        }
    }

    catch(CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_hDlg, 0, 0, 0);
    }
    
    return FALSE;
}

void
CDeviceGeneralPage::UpdateHwProfileStates()
{
    // first decide what to do(enabling or disabling or both)
    BOOL Canceled;
    Canceled = FALSE;

    if (m_SelectedDeviceUsage == m_CurrentDeviceUsage) {
    
        return;
    }

    m_pDevice->m_pMachine->DiTurnOnDiFlags(*m_pDevice, DI_NODI_DEFAULTACTION);

    SP_PROPCHANGE_PARAMS pcp;
    pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;

    //
    // specific enabling/disabling
    //
    pcp.Scope = DICS_FLAG_CONFIGSPECIFIC;
    CHwProfile* phwpf;

    if (m_pHwProfileList->GetCurrentHwProfile(&phwpf))
    {
        pcp.StateChange = DICS_DISABLE;
        
        if (DEVICE_ENABLE == m_SelectedDeviceUsage) {
        
            pcp.StateChange = DICS_ENABLE;
        }

        pcp.HwProfile = phwpf->GetHwProfile();
        
        m_pDevice->m_pMachine->DiSetClassInstallParams(*m_pDevice,
                    &pcp.ClassInstallHeader,
                    sizeof(pcp)
                    );
        
        m_pDevice->m_pMachine->DiCallClassInstaller(DIF_PROPERTYCHANGE, *m_pDevice);
        
        Canceled = (ERROR_CANCELLED == GetLastError());
    }

    //
    // class installer has not objection of our enabling/disabling,
    // do real enabling/disabling.
    //
    if (!Canceled)
    {
        if (m_pHwProfileList->GetCurrentHwProfile(&phwpf))
        {
            if (DEVICE_ENABLE == m_SelectedDeviceUsage) 
            {
                //
                // we are enabling the device,
                // do a specific enabling then a globally enabling.
                // the globally enabling will start the device
                // The implementation here is different from
                // Win9x which does a global enabling, a config
                // specific enabling and then a start.
                //
                pcp.Scope = DICS_FLAG_CONFIGSPECIFIC;
                pcp.HwProfile = phwpf->GetHwProfile();
                
                m_pDevice->m_pMachine->DiSetClassInstallParams(*m_pDevice,
                            &pcp.ClassInstallHeader,
                            sizeof(pcp)
                            );
                
                m_pDevice->m_pMachine->DiChangeState(*m_pDevice);
                
                //
                // this call will start the device is it not started.
                //
                pcp.Scope = DICS_FLAG_GLOBAL;
                m_pDevice->m_pMachine->DiSetClassInstallParams(*m_pDevice,
                            &pcp.ClassInstallHeader,
                            sizeof(pcp)
                            );
                
                m_pDevice->m_pMachine->DiChangeState(*m_pDevice);
            }

            else
            {
                //
                // Do either a global disable or a configspecific disable
                //
                if (DEVICE_DISABLE == m_SelectedDeviceUsage) {
                
                    pcp.Scope = DICS_FLAG_CONFIGSPECIFIC;
                
                } else {

                    pcp.Scope = DICS_FLAG_GLOBAL;
                }

                pcp.StateChange = DICS_DISABLE;
                pcp.HwProfile = phwpf->GetHwProfile();
                
                m_pDevice->m_pMachine->DiSetClassInstallParams(*m_pDevice,
                            &pcp.ClassInstallHeader,
                            sizeof(pcp)
                            );
                
                m_pDevice->m_pMachine->DiChangeState(*m_pDevice);
            }
        }

        // signal that the property of the device is changed.
        m_pDevice->m_pMachine->DiTurnOnDiFlags(*m_pDevice, DI_PROPERTIES_CHANGE);
        m_RestartFlags |= (m_pDevice->m_pMachine->DiGetFlags(*m_pDevice)) & (DI_NEEDRESTART | DI_NEEDREBOOT);
    }

    // remove class install parameters, this also reset
    // DI_CLASSINATLLPARAMS
    m_pDevice->m_pMachine->DiSetClassInstallParams(*m_pDevice, NULL, 0);

    m_pDevice->m_pMachine->DiTurnOffDiFlags(*m_pDevice, DI_NODI_DEFAULTACTION);
}

BOOL 
CDeviceGeneralPage::OnLastChanceApply()
{
    //
    // The last chance apply message is sent in reverse order page n to page 0.
    //
    // Since we are the first page in the set of property sheets we can gaurentee 
    // that the last PSN_LASTCHANCEAPPLY message will be the last message for all 
    // the pages.
    //
    // The property sheet is going away, consolidate the changes on the device.  We
    // do this during the PSN_LASTCHANCEAPPLY message so that the property sheet is
    // still displayed while we do the DIF_PROPERTYCHANGE.  There are some cases where
    // the DIF_PROPERTYCHANGE can take quite a long time so we want the property sheet
    // to still be shown while this is happening.  If we do this during the DestroyCallback
    // the property sheet UI has already been torn down and so the user won't realize
    // we are still saving the changes.
    //
    try
    {
        ASSERT(m_pDevice);

        if (m_pDevice->m_pMachine->DiGetExFlags(*m_pDevice) & DI_FLAGSEX_PROPCHANGE_PENDING)
        {
            DWORD Status = 0, Problem = 0;

            //
            // If the device has the DN_WILL_BE_REMOVED flag set and the user is
            // attempting to change settings on the driver then we will prompt them for a 
            // reboot and include text in the prompt that explains this device
            // is in the process of being removed.
            //
            if (m_pDevice->GetStatus(&Status, &Problem) &&
                (Status & DN_WILL_BE_REMOVED)) {

                PromptForRestart(m_hDlg, DI_NEEDRESTART, IDS_WILL_BE_REMOVED_NO_CHANGE_SETTINGS);
            
            } else {

                //
                // property change pending, issue a DICS_PROPERTYCHANGE to the
                // class installer. A DICS_PROPCHANGE would basically stop the
                // device and restart it. If each property page issues
                // its own DICS_PROPCHANGE command, the device would
                // be stopped/started several times even though one is enough.
                // A property page sets DI_FLAGEX_PROPCHANGE_PENDING when it needs
                // a DICS_PROPCHANGE command to be issued.
                //
                SP_PROPCHANGE_PARAMS pcp;
                pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
                pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
    
                HCURSOR hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
    
                pcp.Scope = DICS_FLAG_GLOBAL;
                pcp.StateChange = DICS_PROPCHANGE;
                m_pDevice->m_pMachine->DiSetClassInstallParams(*m_pDevice,
                                &pcp.ClassInstallHeader,
                                sizeof(pcp)
                                 );
                m_pDevice->m_pMachine->DiCallClassInstaller(DIF_PROPERTYCHANGE, *m_pDevice);
                m_pDevice->m_pMachine->DiTurnOnDiFlags(*m_pDevice, DI_PROPERTIES_CHANGE);
                m_pDevice->m_pMachine->DiTurnOffDiExFlags(*m_pDevice, DI_FLAGSEX_PROPCHANGE_PENDING);
    
                if (hCursorOld) {
    
                    SetCursor(hCursorOld);
                }
            }
        }
    }

    catch(CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_hDlg, 0, 0, 0);
    }
    
    return FALSE;
}

UINT
CDeviceGeneralPage::DestroyCallback()
{

    //
    // We do this because this is the page we are sure will be created --
    // this page is ALWAYS the first page.
    //
    ASSERT(m_pDevice);

    m_RestartFlags |= m_pDevice->m_pMachine->DiGetFlags(*m_pDevice);
    if (m_RestartFlags & (DI_NEEDRESTART | DI_NEEDREBOOT))
    {
        //
        // Do not use our window handle(or its parent) as the parent
        // to the newly create dialog because they are in "detroyed state".
        // WM_CLOSE does not help either.
        // NULL window handle(Desktop) should be okay here.
        //
        // We only want to prompt for a restart if device manager is connected
        // to the local machine.
        //
        if (m_pDevice->m_pMachine->IsLocal()) 
        {
            if (PromptForRestart(NULL, m_RestartFlags) == IDNO) {

                if (m_pDevice->m_pMachine->m_ParentMachine) {

                    m_pDevice->m_pMachine->m_ParentMachine->ScheduleRefresh();

                } else {
                    
                    m_pDevice->m_pMachine->ScheduleRefresh();
                }
            }
        }
    }

    // notify CPropSheetData that the property sheet is going away
    m_pDevice->m_psd.PageDestroyNotify(m_hDlg);
    if (m_RestartFlags & DI_PROPERTIES_CHANGE)
    {
        // Device properties changed. We need to refresh the machine.
        // Since we are running in a separate thread, we can not
        // call the refresh function, instead, we schedule it.
        // This should be done before enabling the refresh
        m_pDevice->m_pMachine->ScheduleRefresh();
    }

    //    
    // Detach this property page from the CMachine so that the CMachine can be
    // destroyed now if it needs to be.
    //
    m_pDevice->m_pMachine->DetachPropertySheet(m_hDlg);
    
    ASSERT(!::IsWindow(m_hwndLocationTip));

    //
    // Destory the CMachine.
    //
    CMachine* pMachine;
    pMachine = m_pDevice->m_pMachine;
    
    if (pMachine->ShouldPropertySheetDestroy()) {
    
        delete pMachine;
    }
    
    return CPropSheetPage::DestroyCallback();
}

void
CDeviceGeneralPage::UpdateControls(
    LPARAM lParam
    )
{
    if (lParam)
        m_pDevice = (CDevice*)lParam;

    m_RestartFlags = 0;

    try
    {
        //
        // Calling PropertyChanged() will update the display name for the device.  We need
        // to do this in case a 3rd party property sheet did something that could change
        // the device's display name.
        //
        m_pDevice->PropertyChanged();

        SetDlgItemText(m_hDlg, IDC_DEVGEN_DESC, m_pDevice->GetDisplayName());
        TCHAR TempString[512];
        String str;
        m_pDevice->GetMFGString(str);
        SetDlgItemText(m_hDlg, IDC_DEVGEN_MFG, str);
        SetDlgItemText(m_hDlg, IDC_DEVGEN_TYPE, m_pDevice->GetClassDisplayName());

        HICON hIconNew;
        hIconNew = m_pDevice->LoadClassIcon();
        if (hIconNew)
        {
            HICON hIconOld;
            m_IDCicon = IDC_DEVGEN_ICON;    // Save for cleanup in OnDestroy.
            hIconOld = (HICON)SendDlgItemMessage(m_hDlg, IDC_DEVGEN_ICON,
                                                 STM_SETICON, (WPARAM)hIconNew,
                                                 0);
            if (hIconOld)
                DestroyIcon(hIconOld);
        }

        //
        // get the device location information
        //
        if (::GetLocationInformation(m_pDevice->GetDevNode(),
                                      TempString, 
                                      ARRAYLEN(TempString),
                                      m_pDevice->m_pMachine->GetHMachine()) != CR_SUCCESS)
        {
            // if the devnode does not have location information,
            // use the word "unknown"
            LoadString(g_hInstance, IDS_UNKNOWN, TempString, ARRAYLEN(TempString));
        }

        SetDlgItemText(m_hDlg, IDC_DEVGEN_LOCATION, TempString);

        AddToolTips(m_hDlg, IDC_DEVGEN_LOCATION, TempString, &m_hwndLocationTip);

        ShowWindow(GetControl(IDC_DEVGEN_TROUBLESHOOTING), SW_HIDE);

        DWORD Problem, Status;
        if (m_pDevice->GetStatus(&Status, &Problem) || m_pDevice->IsPhantom())
        {
            //
            // if the device is a phantom device, use the CM_PROB_PHANTOM
            //
            if (m_pDevice->IsPhantom())
            {
                Problem = CM_PROB_PHANTOM;
                Status = DN_HAS_PROBLEM;
            }

            //
            // if the device is not started and no problem is assigned to it
            // fake the problem number to be failed start.
            //
            if (!(Status & DN_STARTED) && !Problem && m_pDevice->IsRAW())
            {
                Problem = CM_PROB_FAILED_START;
            }



            //
            // if a device has a private problem then give it special text telling
            // the user to contact the manufacturer of this driver.
            //
            if (Status & DN_PRIVATE_PROBLEM) 
            {
                str.LoadString(g_hInstance, IDS_SPECIALPROB_PRIVATEPROB);
            }

            //
            // if a device is not started and still does not have a problem
            // then give it special problem text saying that this device
            // does not have a driver.
            //
            else if (!(Status & DN_STARTED) && !(Status & DN_HAS_PROBLEM))
            {
                if (::GetSystemMetrics(SM_CLEANBOOT) == 0) {
                
                    str.LoadString(g_hInstance, IDS_SPECIALPROB_NODRIVERS);

                } else {

                    str.LoadString(g_hInstance, IDS_SPECIALPROB_SAFEMODE);
                }
            }


            //
            // Display normal problem text
            //
            else
            {
                UINT len = GetDeviceProblemText((HMACHINE)(*m_pDevice->m_pMachine),
                                                m_pDevice->GetDevNode(), Problem, TempString, ARRAYLEN(TempString));
                if (len)
                {
                    if (len < ARRAYLEN(TempString))
                    {
                        SetDlgItemText(m_hDlg, IDC_DEVGEN_STATUS, TempString);
                        str = TempString;
                    }
                    else
                    {
                        BufferPtr<TCHAR> TextPtr(len + 1);
                        GetDeviceProblemText((HMACHINE)(*m_pDevice->m_pMachine),
                                             m_pDevice->GetDevNode(), Problem, TextPtr, len + 1);

                        str = (LPTSTR)TextPtr;
                    }
                }

                else
                {
                    str.LoadString(g_hInstance, IDS_PROB_UNKNOWN);
                }
            }

            // 
            // Add the 'related driver blocked' text if the device has the devnode
            // flag DN_DRIVER_BLOCKED set and it does not have the problem
            // CM_PROB_DRIVER_BLOCKED.
            //
            if ((Status & DN_DRIVER_BLOCKED) &&
                (Problem != CM_PROB_DRIVER_BLOCKED)) {
                LoadString(g_hInstance, IDS_DRIVER_BLOCKED, TempString, ARRAYLEN(TempString));
                str += TempString;
            }

            //
            // Add the 'will be removed' text if the device is going to be removed
            // on the next restart.
            //
            if (Status & DN_WILL_BE_REMOVED) {

                LoadString(g_hInstance, IDS_WILL_BE_REMOVED, TempString, ARRAYLEN(TempString));
                str += TempString;
            }

            //
            // Add the restart text if the device needs to be restarted
            //
            if (Status & DN_NEED_RESTART) {

                LoadString(g_hInstance, IDS_NEED_RESTART, TempString, ARRAYLEN(TempString));
                str += TempString;

                m_RestartFlags |= DI_NEEDRESTART;
            }

            //
            // Create the problem agent and update the control text
            //
            if (!(Status & DN_PRIVATE_PROBLEM)) 
            {
                if (m_pProblemAgent) {
    
                    delete m_pProblemAgent;
                }
    
                m_pProblemAgent = new CProblemAgent(m_pDevice, Problem, FALSE);
    
                DWORD Len;
                Len = m_pProblemAgent->InstructionText(TempString, ARRAYLEN(TempString));
                if (Len)
                {
                    str += TempString;
                }
    
                Len = m_pProblemAgent->FixitText(TempString, ARRAYLEN(TempString));
                if (Len)
                {
                    ::ShowWindow(GetControl(IDC_DEVGEN_TROUBLESHOOTING), SW_SHOW);
                    SetDlgItemText(m_hDlg, IDC_DEVGEN_TROUBLESHOOTING, TempString);
                }
            }
        }

        else
        {
            TRACE((TEXT("%s has not status, devnode =%lx, cr = %lx\n"),
                m_pDevice->GetDisplayName(), m_pDevice->GetDevNode(),
                m_pDevice->m_pMachine->GetLastCR()));
            str.LoadString(g_hInstance, IDS_PROB_UNKNOWN);
            ::ShowWindow(GetControl(IDC_DEVGEN_TROUBLESHOOTING), SW_HIDE);
        }

        SetDlgItemText(m_hDlg, IDC_DEVGEN_STATUS, str);

        HWND hWnd = GetControl(IDC_DEVGEN_PROFILELIST);

        if (m_pDevice->NoChangeUsage() ||
            !m_pDevice->IsDisableable() ||
            (CM_PROB_HARDWARE_DISABLED == Problem))
        {
            // the device disallows any changes on hw profile.
            // disable all profile related controls.
            ::EnableWindow(GetControl(IDC_DEVGEN_PROFILELIST), FALSE);
            ::EnableWindow(GetControl(IDC_DEVGEN_USAGETEXT), FALSE);
        }

        else
        {
            HWND hwndCB = GetControl(IDC_DEVGEN_PROFILELIST);

            DWORD ConfigFlags;
            
            if (!m_pDevice->GetConfigFlags(&ConfigFlags)) {
            
                ConfigFlags = 0;
            }

            //
            // only want the disabled bit
            //
            ConfigFlags &= CONFIGFLAG_DISABLED;

            //
            // rebuild the profile list.
            //
            if (m_pHwProfileList) {
            
                delete m_pHwProfileList;
            }

            m_pHwProfileList = new CHwProfileList();

            if (m_pHwProfileList->Create(m_pDevice, ConfigFlags))
            {
                ComboBox_ResetContent(hwndCB);

                //
                // Get the current device usage
                //
                if (m_pDevice->IsStateDisabled()) {

                    if ((m_pHwProfileList->GetCount() > 1) && ConfigFlags) {

                        m_CurrentDeviceUsage = DEVICE_DISABLE_GLOBAL;
                    
                    } else {

                        m_CurrentDeviceUsage = DEVICE_DISABLE;
                    }

                } else {

                    m_CurrentDeviceUsage = DEVICE_ENABLE;
                }


                //
                // Always add the Enable item
                //
                String Enable;
                
                Enable.LoadString(g_hInstance, IDS_ENABLE_CURRENT);
                ComboBox_AddString(hwndCB, Enable);

                //
                // Add the disable items. There will either be one disable
                // item if there is only one hardware profile or two if there
                // are more than one hardware profile.
                //
                if (m_pHwProfileList->GetCount() > 1) {

                    String DisableInCurrent;
                    DisableInCurrent.LoadString(g_hInstance, IDS_DISABLE_IN_PROFILE);
                    ComboBox_AddString(hwndCB, DisableInCurrent);

                    String DisableGlobal;
                    DisableGlobal.LoadString(g_hInstance, IDS_DISABLE_GLOBAL);
                    ComboBox_AddString(hwndCB, DisableGlobal);

                } else {

                    String Disable;
                    Disable.LoadString(g_hInstance, IDS_DISABLE_CURRENT);
                    ComboBox_AddString(hwndCB, Disable);
                }

                ComboBox_SetCurSel(hwndCB, m_CurrentDeviceUsage);
            }
        }

        //
        // If this is a remote computer or the user does not have SE_LOAD_DRIVER_NAME
        // privileges then disable the enable/disable drop down list along with the
        // TroubleShooter button.
        //
        if (!m_pDevice->m_pMachine->IsLocal() || 
            !g_HasLoadDriverNamePrivilege)
        {
            ::EnableWindow(GetControl(IDC_DEVGEN_PROFILELIST), FALSE);
            ::EnableWindow(GetControl(IDC_DEVGEN_TROUBLESHOOTING), FALSE);
        }

        //
        // Check if we need to autolauch the troubleshooter
        //
        if (m_pDevice->m_pMachine->IsLocal() &&
            g_HasLoadDriverNamePrivilege &&
            m_pDevice->m_bLaunchTroubleShooter) {

            m_pDevice->m_bLaunchTroubleShooter = FALSE;
            ::PostMessage(m_hDlg, WM_COMMAND, MAKELONG(IDC_DEVGEN_TROUBLESHOOTING, BN_CLICKED, ), 0);
        }

    }
    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_hDlg, 0, 0, 0);
    }
}

BOOL
CDeviceGeneralPage::OnQuerySiblings(
    WPARAM wParam,
    LPARAM lParam
    )
{
    DMQUERYSIBLINGCODE Code =  (DMQUERYSIBLINGCODE)wParam;
    
    if (QSC_TO_FOREGROUND == Code)
    {
        HWND hwndSheet;
        
        hwndSheet = m_pDevice->m_psd.GetWindowHandle();
        
        if (GetForegroundWindow() != hwndSheet)
        {
            SetForegroundWindow(hwndSheet);
        }
        
        SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, 1);
        return TRUE;
    }

    return CPropSheetPage::OnQuerySiblings(wParam, lParam);
}


BOOL
CDeviceGeneralPage::OnCommand(
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (BN_CLICKED == HIWORD(wParam) &&
        IDC_DEVGEN_TROUBLESHOOTING == LOWORD(wParam)) {

        BOOL fChanged = FALSE;
        
        if (m_pProblemAgent) {

            fChanged = m_pProblemAgent->FixIt(GetParent(m_hDlg));
        }
        
        if (fChanged) {

            m_pDevice->PropertyChanged();
            m_pDevice->GetClass()->PropertyChanged();
            m_pDevice->m_pMachine->DiTurnOnDiFlags(*m_pDevice, DI_PROPERTIES_CHANGE);
            UpdateControls();
            PropSheet_SetTitle(GetParent(m_hDlg), PSH_PROPTITLE, m_pDevice->GetDisplayName());
            PropSheet_CancelToClose(GetParent(m_hDlg));

            //
            // ISSUE: JasonC 2/7/2000
            //
            // A refresh on m_pDevice->m_pMachine is necessary here.
            // Since we are running on a different thread and each
            // property page may have cached the HDEVINFO and the
            // SP_DEVINFO_DATA, refresh on the CMachine object can not
            // be done here. The problem is worsen by the fact that
            // user can go back to the device tree and work on the tree
            // while this property sheet is still up.
            // It would be nice if MMC would support modal dialog boxes. 
            //
        }
    }

    return FALSE;
}

BOOL
CDeviceGeneralPage::OnHelp(
    LPHELPINFO pHelpInfo
    )
{
    WinHelp((HWND)pHelpInfo->hItemHandle, DEVMGR_HELP_FILE_NAME, HELP_WM_HELP,
        (ULONG_PTR)g_a103HelpIDs);
    return FALSE;
}


BOOL
CDeviceGeneralPage::OnContextMenu(
    HWND hWnd,
    WORD xPos,
    WORD yPos
    )
{
    WinHelp(hWnd, DEVMGR_HELP_FILE_NAME, HELP_CONTEXTMENU,
        (ULONG_PTR)g_a103HelpIDs);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\devmgr.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    dllinit.cpp

Abstract:

    This module implements the dll related function

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "devmgr.h"
#include "factory.h"

LPCTSTR DEVMGR_DEVICEID_SWITCH  = TEXT("DMDeviceId");
LPCTSTR DEVMGR_MACHINENAME_SWITCH = TEXT("DMMachineName");
LPCTSTR DEVMGR_COMMAND_SWITCH      = TEXT("DMCommand");

//
// DLL main entry point
// INPUT:
//  HINSTANCE hInstance -- module instance handle
//  DWORD     dwReason  -- the reason why we are called.
//  LPVOID    lpReserved -- no used here

BOOL
DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:

        // we do not need thread attach/detach calls
        DisableThreadLibraryCalls(hInstance);

        SHFusionInitializeFromModule(hInstance);

        // do must be done
        InitCommonControls();

        INITCOMMONCONTROLSEX icce;
        
        icce.dwSize = sizeof(icce);
        icce.dwICC = ICC_DATE_CLASSES;
        InitCommonControlsEx(&icce);

        // initiailze our global stuff
        InitGlobals(hInstance);

        break;

    case DLL_PROCESS_DETACH:
        // do the clean up here.....
        SHFusionUninitialize();
        break;
    }
    return(TRUE);
}

BOOL InitGlobals(
    HINSTANCE hInstance
    )
{
    g_hInstance = hInstance;
    
    // preload memory allocation error message
    TCHAR tszTemp[256];
    ::LoadString(hInstance, IDS_ERROR_NOMEMORY, tszTemp, ARRAYLEN(tszTemp));
    g_MemoryException.SetMessage(tszTemp);
    ::LoadString(hInstance, IDS_NAME_DEVMGR, tszTemp, ARRAYLEN(tszTemp));
    g_MemoryException.SetCaption(tszTemp);
    
    try
    {
        //preload strings
        g_strDevMgr.LoadString(hInstance, IDS_NAME_DEVMGR);

        // parse the command line and establish machine name and etc
        CDMCommandLine CmdLine;
        CmdLine.ParseCommandLine(GetCommandLine());
        g_strStartupMachineName = CmdLine.GetMachineName();
        g_strStartupDeviceId = CmdLine.GetDeviceId();
        g_strStartupCommand = CmdLine.GetCommand();
    }

    catch (CMemoryException* e)
    {
        e->ReportError();
        e->Delete();
        return FALSE;
    }

    return TRUE;
}

//
// Overloaded allocation operators
//
void * __cdecl operator new(
    size_t size)
{
    return ((void *)LocalAlloc(LPTR, size));
}

void __cdecl operator delete(
    void *ptr)
{
    LocalFree(ptr);
}

__cdecl _purecall(void)
{
    return (0);
}


//
// Standard APIs for a OLE server. They are all routed to CClassFactory
// support functions
//
//

STDAPI
DllRegisterServer()
{
    return CClassFactory::RegisterAll();
}

STDAPI
DllUnregisterServer()
{
    return CClassFactory::UnregisterAll();
}


STDAPI
DllCanUnloadNow()
{
    return CClassFactory::CanUnloadNow();
}


STDAPI
DllGetClassObject(
    REFCLSID rclsid,
    REFIID   riid,
    void**   ppv
    )
{
    return CClassFactory::GetClassObject(rclsid, riid, ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\devrmdlg.h ===
// devrmdlg.h : header file
//

/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    devrmdlg.h

Abstract:

    header file for devrmdlg.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/

//
// help topic ids
//

#define IDH_DISABLEHELP (DWORD(-1))
#define idh_devmgr_confirmrremoval_listbox  210100  // Confirm Device Removal: "" (Static)
#define idh_devmgr_confirmremoval_all   210110  // Confirm Device Removal: "Remove from &all configurations." (Button)
#define idh_devmgr_confirmremoval_specific  210120  // Confirm Device Removal: "Remove from &specific configuration." (Button)
#define idh_devmgr_confirmremoval_configuration 210130  // Confirm Device Removal: "" (ComboBox)


/////////////////////////////////////////////////////////////////////////////
// CRemoveDevDlg dialog

class CRemoveDevDlg : public CDialog
{
public:
    CRemoveDevDlg(CDevice* pDevice)
    : CDialog(IDD_REMOVE_DEVICE),
      m_pDevice(pDevice)
    {}
    virtual BOOL OnInitDialog();
    virtual void OnCommand(WPARAM wParam, LPARAM lParam);
    virtual BOOL OnDestroy();
    virtual BOOL OnHelp(LPHELPINFO pHelpInfo);
    virtual BOOL OnContextMenu(HWND hWnd, WORD xPos, WORD yPos);
private:
    void OnOk();
    CDevice*        m_pDevice;
    BOOL IsRemoveSubtreeOk(CDevice* pDevice, PSP_REMOVEDEVICE_PARAMS prmdParams);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\devpopg.h ===
// devpopg.h : header file
//

#ifndef __DEVPOPG_H__
#define __DEVPOPG_H__

/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    devpopg.h

Abstract:

    header file for devpopg.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "proppage.h"
#include "wmium.h"
#include "wdmguid.h"
#include "ndisguid.h"

//
// help topic ids
//
#define IDH_DISABLEHELP                     (DWORD(-1))
#define IDH_DEVMGR_PWRMGR_WAKEENABLE        2003170
#define IDH_DEVMGR_PWRMGR_MGMT_WAKEENABLE   2003185
#define IDH_DEVMGR_PWRMGR_DEVICEENABLE      2003180


typedef struct tagPowerTimeouts {
    ULONG   ConservationIdleTime;
    ULONG   PerformanceIdleTime;
} DM_POWER_DEVICE_TIMEOUTS, *PDM_POWER_DEVICE_TIMEOUTS;

class CPowerEnable {

public:
    CPowerEnable(const GUID& wmiGuid, ULONG DataBlockSize)
    : m_hWmiBlock(INVALID_HANDLE_VALUE),
    m_WmiInstDataSize(0), m_pWmiInstData(NULL),
    m_DataBlockSize(DataBlockSize)
    {
        m_wmiGuid = wmiGuid;
        m_DevInstId[0] = _T('\0');
    }

    virtual ~CPowerEnable()
    {
        Close();
    }
    BOOL IsOpened()
    {
        return INVALID_HANDLE_VALUE != m_hWmiBlock;
    }
    BOOL Get(BOOLEAN& fEnabled);
    BOOL Set(BOOLEAN fEnable);
    BOOL Open(LPCTSTR DeviceId);
    BOOL Close()
    {
        if (INVALID_HANDLE_VALUE != m_hWmiBlock) {
            WmiCloseBlock(m_hWmiBlock);
        }

        m_hWmiBlock = INVALID_HANDLE_VALUE;
        m_DevInstId[0] = _T('\0');

        if (m_pWmiInstData) {

            delete [] m_pWmiInstData;
            m_pWmiInstData = NULL;
        }

        m_WmiInstDataSize = 0;

        return TRUE;
    }
    operator GUID&()
    {
        return m_wmiGuid;
    }

protected:
    WMIHANDLE   m_hWmiBlock;
    ULONG       m_Version;
    GUID        m_wmiGuid;
    ULONG       m_WmiInstDataSize;
    BYTE*       m_pWmiInstData;
    ULONG       m_DataBlockSize;
    TCHAR       m_DevInstId[MAX_DEVICE_ID_LEN + 2];
};

class CPowerShutdownEnable : public CPowerEnable {
public:
    CPowerShutdownEnable() : CPowerEnable(GUID_POWER_DEVICE_ENABLE, sizeof(BOOLEAN))
    {}
    // override dtor is not necessary
};

class CPowerWakeEnable : public CPowerEnable {
public:
    CPowerWakeEnable() : CPowerEnable(GUID_POWER_DEVICE_WAKE_ENABLE, sizeof(BOOLEAN))
    {}
    // override dtor is not necessary
};

class CPowerWakeMgmtEnable : public CPowerEnable {
public:
    CPowerWakeMgmtEnable() : CPowerEnable(GUID_NDIS_WAKE_ON_MAGIC_PACKET_ONLY, sizeof(BOOLEAN))
    {}
    // override dtor is not necessary
};

class CDevicePowerMgmtPage : public CPropSheetPage {
public:
    CDevicePowerMgmtPage() :
    m_pDevice(NULL),
    CPropSheetPage(g_hInstance, IDD_DEVPOWER_PAGE)
    {}
    ~CDevicePowerMgmtPage()
    {}
    HPROPSHEETPAGE Create(CDevice* pDevice)
    {
        ASSERT(pDevice);
        m_pDevice = pDevice;
        // override PROPSHEETPAGE structure here...
        m_psp.lParam = (LPARAM)this;
        return CreatePage();
    }

protected:
    virtual BOOL OnInitDialog(LPPROPSHEETPAGE ppsp);
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    virtual BOOL OnApply();
    virtual void UpdateControls(LPARAM lParam = 0);
    virtual BOOL OnHelp(LPHELPINFO pHelpInfo);
    virtual BOOL OnContextMenu(HWND hWnd, WORD xPos, WORD yPos);
private:
    CDevice*    m_pDevice;
    CPowerShutdownEnable m_poShutdownEnable;
    CPowerWakeEnable m_poWakeEnable;
    CPowerWakeMgmtEnable m_poWakeMgmtEnable;
};

#endif // _DEVPOPG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\devrmdlg.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    devrmdlg.cpp

Abstract:

    This module implements CRemoveDevDlg -- device removing dialog box

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "devmgr.h"
#include "hwprof.h"
#include "devrmdlg.h"

//
// help topic ids
//
const DWORD g_a210HelpIDs[]=
{
        IDC_REMOVEDEV_ICON,     IDH_DISABLEHELP,        // Confirm Device Removal: "" (Static)
        IDC_REMOVEDEV_DEVDESC,  IDH_DISABLEHELP,        // Confirm Device Removal: "" (Static)
        IDC_REMOVEDEV_WARNING,  IDH_DISABLEHELP,        // Confirm Device Removal: "" (Static)
        0, 0
};

//
// CRemoveDevDlg implementation
//
BOOL CRemoveDevDlg::OnInitDialog() 
{
    SetDlgItemText(m_hDlg, IDC_REMOVEDEV_DEVDESC, m_pDevice->GetDisplayName());
    HICON hIconOld;
    hIconOld = (HICON)SendDlgItemMessage(m_hDlg, IDC_REMOVEDEV_ICON,
                                         STM_SETICON,
                                         (WPARAM)(m_pDevice->LoadClassIcon()),
                                         0
                                         );
    if (hIconOld)
        DestroyIcon(hIconOld);

    try
    {
        String str;
        str.LoadString(g_hInstance, IDS_REMOVEDEV_WARN);
        SetDlgItemText(m_hDlg, IDC_REMOVEDEV_WARNING, str);
    }
    catch (CMemoryException* e)
    {
        e->Delete();
        return FALSE;
    }

    return TRUE;
}

void
CRemoveDevDlg::OnCommand(
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (BN_CLICKED == HIWORD(wParam))
    {
        if (IDOK == LOWORD(wParam))
        {
            OnOk();
        }
        
        else if (IDCANCEL == LOWORD(wParam))
        {
            EndDialog(m_hDlg, IDCANCEL);
        }
    }
}

void CRemoveDevDlg::OnOk()
{
    SP_REMOVEDEVICE_PARAMS rmdParams;
    int hwpfIndex;
    BOOL Continue = TRUE;

    CHwProfile* phwpf;
    rmdParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    rmdParams.ClassInstallHeader.InstallFunction = DIF_REMOVE;

    HCURSOR hCursorOld;
    hCursorOld = SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT)));
    
    //
    // Uninstall does not apply to specific profiles -- it is global.
    //
    rmdParams.Scope = DI_REMOVEDEVICE_GLOBAL;
    rmdParams.HwProfile = 0;
    
    //
    // walk down the tree and remove all of this device's children
    //
    if (m_pDevice->GetChild() &&
        !IsRemoveSubtreeOk(m_pDevice->GetChild(), &rmdParams))
    {
        //
        // Children refuse the removal. Cancel the removal.
        //
        MsgBoxParam(m_hDlg, IDS_DESCENDANTS_VETO, 0, MB_OK | MB_ICONINFORMATION);
        EndDialog(m_hDlg, IDCANCEL);
        return;
    }

    SP_DEVINSTALL_PARAMS dip;
    dip.cbSize = sizeof(dip);
    m_pDevice->m_pMachine->DiSetClassInstallParams(*m_pDevice,
                       &rmdParams.ClassInstallHeader,
                       sizeof(rmdParams));
    
    BOOL RemovalOK;
    
    //
    // Either this device has no children or the children has no
    // objection on removal. Remove it.
    //
    RemovalOK = m_pDevice->m_pMachine->DiCallClassInstaller(DIF_REMOVE, *m_pDevice);
    
    if (hCursorOld)
    {
        SetCursor(hCursorOld);
    }
    
    m_pDevice->m_pMachine->DiSetClassInstallParams(*m_pDevice, NULL, 0);
    
    if (RemovalOK)
    {
        EndDialog(m_hDlg, IDOK);
    }
    
    else
    {
        //
        // Can not removed the device, return Cancel so that
        // the caller know what is going on.
        //
        MsgBoxParam(m_hDlg, IDS_UNINSTALL_FAILED, 0, MB_OK | MB_ICONINFORMATION);
        EndDialog(m_hDlg, IDCANCEL);
    }
}

//
// This function walks the substree started with the given CDevice to
// see if it is ok to removed the CDevice.
// INPUT:
//      pDevice  -- the device
//      prmdParams  -- parameter used to call the setupapi
// OUTPUT:
//      TRUE -- it is ok to remove
//      FALSE -- it is NOT ok to remove
BOOL
CRemoveDevDlg::IsRemoveSubtreeOk(
    CDevice* pDevice,
    PSP_REMOVEDEVICE_PARAMS prmdParams
    )
{
    BOOL Result = TRUE;


    HDEVINFO hDevInfo;
    while (Result && pDevice)
    {
        //
        // if the device has children, remove all of them.
        //
        if (Result && pDevice->GetChild())
        {
            Result = IsRemoveSubtreeOk(pDevice->GetChild(), prmdParams);
        }
        
        //
        // create a new HDEVINFO just for this device -- we do not want
        // to change anything in the main device tree maintained by CMachine
        //
        hDevInfo = pDevice->m_pMachine->DiCreateDeviceInfoList(NULL, m_hDlg);
        
        if (INVALID_HANDLE_VALUE == hDevInfo)
        {
            return FALSE;
        }
        
        SP_DEVINFO_DATA DevData;
        DevData.cbSize = sizeof(DevData);
        CDevInfoList DevInfoList(hDevInfo, m_hDlg);
        
        //
        // include the device in the newly created hdevinfo
        //
        DevInfoList.DiOpenDeviceInfo(pDevice->GetDeviceID(), m_hDlg, 0,
                                     &DevData);

        DevInfoList.DiSetClassInstallParams(&DevData,
                                            &prmdParams->ClassInstallHeader,
                                            sizeof(SP_REMOVEDEVICE_PARAMS)
                                            );
        
        //
        // remove this devnode.
        //
        Result = DevInfoList.DiCallClassInstaller(DIF_REMOVE, &DevData);
        DevInfoList.DiSetClassInstallParams(&DevData, NULL, 0);
        
        //
        // continue the query on all the siblings
        //
        pDevice = pDevice->GetSibling();
    }

    return Result;
}

BOOL
CRemoveDevDlg::OnDestroy()
{
    HICON hIcon;

    if(hIcon = (HICON)SendDlgItemMessage(m_hDlg, IDC_REMOVEDEV_ICON, STM_GETICON, 0, 0)) {
        DestroyIcon(hIcon);
    }
    
    return FALSE;
}

BOOL
CRemoveDevDlg::OnHelp(
    LPHELPINFO pHelpInfo
    )
{
    WinHelp((HWND)pHelpInfo->hItemHandle, DEVMGR_HELP_FILE_NAME, HELP_WM_HELP,
            (ULONG_PTR)g_a210HelpIDs);
    return FALSE;
}

BOOL
CRemoveDevDlg::OnContextMenu(
    HWND hWnd,
    WORD xPos,
    WORD yPos
    )
{
    WinHelp(hWnd, DEVMGR_HELP_FILE_NAME, HELP_CONTEXTMENU,
            (ULONG_PTR)g_a210HelpIDs);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\devmgr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       devmgr.h
//
//--------------------------------------------------------------------------

#ifndef __DEVMGR_H_
#define __DEVMGR_H_

//
// header files from public tree
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windowsx.h>
#include <tchar.h>
#include <new.h>
#include <stdio.h>
#include <stdlib.h>
#include <prsht.h>
#include <prshtp.h>
#include <commctrl.h>
#include <commctrl.h>
#include <shellapi.h>
#include <shlwapi.h>
#include <shlapip.h>
#include <ole2.h>
#include <mmc.h>
#include <objsel.h>
#include <htmlhelp.h>
#include <wincrypt.h>
#include <mscat.h>
#include <softpub.h>
#include <wintrust.h>
#include <shfusion.h>

extern "C" {
#include <commdlg.h>
#include <cfgmgr32.h>
#include <setupapi.h>
#include <spapip.h>
#include <regstr.h>
#include <shimdb.h>
}

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>


#define ARRAYLEN(array)     (sizeof(array) / sizeof(array[0]))


typedef enum tagCookieType
{
    COOKIE_TYPE_SCOPEITEM_DEVMGR = 0,
    COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ,
    COOKIE_TYPE_RESULTITEM_RESOURCE_DMA,
    COOKIE_TYPE_RESULTITEM_RESOURCE_IO,
    COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY,
    COOKIE_TYPE_RESULTITEM_COMPUTER,
    COOKIE_TYPE_RESULTITEM_DEVICE,
    COOKIE_TYPE_RESULTITEM_CLASS,
    COOKIE_TYPE_RESULTITEM_RESTYPE,
    COOKIE_TYPE_UNKNOWN
} COOKIE_TYPE, *PCOOKIE_TYPE;


#define COOKIE_FLAGS_EXPANDED           0x00000001
#define COOKIE_FLAGS_SELECTED           0x00000002

const int TOTAL_COOKIE_TYPES = COOKIE_TYPE_RESULTITEM_RESTYPE - COOKIE_TYPE_SCOPEITEM_DEVMGR + 1;

const int NODETYPE_FIRST =      (int)COOKIE_TYPE_SCOPEITEM_DEVMGR;
const int NODETYPE_LAST  =      (int)COOKIE_TYPE_RESULTITEM_RESTYPE;


typedef struct tagNodeInfo {
    COOKIE_TYPE     ct;
    int             idsName;
    int             idsFormat;
    GUID            Guid;
    TCHAR*          GuidString;
} NODEINFO, *PNODEINFO;


//
// Device manager needs to keep track of the largest problem code that it 
// currently knows about.  Using the NUM_CM_PROB defined in cfg.h is a bad
// idea because if more problem codes are added that device manager doesn't
// know about it will cause us to overrun the end of the CMPROBLEM_INFO array.
//
// Note that the +2 are for
//  1) the working case (0 index in the array)
//  2) the unknown problem case (last problem + 1 index in the array)
//                                                                  

#define DEVMGR_NUM_CM_PROB      0x33

#if DEVMGR_NUM_CM_PROB != (NUM_CM_PROB + 1)
#error Update DEVMGR_NUM_CM_PROB and update tswizard.cpp and globals.cpp.
#endif

#define PIF_CODE_EMBEDDED       0x01

typedef struct tagProblemInfo {
    int     StringId;
    DWORD   Flags;
} PROBLEMINFO, *PPROBLEMINFO;

typedef struct tagInternalData {
    DATA_OBJECT_TYPES   dot;
    COOKIE_TYPE ct;
    MMC_COOKIE  cookie;
} INTERNAL_DATA, *PINTERNAL_DATA;

typedef enum tagTreeType {
    TREE_TYPE_CLASS = 0,
    TREE_TYPE_CONNECTION
} TREE_TYPE, *PTREE_TYPE;

typedef enum tagDriverType{
    DRIVER_TYPE_CLASS = 0,
    DRIVER_TYPE_COMPATIBLE
} DRIVER_TYPE, *PDRIVER_TYPE;


typedef enum tagPropertyChangeType
{
    PCT_STARTUP_INFODATA = 0,
    PCT_DEVICE,
    PCT_CLASS
}PROPERTY_CHANGE_TYPE, *PPROPERTY_CHANGE_TYPE;

typedef struct tagPropertyChangeInfo
{
    PROPERTY_CHANGE_TYPE Type;
    BYTE                 InfoData[1];
}PROPERTY_CHANGE_INFO, *PPROPERTY_CHANGE_INFO;

typedef struct tagStartupInfoData
{
    DWORD           Size;
    COOKIE_TYPE     ct;
    TCHAR           MachineName[MAX_PATH + 3];
}STARTUP_INFODATA, *PSTARTUP_INFODATA;

typedef struct tagDeviceInfoData
{
    DWORD           Size;
    TCHAR           DeviceId[MAX_DEVICE_ID_LEN];
} DEVICE_INFODATA, *PDEVICE_INFODATA;

typedef struct tagClassInfoData
{
    DWORD           Size;
    GUID            ClassGuid;
} CLASS_INFODATA, *PCLASS_INFODATA;


typedef enum tagdmQuerySiblingCode
{
    QSC_TO_FOREGROUND = 0,
    QSC_PROPERTY_CHANGED,
}DMQUERYSIBLINGCODE, *PDMQUERYSIBLINGCODE;

//
// private header files
//

#include "..\inc\tvintf.h"
#include "resource.h"
#include "prndlg.h"
#include "globals.h"
#include "utils.h"
#include "ccookie.h"
#include "machine.h"
#include "compdata.h"
#include "componet.h"
#include "cnode.h"
#include "cfolder.h"
#include "dataobj.h"

BOOL InitGlobals(HINSTANCE hInstance);

extern LPCTSTR DEVMGR_DEVICEID_SWITCH;
extern LPCTSTR DEVMGR_MACHINENAME_SWITCH;
extern LPCTSTR DEVMGR_COMMAND_SWITCH;

void * __cdecl operator new(size_t size);
void __cdecl operator delete(void *ptr);
__cdecl _purecall(void);


STDAPI
DllRegisterServer();

STDAPI
DllUnregisterServer();

STDAPI
DllCanUnloadNow();

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID iid, void** ppv);


//
// CDMCommandLine class defination
//

class CDMCommandLine : public CCommandLine
{
public:
    CDMCommandLine() : m_WaitForDeviceId(FALSE),
                       m_WaitForMachineName(FALSE),
                       m_WaitForCommand(FALSE)
    {}
    virtual void ParseParam(LPCTSTR lpszParam, BOOL bFlag, BOOL bLast)
    {
        if (bFlag)
        {
            if (!lstrcmpi(DEVMGR_DEVICEID_SWITCH, lpszParam))
                m_WaitForDeviceId = TRUE;
            else if (!lstrcmpi(DEVMGR_MACHINENAME_SWITCH, lpszParam))
                m_WaitForMachineName = TRUE;
            else if (!lstrcmpi(DEVMGR_COMMAND_SWITCH, lpszParam))
                m_WaitForCommand = TRUE;
        }
        else
        {
            if (m_WaitForDeviceId) {
                m_strDeviceId = lpszParam;
                m_WaitForDeviceId = FALSE;
            }
            else if (m_WaitForMachineName) {
                m_strMachineName = lpszParam;
                m_WaitForMachineName = FALSE;
            }
            else if (m_WaitForCommand) {

                m_strCommand = lpszParam;
                m_WaitForCommand = FALSE;
            }
        }
    }
    LPCTSTR GetDeviceId()
    {
        return m_strDeviceId.IsEmpty() ? NULL : (LPCTSTR)m_strDeviceId;
    }
    LPCTSTR GetMachineName()
    {
        return m_strMachineName.IsEmpty() ? NULL : (LPCTSTR)m_strMachineName;
    }
    LPCTSTR GetCommand()
    {
        return m_strCommand.IsEmpty() ? NULL : (LPCTSTR)m_strCommand;
    }
private:
    String      m_strDeviceId;
    String      m_strMachineName;
    String      m_strCommand;
    BOOL        m_WaitForDeviceId;
    BOOL        m_WaitForMachineName;
    BOOL        m_WaitForCommand;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\factory.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    factory.cpp

Abstract:

    This module implements CClassFactory class

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "devmgr.h"
#include "factory.h"
#include "about.h"



const TCHAR* const REG_MMC_SNAPINS              = TEXT("Software\\Microsoft\\MMC\\Snapins");
const TCHAR* const REG_MMC_NODETYPE             = TEXT("Software\\Microsoft\\MMC\\NodeTypes");
const TCHAR* const MMC_NAMESTRING               = TEXT("NameString");
const TCHAR* const MMC_NAMESTRINGINDIRECT       = TEXT("NameStringIndirect");
const TCHAR* const MMC_PROVIDER                 = TEXT("Provider");
const TCHAR* const MMC_VERSION                  = TEXT("Version");
const TCHAR* const MMC_NODETYPES                = TEXT("NodeTypes");
const TCHAR* const MMC_STANDALONE               = TEXT("StandAlone");
const TCHAR* const MMC_EXTENSIONS               = TEXT("Extensions");
const TCHAR* const MMC_NAMESPACE                = TEXT("NameSpace");
const TCHAR* const MMC_ABOUT                    = TEXT("About");
const TCHAR* const REG_INPROCSERVER32           = TEXT("InprocServer32");
const TCHAR* const REG_THREADINGMODEL           = TEXT("ThreadingModel");
const TCHAR* const REG_CLSID                    = TEXT("CLSID");
const TCHAR* const REG_PROGID                   = TEXT("ProgId");
const TCHAR* const REG_VERSIONINDEPENDENTPROGID = TEXT("VersionIndependentProgId");
const TCHAR* const APARTMENT                    = TEXT("Apartment");
//
// CClassFactory implmentation
//


LONG CClassFactory::s_Locks = 0;
LONG CClassFactory::s_Objects = 0;

ULONG
CClassFactory::AddRef()
{
    ::InterlockedIncrement((LONG*)&m_Ref);
    
    return m_Ref;
}

ULONG
CClassFactory::Release()
{
    ::InterlockedDecrement((LONG*)&m_Ref);
    
    if (!m_Ref)
    {
        delete this;
        return 0;
    }
    
    return m_Ref;
}

STDMETHODIMP
CClassFactory::QueryInterface(
    REFIID riid,
    LPVOID*  ppv
    )
{

    if (!ppv)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown *)(IClassFactory *)this;
    }

    else if (IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (IUnknown *)(IClassFactory *)this;
    }

    else
    {
        hr = E_NOINTERFACE;
    }

    if (SUCCEEDED(hr))
    {
        AddRef();
    }

    else
    {
        *ppv = NULL;
    }

    return hr;
}


STDMETHODIMP
CClassFactory::CreateInstance(
    IUnknown    *pUnkOuter,
    REFIID       riid,
    LPVOID  *ppv
    )
{

    if (!ppv)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    *ppv = NULL;

    if (pUnkOuter != NULL)
    {
        hr = CLASS_E_NOAGGREGATION;
    }

    try
    {
        switch (m_ClassType)
        {
        case DM_CLASS_TYPE_SNAPIN:
            {
                // create the factory with the request class(class type).
                // When a new OLE object is created, it initializes its
                // ref count to 1. We do a release right after the QI
                // so that if the QI failed, the object will be self-destructed
                CComponentData* pCompData = new CComponentDataPrimary();
                hr = pCompData->QueryInterface(riid, ppv);
                pCompData->Release();
                break;
            }
            
        case DM_CLASS_TYPE_SNAPIN_EXTENSION:
            {
                // create the factory with the request class(class type).
                // When a new OLE object is created, it initializes its
                // ref count to 1. We do a release right after the QI
                // so that if the QI failed, the object will be self-destructed
                CComponentData* pCompData = new CComponentDataExtension();
                hr = pCompData->QueryInterface(riid, ppv);
                pCompData->Release();
                break;
            }
            
        case DM_CLASS_TYPE_SNAPIN_ABOUT:
            {
                // create the factory with the request class(class type).
                // When a new OLE object is created, it initializes its
                // ref count to 1. We do a release right after the QI
                // so that if the QI failed, the object will be self-destructed
                CDevMgrAbout* pAbout = new CDevMgrAbout;
                hr = pAbout->QueryInterface(riid, ppv);
                pAbout->Release();
                break;
            }
            
        default:
            {
                hr = E_NOINTERFACE;
            }
        }
    }

    catch (CMemoryException* e)
    {
        hr = E_OUTOFMEMORY;
        e->Delete();
    }

    return hr;
}



STDMETHODIMP
CClassFactory::LockServer(
    BOOL fLock
    )
{
    if (fLock)
    {
        ::InterlockedIncrement((LONG*)&s_Locks);
    }
    
    else
    {
        ::InterlockedDecrement((LONG*)&s_Locks);
    }
    
    return S_OK;
}

HRESULT
CClassFactory::CanUnloadNow()
{
    return (s_Objects || s_Locks) ? S_FALSE : S_OK;
}


//
// This function create a CClassFactory. It is mainly called
// by DllGetClassObject API
// INPUT:
//  rclsid  -- reference to the CLSID
//  riid    -- reference to the interface IID
//  ppv -- interface pointer holder
//
// OUTPUT:
//  S_OK if succeeded else standard OLE error code
//
//
HRESULT
CClassFactory::GetClassObject(
    REFCLSID rclsid,
    REFIID   riid,
    void**   ppv
    )
{
    if (!ppv)
    {
        return E_INVALIDARG;
    }

    *ppv = NULL;
    HRESULT hr = S_OK;
    DM_CLASS_TYPE ClassType;
    
    //
    // determine the class type so that CreateInstance will be
    // creating the right object. We use a single class factory
    // to create all the object types.
    //
    if (IsEqualCLSID(rclsid, CLSID_DEVMGR))
    {
        ClassType = DM_CLASS_TYPE_SNAPIN;
    }

    else if (IsEqualCLSID(rclsid, CLSID_DEVMGR_EXTENSION))
    {
        ClassType = DM_CLASS_TYPE_SNAPIN_EXTENSION;
    }

    else if (IsEqualCLSID(rclsid, CLSID_DEVMGR_ABOUT))
    {
        ClassType = DM_CLASS_TYPE_SNAPIN_ABOUT;
    }

    else
    {
        ClassType = DM_CLASS_TYPE_UNKNOWN;
        hr = E_NOINTERFACE;
    }

    if (SUCCEEDED(hr))
    {
        CClassFactory* pUnk;
        // guard memory allocation error because we do not want
        // to cause an execption here.
        
        try
        {
            // create the factory with the request class(class type).
            // When a new OLE object is created, it initializes its
            // ref count to 1. We do a release right after the QI
            // so that if the QI failed, the object will be self-destructed
    
            pUnk = new CClassFactory(ClassType);
            hr = pUnk->QueryInterface(riid, ppv);
            pUnk->Release();
        }
        
        catch (CMemoryException* e)
        {
            e->Delete();
            hr = E_OUTOFMEMORY;
        }
    }
    
    return hr;
}

//
// This function registers the dll to MMC
//
HRESULT
CClassFactory::RegisterAll()
{
    BOOL Result;
    TCHAR szText[MAX_PATH];
    TCHAR ModuleName[MAX_PATH];
    GetModuleFileName(g_hInstance, ModuleName, ARRAYLEN(ModuleName));

    Result = FALSE;
    szText[0] = TEXT('\0');
    
    // first register standalone snapin CLSID
    CSafeRegistry regRootCLSID;
    
    if (regRootCLSID.Open(HKEY_CLASSES_ROOT, REG_CLSID))
    {
        CSafeRegistry regCLSID;
        
        // register our CLSID to HKEY_CLASS_ROOT\CLSID
        if (regCLSID.Create(regRootCLSID, CLSID_STRING_DEVMGR))
        {
            // write the description
            ::LoadString(g_hInstance, IDS_DESC_DEVMGR, szText, ARRAYLEN(szText));
            if (regCLSID.SetValue(NULL, szText))
            {
                CSafeRegistry regServer;
                
                if (regServer.Create(regCLSID, REG_INPROCSERVER32) &&
                    regServer.SetValue(NULL, ModuleName) &&
                    regServer.SetValue(REG_THREADINGMODEL, APARTMENT))
                {
                    CSafeRegistry regProgId;
                    
                    if (regProgId.Create(regCLSID, REG_PROGID) &&
                        regProgId.SetValue(NULL, PROGID_DEVMGR))
                    {
                        CSafeRegistry regVerIndProgId;
                        
                        if (regVerIndProgId.Create(regCLSID, REG_VERSIONINDEPENDENTPROGID))
                        {
                            Result = regVerIndProgId.SetValue(NULL, PROGID_DEVMGR);
                        }
                    }
                }
            }
        }
        
        if (Result)
        {
            regCLSID.Close();
            Result = FALSE;
            
            // register extension snapin CLSID
            if (regCLSID.Create(regRootCLSID, CLSID_STRING_DEVMGR_EXTENSION))
            {
                ::LoadString(g_hInstance, IDS_EXTENSION_DESC, szText, ARRAYLEN(szText));
                
                if (regCLSID.SetValue(NULL, szText))
                {
                    CSafeRegistry regServer;
                    
                    if (regServer.Create(regCLSID, REG_INPROCSERVER32)&&
                        regServer.SetValue(NULL, ModuleName) &&
                        regServer.SetValue(REG_THREADINGMODEL, APARTMENT))
                    {
                        CSafeRegistry regProgId;
                        
                        if (regProgId.Create(regCLSID, REG_PROGID) &&
                            regProgId.SetValue(NULL, PROGID_DEVMGREXT))
                        {
                            CSafeRegistry regVerIndProgId;
                            
                            if (regVerIndProgId.Create(regCLSID, REG_VERSIONINDEPENDENTPROGID))
                            {
                                Result = regVerIndProgId.SetValue(NULL, PROGID_DEVMGREXT);
                            }
                        }
                    }
                }
            }
        }

        if (Result)
        {
            regCLSID.Close();
            Result = FALSE;
            
            // register snapin about CLSID
            if (regCLSID.Create(regRootCLSID, CLSID_STRING_DEVMGR_ABOUT))
            {
                ::LoadString(g_hInstance, IDS_ABOUT_DEVMGR, szText, ARRAYLEN(szText));
                
                if (regCLSID.SetValue(NULL, szText))
                {
                    CSafeRegistry regServer;
                    
                    if (regServer.Create(regCLSID, REG_INPROCSERVER32)&&
                        regServer.SetValue(NULL, ModuleName) &&
                        regServer.SetValue(REG_THREADINGMODEL, APARTMENT))
                    {
                        CSafeRegistry regProgId;
                        
                        if (regProgId.Create(regCLSID, REG_PROGID) &&
                            regProgId.SetValue(NULL, PROGID_DEVMGR_ABOUT))
                        {
                            CSafeRegistry regVerIndProgId;
                            
                            if (regVerIndProgId.Create(regCLSID, REG_VERSIONINDEPENDENTPROGID))
                            {
                                Result = regVerIndProgId.SetValue(NULL, PROGID_DEVMGR_ABOUT);
                            }
                        }
                    }
                }
            }
        }
    }
    
    if (Result)
    {
        Result = FALSE;
        CSafeRegistry regSnapins;
        
        //
        // open mmc snapin subkey
        //
        if (regSnapins.Open(HKEY_LOCAL_MACHINE, REG_MMC_SNAPINS))
        {
            PNODEINFO pni = (PNODEINFO)&NodeInfo[COOKIE_TYPE_SCOPEITEM_DEVMGR];
            CSafeRegistry regDevMgr;
            
            if (regDevMgr.Create(regSnapins, CLSID_STRING_DEVMGR))
            {
                wsprintf(szText, TEXT("@%s,-%d"), ModuleName, IDS_DESC_DEVMGR);
                if (regDevMgr.SetValue(MMC_NAMESTRINGINDIRECT, szText))
                {
                    ::LoadString(g_hInstance, pni->idsName, szText, ARRAYLEN(szText));
                    
                    if (regDevMgr.SetValue(MMC_NAMESTRING, szText))
                    {
                        ::LoadString(g_hInstance, IDS_PROGRAM_PROVIDER, szText, ARRAYLEN(szText));
                        
                        if (regDevMgr.SetValue(MMC_PROVIDER, szText))
                        {
                            ::LoadString(g_hInstance, IDS_PROGRAM_VERSION, szText, ARRAYLEN(szText));
                            
                            if (regDevMgr.SetValue(MMC_VERSION, szText) &&
                                regDevMgr.SetValue(MMC_ABOUT, CLSID_STRING_DEVMGR_ABOUT))
                            {
                                //
                                // Let MMC knows that we are a standalone snapin --
                                // meaning we do not need any extension snapins for us
                                // to run.
                                //
                                CSafeRegistry regStandAlone;
                                Result = regStandAlone.Create(regDevMgr, MMC_STANDALONE);
                            }
                        }
                    }
                }
            }

            CSafeRegistry regMMCNodeTypes;
            
            if (Result)
            {
                // populate our nodes
                Result = regMMCNodeTypes.Open(HKEY_LOCAL_MACHINE, REG_MMC_NODETYPE);
                
                if (Result)
                {
                    CSafeRegistry regTheNode;
                    int i = NODETYPE_FIRST;
                    
                    do
                    {
                        PNODEINFO pni = (PNODEINFO) &NodeInfo[i];
                        Result = regTheNode.Create(regMMCNodeTypes, pni->GuidString);
                        regTheNode.Close();
                    } while (Result && ++i <= NODETYPE_LAST);
                }
            }
            
            if (Result)
            {
                // register as an extension to Computer management snapin
                CSafeRegistry regDevMgrExt;
                
                if (regDevMgrExt.Create(regSnapins, CLSID_STRING_DEVMGR_EXTENSION))
                {
                    ::LoadString(g_hInstance, IDS_EXTENSION_DESC, szText, ARRAYLEN(szText));
                    
                    if (regDevMgrExt.SetValue(MMC_NAMESTRING, szText))
                    {
                        ::LoadString(g_hInstance, IDS_PROGRAM_PROVIDER, szText, ARRAYLEN(szText));
                        
                        if (regDevMgrExt.SetValue(MMC_PROVIDER, szText))
                        {
                            ::LoadString(g_hInstance, IDS_PROGRAM_VERSION, szText, ARRAYLEN(szText));
                            
                            if (regDevMgrExt.SetValue(MMC_VERSION, szText) &&
                               regDevMgrExt.SetValue(MMC_ABOUT, CLSID_STRING_DEVMGR_ABOUT))
                            {
                                CSafeRegistry regSysTools;
                                
                                if (regSysTools.Open(regMMCNodeTypes, CLSID_STRING_SYSTOOLS))
                                {
                                    CSafeRegistry regExtensions;
                                    
                                    if (regExtensions.Open(regSysTools,MMC_EXTENSIONS))
                                    {
                                        CSafeRegistry regNameSpace;
                                        
                                        if (regNameSpace.Open(regExtensions, MMC_NAMESPACE))
                                        {
                                            // add our guid as a value of Name space
                                            Result = regNameSpace.SetValue(CLSID_STRING_DEVMGR_EXTENSION, szText);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    if (!Result)
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        UnregisterAll();
        return hr;
    }
    
    return S_OK;
}

//
// This function unregisters the dll from MMC
//
HRESULT
CClassFactory::UnregisterAll()
{

    HRESULT hr = S_OK;
    CSafeRegistry regSnapins;
    
    //
    // open mmc snapin subkey
    //
    if (regSnapins.Open(HKEY_LOCAL_MACHINE, REG_MMC_SNAPINS))
    {
        // remove devmgr subkey from MMC snapins main key
        // both primary and extension
        regSnapins.DeleteSubkey(CLSID_STRING_DEVMGR);
        regSnapins.DeleteSubkey(CLSID_STRING_DEVMGR_EXTENSION);
    
        // removed populated node types
        CSafeRegistry regMMCNodeTypes;
        
        if (regMMCNodeTypes.Open(HKEY_LOCAL_MACHINE, REG_MMC_NODETYPE))
        {
            for (int i = NODETYPE_FIRST; i <= NODETYPE_LAST; i++)
            {
                PNODEINFO pni = (PNODEINFO) &NodeInfo[i];
                regMMCNodeTypes.DeleteValue(pni->GuidString);
            }
            
            // remove from system tools
            CSafeRegistry regSysTools;
            
            if (regSysTools.Open(regMMCNodeTypes, CLSID_STRING_SYSTOOLS))
            {
                CSafeRegistry regExtensions;
                
                if (regExtensions.Open(regSysTools, MMC_EXTENSIONS))
                {
                    CSafeRegistry regNameSpace;
                    
                    if (regNameSpace.Open(regExtensions, MMC_NAMESPACE))
                    {
                        regNameSpace.DeleteValue(CLSID_STRING_DEVMGR_EXTENSION);
                    }
                }
            }
        }
    }

    // unregister from OLE
    CSafeRegistry regRootCLSID;
    
    if (regRootCLSID.Open(HKEY_CLASSES_ROOT, REG_CLSID))
    {
        regRootCLSID.DeleteSubkey(CLSID_STRING_DEVMGR);
        regRootCLSID.DeleteSubkey(CLSID_STRING_DEVMGR_EXTENSION);
        regRootCLSID.DeleteSubkey(CLSID_STRING_DEVMGR_ABOUT);
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\devpopg.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    devpopg.cpp

Abstract:

    This module implements CDevicePowerMgmtPage -- device power management
    property page

Author:

    William Hsieh (williamh) created

Revision History:


--*/
// devdrvpg.cpp : implementation file
//

#include "devmgr.h"
#include "devpopg.h"

extern "C" {
#include <initguid.h>
#include <wdmguid.h>
#include <devguid.h>
}


//
// help topic ids
//
const DWORD g_a15HelpIDs[]=
{
    IDC_DEVPOWER_DESC,  IDH_DISABLEHELP,
    IDC_DEVPOWER_ICON,  IDH_DISABLEHELP,
    IDC_DEVPOWER_WAKEENABLE,    IDH_DEVMGR_PWRMGR_WAKEENABLE,
    IDC_DEVPOWER_MGMT_WAKEENABLE, IDH_DEVMGR_PWRMGR_MGMT_WAKEENABLE,
    IDC_DEVPOWER_DEVICEENABLE, IDH_DEVMGR_PWRMGR_DEVICEENABLE,
    IDC_DEVPOWER_MESSAGE, IDH_DISABLEHELP,
    0,0

};

BOOL
CDevicePowerMgmtPage::OnInitDialog(
    LPPROPSHEETPAGE ppsp
    )
{
    //
    // Notify CPropSheetData about the page creation
    // the controls will be initialize in UpdateControls virtual function.
    //
    m_pDevice->m_psd.PageCreateNotify(m_hDlg);

    BOOLEAN Enabled;

    //
    // First see if the device is able to wake the system
    //
    if (m_poWakeEnable.Open(m_pDevice->GetDeviceID())) {
        
        m_poWakeEnable.Get(Enabled);
        ::SendMessage(GetControl(IDC_DEVPOWER_WAKEENABLE), BM_SETCHECK,
                      Enabled ? BST_CHECKED : BST_UNCHECKED, 0);

        EnableWindow(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE), Enabled);
    } else {
        
        EnableWindow(GetControl(IDC_DEVPOWER_WAKEENABLE), FALSE);
        ShowWindow(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE), FALSE);
    }

    //
    // See if the device can be turned off to save power
    //
    if (m_poShutdownEnable.Open(m_pDevice->GetDeviceID())) {
        
        m_poShutdownEnable.Get(Enabled);
        ::SendMessage(GetControl(IDC_DEVPOWER_DEVICEENABLE), BM_SETCHECK,
                      Enabled ? BST_CHECKED : BST_UNCHECKED, 0);
    } else {
        
        EnableWindow(GetControl(IDC_DEVPOWER_DEVICEENABLE), FALSE);
    }

    //
    // Special network card code.
    //
    GUID ClassGuid;
    m_pDevice->ClassGuid(ClassGuid);
    if (IsEqualGUID(ClassGuid, GUID_DEVCLASS_NET)) {

        if (m_poWakeMgmtEnable.Open(m_pDevice->GetDeviceID())) {
            
            m_poWakeMgmtEnable.Get(Enabled);
            ::SendMessage(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE), BM_SETCHECK,
                          Enabled ? BST_CHECKED : BST_UNCHECKED, 0);
        }

        //
        // This is a special case for network class devices.  Wake on Lan will
        // only work if the device is enabled for power management.  So, if the 
        // user unchecks the 'power manage this device' then we need to disable
        // the WOL and management stations controls.
        //
        if (BST_CHECKED == ::SendMessage(GetControl(IDC_DEVPOWER_DEVICEENABLE),
                                               BM_GETCHECK, 0, 0) ) {

            if (m_poWakeEnable.IsOpened()) {
                ::EnableWindow(GetControl(IDC_DEVPOWER_WAKEENABLE), TRUE);
            }

            if (m_poWakeMgmtEnable.IsOpened()) {
                //
                // The 'allow management stations to bring the computer out of standby'
                // option is only allowed if the 'Allow this device to bring the computer 
                // out of standby' option is checked.
                //
                if (m_poWakeEnable.IsOpened() &&
                    (BST_CHECKED == ::SendMessage(GetControl(IDC_DEVPOWER_WAKEENABLE),
                                                  BM_GETCHECK, 0, 0))) {
                    ::EnableWindow(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE), TRUE);
                } else {
                    ::EnableWindow(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE), FALSE);
                }
            }
        
        } else {

            ::EnableWindow(GetControl(IDC_DEVPOWER_WAKEENABLE), FALSE);
            ::EnableWindow(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE), FALSE);
        }
    } else {

        ShowWindow(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE), FALSE);
        EnableWindow(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE), FALSE);
    }

    return CPropSheetPage::OnInitDialog(ppsp);
}

BOOL
CDevicePowerMgmtPage::OnCommand(
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (LOWORD(wParam)) {
    
    case IDC_DEVPOWER_WAKEENABLE:
        if (BST_CHECKED == ::SendMessage(GetControl(IDC_DEVPOWER_WAKEENABLE),
                                               BM_GETCHECK, 0, 0) ) {

            ::EnableWindow(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE), TRUE);
        
        } else {

            ::EnableWindow(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE), FALSE);
        }
        break;

    case IDC_DEVPOWER_DEVICEENABLE:
        //
        // This is a special case for network class devices.  Wake on Lan will
        // only work if the device is enabled for power management.  So, if the 
        // user unchecks the 'power manage this device' then we need to disable
        // the WOL and management stations controls.
        //
        GUID ClassGuid;
        m_pDevice->ClassGuid(ClassGuid);
        if (IsEqualGUID(ClassGuid, GUID_DEVCLASS_NET)) {
        
            if (BST_CHECKED == ::SendMessage(GetControl(IDC_DEVPOWER_DEVICEENABLE),
                                                   BM_GETCHECK, 0, 0) ) {
    
                if (m_poWakeEnable.IsOpened()) {
                    ::EnableWindow(GetControl(IDC_DEVPOWER_WAKEENABLE), TRUE);
                }

                if (m_poWakeMgmtEnable.IsOpened()) {
                    //
                    // The 'allow management stations to bring the computer out of standby'
                    // option is only allowed if the 'Allow this device to bring the computer 
                    // out of standby' option is checked.
                    //
                    if (m_poWakeEnable.IsOpened() &&
                        (BST_CHECKED == ::SendMessage(GetControl(IDC_DEVPOWER_WAKEENABLE),
                                                      BM_GETCHECK, 0, 0))) {
                        ::EnableWindow(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE), TRUE);
                    } else {
                        ::EnableWindow(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE), FALSE);
                    }
                }
            
            } else {
    
                ::EnableWindow(GetControl(IDC_DEVPOWER_WAKEENABLE), FALSE);
                ::EnableWindow(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE), FALSE);
            }
        }
        break;
    }

    return FALSE;
}

//
// This function saves the settings(if any)
//
BOOL
CDevicePowerMgmtPage::OnApply()
{
    BOOLEAN Enabled;

    if (m_poWakeEnable.IsOpened() && IsWindowEnabled(GetControl(IDC_DEVPOWER_WAKEENABLE))) {
        
        Enabled = BST_CHECKED == ::SendMessage(GetControl(IDC_DEVPOWER_WAKEENABLE),
                                               BM_GETCHECK, 0, 0);
        m_poWakeEnable.Set(Enabled);
    }

    if (m_poWakeMgmtEnable.IsOpened() && IsWindowEnabled(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE))) {
        
        Enabled = BST_CHECKED == ::SendMessage(GetControl(IDC_DEVPOWER_MGMT_WAKEENABLE),
                                               BM_GETCHECK, 0, 0);
        m_poWakeMgmtEnable.Set(Enabled);
    }

    if (m_poShutdownEnable.IsOpened() && IsWindowEnabled(GetControl(IDC_DEVPOWER_DEVICEENABLE))) {
        
        Enabled = BST_CHECKED == ::SendMessage(GetControl(IDC_DEVPOWER_DEVICEENABLE),
                                               BM_GETCHECK, 0, 0);
        m_poShutdownEnable.Set(Enabled);
    }
    return FALSE;
}

//
// This function refreshes every control in the dialog. It may be called
// when the dialog is being initialized
//
void
CDevicePowerMgmtPage::UpdateControls(
    LPARAM lParam
    )
{
    if (lParam) {
        
        m_pDevice = (CDevice*) lParam;
    }

    try {
        
        //
        // Calling PropertyChanged() will update the display name for the device.  We need
        // to do this in case a 3rd party property sheet did something that could change
        // the device's display name.
        //
        m_pDevice->PropertyChanged();

        HICON hIconOld;
        m_IDCicon = IDC_DEVPOWER_ICON;  // Save for cleanup in OnDestroy.
        hIconOld = (HICON)SendDlgItemMessage(m_hDlg, IDC_DEVPOWER_ICON, STM_SETICON,
                                             (WPARAM)(m_pDevice->LoadClassIcon()),
                                             0
                                            );
        if (hIconOld) {
            DestroyIcon(hIconOld);
        }

        SetDlgItemText(m_hDlg, IDC_DEVPOWER_DESC, m_pDevice->GetDisplayName());

        //
        // Get any power message that the class installer might want to display
        //
        SP_POWERMESSAGEWAKE_PARAMS pmp;
        DWORD RequiredSize;

        pmp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
        pmp.ClassInstallHeader.InstallFunction = DIF_POWERMESSAGEWAKE;
        pmp.PowerMessageWake[0] = TEXT('\0');

        m_pDevice->m_pMachine->DiSetClassInstallParams(*m_pDevice,
                                                       &pmp.ClassInstallHeader,
                                                       sizeof(pmp)
                                                       );

        //
        // If the class installer returns NO_ERROR and there is text to display in the 
        // PowerMessageWake field of the SP_POWERMESSAGEWAKE_PARAMS structure then display
        // the text.
        //
        if ((m_pDevice->m_pMachine->DiCallClassInstaller(DIF_POWERMESSAGEWAKE, *m_pDevice)) &&
            (m_pDevice->m_pMachine->DiGetClassInstallParams(*m_pDevice,
                                                            &pmp.ClassInstallHeader,
                                                            sizeof(pmp),
                                                            &RequiredSize)) &&
            (pmp.PowerMessageWake[0] != TEXT('\0'))) {

            SetDlgItemText(m_hDlg, IDC_DEVPOWER_MESSAGE, pmp.PowerMessageWake);
        }
    } catch (CMemoryException* e) {
        e->Delete();
        // report memory error
        MsgBoxParam(m_hDlg, 0, 0, 0);
    }
}

BOOL
CDevicePowerMgmtPage::OnHelp(
    LPHELPINFO pHelpInfo
    )
{
    WinHelp((HWND)pHelpInfo->hItemHandle, DEVMGR_HELP_FILE_NAME, HELP_WM_HELP,
            (ULONG_PTR)g_a15HelpIDs);

    return FALSE;
}


BOOL
CDevicePowerMgmtPage::OnContextMenu(
    HWND hWnd,
    WORD xPos,
    WORD yPos
    )
{
    WinHelp(hWnd, DEVMGR_HELP_FILE_NAME, HELP_CONTEXTMENU,
            (ULONG_PTR)g_a15HelpIDs);

    return FALSE;
}

//
// This function enables/disables the device power capability
// INPUT:
//      fEnable -- TRUE  to enable
//              -- FALSE to disable
// OUTPUT:
//      TRUE if the state is set
//      FALSE if the state is not set.
BOOL
CPowerEnable::Set(
    BOOLEAN fEnable
    )
{
    if (IsOpened()) {
        
        DWORD Error;
        BOOLEAN fNewValue = fEnable;
        
        Error = WmiSetSingleInstance(m_hWmiBlock, m_DevInstId, m_Version,
                                     sizeof(fNewValue), &fNewValue);

        //
        // Get the value back to see if the change is really succeeded.
        //
        if (ERROR_SUCCESS == Error && Get(fNewValue) && fNewValue == fEnable) {
            
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
CPowerEnable::Get(
    BOOLEAN& fEnable
    )
{
    fEnable = FALSE;

    if (IsOpened()) {
        
        ULONG Size = m_WmiInstDataSize;
        DWORD Error;

        Error = WmiQuerySingleInstance(m_hWmiBlock, m_DevInstId, &Size, m_pWmiInstData);

        if (ERROR_SUCCESS == Error && Size == m_WmiInstDataSize &&
            m_DataBlockSize == ((PWNODE_SINGLE_INSTANCE)m_pWmiInstData)->SizeDataBlock &&
            m_Version == ((PWNODE_SINGLE_INSTANCE)m_pWmiInstData)->WnodeHeader.Version) {
            fEnable = *((BOOLEAN*)(m_pWmiInstData + ((PWNODE_SINGLE_INSTANCE)m_pWmiInstData)->DataBlockOffset));
            
            return TRUE;
        }
    }

    return FALSE;
}

//
// Function to open the wmi block.
// INPUT:
//      DeviceId -- the device id
// OUTPUT:
//      TRUE  if the device can be turned off
//      FALSE if the device can not be turned off.
BOOL
CPowerEnable::Open(
    LPCTSTR DeviceId
    )
{
    if (!DeviceId) {
        
        return FALSE;
    }

    //
    // Do nothing if already opened
    //
    if (IsOpened()) {
        
        return TRUE;
    }

    int len = lstrlen(DeviceId);

    if (len >= ARRAYLEN(m_DevInstId) - 2) {
        return FALSE;
    }

    WmiDevInstToInstanceName(m_DevInstId, len+3, (PTCHAR)DeviceId, 0);

    ULONG Error;
    Error = WmiOpenBlock(&m_wmiGuid, 0, &m_hWmiBlock);
    if (ERROR_SUCCESS == Error) {

        //
        // Get the required block size.
        //
        ULONG BufferSize = 0;
        Error = WmiQuerySingleInstance(m_hWmiBlock, m_DevInstId, &BufferSize, NULL);
        if (BufferSize && Error == ERROR_INSUFFICIENT_BUFFER) {
            
            //
            // The device does support the GUID, remember the size
            // and allocate a buffer to the data block.
            //
            m_WmiInstDataSize = BufferSize;
            m_pWmiInstData = new BYTE[BufferSize];

            if (m_pWmiInstData) {
                
                Error = WmiQuerySingleInstance(m_hWmiBlock, m_DevInstId, &BufferSize, m_pWmiInstData);
            
            } else {
                
                Error = ERROR_NOT_ENOUGH_MEMORY;
            }

            if (ERROR_SUCCESS == Error &&
                m_DataBlockSize == ((PWNODE_SINGLE_INSTANCE)m_pWmiInstData)->SizeDataBlock) {
                
                //
                // Remember the version
                //
                m_Version = ((PWNODE_SINGLE_INSTANCE)m_pWmiInstData)->WnodeHeader.Version;
                return TRUE;
            }

        }

        Close();
    }

    SetLastError(Error);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\factory.h ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    cfactory.cpp

Abstract:

    Header file for CFactory.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#ifndef __CFACTORY_H_
#define __CFACTORY_H_


typedef enum tagdDMClassType{
    DM_CLASS_TYPE_SNAPIN = 0,
    DM_CLASS_TYPE_SNAPIN_EXTENSION,
    DM_CLASS_TYPE_SNAPIN_ABOUT,
    DM_CLASS_TYPE_UNKNOWN
}DM_CLASS_TYPE, *PDM_CLASS_TYPE;

class CClassFactory : public IClassFactory
{
public:

    CClassFactory(DM_CLASS_TYPE ClassType)
    : m_Ref(1), m_ClassType(ClassType)
    {}

    STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj);

    STDMETHOD_(ULONG, AddRef) ();

    STDMETHOD_(ULONG, Release) ();

    STDMETHOD(CreateInstance)(IUnknown* pUnkOuter, REFIID riid, LPVOID* ppvObj);

    STDMETHOD(LockServer)(BOOL fLock);

    static HRESULT GetClassObject(REFCLSID rclsid, REFIID riid, void** ppv);
    static HRESULT RegisterAll();
    static HRESULT UnregisterAll();
    static HRESULT CanUnloadNow(void);
    static  LONG    s_Locks;
    static  LONG    s_Objects;

private:
    ULONG   m_Ref;
    DM_CLASS_TYPE  m_ClassType;
};

#endif // __CFACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\events.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    events.cpp

Abstract:

    implementation of CComponent functions

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "devmgr.h"



HRESULT CComponent::OnShow(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    //
    // Note - arg is TRUE when it is time to enumerate
    //
    CFolder* pFolder = FindFolder(cookie);
    
    if (arg) {

        m_pCurFolder = pFolder;
    }

    if (pFolder) {
    
        return pFolder->OnShow((BOOL)arg);

    } else {
    
        return S_OK;
    }
}

HRESULT CComponent::OnMinimize(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    return S_OK;
}

HRESULT CComponent::OnViewChange(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM param
    )
{
    return S_OK;
}

HRESULT CComponent::OnProperties(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM param
    )
{
    return S_OK;
}

HRESULT CComponent::OnResultItemClick(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM param
    )
{
    return S_OK;
}

HRESULT CComponent::OnResultItemDblClick(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM param
    )
{
    return S_FALSE;
}

HRESULT CComponent::OnActivate(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM param
    )
{
    return S_OK;
}

HRESULT CComponent::OnSelect(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM param
    )
{
    CFolder* pFolder;
    pFolder  = FindFolder(cookie);
    
    if (pFolder && LOWORD(arg)) {

        //
        // LOWORD(arg) being set indicated this is for the scope pane item.
        // Save the bSelect value for use by the MenuCommand.
        //
        pFolder->m_bSelect = (BOOL) HIWORD(arg);
    }

    if (!pFolder || S_FALSE == pFolder->OnSelect()) {

        //
        // either we can not find the responsible folder
        // or the responsible folder asks us to do it,
        // set the console verb to its defaults
        //
        m_pConsoleVerb->SetVerbState(MMC_VERB_OPEN, HIDDEN, TRUE);
        m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, TRUE);
        m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);
        m_pConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, TRUE);
        m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, TRUE);
        m_pConsoleVerb->SetVerbState(MMC_VERB_PRINT, HIDDEN, TRUE);
        m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);
    }

    return S_OK;
}

HRESULT CComponent::OnOcxNotify(
    MMC_NOTIFY_TYPE event,
    LPARAM arg,
    LPARAM param
    )
{
    //TRACE1(TEXT("Componet:OnOcxNotify, event = %lx\n"), event);

    if (m_pCurFolder) {
    
        return m_pCurFolder->OnOcxNotify(event, arg, param);
    }

    return S_OK;
}

HRESULT CComponent::OnBtnClick(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM param
    )
{
    return S_OK;
}

HRESULT CComponent::OnAddImages(
    MMC_COOKIE  cookie,
    IImageList* pIImageList,
    HSCOPEITEM hScopeItem
    )
{
    if (!cookie) {

        return LoadScopeIconsForResultPane(pIImageList);
    }

    return S_OK;
}

HRESULT CComponent::OnRestoreView(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM param
    )
{
    if (!param) {

        return E_INVALIDARG;
    }

    CFolder* pFolder;
    pFolder = FindFolder(cookie);
    
    if (pFolder) {
    
        return pFolder->OnRestoreView((BOOL*)param);

    } else {
        
        *((BOOL *)param) = FALSE;
        return S_OK;
    }
}

HRESULT CComponent::OnContextHelp(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM param
    )
{
    String strHelpOverview;
    String strHelpTopic;

    //
    // Load help file and overview topic strings.
    //
    strHelpOverview.LoadString(g_hInstance, IDS_HTMLHELP_NAME);
    strHelpTopic.LoadString(g_hInstance, IDS_HTMLHELP_OVERVIEW_TOPIC);

    strHelpOverview += TEXT("::");
    strHelpOverview += strHelpTopic;
    return m_pDisplayHelp->ShowTopic(const_cast<BSTR>((LPCTSTR)strHelpOverview));
}

HRESULT CComponent::LoadScopeIconsForResultPane(
    IImageList* pIImageList
    )
{
    if (pIImageList) {

        HICON hIcon;
        HRESULT hr = S_OK;
        hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_DEVMGR));
        
        if (hIcon) {

            hr = pIImageList->ImageListSetIcon((PLONG_PTR)hIcon, IMAGE_INDEX_DEVMGR);
            DeleteObject(hIcon);
        }

        return hr;
    
    } else {

        return E_INVALIDARG;
    }
}

#if DBG
TCHAR *tvNotifyStr[] = {
    TEXT("CLICK"),
    TEXT("DBLCLK"),
    TEXT("RCLICK"),
    TEXT("RDBLCLK"),
    TEXT("KEYDOWN"),
    TEXT("CONTEXTMENU"),
    TEXT("EXPANDING"),
    TEXT("EXPANDED"),
    TEXT("SELCHANGING"),
    TEXT("SELCHANGED"),
    TEXT("GETDISPINFO"),
    TEXT("FOCUSCHANGED"),
    TEXT("UNKNOWN")
    };
#endif

HRESULT CComponent::tvNotify(
    HWND hwndTV,
    MMC_COOKIE cookie,
    TV_NOTIFY_CODE Code,
    LPARAM arg,
    LPARAM param
    )
{

#if DBG
    int i = Code;
    
    if (Code > TV_NOTIFY_CODE_UNKNOWN) {
        
        i = TV_NOTIFY_CODE_UNKNOWN;
    }

    //TRACE((TEXT("Componet:tvNotify, Code = %lx %s cookie = %lx\n"), Code, tvNotifyStr[i], cookie));
#endif

    CFolder* pFolder;

    pFolder = FindFolder(cookie);
    
    if (pFolder) {
        
        return pFolder->tvNotify(hwndTV, GetActiveCookie(cookie), Code, arg, param);
    }

    return S_FALSE;
}

////////////////////////////////////////////////////////////////////////////
//// IComponentData events handlers
////


HRESULT
CComponentData::OnProperties(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM param
    )
{
    return S_OK;
}

HRESULT
CComponentData::OnBtnClick(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM param
    )
{
    return S_OK;
}
HRESULT
CComponentData::OnDelete(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM param
    )
{
    return S_OK;
}
HRESULT
CComponentData::OnRename(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM param
    )
{
    return S_OK;
}

//
// This function handles the MMCN_EXPAND notification code
// Input: lpDataObject -- point to the target IDataObject
//        arg          -- TRUE if expanding, FALSE if collapsing.
//        param        -- not used.
//
// Output: HRESULT
HRESULT
CComponentData::OnExpand(
    LPDATAOBJECT lpDataObject,
    LPARAM arg,
    LPARAM param
    )
{
    INTERNAL_DATA tID;
    HRESULT hr;

    //
    // If we are not expanding, do nothing
    //
    if (!arg) {
    
        return S_OK;
    }

    hr = ExtractData(lpDataObject, CDataObject::m_cfSnapinInternal,
                         (PBYTE)&tID, sizeof(tID));
    
    if (SUCCEEDED(hr)) {
        
        hr = CreateScopeItems();
        
        if (SUCCEEDED(hr) && !m_pMachine) {
            
            if (!g_MachineList.CreateMachine(m_hwndMain, m_strMachineName, &m_pMachine)) {
                
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }

        if (SUCCEEDED(hr)) {

            CCookie* pCookie = GetActiveCookie(tID.cookie);
            ASSERT(pCookie);
            HSCOPEITEM hScopeParent = (HSCOPEITEM)param;
            CScopeItem* pScopeItem = pCookie->GetScopeItem();
            ASSERT(pScopeItem);
            pScopeItem->SetHandle(hScopeParent);

            //
            // If we have children and this is the first time we
            // are expanding, insert all the children to scope pane.
            //
            if (pCookie->GetChild() && !pScopeItem->IsEnumerated()) {

                SCOPEDATAITEM ScopeDataItem;

                CCookie* pTheCookie = pCookie->GetChild();
                
                do {

                    CScopeItem* pTheItem = pTheCookie->GetScopeItem();
                    ASSERT(pTheItem);
                    ScopeDataItem.relativeID = hScopeParent;
                    ScopeDataItem.nState = 0;
                    ScopeDataItem.displayname = (LPOLESTR)(-1);
                    ScopeDataItem.mask = SDI_IMAGE | SDI_OPENIMAGE | SDI_CHILDREN |
                                         SDI_STR | SDI_PARAM | SDI_STATE;
                    ScopeDataItem.nImage = pTheItem->GetImageIndex();
                    ScopeDataItem.nOpenImage = pTheItem->GetOpenImageIndex();
                    ScopeDataItem.cChildren = pTheItem->GetChildCount();
                    ScopeDataItem.lParam = reinterpret_cast<LPARAM>(pTheCookie);
                    
                    hr = m_pScope->InsertItem(&ScopeDataItem);
                    
                    if (FAILED(hr)) {
                    
                        break;
                    }
                    
                    pTheItem->SetHandle(ScopeDataItem.ID);
                    pTheCookie = pTheCookie->GetSibling();

                } while (pTheCookie);
            }

            pScopeItem->Enumerated();
        }
    }

    else {

        //
        // The provided lpDataObject is not ours, we are being
        // expanded as an extension snapin. Find out what
        // node type the data object is. If it is "MyComputer"
        // system tools, attach our scope items to
        // it.
        //

        CLSID   CLSID_NodeType;
        hr = ExtractData(lpDataObject, CDataObject::m_cfNodeType,
                         (PBYTE)&CLSID_NodeType, sizeof(CLSID_NodeType));
        
        if (FAILED(hr)) {
        
            return hr;
        }

        if (CLSID_SYSTOOLS == CLSID_NodeType) {

            TCHAR MachineName[MAX_PATH + 1];
            MachineName[0] = _T('\0');
            hr = ExtractData(lpDataObject, CDataObject::m_cfMachineName,
                             (BYTE*)MachineName, sizeof(MachineName));
            
            if (SUCCEEDED(hr)) {

                m_ctRoot = COOKIE_TYPE_SCOPEITEM_DEVMGR;

                m_strMachineName.Empty();
                
                if (_T('\0') != MachineName[0]) {

                    if (_T('\\') != MachineName[0]) {

                        m_strMachineName = TEXT("\\\\");
                    }

                    m_strMachineName += MachineName;
                }

                hr = CreateScopeItems();
                
                if (SUCCEEDED(hr)) {

                    CMachine* pMachine;
                    pMachine = g_MachineList.FindMachine(m_strMachineName);
                    
                    if (!pMachine || pMachine != m_pMachine) {

                        if (!g_MachineList.CreateMachine(m_hwndMain, m_strMachineName, &m_pMachine)) {

                            hr = HRESULT_FROM_WIN32(GetLastError());
                        }
                    }
                }
            }

            if (SUCCEEDED(hr)) {

                //
                // Always insert "Device Manager" node because
                // we are expanding as an extention to Computer Management
                //
                CCookie* pCookie = GetActiveCookie(0);
                ASSERT(pCookie);
                CScopeItem* pScopeItem = pCookie->GetScopeItem();
                ASSERT(pScopeItem);
                SCOPEDATAITEM ScopeDataItem;
                memset(&ScopeDataItem, 0, sizeof(ScopeDataItem));
                ScopeDataItem.relativeID = (HSCOPEITEM)(param);
                ScopeDataItem.nState = 0;
                ScopeDataItem.displayname = (LPOLESTR)(-1);
                ScopeDataItem.mask = SDI_IMAGE | SDI_OPENIMAGE | SDI_CHILDREN |
                                     SDI_STR | SDI_PARAM | SDI_STATE;
                ScopeDataItem.nImage = pScopeItem->GetImageIndex();
                ScopeDataItem.nOpenImage = pScopeItem->GetOpenImageIndex();
                ScopeDataItem.cChildren = pScopeItem->GetChildCount();
                ScopeDataItem.lParam = reinterpret_cast<LPARAM>(pCookie);
                hr = m_pScope->InsertItem(&ScopeDataItem);
                pScopeItem->SetHandle(ScopeDataItem.ID);
            }
        }
    }

    return hr;
}

HRESULT
CComponentData::OnContextMenu(
    MMC_COOKIE cookie,
    LPARAM arg,
    LPARAM param
    )
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\genpage.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    genpage.cpp

Abstract:

    This module implements CGeneralPage -- the snapin startup wizard page

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "devmgr.h"
#include "genpage.h"

UINT g_cfDsObjectPicker = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

const DWORD g_a102HelpIDs[]=
{
    IDC_GENERAL_SELECT_TEXT, IDH_DISABLEHELP,
    IDC_GENERAL_SELECTGROUP, IDH_DISABLEHELP,
    IDC_GENERAL_OVERRIDE_MACHINENAME, idh_devmgr_manage_command_line,   // Device Manager: "Allo&w the selected computer to be changed when launching from the command line.  This only applies if you save the console." (Button)
    IDC_GENERAL_LOCALMACHINE, idh_devmgr_manage_local,                  // Device Manager: "&Local computer:  (the computer this console is running on)" (Button)
    IDC_GENERAL_OTHERMACHINE, idh_devmgr_manage_remote,                 // Device Manager: "&Another computer:" (Button)
    IDC_GENERAL_MACHINENAME, idh_devmgr_manage_remote_name,             // Device Manager: "" (Edit)
    IDC_GENERAL_BROWSE_MACHINENAMES, idh_devmgr_manage_remote_browse,   // Device Manager: "B&rowse..." (Button)
    0, 0
};

CGeneralPage::CGeneralPage() :  CPropSheetPage(g_hInstance, IDD_GENERAL_PAGE)

{
    m_lConsoleHandle = 0;
    m_pstrMachineName = NULL;
    m_pct = NULL;
    m_MachineName[0] = _T('\0');
    m_IsLocalMachine = TRUE;
    m_ct = COOKIE_TYPE_SCOPEITEM_DEVMGR;
}


HPROPSHEETPAGE
CGeneralPage::Create(
    LONG_PTR lConsoleHandle
    )
{
    m_lConsoleHandle = lConsoleHandle;
    // override PROPSHEETPAGE structure here...
    m_psp.lParam = (LPARAM)this;
    return CPropSheetPage::CreatePage();
}

BOOL
CGeneralPage::OnInitDialog(
    LPPROPSHEETPAGE ppsp
    )
{
    ASSERT(m_hDlg);

    // intiallly, enable the local machine and disable the
    // "other" machine.
    ::CheckDlgButton(m_hDlg, IDC_GENERAL_LOCALMACHINE, BST_CHECKED);
    ::CheckDlgButton(m_hDlg, IDC_GENERAL_OTHERMACHINE, BST_UNCHECKED);
    ::EnableWindow(GetControl(IDC_GENERAL_MACHINENAME), FALSE);

    // Default is local machine and view-all. Since everything
    // is valud at the beginning, we have to enable the
    // finish button.
    ::SendMessage(::GetParent(m_hDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_FINISH);
    ::ShowWindow(GetControl(IDC_GENERAL_OVERRIDE_MACHINENAME), SW_HIDE);
    ::EnableWindow(GetControl(IDC_GENERAL_BROWSE_MACHINENAMES), FALSE);

    return TRUE;
}

BOOL
CGeneralPage::OnReset(
    void
    )
{
    m_MachineName[0] = _T('\0');
    m_ct = COOKIE_TYPE_SCOPEITEM_DEVMGR;
    SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, 0L);
    return FALSE;
}

BOOL
CGeneralPage::OnCommand(
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (LOWORD(wParam)) {
    case IDC_GENERAL_LOCALMACHINE:
        if (BN_CLICKED == HIWORD(wParam)) {

            ::EnableWindow(GetControl(IDC_GENERAL_BROWSE_MACHINENAMES), FALSE);
            ::EnableWindow(GetControl(IDC_GENERAL_MACHINENAME), FALSE);
            ::SendMessage(::GetParent(m_hDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_FINISH);
            m_IsLocalMachine = TRUE;
            return TRUE;
        }
        break;

    case IDC_GENERAL_OTHERMACHINE:
        if (BN_CLICKED == HIWORD(wParam)) {

            ::EnableWindow(GetControl(IDC_GENERAL_BROWSE_MACHINENAMES), TRUE);
            ::EnableWindow(GetControl(IDC_GENERAL_MACHINENAME), TRUE);

            if (GetWindowTextLength(GetControl(IDC_GENERAL_MACHINENAME)))
                ::SendMessage(::GetParent(m_hDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_FINISH);
            else
                ::SendMessage(::GetParent(m_hDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_DISABLEDFINISH);
            m_IsLocalMachine = FALSE;
            return TRUE;
        }
        break;

    case IDC_GENERAL_MACHINENAME:
        if (EN_CHANGE == HIWORD(wParam)) {

            // edit control change, see if there are any text in the
            // control at all. It it does, enable the finish button,
            // otherwise, disable it.
            //
            if (GetWindowTextLength((HWND)lParam))
            {
                // there are some text in the edit control
                // enable the finish button
                ::SendMessage(::GetParent(m_hDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_FINISH);
            }

            else
            {
                // no text in the edit control
                // disable the finish button
                ::SendMessage(::GetParent(m_hDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_DISABLEDFINISH);
            }
        }
        break;

    case IDC_GENERAL_BROWSE_MACHINENAMES:
        DoBrowse();
        return TRUE;
        break;
    }

    return FALSE;
}

BOOL
CGeneralPage::OnWizFinish(
    void
    )
{
    BOOL bSuccess = TRUE;    
    
    //
    // First figure out the machine name
    //
    m_MachineName[0] = _T('\0');
    if (!m_IsLocalMachine)
    {
        GetWindowText(GetControl(IDC_GENERAL_MACHINENAME), m_MachineName,
                      sizeof(m_MachineName) / sizeof(TCHAR));

        if (_T('\0') != m_MachineName[0])
        {
            if (_T('\\') != m_MachineName[0])
            {
                //
                // Insert machine name signature to the fron of the name
                //
                int len = lstrlen(m_MachineName);

                if (len + 2 < sizeof(m_MachineName) / sizeof(TCHAR))
                {
                    //
                    // Move the existing string so that we can insert
                    // the signature in the first two locations.
                    // the move includes the terminated null char.
                    //
                    for (int i = len + 2; i >= 2; i--) {

                        m_MachineName[i] = m_MachineName[i - 2];
                    }

                    m_MachineName[0] = _T('\\');
                    m_MachineName[1] = _T('\\');
                }
            }

            //
            // Now verify the machine name. If the machine name is invalid
            // or can be reached, use the local computer;
            //
            if (!VerifyMachineName(m_MachineName))
            {
                TCHAR WarningFormat[MAX_PATH * 3];
                TCHAR WarningMsg[MAX_PATH * 3];
                LPVOID lpLastError = NULL;

                if (LoadString(g_hInstance,
                               IDS_INVALID_COMPUTER_NAME,
                               WarningFormat,
                               ARRAYLEN(WarningFormat)
                               ) &&
                    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                  FORMAT_MESSAGE_FROM_SYSTEM | 
                                  FORMAT_MESSAGE_IGNORE_INSERTS,
                                  NULL,
                                  GetLastError(),
                                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                  (LPTSTR)&lpLastError,
                                  0,
                                  NULL)) {

                    StringCchPrintf(WarningMsg,
                                    ARRAYLEN(WarningMsg),
                                    WarningFormat, 
                                    m_MachineName, 
                                    lpLastError
                                    );

                    MessageBox(m_hDlg,
                               (LPCTSTR)WarningMsg,
                               (LPCTSTR)g_strDevMgr,
                               MB_ICONERROR | MB_OK
                               );

                    bSuccess = FALSE;
                }

                if (lpLastError) {
                    LocalFree(lpLastError);
                }

                m_MachineName[0] = _T('\0');
            }
        }
    }

    try
    {
        if (m_lConsoleHandle)
        {
            //
            // A console handle is created for the property sheet,
            // use the handle to notify the snapin about the new
            // startup information.
            //
            BufferPtr<BYTE> Buffer(sizeof(PROPERTY_CHANGE_INFO) + sizeof(STARTUP_INFODATA));
            PPROPERTY_CHANGE_INFO pPCI = (PPROPERTY_CHANGE_INFO)(BYTE*)Buffer;
            PSTARTUP_INFODATA pSI = (PSTARTUP_INFODATA)&pPCI->InfoData;

            if (_T('\0') != m_MachineName[0]) {
                lstrcpy(pSI->MachineName, m_MachineName);
            }

            pSI->ct = m_ct;
            pSI->Size = sizeof(STARTUP_INFODATA);
            pPCI->Type = PCT_STARTUP_INFODATA;

            //
            // Notify IComponentData about what we have here.
            //
            MMCPropertyChangeNotify(m_lConsoleHandle, reinterpret_cast<LONG_PTR>(&pPCI));
        }

        else if (m_pstrMachineName && m_pct)
        {
            //
            // No console is provided for the property sheet.
            // send the new startup info in the given buffer if it is
            // provided.
            //
            *m_pstrMachineName = m_MachineName;
            *m_pct = m_ct;
        }

        else
        {
            //
            // Nobody is listening to what we have to say. Something must be
            // wrong!
            //
            ASSERT(FALSE);
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_hDlg, 0, 0, 0);
    }

    SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, bSuccess ? 0L : -1L);

    return TRUE;
}


BOOL
CGeneralPage::OnHelp(
    LPHELPINFO pHelpInfo
    )
{
    WinHelp((HWND)pHelpInfo->hItemHandle, DEVMGR_HELP_FILE_NAME, HELP_WM_HELP,
        (ULONG_PTR)g_a102HelpIDs);

    return FALSE;
}


BOOL
CGeneralPage::OnContextMenu(
    HWND hWnd,
    WORD xPos,
    WORD yPos
    )
{
    WinHelp(hWnd, DEVMGR_HELP_FILE_NAME, HELP_CONTEXTMENU,
        (ULONG_PTR)g_a102HelpIDs);

    return FALSE;
}

void
CGeneralPage::DoBrowse(
    void
    )
{
    HRESULT hr;
    static const int SCOPE_INIT_COUNT = 1;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

    //
    // Since we just want computer objects from every scope, combine them
    // all in a single scope initializer.
    //

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                           | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
                           | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_WORKGROUP
                           | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                           | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
    aScopeInit[0].FilterFlags.Uplevel.flBothModes =
        DSOP_FILTER_COMPUTERS;
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.pwzTargetComputer = NULL;  // NULL == local machine
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    IDsObjectPicker *pDsObjectPicker = NULL;
    IDataObject *pdo = NULL;
    bool fGotStgMedium = false;
    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL,
        NULL
    };

    do {

        hr = CoCreateInstance(CLSID_DsObjectPicker,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker,
                              (void **) &pDsObjectPicker);

        hr = pDsObjectPicker->Initialize(&InitInfo);

        hr = pDsObjectPicker->InvokeDialog(m_hDlg, &pdo);

        // Quit if user hit Cancel

        if (hr == S_FALSE)
        {
            break;
        }

        FORMATETC formatetc =
        {
            (CLIPFORMAT)g_cfDsObjectPicker,
            NULL,
            DVASPECT_CONTENT,
            -1,
            TYMED_HGLOBAL
        };

        hr = pdo->GetData(&formatetc, &stgmedium);

        fGotStgMedium = true;

        PDS_SELECTION_LIST pDsSelList =
            (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

        if (!pDsSelList)
        {
            break;
        }

        ULONG i;

        ASSERT(pDsSelList->cItems == 1);

        //
        // Put the machine name in the edit control
        //
        ::SetDlgItemText(m_hDlg, IDC_GENERAL_MACHINENAME, pDsSelList->aDsSelection[0].pwzName);

        GlobalUnlock(stgmedium.hGlobal);

    } while (0);

    if (fGotStgMedium)
    {
        ReleaseStgMedium(&stgmedium);
    }

    if (pDsObjectPicker)
    {
        pDsObjectPicker->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\genpage.h ===
// genpage.h : header file
//

#ifndef __GENPAGE_H__
#define __GENPAGE_H__
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    devgenpg.h

Abstract:

    header file for genpage.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "proppage.h"

//
// context help id
//
#define IDH_DISABLEHELP (DWORD(-1))
#define idh_devmgr_manage_command_line  102170  // Device Manager: "Allo&w the selected computer to be changed when launching from the command line.  This only applies if you save the console." (Button)
#define idh_devmgr_view_devicetree  102110  // Device Manager: "&Device tree" (Button)
#define idh_devmgr_manage_local 102130  // Device Manager: "&Local computer:  (the computer this console is running on)" (Button)
#define idh_devmgr_manage_remote    102140  // Device Manager: "&Another computer:" (Button)
#define idh_devmgr_manage_remote_name   102150  // Device Manager: "" (Edit)
#define idh_devmgr_view_all 102100  // Device Manager: "&All" (Button)
#define idh_devmgr_manage_remote_browse 102160  // Device Manager: "B&rowse..." (Button)
#define idh_devmgr_view_resources   102120  // Device Manager: "&Resources" (Button)


class CGeneralPage : public CPropSheetPage
{
public:
    CGeneralPage();
    virtual BOOL OnInitDialog(LPPROPSHEETPAGE ppsp);
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    virtual BOOL OnReset();
    virtual BOOL OnWizFinish();
    virtual BOOL OnHelp(LPHELPINFO pHelpInfo);
    virtual BOOL OnContextMenu(HWND hWnd, WORD xPos, WORD yPos);
    HPROPSHEETPAGE Create(LONG_PTR lConsoleHandle);
    void SetOutputBuffer(String* pstrMachineName, COOKIE_TYPE* pct)
    {
        m_pstrMachineName = pstrMachineName;
        m_pct = pct;
    }
    void DoBrowse();
private:
    LONG_PTR m_lConsoleHandle;
    TCHAR   m_MachineName[MAX_PATH + 3];
    COOKIE_TYPE m_ct;
    String* m_pstrMachineName;
    COOKIE_TYPE* m_pct;
    BOOL    m_IsLocalMachine;
};

#endif  // __GENPAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\hwprof.h ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    hwprof.h

Abstract:

    header file for hwprof.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/
class CHwProfile;
class CHwProfileList;

class CHwProfileList
{
public:
    CHwProfileList() : m_pDevice(NULL), m_CurHwProfile(0), m_CurHwProfileIndex(0) {}
    ~CHwProfileList();
    BOOL Create(CDevice* pDevice, DWORD ConfigFlags = 0);
    BOOL GetFirst(CHwProfile** pphwpf, PVOID& Context);
    BOOL GetNext(CHwProfile** pphwpf, PVOID& Context);
    BOOL GetCurrentHwProfile(CHwProfile** pphwpf);
    int GetCurrentHwProfileIndex()
    {
        return m_CurHwProfileIndex;
    }
    ULONG IndexToHwProfile(int HwProfileIndex);
    int GetCount()
    {
        return m_listProfile.GetCount();
    }

private:
    CList<CHwProfile*,CHwProfile* > m_listProfile;
    CDevice*    m_pDevice;
    ULONG   m_CurHwProfile;
    int     m_CurHwProfileIndex;
};

class CHwProfile
{
public:
    CHwProfile(int Index, PHWPROFILEINFO phwpfInfo, CDevice* pDevice, DWORD hwpfFlags);
    DWORD GetFlags()
    {
        return m_Flags;
    }
    LPCTSTR GetFriendlyName() const
    {
        return m_hwpfInfo.HWPI_szFriendlyName;
    }
    DWORD GetIndex()
    {
        return m_Index;
    }

    ULONG GetHwProfile()
    {
         return m_hwpfInfo.HWPI_ulHWProfile;
    }
    BOOL IsDisabled()
    {
        return (m_Flags & CSCONFIGFLAG_DISABLED);
    }
    BOOL DoNotCreate()
    {
        return (m_Flags & CSCONFIGFLAG_DO_NOT_CREATE);
    }
    BOOL DoNotStart()
    {
        return (m_Flags & CSCONFIGFLAG_DO_NOT_START);
    }
    void SetEnablePending()
    {
        m_EnablePending = TRUE;
    }
    void ResetEnablePending()
    {
        m_EnablePending = FALSE;
    }
    void SetDisablePending()
    {
        m_DisablePending = TRUE;
    }
    void ResetDisablePending()
    {
        m_DisablePending = FALSE;
    }
    BOOL IsEnablePending()
    {
        return m_EnablePending;
    }
    BOOL IsDisablePending()
    {
        return m_DisablePending;
    }

private:
    DWORD       m_Index;
    HWPROFILEINFO   m_hwpfInfo;
    DWORD       m_Flags;
    CDevice*        m_pDevice;
    BOOL        m_EnablePending;
    BOOL        m_DisablePending;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\hwtab.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    hwtab.cpp

Abstract:

    implement the hardware tab functions and UI.

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "devmgr.h"
#include <commctrl.h>
#include <comctrlp.h>
#include <windowsx.h>
#include <hwtab.h>

#define THIS_DLL g_hInstance

/*****************************************************************************
 *
 *  Exported stuff
 *
 *****************************************************************************/

// Stuff in api.h that we can't #include because api.h can't be #include'd
// by anyone other than api.cpp.

STDAPI_(int)
DevicePropertiesExA(
    HWND hwndParent,
    LPCSTR MachineName,
    LPCSTR DeviceID,
    DWORD Flags,
    BOOL ShowDeviceTree
    );

STDAPI_(int)
DevicePropertiesExW(
    HWND hwndParent,
    LPCWSTR MachineName,
    LPCWSTR DeviceID,
    DWORD Flags,
    BOOL ShowDeviceTree
    );

STDAPI_(int)
DeviceProblemWizardA(
    HWND      hwndParent,
    LPCSTR    MachineName,
    LPCSTR    DeviceId
    );

STDAPI_(int)
DeviceProblemWizardW(
    HWND    hwndParent,
    LPCWSTR MachineName,
    LPCWSTR DeviceId
    );

STDAPI_(UINT)
DeviceProblemTextA(
    HMACHINE hMachine,
    DEVNODE DevNode,
    ULONG ProblemNumber,
    LPSTR Buffer,
    UINT   BufferSize
    );

STDAPI_(UINT)
DeviceProblemTextW(
    HMACHINE hMachine,
    DEVNODE DevNode,
    ULONG ProblemNumber,
    LPWSTR Buffer,
    UINT   BufferSize
    );



#ifdef UNICODE
#define DevicePropertiesEx  DevicePropertiesExW
#define DeviceProblemWizard DeviceProblemWizardW
#define DeviceProblemText   DeviceProblemTextW
#else
#define DevicePropertiesEx  DevicePropertiesExA
#define DeviceProblemWizard DeviceProblemWizardA
#define DeviceProblemText   DeviceProblemTextA
#endif

/*****************************************************************************
 *
 *  General remark about SetupDi functions
 *
 *      Windows NT and Windows 98 implement many of the SetupDi query
 *      functions differently if you are querying for the buffer size.
 *
 *      Windows 98 returns FALSE, and GetLastError() returns
 *      ERROR_INSUFFICIENT_BUFFER.
 *
 *      Windows NT returns TRUE.
 *
 *      So all calls to SetupDi functions that do querying for the buffer
 *      size should be wrapped with BUFFERQUERY_SUCCEEDED.
 *
 *****************************************************************************/

#define BUFFERQUERY_SUCCEEDED(f)    \
            ((f) || GetLastError() == ERROR_INSUFFICIENT_BUFFER)

/*****************************************************************************
 *
 *  Context help
 *
 *****************************************************************************/

#include "devgenpg.h"

#define idh_devmgr_hardware_trblsht 400100
#define idh_devmgr_hardware_properties  400200
#define idh_devmgr_hardware_listview    400300

const DWORD c_HWTabHelpIDs[] =
{
    IDC_HWTAB_LVSTATIC,     idh_devmgr_hardware_listview,
    IDC_HWTAB_LISTVIEW,     idh_devmgr_hardware_listview,
    IDC_HWTAB_GROUPBOX,     IDH_DISABLEHELP,
    IDC_HWTAB_MFG,          idh_devmgr_general_manufacturer,
    IDC_HWTAB_LOC,          idh_devmgr_general_location,
    IDC_HWTAB_STATUS,       idh_devmgr_general_device_status,
    IDC_HWTAB_TSHOOT,       idh_devmgr_hardware_trblsht,
    IDC_HWTAB_PROP,         idh_devmgr_hardware_properties,
        0, 0
};

typedef TCHAR TLINE[LINE_LEN];

typedef struct
{
    int devClass;
    int dsaItem;

} LISTITEM, *LPLISTITEM;


typedef struct
{
    GUID                    devGuid;            // device class guid we are managing
    TLINE                   tszClass;           // Array of friendly name of class
    HDSA                    hdsaDinf;           // array of SP_DEVINFO_DATA structures
    HDEVINFO                hdev;               // hdsaDinfo refers to this
    int                     iImage;             // image index within master imagelist

} CLASSDATA, *LPCLASSDATA;

/*****************************************************************************
 *
 *  CHWTab
 *
 *      The Hardware Tab page.
 *
 *****************************************************************************/

class CHWTab {

private:
    CHWTab(const GUID *pguid, int iNumClass, DWORD dwViewMode);
    ~CHWTab();

    void *operator new(size_t cb) { return LocalAlloc(LPTR, cb); }
    void operator delete(void *p) { LocalFree(p); }

    void RebuildDeviceList();
    void Reset();
    BOOL GetDeviceRegistryProperty(HDEVINFO hDev, DWORD dwProp, PSP_DEVINFO_DATA pdinf,
                                  LPTSTR ptsz, DWORD ctch);
    void SprintfItem(UINT ids, UINT idc, LPCTSTR ptszText);

    static INT_PTR CALLBACK DialogProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp);
    static LRESULT CALLBACK ParentSubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp, UINT_PTR uidSubclass, DWORD_PTR dwRefData);
    friend HWND DeviceCreateHardwarePage(HWND hwndParent, const GUID *pguid);
    friend HWND DeviceCreateHardwarePageEx(HWND hwndParent, const GUID *pguid, int iNumClass, DWORD dwViewMode);

    BOOL OnInitDialog(HWND hdlg);
    void RemoveListItems(HWND hwndList);
    void OnItemChanged(LPNMLISTVIEW pnmlv);
    void OnProperties(void);
    void OnTshoot(void);
    void OnSetText(LPCTSTR ptszText);
    void OnHelp(LPHELPINFO phi);
    void OnContextMenu(HWND hwnd);

    void SetControlPositions(int idcFirst, int idcLast, int dx, int dy, UINT flags);

    //
    //  Helpers for SetWindowPositions.
    //
    void GrowControls(int idcFirst, int idcLast, int dx, int dy) {
        SetControlPositions(idcFirst, idcLast, dx, dy, SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE);
    }
    void ShiftControls(int idcFirst, int idcLast, int dx, int dy) {
        SetControlPositions(idcFirst, idcLast, dx, dy, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
    }

    void RepositionControls();

    inline PSP_DEVINFO_DATA GetPdinf(LPLISTITEM pListItem) {
        return (PSP_DEVINFO_DATA)DSA_GetItemPtr(_pCD[pListItem->devClass].hdsaDinf, pListItem->dsaItem);
    }

private:
    HWND        _hdlg;                          // the dialog box itself
    HWND        _hwndList;                      // The listview
    int         _iNumClass;                     // Number of class guids
    DWORD       _dwViewMode;                    // Dictates size of list box
    LPCLASSDATA _pCD;                           // Class data for each devClass to represent
    SP_CLASSIMAGELIST_DATA _imageListData;      // Class image list data
};


//
//  Constructor.
//
CHWTab::CHWTab(const GUID *pguid, int iNumClass, DWORD dwViewMode) :
                    _pCD(NULL)
{
    //Assert(iNumClass);

    // Since the _dwViewMode is a devisor, we need to make sure it's valid
    _imageListData.ImageList = NULL;
    _dwViewMode     = dwViewMode;
    if (_dwViewMode < HWTAB_LARGELIST)
    {
        _dwViewMode = HWTAB_LARGELIST;
    }
    if (_dwViewMode > HWTAB_SMALLLIST)
    {
        _dwViewMode = HWTAB_SMALLLIST;
    }

    _iNumClass = iNumClass;
    _pCD = new CLASSDATA[_iNumClass];

    if (_pCD && pguid)
    {
        DWORD cbRequired;

        memset(_pCD, 0, sizeof(CLASSDATA) * _iNumClass);

        int devClass;
        for (devClass = 0; devClass < _iNumClass; devClass++)
        {
            _pCD[devClass].hdev        = INVALID_HANDLE_VALUE;
            _pCD[devClass].devGuid     = (GUID) pguid[devClass];
        }
        
        //get the driver class image list
        _imageListData.cbSize = sizeof(SP_CLASSIMAGELIST_DATA);
        if (!SetupDiGetClassImageList(&_imageListData)) {
            _imageListData.ImageList = NULL;
        }

        for (devClass = 0; devClass < _iNumClass; devClass++)
        {
            _pCD[devClass].iImage = -1;

            SetupDiGetClassDescription(&_pCD[devClass].devGuid, _pCD[devClass].tszClass, sizeof(TLINE), &cbRequired);

            if (_imageListData.ImageList)
            {
                // Get the image index for our little guy
                int iImageIndex;

                if (SetupDiGetClassImageIndex(&_imageListData, &_pCD[devClass].devGuid, &iImageIndex)) {
                    _pCD[devClass].iImage = iImageIndex;
                }
            }
        }
    }
}

CHWTab::~CHWTab()
{
    Reset();
    
    if (_imageListData.ImageList) {
        SetupDiDestroyClassImageList(&_imageListData);
    }

    if (_pCD)
    {
        delete _pCD;
        _pCD = NULL;
    }
}

//
//  Return to normal, ready for the next go-round.  This also frees all
//  dynamically allocated stuff.
//
void
CHWTab::Reset()
{
    int devClass;

    for (devClass = 0; devClass < _iNumClass; devClass++)
    {
        if (_pCD[devClass].hdsaDinf) {
            DSA_Destroy(_pCD[devClass].hdsaDinf);
            _pCD[devClass].hdsaDinf = NULL;
        }

        if (_pCD[devClass].hdev != INVALID_HANDLE_VALUE) {
            SetupDiDestroyDeviceInfoList(_pCD[devClass].hdev);
            _pCD[devClass].hdev = INVALID_HANDLE_VALUE;
        }
    }

}

//
//  Helper function that calls SetupDiGetDeviceRegistryProperty
//  and copes with things like detecting the various error modes
//  properly.
//

BOOL
CHWTab::GetDeviceRegistryProperty(HDEVINFO hDev, DWORD dwProp, PSP_DEVINFO_DATA pdinf,
                                  LPTSTR ptsz, DWORD ctch)
{
    DWORD cbRequired;
    ptsz[0] = TEXT('\0');
    SetupDiGetDeviceRegistryProperty(hDev, pdinf, dwProp, 0,
                                     (LPBYTE)ptsz, ctch * sizeof(TCHAR),
                                     &cbRequired);
    return ptsz[0];
}

//
//  Change the size/position of controls idcFirst through idcLast.
//  Change the size/position by (dx, dy).
//  flags specifies what exactly is changing.
//
void
CHWTab::SetControlPositions(int idcFirst, int idcLast, int dx, int dy, UINT flags)
{
    HDWP hdwp = BeginDeferWindowPos(idcLast - idcFirst + 1);
    for (int idc = idcFirst; idc <= idcLast; idc++) {
        if (hdwp) {
            RECT rc;
            HWND hwnd = GetDlgItem(_hdlg, idc);
            GetWindowRect(hwnd, &rc);
            MapWindowRect(HWND_DESKTOP, _hdlg, &rc);
            hdwp = DeferWindowPos(hdwp, hwnd, NULL,
                        rc.left + dx, rc.top + dy,
                        rc.right - rc.left + dx, rc.bottom - rc.top + dy,
                        flags);
        }
    }
    if (hdwp) {
        EndDeferWindowPos(hdwp);
    }
}

//
//  Reposition and resize our controls based on the size we need to be.
//
void
CHWTab::RepositionControls()
{
    //
    //  First, see how much slack space we have.
    //
    RECT rcDlg, rcParent;
    GetClientRect(_hdlg, &rcDlg);
    GetClientRect(GetParent(_hdlg), &rcParent);

    //
    //  Make ourselves as big as our parent.
    //
    SetWindowPos(_hdlg, NULL, 0, 0, rcParent.right, rcParent.bottom,
                 SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE);

    //
    //  Now do a little more math...
    //
    int cyExtra = rcParent.bottom - rcDlg.bottom;
    int cxExtra = rcParent.right  - rcDlg.right;

    //
    //  The extra vertical space is split between the listview and
    //  the groupbox.  The amount of split is determined by _dwViewMode.
    //  Larger modes give more and more space to the listview.
    //
    int cyTop = cyExtra / _dwViewMode;
    int cyBottom = cyExtra - cyTop;

    //
    //  Horizontally grow the controls that reach the full width of the
    //  dialog box.
    //
    GrowControls(IDC_HWTAB_HSIZEFIRST, IDC_HWTAB_HSIZELAST, cxExtra, 0);

    //
    //  Grow the top half.
    //
    GrowControls(IDC_HWTAB_LISTVIEW, IDC_HWTAB_LISTVIEW, 0, cyTop);

    //
    //  Move all the bottom things down.
    //
    ShiftControls(IDC_HWTAB_VMOVEFIRST, IDC_HWTAB_VMOVELAST, 0, cyTop);

    //
    //  Grow the groupbox by the pixels we are granting it.
    //
    GrowControls(IDC_HWTAB_VSIZEFIRST, IDC_HWTAB_VSIZELAST, 0, cyBottom);

    //
    //  And the buttons move with the bottom right corner.
    //
    ShiftControls(IDC_HWTAB_VDOWNFIRST, IDC_HWTAB_VDOWNLAST, cxExtra, cyBottom);

}

LRESULT
CHWTab::ParentSubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp, UINT_PTR uidSubclass, DWORD_PTR dwRefData)
{
    CHWTab *self = (CHWTab *)dwRefData;
    LRESULT lres = 0;

    switch (wm)
    {
    case WM_SIZE:
        self->RepositionControls();
        break;

    case WM_NOTIFY:
        lres = DefSubclassProc(hwnd, wm, wp, lp);
        if (lres) break;            // Parent already handled
        lres = SendMessage(self->_hdlg, wm, wp, lp);
        break;

    // Work around a bug in USER where if you press Enter, the WM_COMMAND
    // gets sent to the wrong window if it belongs to a nested dialog.
    case WM_COMMAND:
        if (GET_WM_COMMAND_HWND(wp, lp) &&
            GetParent(GET_WM_COMMAND_HWND(wp, lp)) == self->_hdlg) {
            lres = SendMessage(self->_hdlg, wm, wp, lp);
        } else {
            lres = DefSubclassProc(hwnd, wm, wp, lp);
        }
        break;

    case WM_DISPLAYCHANGE:
    case WM_SETTINGCHANGE:
    case WM_SYSCOLORCHANGE:
        lres = DefSubclassProc(hwnd, wm, wp, lp);
        lres = SendMessage(self->_hdlg, wm, wp, lp);
        break;

    default:
        lres = DefSubclassProc(hwnd, wm, wp, lp);
        break;
    }
    return lres;
}

//
//  One-time dialog initialization.
//
BOOL
CHWTab::OnInitDialog(HWND hdlg)
{
    _hdlg = hdlg;
    _hwndList = GetDlgItem(_hdlg, IDC_HWTAB_LISTVIEW);

    SetWindowLongPtr(_hdlg, DWLP_USER, (LONG_PTR)this);

    RepositionControls();

    //
    //  The "Name" column gets 75% and the "Type" column gets 25%.
    //  Subtract out the size of a vertical scrollbar in case we
    //  get one.
    //
    RECT rc;
    GetClientRect(_hwndList, &rc);
    rc.right -= GetSystemMetrics(SM_CXVSCROLL);

    LVCOLUMN col;
    TCHAR szTitle[64];

    col.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    col.fmt = LVCFMT_LEFT;
    col.cx = rc.right * 3 / 4;
    col.pszText = szTitle;

    LoadString(THIS_DLL, IDS_HWTAB_LV_NAME, szTitle, ARRAYLEN(szTitle));
    ListView_InsertColumn(_hwndList, 0, &col);

    col.cx = rc.right - col.cx;
    LoadString(THIS_DLL, IDS_HWTAB_LV_TYPE, szTitle, ARRAYLEN(szTitle));
    ListView_InsertColumn(_hwndList, 1, &col);

    if (_imageListData.ImageList)
    {
        ListView_SetImageList(_hwndList, _imageListData.ImageList, LVSIL_SMALL);
    }

    ListView_SetExtendedListViewStyle(_hwndList, LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);

    // Need to subclass parent to take over all parent functionality
    if (!SetWindowSubclass(GetParent(hdlg), ParentSubclassProc, 0,
                           (DWORD_PTR)this))
        DestroyWindow(hdlg);

    return TRUE;
}

void
CHWTab::RemoveListItems(HWND hwndList)
{
    LVITEM lviName;
    LPLISTITEM plistItem;

    int cItems = ListView_GetItemCount(hwndList);
    int iItem;

    for (iItem = 0; iItem < cItems; iItem++)
    {
        lviName.mask = LVIF_PARAM;
        lviName.iSubItem = 0;                   // column 0
        lviName.iItem = iItem;

        ListView_GetItem(hwndList,&lviName);

        plistItem = (LPLISTITEM) lviName.lParam;

        if (plistItem)
        {
            delete plistItem;
        }
    }

    ListView_DeleteAllItems(_hwndList);
}


//
//  Rebuild the list of devices.
//
//  This is done whenever we get focus.  We cache the results from last time
//  and invalidate the cache when we are told that hardware has changed.

void
CHWTab::RebuildDeviceList()
{
    HCURSOR hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));
    int devClass;

    // First clear out the existing listview
    RemoveListItems(_hwndList);
    Reset();


    // Get all the devices of our class

    for (devClass = 0; devClass < _iNumClass; devClass++)
    {
        _pCD[devClass].hdsaDinf = DSA_Create(sizeof(SP_DEVINFO_DATA), 4);

        if (!_pCD[devClass].hdsaDinf) goto done;

        _pCD[devClass].hdev = SetupDiGetClassDevs(&_pCD[devClass].devGuid, 0, 0,
                                    DIGCF_PROFILE | DIGCF_PRESENT);
        if (_pCD[devClass].hdev == INVALID_HANDLE_VALUE) goto done;


        // Study the class in preparation for adding it to our listview
        int idev;
        LVITEM lviName, lviType;
        TCHAR tszName[LINE_LEN];

        lviName.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
        lviName.iSubItem = 0;                       // column 0
        lviName.iImage = _pCD[devClass].iImage;    // image (or -1 if no image)
        lviName.pszText = tszName;                  // name goes here
        lviName.iItem = DA_LAST;                    // Always append

        // The second column contains the class description, which is the same
        // for all items.
        lviType.mask = LVIF_TEXT;
        lviType.iSubItem = 1;
        lviType.pszText = _pCD[devClass].tszClass;

        for (idev = 0; ; idev++)
        {
            SP_DEVINFO_DATA dinf;
            BOOL            fHidden = FALSE;

            dinf.cbSize = sizeof(dinf);


            if (SetupDiEnumDeviceInfo(_pCD[devClass].hdev, idev, &dinf)) {

                // Device status - Don't want to show devices with DN_NO_SHOW_IN_DM set, as a rule.
                ULONG Status, Problem;

                if (CM_Get_DevNode_Status_Ex(&Status, &Problem, dinf.DevInst, 0, NULL) == CR_SUCCESS)
                {
                    if (Status & DN_NO_SHOW_IN_DM)      // No, UI, mark this device as hidden.
                    {
                        fHidden = TRUE;
                    }
                }

                LPLISTITEM pListItem = new LISTITEM;

                if (!pListItem) break;

                pListItem->devClass = devClass;
                pListItem->dsaItem = DSA_AppendItem(_pCD[devClass].hdsaDinf, &dinf);
                lviName.lParam = (LPARAM) pListItem;

                if (lviName.lParam < 0)
                {
                    delete pListItem;
                    break;          // Out of memory
                }

                DWORD cbRequired;

                // Try the friendly name.  If that doesn't work, then try
                // the device name.  If that doesn't work, then say "Unknown".
                if (!GetDeviceRegistryProperty(_pCD[devClass].hdev, SPDRP_FRIENDLYNAME, &dinf, tszName, ARRAYLEN(tszName)) &&
                    !GetDeviceRegistryProperty(_pCD[devClass].hdev, SPDRP_DEVICEDESC  , &dinf, tszName, ARRAYLEN(tszName))) {
                    LoadString(THIS_DLL, IDS_HWTAB_UNKNOWN, tszName, ARRAYLEN(tszName));
                }

                // Give our parent a chance to filter the item before we insert it
                // Return TRUE to reject the item from the list.
                NMHWTAB nmht;
                nmht.nm.hwndFrom = _hdlg;
                nmht.nm.idFrom = 0;
                nmht.nm.code = HWN_FILTERITEM;
                nmht.hdev = _pCD[devClass].hdev;
                nmht.pdinf = &dinf;
                nmht.fHidden = fHidden;

                SendMessage(GetParent(_hdlg), WM_NOTIFY, nmht.nm.idFrom, (LPARAM)&nmht);

                if (!nmht.fHidden)
                {
                    // Add the Item
                    lviType.iItem = ListView_InsertItem(_hwndList, &lviName);
                    if (lviType.iItem >= 0)
                    {
                        ListView_SetItem(_hwndList, &lviType);
                    }
                    else
                    {
                        delete pListItem;
                    }
                }
                else
                {
                    // clean up the item; it got filtered away
                    delete pListItem;
                }
            }

            // Stop on any error after the 100'th device to keep us from going
            // berzerk if we start getting strange errors like ERROR_GENERAL_FAILURE.
            else if (GetLastError() == ERROR_NO_MORE_ITEMS || idev > 100) {
                break;
            }
        }

        // Select the first item so the info pane contains stuff
        ListView_SetItemState(_hwndList, 0, LVIS_SELECTED | LVIS_FOCUSED,
                                            LVIS_SELECTED | LVIS_FOCUSED);
    }

done:
    SetCursor(hcurPrev);
}

void
CHWTab::SprintfItem(UINT ids, UINT idc, LPCTSTR ptszText)
{
    TCHAR tszMsg[MAX_PATH];
    TCHAR tszOut[MAX_PATH + LINE_LEN];
    LoadString(THIS_DLL, ids, tszMsg, ARRAYLEN(tszMsg));
    wsprintf(tszOut, tszMsg, ptszText);
    SetDlgItemText(_hdlg, idc, tszOut);
}

void
CHWTab::OnItemChanged(LPNMLISTVIEW pnmlv)
{
    PSP_DEVINFO_DATA pdinf;
    LPLISTITEM pListItem = (LPLISTITEM) pnmlv->lParam;

    if ((pnmlv->uChanged & LVIF_STATE)  &&
        (pnmlv->uNewState & LVIS_FOCUSED) &&
        (pdinf = GetPdinf(pListItem)) != NULL) {

        TCHAR tsz[LINE_LEN];

        // Manufacturer
        GetDeviceRegistryProperty(_pCD[pListItem->devClass].hdev, SPDRP_MFG, pdinf, tsz, ARRAYLEN(tsz));
        SprintfItem(IDS_HWTAB_MFG, IDC_HWTAB_MFG, tsz);

        // Location
        if (GetLocationInformation(pdinf->DevInst, tsz, ARRAYLEN(tsz), NULL) != CR_SUCCESS) {
            LoadString(g_hInstance, IDS_UNKNOWN, tsz, ARRAYLEN(tsz));
        }
        SprintfItem(IDS_HWTAB_LOC, IDC_HWTAB_LOC, tsz);

        // Device status - have to go to CM for this one
        ULONG Status, Problem;
        if (CM_Get_DevNode_Status_Ex(&Status, &Problem,
                                     pdinf->DevInst, 0, NULL) == CR_SUCCESS &&
            DeviceProblemText(NULL, pdinf->DevInst, Problem, tsz, ARRAYLEN(tsz))) {
            // Yippee
        } else {
            tsz[0] = TEXT('\0');        // Darn
        }
        SprintfItem(IDS_HWTAB_STATUS, IDC_HWTAB_STATUS, tsz);

        //let our parent know that something changed
        NMHWTAB nmht;
        nmht.nm.hwndFrom = _hdlg;
        nmht.nm.idFrom = 0;
        nmht.nm.code = HWN_SELECTIONCHANGED;
        nmht.hdev = _pCD[pListItem->devClass].hdev;
        nmht.pdinf = pdinf;

        SendMessage(GetParent(_hdlg), WM_NOTIFY, nmht.nm.idFrom, (LPARAM)&nmht);
    }
}

void
CHWTab::OnProperties(void)
{
    LVITEM lvi;
    PSP_DEVINFO_DATA pdinf;

    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;                   // column 0
    lvi.iItem = ListView_GetNextItem(_hwndList, -1, LVNI_FOCUSED);


    if (lvi.iItem >= 0 && ListView_GetItem(_hwndList, &lvi) &&
        (pdinf = GetPdinf((LPLISTITEM) lvi.lParam)) != NULL)
    {
        DWORD cchRequired;
        LPLISTITEM pListItem;
        LPTSTR ptszDevid;

        pListItem = (LPLISTITEM) lvi.lParam;
        if (BUFFERQUERY_SUCCEEDED(
                SetupDiGetDeviceInstanceId(_pCD[pListItem->devClass].hdev, pdinf, NULL, 0, &cchRequired)) &&
            (ptszDevid = (LPTSTR)LocalAlloc(LPTR, cchRequired * sizeof(TCHAR)))) {
            if (SetupDiGetDeviceInstanceId(_pCD[pListItem->devClass].hdev, pdinf, ptszDevid, cchRequired, NULL)) {
                DevicePropertiesEx(GetParent(_hdlg), NULL, ptszDevid, 0, FALSE);
            }
            LocalFree(ptszDevid);
        }
    }
}

void
CHWTab::OnTshoot(void)
{
    LVITEM lvi;
    PSP_DEVINFO_DATA pdinf;

    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;                   // column 0
    lvi.iItem = ListView_GetNextItem(_hwndList, -1, LVNI_FOCUSED);


    if (lvi.iItem >= 0 && ListView_GetItem(_hwndList, &lvi) &&
        (pdinf = GetPdinf((LPLISTITEM) lvi.lParam)) != NULL)
    {
        DWORD cchRequired;
        LPLISTITEM pListItem;
        LPTSTR ptszDevid;

        pListItem = (LPLISTITEM) lvi.lParam;
        if (BUFFERQUERY_SUCCEEDED(
                SetupDiGetDeviceInstanceId(_pCD[pListItem->devClass].hdev, pdinf, NULL, 0, &cchRequired)) &&
            (ptszDevid = (LPTSTR)LocalAlloc(LPTR, cchRequired * sizeof(TCHAR)))) {
            if (SetupDiGetDeviceInstanceId(_pCD[pListItem->devClass].hdev, pdinf, ptszDevid, cchRequired, NULL)) {
                DeviceProblemWizard(GetParent(_hdlg), NULL, ptszDevid);
            }
            LocalFree(ptszDevid);
        }
    }
}

//
//  SetText is how the caller tells us what our troubleshooter
//  command line is.
//
void
CHWTab::OnSetText(LPCTSTR ptszText)
{
    BOOL fEnable = ptszText && ptszText[0];
    HWND hwndTS = GetDlgItem(_hdlg, IDC_HWTAB_TSHOOT);
    EnableWindow(hwndTS, fEnable);
    ShowWindow(hwndTS, fEnable ? SW_SHOW : SW_HIDE);
}

void
CHWTab::OnHelp(LPHELPINFO phi)
{
    WinHelp((HWND)phi->hItemHandle, DEVMGR_HELP_FILE_NAME, HELP_WM_HELP,
            (ULONG_PTR)c_HWTabHelpIDs);
}

void
CHWTab::OnContextMenu(HWND hwnd)
{
    WinHelp(hwnd, DEVMGR_HELP_FILE_NAME, HELP_CONTEXTMENU,
            (ULONG_PTR)c_HWTabHelpIDs);
}

//
//  Dialog procedure (yay).
//
INT_PTR CALLBACK
CHWTab::DialogProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp)
{
    CHWTab *self = (CHWTab *)GetWindowLongPtr(hdlg, DWLP_USER);

    if (wm == WM_INITDIALOG) {
        self = (CHWTab *)lp;
        return self->OnInitDialog(hdlg);
    }

    // Ignores messages that arrive before WM_INITDIALOG
    if (!self) return FALSE;

    switch (wm) {
    case WM_DISPLAYCHANGE:
    case WM_SETTINGCHANGE:
    case WM_SYSCOLORCHANGE:
        SendMessage(self->_hwndList, wm, wp, lp);
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnm = (LPNMHDR)lp;
            switch (pnm->code) {
            case PSN_SETACTIVE:
                self->RebuildDeviceList();
                break;

            case LVN_ITEMCHANGED:
                if (pnm->hwndFrom == self->_hwndList) {
                    self->OnItemChanged((LPNMLISTVIEW)pnm);
                }
                break;

            case NM_DBLCLK:
                if (pnm->hwndFrom == self->_hwndList) {
                    DWORD dwPos = GetMessagePos();
                    LVHITTESTINFO hti;
                    hti.pt.x = GET_X_LPARAM(dwPos);
                    hti.pt.y = GET_Y_LPARAM(dwPos);
                    ScreenToClient(self->_hwndList, &hti.pt);
                    ListView_HitTest(self->_hwndList, &hti);
                    if (hti.iItem >= 0)
                        self->OnProperties();
                }
                break;
            }
        }
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wp, lp)) {
        case IDC_HWTAB_PROP:
            self->OnProperties();
            break;

        case IDC_HWTAB_TSHOOT:
            self->OnTshoot();
            break;
        }
        break;

    case WM_SETTEXT:
        self->OnSetText((LPCTSTR)lp);
        break;

    case WM_NCDESTROY:
        if (self && self->_hwndList)
        {
            self->RemoveListItems(self->_hwndList);
        }
        RemoveWindowSubclass(GetParent(hdlg), ParentSubclassProc, 0);
        delete self;
        break;

    case WM_HELP:
        self->OnHelp((LPHELPINFO)lp);
        break;

    case WM_CONTEXTMENU:
        self->OnContextMenu((HWND)wp);
        break;
    }


    return FALSE;
}

//
//  Create a Hardware page for the specified GUID.
//
//  Parameters:
//
//      hwndParent - The dummy frame window created by the caller
//      pguid      - The setup device class GUID we will manage
//
//  Returns:
//
//      HWND of the created subdialog.
//
//  Usage:
//
//      When your control panel applet needs a Hardware page, create
//      a blank dialog template titled "Hardware" and add it to your
//      control panel.  Set the size of the blank to be the size you
//      want the final Hardware Tab page to be.
//
//      Your dialog box procedure should go like this:
//
//      BOOL HardwareDlgProc(HWND hdlg, UINT uMsg, WPARAM wp, LPARAM lp) {
//          switch (uMsg) {
//
//          case WM_INITDIALOG:
//              // GUID_DEVCLASS_MOUSE is in devguid.h
//              hwndHW = DeviceCreateHardwarePage(hdlg, &GUID_DEVCLASS_MOUSE);
//              if (hwndHW) {
//                  // Optional - Set the troubleshooter command line.
//                  // Do this if you want a Troubleshoot button.
//                  SetWindowText(hwndHW,
//                      TEXT("hh.exe mk:@MSITStore:tshoot.chm::/hdw_drives.htm"));
//              } else {
//                  DestroyWindow(hdlg); // catastrophic failure
//              }
//              return TRUE;
//          }
//          return FALSE;
//      }
//

STDAPI_(HWND) DeviceCreateHardwarePageEx(HWND hwndParent, const GUID *pguid, int iNumClass, DWORD dwViewMode)
{
    if (!hwndParent || !pguid)
        return NULL;

    HCURSOR hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));
    CHWTab *self = new CHWTab(pguid, iNumClass, dwViewMode);

    HWND hwnd;

    if (self) {
        hwnd = CreateDialogParam(THIS_DLL, MAKEINTRESOURCE(IDD_HWTAB),
                            hwndParent, CHWTab::DialogProc, (LPARAM)self);
        if (!hwnd) {
            delete self;
            hwnd = NULL;
        }
    } else {
        hwnd = NULL;
    }

    SetCursor(hcurPrev);
    return hwnd;
}

STDAPI_(HWND) DeviceCreateHardwarePage(HWND hwndParent, const GUID *pguid)
{
    return DeviceCreateHardwarePageEx(hwndParent, pguid, 1, HWTAB_SMALLLIST);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\hwprof.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    hwprof.cpp

Abstract:

    This module implements CHwProfileList and CHwProfile classes.

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "devmgr.h"
#include "hwprof.h"


BOOL
CHwProfileList::Create(
    CDevice* pDevice,
    DWORD ConfigFlags
    )
{
    // first get the current profile index.
    HWPROFILEINFO   HwProfileInfo;
    ASSERT(pDevice);
    m_pDevice = pDevice;
    // get the current profile index.
    if (!m_pDevice->m_pMachine->CmGetCurrentHwProfile(&m_CurHwProfile))
    return FALSE;
    // go through each profile and create a CHwProfile for it
    int Index = 0;
    CHwProfile* phwpf;
    while (m_pDevice->m_pMachine->CmGetHwProfileInfo(Index, &HwProfileInfo))
    {
    DWORD hwpfFlags;
    // get the hwprofile flags for this device
    // if failed, use the given ConfigFlags
    if (m_pDevice->m_pMachine->CmGetHwProfileFlags((
                LPTSTR)m_pDevice->GetDeviceID(),
                HwProfileInfo.HWPI_ulHWProfile,
                &hwpfFlags))
    {
        if (hwpfFlags & CSCONFIGFLAG_DO_NOT_CREATE)
        {
        // skip this profile
        Index++;
        continue;
        }
    }
    else
    {
        // flags have not been set for this profile yet.
        hwpfFlags = ConfigFlags;
    }

    ASSERT(CONFIGFLAG_DISABLED == CSCONFIGFLAG_DISABLED);

    hwpfFlags |= ConfigFlags;
    // rememeber current hw profile index
    if (m_CurHwProfile == HwProfileInfo.HWPI_ulHWProfile)
        m_CurHwProfileIndex = Index;
    phwpf = new CHwProfile(Index, &HwProfileInfo, pDevice, hwpfFlags);
    m_listProfile.AddTail(phwpf);
    Index++;
    }
    return TRUE;

}

CHwProfileList::~CHwProfileList()
{
    if (!m_listProfile.IsEmpty())
    {
    POSITION pos = m_listProfile.GetHeadPosition();
    while (NULL != pos)
    {
        CHwProfile* pProfile =  m_listProfile.GetNext(pos);
        delete pProfile;
    }
    m_listProfile.RemoveAll();
    }
}

BOOL
CHwProfileList::GetFirst(
    CHwProfile** pphwpf,
    PVOID&  Context
    )
{
    ASSERT(pphwpf);

    if (!m_listProfile.IsEmpty())
    {
        POSITION pos = m_listProfile.GetHeadPosition();
        *pphwpf = m_listProfile.GetNext(pos);
        Context = pos;
        return TRUE;
    }
    
    Context = NULL;
    *pphwpf = NULL;
    return FALSE;
}

BOOL
CHwProfileList::GetNext(
    CHwProfile** pphwpf,
    PVOID&  Context
    )
{
    ASSERT(pphwpf);
    POSITION pos = (POSITION)Context;

    if (NULL != pos)
    {
        *pphwpf = m_listProfile.GetNext(pos);
        Context = pos;
        return TRUE;
    }
    
    *pphwpf = NULL;
    return FALSE;
}

BOOL 
CHwProfileList::GetCurrentHwProfile(
    CHwProfile** pphwpf
    )
{
    ASSERT(pphwpf);

    POSITION pos = m_listProfile.FindIndex(m_CurHwProfileIndex);
    *pphwpf = m_listProfile.GetAt(pos);

    return TRUE;
}

ULONG
CHwProfileList::IndexToHwProfile(
    int HwProfileIndex
    )
{
    if (HwProfileIndex >= m_listProfile.GetCount())
    return 0XFFFFFFFF;
    POSITION pos = m_listProfile.FindIndex(HwProfileIndex);
    CHwProfile* pHwProfile = m_listProfile.GetAt(pos);
    return pHwProfile->GetHwProfile();
}

CHwProfile::CHwProfile(
    int Index,
    PHWPROFILEINFO phwpfInfo,
    CDevice* pDevice,
    DWORD Flags
    )
{
    m_Index = Index;
    m_hwpfInfo = *phwpfInfo;
    m_pDevice = pDevice;
    m_EnablePending = FALSE;
    m_DisablePending = FALSE;
    m_Flags = Flags;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\machine.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    machine.cpp

Abstract:

    This module implements CDevInfoList, CMachine and CMachineList

Author:

    William Hsieh (williamh) created

Revision History:


--*/


#include "devmgr.h"

extern "C" {
#include <initguid.h>
#include <dbt.h>
#include <devguid.h>
#include <wdmguid.h>
}


//
//private setupapi export
//
DWORD
pSetupGuidFromString(
                    PWCHAR GuidString,
                    LPGUID Guid
                    );



CONST TCHAR*    DEVMGR_NOTIFY_CLASS_NAME = TEXT("DevMgrNotifyClass");

CONST TCHAR*    DEVMGR_REFRESH_MSG = TEXT("DevMgrRefreshOn");

//
// The constant is the size we use to allocate GUID list from within
// stack when we have to build a GUID list. The aim of this is
// that buiding a guid list take time and in many case, a minimum
// buffer should retrive all of them. We do not want to get
// the size first, allocate buffer and get it again.
// 64 looks to be fair enough value because there are not
// many classes out there today (and maybe, in the future).
//
const int GUID_LIST_INIT_SIZE =     64;

//
// CDevInfoList implementation
//
BOOL
CDevInfoList::DiGetExtensionPropSheetPage(
                                         PSP_DEVINFO_DATA DevData,
                                         LPFNADDPROPSHEETPAGE pfnAddPropSheetPage,
                                         DWORD PageType,
                                         LPARAM lParam
                                         )
{
    SP_PROPSHEETPAGE_REQUEST PropPageRequest;
    LPFNADDPROPSHEETPAGES AddPropPages;

    PropPageRequest.cbSize = sizeof(PropPageRequest);
    PropPageRequest.PageRequested = PageType;
    PropPageRequest.DeviceInfoSet = m_hDevInfo;
    PropPageRequest.DeviceInfoData = DevData;

    if (SPPSR_SELECT_DEVICE_RESOURCES == PageType) {
        HINSTANCE hModule = ::GetModuleHandle(TEXT("setupapi.dll"));

        if (hModule) {
            AddPropPages = (LPFNADDPROPSHEETPAGES)GetProcAddress(hModule, "ExtensionPropSheetPageProc");

            if (AddPropPages) {
                if (AddPropPages(&PropPageRequest, pfnAddPropSheetPage, lParam)) {
                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}

BOOL
CDevInfoList::InstallDevInst(
                            HWND hwndParent,
                            LPCTSTR DeviceId,
                            BOOL    UpdateDriver,
                            DWORD* pReboot
                            )
{
    BOOL Result = FALSE;
    HINSTANCE hLib = LoadLibrary(TEXT("newdev.dll"));
    LPFNINSTALLDEVINST InstallDevInst;
    DWORD Status = ERROR_SUCCESS;

    if (hLib) {
        InstallDevInst = (LPFNINSTALLDEVINST)GetProcAddress(hLib, "InstallDevInst");

        if (InstallDevInst) {
            Result = (*InstallDevInst)(hwndParent, DeviceId, UpdateDriver,
                                       pReboot);

            Status = GetLastError();
        }
    }

    if (hLib) {
        FreeLibrary(hLib);
    }

    //
    // We need to put back the error code that was set by newdev.dll's InstallDevInst
    // API.  This last error gets overwritten by FreeLibrary which we don't care about.
    //
    SetLastError(Status);

    return Result;
}

BOOL
CDevInfoList::RollbackDriver(
                            HWND hwndParent,
                            LPCTSTR RegistryKeyName,
                            DWORD Flags,
                            DWORD* pReboot
                            )
{
    BOOL Result = FALSE;
    HINSTANCE hLib = LoadLibrary(TEXT("newdev.dll"));
    LPFNROLLBACKDRIVER RollbackDriver;

    if (hLib) {
        RollbackDriver = (LPFNROLLBACKDRIVER)GetProcAddress(hLib, "RollbackDriver");

        if (RollbackDriver) {
            Result = (*RollbackDriver)(hwndParent, RegistryKeyName, Flags, pReboot);
        }
    }

    if (hLib) {
        FreeLibrary(hLib);
    }

    return Result;
}

DWORD
CDevInfoList::DiGetFlags(
                        PSP_DEVINFO_DATA DevData
                        )
{
    SP_DEVINSTALL_PARAMS dip;
    dip.cbSize = sizeof(dip);

    if (DiGetDeviceInstallParams(DevData, &dip)) {
        return dip.Flags;
    }

    return 0;
}

DWORD
CDevInfoList::DiGetExFlags(
                          PSP_DEVINFO_DATA DevData
                          )
{
    SP_DEVINSTALL_PARAMS dip;
    dip.cbSize = sizeof(dip);

    if (DiGetDeviceInstallParams(DevData, &dip)) {
        return dip.FlagsEx;
    }

    return 0;
}

BOOL
CDevInfoList::DiTurnOnDiFlags(
                             PSP_DEVINFO_DATA DevData,
                             DWORD FlagsMask
                             )
{
    SP_DEVINSTALL_PARAMS dip;
    dip.cbSize = sizeof(dip);

    if (DiGetDeviceInstallParams(DevData, &dip)) {
        dip.Flags |= FlagsMask;
        return DiSetDeviceInstallParams(DevData, &dip);
    }

    return FALSE;
}

BOOL
CDevInfoList::DiTurnOffDiFlags(
                              PSP_DEVINFO_DATA DevData,
                              DWORD FlagsMask
                              )
{
    SP_DEVINSTALL_PARAMS dip;
    dip.cbSize = sizeof(dip);

    if (DiGetDeviceInstallParams(DevData, &dip)) {
        dip.Flags &= ~FlagsMask;
        return DiSetDeviceInstallParams(DevData, &dip);
    }

    return FALSE;
}

BOOL
CDevInfoList::DiTurnOnDiExFlags(
                               PSP_DEVINFO_DATA DevData,
                               DWORD FlagsMask
                               )
{
    SP_DEVINSTALL_PARAMS dip;
    dip.cbSize = sizeof(dip);

    if (DiGetDeviceInstallParams(DevData, &dip)) {
        dip.FlagsEx |= FlagsMask;
        return DiSetDeviceInstallParams(DevData, &dip);
    }

    return FALSE;
}

BOOL
CDevInfoList::DiTurnOffDiExFlags(
                                PSP_DEVINFO_DATA DevData,
                                DWORD FlagsMask
                                )
{
    SP_DEVINSTALL_PARAMS dip;
    dip.cbSize = sizeof(dip);

    if (DiGetDeviceInstallParams(DevData, &dip)) {
        dip.FlagsEx &= ~FlagsMask;
        return DiSetDeviceInstallParams(DevData, &dip);
    }

    return FALSE;
}

void
CDevInfoList::DiDestroyDeviceInfoList()
{
    if (INVALID_HANDLE_VALUE != m_hDevInfo) {
        SetupDiDestroyDeviceInfoList(m_hDevInfo);
        m_hDevInfo = INVALID_HANDLE_VALUE;
    }
}

BOOL
CDevInfoList::DiGetDeviceMFGString(
                                  PSP_DEVINFO_DATA DevData,
                                  TCHAR* pBuffer,
                                  DWORD  Size,
                                  DWORD* pRequiredSize
                                  )
{
    if (Size && !pBuffer) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    DWORD ActualSize = 0;
    BOOL Result;
    Result = DiGetDeviceRegistryProperty(DevData, SPDRP_MFG, NULL,
                                         (PBYTE)pBuffer,
                                         Size * sizeof(TCHAR),
                                         &ActualSize);

    if (pRequiredSize) {
        *pRequiredSize = ActualSize / sizeof(TCHAR);
    }

    return Result;
}

BOOL
CDevInfoList::DiGetDeviceMFGString(
                                  PSP_DEVINFO_DATA DevData,
                                  String& str
                                  )
{
    DWORD RequiredSize = 0;
    TCHAR MFG[LINE_LEN];

    if (DiGetDeviceMFGString(DevData, MFG, ARRAYLEN(MFG), &RequiredSize)) {
        str = MFG;
        return TRUE;
    }

    return FALSE;
}

BOOL
CDevInfoList::DiGetDeviceIDString(
                                 PSP_DEVINFO_DATA DevData,
                                 TCHAR* pBuffer,
                                 DWORD  Size,
                                 DWORD* pRequiredSize
                                 )
{
    if (Size && !pBuffer) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    DWORD ActualSize = 0;
    BOOL Result;
    Result = DiGetDeviceRegistryProperty(DevData, SPDRP_HARDWAREID, NULL,
                                         (PBYTE) pBuffer,
                                         Size * sizeof(TCHAR), &ActualSize);

    if (pRequiredSize) {
        *pRequiredSize = ActualSize / sizeof(TCHAR);
    }

    return Result;
}

BOOL
CDevInfoList::DiGetDeviceIDString(
                                 PSP_DEVINFO_DATA DevData,
                                 String& str
                                 )
{
    BOOL Result;
    DWORD RequiredSize = 0;
    TCHAR DeviceId[MAX_DEVICE_ID_LEN];

    if (DiGetDeviceIDString(DevData, DeviceId, ARRAYLEN(DeviceId), &RequiredSize)) {
        str = DeviceId;
        return TRUE;
    }

    return FALSE;
}

/////////////////////////////////////////////////////////////////////
////  CMachine implementation
////
//
// For every single instance of DevMgr.dll, we maintain a CMachine list
// from which different instances of IComponentData(and IComponent) will
// attach to. The objects created(CDevice, Class, HDEVINFO and etc) are
// shared by all the attached IComponentData and IComponent(the implementation
// use CFolder as the controlling identify).
// Everything changed to the CMachine or one of its object will inform
// all the attached CFolders which would pass the information down to their
// sub-objects(CResultView).
// Imaging that you have two Device Manager window in the same console
// and you do a refresh on one the window. The other window must also
// do a refresh after the first one is done. Since both windows shares
// the same machine(and will get the same notification when machine states
// changed), we can keep the two windows in sync.

CMachine::CMachine(
                  LPCTSTR pMachineName
                  )
{
    InitializeCriticalSection(&m_CriticalSection);
    InitializeCriticalSection(&m_PropertySheetCriticalSection);
    InitializeCriticalSection(&m_ChildMachineCriticalSection);

    //
    // Get various privilege levels, like if the user has the SE_LOAD_DRIVER_NAME
    // privileg or if the user is a Guest.
    //
    g_HasLoadDriverNamePrivilege = pSetupDoesUserHavePrivilege((PCTSTR)SE_LOAD_DRIVER_NAME);
    m_UserIsAGuest = SHTestTokenMembership(NULL, DOMAIN_ALIAS_RID_GUESTS);

    m_RefreshDisableCounter = 0;
    m_RefreshPending = FALSE;
    m_pComputer = NULL;
    m_hMachine = NULL;
    m_ParentMachine = NULL;
    m_Initialized = FALSE;
    TCHAR LocalName[MAX_PATH + 1];
    DWORD dwSize = sizeof(LocalName) / sizeof(TCHAR);

    if (!GetComputerName(LocalName, &dwSize)) {
        LocalName[0] = _T('\0');
    }

    m_strMachineFullName.Empty();
    m_strMachineDisplayName.Empty();

    //
    // Skip over any leading '\' chars
    //
    if (pMachineName && _T('\0') != *pMachineName) {
        int len = lstrlen(pMachineName);
        ASSERT(len >= 3 && _T('\\') == pMachineName[0] && _T('\\') == pMachineName[1]);
        m_strMachineDisplayName = &pMachineName[2];
        m_strMachineFullName = pMachineName;
        m_IsLocal = (0 == m_strMachineDisplayName.CompareNoCase(LocalName));
    }

    else {
        //
        // Local machine
        //
        m_strMachineDisplayName = LocalName;
        m_strMachineFullName = TEXT("\\\\") + m_strMachineDisplayName;
        m_IsLocal = TRUE;
    }

    m_hwndNotify = NULL;
    m_msgRefresh = 0;
    m_ShowNonPresentDevices = FALSE;
    m_PropertySheetShoudDestroy = FALSE;

    TCHAR Buffer[MAX_PATH];
    DWORD BufferLen;

    //
    // If the environment variable DEVMGR_SHOW_NONPRESENT_DEVICES does exist and it
    // is not 0 then we will show Phantom devices.
    //
    if (((BufferLen = ::GetEnvironmentVariable(TEXT("DEVMGR_SHOW_NONPRESENT_DEVICES"),
                                               Buffer,
                                               sizeof(Buffer)/sizeof(TCHAR))) != 0) &&
        ((BufferLen > 1) ||
         (lstrcmp(Buffer, TEXT("0"))))) {

        m_ShowNonPresentDevices = TRUE;
    }
}

BOOL
CMachine::Initialize(
                    IN HWND hwndParent,
                    IN LPCTSTR DeviceId,    OPTIONAL
                    IN LPGUID ClassGuid     OPTIONAL
                    )
{
    BOOL Result = TRUE;
    m_hwndParent = hwndParent;

    if (m_Initialized) {
        return TRUE;
    }

    if (DeviceId && _T('\0') == *DeviceId) {
        DeviceId = NULL;
    }

    HCURSOR hCursorOld;
    hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

    if (DeviceId || ClassGuid) {

        //
        // We are ready for device change notification, create the notify window
        //
        //Result = CreateNotifyWindow();

        if (CreateClassesAndDevices(DeviceId, ClassGuid)) {

            m_Initialized = TRUE;
        }

    } else {

        //
        // We are ready for device change notification, create the notify window
        //
        Result = CreateNotifyWindow();

        m_Initialized = TRUE;

        ScheduleRefresh();
    }

    if (hCursorOld) {
        SetCursor(hCursorOld);
    }

    return Result;
}

BOOL
CMachine::ScheduleRefresh()
{
    Lock();

    //
    // Only queue the the request if there is no requests outstanding
    // and we have a valid window handle/message to the notify window.
    //
    if (!m_RefreshPending && m_hwndNotify && m_msgRefresh) {
        //
        // Broadcast the message so that every instance runs on
        // the computer get the notification
        //
        ::PostMessage(HWND_BROADCAST, m_msgRefresh, 0, 0);
    }

    Unlock();
    return TRUE;

}

//
// This function creates a data window to receive WM_DEVICECHANGE notification
// so that we can refresh the device tree. It also registers a private
// message so that anybody can post a refresh request.
//
BOOL
CMachine::CreateNotifyWindow()
{
    WNDCLASS wndClass;

    //
    // Lets see if the class has been registered.
    //
    if (!GetClassInfo(g_hInstance, DEVMGR_NOTIFY_CLASS_NAME, &wndClass)) {
        //
        // Register the class
        //
        memset(&wndClass, 0, sizeof(wndClass));
        wndClass.lpfnWndProc = dmNotifyWndProc;
        wndClass.hInstance = g_hInstance;
        wndClass.lpszClassName = DEVMGR_NOTIFY_CLASS_NAME;

        if (!RegisterClass(&wndClass)) {
            return FALSE;
        }
    }

    //
    // Register a private message for refresh. The name must contain
    // the target machine name so that every machine has its own message.
    //
    String strMsg = DEVMGR_REFRESH_MSG;
    strMsg += m_strMachineDisplayName;
    m_msgRefresh = RegisterWindowMessage(strMsg);

    if (m_msgRefresh) {
        //
        // Create a data window.
        //
        m_hwndNotify = CreateWindowEx(WS_EX_TOOLWINDOW, DEVMGR_NOTIFY_CLASS_NAME,
                                      TEXT(""),
                                      WS_DLGFRAME|WS_BORDER|WS_DISABLED,
                                      CW_USEDEFAULT, CW_USEDEFAULT,
                                      0, 0, NULL, NULL, g_hInstance, (void*)this);
        return(NULL != m_hwndNotify);
    }

    return FALSE;
}

//
// This is the WM_DEVICECHANGE window procedure running in the main thread
// context. It listens to two messages:
// (1). WM_DEVICECHANGE  broadcasted by Configuration Manager on device
//      addition/removing.
// (2). Private refresh message broadcasted by different instance
//      of Device Manager targeting on the same machine.
// On WM_CREATE, we participate the WM_DEVICECHANGE notification chain
// while on WM_DESTROY, we detach oursleves from the chain.
// There are occasions that we have to detach and re-attach to the
// chain duing the window life time, for example, during device uninstallation
// or during re-enumeration. The EnableFresh function is the place
// that does the attach/detach.
//
//
LRESULT
dmNotifyWndProc(
               HWND hWnd,
               UINT uMsg,
               WPARAM wParam,
               LPARAM lParam
               )
{
    CMachine* pThis;
    pThis = (CMachine*)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    //
    // Special case for private refresh message
    //
    if (pThis && uMsg == pThis->m_msgRefresh) {
        pThis->Refresh();
        return FALSE;
    }

    switch (uMsg) {
    case WM_CREATE:
        {
            pThis =  (CMachine*)((CREATESTRUCT*)lParam)->lpCreateParams;
            SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)pThis);
            break;
        }

    case WM_DEVICECHANGE:
        {
            if (DBT_DEVNODES_CHANGED == wParam) {

                //
                // While we are in WM_DEVICECHANGE context,
                // no CM apis can be called because it would
                // deadlock. Here, we schedule a timer so that
                // we can handle the message later on.
                //
                SetTimer(hWnd, DM_NOTIFY_TIMERID, 1000, NULL);
            }
            break;
        }

    case WM_TIMER:
        {
            if (DM_NOTIFY_TIMERID == wParam) {
                KillTimer(hWnd, DM_NOTIFY_TIMERID);
                ASSERT(pThis);
                pThis->ScheduleRefresh();
            }
            break;
        }

    default:
        break;
    }

    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

//
// This function attaches the given CFolder to the class.
// An attached CFolder will get notified when there are state
// changes in the class(Refresh, property changes, for example).
//
BOOL
CMachine::AttachFolder(
                      CFolder* pFolder
                      )
{
    ASSERT(pFolder);

    if (!IsFolderAttached(pFolder)) {
        pFolder->MachinePropertyChanged(this);
        m_listFolders.AddTail(pFolder);
    }

    return TRUE;
}

BOOL
CMachine::IsFolderAttached(
                          CFolder* pFolder
                          )
{
    if (!m_listFolders.IsEmpty()) {
        POSITION pos = m_listFolders.GetHeadPosition();

        while (NULL != pos) {
            if (pFolder == m_listFolders.GetNext(pos)) {
                return TRUE;
            }
        }
    }

    return FALSE;
}

void
CMachine::DetachFolder(
                      CFolder* pFolder
                      )
{
    POSITION nextpos = m_listFolders.GetHeadPosition();

    while (nextpos) {
        POSITION pos = nextpos;

        CFolder* pFolderToTest = m_listFolders.GetNext(nextpos);

        if (pFolderToTest == pFolder) {
            m_listFolders.RemoveAt(pos);
            break;
        }
    }
}

BOOL
CMachine::AttachPropertySheet(
                             HWND hwndPropertySheet
                             )
{
    ASSERT(hwndPropertySheet);

    EnterCriticalSection(&m_PropertySheetCriticalSection);

    m_listPropertySheets.AddTail(hwndPropertySheet);

    LeaveCriticalSection(&m_PropertySheetCriticalSection);

    return TRUE;
}

void
CMachine::DetachPropertySheet(
                             HWND hwndPropertySheet
                             )
{
    EnterCriticalSection(&m_PropertySheetCriticalSection);

    POSITION nextpos = m_listPropertySheets.GetHeadPosition();

    while (nextpos) {
        POSITION pos = nextpos;

        HWND hwndPropertySheetToTest = m_listPropertySheets.GetNext(nextpos);

        if (hwndPropertySheetToTest == hwndPropertySheet) {
            m_listPropertySheets.RemoveAt(pos);
            break;
        }
    }

    LeaveCriticalSection(&m_PropertySheetCriticalSection);
}

HWND
CMachine::GetDeviceWindowHandle(
    LPCTSTR DeviceId
    )
{
    HWND hwnd = NULL;

    EnterCriticalSection(&m_ChildMachineCriticalSection);

    //
    // Enumerate the list of Child CMachines
    //
    if (!m_listChildMachines.IsEmpty()) {

        PVOID DeviceContext;
        CDevice* pDevice;

        POSITION nextpos = m_listChildMachines.GetHeadPosition();

        while (nextpos) {

            CMachine* pChildMachine = m_listChildMachines.GetNext(nextpos);

            //
            // Child machines will only have one device (if any at all)
            //
            if (pChildMachine->GetFirstDevice(&pDevice, DeviceContext) &&
                pDevice) {

                //
                // If the device Ids match then get the window handle
                //
                if (lstrcmpi(pDevice->GetDeviceID(), DeviceId) == 0) {

                    hwnd = pDevice->m_psd.GetWindowHandle();
                    break;
                }
            }
        }
    }

    LeaveCriticalSection(&m_ChildMachineCriticalSection);

    return hwnd;
}

HWND
CMachine::GetClassWindowHandle(
    LPGUID ClassGuid
    )
{
    HWND hwnd = NULL;

    EnterCriticalSection(&m_ChildMachineCriticalSection);

    //
    // Enumerate the list of Child CMachines
    //
    if (!m_listChildMachines.IsEmpty()) {

        PVOID ClassContext;
        CClass* pClass;

        POSITION nextpos = m_listChildMachines.GetHeadPosition();

        while (nextpos) {

            CMachine* pChildMachine = m_listChildMachines.GetNext(nextpos);

            //
            // Any child CMachine that has a device is a device property sheet.
            // We only want to look at the ones that have 0 devices since those
            // will be class property sheets.
            //
            if (pChildMachine->GetNumberOfDevices() == 0) {

                if (pChildMachine->GetFirstClass(&pClass, ClassContext) &&
                    pClass) {

                    //
                    // If the ClassGuids match then get the window handle
                    //
                    if (IsEqualGUID(*ClassGuid, *pClass)) {

                        hwnd = pClass->m_psd.GetWindowHandle();
                        break;
                    }
                }
            }
        }
    }

    LeaveCriticalSection(&m_ChildMachineCriticalSection);

    return hwnd;
}

BOOL
CMachine::AttachChildMachine(
                            CMachine* ChildMachine
                            )
{
    ASSERT(ChildMachine);

    EnterCriticalSection(&m_ChildMachineCriticalSection);

    m_listChildMachines.AddTail(ChildMachine);

    LeaveCriticalSection(&m_ChildMachineCriticalSection);

    return TRUE;
}

void
CMachine::DetachChildMachine(
                            CMachine* ChildMachine
                            )
{
    EnterCriticalSection(&m_ChildMachineCriticalSection);

    POSITION nextpos = m_listChildMachines.GetHeadPosition();

    while (nextpos) {
        POSITION pos = nextpos;

        CMachine* CMachineToTest = m_listChildMachines.GetNext(nextpos);

        if (CMachineToTest == ChildMachine) {
            m_listChildMachines.RemoveAt(pos);
            break;
        }
    }

    LeaveCriticalSection(&m_ChildMachineCriticalSection);
}

CMachine::~CMachine()
{
    //
    // Turn off refresh.  We need to do this in case there are any property
    // sheets that are still active.
    //
    EnableRefresh(FALSE);

    //
    // We first need to destroy all child CMachines
    //
    while (!m_listChildMachines.IsEmpty()) {

        //
        // Remove the first child machine from the list.  We need to
        // do this in the critical section.
        //
        EnterCriticalSection(&m_ChildMachineCriticalSection);

        CMachine* ChildMachine = m_listChildMachines.RemoveHead();

        //
        // Set the m_ParentMachine to NULL so we won't try to remove it from
        // the list again.
        //
        ChildMachine->m_ParentMachine = NULL;

        LeaveCriticalSection(&m_ChildMachineCriticalSection);

        delete ChildMachine;
    }

    //
    // We need to wait for all of the property sheets to be destroyed.
    //
    // We will check to see if there are any property pages still around, and
    // if there is we will wait for 1 second and then check again.  After 5
    // seconds we will give up and just destroy the CMachine anyway.
    //
    int iSecondsCount = 0;

    while (!m_listPropertySheets.IsEmpty() &&
           (iSecondsCount++ < 10)) {

        //
        // Enumerate through all of the property sheets left and if IsWindow fails
        // then pull them from the list, otherwise call DestroyWindow on them.
        //
        // Since property sheets each run in their own thread we need to do this
        // in a critical section.
        //
        EnterCriticalSection(&m_PropertySheetCriticalSection);

        POSITION nextpos = m_listPropertySheets.GetHeadPosition();

        while (nextpos) {
            POSITION pos = nextpos;

            HWND hwndPropertySheetToTest = m_listPropertySheets.GetNext(nextpos);

            if (IsWindow(hwndPropertySheetToTest)) {
                //
                // There is still a valid window for this property sheet so
                // call DestroyWindow on it.
                //
                ::DestroyWindow(hwndPropertySheetToTest);
            } else {
                //
                // There is no window for this property sheet so just remove
                // it from the list
                //
                m_listPropertySheets.RemoveAt(pos);
            }
        }

        LeaveCriticalSection(&m_PropertySheetCriticalSection);

        //
        // Sleep for .5 seconds and then try again.  This will give the property pages time to
        // finish up their work.
        //
        Sleep(500);
    }


    // if we have created a device change data window for this machine,
    // destroy it.
    if (m_hwndNotify && IsWindow(m_hwndNotify)) {
        ::DestroyWindow(m_hwndNotify);
        m_hwndNotify = NULL;
    }

    DestroyClassesAndDevices();

    if (!m_listFolders.IsEmpty()) {
        m_listFolders.RemoveAll();
    }

    //
    // If we have a parent CMachine then we need to remove oursleves from
    // his list of Child CMachines.
    //
    if (m_ParentMachine) {

        m_ParentMachine->DetachChildMachine(this);
    }

    DeleteCriticalSection(&m_CriticalSection);
    DeleteCriticalSection(&m_PropertySheetCriticalSection);
    DeleteCriticalSection(&m_ChildMachineCriticalSection);
}

//
// This function destroys all the CClass and CDevice we ever created.
// No notification is sent for the attached folder
//
//
void
CMachine::DestroyClassesAndDevices()
{
    if (m_pComputer) {
        delete m_pComputer;
        m_pComputer = NULL;
    }

    if (!m_listDevice.IsEmpty()) {
        POSITION pos = m_listDevice.GetHeadPosition();

        while (NULL != pos) {
            CDevice* pDevice = m_listDevice.GetNext(pos);
            delete pDevice;
        }

        m_listDevice.RemoveAll();
    }

    if (!m_listClass.IsEmpty()) {
        POSITION pos = m_listClass.GetHeadPosition();

        while (NULL != pos) {
            CClass* pClass = m_listClass.GetNext(pos);
            delete pClass;
        }

        m_listClass.RemoveAll();
    }

    if (m_ImageListData.cbSize) {
        DiDestroyClassImageList(&m_ImageListData);
    }

    CDevInfoList::DiDestroyDeviceInfoList();

    m_hMachine = NULL;
}

BOOL
CMachine::BuildClassesFromGuidList(
                                  LPGUID  GuidList,
                                  DWORD   Guids
                                  )
{
    DWORD Index;
    CClass* pClass;

    //
    // Build a list of CClass for each GUID.
    //
    for (Index = 0; Index < Guids; Index++) {
        SafePtr<CClass> ClassPtr;

        pClass = new CClass(this, &GuidList[Index]);
        ClassPtr.Attach(pClass);
        m_listClass.AddTail(ClassPtr);
        ClassPtr.Detach();
    }

    return TRUE;
}

//
// Create CClass and CDevice for this machine.
// If DeviceId is valid, this function will create the machine
// with ONLY ONE device(and its CClass)
//
//  PERFBUG Optimize this function!!!!!!!
//      This function is slow because SetupDiGetClassDevs can take a long
//          time (over 1 sec of a 300Mhz machine).
//      The other slow part is the call to DoNotCreateDevice which needs to
//          go through the service manager for all legacy devnodes to see
//          if they are Win32 services (which we don't display). This takes
//          around 10ms to get this information from the service manager on
//          a 300Mhz machine and their are almost 100 of these legacy devices.
//          This means another second of time.
//
//
BOOL
CMachine::CreateClassesAndDevices(
                                 IN LPCTSTR DeviceId,           OPTIONAL
                                 IN LPGUID  ClassGuid           OPTIONAL
                                 )
{
    SC_HANDLE SCMHandle = NULL;

    //
    // Preventing memory leak
    //
    ASSERT(NULL == m_pComputer);
    ASSERT(INVALID_HANDLE_VALUE == m_hDevInfo);
    ASSERT(NULL == m_hMachine);

    //
    // If the object is being created for a single device,
    // create a empty device info list. We will add the
    // device to the info list later.
    //
    if (DeviceId || ClassGuid) {

        m_hDevInfo = DiCreateDeviceInfoList(ClassGuid, m_hwndParent);
    }

    else {

        //
        // We have to pull out the entire devices/classes set
        // so create a device info list that contains all of them.
        //
        m_hDevInfo = DiGetClassDevs(NULL, NULL, m_hwndParent, DIGCF_ALLCLASSES | DIGCF_PROFILE);
    }

    //
    // NULL != INVALID_HANDLE_VALUE. We checked both just be safe.
    //
    if (INVALID_HANDLE_VALUE == m_hDevInfo || NULL == m_hDevInfo) {

        return FALSE;
    }

    SP_DEVINFO_LIST_DETAIL_DATA DevInfoDetailData;
    DevInfoDetailData.cbSize = sizeof(DevInfoDetailData);

    //
    // Use the HMACHINE returned from Setupapi so that
    // every call we make to Cfgmgr32.dll will use the
    // same HMACHINE. Two call of CM_Connect_Machine will
    // return different hMachines even though they refer to
    // the same machine name(and thus, different set of DEVNODE!).
    // The catch is that we will be able to call Setuapi and cfgmgr32
    // API without worrying about which hMachine to use.
    //
    if (DiGetDeviceInfoListDetail(&DevInfoDetailData)) {
        m_hMachine = DevInfoDetailData.RemoteMachineHandle;
    } else {
        //
        // Unable to get the devinfo detail information.
        // In this case we will just default to the local machine.
        //
        m_hMachine = NULL;
    }

    //
    // Get class image list data;
    //
    m_ImageListData.cbSize = sizeof(m_ImageListData);
    if (DiGetClassImageList(&m_ImageListData)) {
        //
        // Add extra icons
        //
        HICON hIcon;

        if ((hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_DEVMGR))) != NULL) {
            m_ComputerIndex = ImageList_AddIcon(m_ImageListData.ImageList, hIcon);
            DestroyIcon(hIcon);
        }

        if ((hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_RESOURCES))) != NULL) {
            m_ResourceIndex = ImageList_AddIcon(m_ImageListData.ImageList, hIcon);
            DestroyIcon(hIcon);
        }
    }

    //
    // If the object is created for a particular device,
    // do not create the entire device list because it is
    // a waste of time.
    //
    if (DeviceId) {
        SP_DEVINFO_DATA DevData;
        GUID DeviceClassGuid;
        DevData.cbSize = sizeof(DevData);
        if (DiOpenDeviceInfo(DeviceId, m_hwndParent, 0, &DevData) &&
            CmGetClassGuid(DevData.DevInst, DeviceClassGuid)) {
            //
            // Create a CClass for the device(without CClass, no
            // device can not be created).
            //
            CClass* pClass;
            SafePtr<CClass> ClassPtr;
            pClass = new CClass(this, &DeviceClassGuid);

            if (pClass) {
                ClassPtr.Attach(pClass);
                m_listClass.AddTail(ClassPtr);

                //
                // The class object has been inserted to the list
                // it is safe now to detach the object from the smart pointer
                // The class object will be deleted by the list
                //
                ClassPtr.Detach();

                //
                // Create the device
                //
                SafePtr<CDevice> DevicePtr;
                CDevice* pDevice;
                pDevice = new CDevice(this, pClass, &DevData);

                if (pDevice) {
                    //
                    // Guard the object
                    //
                    DevicePtr.Attach(pDevice);
                    m_listDevice.AddTail(DevicePtr);

                    //
                    // Object added..
                    //
                    DevicePtr.Detach();

                    pClass->AddDevice(pDevice);
                }
            }
        }

        //
        // We should have one class and one device object. no more no less.
        // we are done here.
        //
        return(1 == m_listClass.GetCount() && 1 == m_listDevice.GetCount());
    }

    //
    // If the object is for a specific class then just create the class and add
    // it to the CMachine.
    //
    else if (ClassGuid) {

        CClass* pClass;
        SafePtr<CClass> ClassPtr;
        pClass = new CClass(this, ClassGuid);

        if (pClass) {
            ClassPtr.Attach(pClass);
            m_listClass.AddTail(ClassPtr);

            //
            // The class object has been inserted to the list
            // it is safe now to detach the object from the smart pointer
            // The class object will be deleted by the list
            //
            ClassPtr.Detach();
        }

        //
        // We should have one class. no more no less.
        // we are done here.
        //
        return(1 == m_listClass.GetCount());
    }

    //
    // Build class guid list
    //
    DWORD ClassGuids, GuidsRequired;
    GuidsRequired = 0;

    //
    // We make a guess here to save us some time.
    //
    GUID LocalGuid[GUID_LIST_INIT_SIZE];
    ClassGuids = GUID_LIST_INIT_SIZE;

    if (DiBuildClassInfoList(0, LocalGuid, ClassGuids, &GuidsRequired)) {
        BuildClassesFromGuidList(LocalGuid, GuidsRequired);
    } else if (ERROR_INSUFFICIENT_BUFFER == GetLastError() && GuidsRequired) {
        //
        // The stack based buffer is too small, allocate buffer from
        // the heap.
        //
        BufferPtr<GUID> ClassGuidList(GuidsRequired);

        if (DiBuildClassInfoList(0, ClassGuidList, GuidsRequired, &ClassGuids)) {
            BuildClassesFromGuidList(ClassGuidList, ClassGuids);
        }
    }

    //
    // If we have any classes at all, create devices objects
    //
    if (!m_listClass.IsEmpty()) {
        DWORD Index = 0;
        SP_DEVINFO_DATA DevData;

        //
        // We need a handle to the service manager in the DoNotCreateDevice
        // function.  We will open it once and pass it to this function rather
        // than opening and closing it for every device.
        //
        SCMHandle = OpenSCManager(NULL, NULL, GENERIC_READ);

        //
        // Create every device in the devinfo list and
        // associate each device to its class.
        //
        DevData.cbSize = sizeof(DevData);
        while (DiEnumDeviceInfo(Index, &DevData)) {
            POSITION pos = m_listClass.GetHeadPosition();
            CClass* pClass;

            //
            // Find the class for this device
            //
            while (NULL != pos) {
                pClass = m_listClass.GetNext(pos);

                //
                // Match the ClassGuid for this device.
                // Note that if the device does not have a class guid (GUID_NULL)
                // then we will put it in class GUID_DEVCLASS_UNKNOWN)
                //
                if ((IsEqualGUID(DevData.ClassGuid, *pClass)) ||
                    (IsEqualGUID(GUID_DEVCLASS_UNKNOWN, *pClass) &&
                     IsEqualGUID(DevData.ClassGuid, GUID_NULL))) {
                    //
                    // Is this one of the special DevInst that we should
                    // not create a CDevice for?
                    //
                    if (DoNotCreateDevice(SCMHandle, *pClass, DevData.DevInst)) {

                        break;
                    }

                    //
                    // Create the device
                    //
                    SafePtr<CDevice> DevicePtr;
                    CDevice* pDevice;
                    pDevice = new CDevice(this, pClass, &DevData);

                    //
                    // Guard the object
                    //
                    DevicePtr.Attach(pDevice);
                    m_listDevice.AddTail(DevicePtr);

                    //
                    // Object added.
                    //
                    DevicePtr.Detach();

                    //
                    // Put the device under the class
                    //
                    pClass->AddDevice(pDevice);

                    break;
                }

                //
                // No class than, no device
                //
            }

            //
            // next device
            //
            Index++;
        }

        CloseServiceHandle(SCMHandle);

        //
        // Create a device tree under computer
        // the tree order comes from DEVNODE structure;
        //
        DEVNODE dnRoot = CmGetRootDevNode();
        m_pComputer = new CComputer(this, dnRoot);
        DEVNODE dnStart = CmGetChild(dnRoot);
        CreateDeviceTree(m_pComputer, NULL, dnStart);
    }

    return TRUE;
}

//
// This function builds a device tree based on the Devnode tree retreived
// from configuration manager. Note that ALL CDevice are created before
// this function is called. This function establishs each CDevice relationship.
//
void
CMachine::CreateDeviceTree(
                          CDevice* pParent,
                          CDevice* pSibling,
                          DEVNODE dn
                          )
{
    CDevice* pDevice;
    DEVNODE dnChild, dnSibling;

    while (dn) {
        pDevice = DevNodeToDevice(dn);

        if (pDevice) {
            //
            // No sibling ->this is the first child
            //
            if (!pSibling) {
                pParent->SetChild(pDevice);
            }

            else {
                pSibling->SetSibling(pDevice);
            }

            pDevice->SetParent(pParent);
            pSibling = pDevice;
            dnChild = CmGetChild(dn);

            if (dnChild) {
                CreateDeviceTree(pDevice, NULL, dnChild);
            }
        }

        dn = CmGetSibling(dn);
    }
}

//
// Find CDevice from the given devnode
//
CDevice*
CMachine::DevNodeToDevice(
                         DEVNODE dn
                         )
{
    POSITION pos = m_listDevice.GetHeadPosition();

    while (NULL != pos) {
        CDevice* pDevice = m_listDevice.GetNext(pos);

        if (pDevice->GetDevNode() == dn) {

            return pDevice;
        }
    }

    return NULL;
}

//
// Find CDevice from the given device id
//
CDevice*
CMachine::DeviceIDToDevice(
                          LPCTSTR DeviceID
                          )
{
    if (!DeviceID) {
        return NULL;
    }

    POSITION pos = m_listDevice.GetHeadPosition();

    while (NULL != pos) {
        CDevice* pDevice = m_listDevice.GetNext(pos);

        if (*pDevice == DeviceID) {
            return pDevice;
        }
    }

    return NULL;
}

//
// Find CClass from the given GUID
//
CClass*
CMachine::ClassGuidToClass(
                          LPGUID ClassGuid
                          )
{
    if (!ClassGuid) {
        return NULL;
    }

    POSITION pos = m_listClass.GetHeadPosition();

    while (NULL != pos) {
        CClass* pClass = m_listClass.GetNext(pos);

        if (IsEqualGUID(*ClassGuid, *pClass)) {
            return pClass;
        }
    }

    return NULL;
}

BOOL
CMachine::LoadStringWithMachineName(
                                   int StringId,
                                   LPTSTR Buffer,
                                   DWORD*  BufferLen
                                   )
{
    if (!BufferLen || *BufferLen && !Buffer) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    TCHAR Format[LINE_LEN];
    TCHAR Temp[1024];

    LoadResourceString(StringId, Format, ARRAYLEN(Format));

    if (IsLocal()) {
        TCHAR LocalComputer[LINE_LEN];
        LoadResourceString(IDS_LOCAL_MACHINE, LocalComputer, ARRAYLEN(LocalComputer));
        wsprintf(Temp, Format, LocalComputer);
    }

    else {
        wsprintf(Temp, Format, (LPCTSTR)m_strMachineFullName);
    }

    DWORD Len = lstrlen(Temp);

    if (*BufferLen > Len) {
        lstrcpyn(Buffer, Temp, Len + 1);
        *BufferLen = Len;
        return TRUE;
    }

    else {
        SetLastError(ERROR_BUFFER_OVERFLOW);
        *BufferLen = Len;
        return FALSE;
    }
}

//
// This function reenumerates the devnode tree from the root, rebuilds the
// device tree and notifies every attached folder about the new device tree.
//
BOOL
CMachine::Reenumerate()
{
    BOOL Result = FALSE;

    if (m_pComputer) {
        //
        // Temporarily disable refresh while we are doing reenumeration
        // so that we will not keep refreshing the device tree.
        //
        EnableRefresh(FALSE);

        CDialog WaitDialog(IDD_SCAN_PNP_HARDWARES);

        WaitDialog.DoModaless(m_hwndParent, (LPARAM)&WaitDialog);

        if (!CmReenumerate(
            m_pComputer->GetDevNode(),
            CM_REENUMERATE_SYNCHRONOUS | CM_REENUMERATE_RETRY_INSTALLATION
            )) {

            //
            // Win2K doesn't support CM_REENUMERATE_RETRY_INSTALLATION, so we
            // retry without the reinstall flag.
            //
            CmReenumerate(m_pComputer->GetDevNode(), CM_REENUMERATE_SYNCHRONOUS);
        }

        DestroyWindow(WaitDialog);

        //
        // reenumeration is done, schedule a refresh and enable refresh now.
        //
        ScheduleRefresh();

        EnableRefresh(TRUE);

    }

    return TRUE;
}

//
// This function enable/disable refresh. A disble counter is kept to
// support multiple disabling/enabling. Only when the disable counter
// is zero, a refresh is possible.
// If a refresh is pending while we are enabling, we schedule a new
// request so that we will not lose any requests.
//
BOOL
CMachine::EnableRefresh(
                       BOOL fEnable
                       )
{
    BOOL Result = TRUE;
    Lock();

    if (fEnable) {
        if (m_RefreshDisableCounter < 0) {
            m_RefreshDisableCounter++;
        }
    }

    else {
        m_RefreshDisableCounter--;

    }

    //
    // If we are enabling refresh and there is one request pending,
    // schedule it again. This makes sure that we will not lose
    // any requests.
    // We schedule a new refresh request instead of calling Refresh
    // directly because we can be called by different threads while
    // we want the refresh to be done in the main thread. The data window
    // we created will receive the message and execute the refresh
    // in the main thread context.
    //
    if (fEnable && m_RefreshPending) {
        m_RefreshPending = FALSE;
        ScheduleRefresh();
    }

    Unlock();
    return Result;
}

//
//
// This function rebuilds the entire list of CClass and CDevice
// All attached CFolder are notified about the new machine.
//
// There are several occasions that we need to recreate the device tree:
// (1). On WM_DEVICECHANGE.
// (2). Device properties changed.
// (3). Device removal.
// (4). Device drivers updated and
// (5). Reenumeration requested by users.
// The requests may come from different threads and we must serialize
// the requests. A critical section and a new function(EnableRefresh) are added for
// for this purpose.
// Before doing anything on a device or class, one must call EnableRefesh(FALSE)
// to suspend Device change notification. When it is done with the change,
// one must call ScheduleRefesh function(if a refresh is necessary because of
// the changes) and then EnableRefresh(TRUE) to reenable the refresh.
//
BOOL
CMachine::Refresh()
{
    BOOL Result = TRUE;
    POSITION pos;
    Lock();

    if (0 == m_RefreshDisableCounter) {

        HCURSOR hCursorOld;
        hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

        //
        // Before we destroy all the classes and devices,
        // notify every attached folder so that they can dis-engaged
        // from us. After we created a new set of classes and devices,
        // the notification will be sent again to each folder
        // so that each folder can enagage to the machine again.
        //
        pos = m_listFolders.GetHeadPosition();

        while (NULL != pos) {
            ((CFolder*)m_listFolders.GetNext(pos))->MachinePropertyChanged(NULL);
        }

        //
        // we can destroy all the "old" classes and devices now.
        //

        DestroyClassesAndDevices();
        if (CreateClassesAndDevices()) {
            //
            // Notify every attach folder to recreate
            //
            if (!m_listFolders.IsEmpty()) {
                pos = m_listFolders.GetHeadPosition();

                while (NULL != pos) {
                    CFolder* pFolder = m_listFolders.GetNext(pos);
                    Result = SUCCEEDED(pFolder->MachinePropertyChanged(this));
                }
            }

            //
            // Notify every property page to refresh
            //
            if (!m_listChildMachines.IsEmpty()) {

                EnterCriticalSection(&m_ChildMachineCriticalSection);

                POSITION nextpos = m_listChildMachines.GetHeadPosition();

                while (nextpos) {
                    pos = nextpos;

                    CMachine* pMachineToNotify = m_listChildMachines.GetNext(nextpos);

                    pMachineToNotify->DoMiniRefresh();
                }

                LeaveCriticalSection(&m_ChildMachineCriticalSection);
            }
        }

        if (hCursorOld) {
            SetCursor(hCursorOld);
        }

        m_RefreshPending = FALSE;
    }

    else {
        //
        // We need to refresh while the refresh is disabled
        // Remember this so that when refresh is enabled, we
        // can launch a refresh.
        //
        m_RefreshPending = TRUE;
    }

    Unlock();

    return Result;
}

//
// A mini refresh is performed when the CMachine only has a single CClass or
// CDevice.  This is because this will be the property sheet case.  In this
// case we will see if the class or device represented by this property sheet
// still exists.  If it doesn't then we will destroy the property sheet.
//
BOOL
CMachine::DoMiniRefresh()
{
    BOOL Result = TRUE;

    Lock();

    //
    // If the machine has one CDevice then we need to see if this device is
    // still around.
    //
    if (1 == m_listDevice.GetCount()) {

        DEVNODE dn;
        PVOID Context;
        CDevice* pDevice;

        if (GetFirstDevice(&pDevice, Context)) {
/*
            //
            // We need to verify two things here.  First is that we can locate
            // this device instance id, at least as a phantom.  The second is
            // we need to make sure that the devnode is the same as that of the
            // property sheet.  If we can't locate this device instance id, or
            // the devnode is different then we need to destroy the property
            // sheet.  The device instance id will go away if the user uninstalls
            // this device.  The devnode will be different if this device goes
            // from a live devnode to a phantom or vice versa.
            //
            if ((CM_Locate_DevNode_Ex(&dn,
                                     (DEVNODEID)pDevice->GetDeviceID(),
                                     CM_LOCATE_DEVNODE_PHANTOM,
                                     m_hMachine
                                     ) != CR_SUCCESS) ||
                 (dn != pDevice->GetDevNode())) {

                //
                // Either this device instance id has been uninstalled or the devnode
                // has been changed, this means we need to destroy the property sheet.
                //
                Result = FALSE;

            } else {
*/
                //
                // If the devnode did not go away we should tell it to refresh itself
                // in case something changed.
                //
                ::PostMessage(pDevice->m_psd.GetWindowHandle(), PSM_QUERYSIBLINGS, QSC_PROPERTY_CHANGED, 0L);
//            }
        }
    }

    //
    // Note that currently we don't do anything in the class property sheet case.
    // The reason for this is that classes can't really go away unless someone deletes
    // them from the registry, which probably wills mess up lots of other things. Also
    // all current class property sheets don't do anything anyway and so even if someone
    // does delete the class key nothing bad will happen to the property sheet.
    //

    Unlock();

    return Result;
}

BOOL
CMachine::GetFirstDevice(
                        CDevice** ppDevice,
                        PVOID&    Context
                        )
{
    ASSERT(ppDevice);

    if (!m_listDevice.IsEmpty()) {
        POSITION pos = m_listDevice.GetHeadPosition();
        *ppDevice = m_listDevice.GetNext(pos);
        Context = pos;
        return TRUE;
    }

    *ppDevice = NULL;
    Context = NULL;
    return FALSE;
}

BOOL
CMachine::GetNextDevice(
                       CDevice** ppDevice,
                       PVOID& Context
                       )
{
    ASSERT(ppDevice);
    POSITION pos = (POSITION)Context;

    if (NULL != pos) {
        *ppDevice = m_listDevice.GetNext(pos);
        Context = pos;
        return TRUE;
    }

    *ppDevice = NULL;
    return FALSE;
}

BOOL
CMachine::GetFirstClass(
                       CClass** ppClass,
                       PVOID& Context
                       )
{
    ASSERT(ppClass);

    if (!m_listClass.IsEmpty()) {
        POSITION pos = m_listClass.GetHeadPosition();
        *ppClass = m_listClass.GetNext(pos);
        Context = pos;

        return TRUE;
    }

    *ppClass = NULL;
    Context = NULL;
    return FALSE;
}

BOOL
CMachine::GetNextClass(
                      CClass** ppClass,
                      PVOID&   Context
                      )
{
    ASSERT(ppClass);
    POSITION pos = (POSITION)Context;

    if (NULL != pos) {
        *ppClass = m_listClass.GetNext(pos);
        Context = pos;
        return TRUE;
    }

    *ppClass = NULL;
    return FALSE;
}

BOOL
CMachine::pGetOriginalInfName(
                             LPTSTR InfName,
                             String& OriginalInfName
                             )
{
    SP_ORIGINAL_FILE_INFO InfOriginalFileInformation;
    PSP_INF_INFORMATION pInfInformation;
    DWORD InfInformationSize;
    BOOL bRet;

    ZeroMemory(&InfOriginalFileInformation, sizeof(InfOriginalFileInformation));

    InfInformationSize = 8192;  // I'd rather have this too big and succeed first time, than read the INF twice
    pInfInformation = (PSP_INF_INFORMATION)LocalAlloc(LPTR, InfInformationSize);

    if (pInfInformation != NULL) {

        bRet = SetupGetInfInformation(InfName,
                                      INFINFO_INF_NAME_IS_ABSOLUTE,
                                      pInfInformation,
                                      InfInformationSize,
                                      &InfInformationSize
                                     );

        DWORD Error = GetLastError();

        //
        // If buffer was too small then make the buffer larger and try again.
        //
        if (!bRet && GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

            PVOID newbuff = LocalReAlloc(pInfInformation, InfInformationSize, LPTR);

            if (!newbuff) {

                LocalFree(pInfInformation);
                pInfInformation = NULL;

            } else {

                pInfInformation = (PSP_INF_INFORMATION)newbuff;
                bRet = SetupGetInfInformation(InfName,
                                              INFINFO_INF_NAME_IS_ABSOLUTE,
                                              pInfInformation,
                                              InfInformationSize,
                                              &InfInformationSize
                                             );
            }
        }

        if (bRet) {

            InfOriginalFileInformation.cbSize = sizeof(InfOriginalFileInformation);

            if (SetupQueryInfOriginalFileInformation(pInfInformation, 0, NULL, &InfOriginalFileInformation)) {

                if (InfOriginalFileInformation.OriginalInfName[0]!=0) {

                    //
                    // we have a "real" inf name
                    //
                    OriginalInfName = InfOriginalFileInformation.OriginalInfName;
                }
            }
        }

        //
        // Assume that this INF has not been renamed
        //
        else {

            OriginalInfName = MyGetFileTitle(InfName);
        }

        if (pInfInformation != NULL) {

            LocalFree(pInfInformation);
            pInfInformation = NULL;
        }
    }

    return TRUE;
}

BOOL
CMachine::GetDigitalSigner(
                          LPTSTR FullInfPath,
                          String& DigitalSigner
                          )
{
    SP_INF_SIGNER_INFO InfSignerInfo;
    BOOL bRet = FALSE;

    if (m_UserIsAGuest || !IsLocal()) {
        //
        // If the user is loged in as a guest, or we are not on the local
        // machine, then make the digital signer string be 'Not available'
        //
        DigitalSigner.LoadString(g_hInstance, IDS_NOT_AVAILABLE);
    } else {
        InfSignerInfo.cbSize = sizeof(InfSignerInfo);
    
        bRet = SetupVerifyInfFile(FullInfPath,
                                  NULL,
                                  &InfSignerInfo
                                  );
    
        if (bRet && (InfSignerInfo.DigitalSigner[0] != TEXT('\0'))) {
            DigitalSigner = (LPTSTR)InfSignerInfo.DigitalSigner;
        }
    }

    return bRet;
}

BOOL
CMachine::DoNotCreateDevice(
                           SC_HANDLE SCMHandle,
                           LPGUID ClassGuid,
                           DEVINST DevInst
                           )
/*++

    This function returns whether a CDevice should be created for this DevInst
    or not. If a CDevice is not created for DevInst then it will never show up
    in the device manager UI, even when "Show hidden devices" is turned on.

    We don't create a CDevice in the following cases:

        - DevInst is HTREE\ROOT\0
        - DevInst is a Win32 Service.

--*/
{
    SC_HANDLE ServiceHandle;
    TCHAR ServiceName[MAX_PATH];
    LPQUERY_SERVICE_CONFIG ServiceConfig = NULL;
    DWORD ServiceConfigSize;
    ULONG Size;
    String strDeviceID;
    BOOL Return = FALSE;

    //
    // If the DEVMGR_SHOW_NONPRESENT_DEVICES environment variable is not set then
    // we do not want to show any Phantom devices.
    //
    if (!m_ShowNonPresentDevices) {

        ULONG Status, Problem;

        if ((!CmGetStatus(DevInst, &Status, &Problem)) &&
            ((m_LastCR == CR_NO_SUCH_VALUE) ||
             (m_LastCR == CR_NO_SUCH_DEVINST))) {

            return TRUE;
        }
    }

    //
    // Check to see if this device is a Win32 service. Only
    // legacy devices could be Win32 services.
    //
    if (IsEqualGUID(*ClassGuid, GUID_DEVCLASS_LEGACYDRIVER)) {

        Size = sizeof(ServiceName);
        if (CmGetRegistryProperty(DevInst,
                                  CM_DRP_SERVICE,
                                  (PVOID)ServiceName,
                                  &Size
                                 ) == CR_SUCCESS) {

            //
            // Open this particular service
            //
            if ((ServiceHandle = OpenService(SCMHandle, ServiceName, GENERIC_READ)) != NULL) {

                //
                // Get the service config
                //
                if ((!QueryServiceConfig(ServiceHandle, NULL, 0, &ServiceConfigSize)) &&
                    (ERROR_INSUFFICIENT_BUFFER == GetLastError())) {

                    if ((ServiceConfig = (LPQUERY_SERVICE_CONFIG)malloc(ServiceConfigSize)) != NULL) {

                        if (QueryServiceConfig(ServiceHandle, ServiceConfig, ServiceConfigSize, &ServiceConfigSize)) {


                            if (ServiceConfig->dwServiceType & (SERVICE_WIN32 | SERVICE_FILE_SYSTEM_DRIVER)) {

                                Return = TRUE;
                            }

                        }

                        free(ServiceConfig);
                    }
                }

                CloseServiceHandle(ServiceHandle);
            }
        }
    }

    //
    // Check to see if this is the HTREE\ROOT\0 device. We don't
    // want to create a CDevice for this phantom devnode.
    //
    // This is an else statement because the HTREE\ROOT\0 device is
    // not in the legacy device class.
    //
    else {

        CmGetDeviceIDString(DevInst, strDeviceID);
        if (!lstrcmpi((LPTSTR)strDeviceID, TEXT("HTREE\\ROOT\\0"))) {

            Return = TRUE;
        }
    }

    return Return;
}

BOOL
CMachine::DiGetClassFriendlyNameString(
                                      LPGUID Guid,
                                      String& strClass
                                      )
{
    TCHAR DisplayName[LINE_LEN + 1];

    //
    // Try friendly name first. If it failed, try the class name
    //
    if (SetupDiGetClassDescriptionEx(Guid, DisplayName, ARRAYLEN(DisplayName),
                                     NULL, GetRemoteMachineFullName(), NULL) ||
        SetupDiClassNameFromGuidEx(Guid, DisplayName, ARRAYLEN(DisplayName),
                                   NULL, GetRemoteMachineFullName(), NULL)) {
        strClass = DisplayName;
        return TRUE;
    }

    return FALSE;
}

DEVNODE
CMachine::CmGetParent(
                     DEVNODE dn
                     )
{
    DEVNODE dnParent;

    m_LastCR = CM_Get_Parent_Ex(&dnParent, dn, 0, m_hMachine);

    if (CR_SUCCESS == m_LastCR) {
        return dnParent;
    }

    return NULL;
}

DEVNODE
CMachine::CmGetChild(
                    DEVNODE dn
                    )
{
    DEVNODE dnChild;
    m_LastCR = CM_Get_Child_Ex(&dnChild, dn, 0, m_hMachine);

    if (CR_SUCCESS ==  m_LastCR) {
        return dnChild;
    }

    return NULL;
}

DEVNODE
CMachine::CmGetSibling(
                      DEVNODE dn
                      )
{
    DEVNODE dnSibling;

    m_LastCR = CM_Get_Sibling_Ex(&dnSibling, dn, 0, m_hMachine);

    if (CR_SUCCESS == m_LastCR) {
        return dnSibling;
    }

    return NULL;
}

DEVNODE
CMachine::CmGetRootDevNode()
{
    DEVNODE dnRoot;

    m_LastCR =  CM_Locate_DevNode_Ex(&dnRoot, NULL, 0, m_hMachine);

    if (CR_SUCCESS == m_LastCR) {
        return dnRoot;
    }

    return NULL;
}

BOOL
CMachine::CmGetDeviceIDString(
                             DEVNODE dn,
                             String& str
                             )
{
    TCHAR DeviceID[MAX_DEVICE_ID_LEN + 1];

    m_LastCR = CM_Get_Device_ID_Ex(dn, DeviceID, ARRAYLEN(DeviceID), 0, m_hMachine);

    if (CR_SUCCESS == m_LastCR) {
        str = DeviceID;
        return TRUE;
    }

    return FALSE;
}

BOOL
CMachine::CmGetConfigFlags(
                          DEVNODE dn,
                          DWORD* pFlags
                          )
{
    DWORD Size;

    Size = sizeof(DWORD);
    m_LastCR = CmGetRegistryProperty(dn, CM_DRP_CONFIGFLAGS, pFlags, &Size);

    return CR_SUCCESS == m_LastCR;
}

BOOL
CMachine::CmGetCapabilities(
                           DEVNODE dn,
                           DWORD* pCapabilities
                           )
{
    DWORD Size;

    Size = sizeof(DWORD);
    m_LastCR = CmGetRegistryProperty(dn, CM_DRP_CAPABILITIES, pCapabilities, &Size);

    return CR_SUCCESS == m_LastCR;
}

BOOL
CMachine::CmGetDescriptionString(
                                DEVNODE dn,
                                String& str
                                )
{
    TCHAR Description[LINE_LEN + 1];
    ULONG Size = sizeof(Description);

    Description[0] = TEXT('\0');

    m_LastCR = CmGetRegistryProperty(dn, CM_DRP_FRIENDLYNAME, Description, &Size);

    if ((CR_NO_SUCH_VALUE == m_LastCR) || (Description[0] == TEXT('\0'))) {

        Size = sizeof(Description);
        m_LastCR = CmGetRegistryProperty(dn, CM_DRP_DEVICEDESC, Description,
                                         &Size);
    }

    if ((CR_SUCCESS == m_LastCR) && (Description[0] != TEXT('\0'))) {

        str = Description;
        return TRUE;
    }

    return FALSE;
}

BOOL
CMachine::CmGetMFGString(
                        DEVNODE dn,
                        String& str
                        )
{
    TCHAR MFG[LINE_LEN + 1];
    ULONG Size = sizeof(MFG);

    m_LastCR = CmGetRegistryProperty(dn, CM_DRP_MFG, MFG, &Size);

    if (CR_SUCCESS == m_LastCR) {
        str = MFG;
        return TRUE;
    }

    return FALSE;
}

BOOL
CMachine::CmGetProviderString(
                             DEVNODE dn,
                             String& str
                             )
{
    TCHAR Provider[LINE_LEN + 1];
    ULONG Size = sizeof(Provider);

    m_LastCR = CmGetRegistrySoftwareProperty(dn, TEXT("ProviderName"),
                                             Provider, &Size);

    if (CR_SUCCESS == m_LastCR) {
        str = Provider;
        return TRUE;
    }

    return FALSE;
}

BOOL
CMachine::CmGetDriverDateString(
                               DEVNODE dn,
                               String& str
                               )
{
    TCHAR DriverDate[LINE_LEN + 1];
    ULONG Size = sizeof(DriverDate);

    m_LastCR = CmGetRegistrySoftwareProperty(dn, TEXT("DriverDate"),
                                             DriverDate, &Size);

    if (CR_SUCCESS == m_LastCR) {
        str = DriverDate;
        return TRUE;
    }

    return FALSE;
}

BOOL
CMachine::CmGetDriverDateData(
                             DEVNODE dn,
                             FILETIME *ft
                             )
{
    ULONG Size = sizeof(*ft);

    m_LastCR = CmGetRegistrySoftwareProperty(dn, TEXT("DriverDateData"),
                                             ft, &Size);

    return(m_LastCR == CR_SUCCESS);
}

BOOL
CMachine::CmGetDriverVersionString(
                                  DEVNODE dn,
                                  String& str
                                  )
{
    TCHAR DriverVersion[LINE_LEN + 1];
    ULONG Size = sizeof(DriverVersion);

    m_LastCR = CmGetRegistrySoftwareProperty(dn, TEXT("DriverVersion"),
                                             DriverVersion, &Size);

    if (CR_SUCCESS == m_LastCR) {
        str = DriverVersion;
        return TRUE;
    }

    return FALSE;
}

BOOL
CMachine::CmGetBusGuid(
                      DEVNODE dn,
                      LPGUID Guid
                      )
{

    ULONG Size = sizeof(*Guid);

    m_LastCR = CmGetRegistryProperty(dn, CM_DRP_BUSTYPEGUID, (LPVOID)Guid, &Size);

    if (CR_SUCCESS == m_LastCR) {

        return TRUE;
    }

    return FALSE;
}

BOOL
CMachine::CmGetBusGuidString(
                            DEVNODE dn,
                            String& str
                            )
{
    GUID BusGuid;
    TCHAR BusGuidString[MAX_GUID_STRING_LEN];
    ULONG Size;

    while (dn) {
        //
        // We have to set the size on each loop
        //
        Size  = sizeof(BusGuid);
        m_LastCR = CmGetRegistryProperty(dn, CM_DRP_BUSTYPEGUID, &BusGuid, &Size);

        if (CR_SUCCESS == m_LastCR && GuidToString(&BusGuid, BusGuidString,
                                                   ARRAYLEN(BusGuidString))) {

            str = BusGuidString;
            return TRUE;
        }

        dn = CmGetParent(dn);
    }

    return FALSE;
}

BOOL
CMachine::CmGetClassGuid(
                        DEVNODE dn,
                        GUID& Guid
                        )
{
    TCHAR szGuidString[MAX_GUID_STRING_LEN + 1];
    ULONG Size = sizeof(szGuidString);

    m_LastCR = CmGetRegistryProperty(dn, CM_DRP_CLASSGUID, szGuidString, &Size);

    if (CR_SUCCESS == m_LastCR && GuidFromString(szGuidString, &Guid)) {
        return TRUE;
    }

    //
    // If we can't get the class GUID from the registry then most likely the device
    // does not have a class GUID.  If this is the case then we will return
    // GUID_DEVCLASS_UNKNOWN
    //
    else {
        memcpy(&Guid, &GUID_DEVCLASS_UNKNOWN, sizeof(GUID));
        return TRUE;
    }
}

BOOL
CMachine::CmGetHardwareIDs(
                          DEVNODE dn,
                          PVOID Buffer,
                          ULONG* BufferLen
                          )
{
    m_LastCR = CmGetRegistryProperty(dn, CM_DRP_HARDWAREID, Buffer, BufferLen);
    return CR_SUCCESS == m_LastCR;
}

BOOL
CMachine::CmGetCompatibleIDs(
                            DEVNODE dn,
                            PVOID Buffer,
                            ULONG* BufferLen
                            )
{
    m_LastCR = CmGetRegistryProperty(dn, CM_DRP_COMPATIBLEIDS, Buffer, BufferLen);
    return CR_SUCCESS == m_LastCR;
}

LPTSTR
FormatString(
            LPCTSTR format,
            ...
            )
{
    LPTSTR str = NULL;
    va_list arglist;
    va_start(arglist, format);

    if (FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                      format,
                      0,
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                      (LPTSTR)&str,
                      0,
                      &arglist
                     ) == 0) {
        str = NULL;
    }

    va_end(arglist);

    return str;
}

STDAPI_(CONFIGRET) GetLocationInformation(
                                         DEVNODE dn,
                                         LPTSTR Location,
                                         ULONG LocationLen,
                                         HMACHINE hMachine
                                         )
/*++

    Slot x (LocationInformation)
    Slot x
    LocationInformation
    on parent bus

--*/
{
    CONFIGRET LastCR;
    DEVNODE dnParent;
    ULONG ulSize;
    DWORD UINumber;
    TCHAR Buffer[MAX_PATH];
    TCHAR UINumberDescFormat[MAX_PATH];
    TCHAR Format[MAX_PATH];

    Buffer[0] = TEXT('\0');

    //
    // We will first get any LocationInformation for the device.  This will either
    // be in the LocationInformationOverride value in the devices driver (software) key
    // or if that is not present we will look for the LocationInformation value in
    // the devices device (hardware) key.
    //
    HKEY hKey;
    DWORD Type = REG_SZ;
    ulSize = sizeof(Buffer);
    if (CR_SUCCESS == CM_Open_DevNode_Key_Ex(dn,
                                             KEY_READ,
                                             0,
                                             RegDisposition_OpenExisting,
                                             &hKey,
                                             CM_REGISTRY_SOFTWARE,
                                             hMachine
                                            )) {

        RegQueryValueEx(hKey,
                        REGSTR_VAL_LOCATION_INFORMATION_OVERRIDE,
                        NULL,
                        &Type,
                        (const PBYTE)Buffer,
                        &ulSize
                       );

        RegCloseKey(hKey);
    }

    //
    // If the buffer is empty then we didn't get the LocationInformationOverride
    // value in the device's software key.  So, we will see if their is a
    // LocationInformation value in the device's hardware key.
    //
    if (Buffer[0] == TEXT('\0')) {

        ulSize = sizeof(Buffer);
        CM_Get_DevNode_Registry_Property_Ex(dn,
                                            CM_DRP_LOCATION_INFORMATION,
                                            NULL,
                                            Buffer,
                                            &ulSize,
                                            0,
                                            hMachine
                                           );
    }

    //
    // UINumber has precedence over all other location information so check if this
    // device has a UINumber.
    //
    ulSize = sizeof(UINumber);
    if (((LastCR = CM_Get_DevNode_Registry_Property_Ex(dn,
                                                       CM_DRP_UI_NUMBER,
                                                       NULL,
                                                       &UINumber,
                                                       &ulSize,
                                                       0,
                                                       hMachine
                                                      )) == CR_SUCCESS) &&
        (ulSize > 0)) {


        UINumberDescFormat[0] = TEXT('\0');
        ulSize = sizeof(UINumberDescFormat);

        //
        // Get the UINumber description format string from the device's parent,
        // if there is one, otherwise default to 'Location %1'
        if ((CM_Get_Parent_Ex(&dnParent, dn, 0, hMachine) == CR_SUCCESS) &&
            (CM_Get_DevNode_Registry_Property_Ex(dnParent,
                                                 CM_DRP_UI_NUMBER_DESC_FORMAT,
                                                 NULL,
                                                 UINumberDescFormat,
                                                 &ulSize,
                                                 0,
                                                 hMachine) == CR_SUCCESS) &&
            *UINumberDescFormat) {

        } else {
            ::LoadString(g_hInstance, IDS_UI_NUMBER_DESC_FORMAT, UINumberDescFormat, sizeof(UINumberDescFormat)/sizeof(TCHAR));
        }

        LPTSTR UINumberBuffer = NULL;

        //
        // Fill in the UINumber string
        //
        UINumberBuffer = FormatString(UINumberDescFormat, UINumber);

        if (UINumberBuffer) {
            lstrcpy((LPTSTR)Location, UINumberBuffer);
            LocalFree(UINumberBuffer);
        } else {
            Location[0] = TEXT('\0');
        }

        //
        // If we also have LocationInformation then tack that on the end of the string
        // as well.
        //
        if (*Buffer) {
            lstrcat((LPTSTR)Location, TEXT(" ("));
            lstrcat((LPTSTR)Location, Buffer);
            lstrcat((LPTSTR)Location, TEXT(")"));
        }
    }

    //
    // We don't have a UINumber but we do have LocationInformation
    //
    else if (*Buffer) {
        ::LoadString(g_hInstance, IDS_LOCATION, Format, sizeof(Format)/sizeof(TCHAR));
        wsprintf((LPTSTR)Location, Format, Buffer);
    }

    //
    // We don't have a UINumber or LocationInformation so we need to get a description
    // of the parent of this device.
    //
    else {
        if ((LastCR = CM_Get_Parent_Ex(&dnParent, dn, 0, hMachine)) == CR_SUCCESS) {

            //
            // Try the registry for FRIENDLYNAME
            //
            Buffer[0] = TEXT('\0');
            ulSize = sizeof(Buffer);
            if (((LastCR = CM_Get_DevNode_Registry_Property_Ex(dnParent,
                                                               CM_DRP_FRIENDLYNAME,
                                                               NULL,
                                                               Buffer,
                                                               &ulSize,
                                                               0,
                                                               hMachine
                                                              )) != CR_SUCCESS) ||
                !*Buffer) {

                //
                // Try the registry for DEVICEDESC
                //
                ulSize = sizeof(Buffer);
                if (((LastCR = CM_Get_DevNode_Registry_Property_Ex(dnParent,
                                                                   CM_DRP_DEVICEDESC,
                                                                   NULL,
                                                                   Buffer,
                                                                   &ulSize,
                                                                   0,
                                                                   hMachine
                                                                  )) != CR_SUCCESS) ||
                    !*Buffer) {

                    ulSize = sizeof(Buffer);
                    if (((LastCR = CM_Get_DevNode_Registry_Property_Ex(dnParent,
                                                                       CM_DRP_CLASS,
                                                                       NULL,
                                                                       Buffer,
                                                                       &ulSize,
                                                                       0,
                                                                       hMachine
                                                                      )) != CR_SUCCESS) ||
                        !*Buffer) {

                        //
                        // no parent, or parent name.
                        //
                        Buffer[0] = TEXT('\0');
                    }
                }
            }
        }

        if (*Buffer) {
            //
            // We have a description of the parent
            //
            ::LoadString(g_hInstance, IDS_LOCATION_NOUINUMBER, Format, sizeof(Format)/sizeof(TCHAR));
            wsprintf((LPTSTR)Location, Format, Buffer);
        } else {
            //
            // We don't have any information so we will just say Unknown
            //
            ::LoadString(g_hInstance, IDS_UNKNOWN, Location, LocationLen);
        }
    }

    return CR_SUCCESS;
}

BOOL
CMachine::CmGetStatus(
                     DEVNODE dn,
                     DWORD* pProblem,
                     DWORD* pStatus
                     )
{
    ASSERT(pProblem && pStatus);
    m_LastCR = CM_Get_DevNode_Status_Ex(pStatus, pProblem, dn, 0, m_hMachine);
    return(CR_SUCCESS == m_LastCR);
}

BOOL
CMachine::CmGetKnownLogConf(
                           DEVNODE dn,
                           LOG_CONF* plc,
                           DWORD*    plcType
                           )
{
    ASSERT(plc);

    *plc  = 0;

    if (plcType) {
        *plcType = LOG_CONF_BITS + 1;
    }

    ULONG lcTypeFirst = ALLOC_LOG_CONF;
    ULONG lcTypeLast = FORCED_LOG_CONF;
    ASSERT(ALLOC_LOG_CONF + 1 == BOOT_LOG_CONF &&
           BOOT_LOG_CONF + 1 == FORCED_LOG_CONF);

    for (ULONG lcType = lcTypeFirst; lcType <= lcTypeLast; lcType++) {
        m_LastCR = CM_Get_First_Log_Conf_Ex(plc, dn, lcType, m_hMachine);

        if (CR_SUCCESS == m_LastCR) {
            if (plcType) {
                *plcType = lcType;
            }

            break;
        }
    }

    return CR_SUCCESS == m_LastCR;
}

BOOL
CMachine::CmHasResources(
                        DEVNODE dn
                        )
{
    for (ULONG lcType = 0; lcType < NUM_LOG_CONF; lcType++) {
        m_LastCR = CM_Get_First_Log_Conf_Ex(NULL, dn, lcType, m_hMachine);

        if (CR_SUCCESS == m_LastCR) {
            break;
        }
    }

    return CR_SUCCESS == m_LastCR;
}

BOOL
CMachine::CmReenumerate(
                       DEVNODE dn,
                       ULONG Flags
                       )
{
    m_LastCR = CM_Reenumerate_DevNode_Ex(dn, Flags, m_hMachine);
    return CR_SUCCESS == m_LastCR;
}

BOOL
CMachine::CmGetHwProfileFlags(
                             DEVNODE dn,
                             ULONG Profile,
                             ULONG* pFlags
                             )
{
    TCHAR DeviceID[MAX_DEVICE_ID_LEN + 1];

    m_LastCR = CM_Get_Device_ID_Ex(dn, DeviceID, ARRAYLEN(DeviceID),
                                   0, m_hMachine);

    if (CR_SUCCESS == m_LastCR) {
        return CmGetHwProfileFlags(DeviceID, Profile, pFlags);
    }

    return FALSE;
}

BOOL
CMachine::CmGetHwProfileFlags(
                             LPCTSTR DeviceID,
                             ULONG Profile,
                             ULONG* pFlags
                             )
{
    m_LastCR = CM_Get_HW_Prof_Flags_Ex((LPTSTR)DeviceID, Profile, pFlags, 0,
                                       m_hMachine);
    return CR_SUCCESS == m_LastCR;
}

BOOL
CMachine::CmSetHwProfileFlags(
                             DEVNODE dn,
                             ULONG Profile,
                             ULONG Flags
                             )
{
    TCHAR DeviceID[MAX_DEVICE_ID_LEN + 1];

    m_LastCR = CM_Get_Device_ID_Ex(dn, DeviceID, ARRAYLEN(DeviceID),
                                   0, m_hMachine);

    if (CR_SUCCESS == m_LastCR) {
        return CmSetHwProfileFlags(DeviceID, Profile, Flags);
    }

    return FALSE;
}

BOOL
CMachine::CmSetHwProfileFlags(
                             LPCTSTR DeviceID,
                             ULONG Profile,
                             ULONG Flags
                             )
{
    m_LastCR = CM_Set_HW_Prof_Flags_Ex((LPTSTR)DeviceID, Profile, Flags, 0,
                                       m_hMachine);
    return CR_SUCCESS == m_LastCR;
}

BOOL
CMachine::CmHasDrivers(
                      DEVNODE dn
                      )
{
    ULONG Size = 0;

    m_LastCR = CmGetRegistryProperty(dn, CM_DRP_DRIVER, NULL, &Size);

    if (CR_BUFFER_SMALL != m_LastCR) {
        Size = 0;
        m_LastCR = CmGetRegistryProperty(dn, CM_DRP_SERVICE, NULL, &Size);
    }

    return(CR_BUFFER_SMALL == m_LastCR);
}

BOOL
CMachine::CmGetCurrentHwProfile(
                               ULONG* phwpf
                               )
{
    HWPROFILEINFO hwpfInfo;
    ASSERT(phwpf);

    if (CmGetHwProfileInfo(0xFFFFFFFF, &hwpfInfo)) {
        *phwpf = hwpfInfo.HWPI_ulHWProfile;
        return TRUE;
    }

    return FALSE;
}

BOOL
CMachine::CmGetHwProfileInfo(
                            int Index,
                            PHWPROFILEINFO pHwProfileInfo
                            )
{
    m_LastCR = CM_Get_Hardware_Profile_Info_Ex(Index, pHwProfileInfo, 0, m_hMachine);

    return(CR_SUCCESS == m_LastCR);
}

ULONG
CMachine::CmGetResDesDataSize(
                             RES_DES rd
                             )
{
    ULONG Size;

    m_LastCR = CM_Get_Res_Des_Data_Size_Ex(&Size, rd, 0, m_hMachine);

    if (CR_SUCCESS == m_LastCR) {
        return Size;
    }

    return 0;
}

BOOL
CMachine::CmGetResDesData(
                         RES_DES rd,
                         PVOID Buffer,
                         ULONG BufferSize
                         )
{
    m_LastCR = CM_Get_Res_Des_Data_Ex(rd, Buffer, BufferSize, 0, m_hMachine);

    return CR_SUCCESS == m_LastCR;
}

BOOL
CMachine::CmGetNextResDes(
                         PRES_DES  prdNext,
                         RES_DES   rd,
                         RESOURCEID ForResource,
                         PRESOURCEID pTheResource
                         )
{
    m_LastCR = CM_Get_Next_Res_Des_Ex(prdNext, rd, ForResource, pTheResource,
                                      0, m_hMachine);
    return(CR_SUCCESS == m_LastCR);
}

void
CMachine::CmFreeResDesHandle(
                            RES_DES rd
                            )
{
    m_LastCR = CM_Free_Res_Des_Handle(rd);
}

void
CMachine::CmFreeResDes(
                      PRES_DES prdPrev,
                      RES_DES  rd
                      )
{
    m_LastCR = CM_Free_Res_Des_Ex(prdPrev, rd, 0, m_hMachine);
}

void
CMachine::CmFreeLogConfHandle(
                             LOG_CONF lc
                             )
{
    m_LastCR = CM_Free_Log_Conf_Handle(lc);
}

int
CMachine::CmGetNumberOfBasicLogConf(
                                   DEVNODE dn
                                   )
{
    LOG_CONF lcFirst;
    int      nLC = 0;

    if (CmGetFirstLogConf(dn, &lcFirst, BASIC_LOG_CONF)) {
        LOG_CONF lcNext;
        BOOL NoMore = FALSE;

        do {
            NoMore = !CmGetNextLogConf(&lcNext, lcFirst, BASIC_LOG_CONF);
            CmFreeLogConfHandle(lcFirst);
            lcFirst = lcNext;
            nLC++;

        } while (NoMore);
    }

    return nLC;
}

BOOL
CMachine::CmGetFirstLogConf(
                           DEVNODE dn,
                           LOG_CONF* plc,
                           ULONG Type
                           )
{
    m_LastCR = CM_Get_First_Log_Conf_Ex(plc, dn, Type, m_hMachine);

    return CR_SUCCESS == m_LastCR;
}

BOOL
CMachine::CmGetNextLogConf(
                          LOG_CONF* plcNext,
                          LOG_CONF lcRef,
                          ULONG Type
                          )
{
    m_LastCR = CM_Get_Next_Log_Conf_Ex(plcNext, lcRef, Type, m_hMachine);

    return CR_SUCCESS == m_LastCR;
}

ULONG
CMachine::CmGetArbitratorFreeDataSize(
                                     DEVNODE dn,
                                     RESOURCEID ResType
                                     )
{
    ULONG Size;
    m_LastCR = CM_Query_Arbitrator_Free_Size_Ex(&Size, dn, ResType,
                                                0, m_hMachine);
    if (CR_SUCCESS == m_LastCR) {
        return Size;
    }

    return 0;
}

BOOL
CMachine::CmGetArbitratorFreeData(
                                 DEVNODE dn,
                                 PVOID pBuffer,
                                 ULONG BufferSize,
                                 RESOURCEID ResType
                                 )
{
    m_LastCR = CM_Query_Arbitrator_Free_Data_Ex(pBuffer, BufferSize, dn,
                                                ResType, 0, m_hMachine
                                               );

    return CR_SUCCESS == m_LastCR;
}

BOOL
CMachine::CmTestRangeAvailable(
                              RANGE_LIST RangeList,
                              DWORDLONG dlBase,
                              DWORDLONG dlEnd
                              )
{
    m_LastCR = CM_Test_Range_Available(dlBase, dlEnd, RangeList, 0);

    return(CR_SUCCESS == m_LastCR);
}

void
CMachine::CmDeleteRange(
                       RANGE_LIST RangeList,
                       DWORDLONG dlBase,
                       DWORDLONG dlLen
                       )
{
    DWORDLONG dlEnd = dlBase + dlLen - 1;

    m_LastCR  = CM_Delete_Range(dlBase, dlEnd, RangeList, 0);
}

BOOL
CMachine::CmGetFirstRange(
                         RANGE_LIST RangeList,
                         DWORDLONG* pdlBase,
                         DWORDLONG* pdlLen,
                         RANGE_ELEMENT* pre
                         )
{
    m_LastCR = CM_First_Range(RangeList, pdlBase, pdlLen, pre, 0);

    if (CR_SUCCESS == m_LastCR) {
        *pdlLen = *pdlLen - *pdlBase + 1;
        return TRUE;
    }

    return FALSE;
}

BOOL
CMachine::CmGetNextRange(
                        RANGE_ELEMENT* pre,
                        DWORDLONG* pdlBase,
                        DWORDLONG* pdlLen
                        )
{
    m_LastCR = CM_Next_Range(pre, pdlBase, pdlLen, 0);

    if (CR_SUCCESS == m_LastCR) {
        *pdlLen = *pdlLen - *pdlBase + 1;
        return TRUE;
    }

    return FALSE;
}

void
CMachine::CmFreeRangeList(
                         RANGE_LIST RangeList
                         )
{
    m_LastCR = CM_Free_Range_List(RangeList, 0);
}

CONFIGRET
CMachine::CmGetRegistryProperty(
                               DEVNODE dn,
                               ULONG Property,
                               PVOID pBuffer,
                               ULONG* pBufferSize
                               )
{
    return CM_Get_DevNode_Registry_Property_Ex(dn, Property, NULL,
                                               pBuffer, pBufferSize,
                                               0, m_hMachine
                                              );
}

CONFIGRET
CMachine::CmGetRegistrySoftwareProperty(
                                       DEVNODE dn,
                                       LPCTSTR ValueName,
                                       PVOID pBuffer,
                                       ULONG* pBufferSize
                                       )
{
    HKEY hKey;
    DWORD Type = REG_SZ;
    CONFIGRET CR;

    if (CR_SUCCESS == (CR = CM_Open_DevNode_Key_Ex(dn, KEY_READ, 0, RegDisposition_OpenExisting,
                                                   &hKey, CM_REGISTRY_SOFTWARE, m_hMachine))) {

        if (ERROR_SUCCESS != RegQueryValueEx(hKey, ValueName, NULL, &Type, (const PBYTE)pBuffer,
                                             pBufferSize)) {

            CR = CR_REGISTRY_ERROR;
        }

        RegCloseKey(hKey);
    }

    return CR;
}

BOOL
CMachine::CmGetDeviceIdListSize(
                               LPCTSTR Filter,
                               ULONG*  Size,
                               ULONG   Flags
                               )
{
    m_LastCR = CM_Get_Device_ID_List_Size_Ex(Size, Filter, Flags, m_hMachine);

    return CR_SUCCESS == m_LastCR;
}

BOOL
CMachine::CmGetDeviceIdList(
                           LPCTSTR Filter,
                           TCHAR*  Buffer,
                           ULONG   BufferSize,
                           ULONG   Flags
                           )
{
    m_LastCR = CM_Get_Device_ID_List_Ex(Filter, Buffer, BufferSize, Flags, m_hMachine);

    return CR_SUCCESS == m_LastCR;
}

CMachineList::~CMachineList()
{
    if (!m_listMachines.IsEmpty()) {
        POSITION pos = m_listMachines.GetHeadPosition();
        CMachine* pMachine;

        while (NULL != pos) {
            pMachine = m_listMachines.GetNext(pos);
            delete pMachine;
        }

        m_listMachines.RemoveAll();
    }
}

//
// This function creates a machine object on the given machine name
// INPUT:
//      hwndParent -- Window Handle to be used as the owner window
//                    of all possible windows this function may create
//      MachineName -- the machine name. Must be in full qualified format
//                     NULL means the local machine
//      ppMachine  -- buffer to receive the newly create machine.
//
// OUTPUT:
//      TRUE  if the machine is created successfully. ppMachine
//            is filled with the newly created Machine.
//      FALSE if the function failed.
// NOTE:
//      The caller should NOT free any machine object retruned
//      from this function.
//
BOOL
CMachineList::CreateMachine(
                           HWND hwndParent,
                           LPCTSTR MachineName,
                           CMachine** ppMachine
                           )
{
    ASSERT(ppMachine);
    *ppMachine =  NULL;

    CMachine* pMachine = NULL;

    if (!MachineName || _T('\0') == MachineName[0]) {
        //
        // Local machine.
        //
        String strMachineName;
        strMachineName.GetComputerName();
        pMachine = FindMachine(strMachineName);
    }

    else {
        pMachine = FindMachine(MachineName);
    }

    if (NULL == pMachine) {
        pMachine = new CMachine(MachineName);
        m_listMachines.AddTail(pMachine);
    }

    *ppMachine = pMachine;

    return NULL != pMachine;
}

CMachine*
CMachineList::FindMachine(
                         LPCTSTR MachineName
                         )
{
    if (!m_listMachines.IsEmpty()) {
        POSITION pos = m_listMachines.GetHeadPosition();

        while (NULL != pos) {
            CMachine* pMachine;
            pMachine = m_listMachines.GetNext(pos);

            if (!lstrcmpi(MachineName, pMachine->GetMachineFullName())) {
                return pMachine;
            }
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\globals.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    globals.cpp

Abstract:

    This module implements global functions needed for the program.
    It also contain global variables/classes.

Author:

    William Hsieh (williamh) created

Revision History:


--*/


#include "devmgr.h"
#include <winioctl.h>
#include <shlobj.h>
#define NO_SHELL_TREE_TYPE
#include <shlobjp.h>


//
//  global classes and variables
//

// this, of course, our dll's instance handle.
HINSTANCE g_hInstance = NULL;

//
// A CMachineList is created for each instance of DLL. It is shared
// by all the CComponentData the instance might create. The class CMachine
// contains all the information about all the classes and devices on the
// machine. Each CComponent should register itself to CMachine. This way,
// A CComponent will get notification whenever there are changes in
// the CMachine(Refresh, Property changes on a device, for example).
// We do not rely on MMC's view notification(UpdatAllView) because
// it only reaches all the CComponents created by a CComponenetData.
//
//
CMachineList    g_MachineList;
CMemoryException g_MemoryException(TRUE);
String      g_strStartupMachineName;
String      g_strStartupDeviceId;
String      g_strStartupCommand;
String      g_strDevMgr;
BOOL        g_HasLoadDriverNamePrivilege = FALSE;
CPrintDialog    g_PrintDlg;


//
// UUID consts
//

const CLSID CLSID_DEVMGR = {0x74246BFC,0x4C96,0x11D0,{0xAB,0xEF,0x00,0x20,0xAF,0x6B,0x0B,0x7A}};
const CLSID CLSID_DEVMGR_EXTENSION = {0x90087284,0xd6d6,0x11d0,{0x83,0x53,0x00,0xa0,0xc9,0x06,0x40,0xbf}};
const CLSID CLSID_SYSTOOLS = {0x476e6448,0xaaff,0x11d0,{0xb9,0x44,0x00,0xc0,0x4f,0xd8,0xd5,0xb0}};
const CLSID CLSID_DEVMGR_ABOUT = {0x94abaf2a,0x892a,0x11d1,{0xbb,0xc4,0x00,0xa0,0xc9,0x06,0x40,0xbf}};

const TCHAR* const CLSID_STRING_DEVMGR = TEXT("{74246bfc-4c96-11d0-abef-0020af6b0b7a}");
const TCHAR* const CLSID_STRING_DEVMGR_EXTENSION = TEXT("{90087284-d6d6-11d0-8353-00a0c90640bf}");
const TCHAR* const CLSID_STRING_SYSTOOLS = TEXT("{476e6448-aaff-11d0-b944-00c04fd8d5b0}");
const TCHAR* const CLSID_STRING_DEVMGR_ABOUT = TEXT("{94abaf2a-892a-11d1-bbc4-00a0c90640bf}");
//
// ProgID
//

const TCHAR* const PROGID_DEVMGR = TEXT("DevMgrSnapin.DevMgrSnapin.1");
const TCHAR* const PROGID_DEVMGREXT = TEXT("DevMgrExtension.DevMgrExtension.1");
const TCHAR* const PROGID_DEVMGR_ABOUT = TEXT("DevMgrAbout.DevMgrAbout.1");

const TCHAR* const ENV_NAME_SYSTEMDRIVE = TEXT("SystemDrive");

//
// Node types const
//
const NODEINFO NodeInfo[TOTAL_COOKIE_TYPES] =
{

    { COOKIE_TYPE_SCOPEITEM_DEVMGR,
      IDS_NAME_DEVMGR,
      IDS_DISPLAYNAME_SCOPE_DEVMGR,
      {0xc41dfb2a,0x4d5b,0x11d0,{0xab,0xef,0x00,0x20,0xaf,0x6b,0x0b,0x7a}},
      TEXT("{c41dfb2a-4d5b-11d0-abef-0020af6b0b7a}")
    },
    { COOKIE_TYPE_RESULTITEM_RESOURCE_IRQ,
      IDS_NAME_IRQ,
      0,
      {0x494535fe,0x5aa2,0x11d0,{0xab,0xf0,0x00,0x20,0xaf,0x6b,0x0b,0x7a}},
      TEXT("{494535fe-5aa2-11d0-abf0-0020af6b0b7a}")
    },
    { COOKIE_TYPE_RESULTITEM_RESOURCE_DMA,
      IDS_NAME_DMA,
      0,
      {0x49f0df4e,0x5aa2,0x11d0,{0xab,0xf0,0x00,0x20,0xaf,0x6b,0x0b,0x7a}},
      TEXT("{49f0df4e-5aa2-11d0-abf0-0020af6b0b7a}")
    },
    { COOKIE_TYPE_RESULTITEM_RESOURCE_IO,
      IDS_NAME_IO,
      0,
      {0xa2958d7a,0x5aa2,0x11d0,{0xab,0xf0,0x00,0x20,0xaf,0x6b,0x0b,0x7a}},
      TEXT("{a2958d7a-5aa2-11d0-abf0-0020af6b0b7a}")
    },
    { COOKIE_TYPE_RESULTITEM_RESOURCE_MEMORY,
      IDS_NAME_MEMORY,
      0,
      {0xa2958d7b,0x5aa2,0x11d0,{0xab,0xf0,0x00,0x20,0xaf,0x6b,0x0b,0x7a}},
      TEXT("{a2958d7b-5aa2-11d0-abf0-0020af6b0b7a}")
    },
    { COOKIE_TYPE_RESULTITEM_COMPUTER,
      IDS_NAME_COMPUTER,
      0,
      {0xa2958d7c,0x5aa2,0x11d0,{0xab,0xf0,0x00,0x20,0xaf,0x6b,0x0b,0x7a}},
      TEXT("{a2958d7c-5aa2-11d0-abf0-0020af6b0b7a}")
    },
    { COOKIE_TYPE_RESULTITEM_DEVICE,
      IDS_NAME_DEVICE,
      0,
      {0xa2958d7d,0x5aa2,0x11d0,{0xab,0xf0,0x00,0x20,0xaf,0x6b,0x0b,0x7a}},
      TEXT("{a2958d7d-5aa2-11d0-abf0-0020af6b0b7a}")
    },
    { COOKIE_TYPE_RESULTITEM_CLASS,
      IDS_NAME_CLASS,
      0,
      {0xe677e204,0x5aa2,0x11d0,{0xab,0xf0,0x00,0x20,0xaf,0x6b,0x0b,0x7a}},
      TEXT("{e677e204-5aa2-11d0-abf0-0020af6b0b7a}")
    },
    { COOKIE_TYPE_RESULTITEM_RESTYPE,
      IDS_NAME_RESOURCES,
      0,
      {0xa2958d7e,0x5aa2,0x11d0,{0xab,0xf0,0x00,0x20,0xaf,0x6b,0x0b,0x7a}},
      TEXT("{a2958d7e-5aa2-11d0-abf0-0020af6b0b7a}")
    }
};

const IID IID_IDMTVOCX =    \
    {0x142525f2,0x59d8,0x11d0,{0xab,0xf0,0x00,0x20,0xaf,0x6b,0x0b,0x7a}};
const IID IID_ISnapinCallback = \
    {0x8e0ba98a,0xd161,0x11d0,{0x83,0x53,0x00,0xa0,0xc9,0x06,0x40,0xbf}};

//
// cliboard format strings
//
const TCHAR* const MMC_SNAPIN_MACHINE_NAME = TEXT("MMC_SNAPIN_MACHINE_NAME");
const TCHAR* const SNAPIN_INTERNAL = TEXT("SNAPIN_INTERNAL");
const TCHAR* const DEVMGR_SNAPIN_CLASS_GUID = TEXT("DEVMGR_SNAPIN_CLASS_GUID");
const TCHAR* const DEVMGR_SNAPIN_DEVICE_ID  = TEXT("DEVMGR_SNAPIN_DEVICE_ID");
const TCHAR* const DEVMGR_COMMAND_PROPERTY = TEXT("Property");
const TCHAR* const REG_PATH_DEVICE_MANAGER = TEXT("SOFTWARE\\Microsoft\\DeviceManager");
const TCHAR* const REG_STR_BUS_TYPES    = TEXT("BusTypes");
const TCHAR* const REG_STR_TROUBLESHOOTERS = TEXT("TroubleShooters");
const TCHAR* const DEVMGR_HELP_FILE_NAME = TEXT("devmgr.hlp");
const TCHAR* const DEVMGR_HTML_HELP_FILE_NAME = TEXT("\\help\\devmgr.chm");

// lookup table to translate problem number to its text resource id.
const PROBLEMINFO  g_ProblemInfo[] =
{
    {IDS_PROB_NOPROBLEM, 0},                                    // NO PROBLEM
    {IDS_PROB_NOT_CONFIGURED, PIF_CODE_EMBEDDED},               // CM_PROB_NOT_CONFIGURED
    {IDS_PROB_DEVLOADERFAILED, PIF_CODE_EMBEDDED},              // CM_PROB_DEVLOADER_FAILED
    {IDS_PROB_OUT_OF_MEMORY, PIF_CODE_EMBEDDED},                // CM_PROB_OUT_OF_MEMORY
    {IDS_PROB_WRONG_TYPE, PIF_CODE_EMBEDDED},                   // CM_PROB_ENTRY_IS_WRONG_TYPE
    {IDS_PROB_LACKEDARBITRATOR, PIF_CODE_EMBEDDED},             // CM_PROB_LACKED_ARBITRATOR
    {IDS_PROB_BOOT_CONFIG_CONFLICT, PIF_CODE_EMBEDDED},         // CM_PROB_BOOT_CONFIG_CONFLICT
    {IDS_PROB_FAILED_FILTER, PIF_CODE_EMBEDDED},                // CM_PROB_FAILED_FILTER
    {IDS_PROB_DEVLOADER_NOT_FOUND, PIF_CODE_EMBEDDED},          // CM_PROB_DEVLOADER_NOT_FOUND
    {IDS_PROB_INVALID_DATA, PIF_CODE_EMBEDDED},                 // CM_PROB_INVALID_DATA
    {IDS_PROB_FAILED_START, PIF_CODE_EMBEDDED},                 // CM_PROB_FAILED_START
    {IDS_PROB_LIAR, PIF_CODE_EMBEDDED},                         // CM_PROB_LIAR
    {IDS_PROB_NORMAL_CONFLICT, PIF_CODE_EMBEDDED},              // CM_PROB_NORMAL_CONFLICT
    {IDS_PROB_NOT_VERIFIED, PIF_CODE_EMBEDDED},                 // CM_PROB_NOT_VERIFIED
    {IDS_PROB_NEEDRESTART, PIF_CODE_EMBEDDED},                  // CM_PROB_NEED_RESTART
    {IDS_PROB_REENUMERATION, PIF_CODE_EMBEDDED},                // CM_PROB_REENUMERATION
    {IDS_PROB_PARTIALCONFIG, PIF_CODE_EMBEDDED},                // CM_PROB_PARTIAL_LOG_CONF
    {IDS_PROB_UNKNOWN_RESOURCE, PIF_CODE_EMBEDDED},             // CM_PROB_UNKNOWN_RESOURCE
    {IDS_PROB_REINSTALL, PIF_CODE_EMBEDDED},                    // CM_PROB_REINSTALL
    {IDS_PROB_REGISTRY, PIF_CODE_EMBEDDED},                     // CM_PROB_REGISTRY
    {IDS_PROB_SYSTEMFAILURE, PIF_CODE_EMBEDDED},                // CM_PROB_VXDLDR
    {IDS_PROB_WILL_BE_REMOVED, PIF_CODE_EMBEDDED},              // CM_PROB_WILL_BE_REMOVED
    {IDS_PROB_DISABLED, PIF_CODE_EMBEDDED},                     // CM_PROB_DISABLED
    {IDS_PROB_SYSTEMFAILURE, PIF_CODE_EMBEDDED},                // CM_PROB_DEVLOADER_NOT_READY
    {IDS_DEVICE_NOT_THERE, PIF_CODE_EMBEDDED},                  // CM_PROB_DEVICE_NOT_THERE
    {IDS_PROB_MOVED, PIF_CODE_EMBEDDED},                        // CM_PROB_MOVED
    {IDS_PROB_TOO_EARLY, PIF_CODE_EMBEDDED},                    // CM_PROB_TOO_EARLY
    {IDS_PROB_NO_VALID_LOG_CONF, PIF_CODE_EMBEDDED},            // CM_PROB_NO_VALID_LOG_CONF
    {IDS_PROB_FAILEDINSTALL, PIF_CODE_EMBEDDED},                // CM_PROB_FAILED_INSTALL
    {IDS_PROB_HARDWAREDISABLED, PIF_CODE_EMBEDDED},             // CM_PROB_HARDWARE_DISABLED
    {IDS_PROB_CANT_SHARE_IRQ, PIF_CODE_EMBEDDED},               // CM_PROB_CANT_SHARE_IRQ
    {IDS_PROB_FAILED_ADD, PIF_CODE_EMBEDDED},                   // CM_PROB_FAILED_ADD
    {IDS_PROB_DISABLED_SERVICE, PIF_CODE_EMBEDDED},             // CM_PROB_DISABLED_SERVICE
    {IDS_PROB_TRANSLATION_FAILED, PIF_CODE_EMBEDDED},           // CM_PROB_TRANSLATION_FAILED
    {IDS_PROB_NO_SOFTCONFIG, PIF_CODE_EMBEDDED},                // CM_PROB_NO_SOFTCONFIG
    {IDS_PROB_BIOS_TABLE, PIF_CODE_EMBEDDED},                   // CM_PROB_BIOS_TABLE
    {IDS_PROB_IRQ_TRANSLATION_FAILED, PIF_CODE_EMBEDDED},       // CM_PROB_IRQ_TRANSLATION_FAILED
    {IDS_PROB_FAILED_DRIVER_ENTRY, PIF_CODE_EMBEDDED},          // CM_PROB_FAILED_DRIVER_ENTRY
    {IDS_PROB_DRIVER_FAILED_PRIOR_UNLOAD, PIF_CODE_EMBEDDED},   // CM_PROB_DRIVER_FAILED_PRIOR_UNLOAD
    {IDS_PROB_DRIVER_FAILED_LOAD, PIF_CODE_EMBEDDED},           // CM_PROB_DRIVER_FAILED_LOAD
    {IDS_PROB_DRIVER_SERVICE_KEY_INVALID, PIF_CODE_EMBEDDED},   // CM_PROB_DRIVER_SERVICE_KEY_INVALID
    {IDS_PROB_LEGACY_SERVICE_NO_DEVICES, PIF_CODE_EMBEDDED},    // CM_PROB_LEGACY_SERVICE_NO_DEVICES
    {IDS_PROB_DUPLICATE_DEVICE, PIF_CODE_EMBEDDED},             // CM_PROB_DUPLICATE_DEVICE
    {IDS_PROB_FAILED_POST_START, PIF_CODE_EMBEDDED},            // CM_PROB_FAILED_POST_START
    {IDS_PROB_HALTED, PIF_CODE_EMBEDDED},                       // CM_PROB_HALTED
    {IDS_PROB_PHANTOM, PIF_CODE_EMBEDDED},                      // CM_PROB_PHANTOM
    {IDS_PROB_SYSTEM_SHUTDOWN, PIF_CODE_EMBEDDED},              // CM_PROB_SYSTEM_SHUTDOWN
    {IDS_PROB_HELD_FOR_EJECT, PIF_CODE_EMBEDDED},               // CM_PROB_HELD_FOR_EJECT
    {IDS_PROB_DRIVER_BLOCKED, PIF_CODE_EMBEDDED},               // CM_PROB_DRIVER_BLOCKED
    {IDS_PROB_REGISTRY_TOO_LARGE, PIF_CODE_EMBEDDED},           // CM_PROB_REGISTRY_TOO_LARGE
    {IDS_PROB_UNKNOWN_WITHCODE, PIF_CODE_EMBEDDED}              // UNKNOWN PROBLEM
};


//
// Global functions
//

#if DBG
//
// Debugging aids
//
void
Trace(
    LPCTSTR format,
    ...
    )
{
    // according to wsprintf specification, the max buffer size is
    // 1024
    TCHAR Buffer[1024];
    va_list arglist;
    va_start(arglist, format);
    wvsprintf(Buffer, format, arglist);
    va_end(arglist);
    OutputDebugString(TEXT("DEVMGR: "));
    OutputDebugString(Buffer);
    OutputDebugString(TEXT("\r\n"));
}
#endif


inline
BOOL
IsBlankChar(TCHAR ch)
{
    return (_T(' ') == ch || _T('\t') == ch);
}

inline
LPTSTR
SkipBlankChars(
    LPTSTR psz
    )
{
    while (IsBlankChar(*psz))
    psz++;
    return psz;
}

// We import the following two "private" apis to avoid linking with rpcrt4.dll
// which contains UuidFromString and StringToUuid functions.
extern "C" {
extern DWORD pSetupGuidFromString(LPCTSTR GuidString, LPGUID pGuid);
extern DWORD pSetupStringFromGuid(const GUID* pGuid, LPTSTR Buffer, DWORD BufferLen);
}

//
// This function converts a given string to GUID
// INPUT:
//  GuidString   -- the null terminated guid string
//  LPGUID       -- buffer to receive the GUID
// OUTPUT:
//     TRUE if the conversion succeeded.
//     FALSE if failed.
//
inline
BOOL
GuidFromString(
    LPCTSTR GuidString,
    LPGUID  pGuid
    )
{
    return ERROR_SUCCESS == pSetupGuidFromString(GuidString, pGuid);
}

// This function converts the given GUID to a string
// INPUT:
//  pGuid    -- the guid
//  Buffer   -- the buffer to receive the string
//  BufferLen -- the buffer size in char unit
// OUTPUT:
//  TRUE  if the conversion succeeded.
//  FLASE if failed.
//
//
inline
BOOL
GuidToString(
    LPGUID pGuid,
    LPTSTR Buffer,
    DWORD  BufferLen
    )
{
    return ERROR_SUCCESS == pSetupStringFromGuid(pGuid, Buffer, BufferLen);
}

//
// This function allocates an OLE string from OLE task memory pool
// It does necessary char set conversion before copying the string.
//
// INPUT: LPCTSTR str  -- the initial string
// OUTPUT:  LPOLESTR   -- the result OLE string. NULL if the function fails.
//
LPOLESTR
AllocOleTaskString(
    LPCTSTR str
    )
{
    if (!str)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    // if _UNICODE is defined, OLECHAR == WCHAR
    // if OLE2ANSI is defined, OLECHAR == CHAR

#if defined(UNICODE) || defined(OLE2ANSI)
    size_t Len = lstrlen(str);
    
    // allocate the null terminate char also.
    LPOLESTR olestr = (LPOLESTR)::CoTaskMemAlloc((Len + 1) * sizeof(TCHAR));
    
    if (olestr)
    {
        lstrcpy((LPTSTR)olestr, str);
        return olestr;
    }
    
    return NULL;
#else
    // OLE is in UNICODE while TCHAR is CHAR
    // We need to convert ANSI(TCHAR) to WCHAR
    size_t Len = strlen(str);
    
    LPOLESTR olestr = (LPOLESTR)::CoTaskMemAlloc((Len + 1) * sizeof(WCHAR));
    
    if (olestr)
    {
        MultiByteToWideChar(CP_ACP, 0, str, -1, (LPWSTR)olestr, Len + 1);
        return olestr;
    }

    return NULL;
#endif
}

inline
void
FreeOleTaskString(
    LPOLESTR olestr
    )
{
    if (olestr)
    {
        ::CoTaskMemFree(olestr);
    }
}
//
// This function addes the given menu item to snapin
// INPUT:
//  iNameStringId    -- menu item text resource id
//  iStatusBarStringId -- status bar text resource id.
//  iCommandId     -- command id to be assigned to the menu item
//  InsertionPointId   -- Insertion point id
//  Flags          -- flags
//  SpecialFlags       -- special flags
// OUTPUT:
//  HRESULT
//
HRESULT
AddMenuItem(
    LPCONTEXTMENUCALLBACK pCallback,
    int   iNameStringId,
    int   iStatusBarStringId,
    long  lCommandId,
    long  InsertionPointId,
    long  Flags,
    long  SpecialFlags
    )
{
    ASSERT(pCallback);

    CONTEXTMENUITEM tCMI;
    memset(&tCMI, 0, sizeof(tCMI));
    tCMI.lCommandID = lCommandId;
    tCMI.lInsertionPointID = InsertionPointId;
    tCMI.fFlags = Flags;
    tCMI.fSpecialFlags = SpecialFlags;
    TCHAR Name[MAX_PATH];
    TCHAR Status[MAX_PATH];
    ::LoadString(g_hInstance, iNameStringId, Name, ARRAYLEN(Name));
    tCMI.strName = Name;
    
    if (iStatusBarStringId) {
       ::LoadString(g_hInstance, iStatusBarStringId, Status, ARRAYLEN(Status));
       tCMI.strStatusBarText = Status;
    }
    
    return pCallback->AddItem(&tCMI);
}

//
// This function verifies the given machine name can be accessed remotely.
// INPUT:
//  MachineName -- the machine name. The machine name must be
//             led by "\\\\".
// OUTPUT:
//  BOOL TRUE for success and FALSE for failure.  Check GetLastError() for failure
//  reason.
//
BOOL
VerifyMachineName(
    LPCTSTR MachineName
    )
{
    CONFIGRET cr = CR_SUCCESS;
    HMACHINE hMachine = NULL;
    HKEY hRemoteKey = NULL;
    HKEY hClass = NULL;

    if (MachineName)
    {
        int len = lstrlen(MachineName);

        //
        // empty means local machine.
        //
        if (!len)
        {
            return TRUE;
        }
        
        if (len > 2 &&  _T('\\') == MachineName[0] && _T('\\') == MachineName[1])
        {
            //
            // make sure we can connect the machine using cfgmgr32.
            //
            cr = CM_Connect_Machine(MachineName, &hMachine);

            //
            // We could not connect to the machine using cfgmgr32
            //
            if (CR_SUCCESS != cr)
            {
                goto clean0;
            }

            //
            // make sure we can connect to the registry of the remote machine
            //
            if (RegConnectRegistry(MachineName, HKEY_LOCAL_MACHINE,
                                           &hRemoteKey) != ERROR_SUCCESS) {

                cr = CR_REGISTRY_ERROR;
                goto clean0;
            }

            cr = CM_Open_Class_Key_Ex(NULL,
                                      NULL,
                                      KEY_READ,
                                      RegDisposition_OpenExisting,
                                      &hClass,
                                      CM_OPEN_CLASS_KEY_INSTALLER,
                                      hMachine
                                      );
        }
    }
    
clean0:

    if (hMachine) {
        
        CM_Disconnect_Machine(hMachine);
    }

    if (hRemoteKey) {

        RegCloseKey(hRemoteKey);
    }

    if (hClass) {

        RegCloseKey(hClass);
    }

    //
    // We will basically set two different error codes for this API, since we need
    // to present this information to the user.
    // 1) SPAPI_E_MACHINE_UNABAILABLE
    // 2) ERROR_ACCESS_DENIED.
    //
    if (CR_SUCCESS == cr) {

        SetLastError(NO_ERROR);
    
    } else if (CR_MACHINE_UNAVAILABLE == cr) {

        SetLastError(SPAPI_E_MACHINE_UNAVAILABLE);
    
    } else {

        SetLastError(ERROR_ACCESS_DENIED);
    }
    
    return (CR_SUCCESS == cr);
}

// This function loads the string designated by the given
// string id(resource id) from the module's resource to the provided
// buffer. It returns the required buffer size(in chars) to hold the string,
// not including the terminated NULL chars. Last error will be set
// appropaitely.
//
// input: int StringId  -- the resource id of the string to be loaded.
//    LPTSTR Buffer -- provided buffer to receive the string
//    UINT   BufferSize -- the size of Buffer in chars
// output:
//    UINT the required buffer size to receive the string
//    if it returns 0, GetLastError() returns the error code.
//
UINT
LoadResourceString(
    int StringId,
    LPTSTR Buffer,
    UINT   BufferSize
    )
{
    // do some trivial tests.
    if (BufferSize && !Buffer)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    // if caller provides buffer, try to load the string with the given buffer
    // and length.
    UINT FinalLen;

    if (Buffer)
    {
        FinalLen = ::LoadString(g_hInstance, StringId, Buffer, BufferSize);
        if (BufferSize > FinalLen)
        {
            return FinalLen;
        }
    }

    // Either the caller does not provide the buffer or the given buffer
    // is too small. Try to figure out the requried size.
    //

    // first use a stack-based buffer to get the string. If the buffer
    // is big enough, we are happy.
    TCHAR Temp[256];
    UINT ArrayLen = ARRAYLEN(Temp);
    FinalLen = ::LoadString(g_hInstance, StringId, Temp, ArrayLen);

    DWORD LastError = ERROR_SUCCESS;

    if (ArrayLen <= FinalLen)
    {   
        // the stack-based buffer is too small, use heap-based buffer.
        // we have not got all the chars. we increase the buffer size of 256
        // chars each time it fails. The initial size is 512(256+256)
        // the max size is 32K
        ArrayLen = 256;
        TCHAR* HeapBuffer;
        FinalLen = 0;
        
        while (ArrayLen < 0x8000)
        {
            ArrayLen += 256;
            HeapBuffer = new TCHAR[ArrayLen];
            if (HeapBuffer)
            {
                FinalLen = ::LoadString(g_hInstance, StringId, HeapBuffer, ArrayLen);
                delete [] HeapBuffer;
                
                if (FinalLen < ArrayLen)
                    break;
            }
            
            else
            {
                LastError = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }

        if (ERROR_SUCCESS != LastError)
        {
            SetLastError(LastError);
            FinalLen = 0;
        }
    }

    return FinalLen;
}

// This function get the problem text designated by the given problem number
// for the given devnode on the given machine.
//
//
// input: HMACHINE hMachine -- machine handle(NULL for local machine)
//    DEVNODE  DevNode  -- the device
//    ULONG ProblemNumber -- the problem number
//    LPTSTR Buffer -- provided buffer to receive the string
//    UINT   BufferSize -- the size of Buffer in chars
// output:
//    UINT the required buffer size to receive the string
//    if it returns 0, GetLastError() returns the error code.
//
UINT
GetDeviceProblemText(
    HMACHINE hMachine,
    DEVNODE DevNode,
    ULONG ProblemNumber,
    LPTSTR Buffer,
    UINT   BufferSize
    )
{
    //
    // first does a trivial test
    //
    if (!Buffer && BufferSize)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    int StringId;
    TCHAR*  pMainText;
    UINT RequiredSize;
    UINT Length;
    pMainText = NULL;
    RequiredSize = 0;

    PROBLEMINFO pi;
    
    // get the PROBLEMINFO for the problem number
    pi = g_ProblemInfo[min(ProblemNumber, DEVMGR_NUM_CM_PROB-1)];
    
    // figure out the main text length
    Length = LoadResourceString(pi.StringId, Buffer, BufferSize);
    
    if (Length)
    {
        try
        {
            BufferPtr<TCHAR> MainTextPtr(Length + 1);
            LoadResourceString(pi.StringId, MainTextPtr, Length + 1);
            if (pi.Flags & PIF_CODE_EMBEDDED)
            {
                // embedded problem code in the main text.
                Length = LoadResourceString(IDS_PROB_CODE, NULL, 0);
                
                if (Length)
                {
                    BufferPtr<TCHAR> FormatPtr(Length + 1);
                    LoadResourceString(IDS_PROB_CODE, FormatPtr, Length + 1);
                    BufferPtr<TCHAR> CodeTextPtr(Length + 1 + 32);
                    wsprintf(CodeTextPtr, FormatPtr, ProblemNumber);
                    pMainText = new TCHAR[lstrlen(MainTextPtr) + lstrlen(CodeTextPtr) + 32];
                    wsprintf(pMainText, MainTextPtr, CodeTextPtr);
                }
            }
            
            else
            {
                pMainText = new TCHAR[Length + 1];
                lstrcpy(pMainText, MainTextPtr);
            }

            RequiredSize += lstrlen(pMainText);
            
            // copy the main text
            if (RequiredSize && BufferSize > RequiredSize)
            {
                lstrcpy(Buffer, pMainText);
            }
        }

        catch (CMemoryException* e)
        {
            e->Delete();
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            RequiredSize = 0;
        }
    }
    
    if (pMainText)
    {
        delete [] pMainText;
    }

    return RequiredSize;
}

//
// This function creates and shows a message box
// INPUT:
//  hwndParent -- the window handle servers as the parent window to the
//        message box
//  MsgId      -- string id for message box body. The string can be
//        a format string.
//  CaptionId  -- string id for caption. if 0, default is device manager
//  Type       -- the standard message box flags(MB_xxxx)
//  ...        -- parameters to MsgId string if it contains any
//        format chars.
//OUTPUT:
//  return value from MessageBox(IDOK, IDYES...)

int MsgBoxParam(
    HWND hwndParent,
    int MsgId,
    int CaptionId,
    DWORD Type,
    ...
    )
{
    TCHAR szMsg[MAX_PATH * 4], szCaption[MAX_PATH];;
    LPCTSTR pCaption;

    va_list parg;
    int Result;
    
    // if no MsgId is given, it is for no memory error;
    if (MsgId)
    {
        va_start(parg, Type);
    
        // load the msg string to szCaption(temp). The text may contain
        // format information
        if (!::LoadString(g_hInstance, MsgId, szCaption, ARRAYLEN(szCaption)))
        {
            goto NoMemory;
        }
        
        //finish up format string
        wvsprintf(szMsg, szCaption, parg);
        
        // if caption id is given, load it.
        if (CaptionId)
        {
            if (!::LoadString(g_hInstance, CaptionId, szCaption, ARRAYLEN(szCaption)))
            {
                goto NoMemory;
            }

            pCaption = szCaption;
        }
        
        else
        {
            pCaption = g_strDevMgr;
        }
    
        if (!(Result = MessageBox(hwndParent, szMsg, pCaption, Type)))
        {
            goto NoMemory;
        }
        
        return Result;
    }

NoMemory:
    g_MemoryException.ReportError(hwndParent);
    return 0;
}


// This function creates and displays a message box for the given
// win32 error(or last error)
// INPUT:
//  hwndParent -- the parent window for the will-be-created message box
//  CaptionId  -- optional string id for caption
//  Type       -- message styles(MB_xxxx)
//  Error      -- Error code. If the value is ERROR_SUCCESS,
//            GetLastError() will be called to retreive the
//            real error code.
// OUTPUT:
//  the value return from MessageBox
//
int
MsxBoxWinError(
    HWND hwndParent,
    int  CaptionId,
    DWORD Type,
    DWORD Error
    )
{
    if (ERROR_SUCCESS == Error)
    {
        Error = GetLastError();
    }

    // nonsense to report success!
    ASSERT(ERROR_SUCCESS != Error);

    TCHAR szMsg[MAX_PATH];
    TCHAR szCaption[MAX_PATH];
    LPCTSTR Caption;

    if (CaptionId && ::LoadString(g_hInstance, CaptionId, szCaption, ARRAYLEN(szCaption)))
    {
        Caption = szCaption;
    }

    else
    {
        Caption = g_strDevMgr;
    }

    FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
          NULL, Error, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
          szMsg, ARRAYLEN(szMsg), NULL);
    
    return MessageBox(hwndParent, szMsg, Caption, Type);
}

// This functin prompts for restart.
// INPUT:
//  hwndParent -- the window handle to be used as the parent window
//            to the restart dialog
//  RestartFlags -- flags(RESTART/REBOOT/POWERRECYCLE)
//  ResId        -- designated string resource id. If 0, default will
//          be used.
// OUTPUT:
//  ID returned from the MessageBox.  IDYES if the user said Yes to the restart
//  dialog and IDNO if they said NO.
INT
PromptForRestart(
    HWND hwndParent,
    DWORD RestartFlags,
    int   ResId
    )
{
    INT id = 0;    
    
    if (RestartFlags & (DI_NEEDRESTART | DI_NEEDREBOOT))
    {
        DWORD ExitWinCode;

        try
        {
            String str;
    
            if (RestartFlags & DI_NEEDRESTART)
            {
                if (!ResId)
                {
                    ResId = IDS_DEVCHANGE_RESTART;
                }

                str.LoadString(g_hInstance, ResId);
                ExitWinCode = EWX_REBOOT;
            }
            
            else if (RestartFlags & DI_NEEDREBOOT)
            {
                if (!ResId && RestartFlags & DI_NEEDPOWERCYCLE)
                {
        
                    String str2;
                    str.LoadString(g_hInstance, IDS_POWERCYC1);
                    str2.LoadString(g_hInstance, IDS_POWERCYC2);
                    str += str2;
                    ExitWinCode = EWX_SHUTDOWN;
                }
                
                else
                {
                    if (!ResId)
                    {
                        ResId = IDS_DEVCHANGE_RESTART;
                    }

                    str.LoadString(g_hInstance, ResId);
                    ExitWinCode = EWX_REBOOT;
                }
            }
            
            id = RestartDialogEx(hwndParent, 
                                 str, 
                                 ExitWinCode, 
                                 REASON_PLANNED_FLAG | REASON_HWINSTALL
                                 );
        }
        
        catch(CMemoryException* e)
        {
            e->Delete();
            MsgBoxParam(hwndParent, 0, 0, 0);
        }
    }

    return id;
}

BOOL
LoadEnumPropPage32(
    LPCTSTR RegString,
    HMODULE* pDll,
    FARPROC* pProcAddress
    )
{
    // verify parameters
    if (!RegString || _T('\0') == RegString[0] || !pDll || !pProcAddress)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // make a copy of the string because we have to party on it
    TCHAR* psz = new TCHAR[lstrlen(RegString) + 1];
    
    if (!psz) 
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    lstrcpy(psz, RegString);
    LPTSTR DllName;
    LPTSTR DllNameEnd;
    LPTSTR FunctionName;
    LPTSTR FunctionNameEnd;
    LPTSTR p;
    p = psz;
    SetLastError(ERROR_SUCCESS);
    
    // the format of the  string is "dllname, dllentryname"
    p = SkipBlankChars(p);
    if (_T('\0') != *p)
    {
        // looking for dllname which could be enclosed
        // inside double quote chars.
        // NOTE: not double quote chars inside double quoted string is allowed.
        if (_T('\"') == *p)
        {
            DllName = ++p;
            while (_T('\"') != *p && _T('\0') != *p)
                p++;
            DllNameEnd = p;
            if (_T('\"') == *p)
            p++;
        }
        else
        {
            DllName = p;
            while (!IsBlankChar(*p) && _T(',') != *p)
            p++;
            DllNameEnd = p;
        }
        
        // looking for ','
        p = SkipBlankChars(p);
        if (_T('\0') != *p && _T(',') == *p)
        {
            p = SkipBlankChars(p + 1);
            if (_T('\0') != *p)
            {
                FunctionName = p++;
                while (!IsBlankChar(*p) && _T('\0') != *p)
                    p++;
                FunctionNameEnd = p;
            }
        }
    }

    if (DllName && FunctionName)
    {
        *DllNameEnd = _T('\0');
        *FunctionNameEnd = _T('\0');
        *pDll = LoadLibrary(DllName);
        if (*pDll)
        {
#ifdef UNICODE
            // convert Wide char to ANSI which is GetProcAddress expected.
            // We do not append a 'A" or a "W' here.
            CHAR FuncNameA[256];
            int LenA = WideCharToMultiByte(CP_ACP, 0,
                           FunctionName,
                           wcslen(FunctionName) + 1,
                           FuncNameA,
                           sizeof(FuncNameA),
                           NULL, NULL);
            *pProcAddress = GetProcAddress(*pDll, FuncNameA);
#else
            *pProcAddress = GetProcAddress(*pDll, FunctionName);
#endif
        }
    }
    
    delete [] psz;
    
    if (!*pProcAddress && *pDll)
        FreeLibrary(*pDll);
    
    return (*pDll && *pProcAddress);
}


BOOL
AddPropPageCallback(
    HPROPSHEETPAGE hPage,
    LPARAM lParam
    )
{
    CPropSheetData* ppsData = (CPropSheetData*)lParam;
    ASSERT(ppsData);
    return ppsData->InsertPage(hPage);
}

PCTSTR
MyGetFileTitle(
    IN PCTSTR FilePath
    )

/*++

Routine Description:

    This routine returns a pointer to the first character in the
    filename part of the supplied path.  If only a filename was given,
    then this will be a pointer to the first character in the string
    (i.e., the same as what was passed in).

    To find the filename part, the routine returns the last component of
    the string, beginning with the character immediately following the
    last '\', '/' or ':'. (NB NT treats '/' as equivalent to '\' )

Arguments:

    FilePath - Supplies the file path from which to retrieve the filename
        portion.

Return Value:

    A pointer to the beginning of the filename portion of the path.

--*/

{
    PCTSTR LastComponent = FilePath;
    TCHAR  CurChar;

    while(CurChar = *FilePath) {
        FilePath = CharNext(FilePath);
        if((CurChar == TEXT('\\')) || (CurChar == TEXT('/')) || (CurChar == TEXT(':'))) {
            LastComponent = FilePath;
        }
    }

    return LastComponent;
}

BOOL
AddToolTips(
    HWND hDlg,
    UINT id,
    LPCTSTR pszText,
    HWND *phwnd
    )
{
    if (*phwnd == NULL)
    {
        *phwnd = CreateWindow(TOOLTIPS_CLASS,
                              TEXT(""),
                              WS_POPUP | TTS_NOPREFIX,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              hDlg,
                              NULL,
                              g_hInstance,
                              NULL);
        if (*phwnd)
        {
            TOOLINFO ti;

            ti.cbSize = sizeof(ti);
            ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
            ti.hwnd = hDlg;
            ti.uId = (UINT_PTR)GetDlgItem(hDlg, id);
            ti.lpszText = (LPTSTR)pszText;  // const -> non const
            ti.hinst = g_hInstance;
            SendMessage(*phwnd, TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);
        }
    }

    return (*phwnd) ? TRUE : FALSE;
}

BOOL
EnablePrivilege(
    IN PCTSTR PrivilegeName,
    IN BOOL   Enable
    )

/*++

Routine Description:

    Enable or disable a given named privilege.

Arguments:

    PrivilegeName - supplies the name of a system privilege.

    Enable - flag indicating whether to enable or disable the privilege.

Return Value:

    Boolean value indicating whether the operation was successful.

--*/

{
    HANDLE Token;
    BOOL b;
    TOKEN_PRIVILEGES NewPrivileges;
    LUID Luid;

    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&Token)) {
        return(FALSE);
    }

    if(!LookupPrivilegeValue(NULL,PrivilegeName,&Luid)) {
        CloseHandle(Token);
        return(FALSE);
    }

    NewPrivileges.PrivilegeCount = 1;
    NewPrivileges.Privileges[0].Luid = Luid;
    NewPrivileges.Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;

    b = AdjustTokenPrivileges(
            Token,
            FALSE,
            &NewPrivileges,
            0,
            NULL,
            NULL
            );

    CloseHandle(Token);

    return(b);
}

void Int64ToStr(LONGLONG n, LPTSTR lpBuffer)
{
    TCHAR szTemp[40];
    LONGLONG iChr = 0;

    do {
        szTemp[iChr++] = TEXT('0') + (TCHAR)(n % 10);
        n = n / 10;
    } while (n != 0);

    do {
        iChr--;
        *lpBuffer++ = szTemp[iChr];
    } while (iChr != 0);

    *lpBuffer++ = '\0';
}

//
//  Obtain NLS info about how numbers should be grouped.
//
//  The annoying thing is that LOCALE_SGROUPING and NUMBERFORMAT
//  have different ways of specifying number grouping.
//
//          LOCALE      NUMBERFMT      Sample   Country
//
//          3;0         3           1,234,567   United States
//          3;2;0       32          12,34,567   India
//          3           30           1234,567   ??
//
//  Not my idea.  That's the way it works.
//
UINT GetNLSGrouping(void)
{
    TCHAR szGrouping[32];
    // If no locale info, then assume Western style thousands
    if (!GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szGrouping, ARRAYLEN(szGrouping)))
        return 3;

    UINT grouping = 0;
    LPTSTR psz = szGrouping;
    for (;;)
    {
        if (*psz == '0') break;             // zero - stop

        else if ((UINT)(*psz - '0') < 10)   // digit - accumulate it
            grouping = grouping * 10 + (UINT)(*psz - '0');

        else if (*psz)                      // punctuation - ignore it
            { }

        else                                // end of string, no "0" found
        {
            grouping = grouping * 10;       // put zero on end (see examples)
            break;                          // and finished
        }

        psz++;
    }
    return grouping;
}

STDAPI_(LPTSTR) 
AddCommas64(
    LONGLONG n, 
    LPTSTR pszResult, 
    UINT cchResult
    )
{
    TCHAR  szTemp[MAX_COMMA_NUMBER_SIZE];
    TCHAR  szSep[5];
    NUMBERFMT nfmt;

    nfmt.NumDigits=0;
    nfmt.LeadingZero=0;
    nfmt.Grouping = GetNLSGrouping();
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, ARRAYLEN(szSep));
    nfmt.lpDecimalSep = nfmt.lpThousandSep = szSep;
    nfmt.NegativeOrder= 0;

    Int64ToStr(n, szTemp);

    if (GetNumberFormat(LOCALE_USER_DEFAULT, 0, szTemp, &nfmt, pszResult, cchResult) == 0)
        StrCpyN(pszResult, szTemp, cchResult);

    return pszResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\machine.h ===
#ifndef __MACHINE_H_
#define __MACHINE_H_

/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    machine.h

Abstract:

    header file that declares CMachine, CDevInfoist and CMachineList classes

Author:

    William Hsieh (williamh) created

Revision History:


--*/

LRESULT CALLBACK dmNotifyWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

typedef BOOL (*LPFNINSTALLDEVINST)(HWND hwndParent, LPCTSTR DeviceId, BOOL UpdateDriver, DWORD* pReboot);
typedef BOOL (*LPFNROLLBACKDRIVER)(HWND hwndParent, LPCTSTR RegistryKey, DWORD Flags, DWORD* pReboot);

class CDevice;
class CClass;
class CComputer;
class CLogConf;
class CResDes;
class CMachineList;
class CFolder;

#define DM_NOTIFY_TIMERID           0x444d4d44

//This class represents SETUPAPI's <Device Information List>
//
// WARNING !!!
// no copy constructor and assignment operator are provided ---
// DO NOT ASSIGN A CDevInfoList from one to another!!!!!
class CDevInfoList
{
public:

    CDevInfoList(HDEVINFO hDevInfo = INVALID_HANDLE_VALUE, HWND hwndParent = NULL)
            :m_hDevInfo(hDevInfo), m_hwndParent(hwndParent)
        {
        }
    virtual ~CDevInfoList()
        {
            if (INVALID_HANDLE_VALUE != m_hDevInfo)
                DiDestroyDeviceInfoList();
        }

    operator HDEVINFO()
        {
            return m_hDevInfo;
        }
    BOOL DiGetDeviceInfoListDetail(PSP_DEVINFO_LIST_DETAIL_DATA DetailData)
        {
           return SetupDiGetDeviceInfoListDetail(m_hDevInfo, DetailData);
        }
    BOOL DiOpenDeviceInfo(LPCTSTR DeviceID, HWND hwndParent, DWORD OpenFlags,
                          PSP_DEVINFO_DATA DevData)
        {
           return SetupDiOpenDeviceInfo(m_hDevInfo, DeviceID, hwndParent, OpenFlags,
                                        DevData);
        }
    BOOL DiEnumDeviceInfo(DWORD Index, PSP_DEVINFO_DATA DevData)
        {
            return SetupDiEnumDeviceInfo(m_hDevInfo, Index, DevData);
        }
    BOOL DiBuildDriverInfoList(PSP_DEVINFO_DATA DevData, DWORD DriverType)
        {
            return SetupDiBuildDriverInfoList(m_hDevInfo, DevData, DriverType);
        }
    BOOL DiEnumDriverInfo(PSP_DEVINFO_DATA DevData, DWORD DriverType, DWORD Index,
                          PSP_DRVINFO_DATA DrvData)
        {
            return  SetupDiEnumDriverInfo(m_hDevInfo, DevData, DriverType, Index, DrvData);
        }
    BOOL DiGetDriverInfoDetail(PSP_DEVINFO_DATA DevData, PSP_DRVINFO_DATA DrvData,
                               PSP_DRVINFO_DETAIL_DATA DrvDetailData,
                               DWORD DrvDetailDataSize,
                               PDWORD RequiredSize)
        {
            return SetupDiGetDriverInfoDetail(m_hDevInfo, DevData, DrvData,
                                              DrvDetailData,
                                              DrvDetailDataSize,
                                              RequiredSize);
        }
    BOOL DiDestroyDriverInfoList(PSP_DEVINFO_DATA DevData, DWORD DriverType)
        {
            return SetupDiDestroyDriverInfoList(m_hDevInfo, DevData, DriverType);
        }
    BOOL DiCallClassInstaller(DI_FUNCTION InstallFunction, PSP_DEVINFO_DATA DevData)
        {
            return SetupDiCallClassInstaller(InstallFunction, m_hDevInfo, DevData);
        }
    BOOL DiRemoveDevice(PSP_DEVINFO_DATA DevData)
        {
            return SetupDiRemoveDevice(m_hDevInfo, DevData);
        }
    BOOL DiChangeState(PSP_DEVINFO_DATA DevData)
        {
            return SetupDiChangeState(m_hDevInfo, DevData);
        }
    HKEY DiOpenDevRegKey(PSP_DEVINFO_DATA DevData, DWORD Scope, DWORD HwProfile,
                         DWORD KeyType, REGSAM samDesired)
        {
            return  SetupDiOpenDevRegKey(m_hDevInfo, DevData, Scope, HwProfile,
                                  KeyType, samDesired);
        }
    BOOL DiGetDeviceRegistryProperty(PSP_DEVINFO_DATA DevData, DWORD Property,
                                     PDWORD PropertyDataType, PBYTE PropertyBuffer,
                                     DWORD PropertyBufferSize, PDWORD RequiredSize)
        {
            return SetupDiGetDeviceRegistryProperty(m_hDevInfo, DevData,
                                              Property, PropertyDataType,
                                              PropertyBuffer,
                                              PropertyBufferSize,
                                              RequiredSize
                                              );
        }
    BOOL DiGetDeviceInstallParams(PSP_DEVINFO_DATA DevData,
                                  PSP_DEVINSTALL_PARAMS DevInstParams)
        {
            return SetupDiGetDeviceInstallParams(m_hDevInfo, DevData, DevInstParams);
        }
    BOOL DiGetClassInstallParams(PSP_DEVINFO_DATA DevData,
                                 PSP_CLASSINSTALL_HEADER ClassInstallHeader,
                                 DWORD ClassInstallParamsSize,
                                 PDWORD RequiredSize)
        {
            return SetupDiGetClassInstallParams(m_hDevInfo, DevData,
                                          ClassInstallHeader,
                                          ClassInstallParamsSize,
                                          RequiredSize);
        }
    BOOL DiSetDeviceInstallParams(PSP_DEVINFO_DATA DevData,
                                PSP_DEVINSTALL_PARAMS DevInstParams)
        {
             return SetupDiSetDeviceInstallParams(m_hDevInfo, DevData, DevInstParams);
        }
    BOOL DiSetClassInstallParams(PSP_DEVINFO_DATA DevData,
                                 PSP_CLASSINSTALL_HEADER ClassInstallHeader,
                                 DWORD ClassInstallParamsSize)
        {
            return SetupDiSetClassInstallParams(m_hDevInfo, DevData,
                                     ClassInstallHeader,
                                     ClassInstallParamsSize);
        }
    BOOL DiGetClassDevPropertySheet(PSP_DEVINFO_DATA DevData,
                                    LPPROPSHEETHEADER PropertySheetHeader,
                                    DWORD PagesAllowed,
                                    DWORD Flags)
        {
            return  SetupDiGetClassDevPropertySheets(m_hDevInfo, DevData,
                                        PropertySheetHeader, PagesAllowed,
                                        NULL, Flags);
        }

    BOOL DiGetExtensionPropSheetPage(PSP_DEVINFO_DATA DevData,
                                     LPFNADDPROPSHEETPAGE pfnAddPropSheetPage,
                                     DWORD PageType,
                                     LPARAM lParam
                                     );

    BOOL DiGetSelectedDriver(PSP_DEVINFO_DATA DevData, PSP_DRVINFO_DATA DriverInfoData)
        {
            return SetupDiGetSelectedDriver(m_hDevInfo, DevData, DriverInfoData);
        }
    BOOL DiSetSelectedDriver(PSP_DEVINFO_DATA DevData, PSP_DRVINFO_DATA DriverInfoData)
        {
            return SetupDiSetSelectedDriver(m_hDevInfo, DevData, DriverInfoData);
        }
    BOOL DiEnumDeviceInterfaces(DWORD Index, LPGUID InterfaceGuid, PSP_DEVICE_INTERFACE_DATA InterfaceData)
        {
            return SetupDiEnumDeviceInterfaces(m_hDevInfo, NULL, InterfaceGuid, Index, InterfaceData);
        }
    BOOL DiGetInterfaceDetailData(PSP_DEVICE_INTERFACE_DATA pInterfaceData,
                                        PSP_DEVICE_INTERFACE_DETAIL_DATA pDetailData,
                                        DWORD Size, DWORD* pRequiredSize)
        {
            return SetupDiGetDeviceInterfaceDetail(m_hDevInfo, pInterfaceData,
                                                   pDetailData, Size,
                                                   pRequiredSize, NULL);
        }
    BOOL DiTurnOnDiFlags(PSP_DEVINFO_DATA DevData, DWORD FlagMask );
    BOOL DiTurnOffDiFlags(PSP_DEVINFO_DATA DevData, DWORD FlagsMask);
    BOOL DiTurnOnDiExFlags(PSP_DEVINFO_DATA DevData, DWORD FlagMask );
    BOOL DiTurnOffDiExFlags(PSP_DEVINFO_DATA DevData, DWORD FlagsMask);
    BOOL InstallDevInst(HWND hwndParent, LPCTSTR DeviceID, BOOL UpdateDriver, DWORD* pReboot);
    BOOL RollbackDriver(HWND hwndParent, LPCTSTR RegistryKeyName, DWORD Flags, DWORD* pReboot);
    DWORD DiGetFlags(PSP_DEVINFO_DATA DevData = NULL);
    DWORD DiGetExFlags(PSP_DEVINFO_DATA DevData = NULL);
    void DiDestroyDeviceInfoList();
    BOOL DiGetDeviceMFGString(PSP_DEVINFO_DATA DevData, String& str);
    BOOL DiGetDeviceMFGString(PSP_DEVINFO_DATA DevData, TCHAR* pBuffer, DWORD Size, DWORD* pRequiredSize = NULL);
    BOOL DiGetDeviceIDString(PSP_DEVINFO_DATA DevData, String& str);
    BOOL DiGetDeviceIDString(PSP_DEVINFO_DATA DevData, TCHAR* pBuffer, DWORD Size, DWORD* pRequiredSize = NULL);
    HWND OwnerWindow()
        {
            return m_hwndParent;
        }
protected:
    HDEVINFO    m_hDevInfo;
    HWND        m_hwndParent;

private:
    CDevInfoList(const CDevInfoList&);
    CDevInfoList& operator=(const CDevInfoList&);
};

class CMachine : public CDevInfoList
{
public:
    CMachine(LPCTSTR MachineName = NULL);

    virtual ~CMachine();
    operator HMACHINE()
        {
            return m_hMachine;
        }
    LPCTSTR GetMachineDisplayName()
        {
            return (LPCTSTR)m_strMachineDisplayName;
        }
    LPCTSTR GetMachineFullName()
        {
            return (LPCTSTR)m_strMachineFullName;
        }
    LPCTSTR GetRemoteMachineFullName()
        {
            return m_IsLocal ? NULL : (LPCTSTR)m_strMachineFullName;
        }
    HMACHINE GetHMachine()
        {
            return m_hMachine;
        }
    BOOL LoadStringWithMachineName(int StringId, LPTSTR Buffer, DWORD* BufferLen);

    BOOL IsLocal()
        {
            return m_IsLocal;
        }
    BOOL AttachFolder(CFolder* pFolder);
    void DetachFolder(CFolder* pFolder);
    BOOL IsFolderAttached(CFolder* pFolder);
    BOOL AttachPropertySheet(HWND hwndPropertySheet);
    void DetachPropertySheet(HWND hwndPropertySheet);
    HWND GetDeviceWindowHandle(LPCTSTR DeviceId);
    HWND GetClassWindowHandle(LPGUID ClassGuid);
    BOOL AttachChildMachine(CMachine* ChildMachine);
    void DetachChildMachine(CMachine* ChildMachine);
    BOOL EnuemerateDevice(int Index, CDevice** ppDevice);

    BOOL Initialize(
        HWND hwndParent = NULL, 
        LPCTSTR DeviceId = NULL,
        LPGUID ClassGuid = NULL
        );

    DWORD GetNumberOfClasses() const
        {
            return m_listClass.GetCount();
        }
    DWORD GetNumberOfDevices() const
        {
            return (DWORD)m_listDevice.GetCount();
        }
    BOOL GetFirstClass(CClass** ppClass, PVOID& Context);
    BOOL GetNextClass(CClass** ppClass, PVOID&  Context);
    BOOL GetFirstDevice(CDevice** ppDevice,  PVOID&  Context);
    BOOL GetNextDevice(CDevice** ppDevice, PVOID&  Context);
    CDevice* DevNodeToDevice(DEVNODE dn);
    CDevice* DeviceIDToDevice(LPCTSTR DeviceID);
    CClass* ClassGuidToClass(LPGUID ClassGuid);
    BOOL Reenumerate();
    BOOL DoMiniRefresh();
    BOOL Refresh();
    int GetComputerIconIndex()
    {
        return m_ComputerIndex;
    }
    int GetResourceIconIndex()
    {
        return m_ResourceIndex;
    }
    BOOL ShouldPropertySheetDestroy()
    {
        return m_PropertySheetShoudDestroy;
    }
    void SetPropertySheetShouldDestroy()
    {
        m_PropertySheetShoudDestroy = TRUE;
    }
    BOOL GetDigitalSigner(LPTSTR FullInfPath, String& DigitalSigner);
    BOOL DoNotCreateDevice(SC_HANDLE SCMHandle, LPGUID ClassGuid, DEVINST DevInst);
    BOOL IsUserAGuest()
        {
            return m_UserIsAGuest;
        }
    HDEVINFO DiCreateDeviceInfoList(LPGUID ClassGuid, HWND hwndParent)
        {
            return SetupDiCreateDeviceInfoListEx(ClassGuid, hwndParent,
                                GetRemoteMachineFullName(), NULL);
        }
    HDEVINFO DiCreateDeviceInterfaceList(LPGUID InterfaceGuid, LPCTSTR DeviceId, HWND hwndParent)
        {
            return SetupDiGetClassDevsEx(InterfaceGuid, DeviceId, m_hwndParent, DIGCF_DEVICEINTERFACE,
                                         NULL, GetRemoteMachineFullName(), NULL);
        }

    HDEVINFO DiGetClassDevs(LPGUID ClassGuid, LPCTSTR Enumerator, HWND hwndParent, DWORD Flags)
        {
            return SetupDiGetClassDevsEx(ClassGuid, Enumerator, hwndParent,
                                     Flags, NULL, GetRemoteMachineFullName(), NULL
                                     );
        }
    HIMAGELIST DiGetClassImageList()
        {
            return m_ImageListData.ImageList;
        }
    BOOL DiBuildClassInfoList(DWORD Flags, LPGUID ClassGuid,
                              DWORD ClassGuidListSize, PDWORD RequiredSize)
        {
            return SetupDiBuildClassInfoListEx(Flags, ClassGuid,
                                     ClassGuidListSize, RequiredSize,
                                     GetRemoteMachineFullName(), NULL);
        }
    BOOL DiGetClassDescription(LPGUID ClassGuid, LPTSTR ClassDescription,
                               DWORD ClassDescriptionSize, PDWORD RequiredSize)
        {
            return SetupDiGetClassDescriptionEx(ClassGuid, ClassDescription,
                                        ClassDescriptionSize,
                                        RequiredSize,
                                        GetRemoteMachineFullName(),
                                        NULL);
        }
    HKEY DiOpenClassRegKey(LPGUID ClassGuid, REGSAM samDesired, DWORD Flags)
        {
            return SetupDiOpenClassRegKeyEx(ClassGuid, samDesired, Flags,
                                    GetRemoteMachineFullName(), NULL);
        }
    BOOL DiGetHwProfileList(PDWORD HwProfileList, DWORD HwProfileListSize,
                            PDWORD RequiredSize, PDWORD CurrentIndex)
        {
            return  SetupDiGetHwProfileListEx(HwProfileList, HwProfileListSize,
                                       RequiredSize, CurrentIndex,
                                       GetRemoteMachineFullName(), NULL);
        }
    BOOL DiLoadClassIcon(LPGUID ClassGuid, HICON* LargeIcon, PINT MiniIconIndex)
        {
            return SetupDiLoadClassIcon(ClassGuid, LargeIcon, MiniIconIndex);
        }
    BOOL DiGetClassImageList(PSP_CLASSIMAGELIST_DATA pImageListData)
        {
            return SetupDiGetClassImageListEx(pImageListData,
                                   GetRemoteMachineFullName(), NULL);
        }
    BOOL DiDestroyClassImageList(PSP_CLASSIMAGELIST_DATA pImageListData)
        {
            return SetupDiDestroyClassImageList(pImageListData);
        }

    BOOL DiGetClassImageIndex(LPGUID ClassGuid, PINT ImageIndex)
        {
            return SetupDiGetClassImageIndex(&m_ImageListData, ClassGuid, ImageIndex);
        }
    int  DiDrawMiniIcon(HDC hdc, RECT rc, int IconIndex, DWORD Flags)
        {
            return SetupDiDrawMiniIcon(hdc, rc, IconIndex, Flags);
        }
    BOOL DiClassNameFromGuid(LPGUID ClassGuid, LPTSTR ClassName,
                             DWORD ClassNameSize, PDWORD RequiredSize)
        {
            return SetupDiClassNameFromGuidEx(ClassGuid, ClassName,
                                      ClassNameSize, RequiredSize,
                                      GetRemoteMachineFullName(), NULL);
        }
    BOOL DiGetHwProfileFriendlyName(DWORD HwProfile, LPTSTR FriendlyName,
                                    DWORD FriendlyNameSize,
                                    PDWORD RequiredSize)

        {
            return SetupDiGetHwProfileFriendlyNameEx(HwProfile, FriendlyName,
                                             FriendlyNameSize,
                                             RequiredSize,
                                             GetRemoteMachineFullName(),
                                             NULL);
        }
    BOOL DiGetClassFriendlyNameString(LPGUID Guid, String& strClass);
    BOOL DiDestroyDeviceInfoList(HDEVINFO hDevInfo)
        {
            return SetupDiDestroyDeviceInfoList(hDevInfo);
        }

///////////////////////////////////////////////////////////////////////////
//// Configuration Manager APIs
////
    CONFIGRET GetLastCR()
        {
            return m_LastCR;
        }
    BOOL CmGetConfigFlags(DEVNODE dn, DWORD* pFlags);
    BOOL CmGetCapabilities(DEVNODE dn, DWORD* pCapabilities);
    BOOL CmGetDeviceIDString(DEVNODE dn, String& str);
    BOOL CmGetDescriptionString(DEVNODE dn, String& str);
    BOOL CmGetMFGString(DEVNODE dn, String& str);
    BOOL CmGetProviderString(DEVNODE dn, String& str);
    BOOL CmGetDriverDateString(DEVNODE dn, String& str);
    BOOL CmGetDriverDateData(DEVNODE dn, FILETIME *ft);
    BOOL CmGetDriverVersionString(DEVNODE dn, String& str);
    BOOL CmGetClassGuid(DEVNODE dn, GUID& Guid);
    BOOL CmGetHardwareIDs(DEVNODE dn, PVOID Buffer, ULONG* BufferLen);
    BOOL CmGetCompatibleIDs(DEVNODE dn, PVOID Buffer, ULONG* BufferLen);
    BOOL CmGetStatus(DEVNODE dn, DWORD* pProblem, DWORD* pStatus);
    BOOL CmGetKnownLogConf(DEVNODE dn, LOG_CONF* plc, DWORD* plcType);
    BOOL CmReenumerate(DEVNODE dn, ULONG Flags);
    BOOL CmGetHwProfileFlags(DEVNODE dn, ULONG Profile, ULONG* pFlags);
    BOOL CmGetHwProfileFlags(LPCTSTR DeviceID, ULONG Profile, ULONG* pFlags);
    BOOL CmSetHwProfileFlags(DEVNODE dn, ULONG Profile, ULONG Flags);
    BOOL CmSetHwProfileFlags(LPCTSTR DeviceID, ULONG Profile, ULONG Flags);
    BOOL CmGetCurrentHwProfile(ULONG* phwpf);
    BOOL CmGetHwProfileInfo(int Index, PHWPROFILEINFO pHwProfileInfo);
    BOOL CmGetBusGuid(DEVNODE dn, LPGUID Guid);
    BOOL CmGetBusGuidString(DEVNODE dn, String& str);
    DEVNODE CmGetParent(DEVNODE dn);
    DEVNODE CmGetChild(DEVNODE dn);
    DEVNODE CmGetSibling(DEVNODE dn);
    DEVNODE CmGetRootDevNode();
    BOOL CmHasResources(DEVNODE dn);
    BOOL CmHasDrivers(DEVNODE dn);
    DWORD CmGetResDesDataSize(RES_DES rd);
    BOOL CmGetResDesData(RES_DES rd, PVOID pData, ULONG DataSize);

    BOOL CmGetNextResDes(PRES_DES prdNext, RES_DES rd, RESOURCEID ForResource,
                          PRESOURCEID pTheResource);
    void CmFreeResDesHandle(RES_DES rd);
    void CmFreeResDes(PRES_DES prdPrev, RES_DES rd);
    void CmFreeLogConfHandle(LOG_CONF lc);
    int CmGetNumberOfBasicLogConf(DEVNODE dn);
    BOOL CmGetFirstLogConf(DEVNODE dn, LOG_CONF* plc, ULONG Type);
    BOOL CmGetNextLogConf(LOG_CONF* plcNext, LOG_CONF lcRef, ULONG Type);
    ULONG CmGetArbitratorFreeDataSize(DEVNODE dn, RESOURCEID ResType);
    BOOL CmGetArbitratorFreeData(DEVNODE dn, PVOID pBuffer, ULONG BufferSize,
                                 RESOURCEID ResType);
    BOOL CmTestRangeAvailable(RANGE_LIST RangeList, DWORDLONG dlBase,
                              DWORDLONG dlEnd);
    void CmDeleteRange(RANGE_LIST RangeList, DWORDLONG dlBase, DWORDLONG dlLen);
    BOOL CmGetFirstRange(RANGE_LIST RangeList, DWORDLONG* pdlBase,
                         DWORDLONG* pdlLen, RANGE_ELEMENT* pre);
    BOOL CmGetNextRange(RANGE_ELEMENT* pre, DWORDLONG* pdlBase, DWORDLONG* pdlLen);
    void CmFreeRangeList(RANGE_LIST RangeList);
    BOOL CmGetDeviceIdListSize(LPCTSTR Fileter, ULONG* Size, ULONG Flags);
    BOOL CmGetDeviceIdList(LPCTSTR Filter, TCHAR* Buffer, ULONG BufferSize, ULONG Flags);
    CONFIGRET CmGetRegistryProperty(DEVNODE dn, ULONG Property,
                                    PVOID pBuffer,
                                    ULONG* BufferSize);

    BOOL EnableRefresh(BOOL fEnable);
    BOOL ScheduleRefresh();
    void Lock()
        {
            EnterCriticalSection(&m_CriticalSection);
        }
    void Unlock()
        {
            LeaveCriticalSection(&m_CriticalSection);
        }
    CComputer*  m_pComputer;
    CMachine* m_ParentMachine;
    UINT  m_msgRefresh;
    static DWORD WaitDialogThread(PVOID Parameter);

private:

        // no copy constructor and no assigment operator
        CMachine(const CMachine& MachineSrc);
        CMachine& operator=(const CMachine& MachineSrc);

        BOOL BuildClassesFromGuidList(LPGUID GuidList, DWORD Guids);
        CONFIGRET CmGetRegistrySoftwareProperty(DEVNODE dn, LPCTSTR ValueName,
                                        PVOID pBuffer, ULONG* pBufferSize);
        void CreateDeviceTree(CDevice* pParent, CDevice* pSibling, DEVNODE dn);
        BOOL CreateClassesAndDevices(LPCTSTR DeviceId = NULL, LPGUID ClassGuid = NULL);
        void DestroyClassesAndDevices();
        BOOL CreateNotifyWindow();
        BOOL pGetOriginalInfName(LPTSTR InfName, String& OriginalInfName);
        String m_strMachineDisplayName;
        String m_strMachineFullName;
        HMACHINE m_hMachine;
        CONFIGRET   m_LastCR;
        CList<CClass*, CClass*> m_listClass;
        SP_CLASSIMAGELIST_DATA  m_ImageListData;
        int             m_ComputerIndex;
        int             m_ResourceIndex;
        CList<CDevice*, CDevice*> m_listDevice;
        DWORD           m_Flags;
        BOOL            m_Initialized;
        BOOL            m_IsLocal;
        BOOL            m_PropertySheetShoudDestroy;
        BOOL            m_UserIsAGuest;
        HWND            m_hwndNotify;
        CList<CFolder*, CFolder*> m_listFolders;
        int             m_RefreshDisableCounter;
        BOOL            m_RefreshPending;
        BOOL            m_ShowNonPresentDevices;
        CRITICAL_SECTION m_CriticalSection;
        CRITICAL_SECTION m_PropertySheetCriticalSection;
        CRITICAL_SECTION m_ChildMachineCriticalSection;
        CList<HWND, HWND> m_listPropertySheets;
        CList<CMachine*, CMachine*> m_listChildMachines;
};


class CMachineList
{
public:
    CMachineList() {};
    ~CMachineList();
    BOOL CreateMachine(HWND hwndParent, LPCTSTR MachineName, CMachine** ppMachine);
    CMachine* FindMachine(LPCTSTR MachineName);
private:
    CMachineList(const CMachineList& MachineListSrc);
    CMachineList& operator=(const CMachineList& MachineListSrc);
    CList<CMachine*, CMachine*> m_listMachines;
};
#endif  //__MACHINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\globals.h ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    globals.h

Abstract:

    header file for globals.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#ifndef __GLOBALS_H_
#define __GLOBALS_H_


class CMachineList;
class String;
class CMemoryException;

extern CMachineList g_MachineList;
extern HINSTANCE g_hInstance;
extern String       g_strStartupMachineName;
extern String       g_strStartupDeviceId;
extern String       g_strStartupCommand;
extern String       g_strDevMgr;
extern BOOL     g_HasLoadDriverNamePrivilege;
extern CPrintDialog g_PrintDlg;

extern CMemoryException g_MemoryException;

extern const CLSID CLSID_DEVMGR;
extern const CLSID CLSID_DEVMGR_EXTENSION;
extern const CLSID CLSID_SYSTOOLS;
extern const CLSID CLSID_DEVMGR_ABOUT;

extern const IID IID_IDMTVOCX;
extern const IID IID_ISnapinCallback;

extern const TCHAR*  const CLSID_STRING_DEVMGR;
extern const TCHAR*  const CLSID_STRING_DEVMGR_EXTENSION;
extern const TCHAR*  const CLSID_STRING_SYSTOOLS;
extern const TCHAR*  const CLSID_STRING_DEVMGR_ABOUT;

extern const TCHAR*  const MMC_SNAPIN_MACHINE_NAME;
extern const TCHAR*  const SNAPIN_INTERNAL;
extern const TCHAR*  const DEVMGR_SNAPIN_CLASS_GUID;
extern const TCHAR*  const DEVMGR_SNAPIN_DEVICE_ID;
extern const TCHAR*  const REG_PATH_DEVICE_MANAGER;
extern const TCHAR*  const REG_STR_BUS_TYPES;
extern const TCHAR*  const REG_STR_TROUBLESHOOTERS;
extern const TCHAR*  const DEVMGR_COMMAND_PROPERTY;
extern const TCHAR*  const DEVMGR_HELP_FILE_NAME;

extern const TCHAR*  const PROGID_DEVMGR;
extern const TCHAR*  const PROGID_DEVMGREXT;
extern const TCHAR*  const PROGID_DEVMGR_ABOUT;
extern const TCHAR*  const DEVMGR_HTML_HELP_FILE_NAME;
extern const TCHAR*  const ENV_NAME_SYSTEMDRIVE;

extern LPOLESTR AllocOleTaskString(LPCTSTR str);
extern void FreeOleTaskString(LPOLESTR str);

extern  const NODEINFO NodeInfo[];

//
// global functions declaration
//
extern HRESULT AddMenuItem(LPCONTEXTMENUCALLBACK pCallback, int iNameStringId,
               int iStatusBarStringId, long lCommandId,
               long InsertionPointId, long  Flags,
               long SpecialFlags = 0);
extern BOOL VerifyMachineName(LPCTSTR MachineName);
extern UINT LoadResourceString(int StringId, LPTSTR Buffer, UINT BufferSize);
extern UINT GetDeviceProblemText(HMACHINE hMachine, DEVNODE DevNode,  ULONG ProblemNumber,  LPTSTR Buffer, UINT BufferSize);
extern int MsgBoxParam(HWND hwnd, int MsgId, int CaptionId, DWORD Type, ...);
extern int MsgBoxWinError(HWND hwndParent, int CaptionId, DWORD Type, DWORD Error = ERROR_SUCCESS);
extern LRESULT dmNotifyWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT PromptForRestart(HWND hwndParent, DWORD RestartFlags, int ResId = 0);

extern BOOL LoadEnumPropPage32(LPCTSTR RegString, HMODULE* pdll, FARPROC* pProcAddress);
extern BOOL IsBlankChar(TCHAR ch);
extern LPTSTR SkipBlankChars(LPTSTR psz);
extern BOOL GuidFromString(LPCTSTR GuidString, LPGUID pGuid);
extern BOOL GuidToString(LPGUID pGuid, LPTSTR Buffer, DWORD BufferLen);
extern PCTSTR MyGetFileTitle(IN PCTSTR FilePath);
extern BOOL AddToolTips(HWND hDlg, UINT id, LPCTSTR pszText, HWND *phwnd);
extern BOOL AddPropPageCallback(HPROPSHEETPAGE hPage, LPARAM lParam);
extern BOOL EnablePrivilege(PCTSTR PrivilegeName, BOOL Enable);
const int MAX_PROP_PAGES = 64;

#if DBG
extern void Trace(LPCTSTR format, ...);
#define TRACE(text)     Trace text
#else
#define TRACE(text)
#endif

#define DI_NEEDPOWERCYCLE   0x400000L

// Sizes of various stringized numbers
#define MAX_INT64_SIZE  30              // 2^64 is less than 30 chars long
#define MAX_COMMA_NUMBER_SIZE   (MAX_INT64_SIZE + 10)

STDAPI_(LPTSTR) 
AddCommas64(
    LONGLONG n, 
    LPTSTR pszResult, 
    UINT cchResult
    );


#endif      // __GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\printer.h ===
#ifndef __PRINTER_H_
#define __PRINTER_H_

/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    printer.h

Abstract:

    header file for printer.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/

class CPrintCancelDialog : public CDialog
{
public:
    CPrintCancelDialog() : CDialog(IDD_PRINT_CANCEL)
    {}
    virtual void OnCommand(WPARAM wParam, LPARAM lParam);
};


static BOOL CALLBACK AbortPrintProc(HDC hDC, int Code);

class CPrinter
{
public:
    CPrinter(HWND hwndOwner, HDC hDC);
    CPrinter() : m_hDC(NULL), m_hwndOwner(NULL),
         m_hLogFile(INVALID_HANDLE_VALUE)
    {}
    ~CPrinter()
    {
        if (m_hDC)
        DeleteDC(m_hDC);
            if (INVALID_HANDLE_VALUE != m_hLogFile)
        CloseHandle(m_hLogFile);
    }
    int StartDoc(LPCTSTR DocTitle);
    int EndDoc();
    int AbortDoc();
    int PrintLine(LPCTSTR Text);
    int FlushPage();
    void Indent()
    {
        m_Indent++;
    }
    void UnIndent()
    {
        if (m_Indent)
        m_Indent--;
    }
    void SetPageTitle(int TitleId)
    {
        m_strPageTitle.LoadString(g_hInstance, TitleId);
    }
    void LineFeed();
    int PrintAll(CMachine& Machine);
    int PrintSystemSummary(CMachine& Machine);
    int PrintResourceSummary(CMachine& Machine);
    int PrintAllClassAndDevice(CMachine* pMachine);
    int PrintClass(CClass* pClass, BOOL PrintBanner = TRUE);
    int PrintDevice(CDevice* pDevice, BOOL PrintBanner = TRUE);
    int PrintDeviceDriver(CDevice* pDevice);
    int PrintDeviceResource(CDevice* pDevice);
    int PrintResourceSubtree(CResource* pRes);
    static BOOL s_UserAborted;
    static HWND s_hCancelDlg;

private:
    HDC   m_hDC;
    HWND  m_hwndOwner;
    HANDLE  m_hLogFile;
    DWORD m_xChar;
    DWORD m_yChar;
    DWORD m_xMargin;
    DWORD m_yTopMargin;
    DWORD m_yBottomMargin;
    DWORD m_CurLine;
    DWORD m_CurPage;
    int   m_Indent;
    String m_strPageTitle;
    int     m_Status;
    CPrintCancelDialog  m_CancelDlg;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\printer.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    printer.cpp

Abstract:

    This module implements CPrinter -- class that support printing

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "devmgr.h"
#include "printer.h"
#include "cdriver.h"
#include "sysinfo.h"

const TCHAR* const g_BlankLine = TEXT("");
const TCHAR* const g_NewLine = TEXT("\r\n");
const CHAR*  const g_NewLineA = "\r\n";
//
// CPrinter Class implementation
//

BOOL CPrinter::s_UserAborted = FALSE;
HWND CPrinter::s_hCancelDlg = NULL;


void
CPrintCancelDialog::OnCommand(
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (BN_CLICKED == HIWORD(wParam) && IDCANCEL == LOWORD(wParam)) {
    
        CPrinter::s_UserAborted = TRUE;
    }
}

CPrinter::CPrinter(
    HWND hwndOwner,
    HDC hDC
    )
{
    m_hwndOwner = hwndOwner;
    s_UserAborted = FALSE;
    m_hDC = hDC;
    ASSERT(hDC);
    m_CurLine = 0;
    m_CurPage = 0;
    m_Indent = 0;
    m_Status = 1;
    TEXTMETRIC tm;
    GetTextMetrics(m_hDC, &tm);
    m_yChar = tm.tmHeight + tm.tmExternalLeading;
    m_xChar = tm.tmAveCharWidth;

    //
    // Give a little room for dot matrix printers.
    //
    m_xMargin = GetDeviceCaps(m_hDC, LOGPIXELSX) * 3 / 4;
    DWORD LinesPerPage;

    LinesPerPage = GetDeviceCaps(m_hDC, VERTRES) / m_yChar;
    m_yBottomMargin = LinesPerPage - 3; // Bottom Margin 3 lines from bottom of page.
    m_CancelDlg.DoModaless(hwndOwner, (LPARAM)&m_CancelDlg);
    s_hCancelDlg = m_CancelDlg.m_hDlg;

    //
    // Set the abort proc to allow cancel
    //
    SetAbortProc(m_hDC, AbortPrintProc);
    
    //
    // Four lines for top margin
    //
    m_yTopMargin = 4;
    m_hLogFile = INVALID_HANDLE_VALUE;
}

int
CPrinter::StartDoc(
    LPCTSTR DocTitle
    )
{
    if (m_hDC) {

        if (m_hwndOwner) {
        
            ::EnableWindow(m_hwndOwner, FALSE);
        }

        //
        // Initialize DOCINFO
        //
        DOCINFO DocInfo;
        DocInfo.cbSize = sizeof(DocInfo);
        TCHAR Temp[MAX_PATH];
        lstrcpyn(Temp, DocTitle, ARRAYLEN(Temp));
        DocInfo.lpszDocName = Temp;
        
        DocInfo.lpszOutput = NULL;
        DocInfo.lpszDatatype = NULL;
        DocInfo.fwType = 0;
        m_CurPage = 1;
        m_CurLine = 0;
        m_Status = ::StartDoc(m_hDC, &DocInfo);
    }
    
    else {

        if (!DocTitle || _T('\0') == *DocTitle) {
        
            m_Status = 0;
        }
        
        else {

            m_hLogFile = CreateFile(DocTitle,
                                    GENERIC_READ | GENERIC_WRITE,
                                    0,
                                    NULL,
                                    CREATE_NEW,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);

            m_Status = (INVALID_HANDLE_VALUE == m_hLogFile) ? 0 : 1;
        }
    }

    return m_Status;
}

int
CPrinter::EndDoc()
{

    if (m_hDC) {

        if (m_hwndOwner) {
        
            ::EnableWindow(m_hwndOwner, TRUE);
        }
        
        if (s_hCancelDlg) {

            DestroyWindow(s_hCancelDlg);
            s_hCancelDlg = NULL;
        }
        
        if (!s_UserAborted) {

            m_Status = ::EndDoc(m_hDC);
        }
    
    } else {
        
        m_Status = 1;
        
        if (INVALID_HANDLE_VALUE != m_hLogFile) {
        
            CloseHandle(m_hLogFile);
        
        } else {
        
            m_Status = 0;
        }
        
        m_hLogFile = INVALID_HANDLE_VALUE;
    }

    return m_Status;
}

int
CPrinter::AbortDoc()
{
    if (m_hDC) {

        if (m_hwndOwner) {
        
            ::EnableWindow(m_hwndOwner, TRUE);
        }
        
        if (s_hCancelDlg) {

            DestroyWindow(s_hCancelDlg);
            s_hCancelDlg = NULL;
        }
        
        m_Status = ::AbortDoc(m_hDC);
    
    } else {

        m_Status = 1;
        
        if (INVALID_HANDLE_VALUE != m_hLogFile) {
        
            CloseHandle(m_hLogFile);
        
        } else {
        
            m_Status = 0;
        }
        
        m_hLogFile = INVALID_HANDLE_VALUE;
    }

    return m_Status;
}

int
CPrinter::FlushPage()
{
    return PrintLine(NULL);
}

int
CPrinter::PrintLine(
    LPCTSTR LineText
    )
{
    if (INVALID_HANDLE_VALUE != m_hLogFile) {

        if (LineText) {

            DWORD BytesWritten;
            
            if (m_Indent) {

                int Count = m_Indent * 2;
                CHAR Blanks[MAX_PATH];
                
                for (int i = 0; i < Count; i++) {
                
                    Blanks[i] = _T(' ');
                }

                WriteFile(m_hLogFile, Blanks, Count * sizeof(CHAR), &BytesWritten, NULL);
            }
#ifdef UNICODE
            int LenW = wcslen(LineText);
            CHAR LineTextA[MAX_PATH];
            int LenA;
            LenA = WideCharToMultiByte(CP_ACP, 0, LineText, LenW, LineTextA, ARRAYLEN(LineTextA), NULL, NULL);
            WriteFile(m_hLogFile, LineTextA, LenA * sizeof(CHAR), &BytesWritten, NULL);
            WriteFile(m_hLogFile, g_NewLineA, strlen(g_NewLineA) * sizeof(CHAR), &BytesWritten, NULL);
#else
            WriteFile(m_hLogFile, LineText, lstrlen(LineText) * sizeof(CHAR), &BytesWritten, NULL);
            WriteFike(m_hLogFile, g_NewLine, lstrlen(g_NewLine) * sizeof(CHAR), &BytesWritten, NULL);
#endif
        }
    }
    
    else {
        
        //
        // !LineText means flush the page
        //
        if ((!LineText && m_CurLine) || (m_CurLine > m_yBottomMargin)) {

            m_CurLine = 0;
            
            if (m_Status) {
            
                m_Status = ::EndPage(m_hDC);
            }
        }
        
        if (LineText) {

            //
            // If this is the first line and we are still in good shape,
            // start a new page
            //
            if (!m_CurLine && m_Status) {

                m_Status = ::StartPage(m_hDC);
                
                if (m_Status) {

                    TCHAR PageTitle[MAX_PATH];
                    wsprintf(PageTitle, (LPCTSTR)m_strPageTitle, m_CurPage);
                    m_CurLine = m_yTopMargin;
                    TextOut(m_hDC, m_xMargin, m_yChar*m_CurLine, PageTitle, lstrlen(PageTitle));
                    
                    //
                    // Have one blank line right after page title
                    //
                    LineFeed();
                    m_CurLine++;
                    m_CurPage++;
                }
            }
            
            if (m_Status) {
            
                TextOut(m_hDC, m_xMargin + m_xChar*m_Indent*2, m_yChar*m_CurLine, LineText, lstrlen(LineText));
            }
            
            m_CurLine++;
        }
    }

    return m_Status;
}

inline
void
CPrinter::LineFeed()
{
    PrintLine(g_BlankLine);
}

// the abort procedure
BOOL CALLBACK
AbortPrintProc(
    HDC hDC,
    int nCode
    )
{
    MSG msg;

    while (!CPrinter::s_UserAborted && PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {

        if (!IsDialogMessage(CPrinter::s_hCancelDlg, &msg)) {

            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    
    return !CPrinter::s_UserAborted;
}

//
// This function prints system summary.
// INPUT:
//      Machine -- the machine
// OUTPUT:
//      0 -- failed else succeeded.
//
//
int
CPrinter::PrintSystemSummary(
    CMachine& Machine
    )
{
    CSystemInfo SysInfo;
    TCHAR Line[MAX_PATH];
    TCHAR Buffer[MAX_PATH];
    TCHAR Format[MAX_PATH];
    TCHAR Unknown[30];
    TCHAR szTemp[30];
    DWORD Size, BufferSize;
    BufferSize = ARRAYLEN(Buffer);
    
    //
    // Preload the "Unknown" string which will be used as default when
    // the corresponding value can not found
    //
    LoadString(g_hInstance, IDS_PRINT_UNKNOWN, Unknown, ARRAYLEN(Unknown));


    //
    // Print System summary heading
    //
    LoadString(g_hInstance, IDS_PRINT_HEADING_SYSSUMMARY, Buffer, ARRAYLEN(Buffer));
    LoadString(g_hInstance, IDS_PRINT_BANNER, Format, ARRAYLEN(Format));
    wsprintf(Line, Format, Buffer);
    PrintLine(Line);
    LineFeed();

    //
    // Windows version
    //
    LoadString(g_hInstance, IDS_PRINT_WINVER, Line, ARRAYLEN(Line));
    Size = SysInfo.WindowsVersion(Buffer, BufferSize);
    lstrcat(Line, Size ? Buffer : Unknown);
    PrintLine(Line);
    
    //
    // Registered Owner
    //
    LoadString(g_hInstance, IDS_PRINT_OWNER, Line, ARRAYLEN(Line));
    Size = SysInfo.RegisteredOwner(Buffer, BufferSize);
    lstrcat(Line, Size ? Buffer : Unknown);
    PrintLine(Line);
    
    //
    // Registered Organization
    //
    LoadString(g_hInstance, IDS_PRINT_ORGANIZATION, Line, ARRAYLEN(Line));
    Size = SysInfo.RegisteredOrganization(Buffer, BufferSize);
    lstrcat(Line, Size ? Buffer : Unknown);
    PrintLine(Line);
    
    //
    // Computer name
    //
    LoadString(g_hInstance, IDS_PRINT_COMPUTERNAME, Line, ARRAYLEN(Line));
    lstrcat(Line, SysInfo.ComputerName());
    PrintLine(Line);
    
    //
    // Machine Type
    //
    LoadString(g_hInstance, IDS_PRINT_MACHINE_TYPE, Line, ARRAYLEN(Line));
    Size = SysInfo.MachineType(Buffer, BufferSize);
    lstrcat(Line, Size ? Buffer : Unknown);
    PrintLine(Line);
    
    //
    // System BIOS Version
    //
    LoadString(g_hInstance, IDS_PRINT_SYSBIOS_VERSION, Line, ARRAYLEN(Line));
    Size = SysInfo.SystemBiosVersion(Buffer, BufferSize);
    lstrcat(Line, Size ? Buffer : Unknown);
    PrintLine(Line);

    //
    // System BIOS Date
    //
    LoadString(g_hInstance, IDS_PRINT_SYSBIOS_DATE, Line, ARRAYLEN(Line));
    Size = SysInfo.SystemBiosDate(Buffer, BufferSize);
    lstrcat(Line, Size ? Buffer : Unknown);
    PrintLine(Line);
    
    //
    // Processor type
    //
    LoadString(g_hInstance, IDS_PRINT_PROCESSOR_TYPE, Line, ARRAYLEN(Line));
    Size = SysInfo.ProcessorType(Buffer, BufferSize);
    lstrcat(Line, Size ? Buffer : Unknown);
    PrintLine(Line);

    //
    // Processor vendor
    //
    LoadString(g_hInstance, IDS_PRINT_PROCESSOR_VENDOR, Line, ARRAYLEN(Line));
    Size = SysInfo.ProcessorVendor(Buffer, BufferSize);
    lstrcat(Line, Size ? Buffer : Unknown);
    PrintLine(Line);

    //
    // Number of processors
    //
    LoadString(g_hInstance, IDS_PRINT_PROCESSORS, Line, ARRAYLEN(Line));
    DWORD NumProcessors = SysInfo.NumberOfProcessors();
    
    if (NumProcessors) {

        wsprintf(Buffer, TEXT("%u"), NumProcessors);
        lstrcat(Line, Buffer);
    
    } else {

        lstrcat(Line, Unknown);
    }

    PrintLine(Line);
    
    //
    // Total physical memory
    //
    ULARGE_INTEGER MemorySize;
    SysInfo.TotalPhysicalMemory(MemorySize);
    LoadString(g_hInstance, IDS_PRINT_PHY_MEMORY, Line, ARRAYLEN(Line));
    
    if (MemorySize.QuadPart) {

        LoadString(g_hInstance, IDS_PRINT_MEMORY_UNIT, Format, ARRAYLEN(Format));
        MemorySize.QuadPart += 1024*1024 - 1;
        wsprintf(Buffer, Format, Int64ShrlMod32(MemorySize.QuadPart, 20));
        lstrcat(Line, Buffer);
    
    } else {

        lstrcat(Line, Unknown);
    }

    PrintLine(Line);
    LineFeed();
    
    //
    //  Local disk drive information
    //
    // Print Disk info summary heading
    //
    LoadString(g_hInstance, IDS_PRINT_HEADING_DISKINFO, Buffer, ARRAYLEN(Buffer));
    LoadString(g_hInstance, IDS_PRINT_BANNER, Format, ARRAYLEN(Format));
    wsprintf(Line, Format, Buffer);
    PrintLine(Line);
    LineFeed();

    DISK_INFO DiskInfo;
    DiskInfo.cbSize = sizeof(DiskInfo);
    
    for(int Drive = 0; Drive < 25; Drive++) {

        // information we want to report on the drive:
        // (1). drive letter and type
        // (2). Total space
        // (3). Free space(if available)
        // (4). Cylinders
        // (5). Heads
        // (6). Sectors per track
        // (7). Bytes per sector
        
        Indent();
        
        if(SysInfo.GetDiskInfo(Drive, DiskInfo)) {

            TCHAR DriveLetter;
            DriveLetter = Drive + _T('A');
            LoadString(g_hInstance, IDS_PRINT_DRIVE_LETTER, Format, ARRAYLEN(Format));
            wsprintf(Line, Format, DriveLetter);
            PrintLine(Line);
            Indent();
            
            //
            // Drive type
            //
            LoadString(g_hInstance, IDS_PRINT_DRIVE_TYPE, Format, ARRAYLEN(Format));
            int StringId;
            LoadString(g_hInstance,
                       IDS_MEDIA_BASE + (int)DiskInfo.MediaType,
                       Buffer, ARRAYLEN(Buffer));
            wsprintf(Line, Format, Buffer);
            PrintLine(Line);
            
            //
            //Total and free space
            //
            LoadString(g_hInstance, IDS_PRINT_TOTAL_SPACE, Format, ARRAYLEN(Format));
            wsprintf(Line, Format, AddCommas64(DiskInfo.TotalSpace.QuadPart, szTemp, ARRAYLEN(szTemp)));
            PrintLine(Line);

            if (-1 != DiskInfo.FreeSpace.QuadPart) {

                LoadString(g_hInstance, IDS_PRINT_FREE_SPACE, Format, ARRAYLEN(Format));
                wsprintf(Line, Format, AddCommas64(DiskInfo.FreeSpace.QuadPart, szTemp, ARRAYLEN(szTemp)));
                PrintLine(Line);
            }
            
            //
            // Disk physical dimension
            // skip CD-ROM because the dimension it reports is bogus
            //
            if (DRIVE_CDROM != DiskInfo.DriveType) {

                //
                // Heads
                //
                LoadString(g_hInstance, IDS_PRINT_HEADS, Format, ARRAYLEN(Format));
                wsprintf(Line, Format, DiskInfo.Heads);
                PrintLine(Line);
                
                //
                // Cylinders
                //
                if (DiskInfo.Cylinders.HighPart) {

                    LoadString(g_hInstance, IDS_PRINT_CYLINDERS_XL, Format, ARRAYLEN(Format));
                    wsprintf(Line, Format, DiskInfo.Cylinders.HighPart,
                             DiskInfo.Cylinders.LowPart);
                    PrintLine(Line);
                
                } else {
                    LoadString(g_hInstance, IDS_PRINT_CYLINDERS, Format, ARRAYLEN(Format));
                    wsprintf(Line, Format, DiskInfo.Cylinders.LowPart);
                    PrintLine(Line);
                }
                
                //
                // Sectors per track
                //
                LoadString(g_hInstance, IDS_PRINT_TRACKSIZE, Format, ARRAYLEN(Format));
                wsprintf(Line, Format, DiskInfo.SectorsPerTrack);
                PrintLine(Line);
                
                //
                // Bytes per sector
                //
                LoadString(g_hInstance, IDS_PRINT_SECTORSIZE, Format, ARRAYLEN(Format));
                wsprintf(Line, Format, DiskInfo.BytesPerSector);
                PrintLine(Line);
            }

            UnIndent();
            LineFeed();
        }

        UnIndent();
    }

    return 1;
}

int
CPrinter::PrintResourceSummary(
    CMachine& Machine
    )
{
    TCHAR Temp[MAX_PATH];
    CResource* pResource;
    String str;
    String strBanner;

    PrintSystemSummary(Machine);

    //
    // print IRQ summary heading
    //
    str.LoadString(g_hInstance, IDS_PRINT_HEADING_IRQSUMMARY);
    strBanner.LoadString(g_hInstance, IDS_PRINT_BANNER);
    wsprintf(Temp, (LPCTSTR)strBanner, (LPCTSTR)str);
    PrintLine(Temp);
    LineFeed();
    CResourceList IrqSummary(&Machine, ResType_IRQ);
    
    if (IrqSummary.GetCount()) {

        CResource* pResRoot;
        IrqSummary.CreateResourceTree(&pResRoot);
        str.LoadString(g_hInstance, IDS_PRINT_IRQSUM);
        PrintLine(str);
        Indent();
        PrintResourceSubtree(pResRoot);
        UnIndent();
        LineFeed();
    }

    //
    // print DMA summary heading
    //
    str.LoadString(g_hInstance, IDS_PRINT_HEADING_DMASUMMARY);
    wsprintf(Temp, (LPCTSTR)strBanner, (LPCTSTR)str);
    PrintLine(Temp);
    LineFeed();
    CResourceList DmaSummary(&Machine, ResType_DMA);
    
    if (DmaSummary.GetCount()) {

        CResource* pResRoot;
        DmaSummary.CreateResourceTree(&pResRoot);
        str.LoadString(g_hInstance, IDS_PRINT_DMASUM);
        PrintLine(str);
        Indent();
        PrintResourceSubtree(pResRoot);
        UnIndent();
        LineFeed();
    }

    //
    // print MEM summary heading
    //
    str.LoadString(g_hInstance, IDS_PRINT_HEADING_MEMSUMMARY);
    wsprintf(Temp, (LPCTSTR)strBanner, (LPCTSTR)str);
    PrintLine(Temp);
    LineFeed();
    CResourceList MemSummary(&Machine, ResType_Mem);
    
    if (MemSummary.GetCount()) {

        CResource* pResRoot;
        MemSummary.CreateResourceTree(&pResRoot);
        str.LoadString(g_hInstance, IDS_PRINT_MEMSUM);
        PrintLine(str);
        Indent();
        PrintResourceSubtree(pResRoot);
        UnIndent();
        LineFeed();
    }

    //
    // print IO summary heading
    //
    str.LoadString(g_hInstance, IDS_PRINT_HEADING_IOSUMMARY);
    wsprintf(Temp, (LPCTSTR)strBanner, (LPCTSTR)str);
    PrintLine(Temp);
    LineFeed();
    CResourceList IoSummary(&Machine, ResType_IO);
    
    if (IoSummary.GetCount()) {

        CResource* pResRoot;
        IoSummary.CreateResourceTree(&pResRoot);
        str.LoadString(g_hInstance, IDS_PRINT_IOSUM);
        PrintLine(str);
        Indent();
        PrintResourceSubtree(pResRoot);
        UnIndent();
        LineFeed();
    }

    return 1;
}

int
CPrinter::PrintResourceSubtree(
    CResource* pResRoot
    )
{
    while (pResRoot)
    {
        DWORD Status, Problem;
        
        if (pResRoot->m_pDevice->GetStatus(&Status, &Problem) && Problem ||
            pResRoot->m_pDevice->IsDisabled()) {

            TCHAR Temp[MAX_PATH];
            Temp[0] = _T('*');
            lstrcpy(&Temp[1], pResRoot->GetViewName());
            PrintLine(Temp);
        
        } else {

            PrintLine(pResRoot->GetViewName());
        }

        if (pResRoot->GetChild()) {

            if ((ResType_IO == pResRoot->ResType()) ||
                (ResType_Mem == pResRoot->ResType())) {
            
                Indent();
            }

            PrintResourceSubtree(pResRoot->GetChild());
            
            if ((ResType_IO == pResRoot->ResType()) ||
                (ResType_Mem == pResRoot->ResType())) {
            
                UnIndent();
            }
        }

        pResRoot = pResRoot->GetSibling();
    }

    return 1;
}

int
CPrinter::PrintAllClassAndDevice(
    CMachine* pMachine
    )
{

    if (!pMachine) {
    
        return 0;
    }
    
    String strHeading;
    String strBanner;
    TCHAR       Temp[MAX_PATH];
    strHeading.LoadString(g_hInstance, IDS_PRINT_HEADING_SYSDEVINFO);
    strBanner.LoadString(g_hInstance, IDS_PRINT_BANNER);
    wsprintf(Temp, (LPCTSTR)strBanner, (LPCTSTR)strHeading);
    PrintLine(Temp);
    LineFeed();

    CClass* pClass;
    PVOID Context;
    
    if (pMachine->GetFirstClass(&pClass, Context)) {

        do {

            PrintClass(pClass, FALSE);

        } while (pMachine->GetNextClass(&pClass, Context));
    }

    return 1;
}

int
CPrinter::PrintClass(
    CClass* pClass,
    BOOL PrintBanner
    )
{
    PVOID Context;
    CDevice* pDevice;

    if (!pClass) {
    
        return 0;
    }

    if (PrintBanner) {

        String strHeading;
        String strBanner;
        TCHAR  Temp[MAX_PATH];
        strHeading.LoadString(g_hInstance, IDS_PRINT_HEADING_SYSDEVCLASS);
        strBanner.LoadString(g_hInstance, IDS_PRINT_BANNER);
        wsprintf(Temp, (LPCTSTR)strBanner, (LPCTSTR)strHeading);
        PrintLine(Temp);
        LineFeed();
    }
    
    if (pClass && pClass->GetFirstDevice(&pDevice, Context)) {

        do {

            //
            // Do print banner on the device
            //
            PrintDevice(pDevice, FALSE);

        } while (pClass->GetNextDevice(&pDevice, Context));
    }
    
    return 1;
}

int
CPrinter::PrintDevice(
    CDevice* pDevice,
    BOOL PrintBanner
    )
{

    if (!pDevice) {
    
        return 0;
    }
    
    String str;
    TCHAR Temp[MAX_PATH];

    if (PrintBanner) {

        String strBanner;
        str.LoadString(g_hInstance, IDS_PRINT_HEADING_SYSDEVICE);
        strBanner.LoadString(g_hInstance, IDS_PRINT_BANNER);
        wsprintf(Temp, (LPCTSTR)strBanner, (LPCTSTR)str);
        PrintLine(Temp);
        LineFeed();
    }
    
    DWORD Status, Problem;
    
    if (pDevice->GetStatus(&Status, &Problem) && Problem ||
        pDevice->IsDisabled()) {

        LoadString(g_hInstance, IDS_PRINT_DEVICE_DISABLED, Temp, ARRAYLEN(Temp));
        PrintLine(Temp);
    }
    
    str.LoadString(g_hInstance, IDS_PRINT_CLASS);
    wsprintf(Temp, (LPCTSTR)str, pDevice->GetClassDisplayName());
    PrintLine(Temp);
    str.LoadString(g_hInstance, IDS_PRINT_DEVICE);
    wsprintf(Temp, (LPCTSTR)str, pDevice->GetDisplayName());
    PrintLine(Temp);
    PrintDeviceResource(pDevice);
    PrintDeviceDriver(pDevice);
    return 1;
}

int
CPrinter::PrintAll(
    CMachine& Machine
    )
{
    PrintResourceSummary(Machine);
    PrintAllClassAndDevice(&Machine);
    return 1;
}

//
// This function prints the given device's resource summary
//
int
CPrinter::PrintDeviceResource(
    CDevice* pDevice
    )
{

    if (!pDevice) {
    
        return 0;
    }

    CResourceList IrqSummary(pDevice, ResType_IRQ);
    CResourceList DmaSummary(pDevice, ResType_DMA);
    CResourceList MemSummary(pDevice, ResType_Mem);
    CResourceList IoSummary(pDevice, ResType_IO);

    String str;
    TCHAR Temp[MAX_PATH];

    //
    // If the device has any kind of resources, print it
    //
    if (IrqSummary.GetCount() || DmaSummary.GetCount() ||
        MemSummary.GetCount() || IoSummary.GetCount()) {

        str.LoadString(g_hInstance, IDS_PRINT_RESOURCE);
        PrintLine(str);
        
        //
        // Start printing individual resources
        //
        Indent();
        PVOID Context;
        CResource* pResource;
        DWORDLONG dlBase, dlLen;
        TCHAR Format[MAX_PATH];
        
        if (IrqSummary.GetFirst(&pResource, Context)) {

            LoadString(g_hInstance, IDS_PRINT_IRQ_FORMAT, Temp, ARRAYLEN(Temp));
            
            do {

                pResource->GetValue(&dlBase, &dlLen);
                str.Format(Temp, (ULONG)dlBase);
                PrintLine((LPCTSTR)str);

            } while (IrqSummary.GetNext(&pResource, Context));
        }

        if (DmaSummary.GetFirst(&pResource, Context)) {

            LoadString(g_hInstance, IDS_PRINT_DMA_FORMAT, Temp, ARRAYLEN(Temp));
            
            do {

                pResource->GetValue(&dlBase, &dlLen);
                str.Format(Temp, (ULONG)dlBase);
                PrintLine((LPCTSTR)str);

            } while (DmaSummary.GetNext(&pResource, Context));
        }

        if (MemSummary.GetFirst(&pResource, Context)) {

            LoadString(g_hInstance, IDS_PRINT_MEM_FORMAT, Temp, ARRAYLEN(Temp));
            
            do {

                pResource->GetValue(&dlBase, &dlLen);
                str.Format(Temp, (ULONG)dlBase, (ULONG)(dlBase + dlLen - 1));
                PrintLine((LPCTSTR)str);

            } while (MemSummary.GetNext(&pResource, Context));
        }

        if (IoSummary.GetFirst(&pResource, Context)) {

            LoadString(g_hInstance, IDS_PRINT_IO_FORMAT, Temp, ARRAYLEN(Temp));
            
            do {

                pResource->GetValue(&dlBase, &dlLen);
                str.Format(Temp, (ULONG)dlBase, (ULONG)(dlBase + dlLen -1));
                PrintLine((LPCTSTR)str);

            } while (IoSummary.GetNext(&pResource, Context));
        }

        UnIndent();
    
    } else {
        str.LoadString(g_hInstance, IDS_PRINT_NORES);
        PrintLine(str);
    }

    return 1;
}


//
// This function prints the given device's driver information
// INPUT:
//      pDevice  -- the device
// OUTPUT:
//      >0 if the function succeeded.
//      0 if the function failed.
//
int
CPrinter::PrintDeviceDriver(
    CDevice* pDevice
    )
{
    if (!pDevice) {
    
        return 0;
    }

    String str;
    TCHAR Temp[MAX_PATH];

    CDriver* pDriver;
    pDriver = pDevice->CreateDriver();
    SafePtr<CDriver> DrvPtr;
    
    if (pDriver) {

        DrvPtr.Attach(pDriver);
        str.LoadString(g_hInstance, IDS_PRINT_DRVINFO);
        PrintLine(str);
        PVOID Context;
        CDriverFile* pDrvFile;
        Indent();
        
        if (pDriver->GetFirstDriverFile(&pDrvFile, Context)) {

            do {

                PrintLine(pDrvFile->GetFullPathName());
                HANDLE hFile;
                Indent();
                hFile = CreateFile(pDrvFile->GetFullPathName(),
                                   GENERIC_READ,
                                   0,
                                   NULL,
                                   OPEN_EXISTING,
                                   FILE_ATTRIBUTE_NORMAL |
                                   FILE_ATTRIBUTE_READONLY |
                                   FILE_ATTRIBUTE_SYSTEM |
                                   FILE_ATTRIBUTE_HIDDEN,
                                   NULL
                                   );
                
                if (INVALID_HANDLE_VALUE != hFile) {

                    DWORD FileSize;
                    FileSize = ::GetFileSize(hFile, NULL);
                    CloseHandle(hFile);
                    LoadString(g_hInstance, IDS_PRINT_FILESIZE, Temp, ARRAYLEN(Temp));
                    str.Format(Temp, FileSize);
                    PrintLine(str);
                    // print the driver version infomation
                    TCHAR Unknown[MAX_PATH];
                    LoadString(g_hInstance, IDS_PRINT_UNKNOWN, Unknown, ARRAYLEN(Unknown));
                    
                    if (pDrvFile->HasVersionInfo()) {

                        LoadString(g_hInstance, IDS_PRINT_FILEVERSION, Temp, ARRAYLEN(Temp));
                        
                        if (pDrvFile->GetVersion()) {

                            str.Format(Temp, pDrvFile->GetVersion());
                        
                        } else {

                            str.Format(Temp, Unknown);
                        }
                        
                        PrintLine(str);

                        LoadString(g_hInstance, IDS_PRINT_FILEMFG, Temp, ARRAYLEN(Temp));
                        
                        if (pDrvFile->GetProvider()) {

                            str.Format(Temp, pDrvFile->GetProvider());
                        
                        } else {

                            str.Format(Temp, Unknown);
                        }
                        
                        PrintLine(str);

                        LoadString(g_hInstance, IDS_PRINT_FILECOPYRIGHT, Temp, ARRAYLEN(Temp));
                        
                        if (pDrvFile->GetCopyright()) {

                            str.Format(Temp, pDrvFile->GetCopyright());
                        
                        } else {

                            str.Format(Temp, Unknown);
                        }
                        
                        PrintLine(str);
                    
                    } else {

                        str.LoadString(g_hInstance, IDS_PRINT_NOVERSION);
                        PrintLine(str);
                    }
                
                } else {

                    str.LoadString(g_hInstance, IDS_PRINT_DRVMISSING);
                    PrintLine(str);
                }
                
                UnIndent();

            } while (pDriver->GetNextDriverFile(&pDrvFile, Context));
        }

        UnIndent();
    }

    LineFeed();
    
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\prndlg.cpp ===
#include "devmgr.h"


/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    prndlg.cpp

Abstract:

    This module implements CPrintDialog, the class that processes
    printer dialog

Author:

    William Hsieh (williamh) created

Revision History:


--*/


//
// CPrintDialog implementation
//


//
// help topic ids
//

const DWORD g_a207HelpIDs[]=
{
    IDC_PRINT_SYSTEM_SUMMARY,   idh_devmgr_print_system,
    IDC_PRINT_SELECT_CLASSDEVICE,   idh_devmgr_print_device,
    IDC_PRINT_ALL,          idh_devmgr_print_both,
    IDC_PRINT_REPORT_TYPE_TEXT, idh_devmgr_print_report,
    0, 0
};

HRESULT
CDevMgrPrintDialogCallback::QueryInterface(
    REFIID  riid,
    void**  ppv
    )
{
    if (!ppv) {
    
        return E_INVALIDARG;
    }
    
    HRESULT hr = S_OK;


    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown*)this;
    }
    
    else if (IsEqualIID(riid, IID_IPrintDialogCallback))
    {
        *ppv = (ISnapinAbout*)this;
    }
    
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }
    
    if (SUCCEEDED(hr))
    {
        AddRef();
    }

    return hr;
}

ULONG
CDevMgrPrintDialogCallback::AddRef()
{
    ::InterlockedIncrement((LONG*)&m_Ref);
    
    return m_Ref;
}

ULONG
CDevMgrPrintDialogCallback::Release()
{
    ::InterlockedDecrement((LONG*)&m_Ref);
    
    if (!m_Ref)
    {
        delete this;
        return 0;
    }

    return m_Ref;
}

HRESULT
CDevMgrPrintDialogCallback::InitDone()
{
    return S_OK;
}

HRESULT
CDevMgrPrintDialogCallback::SelectionChange()
{
    return S_OK;
}

HRESULT
CDevMgrPrintDialogCallback::HandleMessage(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam, 
    LRESULT *pResult
    )
{
    *pResult = FALSE;
    
    switch (uMsg) {
    
    case WM_INITDIALOG:
        *pResult = OnInitDialog(hDlg);
        break;

    case WM_COMMAND:
        *pResult = OnCommand(hDlg, wParam, lParam);
        break;

    case WM_HELP:
        *pResult = OnHelp((LPHELPINFO)lParam);
        break;

    case WM_CONTEXTMENU:
        *pResult = OnContextMenu(hDlg, LOWORD(lParam), HIWORD(lParam), wParam);
        break;

    default:
        break;
    }
    
    return S_OK;
}

BOOL
CDevMgrPrintDialogCallback::OnInitDialog(
    HWND hWnd
    )
{
    
    int DefaultId = IDC_PRINT_SELECT_CLASSDEVICE;
    
    m_pPrintDialog->SetReportType(REPORT_TYPE_CLASSDEVICE);

    if (!(m_pPrintDialog->GetTypeEnableMask() & REPORT_TYPE_MASK_CLASSDEVICE))
    {
        EnableWindow(GetDlgItem(hWnd, IDC_PRINT_SELECT_CLASSDEVICE), FALSE);
        DefaultId =  IDC_PRINT_SYSTEM_SUMMARY;
        m_pPrintDialog->SetReportType(REPORT_TYPE_SUMMARY);
    }
    
    if (!(m_pPrintDialog->GetTypeEnableMask() & REPORT_TYPE_MASK_SUMMARY))
    {
        EnableWindow(GetDlgItem(hWnd, IDC_PRINT_SYSTEM_SUMMARY), FALSE);
        
        if (IDC_PRINT_SYSTEM_SUMMARY == DefaultId)
        {
            DefaultId = IDC_PRINT_ALL;
            m_pPrintDialog->SetReportType(REPORT_TYPE_SUMMARY_CLASSDEVICE);
        }
    }

    if (!(m_pPrintDialog->GetTypeEnableMask() & REPORT_TYPE_MASK_SUMMARY_CLASSDEVICE))
    {
        EnableWindow(GetDlgItem(hWnd, IDC_PRINT_ALL), FALSE);
    }

    CheckDlgButton(hWnd, DefaultId, BST_CHECKED);
    
    return TRUE;
}

UINT_PTR
CDevMgrPrintDialogCallback::OnCommand(
    HWND hWnd,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (BST_CHECKED == IsDlgButtonChecked(hWnd, IDC_PRINT_SELECT_CLASSDEVICE))
    {
        m_pPrintDialog->SetReportType(REPORT_TYPE_CLASSDEVICE);
    }

    else if (BST_CHECKED == IsDlgButtonChecked(hWnd, IDC_PRINT_SYSTEM_SUMMARY))
    {
        m_pPrintDialog->SetReportType(REPORT_TYPE_SUMMARY);
    }
    
    else if (BST_CHECKED == IsDlgButtonChecked(hWnd, IDC_PRINT_ALL))
    {
        m_pPrintDialog->SetReportType(REPORT_TYPE_SUMMARY_CLASSDEVICE);
    }

    return FALSE;
}

BOOL
CDevMgrPrintDialogCallback::OnHelp(
    LPHELPINFO pHelpInfo
    )
{
    int id = GetDlgCtrlID((HWND)pHelpInfo->hItemHandle);

    //
    // We only want to intercept help messages for controls that we are
    // responsible for.
    //
    if ((IDC_PRINT_SYSTEM_SUMMARY == id) ||
        (IDC_PRINT_SELECT_CLASSDEVICE == id) ||
        (IDC_PRINT_ALL == id) ||
        (IDC_PRINT_REPORT_TYPE_TEXT == id)) {

        WinHelp((HWND)pHelpInfo->hItemHandle, DEVMGR_HELP_FILE_NAME, HELP_WM_HELP,
                (ULONG_PTR)g_a207HelpIDs);

        return TRUE;
    }

    //
    // If it is not one of the above controls then just let the normal help handle
    // the message.  We do this by returning FALSE
    //
    return FALSE;
}

BOOL
CDevMgrPrintDialogCallback::OnContextMenu(
    HWND hWnd,
    WORD xPos,
    WORD yPos,
    WPARAM wParam
    )
{
    POINT pt;

    if (hWnd == (HWND)wParam) {
    
        GetCursorPos(&pt);
        ScreenToClient(hWnd, &pt);
        wParam = (WPARAM)ChildWindowFromPoint(hWnd, pt);
    }

    int id = GetDlgCtrlID((HWND)wParam);

    //
    // We only want to intercept help messages for controls that we are
    // responsible for.
    //
    if ((IDC_PRINT_SYSTEM_SUMMARY == id) ||
        (IDC_PRINT_SELECT_CLASSDEVICE == id) ||
        (IDC_PRINT_ALL == id) ||
        (IDC_PRINT_REPORT_TYPE_TEXT == id)) {
    
        WinHelp((HWND)wParam, DEVMGR_HELP_FILE_NAME, HELP_CONTEXTMENU,
                (ULONG_PTR)g_a207HelpIDs);

        return TRUE;
    }

    return FALSE;
}

BOOL
CPrintDialog::PrintDlg(
    HWND hwndOwner,
    DWORD TypeEnableMask
    )
{
    HRESULT hr;

    ASSERT(REPORT_TYPE_MASK_NONE != TypeEnableMask);

    memset(&m_PrintDlg, 0, sizeof(m_PrintDlg));

    CDevMgrPrintDialogCallback* pPrintDialogCallback = new CDevMgrPrintDialogCallback;

    if (!pPrintDialogCallback) {

        return FALSE;
    }

    pPrintDialogCallback->m_pPrintDialog = this;
    
    m_TypeEnableMask = TypeEnableMask;

    m_PrintDlg.lStructSize = sizeof(m_PrintDlg);
    m_PrintDlg.hwndOwner = hwndOwner;
    m_PrintDlg.hDC = NULL;
    m_PrintDlg.Flags = PD_ENABLEPRINTTEMPLATE | PD_RETURNDC | PD_NOPAGENUMS;
    m_PrintDlg.Flags2 = 0;
    m_PrintDlg.ExclusionFlags = 0;
    m_PrintDlg.hInstance = g_hInstance;
    m_PrintDlg.nCopies = 1;
    m_PrintDlg.nStartPage = START_PAGE_GENERAL;
    m_PrintDlg.lpCallback = (IUnknown*)pPrintDialogCallback;
    m_PrintDlg.lpPrintTemplateName = MAKEINTRESOURCE(IDD_PRINT);
    
    if (FAILED(hr = PrintDlgEx(&m_PrintDlg))) {
        
        return FALSE;
    }

    //
    // If the user did not want to print then return FALSE.
    // This can happen if the user hits Cancel on the print dialog.
    //
    if (m_PrintDlg.dwResultAction != PD_RESULT_PRINT) {

        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\prndlg.h ===
#ifndef __PRNDLG_H_
#define __PRNDLG_H_

/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    prndlg.h

Abstract:

    header file for prndlg.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/

//
// help topic ids
//
#define idh_devmgr_print_system         207325
#define idh_devmgr_print_device         207326
#define idh_devmgr_print_both           207265
#define idh_devmgr_print_report         207324

//
// Report type mask
//
#define REPORT_TYPE_MASK_NONE                           0x00
#define REPORT_TYPE_MASK_SUMMARY                        0x01
#define REPORT_TYPE_MASK_CLASSDEVICE                    0x02
#define REPORT_TYPE_MASK_SUMMARY_CLASSDEVICE            0x04
#define REPORT_TYPE_MASK_ALL                            0x07

typedef enum tagReportType
{
    REPORT_TYPE_SUMMARY = 0,
    REPORT_TYPE_CLASSDEVICE,
    REPORT_TYPE_SUMMARY_CLASSDEVICE,
    REPORT_TYPE_UNKNOWN
} REPORT_TYPE, *PREPORT_TYPE;

class CPrintDialog
{
public:
    CPrintDialog()
        : m_hDlg(NULL), m_ReportType(REPORT_TYPE_UNKNOWN)
        {
            memset(&m_PrintDlg, 0, sizeof(m_PrintDlg));
        }
    ~CPrintDialog()
        {
            if (m_PrintDlg.hDevNames)
                GlobalFree(m_PrintDlg.hDevNames);
            if (m_PrintDlg.hDevMode)
                GlobalFree(m_PrintDlg.hDevMode);
        }
    BOOL PrintDlg(HWND hwndOwner, DWORD TypeEnableMask);

    HDC HDC()
        {
            return m_PrintDlg.hDC;
        }
    REPORT_TYPE ReportType()
        {
            return m_ReportType;
        }
    void SetReportType(REPORT_TYPE ReportType)
        {
            m_ReportType = ReportType;
        }
    DWORD GetTypeEnableMask()
        {
            return m_TypeEnableMask;
        }
    
    HWND    m_hDlg;
    PRINTDLGEX  m_PrintDlg;

private:
    DWORD       m_TypeEnableMask;
    REPORT_TYPE m_ReportType;
};


class CDevMgrPrintDialogCallback : public IPrintDialogCallback
{
public:
    CDevMgrPrintDialogCallback() :m_Ref(0), m_pPrintDialog(NULL)
    {}

    // IUNKNOWN interface
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);
    
    // IPrintDialogCallback interface
    STDMETHOD(InitDone) (THIS);
    STDMETHOD(SelectionChange) (THIS);
    STDMETHOD(HandleMessage) (THIS_ HWND hDlg, UINT uMsg, WPARAM wParam, 
        LPARAM lParam, LRESULT *pResult);

    CPrintDialog *m_pPrintDialog;

private:
    BOOL OnInitDialog(HWND hWnd);
    UINT_PTR OnCommand(HWND hWnd, WPARAM wParam, LPARAM lParam);
    BOOL OnHelp(LPHELPINFO pHelpInfo);
    BOOL OnContextMenu(HWND hWnd, WORD xPos, WORD yPos, WPARAM wParam);
    
    ULONG m_Ref;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\proppage.h ===
#ifndef _PROPPAGE_H_
#define _PROPPAGE_H_
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    proppage.h

Abstract:

    header file for proppage.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/


class CPropSheetPage
{
public:
    CPropSheetPage(HINSTANCE hInst, UINT idTemplate);
    virtual ~CPropSheetPage()
    {}
    static INT_PTR CALLBACK PageDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static UINT CALLBACK PageCallback(HWND hDlg, UINT uMsg, LPPROPSHEETPAGE ppsp);
protected:
    HWND    GetControl(int ControlId)
    {
        ASSERT(m_hDlg);
        return GetDlgItem(m_hDlg, ControlId);
    }

    virtual BOOL OnInitDialog(LPPROPSHEETPAGE ppsp)
    {
        return TRUE;
    }

    virtual void UpdateControls(LPARAM lParam = 0)
    {

    }
    virtual BOOL OnApply()
    {
        ASSERT(m_hDlg);
        SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, 0L);
        return FALSE;
    }
    virtual BOOL OnLastChanceApply()
    {
        ASSERT(m_hDlg);
        return FALSE;
    }
    virtual BOOL OnWizFinish()
    {
        ASSERT(m_hDlg);
        SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, 0L);
        return FALSE;
    }
    virtual BOOL OnWizNext()
    {
        ASSERT(m_hDlg);
        SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, -1L);
        return FALSE;
    }
    virtual BOOL OnWizBack()
    {
        ASSERT(m_hDlg);
        SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, -1L);
        return FALSE;
    }
    virtual BOOL OnSetActive()
    {
        ASSERT(m_hDlg);
        m_Active = TRUE;
        if (m_AlwaysUpdateOnActive || m_UpdateControlsPending)
        {
            UpdateControls();
            m_UpdateControlsPending = FALSE;
        }
        SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, 0L);
        return FALSE;
    }
    virtual BOOL OnKillActive()
    {
        ASSERT(m_hDlg);
        m_Active = FALSE;
        SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, 0L);
        return FALSE;
    }
    virtual BOOL OnReset()
    {
        ASSERT(m_hDlg);
        SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, 0L);
        return FALSE;
    }
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam)
    {
        return FALSE;
    }
    virtual BOOL OnQuerySiblings(WPARAM wParam, LPARAM lParam);
    virtual BOOL OnNotify(LPNMHDR pnmhdr)
    {
        ASSERT(m_hDlg);
        SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, 0L);
        return FALSE;
    }
    virtual BOOL OnDestroy();
    virtual BOOL OnHelp(LPHELPINFO pHelpInfo)
    {
        return FALSE;
    }

    virtual BOOL OnContextMenu(HWND hWnd, WORD xPos, WORD yPos)
    {
        return FALSE;
    }

    virtual UINT CreateCallback()
    {
        return TRUE;
    }
    virtual UINT DestroyCallback();

    HPROPSHEETPAGE CreatePage()
    {
        return ::CreatePropertySheetPage(&m_psp);
    }

    HWND        m_hDlg;
    PROPSHEETPAGE   m_psp;
    BOOL        m_Active;
    BOOL        m_AlwaysUpdateOnActive;
    BOOL        m_UpdateControlsPending;
    int             m_IDCicon;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by devmgr.rc
//


#include <dlgs.h>

#define IDC_STATIC                     -1


#define IDS_NAME_DEVMGR                 4
#define IDS_DESC_DEVMGR                 5
#define IDS_NAME_CLASS                  6
#define IDS_NAME_DEVICE                 8
#define IDS_NAME_COMPUTER               10
#define IDS_INVALID_COMPUTER_NAME       12
#define IDS_NAME_RESOURCES              13
#define IDS_NAME_IRQ                    15
#define IDS_NAME_IO                     17
#define IDS_NAME_DMA                    19
#define IDS_NAME_MEMORY                 21
#define IDS_NO_DEVICEID                 29
#define IDS_UNKNOWN_DEVICE              38
#define IDI_SIGNED                      40
#define IDI_BLANK                       41
#define IDI_DRIVERBLOCK                 42
#define IDD_GENERAL_PAGE                102
#define IDS_REMOVE                      103
#define IDM_REMOVE                      103
#define IDD_DEVGEN_PAGE                 103
#define IDS_REFRESH                     104
#define IDM_REFRESH                     104
#define IDD_DEVDRV_PAGE                 106
#define IDS_PROPERTIES                  107
#define IDM_PROPERTIES                  107
#define IDD_FIRST_PAGE                  107
#define IDD_CLSGEN_PAGE                 108
#define IDD_DEVMGR                      109
#define IDD_DRIVERFILES                 110
#define IDS_ENABLE                      111
#define IDM_ENABLE                      111
#define IDS_DISABLE                     112
#define IDM_DISABLE                     112
#define IDS_UPDATEDRIVER                113
#define IDM_UPDATEDRIVER                113
#define IDC_REMOVEDEV_ICON              115
#define IDC_REMOVEDEV_DEVDESC           116
#define IDC_REMOVEDEV_WARNING           117
#define IDM_VIEW_DEVICESBYTYPE          158
#define IDM_VIEW_DEVICESBYCONNECTION    159
#define IDM_VIEW_RESOURCESBYTYPE        160
#define IDM_VIEW_RESOURCESBYCONNECTION  161
#define IDM_VIEW_RESOURCES              162
#define IDM_VIEW_RESOURCE_IRQ           163
#define IDM_VIEW_RESOURCE_DMA           164
#define IDM_VIEW_RESOURCE_IO            165
#define IDM_VIEW_RESOURCE_MEM           166
#define IDM_SHOW_ALL                    176
#define IDI_DEVMGR                      201
#define IDC_GENERAL_LOCALMACHINE        201
#define IDI_RESOURCES                   202
#define IDC_GENERAL_OTHERMACHINE        202
#define IDC_GENERAL_MACHINENAME         203
#define IDC_GENERAL_BROWSE_MACHINENAMES 205
#define IDD_PRINT                       207
#define IDC_GENERAL_OVERRIDE_MACHINENAME 208
#define IDD_REMOVE_DEVICE               210
#define IDB_WATERMARK                   214
#define IDB_BANNER                      215
#define IDC_DEVGEN_ICON                 218
#define IDC_DEVGEN_DESC                 219
#define IDC_DEVGEN_TYPE                 220
#define IDC_DEVGEN_MFG                  221
#define IDC_DEVGEN_STATUS               223
#define IDC_DEVGEN_DISABLE              224
#define IDC_DEVGEN_PROFILELIST          225
#define IDC_DEVDRV_ICON                 226
#define IDC_DEVDRV_DESC                 227
#define IDC_DRIVERFILES_FILELIST        228
#define IDC_DRIVERFILES_PROVIDER        229
#define IDC_DRIVERFILES_VERSION         230
#define IDC_DRIVERFILES_COPYRIGHT       231
#define IDC_DRIVERFILES_DIGITALSIGNER   232
#define IDC_CLSGEN_ICON                 243
#define IDC_CLSGEN_NAME                 244
#define IDC_CLSGEN_DESC                 245
#define IDC_DEVGEN_USAGETEXT            246
#define IDS_DRIVERFILES_BLOCKDRIVERLINK 247
#define IDC_PRINT_ALL                   265
#define IDC_DRIVERFILES_ICON            303
#define IDC_DRIVERFILES_DESC            304
#define IDC_DRIVERFILES_FILES           305
#define IDC_DRIVERFILES_TITLE_PROVIDER  306
#define IDC_DRIVERFILES_TITLE_VERSION   307
#define IDC_DRIVERFILES_TITLE_COPYRIGHT 308
#define IDC_DEVGEN_TROUBLESHOOTING      309
#define IDC_DRIVERFILES_TITLE_DIGITALSIGNER 310
#define IDC_PRINT_REPORT_TYPE_TEXT      324
#define IDC_PRINT_SYSTEM_SUMMARY        325
#define IDC_PRINT_SELECT_CLASSDEVICE    326
#define IDD_PRINT_CANCEL                327
#define IDD_SCAN_PNP_HARDWARES          328
#define IDD_DEVPOWER_PAGE               330
#define IDC_DEVPOWER_ICON               331
#define IDC_DEVPOWER_DESC               332
#define IDC_DEVPOWER_WAKEENABLE         333
#define IDC_DEVPOWER_CON_EDIT           334
#define IDC_DEVPOWER_CON_SPIN           335
#define IDC_DEVPOWER_PER_EDIT           336
#define IDC_DEVPOWER_PER_SPIN           337
#define IDC_DEVPOWER_DEVICEENABLE       338
#define IDC_DEVPOWER_CON_TEXT           339
#define IDC_DEVPOWER_PER_TEXT           340
#define IDC_DEVPOWER_IDLE_TEXT          341
#define IDC_DEVPOWER_IDLE_GROUP         342
#define IDC_DEVPOWER_MESSAGE            343
#define IDB_SYSDM16                     347
#define IDB_SYSDM32                     348
#define IDC_DEVGEN_TITLE_TYPE           349
#define IDC_DEVGEN_TITLE_MFG            350
#define IDC_DEVGEN_STATUSGROUP          352
#define IDC_GENERAL_SELECT_TEXT         353
#define IDC_GENERAL_SELECTGROUP         354
#define IDC_DEVGEN_TITLE_LOCATION       356
#define IDC_DEVGEN_LOCATION             357
#define IDB_TOOLBAR                     358
#define IDS_BUTTON_REFRESH              359
#define IDS_TOOLTIP_REFRESH             360
#define IDS_BUTTON_ENABLE               361
#define IDS_TOOLTIP_ENABLE              362
#define IDS_BUTTON_DISABLE              363
#define IDS_TOOLTIP_DISABLE             364
#define IDS_BUTTON_REMOVE               365
#define IDS_TOOLTIP_REMOVE              366
#define IDS_BUTTON_UPDATEDRIVER         367
#define IDS_TOOLTIP_UPDATEDRIVER        368
#define IDS_HTMLHELP_NAME               370
#define IDS_HTMLHELP_OVERVIEW_TOPIC     371
#define IDD_DEVDETAILS_PAGE             372
#define IDC_DEVDETAILS_ICON             373
#define IDC_DEVDETAILS_DESC             374
#define IDC_DEVDETAILS_COMBO            375
#define IDC_DEVDETAILS_LIST             376
#define IDC_DEVDETAILS_COPY             377
#define IDC_DEVDRV_CHANGEDRIVER         380
#define IDC_DEVDRV_CHANGEDRIVER_TEXT    381
#define IDC_DEVDRV_UNINSTALL            382
#define IDC_DEVDRV_UNINSTALL_TEXT       383
#define IDC_DEVDRV_TITLE_DRIVERPROVIDER 384
#define IDC_DEVDRV_DRIVERPROVIDER       385
#define IDC_DEVDRV_TITLE_DRIVERDATE     386
#define IDC_DEVDRV_DRIVERDATE           387
#define IDC_DEVDRV_TITLE_DRIVERVERSION  388
#define IDC_DEVDRV_DRIVERVERSION        389
#define IDC_DEVDRV_DETAILS              390
#define IDC_DEVDRV_DETAILS_TEXT         391
#define IDC_DEVDRV_TITLE_DRIVERSIGNER   392
#define IDC_DEVDRV_DRIVERSIGNER         393
#define IDC_DEVDRV_ROLLBACK             394
#define IDC_DEVDRV_ROLLBACK_TEXT        395
#define IDC_DEVPOWER_MGMT_WAKEENABLE    396

#define IDS_DN_ROOT_ENUMERATED          400
#define IDS_DN_DRIVER_LOADED            401
#define IDS_DN_ENUM_LOADED              402
#define IDS_DN_STARTED                  403
#define IDS_DN_MANUAL                   404
#define IDS_DN_NEED_TO_ENUM             405
#define IDS_DN_DRIVER_BLOCKED           406
#define IDS_DN_HARDWARE_ENUM            407
#define IDS_DN_NEED_RESTART             408
#define IDS_DN_HAS_MARK                 409
#define IDS_DN_HAS_PROBLEM              410
#define IDS_DN_FILTERED                 411
#define IDS_DN_MOVED                    412
#define IDS_DN_DISABLEABLE              413
#define IDS_DN_REMOVABLE                414
#define IDS_DN_PRIVATE_PROBLEM          415
#define IDS_DN_MF_PARENT                416
#define IDS_DN_MF_CHILD                 417
#define IDS_DN_WILL_BE_REMOVED          418
#define IDS_DN_NOT_FIRST_TIMEE          419
#define IDS_DN_STOP_FREE_RES            420
#define IDS_DN_REBAL_CANDIDATE          421
#define IDS_DN_BAD_PARTIAL              422
#define IDS_DN_NT_ENUMERATOR            423
#define IDS_DN_NT_DRIVER                424
#define IDS_DN_NEEDS_LOCKING            425
#define IDS_DN_ARM_WAKEUP               426
#define IDS_DN_APM_ENUMERATOR           427
#define IDS_DN_APM_DRIVER               428
#define IDS_DN_SILTEN_INSTALL           429
#define IDS_DN_NO_SHOW_IN_DM            430
#define IDS_DN_BOOT_LOG_PROB            431

#define IDS_CM_DEVCAP_LOCKSUPPORTED     440
#define IDS_CM_DEVCAP_EJECTSUPPORTED    441
#define IDS_CM_DEVCAP_REMOVALBE         442
#define IDS_CM_DEVCAP_DOCKDEVICE        443
#define IDS_CM_DEVCAP_UNIQUEID          444
#define IDS_CM_DEVCAP_SILENTINSTALL     445
#define IDS_CM_DEVCAP_RAWDEVICEOK       446
#define IDS_CM_DEVCAP_SURPRISEREMOVEALOK 447
#define IDS_CM_DEVCAP_HARDWAREDISABLED  448
#define IDS_CM_DEVCAP_NONDYNAMIC        449

#define IDS_CONFIGFLAG_DISABLED         460
#define IDS_CONFIGFLAG_REMOVED          461
#define IDS_CONFIGFLAG_MANUAL_INSTALL   462
#define IDS_CONFIGFLAG_IGNORE_BOOT_LC   463
#define IDS_CONFIGFLAG_NET_BOOT         464
#define IDS_CONFIGFLAG_REINSTALL        465
#define IDS_CONFIGFLAG_FAILEDINSTALL    466
#define IDS_CONFIGFLAG_CANTSTOPACHILD   467
#define IDS_CONFIGFLAG_OKREMOVEROM      468
#define IDS_CONFIGFLAG_NOREMOVEEXIT     469
#define IDS_CONFIGFLAG_FINISH_INSTALL   470
#define IDS_CONFIGFLAG_NEEDS_FORCED_CONFIG 471
#define IDS_CONFIGFLAG_NETBOOT_CARD     472
#define IDS_CONFIGFLAG_PARTIAL_LOG_CONF 473
    
#define IDS_CSCONFIGFLAG_DISABLED       474
#define IDS_CSCONFIGFLAG_DO_NOT_CREATE  475
#define IDS_CSCONFIGFLAG_DO_NOT_START   476

#define IDS_POWERSTATE_UNSPECIFIED      480
#define IDS_POWERSTATE_D0               481
#define IDS_POWERSTATE_D1               482
#define IDS_POWERSTATE_D2               483
#define IDS_POWERSTATE_D3               484

#define IDS_PDCAP_D0_SUPPORTED           490
#define IDS_PDCAP_D1_SUPPORTED           491
#define IDS_PDCAP_D2_SUPPORTED           492
#define IDS_PDCAP_D3_SUPPORTED           493
#define IDS_PDCAP_WAKE_FROM_D0_SUPPORTED 494
#define IDS_PDCAP_WAKE_FROM_D1_SUPPORTED 495
#define IDS_PDCAP_WAKE_FROM_D2_SUPPORTED 496
#define IDS_PDCAP_WAKE_FROM_D3_SUPPORTED 497
#define IDS_PDCAP_WARM_EJECT_SUPPORTED   498
        
#define IDS_DETAILS_DEVICEINSTANCEID    500
#define IDS_DETAILS_HARDWAREIDS         501
#define IDS_DETAILS_COMPATIDS           502
#define IDS_DETAILS_MATCHINGID          503
#define IDS_DETAILS_SERVICE             504
#define IDS_DETAILS_ENUMERATOR          505
#define IDS_DETAILS_CAPABILITIES        506
#define IDS_DETAILS_DEVNODE_FLAGS       507
#define IDS_DETAILS_CONFIGFLAGS         508
#define IDS_DETAILS_CSCONFIGFLAGS       509
#define IDS_DETAILS_EJECTIONRELATIONS   510
#define IDS_DETAILS_REMOVALRELATIONS    511
#define IDS_DETAILS_BUSRELATIONS        512
#define IDS_DETAILS_DEVICEUPPERFILTERS  513
#define IDS_DETAILS_DEVICELOWERFILTERS  514
#define IDS_DETAILS_CLASSUPPERFILTERS   515
#define IDS_DETAILS_CLASSLOWERFILTERS   516
#define IDS_DETAILS_CLASSINSTALLER      517
#define IDS_DETAILS_CLASSCOINSTALLERS   518
#define IDS_DETAILS_DEVICECOINSTALLERS  519
#define IDS_DETAILS_FIRMWAREREVISION    520
#define IDS_DETAILS_CURRENTPOWERSTATE   521
#define IDS_DETAILS_POWERCAPABILITIES   522
#define IDS_DETAILS_POWERSTATEMAPPINGS  523

#define IDS_UNKNOWN                     941
#define IDS_NOT_PRESENT                 945
#define IDS_NOT_AVAILABLE               946
#define IDS_REMOVEDEV_WARN              952
#define IDS_VIEW_DEVICESBYTYPE          959
#define IDS_VIEW_DEVICESBYCONNECTION    960
#define IDS_VIEW_RESOURCESBYTYPE        961
#define IDS_VIEW_RESOURCESBYCONNECTION  962
#define IDS_VIEW_RESOURCE_IRQ           969
#define IDS_VIEW_RESOURCE_DMA           970
#define IDS_VIEW_RESOURCE_IO            971
#define IDS_VIEW_RESOURCE_MEM           972
#define IDS_EXTENSION_DESC              981
#define IDS_REMOVEDEV_RESTART           982
#define IDS_DEVCHANGE_RESTART           983
#define IDS_POWERCYC1                   984
#define IDS_POWERCYC2                   985
#define IDS_DISPLAYNAME_SCOPE_DEVMGR    986
#define IDS_LOCAL_MACHINE               989
#define IDS_SHOW_ALL                    990
#define IDS_ERROR_NOMEMORY              991
#define IDS_NO_DIGITALSIGNATURE         992
#define IDS_PROB_NOT_CONFIGURED         1000
#define IDS_PROB_DEVLOADERFAILED        1001
#define IDS_PROB_OUT_OF_MEMORY          1002
#define IDS_PROB_WRONG_TYPE             1003
#define IDS_PROB_LACKEDARBITRATOR       1004
#define IDS_PROB_BOOT_CONFIG_CONFLICT   1005
#define IDS_PROB_FAILED_FILTER          1006
#define IDS_PROB_DEVLOADER_NOT_FOUND    1007
#define IDS_PROB_INVALID_DATA           1008
#define IDS_PROB_FAILED_START           1009
#define IDS_PROB_LIAR                   1010
#define IDS_PROB_NORMAL_CONFLICT        1011
#define IDS_PROB_NOT_VERIFIED           1012
#define IDS_PROB_NEEDRESTART            1013
#define IDS_PROB_REENUMERATION          1014
#define IDS_PROB_PARTIALCONFIG          1015
#define IDS_PROB_UNKNOWN_RESOURCE       1016
#define IDS_PROB_REINSTALL              1017
#define IDS_PROB_REGISTRY               1018
#define IDS_PROB_WILL_BE_REMOVED        1019
#define IDS_PROB_DISABLED               1020
#define IDS_DEVICE_NOT_THERE            1021
#define IDS_PROB_MOVED                  1022
#define IDS_PROB_TOO_EARLY              1023
#define IDS_PROB_NO_VALID_LOG_CONF      1024
#define IDS_PROB_FAILEDINSTALL          1025
#define IDS_PROB_HARDWAREDISABLED       1026
#define IDS_PROB_CANT_SHARE_IRQ         1027
#define IDS_PROB_SYSTEMFAILURE          1028
#define IDS_PROB_NOPROBLEM              1030
#define IDS_PROB_UNKNOWN                1031
#define IDS_PROB_UNKNOWN_WITHCODE       1032
#define IDS_PROB_CODE                   1035
#define IDS_SPECIALPROB_NODRIVERS       1037
#define IDS_SPECIALPROB_PRIVATEPROB     1038
#define IDS_SPECIALPROB_SAFEMODE        1039
#define IDS_PROPSHEET_WARNING           1040
#define IDS_GENERAL_PAGE_WARNING        1042
#define IDS_TROUBLESHOOTING_NAME        1044
#define IDS_PROB_DISABLED_SERVICE       1052
#define IDS_PROB_TRANSLATION_FAILED     1053
#define IDS_PROB_NO_SOFTCONFIG          1054
#define IDS_PROB_BIOS_TABLE             1055
#define IDS_PROB_IRQ_TRANSLATION_FAILED 1056
#define IDS_DESCENDANTS_VETO            1061
#define IDS_UNINSTALL_FAILED            1062
#define IDS_PRINT_DOC_TITLE             1063
#define IDS_PRINT_SUMMARY_PAGE_TITLE    1064
#define IDS_PRINT_CLASSDEVICE_PAGE_TITLE 1065
#define IDS_PRINT_SUMMARY_CLASSDEVICE_PAGE_TITLE 1066
#define IDS_PRINT_BANNER                1067
#define IDS_PRINT_HEADING_IRQSUMMARY    1068
#define IDS_PRINT_HEADING_IOSUMMARY     1069
#define IDS_PRINT_HEADING_DMASUMMARY    1070
#define IDS_PRINT_HEADING_MEMSUMMARY    1071
#define IDS_PRINT_HEADING_SYSDEVINFO    1072
#define IDS_PRINT_HEADING_SYSDEVCLASS   1073
#define IDS_PRINT_HEADING_SYSDEVICE     1074
#define IDS_PRINT_DEVICE_DISABLED       1075
#define IDS_PRINT_IRQ_FORMAT            1076
#define IDS_PRINT_DMA_FORMAT            1077
#define IDS_PRINT_MEM_FORMAT            1078
#define IDS_PRINT_IO_FORMAT             1079
#define IDS_PRINT_DRVINFO               1080
#define IDS_PRINT_FILESIZE              1081
#define IDS_PRINT_FILEVERSION           1082
#define IDS_PRINT_FILEMFG               1083
#define IDS_PRINT_FILECOPYRIGHT         1084
#define IDS_PRINT_DRVMISSING            1085
#define IDS_PRINT_NOVERSION             1086
#define IDS_PRINT_RESOURCE              1087
#define IDS_PRINT_NORES                 1088
#define IDS_PRINT_UNKNOWN               1089
#define IDS_PRINT_CLASS                 1090
#define IDS_PRINT_DEVICE                1091
#define IDS_PRINT_IRQSUM                1092
#define IDS_PRINT_DMASUM                1093
#define IDS_PRINT_MEMSUM                1094
#define IDS_PRINT_IOSUM                 1095
#define IDS_CPU_INTEL_386               1098
#define IDS_CPU_INTEL_486               1099
#define IDS_CPU_INTEL_PENTIUM           1100
#define IDS_CPU_ALPHA                   1101
#define IDS_CPU_REVISION_MODEL_STEPPING 1102
#define IDS_CPU_REVISION_STEPPING       1103
#define IDS_CPU_REVISION_ALPHA          1104
#define IDS_PRINT_HEADING_SYSSUMMARY    1105
#define IDS_PRINT_HEADING_DISKINFO      1106
#define IDS_PRINT_WINVER                1107
#define IDS_PRINT_COMPUTERNAME          1108
#define IDS_PRINT_PROCESSOR_TYPE        1109
#define IDS_PRINT_SYSBIOS_DATE          1111
#define IDS_PRINT_SYSBIOS_VERSION       1112
#define IDS_PRINT_MACHINE_TYPE          1113
#define IDS_PRINT_OWNER                 1114
#define IDS_PRINT_ORGANIZATION          1115
#define IDS_PRINT_PROCESSORS            1116
#define IDS_PRINT_PHY_MEMORY            1117
#define IDS_WINDOWS_NT                  1118
#define IDS_BUILD_NUMBER                1119
#define IDS_PRINT_DRIVE_LETTER          1120
#define IDS_PRINT_DRIVE_TYPE            1121
#define IDS_PRINT_TOTAL_SPACE           1122
#define IDS_PRINT_FREE_SPACE            1124
#define IDS_PRINT_CYLINDERS             1126
#define IDS_PRINT_CYLINDERS_XL          1127
#define IDS_PRINT_HEADS                 1128
#define IDS_PRINT_TRACKSIZE             1129
#define IDS_PRINT_SECTORSIZE            1130

// IDS_MEDIA_BASE - IDS_MEDIA_BASE + 200 are reserved for disk media type
//
#define IDS_MEDIA_BASE                  1131
#define IDS_MEDIA_MAX                   1330
//
// start next one with 1331
//
#define IDS_PRINT_PROCESSOR_VENDOR      1331
#define IDS_PRINT_MEMORY_UNIT           1332
#define IDS_INST_ENABLEDEVICE           1333
#define IDS_INST_RESTARTCOMPUTER        1335
#define IDS_INST_REINSTALL              1336
#define IDS_INST_TROUBLESHOOTER         1339
#define IDS_INST_WORKING_TROUBLESHOOTER 1340
#define IDS_FIXIT_ENABLEDEVICE          1342
#define IDS_FIXIT_RESTARTCOMPUTER       1344
#define IDS_FIXIT_REINSTALL             1345
#define IDS_FIXIT_TROUBLESHOOTER        1347
#define IDS_PROGRAM_PROVIDER            1353
#define IDS_PROGRAM_VERSION             1354
#define IDS_PROGRAM_ABOUT               1355
#define IDS_ABOUT_DEVMGR                1356
#define IDS_NOADMIN_WARNING             1357
#define IDS_REMOTE_WARNING1             1358
#define IDS_PROB_FAILED_ADD             1359
#define IDS_STATUS_DEVICES_BYTYPE       1362
#define IDS_STATUS_DEVICES_BYCONN       1363
#define IDS_STATUS_RESOURCES_BYTYPE     1364
#define IDS_STATUS_RESOURCES_BYCONN     1365
#define IDS_REMOTE_WARNING2             1375

#define IDS_MENU_STATUS_DEVBYTYPE       1385
#define IDS_MENU_STATUS_DEVBYCONNECTION 1386
#define IDS_MENU_STATUS_RESBYTYPE       1387
#define IDS_MENU_STATUS_RESBYCONNECTION 1388
#define IDS_MENU_STATUS_HIDDEN_DEVICES  1389
#define IDS_MENU_STATUS_SCAN_CHANGES    1390
#define IDS_MENU_STATUS_PRINT           1391
#define IDS_MENU_STATUS_REMOVE          1392
#define IDS_MENU_STATUS_PROPERTIES      1393
#define IDS_MENU_STATUS_ENABLE          1394
#define IDS_MENU_STATUS_DISABLE         1395
#define IDS_MENU_STATUS_UPDATEDRIVER    1396

#define IDS_WARN_NORMAL_DISABLE         1397
#define IDS_LOCATION                    1400
#define IDS_LOCATION_NOUINUMBER         1402
#define IDS_UI_NUMBER_DESC_FORMAT       1405
#define IDS_DEVDRV_NODRIVERFILE         1407
#define IDS_DEVDRV_NOROLLBACK           1408
#define IDS_DEVDRV_YESROLLBACK          1409
#define IDD_TS_ENABLEDEVICE_INTRO       1500
#define IDD_TS_ENABLEDEVICE_FINISH      1501
#define IDD_TS_RESTARTCOMPUTER_FINISH   1502
#define IDC_RESTART                     1503
#define IDC_CLASSICON                   1504
#define IDC_TS_DRVDESC                  1505
#define IDC_TS_ENABLEDEVICE_FINISH_MSG  1506
#define IDS_TS_ENABLE                   1507
#define IDS_TS_ENABLE_INFO              1508
#define IDS_TS_ENABLE_FINISH            1509
#define IDS_TS_ENABLE_FINISH_INFO       1510
#define IDS_TS_ENABLEDEVICE_SUCCESS     1511
#define IDS_TS_ENABLEDEVICE_FAIL        1512
#define IDS_TS_ENABLEDEVICE_RESTART     1513
#define IDS_TS_ENABLEDEVICE_PROBLEM     1514
#define IDS_TS_RESTART_FINISH           1515
#define IDS_TS_RESTART_FINISH_INFO      1516
#define IDS_NEED_RESTART                1517
#define IDS_WILL_BE_REMOVED             1518
#define IDS_PCI                         1519
#define IDS_ISA                         1520
#define IDS_ENABLE_CURRENT              1521
#define IDS_DISABLE_CURRENT             1522
#define IDS_DISABLE_IN_PROFILE          1523
#define IDS_DISABLE_GLOBAL              1524
#define IDS_WILL_BE_REMOVED_NO_UPDATE_DRIVER    1525
#define IDS_WILL_BE_REMOVED_NO_ROLLBACK_DRIVER  1526
#define IDS_WILL_BE_REMOVED_NO_CHANGE_SETTINGS  1527
#define IDS_DRIVER_BLOCKED                      1528
#define IDS_PROB_FAILED_DRIVER_ENTRY            1600
#define IDS_PROB_DRIVER_FAILED_PRIOR_UNLOAD     1601
#define IDS_PROB_DRIVER_FAILED_LOAD             1602
#define IDS_PROB_DRIVER_SERVICE_KEY_INVALID     1603
#define IDS_PROB_LEGACY_SERVICE_NO_DEVICES      1604
#define IDS_PROB_DUPLICATE_DEVICE               1605
#define IDS_PROB_FAILED_POST_START              1606
#define IDS_PROB_HALTED                         1607
#define IDS_PROB_PHANTOM                        1608
#define IDS_PROB_SYSTEM_SHUTDOWN                1609
#define IDS_PROB_HELD_FOR_EJECT                 1610
#define IDS_PROB_DRIVER_BLOCKED                 1611
#define IDS_PROB_REGISTRY_TOO_LARGE             1612
#define IDS_ANNOTATION_WORKING                  1700
#define IDS_ANNOTATION_PROBLEM                  1701
#define IDS_ANNOTATION_DISABLED                 1702
#define IDS_ANNOTATION_FORCED                   1703


// Hardware tab definitions

#define IDD_HWTAB                       1410

#define IDC_HWTAB_HSIZEFIRST            1411
#define IDC_HWTAB_LVSTATIC              1411
#define IDC_HWTAB_LISTVIEW              1412
#define IDC_HWTAB_VMOVEFIRST            1413
#define IDC_HWTAB_VSIZEFIRST            1413
#define IDC_HWTAB_GROUPBOX              1413

#define IDC_HWTAB_STATUS                1414
#define IDC_HWTAB_VSIZELAST             1414
#define IDC_HWTAB_MFG                   1415
#define IDC_HWTAB_LOC                   1416
#define IDC_HWTAB_HSIZELAST             1416

#define IDC_HWTAB_VDOWNFIRST            1417

#define IDC_HWTAB_TSHOOT                1417
#define IDC_HWTAB_PROP                  1418

#define IDC_HWTAB_VMOVELAST             1418
#define IDC_HWTAB_VDOWNLAST             1418

#define IDS_HWTAB_UNKNOWN   IDS_UNKNOWN
#define IDS_HWTAB_UNAVAIL   IDS_NOT_AVAILABLE
#define IDS_HWTAB_MFG       0x0601
#define IDS_HWTAB_LOC       0x0602
#define IDS_HWTAB_STATUS    0x0603

#define IDS_HWTAB_LV_NAME   0x0604
#define IDS_HWTAB_LV_TYPE   0x0605

// End of hardware tab definitions
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\sysinfo.h ===
#ifndef __SYSINFO_H_
#define __SYSINFO_H_

/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    sysinfo.h

Abstract:

    header file for sysinfo.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/


#include <winioctl.h>

typedef struct tagDiskInfo
{
    DWORD       cbSize;
    UINT        DriveType;
    STORAGE_MEDIA_TYPE  MediaType;
    ULARGE_INTEGER   TotalSpace;
    ULARGE_INTEGER   FreeSpace;
    LARGE_INTEGER   Cylinders;
    ULONG       Heads;
    ULONG       BytesPerSector;
    ULONG       SectorsPerTrack;
}DISK_INFO, *PDISK_INFO;

class CSystemInfo
{
public:
    CSystemInfo(CMachine* pMachine = NULL);
    ~CSystemInfo();
    BOOL GetDiskInfo(int Drive, DISK_INFO& DiskInfo);
    LPCTSTR ComputerName()
    {
        return m_strComputerName;
    }
    DWORD MachineType(TCHAR* Buffer, DWORD BufferSize);
    DWORD WindowsVersion(TCHAR* Buffer, DWORD BufferSize);
    DWORD SystemBiosDate(TCHAR* Buffer, DWORD BufferSize);
    DWORD SystemBiosVersion(TCHAR* Buffer, DWORD BufferSize);
    DWORD ProcessorType(TCHAR* Buffer, DWORD BufferSize);
    DWORD RegisteredOwner(TCHAR* Buffer, DWORD BufferSize);
    DWORD RegisteredOrganization(TCHAR* Buffer, DWORD BufferSize);
    DWORD ProcessorVendor(TCHAR* Buffer, DWORD BufferSize);
    DWORD NumberOfProcessors();
    DWORD ProcessorInfo(LPCTSTR ValueName, TCHAR* Buffer, DWORD BufferSize);
    void TotalPhysicalMemory(ULARGE_INTEGER& Size);

private:
    DWORD InfoFromRegistry(LPCTSTR SubkeyName, 
                           LPCTSTR ValueName,
                           TCHAR* Buffer, 
                           DWORD BufferSize,
                           HKEY hKeyAncestor = NULL
                           );
    String  m_strComputerName;
    BOOL    m_fLocalMachine;
    HKEY    m_hKeyMachine;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\proppage.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    proppage.cpp

Abstract:

    This module implements CPropSheetPage class, the base class of
    CDeviceGeneralPage, CClassGeneralPage and CDeviceDriverPage.

Author:

    William Hsieh (williamh) created

Revision History:


--*/
#include "devmgr.h"
#include "proppage.h"

//
// CPropSheetPage implementation
//


CPropSheetPage::CPropSheetPage(
    HINSTANCE hInst,
    UINT idTemplate
    )
{
    memset(&m_psp, 0, sizeof(m_psp));
    m_psp.dwSize = sizeof(m_psp);
    m_psp.dwFlags = PSP_USECALLBACK;
    m_psp.pszTemplate = MAKEINTRESOURCE(idTemplate);
    m_psp.lParam = 0;
    m_psp.pfnCallback = CPropSheetPage::PageCallback;
    m_psp.pfnDlgProc = PageDlgProc;
    m_psp.hInstance = hInst;
    m_Active = FALSE;
    //
    // By default, we want every derived page to update its contents
    // on each PSN_SETACTIVE so that it has up-to-date information
    // presented since any page in the same property sheet may
    // change the target object and there are not reliable ways
    // to synchronize changes among pages.
    //
    m_AlwaysUpdateOnActive = TRUE;
    // Right after WM_INITDIALOG, we will receive a
    // PSN_SETACTIVE and by setting m_UpdateControlsPending
    // to TRUE, the PSN_SETACTIVE handler will call UpdateControls
    // to refresh the page.
    // derived classes can turn this off if they wish to
    // update the dialog box only once in OnInitDialog.
    // Also, since m_AlwaysUpdateOnActive is TRUE by-default,
    // m_UpdateControlPending is FALSE by-default.
    m_UpdateControlsPending = FALSE;

    m_IDCicon = 0;
}

INT_PTR
CPropSheetPage::PageDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CPropSheetPage* pThis = (CPropSheetPage *) GetWindowLongPtr(hDlg, DWLP_USER);
    LPNMHDR pnmhdr;
    BOOL Result;

    switch (uMsg) {
     
    case WM_INITDIALOG: {
        
        PROPSHEETPAGE* ppsp = (PROPSHEETPAGE *)lParam;
        pThis = (CPropSheetPage *) ppsp->lParam;
        ASSERT(pThis);
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pThis);
        pThis->m_hDlg = hDlg;
        Result = pThis->OnInitDialog(ppsp);
        break;
    }
    
    case WM_COMMAND:
        if (pThis)
            Result = pThis->OnCommand(wParam, lParam);
        else
            Result = FALSE;
        break;
    
    case WM_NOTIFY: {
        
        pnmhdr = (LPNMHDR)lParam;
        
        switch (pnmhdr->code) {
            
        case PSN_SETACTIVE:
            ASSERT(pThis);
            Result = pThis->OnSetActive();
            break;
        
        case PSN_KILLACTIVE:
            ASSERT(pThis);
            Result = pThis->OnKillActive();
            break;
            
        case PSN_APPLY:
            ASSERT(pThis);
            Result = pThis->OnApply();
            break;

        case PSN_LASTCHANCEAPPLY:
            ASSERT(pThis);
            Result = pThis->OnLastChanceApply();
            break;
            
        case PSN_RESET:
            ASSERT(pThis);
            Result = pThis->OnReset();
            break;
            
        case PSN_WIZFINISH:
            ASSERT(pThis);
            Result = pThis->OnWizFinish();
            break;
            
        case PSN_WIZNEXT:
            ASSERT(pThis);
            Result = pThis->OnWizNext();
            break;
            
        case PSN_WIZBACK:
            ASSERT(pThis);
            Result = pThis->OnWizBack();
            break;
            
        default:
            ASSERT(pThis);
            pThis->OnNotify(pnmhdr);
            Result = FALSE;
            break;
        }
        
        break;
    }
    
    case WM_DESTROY:
        if (pThis)
            Result = pThis->OnDestroy();
        else
            Result = FALSE;
        break;
    
    case PSM_QUERYSIBLINGS:
        ASSERT(pThis);
        Result = pThis->OnQuerySiblings(wParam, lParam);
        break;
    
    case WM_HELP:
        ASSERT(pThis);
        Result = pThis->OnHelp((LPHELPINFO)lParam);
        break;
    
    case WM_CONTEXTMENU:
        ASSERT(pThis);
        Result = pThis->OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));
        break;
    
    default:
        Result = FALSE;
        break;
    }
    
    return Result;
}

UINT
CPropSheetPage::DestroyCallback()
{
    delete this;
    return TRUE;
}

//
// This function is the property page create/desrtroy callback.
// It monitors the PSPSCB_RELEASE to delete this object.
// This is the most reliable way to free objects associated with
// a property page. A property page which is never activated
// will not receive a WM_DESTROY message because its window is not
// created.
//
UINT
CPropSheetPage::PageCallback(
    HWND hDlg,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp
    )
{
    ASSERT(ppsp);
    CPropSheetPage* pThis = (CPropSheetPage*)ppsp->lParam;
    
    if (PSPCB_CREATE == uMsg && pThis)
    {
        pThis->CreateCallback();
    }
    
    else if (PSPCB_RELEASE == uMsg && pThis)
    {
        return pThis->DestroyCallback();
    }

    return TRUE;
}


BOOL
CPropSheetPage::OnQuerySiblings(
    WPARAM wParam,
    LPARAM lParam
    )
{
    ASSERT(m_hDlg);
    DMQUERYSIBLINGCODE Code = (DMQUERYSIBLINGCODE)wParam;
    
    //
    // Properties of the device attached to this page have
    // changed. Try to update the controls if we are currently
    // active. If we are active at this time, signal a flag
    // so that on PSN_SETACTIVE will do the update.
    //
    switch (Code) {
    
    case QSC_PROPERTY_CHANGED:
        if (m_Active)
        {
            UpdateControls(lParam);
            m_UpdateControlsPending = FALSE;
        }
        
        else
        {
            // wait for SetActive to update the controls
            m_UpdateControlsPending = TRUE;
        }
        break;
    }
    
    SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, 0L);
    return FALSE;
}


BOOL
CPropSheetPage::OnDestroy()
{
    HICON hIcon;

    if (m_IDCicon)
    {
        if (hIcon = (HICON)SendDlgItemMessage(m_hDlg, m_IDCicon, STM_GETICON, 0, 0))
        {
            DestroyIcon(hIcon);
        }
        m_IDCicon = 0;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\tsmain.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    tsmain.cpp

Abstract:

    This module implements Device Manager troubleshooting supporting classes

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "devmgr.h"
#include "proppage.h"
#include "tsmain.h"
#include "tswizard.h"

const TCHAR*    REG_PATH_TROUBLESHOOTERS = TEXT("Troubleshooters");
const TCHAR*    REG_VALUE_WIZARD32 = TEXT("Wizard32");

//
// class CWizard implementation
//

BOOL
CWizard::Query(
              CDevice* pDevice,
              ULONG Problem
              )
{
    if (!m_WizardEntry)
        return FALSE;
    TSHOOTER_QUERYPARAM QueryParam;
    TCHAR Description[MAX_PATH];
    m_pDevice = pDevice;
    QueryParam.Header.cbSize = sizeof(QueryParam);
    QueryParam.Header.Command = TSHOOTER_QUERY;
    QueryParam.DeviceId = pDevice->GetDeviceID();
    QueryParam.Problem = Problem;
    QueryParam.DescBuffer = Description;
    QueryParam.DescBufferSize = ARRAYLEN(Description);
    if ((*m_WizardEntry)((PTSHOOTER_PARAMHEADER) &QueryParam)) {
        m_DeviceRank = QueryParam.DeviceRank;
        m_ProblemRank = QueryParam.ProblemRank;
        m_strDescription = Description;
        return TRUE;
    }
    return FALSE;
}
BOOL
CWizard::About(HWND hwndOwner)
{
    if (!m_WizardEntry)
        return FALSE;
    TSHOOTER_ABOUTPARAM AboutParam;
    AboutParam.Header.cbSize = sizeof(AboutParam);
    AboutParam.Header.Command = TSHOOTER_ABOUT;
    AboutParam.hwndOwner = hwndOwner;
    return(*m_WizardEntry)((PTSHOOTER_PARAMHEADER)&AboutParam);
}
BOOL
CWizard::AddPages(
                 LPPROPSHEETHEADER ppsh,
                 DWORD MaxPages
                 )
{
    if (!m_WizardEntry)
        return FALSE;
    if (!m_pDevice) {
        SetLastError(ERROR_INVALID_FUNCTION);
        return FALSE;
    }
    TSHOOTER_ADDPAGESPARAM AddPagesParam;
    AddPagesParam.Header.cbSize = sizeof(AddPagesParam);
    AddPagesParam.Header.Command = TSHOOTER_ADDPAGES;
    AddPagesParam.Problem = m_Problem;
    AddPagesParam.DeviceId = m_pDevice->GetDeviceID();
    AddPagesParam.PropSheetHeader = ppsh;
    AddPagesParam.MaxPages = MaxPages;
    return(*m_WizardEntry)((PTSHOOTER_PARAMHEADER)&AddPagesParam);
}

//
// class CWizardList implementation
//

BOOL
CWizardList::Create(
                   CDevice* pDevice,
                   ULONG   Problem
                   )
{
    CSafeRegistry regDevMgr;
    CSafeRegistry regTShooters;
    DWORD RegType, Size, Type;
    if (regDevMgr.Open(HKEY_LOCAL_MACHINE, REG_PATH_DEVICE_MANAGER) &&
        regTShooters.Open(regDevMgr, REG_PATH_TROUBLESHOOTERS)) {

        if (TWT_ANY == m_Type || TWT_PROBLEM_SPECIFIC == m_Type) {
            // create problem specific wizards list first
            // convert problem number to subkey name
            TCHAR ProblemSubkey[10];
            wsprintf(ProblemSubkey, TEXT("%08X"), Problem);
            // see if there are registered for the problem.
            CSafeRegistry regProblem;
            if (regProblem.Open(regTShooters, ProblemSubkey)) {
                Size = 0;
                if (regProblem.GetValue(REG_VALUE_WIZARD32, &Type, NULL, &Size) &&
                    REG_MULTI_SZ == Type && Size) {
                    BufferPtr<BYTE> WizardPtr(Size);
                    regProblem.GetValue(REG_VALUE_WIZARD32, &Type, WizardPtr, &Size);
                    CreateWizardsFromStrings((LPTSTR)(BYTE*)WizardPtr, pDevice, Problem);
                }
            }
        }
        if (TWT_ANY == m_Type || TWT_CLASS_SPECIFIC == m_Type) {
            TCHAR GuidSubkey[MAX_GUID_STRING_LEN];
            GUID ClassGuid;
            pDevice->ClassGuid(ClassGuid);
            ULONG Size;
            if (GuidToString(&ClassGuid, GuidSubkey, ARRAYLEN(GuidSubkey))) {
                CSafeRegistry regGuid;
                if (regGuid.Open(regTShooters, GuidSubkey)) {
                    Size = 0;
                    if (regGuid.GetValue(REG_VALUE_WIZARD32, &Type, NULL, &Size) &&
                        REG_MULTI_SZ == Type && Size) {
                        BufferPtr<BYTE> WizardPtr(Size);
                        regGuid.GetValue(REG_VALUE_WIZARD32, &Type, WizardPtr, &Size);
                        CreateWizardsFromStrings((LPTSTR)(BYTE*)WizardPtr, pDevice, Problem);
                    }
                }
            }
        }
        if (TWT_ANY == m_Type || TWT_GENERAL_PURPOSE == m_Type) {
            if (regTShooters.GetValue(REG_VALUE_WIZARD32, &Type, NULL, &Size) &&
                REG_MULTI_SZ == Type && Size) {
                BufferPtr<BYTE> WizardPtr(Size);
                regTShooters.GetValue(REG_VALUE_WIZARD32, &Type, WizardPtr, &Size);
                CreateWizardsFromStrings((LPTSTR)(BYTE*)WizardPtr, pDevice, Problem);
            }
        }
    }
    if (TWT_ANY == m_Type || TWT_DEVMGR_DEFAULT == m_Type) {
        SafePtr<CDefaultWizard> WizardPtr;
        CDefaultWizard* pWizard = new CDefaultWizard;
        WizardPtr.Attach(pWizard);
        if (pWizard->Query(pDevice, Problem)) {
            m_listWizards.AddTail(pWizard);
            WizardPtr.Detach();
        }
    }
    return !m_listWizards.IsEmpty();
}

CWizardList::~CWizardList()
{
    if (!m_listWizards.IsEmpty()) {
        POSITION pos = m_listWizards.GetHeadPosition();
        while (NULL != pos) {
            delete (CWizard*)m_listWizards.GetNext(pos);
        }
        m_listWizards.RemoveAll();
    }
}


BOOL
CWizardList::CreateWizardsFromStrings(
                                     LPTSTR msz,
                                     CDevice* pDevice,
                                     ULONG   Problem
                                     )
{
    LPTSTR p;
    p = msz;
    SetLastError(ERROR_SUCCESS);
    BOOL Result = TRUE;
    // the format of each string is "dllname, dllentryname"
    while (Result && _T('\0') != *p) {
        HMODULE hDll;
        FARPROC ProcAddress;
        Result =  LoadEnumPropPage32(p, &hDll, &ProcAddress);
        if (Result) {
            SafePtr<CWizard> WizardPtr;
            CWizard* pWizard = new CWizard(hDll, ProcAddress);
            WizardPtr.Attach(pWizard);
            if (pWizard->Query(pDevice, Problem)) {
                m_listWizards.AddTail(pWizard);
                WizardPtr.Detach();
            }
        }
        p += lstrlen(p) + 1;
    }
    return Result;
}

BOOL
CWizardList::GetFirstWizard(
                           CWizard** ppWizard,
                           PVOID*    pContext
                           )
{
    if (!ppWizard || !pContext) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    if (!m_listWizards.IsEmpty()) {
        POSITION pos = m_listWizards.GetHeadPosition();
        if (NULL != pos) {
            *ppWizard = m_listWizards.GetNext(pos);
            *pContext = (PVOID)pos;
            return TRUE;
        }
    }
    SetLastError(ERROR_NO_MORE_ITEMS);
    *ppWizard = NULL;
    *pContext   = NULL;
    return FALSE;
}

BOOL
CWizardList::GetNextWizard(
                          CWizard** ppWizard,
                          PVOID&    Context
                          )
{
    if (!ppWizard) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    POSITION pos = (POSITION)Context;
    if (NULL != pos) {
        *ppWizard = m_listWizards.GetNext(pos);
        Context = pos;
        return TRUE;
    }
    *ppWizard = NULL;
    Context = NULL;
    SetLastError(ERROR_NO_MORE_ITEMS);
    return FALSE;
}

CWizard98::CWizard98(
                    HWND hwndParent,
                    UINT MaxPages
                    )
{
    m_MaxPages = 0;
    if (MaxPages && MaxPages <= 32) {
        m_MaxPages = MaxPages;
        memset(&m_psh, 0, sizeof(m_psh));
        m_psh.hInstance = g_hInstance;
        m_psh.hwndParent = hwndParent;
        m_psh.phpage = new HPROPSHEETPAGE[MaxPages];
        m_psh.dwSize = sizeof(m_psh);
        m_psh.dwFlags = PSH_WIZARD | PSH_WIZARD97 | PSH_HEADER |
                        PSH_WATERMARK | PSH_STRETCHWATERMARK;
        m_psh.pszbmWatermark = MAKEINTRESOURCE(IDB_WATERMARK);
        m_psh.pszbmHeader = MAKEINTRESOURCE(IDB_BANNER);
        PSH_STRETCHWATERMARK;
        m_psh.pszCaption = MAKEINTRESOURCE(IDS_TROUBLESHOOTING_NAME);
    }

}

BOOL
CWizard98::CreateIntroPage(
                          CDevice* pDevice
                          )
{


    CWizardIntro* pIntroPage = new CWizardIntro;
    HPROPSHEETPAGE hPage = pIntroPage->Create(pDevice);
    if (hPage) {
        m_psh.phpage[m_psh.nPages++] = hPage;
        return TRUE;
    }
    return FALSE;
}

HPROPSHEETPAGE
CWizardIntro::Create(
                    CDevice* pDevice
                    )
{
    if (!m_pDevice) {
        ASSERT(m_pDevice);
        m_pDevice = pDevice;
        m_psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_HIDEHEADER;
        m_psp.pszTitle = MAKEINTRESOURCE(IDS_TROUBLESHOOTING_NAME);
        m_psp.lParam = (LPARAM)this;
        m_pSelectedWizard = NULL;
        DWORD Problem, Status;
        if (pDevice->GetStatus(&Status, &Problem) &&
            m_Wizards.Create(pDevice, Problem)) {
            m_Problem = Problem;
            return CPropSheetPage::CreatePage();
        }
    }
    return NULL;
}

BOOL
CWizardIntro::OnInitDialog(
                          LPPROPSHEETPAGE ppsp
                          )
{
    try {
        ASSERT(!m_hFontBold && !m_hFontBigBold);
        HFONT hFont = (HFONT)SendMessage(GetDlgItem(m_hDlg, IDC_WIZINTRO_WELCOME),
                                         WM_GETFONT, 0, 0);
        LOGFONT LogFont;
        GetObject(hFont, sizeof(LogFont), &LogFont);
        LogFont.lfWeight = FW_BOLD;
        m_hFontBold = CreateFontIndirect(&LogFont);
        int PtsPixels = GetDeviceCaps(GetDC(m_hDlg), LOGPIXELSY);
        int FontSize = (LogFont.lfHeight * 72 / PtsPixels) * 2;
        LogFont.lfHeight = PtsPixels * FontSize / 72;
        m_hFontBigBold = CreateFontIndirect(&LogFont);

        if (m_hFontBigBold && m_hFontBold) {
            SendMessage(GetDlgItem(m_hDlg, IDC_WIZINTRO_WELCOME),
                        WM_SETFONT, (WPARAM)m_hFontBold, (LPARAM)TRUE);
            SendMessage(GetDlgItem(m_hDlg, IDC_WIZINTRO_NAME),
                        WM_SETFONT, (WPARAM)m_hFontBigBold, (LPARAM)TRUE);
        }
        int Count = 0;
        CWizard* pWizard;
        PVOID    Context;
        Count = m_Wizards.NumberOfWizards();
        if (Count > 1) {
            //
            // enumerate all registered wizard32 based troubleshooters
            //
            if (m_Wizards.GetFirstWizard(&pWizard, &Context)) {
                do {
                    int iItem;
                    iItem = SendDlgItemMessage(m_hDlg, IDC_WIZINTRO_WIZARDLIST,
                                               LB_ADDSTRING, Count,
                                               (LPARAM)(LPCTSTR)pWizard->GetDescription()
                                              );
                    if (LB_ERR != iItem) {
                        SendDlgItemMessage(m_hDlg, IDC_WIZINTRO_WIZARDLIST,
                                           LB_SETITEMDATA, iItem, (LPARAM)pWizard);
                        Count++;
                    }
                } while (m_Wizards.GetNextWizard(&pWizard, Context));
            }
        }
        // if we have any troubleshooters listed at all,
        // display the list and change the instruction text
        //
        if (Count > 1) {
            // make the default selection to the first one
            SendDlgItemMessage(m_hDlg, IDC_WIZINTRO_WIZARDLIST,
                               LB_SETCURSEL, 0, 0);
        } else {
            // we have only one wizard in the list,
            // hide the wizard list box and necessary text and
            // select the only wizard as the selected wizard
            ShowWindow(GetControl(IDC_WIZINTRO_WIZARDS_GROUP), SW_HIDE);
            ShowWindow(GetControl(IDC_WIZINTRO_WIZARDS_TEXT), SW_HIDE);
            ShowWindow(GetControl(IDC_WIZINTRO_WIZARDLIST), SW_HIDE);
            m_Wizards.GetFirstWizard(&m_pSelectedWizard, &Context);
            ASSERT(m_pSelectedWizard);
        }
    } catch (CMemoryException* e) {
        e->Delete();
        MsgBoxParam(m_hDlg, 0, 0, 0);
    }
    return TRUE;

}

BOOL
CWizardIntro::OnWizNext()
{
    try {
        CWizard* pNewSelectedWizard = NULL;
        // get the current selected wizard from the list box
        // The list box is hidden when there is only one wizard
        // available.
        if (IsWindowVisible(GetControl(IDC_WIZINTRO_WIZARDLIST))) {
            int iItem = SendDlgItemMessage(m_hDlg, IDC_WIZINTRO_WIZARDLIST,
                                           LB_GETCURSEL, 0, 0);
            if (LB_ERR != iItem) {
                pNewSelectedWizard = (CWizard*) SendDlgItemMessage(m_hDlg,
                                                                   IDC_WIZINTRO_WIZARDLIST,
                                                                   LB_GETITEMDATA, iItem, 0);
            }
        }
        if (m_pSelectedWizard != pNewSelectedWizard) {
            if (m_pSelectedWizard) {
                // user has changed the wizard selection
                // remove all the pages added by the previous wizard
                UINT TotalPages = m_pSelectedWizard->m_AddedPages;

                // do not remove page 0 which is our introduction page
                for (UINT PageIndex = 1; TotalPages; TotalPages--, PageIndex++) {
                    // PSM_REMOVEPAGE should also destroy the page, therefore,
                    // we do not call DestroyPropertySheetPage on that page
                    // here.
                    ::SendMessage(GetParent(m_hDlg), PSM_REMOVEPAGE, PageIndex, 0);
                }
            }
            m_pSelectedWizard = NULL;

            // Let the newly selected wizard to create pages
            // We need a local copy of PROPERSHEETHEADER here
            // because we have to add each page to the active property
            // sheet(already displayed).
            CWizard98   theSheet(GetParent(GetParent(m_hDlg)));
            LONG Error;
            if (pNewSelectedWizard->AddPages(&theSheet.m_psh,
                                             theSheet.GetMaxPages()
                                            )) {
                // Remember how many pages the wizard added to the sheet.
                // It is used to removed page when we switch troubleshooters
                pNewSelectedWizard->m_AddedPages = theSheet.m_psh.nPages;

                // Add new pages to the property sheet
                for (UINT i = 0; i < theSheet.m_psh.nPages; i++) {
                    SendMessage(GetParent(m_hDlg), PSM_ADDPAGE, 0,
                                (LPARAM)theSheet.m_psh.phpage[i]);
                }
                m_pSelectedWizard = pNewSelectedWizard;
            } else {
                SetWindowLong(m_hDlg, DWL_MSGRESULT, -1);
            }
        }
    } catch (CMemoryException* e) {
        e->Delete();
        MsgBoxParam(m_hDlg, 0, 0, 0);
    }
    return CPropSheetPage::OnWizNext();
}

BOOL
CWizardIntro::OnSetActive()
{
    PropSheet_SetWizButtons(GetParent(m_hDlg), PSWIZB_NEXT);
    return CPropSheetPage::OnSetActive();
}

BOOL
CWizardIntro::OnCommand(
                       WPARAM wParam,
                       LPARAM lParam
                       )
{
    if (LBN_DBLCLK == HIWORD(wParam) && IDC_WIZINTRO_WIZARDLIST == LOWORD(wParam)) {
        int iItem = SendDlgItemMessage(m_hDlg, IDC_WIZINTRO_WIZARDLIST,
                                       LB_GETCURSEL, 0, 0);
        if (LB_ERR != iItem && m_pSelectedWizard) {

            m_pSelectedWizard->About(m_hDlg);
        }
    }
    return CPropSheetPage::OnCommand(wParam, lParam);
}




INT_PTR
StartTroubleshootingWizard(
                          HWND hwndParent,
                          CDevice* pDevice
                          )
{
    try {
        CWizard98 theSheet(hwndParent);
        if (theSheet.CreateIntroPage(pDevice))
            return theSheet.DoSheet();
    } catch (CMemoryException* e) {
        e->Delete();
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\tsmisc.h ===
#ifndef __TSMISC_H__
#define __TSMISC_H__

/*++

Copyright (C) 1998-1999  Microsoft Corporation

Module Name:

    tsmisc.h

Abstract:

    header file for tsmain.cpp

Author:

    Jason Cobb (jasonc) created

Revision History:


--*/


//
// Class that represents a single wizard page for the following problems:
//
//  Enable device
//  Restart
//
class CTSEnableDeviceIntroPage : public CPropSheetPage
{
public:
    CTSEnableDeviceIntroPage() : 
            m_pDevice(NULL), 
            m_Problem(0),
            CPropSheetPage(g_hInstance, IDD_TS_ENABLEDEVICE_INTRO)
    {
    }

    virtual BOOL OnWizNext();
    virtual BOOL OnSetActive();
    HPROPSHEETPAGE Create(CDevice* pDevice);

private:
    CDevice* m_pDevice;
    ULONG m_Problem;
};

class CTSEnableDeviceFinishPage : public CPropSheetPage
{
public:
    CTSEnableDeviceFinishPage() : 
            m_pDevice(NULL), 
            m_Problem(0),
            CPropSheetPage(g_hInstance, IDD_TS_ENABLEDEVICE_FINISH)
    {
    }

    virtual BOOL OnWizFinish();
    virtual BOOL OnSetActive();
    HPROPSHEETPAGE Create(CDevice* pDevice);

private:
    CDevice* m_pDevice;
    ULONG m_Problem;
};


class CTSRestartComputerFinishPage : public CPropSheetPage
{
public:
    CTSRestartComputerFinishPage() : 
            m_pDevice(NULL), 
            m_Problem(0),
            CPropSheetPage(g_hInstance, IDD_TS_RESTARTCOMPUTER_FINISH)
    {
    }

    virtual BOOL OnWizFinish();
    virtual BOOL OnSetActive();
    HPROPSHEETPAGE Create(CDevice* pDevice);

private:
    CDevice* m_pDevice;
    ULONG m_Problem;
};

    
#endif // __TSMISC__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\sysinfo.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    sysinfo.cpp

Abstract:

    This module implements CSystemInfo, the class that returns various
    system information

Author:

    William Hsieh (williamh) created

Revision History:


--*/


#include "devmgr.h"
#include "sysinfo.h"

// disk drive root template name. Used to retreive the disk's media
// information or geometry
const TCHAR* const DRIVE_ROOT = TEXT("\\\\.\\?:");
const int DRIVE_LETTER_IN_DRIVE_ROOT = 4;

// disk drive root directory template name. Used to retreive the disk's
// total and free space
const TCHAR* const DRIVE_ROOT_DIR = TEXT("?:\\");
const int DRIVE_LETTER_IN_DRIVE_ROOT_DIR = 0;

//
// Registry various subkey and value names used to retreive
// system information
//
const TCHAR* const REG_PATH_HARDWARE_SYSTEM = TEXT("HARDWARE\\DESCRIPTION\\System");
const TCHAR* const REG_VALUE_SYSTEMBIOSDATE = TEXT("SystemBiosDate");
const TCHAR* const REG_VALUE_SYSTEMBIOSVERSION = TEXT("SystemBiosVersion");
const TCHAR* const REG_VALUE_MACHINETYPE  = TEXT("Identifier");
const TCHAR* const REG_VALUE_PROCESSOR_SPEED = TEXT("~MHZ");

const TCHAR* const REG_PATH_WINDOWS_NT = TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion");
const TCHAR* const REG_VALUE_REGISTERED_OWNER = TEXT("RegisteredOwner");
const TCHAR* const REG_VALUE_REGISTERED_ORGANIZATION = TEXT("RegisteredOrganization");
const TCHAR* const REG_VALUE_BUID_TYPE  = TEXT("CurrentType");
const TCHAR* const REG_VALUE_SYSTEMROOT = TEXT("SystemRoot");
const TCHAR* const REG_VALUE_INSTALLDATE = TEXT("InstallDate");
const TCHAR* const REG_VALUE_CURRENTBUILDNUMBER = TEXT("CurrentBuildNumber");
const TCHAR* const REG_VALUE_CURRENTVERSION = TEXT("CurrentVersion");
const TCHAR* const REG_VALUE_CSDVERSION = TEXT("CSDVersion");
const TCHAR* const REG_PATH_CPU = TEXT("HARDWARE\\DESCRIPTION\\System\\CentralProcessor");
const TCHAR* const REG_VALUE_CPU_TYPE = TEXT("Identifier");
const TCHAR* const REG_VALUE_CPU_SPEED = TEXT("~MHz");
const TCHAR* const REG_VALUE_CPU_VENDOR = TEXT("VendorIdentifier");

CSystemInfo::CSystemInfo(
                        CMachine* pMachine
                        )
{
    // assuming the machine is a local machine and initialize
    // the registry root key as well.
    m_hKeyMachine = HKEY_LOCAL_MACHINE;

    if (pMachine) {
        m_fLocalMachine = pMachine->IsLocal();
        m_strComputerName += pMachine->GetMachineDisplayName();
    } else {
        TCHAR LocalName[MAX_PATH + 1];
        DWORD dwSize = sizeof(LocalName) / sizeof(TCHAR);

        if (!GetComputerName(LocalName, &dwSize)) {

            LocalName[0] = _T('\0');
        }


        // local machine
        m_fLocalMachine = TRUE;
        m_strComputerName = LocalName;
    }

    if (!m_fLocalMachine) {
        // The machine is not local, connect to the registry
        TCHAR ComputerName[MAX_PATH];

        // the api requires an LPTSTR instead of LPCTSTR!!!!
        lstrcpy(ComputerName, TEXT("\\\\"));
        lstrcat(ComputerName, (LPCTSTR)m_strComputerName);
        m_hKeyMachine = NULL;
        RegConnectRegistry(ComputerName, HKEY_LOCAL_MACHINE, &m_hKeyMachine);
    }
}

CSystemInfo::~CSystemInfo()
{
    if (!m_fLocalMachine && NULL != m_hKeyMachine) {
        RegCloseKey(m_hKeyMachine);

        // disconnect the machine
        WNetCancelConnection2(TEXT("\\server\\ipc$"), 0, TRUE);
    }
}

//
// This function gets the disk information about the given disk drive
// INPUT:
//  Drive -- the drive number. 0 for A, 1 for B and etc.
//  DiskInfo -- the DISK_INFO to be filled with the information about
//          the drive. DiskInfo.cbSize must be initialized before
//          the call.
// OUTPUT:
//  TRUE  -- if succeeded, DiskInfo is filled with information
//  FALSE -- if the drive information can not be retreived.
//       No appropriate error code is returned;
BOOL
CSystemInfo::GetDiskInfo(
                        int  Drive,
                        DISK_INFO& DiskInfo
                        )
{
    // diskinfo only valid on local computer
    if (!m_fLocalMachine) {
        return FALSE;
    }

    TCHAR DriveLetter;
    TCHAR Root[MAX_PATH];
    DriveLetter = _T('A') + Drive;
    lstrcpy(Root, DRIVE_ROOT_DIR);
    Root[DRIVE_LETTER_IN_DRIVE_ROOT_DIR] = DriveLetter;
    UINT DriveType;
    DriveType = GetDriveType(Root);

    //
    // only valid for local drives
    //
    if (DRIVE_UNKNOWN == DriveType || DRIVE_REMOTE == DriveType ||
        DRIVE_NO_ROOT_DIR == DriveType) {
        return FALSE;
    }

    if (DiskInfo.cbSize < sizeof(DISK_INFO)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // form the disk root name from template
    //
    lstrcpy(Root, DRIVE_ROOT);
    Root[DRIVE_LETTER_IN_DRIVE_ROOT] = DriveLetter;
    HANDLE hDisk;

    // FILE_READ_ATTRIBUTES is used here so that we will not get nasty
    // error or prompt if the disk is a removable drive and there is no
    // media available.
    hDisk = CreateFile(Root,
                       FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (INVALID_HANDLE_VALUE != hDisk) {
        // form the disk root directory name from template
        lstrcpy(Root, DRIVE_ROOT_DIR);
        Root[DRIVE_LETTER_IN_DRIVE_ROOT_DIR] = DriveLetter;
        BYTE Buffer[512];
        DWORD BytesRequired = 0;

        if (DeviceIoControl(hDisk, IOCTL_STORAGE_GET_MEDIA_TYPES_EX, NULL, 0,
                            Buffer, sizeof(Buffer), &BytesRequired, NULL)) {
            GET_MEDIA_TYPES* pMediaList;
            DEVICE_MEDIA_INFO*  pMediaInfo;
            pMediaList = (GET_MEDIA_TYPES*)Buffer;
            pMediaInfo = pMediaList->MediaInfo;
            DWORD MediaCount = pMediaList->MediaInfoCount;
            ULARGE_INTEGER MaxSpace, NewSpace;
            DEVICE_MEDIA_INFO* pMaxMediaInfo;
            MaxSpace.QuadPart = 0;
            pMaxMediaInfo = NULL;

            for (DWORD i = 0; i < MediaCount; i++, pMediaInfo++) {
                //
                // find the mediainfo which has max space
                // A disk drive may support multiple media types and the
                // one with maximum capacity is what we want to report.
                //
                if (DRIVE_REMOVABLE == DriveType || DRIVE_CDROM == DriveType) {
                    NewSpace.QuadPart =
                    pMediaInfo->DeviceSpecific.RemovableDiskInfo.BytesPerSector *
                    pMediaInfo->DeviceSpecific.RemovableDiskInfo.SectorsPerTrack *
                    pMediaInfo->DeviceSpecific.RemovableDiskInfo.TracksPerCylinder *
                    pMediaInfo->DeviceSpecific.RemovableDiskInfo.Cylinders.QuadPart;

                } else {
                    NewSpace.QuadPart =
                    pMediaInfo->DeviceSpecific.DiskInfo.BytesPerSector *
                    pMediaInfo->DeviceSpecific.DiskInfo.SectorsPerTrack *
                    pMediaInfo->DeviceSpecific.DiskInfo.TracksPerCylinder *
                    pMediaInfo->DeviceSpecific.DiskInfo.Cylinders.QuadPart;
                }

                if (NewSpace.QuadPart > MaxSpace.QuadPart) {
                    MaxSpace.QuadPart = NewSpace.QuadPart;
                    pMaxMediaInfo = pMediaInfo;
                }
            }

            if (pMaxMediaInfo) {
                //
                // a valid media information is found, compose  DISK_INFO
                // from the media information
                //
                DiskInfo.DriveType = DriveType;
                if (DRIVE_REMOVABLE == DriveType || DRIVE_CDROM == DriveType) {
                    DiskInfo.MediaType = pMaxMediaInfo->DeviceSpecific.RemovableDiskInfo.MediaType;
                    DiskInfo.Cylinders = pMaxMediaInfo->DeviceSpecific.RemovableDiskInfo.Cylinders;
                    DiskInfo.Heads = pMaxMediaInfo->DeviceSpecific.RemovableDiskInfo.TracksPerCylinder;
                    DiskInfo.BytesPerSector = pMaxMediaInfo->DeviceSpecific.RemovableDiskInfo.BytesPerSector;
                    DiskInfo.SectorsPerTrack = pMaxMediaInfo->DeviceSpecific.RemovableDiskInfo.SectorsPerTrack;

                    //
                    // Do not call GetDiskFreeSpaceEx on removable disk
                    // or CD-ROM
                    //
                    DiskInfo.TotalSpace = MaxSpace;
                    DiskInfo.FreeSpace.QuadPart = -1;

                } else {
                    DiskInfo.MediaType = pMaxMediaInfo->DeviceSpecific.DiskInfo.MediaType;
                    DiskInfo.Cylinders = pMaxMediaInfo->DeviceSpecific.DiskInfo.Cylinders;
                    DiskInfo.Heads = pMaxMediaInfo->DeviceSpecific.DiskInfo.TracksPerCylinder;
                    DiskInfo.BytesPerSector = pMaxMediaInfo->DeviceSpecific.DiskInfo.BytesPerSector;
                    DiskInfo.SectorsPerTrack = pMaxMediaInfo->DeviceSpecific.DiskInfo.SectorsPerTrack;
                    lstrcpy(Root, DRIVE_ROOT_DIR);
                    Root[DRIVE_LETTER_IN_DRIVE_ROOT_DIR] = DriveLetter;
                    ULARGE_INTEGER FreeSpaceForCaller;

                    if (!GetDiskFreeSpaceEx(Root, &FreeSpaceForCaller, &DiskInfo.TotalSpace, &DiskInfo.FreeSpace)) {
                        DiskInfo.TotalSpace = MaxSpace;

                        // unknown
                        DiskInfo.FreeSpace.QuadPart = -1;
                    }
                }

                CloseHandle(hDisk);
                return TRUE;
            }
        }

        //
        // we wouldn't go here if the drive is not  removable.
        // Basically, this is for floppy drives only.
        //
        if (DRIVE_REMOVABLE == DriveType &&
            DeviceIoControl(hDisk, IOCTL_DISK_GET_MEDIA_TYPES, NULL, 0,
                            Buffer, sizeof(Buffer), &BytesRequired, NULL)) {
            int TotalMediaTypes = BytesRequired / sizeof(DISK_GEOMETRY);
            DISK_GEOMETRY* pGeometry;
            pGeometry = (DISK_GEOMETRY*)Buffer;
            ULARGE_INTEGER MaxSpace;
            ULARGE_INTEGER NewSpace;
            MaxSpace.QuadPart = 0;
            DISK_GEOMETRY* pMaxGeometry = NULL;

            for (int i = 0; i < TotalMediaTypes; i++, pGeometry++) {
                //
                // find the geometry with maximum capacity
                //
                NewSpace.QuadPart = pGeometry->BytesPerSector *
                                    pGeometry->SectorsPerTrack *
                                    pGeometry->TracksPerCylinder *
                                    pGeometry->Cylinders.QuadPart;

                if (NewSpace.QuadPart > MaxSpace.QuadPart) {
                    pMaxGeometry = pGeometry;
                    MaxSpace = NewSpace;
                }
            }

            if (pMaxGeometry) {
                DiskInfo.DriveType = DriveType;
                DiskInfo.MediaType = (STORAGE_MEDIA_TYPE)pMaxGeometry->MediaType;
                DiskInfo.Cylinders = pMaxGeometry->Cylinders;
                DiskInfo.Heads = pMaxGeometry->TracksPerCylinder;
                DiskInfo.BytesPerSector = pMaxGeometry->BytesPerSector;
                DiskInfo.SectorsPerTrack = pMaxGeometry->SectorsPerTrack;
                DiskInfo.TotalSpace = MaxSpace;
                DiskInfo.FreeSpace.QuadPart = -1;
                CloseHandle(hDisk);
                return TRUE;
            }
        }

        CloseHandle(hDisk);
    }

    return FALSE;
}

//
// This functions retreive the Window version information in text string
// INPUT:
//  Buffer      -- buffer to receive the text string
//  BufferSize  -- buffer size in char(in bytes on ANSI version)
// OUTPUT:
//  The size of the text string, not including the terminated NULL char
//  If the returned value is 0, GetLastError will returns the error code.
//  If the returned value is larger than BufferSize, Buffer is too small
//
DWORD
CSystemInfo::WindowsVersion(
                           TCHAR* Buffer,
                           DWORD  BufferSize
                           )
{
    if (!Buffer && BufferSize) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    TCHAR FinalText[1024];
    TCHAR Temp[LINE_LEN];
    TCHAR Build[128];

    FinalText[0] = TEXT('\0');

    LoadString(g_hInstance, IDS_WINDOWS_NT, FinalText, ARRAYLEN(FinalText));
    LoadString(g_hInstance, IDS_BUILD_NUMBER, Build, ARRAYLEN(Build));

    CSafeRegistry regWindowsNT;
    if (regWindowsNT.Open(m_hKeyMachine, REG_PATH_WINDOWS_NT, KEY_READ)) {
        DWORD Type, Size;
        Size = sizeof(Temp);

        if (regWindowsNT.GetValue(REG_VALUE_CURRENTVERSION, &Type,
                                  (PBYTE)Temp, &Size)) {
            lstrcat(FinalText, Temp);
        }

        Size = sizeof(Temp);

        if (regWindowsNT.GetValue(REG_VALUE_CSDVERSION, &Type,
                                  (PBYTE)Temp, &Size) && Size) {
            lstrcat(FinalText, TEXT(" "));
            lstrcat(FinalText, Temp);
        }

        Size = sizeof(Temp);

        if (regWindowsNT.GetValue(REG_VALUE_CURRENTBUILDNUMBER, &Type,
                                  (PBYTE)Temp, &Size) && Size) {
            DWORD FinalLen = lstrlen(FinalText);
            wsprintf(FinalText + FinalLen, Build, Temp);
        }
    }

    DWORD FinalLen = lstrlen(FinalText);

    if (BufferSize > FinalLen) {
        lstrcpyn(Buffer, FinalText, FinalLen + 1);
        SetLastError(ERROR_SUCCESS);
    }

    else {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }

    return FinalLen;
}

//
// This functions retreive a REG_SZ from the registry
// INPUT:
//  SubkeyName -- registry subkey name.
//  ValueName  -- registry value name;
//  Buffer      -- buffer to receive the string
//  BufferSize  -- buffer size in char(in bytes on ANSI version)
//  hKeyAncestory -- the key under which Subkeyname should be opened.
//
// OUTPUT:
//  The size of the text string, not including the terminated NULL char
//  If the returned value is 0, GetLastError will returns the error code.
//  If the returned value is larger than BufferSize, Buffer is too small
//
DWORD
CSystemInfo::InfoFromRegistry(
                             LPCTSTR SubkeyName,
                             LPCTSTR ValueName,
                             TCHAR* Buffer,
                             DWORD BufferSize,
                             HKEY    hKeyAncestor
                             )
{
    // validate parameters
    if (!SubkeyName || !ValueName || _T('\0') == *SubkeyName ||
        _T('\0') == *SubkeyName || (!Buffer && BufferSize)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    if (!hKeyAncestor) {
        hKeyAncestor = m_hKeyMachine;
    }

    CSafeRegistry regSubkey;

    if (regSubkey.Open(hKeyAncestor, SubkeyName)) {
        TCHAR Temp[MAX_PATH];
        DWORD Type;
        DWORD Size;
        Size = sizeof(Temp);

        if (regSubkey.GetValue(ValueName, &Type, (PBYTE)Temp, &Size) && Size) {
            Size /= sizeof(TCHAR);

            if (BufferSize > Size) {
                lstrcpy(Buffer, Temp);
            }

            return Size;
        }
    }

    SetLastError(ERROR_SUCCESS);

    return 0;
}

//
// This functions retreive the system BIOS date information in text string
// INPUT:
//  Buffer      -- buffer to receive the text string
//  BufferSize  -- buffer size in char(in bytes on ANSI version)
// OUTPUT:
//  The size of the text string, not including the terminated NULL char
//  If the returned value is 0, GetLastError will returns the error code.
//  If the returned value is larger than BufferSize, Buffer is too small
//
DWORD
CSystemInfo::SystemBiosDate(
                           TCHAR* Buffer,
                           DWORD BufferSize
                           )
{
    return InfoFromRegistry(REG_PATH_HARDWARE_SYSTEM,
                            REG_VALUE_SYSTEMBIOSDATE,
                            Buffer, BufferSize);
}


//
// This functions retreive the system BIOS version information in text string
// INPUT:
//  Buffer      -- buffer to receive the text string
//  BufferSize  -- buffer size in char(in bytes on ANSI version)
// OUTPUT:
//  The size of the text string, not including the terminated NULL char
//  If the returned value is 0, GetLastError will returns the error code.
//  If the returned value is larger than BufferSize, Buffer is too small
//
DWORD
CSystemInfo::SystemBiosVersion(
                              TCHAR* Buffer,
                              DWORD BufferSize
                              )
{
    return InfoFromRegistry(REG_PATH_HARDWARE_SYSTEM,
                            REG_VALUE_SYSTEMBIOSVERSION,
                            Buffer, BufferSize);

}

//
// This functions retreive the machine type  in text string
// INPUT:
//  Buffer      -- buffer to receive the text string
//  BufferSize  -- buffer size in char(in bytes on ANSI version)
// OUTPUT:
//  The size of the text string, not including the terminated NULL char
//  If the returned value is 0, GetLastError will returns the error code.
//  If the returned value is larger than BufferSize, Buffer is too small
//
DWORD
CSystemInfo::MachineType(
                        TCHAR* Buffer,
                        DWORD BufferSize
                        )
{
    return InfoFromRegistry(REG_PATH_HARDWARE_SYSTEM,
                            REG_VALUE_MACHINETYPE,
                            Buffer, BufferSize);
}

//
// This functions retreive the registered owner name
// INPUT:
//  Buffer      -- buffer to receive the text string
//  BufferSize  -- buffer size in char(in bytes on ANSI version)
// OUTPUT:
//  The size of the text string, not including the terminated NULL char
//  If the returned value is 0, GetLastError will returns the error code.
//  If the returned value is larger than BufferSize, Buffer is too small
//
DWORD
CSystemInfo::RegisteredOwner(
                            TCHAR* Buffer,
                            DWORD  BufferSize
                            )
{
    return InfoFromRegistry(REG_PATH_WINDOWS_NT,
                            REG_VALUE_REGISTERED_OWNER,
                            Buffer,
                            BufferSize
                           );
}

//
// This functions retreive the registered organization name
// INPUT:
//  Buffer      -- buffer to receive the text string
//  BufferSize  -- buffer size in char(in bytes on ANSI version)
// OUTPUT:
//  The size of the text string, not including the terminated NULL char
//  If the returned value is 0, GetLastError will returns the error code.
//  If the returned value is larger than BufferSize, Buffer is too small
//
DWORD
CSystemInfo::RegisteredOrganization(
                                   TCHAR* Buffer,
                                   DWORD  BufferSize
                                   )
{
    return InfoFromRegistry(REG_PATH_WINDOWS_NT,
                            REG_VALUE_REGISTERED_ORGANIZATION,
                            Buffer,
                            BufferSize
                           );
}

// This function resturns the number of processors on the computer
// INPUT:
//  NONE
// OUTPUT:
//  Number of processor.
//
DWORD
CSystemInfo::NumberOfProcessors()
{
    CSafeRegistry regCPU;
    DWORD CPUs = 0;

    if (regCPU.Open(m_hKeyMachine, REG_PATH_CPU, KEY_READ)) {
        TCHAR SubkeyName[MAX_PATH + 1];
        DWORD SubkeySize = ARRAYLEN(SubkeyName);

        while (regCPU.EnumerateSubkey(CPUs, SubkeyName, &SubkeySize)) {
            SubkeySize = ARRAYLEN(SubkeyName);
            CPUs++;
        }
    }

    return CPUs;
}

// This function returns the processor vendor in text string
// INPUT:
//  Buffer -- buffer to receive the string
//  BufferSize -- size of the buffer in char(bytes in ANSI)
// OUTPUT:
//  The size of the text string, not including the terminated NULL char
//  If the returned value is 0, GetLastError will returns the error code.
//  If the returned value is larger than BufferSize, Buffer is too small
//
//  The system assumes that all processor in the machine must
//  have the same type, therefore, this function does not take
//  processor number as a parameter.
DWORD
CSystemInfo::ProcessorVendor(
                            TCHAR* Buffer,
                            DWORD BufferSize
                            )
{
    return ProcessorInfo(REG_VALUE_CPU_VENDOR, Buffer, BufferSize);
}

// This function returns the processor type in text string
// INPUT:
//  Buffer -- buffer to receive the string
//  BufferSize -- size of the buffer in char(bytes in ANSI)
// OUTPUT:
//  The size of the text string, not including the terminated NULL char
//  If the returned value is 0, GetLastError will returns the error code.
//  If the returned value is larger than BufferSize, Buffer is too small
//
//  The system assumes that all processor in the machine must
//  have the same type, therefore, this function does not take
//  processor number as a parameter.
DWORD
CSystemInfo::ProcessorType(
                          TCHAR* Buffer,
                          DWORD BufferSize
                          )
{
    return ProcessorInfo(REG_VALUE_CPU_TYPE, Buffer, BufferSize);
}

DWORD
CSystemInfo::ProcessorInfo(
                          LPCTSTR ValueName,
                          TCHAR* Buffer,
                          DWORD  BufferSize
                          )
{
    if (!ValueName || (!Buffer && BufferSize)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    CSafeRegistry regCPU;
    DWORD CPUIndex = 0;
    TCHAR CPUInfo[MAX_PATH];
    DWORD CPUInfoSize = 0;
    DWORD Type;

    if (regCPU.Open(m_hKeyMachine, REG_PATH_CPU, KEY_READ)) {
        TCHAR CPUKey[MAX_PATH + 1];
        DWORD Size;
        Size = ARRAYLEN(CPUKey);

        // loop through all cpus until we find something interesting
        while (CPUInfoSize <= sizeof(TCHAR) &&
               regCPU.EnumerateSubkey(CPUIndex, CPUKey, &Size)) {
            CSafeRegistry regTheCPU;

            if (regTheCPU.Open(regCPU, CPUKey, KEY_READ)) {
                CPUInfoSize = sizeof(CPUInfo);
                regTheCPU.GetValue(ValueName, &Type, (PBYTE)CPUInfo, &CPUInfoSize);
            }

            CPUIndex++;
        }

        // CPUInfoSize != 0 means we find something
        if (CPUInfoSize > sizeof(TCHAR)) {
            CPUInfoSize = CPUInfoSize / sizeof(TCHAR) - 1;
            if (BufferSize > CPUInfoSize) {
                lstrcpyn(Buffer, CPUInfo, CPUInfoSize + 1);
            }

            return CPUInfoSize;
        }
    }

    return 0;
}

#if 0
DWORD
CSystemInfo::ProcessorType(
                          TCHAR* Buffer,
                          DWORD BufferSize
                          )
{
    SYSTEM_INFO SysInfo;
    GetSystemInfo(&SysInfo);
    TCHAR Format[MAX_PATH];
    TCHAR CPUType[MAX_PATH];
    TCHAR Revision[128];

    switch (SysInfo.wProcessorArchitecture) {
    case PROCESSOR_ARCHITECTURE_INTEL:
        // decode the processor level and revision
        if (3 == SysInfo.wProcessorLevel ||
            4 == SysInfo.wProcessorLevel) {
            int StringId = (3 == SysInfo.wProcessorLevel) ?
                           IDS_CPU_INTEL_386 : IDS_CPU_INTEL_486;
            LoadString(g_hInstance, StringId, CPUType, ARRAYLEN(CPUType));

            if (SysInfo.wProcessorRevision & 0xFF00 == 0xFF00) {
                LoadString(g_hInstance, IDS_CPU_REVISION_MODEL_STEPPING,
                           Format, ARRAYLEN(Format));
                wsprintf(Revision, Format,
                         ((SysInfo.wProcessorRevision & 0x00F0) > 4) - 10,
                         SysInfo.wProcessorRevision & 0x000F);
            }

            else {
                LoadString(g_hInstance, IDS_CPU_REVISION_STEPPING,
                           Format, ARRAYLEN(Format));
                wsprintf(Revision, Format,
                         (SysInfo.wProcessorRevision >> 8) + _T('A'),
                         SysInfo.wProcessorRevision & 0x00FF);
            }
        }

        else if (5 == SysInfo.wProcessorLevel) {
            LoadString(g_hInstance, IDS_CPU_INTEL_PENTIUM, CPUType, ARRAYLEN(CPUType));
            LoadString(g_hInstance, IDS_CPU_REVISION_MODEL_STEPPING,
                       Format, ARRAYLEN(Format));
            wsprintf(Revision, Format, SysInfo.wProcessorRevision >> 8,
                     SysInfo.wProcessorRevision & 0x00FF);
        }

        lstrcat(CPUType, Revision);
        break;

    case PROCESSOR_ARCHITECTURE_ALPHA:
        LoadString(g_hInstance, IDS_CPU_ALPHA, Format, ARRAYLEN(Format));
        wsprintf(CPUType, Format, SysInfo.wProcessorLevel);
        LoadString(g_hInstance, IDS_CPU_REVISION_ALPHA, Format,
                   ARRAYLEN(Format));
        wsprintf(Revision, Format, (SysInfo.wProcessorRevision >> 8) + _T('A'),
                 SysInfo.wProcessorRevision & 0x00FF);
        lstrcat(CPUType, Revision);

    default:
        CPUType[0] = _T('\0');
    }

    DWORD Size = lstrlen(CPUType);

    if (BufferSize > Size) {
        lstrcpy(Buffer, CPUType);
    }

    SetLastError(ERROR_SUCCESS);
    return Size;
}
#endif


//
// This function returns the total physical memeory in KB
// INPUT:
//  NONE
// OUTPUT:
//  Total Memory in KB
//
void
CSystemInfo::TotalPhysicalMemory(
                                ULARGE_INTEGER& Size
                                )
{
    if (m_fLocalMachine) {
        SYSTEM_BASIC_INFORMATION SysBasicInfo;
        NTSTATUS Status;
        Status = NtQuerySystemInformation(SystemBasicInformation,
                                          (PVOID)&SysBasicInfo,
                                          sizeof(SysBasicInfo),
                                          NULL);

        if (NT_SUCCESS(Status)) {
            Size.QuadPart = Int32x32To64(SysBasicInfo.PageSize,
                                         SysBasicInfo.NumberOfPhysicalPages
                                        );
        }

        else {
            MEMORYSTATUS MemoryStatus;
            GlobalMemoryStatus(&MemoryStatus);
            Size.LowPart = (ULONG)MemoryStatus.dwTotalPhys;
            Size.HighPart = 0;
        }
    }

    else {
        Size.QuadPart = 0;
        SetLastError(ERROR_SUCCESS);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\tswizard.h ===
#ifndef __TSWIZARD_H__
#define __TSWIZARD_H__

/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    tswizard.h

Abstract:

    header file for tswizard.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/

typedef enum tagFixCommand
{
    FIX_COMMAND_DONOTHING = 0,
    FIX_COMMAND_UPGRADEDRIVERS,
    FIX_COMMAND_REINSTALL,
    FIX_COMMAND_ENABLEDEVICE,
    FIX_COMMAND_STARTDEVICE,
    FIX_COMMAND_RESTARTCOMPUTER,
    FIX_COMMAND_DRIVERBLOCKED,
    FIX_COMMAND_TROUBLESHOOTER
} FIX_COMMAND, *PFIX_COMMAND;

typedef struct tagCMProblemInfo
{
    BOOL    Query;      // true if we have something to fix the problem
    FIX_COMMAND FixCommand; // command to fix the problem
    int     idInstFirst;    // instruction text string id
    int     idInstCount;    // how many instruction string id
    int     idFixit;        // fix it string id
}CMPROBLEM_INFO, *PCMPROBLEM_INFO;

class CProblemAgent
{
public:
    CProblemAgent(CDevice* pDevice, ULONG Problem, BOOL SeparateProcess);
    ~CProblemAgent()
    {}
    // retreive the problem description text
    DWORD InstructionText(LPTSTR Buffer, DWORD BufferSize);
    DWORD FixitText(LPTSTR Buffer, DWORD BufferSize);
    // fix the problem
    BOOL FixIt(HWND hwndOwner);
    BOOL UpgradeDriver(HWND hwndOwner, CDevice* pDevice);
    BOOL Reinstall(HWND hwndOwner, CDevice* pDevice);
    BOOL RestartComputer(HWND hwndOwner, CDevice* pDevice);
    BOOL EnableDevice(HWND hwndOwner, CDevice* pDevice);
    BOOL FixDriverBlocked(HWND hwndOwner, CDevice* pDevice, LPTSTR ChmFile, LPTSTR HtmlTroubleShooter);
    BOOL StartTroubleShooter(HWND hwndOwner, CDevice *pDevice, LPTSTR ChmFile, LPTSTR HtmlTroubleShooter);
    BOOL GetTroubleShooter(CDevice* pDevice, LPTSTR ChmFile, LPTSTR HtmlTroubleShooter);
    void LaunchHtlmTroubleShooter(HWND hwndOwner, LPTSTR ChmFile, LPTSTR HtmlTroubleShooter);

protected:
    CDevice*    m_pDevice;
    ULONG   m_Problem;
    int     m_idInstFirst;
    int     m_idInstCount;
    int     m_idFixit;
    BOOL    m_SeparateProcess;
    FIX_COMMAND m_FixCommand;
};

class CWizard98
{
public:
    CWizard98(HWND hwndParent, UINT MaxPages = 32);
    ~CWizard98()
    {}
    INT_PTR DoSheet() {

        return ::PropertySheet(&m_psh);
    }

    void InsertPage(HPROPSHEETPAGE hPage) {

        if (hPage && (m_psh.nPages < m_MaxPages)) {

            m_psh.phpage[m_psh.nPages++] = hPage;
        }
    }

    static INT CALLBACK WizardCallback(HWND hwndDlg, UINT uMsg, LPARAM lParam);

    PROPSHEETHEADER m_psh;

private:
    UINT m_MaxPages;
};

#endif  // #ifndef  __TSWIZARD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\tsmisc.cpp ===
/*++

Copyright (C) 1998-1999  Microsoft Corporation

Module Name:

    tsmisc.cpp

Abstract:

    This module implements Device Manager troubleshooting supporting classes

Author:

    Jason Cobb (jasonc) created

Revision History:


--*/

#include "devmgr.h"
#include "proppage.h"
#include "tsmisc.h"
#include "tswizard.h"

HPROPSHEETPAGE
CTSEnableDeviceIntroPage::Create(
    CDevice* pDevice
    )
{
    if (!m_pDevice)
    {
        ASSERT(pDevice);

        m_pDevice = pDevice;
        m_psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        m_psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_TS_ENABLE);
        m_psp.pszHeaderSubTitle = MAKEINTRESOURCE(IDS_TS_ENABLE_INFO);
        m_psp.pszTitle = MAKEINTRESOURCE(IDS_TROUBLESHOOTING_NAME);
        m_psp.lParam = (LPARAM)this;
        
        DWORD Problem, Status;
        
        if (pDevice->GetStatus(&Status, &Problem))
        {
            m_Problem = Problem;
            return CPropSheetPage::CreatePage();
        }
    }
    
    return NULL;
}

BOOL
CTSEnableDeviceIntroPage::OnWizNext()
{
    try
    {
        m_pDevice->EnableDisableDevice(m_hDlg, TRUE);
    }
    
    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_hDlg, 0, 0, 0);
    }
    
    return CPropSheetPage::OnWizNext();
}

BOOL
CTSEnableDeviceIntroPage::OnSetActive()
{
    SetDlgItemText(m_hDlg, IDC_TS_DRVDESC, m_pDevice->GetDisplayName());

    HICON hIconNew;
    hIconNew = m_pDevice->LoadClassIcon();

    if (hIconNew) {
        HICON hIconOld;
        m_IDCicon = IDC_CLASSICON;      // Save for cleanup in OnDestroy.
        hIconOld = (HICON)SendDlgItemMessage(m_hDlg, IDC_CLASSICON,
                                             STM_SETICON, (WPARAM)hIconNew,
                                             0);
        if (hIconOld) {
        
            DestroyIcon(hIconOld);
        }
    }

    PropSheet_SetWizButtons(GetParent(m_hDlg), PSWIZB_NEXT);
    return CPropSheetPage::OnSetActive();
}


HPROPSHEETPAGE
CTSEnableDeviceFinishPage::Create(
    CDevice* pDevice
    )
{
    if (!m_pDevice)
    {
        ASSERT(pDevice);

        m_pDevice = pDevice;
        m_psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        m_psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_TS_ENABLE_FINISH);
        m_psp.pszHeaderSubTitle = MAKEINTRESOURCE(IDS_TS_ENABLE_FINISH_INFO);
        m_psp.pszTitle = MAKEINTRESOURCE(IDS_TROUBLESHOOTING_NAME);
        m_psp.lParam = (LPARAM)this;
        
        DWORD Problem, Status;
        
        if (pDevice->GetStatus(&Status, &Problem))
        {
            m_Problem = Problem;
            return CPropSheetPage::CreatePage();
        }
    }
    
    return NULL;
}

BOOL
CTSEnableDeviceFinishPage::OnWizFinish()
{
    try
    {
        if (BST_CHECKED == IsDlgButtonChecked(m_hDlg, IDC_RESTART)) {
            //
            // Restart the computer
            //
            if (EnablePrivilege((PCTSTR)SE_SHUTDOWN_NAME, TRUE)) {
            
                ExitWindowsEx(EWX_REBOOT, 0);
            }
       }
    }
    
    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_hDlg, 0, 0, 0);
    }
    
    return CPropSheetPage::OnWizNext();
}

BOOL
CTSEnableDeviceFinishPage::OnSetActive()
{
    DWORD RestartFlags = m_pDevice->m_pMachine->DiGetFlags(*m_pDevice);

    SetDlgItemText(m_hDlg, IDC_TS_DRVDESC, m_pDevice->GetDisplayName());

    HICON hIconNew;
    hIconNew = m_pDevice->LoadClassIcon();

    if (hIconNew) {
        HICON hIconOld;
        m_IDCicon = IDC_CLASSICON;      // Save for cleanup in OnDestroy.
        hIconOld = (HICON)SendDlgItemMessage(m_hDlg, IDC_CLASSICON,
                                             STM_SETICON, (WPARAM)hIconNew,
                                             0);
        if (hIconOld) {
        
            DestroyIcon(hIconOld);
        }
    }

    //
    // We need to restart the machine for the enable to take affect
    //
    if (RestartFlags & (DI_NEEDRESTART | DI_NEEDREBOOT)) {

        String strAltText_1;
        strAltText_1.LoadString(g_hInstance, IDS_TS_ENABLEDEVICE_RESTART);
        SetDlgItemText(m_hDlg, IDC_TS_ENABLEDEVICE_FINISH_MSG, strAltText_1);

        ::SendMessage(GetControl(IDC_RESTART), BM_SETCHECK, BST_CHECKED, 0);

    //
    // We don't need to restart
    //
    } else {

        DWORD Problem, Status;
        
        Problem = Status = 0;

        m_pDevice->GetStatus(&Status, &Problem);

        //
        // The device is still disabled
        //
        if (CM_PROB_DISABLED == Problem) {

            String strAltText_1;
            strAltText_1.LoadString(g_hInstance, IDS_TS_ENABLEDEVICE_FAIL);
            SetDlgItemText(m_hDlg, IDC_TS_ENABLEDEVICE_FINISH_MSG, strAltText_1);

        //
        // The device has some other problem
        //
        } else if (Problem) {

            String strAltText_1;
            strAltText_1.LoadString(g_hInstance, IDS_TS_ENABLEDEVICE_PROBLEM);
            SetDlgItemText(m_hDlg, IDC_TS_ENABLEDEVICE_FINISH_MSG, strAltText_1);
            
        //
        // The device is now working
        //
        } else {

            String strAltText_1;
            strAltText_1.LoadString(g_hInstance, IDS_TS_ENABLEDEVICE_SUCCESS);
            SetDlgItemText(m_hDlg, IDC_TS_ENABLEDEVICE_FINISH_MSG, strAltText_1);
        }

        ::ShowWindow(GetControl(IDC_RESTART), SW_HIDE);
    }

    PropSheet_SetWizButtons(GetParent(m_hDlg), PSWIZB_FINISH);
    ::EnableWindow(GetDlgItem(GetParent(m_hDlg), IDCANCEL), FALSE);
    return CPropSheetPage::OnSetActive();
}


HPROPSHEETPAGE
CTSRestartComputerFinishPage::Create(
    CDevice* pDevice
    )
{
    if (!m_pDevice)
    {
        ASSERT(pDevice);

        m_pDevice = pDevice;
        m_psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        m_psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_TS_RESTART_FINISH);
        m_psp.pszHeaderSubTitle = MAKEINTRESOURCE(IDS_TS_RESTART_FINISH_INFO);
        m_psp.pszTitle = MAKEINTRESOURCE(IDS_TROUBLESHOOTING_NAME);
        m_psp.lParam = (LPARAM)this;
        
        DWORD Problem, Status;
        
        if (pDevice->GetStatus(&Status, &Problem))
        {
            m_Problem = Problem;
            return CPropSheetPage::CreatePage();
        }
    }
    
    return NULL;
}

BOOL
CTSRestartComputerFinishPage::OnWizFinish()
{
    try
    {
        if (BST_CHECKED == IsDlgButtonChecked(m_hDlg, IDC_RESTART)) {
            //
            // Restart the computer
            //
            if (EnablePrivilege((PCTSTR)SE_SHUTDOWN_NAME, TRUE)) {
            
                ExitWindowsEx(EWX_REBOOT, 0);
            }
       }
    }
    
    catch (CMemoryException* e)
    {
        e->Delete();
        MsgBoxParam(m_hDlg, 0, 0, 0);
    }
    
    return CPropSheetPage::OnWizNext();
}

BOOL
CTSRestartComputerFinishPage::OnSetActive()
{
    SetDlgItemText(m_hDlg, IDC_TS_DRVDESC, m_pDevice->GetDisplayName());

    HICON hIconNew;
    hIconNew = m_pDevice->LoadClassIcon();

    if (hIconNew) {
        HICON hIconOld;
        m_IDCicon = IDC_CLASSICON;      // Save for cleanup in OnDestroy.
        hIconOld = (HICON)SendDlgItemMessage(m_hDlg, IDC_CLASSICON,
                                             STM_SETICON, (WPARAM)hIconNew,
                                             0);
        if (hIconOld) {
        
            DestroyIcon(hIconOld);
        }
    }

    ::SendMessage(GetControl(IDC_RESTART), BM_SETCHECK, BST_CHECKED, 0);

    PropSheet_SetWizButtons(GetParent(m_hDlg), PSWIZB_FINISH);
    return CPropSheetPage::OnSetActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\tsmain.h ===
#ifndef __TSMAIN_H__
#define __TSMAIN_H__

/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    tsmain.h

Abstract:

    header file for tsmain.cpp

Author:

    William Hsieh (williamh) created

Revision History:


--*/

//
// Wizard32 command and parameter definitions
//

//
//
// INPUT:
//  pParam  -- troubleshooter parameter. The contents vary depends on
//          the command specified in the block. See below
//          for detail.
//
//
// OUTPUT:
//  TRUE -- if the function succeeded.
//  FALSE -- if the function failed. GetLastError() should be able
//        to retreive the error code


typedef enum tagTShooterCommand
{
    TSHOOTER_QUERY = 0,
    TSHOOTER_ABOUT,
    TSHOOTER_ADDPAGES
}TSHOOTER_COMMAND, *PTSHOOTER_COMMAND;

// parameter header.
typedef struct tagTShooterParamHeader
{
    DWORD cbSize;           // size of the entire structure
    TSHOOTER_COMMAND Command;       // command
}TSHOOTER_PARAMHEADER, *PTSHOOTER_PARAMHEADER;

//
// QUERY command asks the troubleshooter the following questions:
// (1). if the troubleshooter supports the given DeviceId/Problem combination.
// (2). the brief description about the troubleshooter
// (3). the ranking on the DeviceId and the problem.
// If the troubleshooter does not support the device id and problem
// combination, it should resturn FALSE and set the error code
// to ERROR_INVALID_FUNCTION. The DescBuffer and DescBufferSize
// can be ignored. If the provided DescBuffer is too small, it should
// fill DescBufferSize with the required size, set the error code
// to ERROR_INSUFFICIENT_BUFFER and return FALSE.
//
// parameter definition for TSHOOTER_QUERY command
//
// The Header.Command  must be TSHOOTER_QUERY;
// The header.cbSize must be sizeof(TSHOOTER_QUERY_PARAM);
//
// IN DeviceId  -- device instance id
// IN Problem   -- Configuration manager defined problem number
// IN OUT DescBuffer -- buffer to receive the troubleshooter description text
// IN OUT DescBufferSize -- Description buffer size in char(byte for ANSI)
//              Troubleshooter should fill this field with required
//              size on return.
// OUT DeviceRank   -- to receive the device ranking
// OUT ProblemRank -- to receive the problem ranking
//
//
typedef struct tagTShooterQueryParam
{
    TSHOOTER_PARAMHEADER    Header;
    LPCTSTR         DeviceId;
    ULONG           Problem;
    LPTSTR          DescBuffer;
    DWORD           DescBufferSize;
    DWORD           DeviceRank;
    DWORD           ProblemRank;
}TSHOOTER_QUERYPARAM, *PTSHOOTER_QUERYPARAM;

// The TSHOOTER_ABOUT asks the troubleshooter to display its about dialog box.
// The about dialog box should tell user what the troubleshooter is all about.
//
// The about dialog box is supposed to be Modal. If the troubleshooter
// implements a modaless about dialog box, it should disable
// the given hwndOwner after the dialog box is created and reenable
// it after the dialog box is destroyed.
//
// parameter definition for ABOUT troubleshooter command
//
// Header.Command must be TSHOOTER_ABOUT;
// Header.cbSize must be sizeof(TSHOOTER_ABOUT_PARAM);
//
// IN hwndOwner -- the window handle to serve as the owner window
//         of the troubleshooter about dialog box
//
//
typedef struct tagTShooterAboutParam
{
    TSHOOTER_PARAMHEADER    Header;
    HWND            hwndOwner;
}TSHOOTER_ABOUTPARAM, *PTSHOOTER_ABOUTPARAM;

//
// The TSHOOTER_ADDPAGES asks the troubleshooter to add its wizard
// pages to the provided property sheet header.
//
//
// parameter definition for ADDPAGES troubleshooter command
//
// Header.Command must be TSHOOTER_ADDPAGRES;
// Header.cbSize must be sizeof(TSHOOTER_ADDPAGES_PARAM);
//
// IN DeviceId  -- the hardware id of the device
// IN Problem   -- Configuration Manager defined problem number
// IN OUT ppsh  -- property sheet header to which the troubleshooter
//         add its pages
// IN MaxPages  -- total pages alloated for the ppsh.
//         The troubleshooter should not add more than
//         (MaxPages - ppsh.nPages) pages
//

typedef struct tagTShooterAddPagesParam
{
    TSHOOTER_PARAMHEADER    Header;
    LPCTSTR         DeviceId;
    ULONG           Problem;
    LPPROPSHEETHEADER       PropSheetHeader;
    DWORD           MaxPages;
}TSHOOTER_ADDPAGESPARAM, *PTSHOOTER_ADDPAGESPARAM;

// Each Troubleshooting wizard must provide an entry point for Device Manager
// to call:

typedef BOOL (APIENTRY *WIZARDENTRY)(PTSHOOTER_PARAMHEADER pParam);



typedef enum tagTShooterWizadType
{
    TWT_ANY = 0,                // any type of troubleshooter wizard
    TWT_PROBLEM_SPECIFIC,           // problem specific wizards
    TWT_CLASS_SPECIFIC,             // class specific wizards
    TWT_GENERAL_PURPOSE,            // general purpose
    TWT_DEVMGR_DEFAULT              // device manager default
}TSHOOTERWIZARDTYPE, *PTSHOOTERWIZARTYPE;


//
// class that represent a wizard32 troubleshooter
//
class CWizard
{
public:
    CWizard(HMODULE hWizardDll, FARPROC WizardEntry)
    : m_WizardEntry((WIZARDENTRY)WizardEntry),
      m_hWizardDll(hWizardDll),
      m_Problem(0),
      m_DeviceRank(0),
      m_ProblemRank(0),
      m_AddedPages(0),
      m_pDevice(NULL)
    {}
    ~CWizard()
    {
        if (m_hWizardDll)
        FreeLibrary(m_hWizardDll);
    }
    LPCTSTR GetDescription()
    {
        return m_strDescription.IsEmpty() ? NULL : (LPCTSTR)m_strDescription;
    }
    virtual BOOL Query(CDevice* pDevice, ULONG Problem);
    virtual BOOL About(HWND hwndOwner);
    virtual BOOL AddPages(LPPROPSHEETHEADER ppsh, DWORD MaxPages);
    ULONG   DeviceRank()
    {
        return m_DeviceRank;
    }
    ULONG   ProblemRank()
    {
        return m_ProblemRank;
    }
    UINT    m_AddedPages;
protected:
    WIZARDENTRY m_WizardEntry;
    HINSTANCE   m_hWizardDll;
    String  m_strDescription;
    ULONG   m_Problem;
    ULONG   m_DeviceRank;
    ULONG   m_ProblemRank;
    CDevice*    m_pDevice;
};


//
// Class that collects all available troubleshooter
//
class CWizardList
{
public:
    CWizardList(TSHOOTERWIZARDTYPE Type = TWT_ANY) : m_Type(Type)
    {}
    ~CWizardList();
    BOOL Create(CDevice* pDevice, ULONG Problem);
    int NumberOfWizards()
    {
    return m_listWizards.GetCount();
    }
    BOOL GetFirstWizard(CWizard** ppWizard, PVOID* pContext);
    BOOL GetNextWizard(CWizard** ppWizard, PVOID& Context);
private:
    BOOL CreateWizardsFromStrings(LPTSTR msz, CDevice* pDevice, ULONG Problem);
    CList<CWizard*, CWizard*> m_listWizards;
    TSHOOTERWIZARDTYPE      m_Type;
};

//
// class that represents the troubleshooter wizard introduction page
//
class CWizardIntro : public CPropSheetPage
{
public:
    CWizardIntro() : m_pDevice(NULL), m_hFontBold(NULL),
             m_hFontBigBold(NULL),
             m_pSelectedWizard(NULL), m_Problem(0),
             CPropSheetPage(g_hInstance, IDD_WIZINTRO)
    {
    }
    virtual ~CWizardIntro()
    {
        if (m_hFontBold)
        DeleteObject(m_hFontBold);
        if (m_hFontBigBold)
        DeleteObject(m_hFontBigBold);
    }
    virtual BOOL OnInitDialog(LPPROPSHEETPAGE ppsp);
    virtual BOOL OnWizNext();
    virtual BOOL OnSetActive();
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    HPROPSHEETPAGE Create(CDevice* pDevice);
private:
    CDevice*    m_pDevice;
    HFONT   m_hFontBold;
    HFONT   m_hFontBigBold;
    CWizardList m_Wizards;
    ULONG   m_Problem;
    CWizard*    m_pSelectedWizard;
};


//
// class that represents the troubleshooter property sheet
//
class CWizard98
{
public:
    CWizard98(HWND hwndParent, UINT MaxPages = 32);

    BOOL CreateIntroPage(CDevice* pDevice);
    UINT GetMaxPages()
    {
        return m_MaxPages;
    }
    INT_PTR DoSheet()
    {
        return ::PropertySheet(&m_psh);
    }
    PROPSHEETHEADER m_psh;
private:
    CDevice* m_pDevice;
    UINT    m_MaxPages;
};



class CTSLauncher
{
public:
    CTSLauncher() : m_hTSL(NULL)
    {}
    ~CTSLauncher()
    {
        Close();
    }
    BOOL Open(LPCTSTR DeviceId, const GUID& ClassGuid, ULONG Problem)
    {
        return FALSE;
    }
    BOOL Close()
    {
        m_hTSL = NULL;
        return TRUE;
    }
    BOOL Go()
    {
        return FALSE;
    }
    BOOL EnumerateStatus(int Index, DWORD& Status)
    {
        return FALSE;
    }
private:
    HANDLE   m_hTSL;
};

#if 0

typedef enum tagFixItCommand
{
    FIXIT_COMMAND_DONOTHING = 0,
    FIXIT_COMMAND_UPGRADEDRIVERS,
    FIXIT_COMMAND_REINSTALL,
    FIXIT_COMMAND_ENABLEDEVICE
    FIXIT_COMMAND_RESTARTCOMPUTER
} FIXIT_COMMAND, *PFIXIT_COMMAND;

class CProblemAgent
{
public:
    CProblemAgent(CDevice* pDevice, ULONG Problem, ULONG Status);
    ~CProblemAgent();
    // retreive the problem description text
    LPCTSTR ProblemText()
    {
        return m_strDescription.IsEmpty() ? NULL : (LPCTSTR)m_strDescription;
    }
    LPCTSTR InstructionText()
    {
        return m_strInstruction.IsEmpty() ? NULL : (LPCTSTR)m_strInstruction;
    }
    // fix the problem
    virtual BOOL FixIt(HWND hwndOwner)
    {
        return TRUE;
    }
protected:
    BOOL UpdateDriver(HWND hwndOwner, m_pDevice);
    BOOL Reinstall(HWND hwndOwner);
    BOOL RestartComputer(HWND hwndOwner);
    BOOL EnableDevice()
    CDevice*    m_pDevice;
    ULONG   m_Problem;
    ULONG   m_Status;
    String  m_strDescription;
    String  m_strInstruction;
    FIXITCOMMAND m_Command;
};

#endif



INT_PTR
StartTroubleshootingWizard(
    HWND hWndParent,
    CDevice* pDevice
    );
#endif // __PROBLEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\tswizard.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    tsmain.cpp

Abstract:

    This module implements Device Manager troubleshooting supporting classes

Author:

    William Hsieh (williamh) created

Revision History:


--*/
//


#include "devmgr.h"
#include "proppage.h"
#include "devdrvpg.h"
#include "tsmisc.h"
#include "tswizard.h"
#include "cdriver.h"

const CMPROBLEM_INFO ProblemInfo[DEVMGR_NUM_CM_PROB] =
{
    // no problem
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_WORKING_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_NOT_CONFIGURED
    {
        TRUE,
        FIX_COMMAND_REINSTALL,
        IDS_INST_REINSTALL,
        1,
        IDS_FIXIT_REINSTALL
    },
    // CM_PROB_DEVLOADER_FAILED
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_OUT_OF_MEMORY
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_IS_WRONG_TYPE
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_LACKED_ARBITRATOR
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_BOOT_CONFIG_CONFLICT
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_FAILED_FILTER (Never used)
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_DEVLOADER_NOT_FOUND (Never used)
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_INVALID_DATA
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_FAILED_START
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_LIAR (Never used)
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_NORMAL_CONFLICT
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_NOT_VERIFIED (Never used)
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_NEED_RESTART
    {
        TRUE,
        FIX_COMMAND_RESTARTCOMPUTER,
        IDS_INST_RESTARTCOMPUTER,
        1,
        IDS_FIXIT_RESTARTCOMPUTER
    },
    // CM_PROB_REENUMERATION
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_PARTIAL_LOG_CONF
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_UNKNOWN_RESOURCE
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_REINSTALL
    {
        TRUE,
        FIX_COMMAND_REINSTALL,
        IDS_INST_REINSTALL,
        1,
        IDS_FIXIT_REINSTALL
    },
    // CM_PROB_REGISTRY (Never used)
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_VXDLDR (Never used)
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
     // CM_PROB_WILL_BE_REMOVED (Never used)
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_DISABLED
    {
        TRUE,
        FIX_COMMAND_ENABLEDEVICE,
        IDS_INST_ENABLEDEVICE,
        1,
        IDS_FIXIT_ENABLEDEVICE
    },
     // CM_PROB_DEVLOADER_NOT_READY (Never used)
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
     // CM_PROB_DEVICE_NOT_THERE
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
     // CM_PROB_MOVED
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
     // CM_PROB_TOO_EARLY
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
     // CM_PROB_NO_VALID_LOG_CONF
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
     // CM_PROB_FAILED_INSTALL
    {
        TRUE,
        FIX_COMMAND_REINSTALL,
        IDS_INST_REINSTALL,
        1,
        IDS_FIXIT_REINSTALL
    },
     // CM_PROB_HARDWARE_DISABLED
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
     // CM_PROB_CANT_SHARE_IRQ
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_FAILED_ADD
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_DISABLED_SERVICE
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_TRANSLATION_FAILED
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_NO_SOFTCONFIG
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_BIOS_TABLE
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_IRQ_TRANSLATION_FAILED
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_FAILED_DRIVER_ENTRY
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_DRIVER_FAILED_PRIOR_UNLOAD 
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_DRIVER_FAILED_LOAD
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_DRIVER_SERVICE_KEY_INVALID
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_LEGACY_SERVICE_NO_DEVICES
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_DUPLICATE_DEVICE
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_FAILED_POST_START
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_HALTED
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_PHANTOM
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_SYSTEM_SHUTDOWN
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_HELD_FOR_EJECT
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_DRIVER_BLOCKED
    {
        TRUE,
        FIX_COMMAND_DRIVERBLOCKED,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // CM_PROB_REGISTRY_TOO_LARGE
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
    // UNKNOWN PROBLEM
    {
        TRUE,
        FIX_COMMAND_TROUBLESHOOTER,
        IDS_INST_TROUBLESHOOTER,
        1,
        IDS_FIXIT_TROUBLESHOOTER
    },
};

//
// CProblemAgent implementation
//
CProblemAgent::CProblemAgent(
    CDevice* pDevice,
    ULONG Problem,
    BOOL SeparateProcess
    )
{
    m_pDevice = pDevice;
    m_Problem = Problem;

    ASSERT(pDevice);

    m_idInstFirst = ProblemInfo[min(Problem, DEVMGR_NUM_CM_PROB-1)].idInstFirst;
    m_idInstCount = ProblemInfo[min(Problem, DEVMGR_NUM_CM_PROB-1)].idInstCount;
    m_idFixit = ProblemInfo[min(Problem, DEVMGR_NUM_CM_PROB-1)].idFixit;
    m_FixCommand = ProblemInfo[min(Problem, DEVMGR_NUM_CM_PROB-1)].FixCommand;
    m_SeparateProcess = SeparateProcess;
}

DWORD
CProblemAgent::InstructionText(
    LPTSTR Buffer,
    DWORD  BufferSize
    )
{
    TCHAR LocalBuffer[512];
    LocalBuffer[0] = TEXT('\0');
    SetLastError(ERROR_SUCCESS);

    if (m_idInstFirst)
    {
        TCHAR Temp[256];

        for (int i = 0; i < m_idInstCount; i++)
        {
            LoadString(g_hInstance, m_idInstFirst + i, Temp, ARRAYLEN(Temp));
            lstrcat(LocalBuffer, Temp);
        }
    }

    DWORD Len = lstrlen(LocalBuffer);

    if (BufferSize > Len) {
        lstrcpyn(Buffer, LocalBuffer, Len + 1);
    }

    else if (Len) {

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }

    return Len;
}

DWORD
CProblemAgent::FixitText(
    LPTSTR Buffer,
    DWORD BufferSize
    )
{
    if (!Buffer && BufferSize)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    SetLastError(ERROR_SUCCESS);

    if (m_idFixit)
    {
        return LoadResourceString(m_idFixit, Buffer, BufferSize);
    }

    return 0;
}

BOOL
CProblemAgent::FixIt(
    HWND hwndOwner
    )
/*++

    Lanuches a troubleshooter based on the m_FixCommand.
    
Arguments:

    hwndOwner - Parent window handle
    
Return Value:
    TRUE if launching the troubleshooter changed the device in some way
    so that the UI on the general tab needs to be refreshed.
        
    FALSE if launching the troubleshooter did not change the device in
    any way.

--*/
{
    BOOL Result;
    SP_TROUBLESHOOTER_PARAMS tsp;
    DWORD RequiredSize;

    tsp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    tsp.ClassInstallHeader.InstallFunction = DIF_TROUBLESHOOTER;
    tsp.ChmFile[0] = TEXT('\0');
    tsp.HtmlTroubleShooter[0] = TEXT('\0');

    m_pDevice->m_pMachine->DiSetClassInstallParams(*m_pDevice,
            &tsp.ClassInstallHeader,
            sizeof(tsp)
            );

    //
    // If the class installer retuns NO_ERROR (SetupDiCallClassInstaller returns TRUE)
    // then don't launch the default troubleshooters because the class installer has
    // launched it's own troubleshooter
    //
    if (m_pDevice->m_pMachine->DiCallClassInstaller(DIF_TROUBLESHOOTER, *m_pDevice)) {

        return TRUE;
    
    } else if (ERROR_DI_DO_DEFAULT == GetLastError()) {

        m_pDevice->m_pMachine->DiGetClassInstallParams(*m_pDevice,
                                                       &tsp.ClassInstallHeader,
                                                       sizeof(tsp),
                                                       &RequiredSize
                                                       );
    }

    switch (m_FixCommand)
    {
    case FIX_COMMAND_UPGRADEDRIVERS:
        Result = UpgradeDriver(hwndOwner, m_pDevice);
        break;

    case FIX_COMMAND_REINSTALL:
        Result = Reinstall(hwndOwner, m_pDevice);
        break;

    case FIX_COMMAND_ENABLEDEVICE:
        Result = EnableDevice(hwndOwner, m_pDevice);
        break;

    case FIX_COMMAND_STARTDEVICE:
        Result = EnableDevice(hwndOwner, m_pDevice);
        break;

    case FIX_COMMAND_RESTARTCOMPUTER:
        Result = RestartComputer(hwndOwner, m_pDevice);
        break;

    case FIX_COMMAND_DRIVERBLOCKED:
        FixDriverBlocked(hwndOwner, m_pDevice, tsp.ChmFile, tsp.HtmlTroubleShooter);
        break;

    case FIX_COMMAND_TROUBLESHOOTER:
        Result = StartTroubleShooter(hwndOwner, m_pDevice, tsp.ChmFile, tsp.HtmlTroubleShooter);
        break;

    case FIX_COMMAND_DONOTHING:
        Result = TRUE;
        break;

    default:
        Result = FALSE;
    }

    return Result;
}


BOOL
CProblemAgent::UpgradeDriver(
    HWND hwndOwner,
    CDevice* pDevice
    )
{
    DWORD Status = 0, Problem = 0;

    if (!pDevice || !pDevice->m_pMachine->IsLocal() || !g_HasLoadDriverNamePrivilege) {
        // Must be an admin and on the local machine to update a device.

        ASSERT(FALSE);
        return FALSE;
    }

    //
    // If the device has the DN_WILL_BE_REMOVED flag set and the user is
    // attempting to update the driver then we will prompt them for a 
    // reboot and include text in the prompt that explains this device
    // is in the process of being removed.
    //
    if (pDevice->GetStatus(&Status, &Problem) &&
        (Status & DN_WILL_BE_REMOVED)) {

        PromptForRestart(hwndOwner, DI_NEEDRESTART, IDS_WILL_BE_REMOVED_NO_UPDATE_DRIVER);
        
        return FALSE;
    }

    pDevice->m_pMachine->InstallDevInst(hwndOwner, pDevice->GetDeviceID(), TRUE, NULL);

    return TRUE;
}

BOOL
CProblemAgent::Reinstall(
    HWND hwndOwner,
    CDevice* pDevice
    )
{

    return UpgradeDriver(hwndOwner, pDevice);
}

BOOL
CProblemAgent::EnableDevice(
    HWND hwndOwner,
    CDevice* pDevice
    )
{
    CWizard98 theSheet(hwndOwner);

    CTSEnableDeviceIntroPage* pEnableDeviceIntroPage = new CTSEnableDeviceIntroPage;

    if (!pEnableDeviceIntroPage) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    HPROPSHEETPAGE hIntroPage = pEnableDeviceIntroPage->Create(pDevice);
    theSheet.InsertPage(hIntroPage);

    CTSEnableDeviceFinishPage* pEnableDeviceFinishPage = new CTSEnableDeviceFinishPage;

    if (!pEnableDeviceFinishPage) {

        if (pEnableDeviceIntroPage) {
            delete pEnableDeviceIntroPage;
        }
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    
    HPROPSHEETPAGE hFinishPage = pEnableDeviceFinishPage->Create(pDevice);
    theSheet.InsertPage(hFinishPage);

    return (BOOL)theSheet.DoSheet();
}

BOOL
CProblemAgent::RestartComputer(
    HWND hwndOwner,
    CDevice* pDevice
    )
{
    HWND hwndFocus;

    if (!pDevice || !pDevice->m_pMachine)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    hwndFocus = GetFocus();

    CWizard98 theSheet(hwndOwner);

    CTSRestartComputerFinishPage* pRestartComputerFinishPage = new CTSRestartComputerFinishPage;

    if (!pRestartComputerFinishPage) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    HPROPSHEETPAGE hPage = pRestartComputerFinishPage->Create(pDevice);
    theSheet.InsertPage(hPage);

    theSheet.DoSheet();

    // restore focus
    if (hwndFocus) {

        SetFocus(hwndFocus);
    }

    return TRUE;
}

BOOL
CProblemAgent::FixDriverBlocked(
    HWND hwndOwner,
    CDevice* pDevice,
    LPTSTR ChmFile,
    LPTSTR HtmlTroubleShooter
    )
{
    CDriver *pDriver = NULL;
    CDriverFile* pDrvFile = NULL;
    PVOID Context;
    LPCTSTR pBlockDriverHtmlHelpID = NULL;

    *ChmFile = TEXT('\0');

    pDriver = pDevice->CreateDriver();

    if (pDriver) {
        //
        // Build up a list of function and filter drivers for this device.
        //
        pDriver->BuildDriverList(NULL, TRUE);

        //
        // Enumerate through the list of drivers for this device until we find
        // one that has a blocked driver html help ID.
        //
        pDriver->GetFirstDriverFile(&pDrvFile, Context);

	if (pDrvFile) {
            do {
                if (pDrvFile && 
                    ((pBlockDriverHtmlHelpID = pDrvFile->GetBlockedDriverHtmlHelpID()) != NULL) &&
                    (*pBlockDriverHtmlHelpID != TEXT('\0'))) {
                    //
                    // Found a Blocked Driver html help ID so break out of the loop.
                    //
                    lstrcpy(ChmFile, pBlockDriverHtmlHelpID);
                    break;
                }

            } while (pDriver->GetNextDriverFile(&pDrvFile, Context));
        }
    }

    if (!(*ChmFile)) {
        //
        // If we couldn't get a troubleshooter for one of the drivers then just
        // do the default troubleshooter code.
        //
        GetTroubleShooter(pDevice, ChmFile, HtmlTroubleShooter);
    }

    LaunchHtlmTroubleShooter(hwndOwner, ChmFile, HtmlTroubleShooter);

    if (pDriver) {
        delete pDriver;
    }

    return TRUE;
}

BOOL
ParseTroubleShooter(
    LPCTSTR TSString,
    LPTSTR ChmFile,
    LPTSTR HtmlTroubleShooter
    )
{
    //
    // Berify parameters
    //
    if (!TSString || TEXT('\0') == TSString[0] || !ChmFile || !HtmlTroubleShooter)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Make a copy of the string because we have to party on it
    //
    TCHAR* psz = new TCHAR[lstrlen(TSString) + 1];

    if (!psz) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    lstrcpy(psz, TSString);

    LPTSTR ChmName = NULL;
    LPTSTR ChmNameEnd;
    LPTSTR HtmName = NULL;
    LPTSTR HtmNameEnd;
    LPTSTR p;

    p = psz;

    SetLastError(ERROR_SUCCESS);

    //
    // the format of the  string is "chmfile, htmlfile"
    //
    p = SkipBlankChars(p);

    if (TEXT('\0') != *p) {

        //
        // looking for CHM file which could be enclosed
        // inside double quote chars.
        // NOTE: not double quote chars inside double quoted string is allowed.
        //
        if (TEXT('\"') == *p) {

            ChmName = ++p;
        
            while (TEXT('\"') != *p && TEXT('\0') != *p) {
                
                p++;
            }

            ChmNameEnd = p;
        
            if (TEXT('\"') == *p) {

                p++;
            }
        
        } else {

            ChmName = p;
        
            while ((TEXT('\0') != *p) && 
                   !IsBlankChar(*p) && 
                   (TEXT(',') != *p)
                   ) {

                p++;
            }

            ChmNameEnd = p;
        }

        //
        // looking for ','
        //
        if (TEXT('\0') != *p) {
        
            p = SkipBlankChars(p);
    
            if (TEXT('\0') != *p && TEXT(',') == *p) {
    
                p = SkipBlankChars(p + 1);
    
                if (TEXT('\0') != *p) {
    
                    HtmName = p++;
    
                    while (!IsBlankChar(*p) && TEXT('\0') != *p) {
    
                        p++;
                    }
    
                    HtmNameEnd = p;
                }
            }
        }
    }

    if (HtmName) {
        
        *HtmNameEnd = TEXT('\0');
        lstrcpy(HtmlTroubleShooter, HtmName);
    }

    if (ChmName){
        
        *ChmNameEnd = TEXT('\0');
        lstrcpy(ChmFile, ChmName);
    }

    if (HtmName || ChmName) {

        return TRUE;
    }

    return FALSE;
}

//
// This function looks for CHM and HTM troubleshooter files for this device.
//
// The troubleshoooter string value has the following form:
//  "TroubleShooter-xx" = "foo.chm, bar.htm"
// where xx is the problem code for the device
//
// It first looks under the devices driver key.
// If nothing is found there it looks under the class key.
// If nothing is there it looks in the default troubleshooter location
// If nothing is there it just displays the hard-coded generic troubleshooter.
//
BOOL
CProblemAgent::GetTroubleShooter(
    CDevice* pDevice,
    LPTSTR ChmFile,
    LPTSTR HtmlTroubleShooter
    )
{
    BOOL Result = FALSE;
    DWORD Status, Problem = 0;
    TCHAR TroubleShooterKey[MAX_PATH];
    TCHAR TroubleShooterValue[MAX_PATH * 2];
    HKEY hKey;

    try {

        if (pDevice->GetStatus(&Status, &Problem)) {

            //
            // If the device is a phantom device, use the CM_PROB_DEVICE_NOT_THERE
            //
            if (pDevice->IsPhantom()) {

                Problem = CM_PROB_PHANTOM;
            }

            //
            // If the device is not started and no problem is assigned to it
            // fake the problem number to be failed start.
            //
            if (!(Status & DN_STARTED) && !Problem && pDevice->IsRAW()) {

                Problem = CM_PROB_FAILED_START;
            }
        }

        wsprintf(TroubleShooterKey, TEXT("TroubleShooter-%d"), Problem);

        //
        // First check the devices driver key
        //
        hKey = pDevice->m_pMachine->DiOpenDevRegKey(*pDevice, DICS_FLAG_GLOBAL,
                     0, DIREG_DRV, KEY_READ);

        if (INVALID_HANDLE_VALUE != hKey)
        {
            DWORD regType;
            DWORD Len = sizeof(TroubleShooterValue);

            CSafeRegistry regDrv(hKey);

            //
            // Get the TroubleShooter value from the driver key
            //
            if (regDrv.GetValue(TroubleShooterKey, &regType,
                        (PBYTE)TroubleShooterValue,
                        &Len))
            {
                if (ParseTroubleShooter(TroubleShooterValue, ChmFile, HtmlTroubleShooter)) {

                    Result = TRUE;
                }
            }
        }

        //
        // If we don't have a TroubleShooter yet then try the class key
        //
        if (!Result) {

                        CClass* pClass = pDevice->GetClass();
                        ASSERT(pClass);
                        LPGUID pClassGuid = *pClass;

            hKey = pDevice->m_pMachine->DiOpenClassRegKey(pClassGuid, KEY_READ, DIOCR_INSTALLER);

            if (INVALID_HANDLE_VALUE != hKey)
            {
                DWORD regType;
                DWORD Len = sizeof(TroubleShooterValue);

                CSafeRegistry regClass(hKey);

                // get the TroubleShooter value from the class key
                if (regClass.GetValue(TroubleShooterKey, &regType,
                            (PBYTE)TroubleShooterValue,
                            &Len))
                {
                    if (ParseTroubleShooter(TroubleShooterValue, ChmFile, HtmlTroubleShooter)) {

                        Result = TRUE;
                    }
                }
            }
        }

        //
        // If we still don't have a TroubleShooter then try the default TroubleShooters
        // key.
        //
        if (!Result) {

            CSafeRegistry regDevMgr;
            CSafeRegistry regTroubleShooters;

            if (regDevMgr.Open(HKEY_LOCAL_MACHINE, REG_PATH_DEVICE_MANAGER) &&
                regTroubleShooters.Open(regDevMgr, REG_STR_TROUBLESHOOTERS)) {

                DWORD regType;
                DWORD Len = sizeof(TroubleShooterValue);

                // get the TroubleShooter value from the default TroubleShooters key
                if (regTroubleShooters.GetValue(TroubleShooterKey, &regType,
                            (PBYTE)TroubleShooterValue,
                            &Len))
                {
                    if (ParseTroubleShooter(TroubleShooterValue, ChmFile, HtmlTroubleShooter)) {

                        Result = TRUE;
                    }
                }
            }
        }

        //
        // And finally, if still not TroubleShooter we will just use the default one
        //
        if (!Result) {

            lstrcpy(ChmFile, TEXT("hcp://help/tshoot/hdw_generic.htm"));
            HtmlTroubleShooter[0] = TEXT('\0');
            Result = TRUE;
        }
    }

    catch (CMemoryException* e)
    {
        e->Delete();

        Result = FALSE;
    }

    return Result;
}

void
CProblemAgent::LaunchHtlmTroubleShooter(
    HWND hwndOwner,
    LPTSTR ChmFile,
    LPTSTR HtmlTroubleShooter
    )
{
    String StringCommand;

    if ((!ChmFile || !*ChmFile) &&
        (!HtmlTroubleShooter || !*HtmlTroubleShooter)) {
        //
        // If both ChmFile and HtmlTroubleShooter are NULL then
        // bail out.
        //
        return;
    }

    //
    // There are two different types of troubleshooters that can be launched.  
    // HelpCenter troubleshooters and HtmlHelp troubleshooters. This API tells
    // the difference by checking if a HtmlTroubleShooter was specified or not.
    // If only a ChmFile was specified and it starts with hcp:// then this API
    // will send the entire string to help center. Otherwise we send the string
    // to HtmlHelp (or hh.exe if it is launched as a separate process).
    //
    if ((!HtmlTroubleShooter || (HtmlTroubleShooter[0] == TEXT('\0'))) &&
        (StrCmpNI(ChmFile, TEXT("hcp://"), lstrlen(TEXT("hcp://"))) == 0)) {

        //
        // This is a new HelpCenter troubleshooter
        //
        StringCommand.Format(TEXT(" -url %s"), ChmFile);

        ShellExecute(hwndOwner, 
                     TEXT("open"),
                     TEXT("HELPCTR.EXE"),
                     (LPTSTR)StringCommand, 
                     NULL, 
                     SW_SHOWNORMAL
                     );

    } else {
    
        //
        // This is an old HtlmHelp troubleshooter
        //
        if (m_SeparateProcess) {
    
            STARTUPINFO si;
            PROCESS_INFORMATION pi;
    
            StringCommand.Format(TEXT("hh.exe ms-its:%s::/%s"), ChmFile, HtmlTroubleShooter);
    
            ZeroMemory(&si, sizeof(si));
            si.cb = sizeof(si);
            si.dwFlags = STARTF_USESHOWWINDOW;
            si.wShowWindow = SW_NORMAL;
    
            if (CreateProcess(NULL, (LPTSTR)StringCommand, NULL, NULL, FALSE, 0, 0, NULL, &si, &pi)) {
    
                CloseHandle(pi.hThread);
                CloseHandle(pi.hProcess);
            }
    
    
        } else {
    
            HtmlHelp(hwndOwner, ChmFile, HH_DISPLAY_TOPIC, (LPARAM)HtmlTroubleShooter);
        }
    }
}


BOOL
CProblemAgent::StartTroubleShooter(
    HWND hwndOwner,
    CDevice* pDevice,
    LPTSTR ChmFile,
    LPTSTR HtmlTroubleShooter
    )
{
    //
    // If the class installers or one of the co-installers returned
    // ERROR_DI_DO_DEFAULT then verify that they filled in either the ChmFile
    // or the HtmlTroubleShooter, or both.
    //
    if ((ERROR_DI_DO_DEFAULT == GetLastError()) &&
        (((ChmFile[0] != TEXT('\0')) ||
         (HtmlTroubleShooter[0] != TEXT('\0'))))) {

        LaunchHtlmTroubleShooter(hwndOwner, ChmFile, HtmlTroubleShooter);

    } else {

        //
        // Get CHM file and TroubleShooter file from the registry
        //
        if (GetTroubleShooter(pDevice, ChmFile, HtmlTroubleShooter)) {

            LaunchHtlmTroubleShooter(hwndOwner, ChmFile, HtmlTroubleShooter);
        }
    }

    //
    // Return FALSE since launching the troubleshooter does not change the device
    // in any way.
    //
    return FALSE;
}

CWizard98::CWizard98(
    HWND hwndParent,
    UINT MaxPages
    )
{
    m_MaxPages = 0;

    if (MaxPages && MaxPages <= 32) {

        m_MaxPages = MaxPages;
        memset(&m_psh, 0, sizeof(m_psh));
        m_psh.hInstance = g_hInstance;
        m_psh.hwndParent = hwndParent;
        m_psh.phpage = new HPROPSHEETPAGE[MaxPages];
        m_psh.dwSize = sizeof(m_psh);
        m_psh.dwFlags = PSH_WIZARD | PSH_USEICONID | PSH_USECALLBACK | PSH_WIZARD97 | PSH_WATERMARK | PSH_STRETCHWATERMARK | PSH_HEADER;
        m_psh.pszbmWatermark = MAKEINTRESOURCE(IDB_WATERMARK);
        m_psh.pszbmHeader = MAKEINTRESOURCE(IDB_BANNER);
            PSH_STRETCHWATERMARK;
        m_psh.pszIcon = MAKEINTRESOURCE(IDI_DEVMGR);
        m_psh.pszCaption = MAKEINTRESOURCE(IDS_TROUBLESHOOTING_NAME);
        m_psh.pfnCallback = CWizard98::WizardCallback;
    }
}

INT
CWizard98::WizardCallback(
    IN HWND             hwndDlg,
    IN UINT             uMsg,
    IN LPARAM           lParam
    )
/*++

Routine Description:

    Call back used to remove the "?" from the wizard page.

Arguments:

    hwndDlg - Handle to the property sheet dialog box.

    uMsg - Identifies the message being received. This parameter
            is one of the following values:

            PSCB_INITIALIZED - Indicates that the property sheet is
            being initialized. The lParam value is zero for this message.

            PSCB_PRECREATE      Indicates that the property sheet is about
            to be created. The hwndDlg parameter is NULL and the lParam
            parameter is a pointer to a dialog template in memory. This
            template is in the form of a DLGTEMPLATE structure followed
            by one or more DLGITEMTEMPLATE structures.

    lParam - Specifies additional information about the message. The
            meaning of this value depends on the uMsg parameter.

Return Value:

    The function returns zero.

--*/
{

    switch( uMsg ) {

    case PSCB_INITIALIZED:
        break;

    case PSCB_PRECREATE:
        if( lParam ){

            DLGTEMPLATE *pDlgTemplate = (DLGTEMPLATE *)lParam;
            pDlgTemplate->style &= ~(DS_CONTEXTHELP | WS_SYSMENU);
        }
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\utils.h ===
#ifndef __UTILS__H
#define __UTILS__H
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    utils.h

Abstract:

    This module declares utilities classes

Author:

    William Hsieh (williamh) created

Revision History:


--*/

//
// Memory allocation exception class
//
class CMemoryException
{
public:
    CMemoryException(BOOL Global)
    {
        m_Global = Global;
        m_Message[0] = _T('\0');
        m_Caption[0] = _T('\0');
        m_Options = MB_OK | MB_ICONHAND;
    }
    BOOL SetMessage(LPCTSTR Message)
    {
        if (!Message || lstrlen(Message) >= ARRAYLEN(m_Message))
        {
            return FALSE;
        }

        lstrcpy(m_Message, Message);
        return TRUE;

    }
    BOOL SetCaption(LPCTSTR Caption)
    {
        if (!Caption || lstrlen(Caption) >= ARRAYLEN(m_Caption))
        {
            return FALSE;
        }

        lstrcpy(m_Caption, Caption);
        return TRUE;
    }
    BOOL SetOptions(DWORD Options)
    {
        m_Options = Options;
        return TRUE;
    }
    void ReportError(HWND hwndParent = NULL)
    {
        MessageBox(hwndParent, m_Message, m_Caption, m_Options);
    }
    void Delete()
    {
        if (!m_Global)
        {
            delete this;
        }
    }

private:
    TCHAR m_Message[128];
    TCHAR m_Caption[128];
    DWORD m_Options;
    BOOL  m_Global;
};

inline int MAX(int Value1, int Value2)
{
    return (Value1 >= Value2) ? Value1 : Value2;
}

//
// data buffer control class for String class
//
class StringData
{
public:
    StringData() : Ref(1), ptsz(NULL), Len(0)
    {}
    ~StringData()
    {
        delete [] ptsz;
    }
    long AddRef()
    {
        Ref++;
        return Ref;
    }
    long Release()
    {
        ASSERT(Ref);
        if (!(--Ref))
        {
        delete this;
        return 0;
        }
        return Ref;
    }
    TCHAR*  ptsz;
    long    Len;

private:
    long    Ref;
};

class CBlock
{
public:
    CBlock(CBlock* BlockHead, UINT unitCount, UINT unitSize)
    {
        data = new BYTE[unitCount * unitSize];
        if (data)
        {
            if (BlockHead)
            {
                m_Next = BlockHead->m_Next;
                BlockHead->m_Next = this;
            }
            else
            {
                m_Next = NULL;
            }
        }
        else
        {
            throw &g_MemoryException;
        }
    }
    ~CBlock()
    {
        if (data)
        delete [] data;
        if (m_Next)
        delete m_Next;
    }
    void*   data;

private:
    CBlock* m_Next;
};


//
// Text string class
//
class String
{
public:
// constructors
    String();
    String(LPCTSTR lptsz);
    String(const String& strSrc);
    ~String()
    {
        m_pData->Release();
    }
//operators

    TCHAR& operator[](int Index);
    operator LPTSTR();

    const TCHAR& operator[](int Index) const
    {
        ASSERT(Index < m_pData->Len && m_pData->ptsz);
        return m_pData->ptsz[Index];
    }

    operator LPCTSTR () const
    {
        return m_pData->ptsz;
    }
    String& operator=(const String& strSrc);
    String& operator=(LPCTSTR ptsz);
    String& operator+=(const String& strSrc);
    String& operator+=(LPCTSTR prsz);
    friend String operator+(const String& str1, const String& str2);

    int GetLength() const
    {
        return m_pData->Len;
    }
    BOOL IsEmpty() const
    {
        return (0 == m_pData->Len);
    }
    int Compare(const String& strSrc) const
    {
        return lstrcmp(m_pData->ptsz, strSrc.m_pData->ptsz);
    }
    int CompareNoCase(const String& strSrc) const
    {
        return lstrcmpi(m_pData->ptsz, strSrc.m_pData->ptsz);
    }
    void Empty();
    BOOL LoadString(HINSTANCE hInstance, int ResourceId);
    BOOL GetComputerName();
    BOOL GetSystemWindowsDirectory();
    void Format(LPCTSTR FormatString, ...);
    StringData* m_pData;

protected:
    String(int Len);

};

//
// Command line parsing class
//
class CCommandLine
{
public:
    void ParseCommandLine(LPCTSTR cmdline);
    virtual void ParseParam(LPCTSTR Param, BOOL bFlag, BOOL bLast) = 0;
};




//
// Safe registry class
//
class CSafeRegistry
{
public:
    CSafeRegistry(HKEY hKey = NULL) : m_hKey(hKey)
    {}
    ~CSafeRegistry()
    {
        if (m_hKey)
        {
            RegCloseKey(m_hKey);
        }
    }
    operator HKEY()
    {
        return m_hKey;
    }
    BOOL Open(HKEY hKeyAncestor, LPCTSTR KeyName, REGSAM Access = KEY_ALL_ACCESS);
    void Close()
    {
        if (m_hKey)
        {
            RegCloseKey(m_hKey);
        }

        m_hKey = NULL;
    }
    BOOL Create(HKEY hKeyAncestor, LPCTSTR KeyName,
             REGSAM Access = KEY_ALL_ACCESS,
             DWORD * pDisposition = NULL, DWORD  Options = 0,
             LPSECURITY_ATTRIBUTES pSecurity = NULL);
    BOOL SetValue(LPCTSTR ValueName, DWORD Type, PBYTE pData, DWORD DataLen);
    BOOL SetValue(LPCTSTR ValueName, LPCTSTR Value);
    BOOL GetValue(LPCTSTR ValueName, DWORD* pType, PBYTE Buffer, DWORD* BufferLen);
    BOOL GetValue(LPCTSTR ValueName, String& str);
    BOOL DeleteValue(LPCTSTR ValueName);
    BOOL DeleteSubkey(LPCTSTR SubkeyName);
    BOOL EnumerateSubkey(DWORD Index, LPTSTR Buffer, DWORD* BufferSize);

private:
    HKEY    m_hKey;
};

// define iteration context. To be used by CLIST
struct tagPosition{ };
typedef tagPosition* POSITION;

template<class TYPE>
inline void ConstructElements(TYPE* pElements, int Count)
{
    memset((void*)&pElements, 0, Count * sizeof(TYPE));
    
    for (; Count; Count--, pElements++)
    {
        // call the contructor -- note the placement
        ::new((void*)pElements) TYPE;
    }
}

template<class TYPE>
inline void DestructElements(TYPE* pElements, int Count)
{
    for (; Count; Count--, pElements++)
    {
        pElements->~TYPE();
    }
}
//
// TEMPLATEs
//


//
// CList template, adapted from MFC
//
template<class TYPE, class ARG_TYPE>
class CList
{
protected:
    struct CNode
    {
        CNode* pNext;
        CNode* pPrev;
        TYPE data;
    };

public:
// Construction
    CList(int nBlockSize = 10);

// Attributes (head and tail)
    // count of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // peek at head or tail
    TYPE& GetHead();
    TYPE GetHead() const;
    TYPE& GetTail();
    TYPE GetTail() const;

// Operations
    // get head or tail (and remove it) - don't call on empty list !
    TYPE RemoveHead();
    TYPE RemoveTail();

    // add before head or after tail
    POSITION AddHead(ARG_TYPE newElement);
    POSITION AddTail(ARG_TYPE newElement);

    // add another list of elements before head or after tail
    void AddHead(CList* pNewList);
    void AddTail(CList* pNewList);

    // remove all elements
    void RemoveAll();

    // iteration
    POSITION GetHeadPosition() const;
    POSITION GetTailPosition() const;
    TYPE& GetNext(POSITION& rPosition); // return *Position++
    TYPE GetNext(POSITION& rPosition) const; // return *Position++
    TYPE& GetPrev(POSITION& rPosition); // return *Position--
    TYPE GetPrev(POSITION& rPosition) const; // return *Position--

    // getting/modifying an element at a given position
    TYPE& GetAt(POSITION position);
    TYPE GetAt(POSITION position) const;
    void SetAt(POSITION pos, ARG_TYPE newElement);
    void RemoveAt(POSITION position);

    // inserting before or after a given position
    POSITION InsertBefore(POSITION position, ARG_TYPE newElement);
    POSITION InsertAfter(POSITION position, ARG_TYPE newElement);

    POSITION FindIndex(int nIndex) const;
        // get the 'nIndex'th element (may return NULL)

// Implementation
protected:
    CNode* m_pNodeHead;
    CNode* m_pNodeTail;
    int m_nCount;
    CNode* m_pNodeFree;
    CBlock* m_pBlocks;
    int m_nBlockSize;

    CNode* NewNode(CNode*, CNode*);
    void FreeNode(CNode*);

public:
    ~CList();
};


/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CList<TYPE, ARG_TYPE>::GetCount() const
    { return m_nCount; }
template<class TYPE, class ARG_TYPE>
inline BOOL CList<TYPE, ARG_TYPE>::IsEmpty() const
    { return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetHead()
    { ASSERT(m_pNodeHead != NULL);
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetHead() const
    { ASSERT(m_pNodeHead != NULL);
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetTail()
    { ASSERT(m_pNodeTail != NULL);
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetTail() const
    { ASSERT(m_pNodeTail != NULL);
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline POSITION CList<TYPE, ARG_TYPE>::GetHeadPosition() const
    { return (POSITION) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
inline POSITION CList<TYPE, ARG_TYPE>::GetTailPosition() const
    { return (POSITION) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) // return *Position++
    { CNode* pNode = (CNode*) rPosition;
        rPosition = (POSITION) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) const // return *Position++
    { CNode* pNode = (CNode*) rPosition;
        rPosition = (POSITION) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) // return *Position--
    { CNode* pNode = (CNode*) rPosition;
        rPosition = (POSITION) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) const // return *Position--
    { CNode* pNode = (CNode*) rPosition;
        rPosition = (POSITION) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position)
    { CNode* pNode = (CNode*) position;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetAt(POSITION position) const
    { CNode* pNode = (CNode*) position;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::SetAt(POSITION pos, ARG_TYPE newElement)
    { CNode* pNode = (CNode*) pos;
        pNode->data = newElement; }

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::CList(int nBlockSize)
{
    ASSERT(nBlockSize > 0);

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAll()
{
    // destroy elements
    CNode* pNode;
    for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
    {
        DestructElements<TYPE>(&pNode->data, 1);
    }

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    delete m_pBlocks;
    m_pBlocks = NULL;
}

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::~CList()
{
    RemoveAll();
    ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::CNode*
CList<TYPE, ARG_TYPE>::NewNode(CList::CNode* pPrev, CList::CNode* pNext)
{
    if (m_pNodeFree == NULL)
    {
        // add another block
        CBlock* pNewBlock = new CBlock(m_pBlocks, m_nBlockSize, sizeof(CNode));
        
        if (!pNewBlock) {

            throw &g_MemoryException;
        }

        if (m_pBlocks == NULL)
        {
            m_pBlocks = pNewBlock;
        }

        // chain them into free list
        CNode* pNode = (CNode*) pNewBlock->data;
        
        // free in reverse order to make it easier to debug
        pNode += m_nBlockSize - 1;
        
        for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
        {
            pNode->pNext = m_pNodeFree;
            m_pNodeFree = pNode;
        }
    }
    
    ASSERT(m_pNodeFree != NULL);  // we must have something

    CList::CNode* pNode = m_pNodeFree;
    m_pNodeFree = m_pNodeFree->pNext;
    pNode->pPrev = pPrev;
    pNode->pNext = pNext;
    m_nCount++;
    ASSERT(m_nCount > 0);  // make sure we don't overflow

    ConstructElements<TYPE>(&pNode->data, 1);
    
    return pNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::FreeNode(CList::CNode* pNode)
{
    DestructElements<TYPE>(&pNode->data, 1);
    pNode->pNext = m_pNodeFree;
    m_pNodeFree = pNode;
    m_nCount--;
    ASSERT(m_nCount >= 0);  // make sure we don't underflow

    // if no more elements, cleanup completely
    if (m_nCount == 0)
        RemoveAll();
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
    CNode* pNewNode = NewNode(NULL, m_pNodeHead);
    pNewNode->data = newElement;
    
    if (m_pNodeHead != NULL)
    {
        m_pNodeHead->pPrev = pNewNode;
    }
    else
    {
        m_pNodeTail = pNewNode;
    }

    m_pNodeHead = pNewNode;
    
    return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
    CNode* pNewNode = NewNode(m_pNodeTail, NULL);
    pNewNode->data = newElement;
    if (m_pNodeTail != NULL)
    {
        m_pNodeTail->pNext = pNewNode;
    }
    else
    {
        m_pNodeHead = pNewNode;
    }

    m_pNodeTail = pNewNode;
    
    return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddHead(CList* pNewList)
{
    ASSERT(pNewList != NULL);

    // add a list of same elements to head (maintain order)
    POSITION pos = pNewList->GetTailPosition();
    
    while (pos != NULL)
    {
        AddHead(pNewList->GetPrev(pos));
    }
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddTail(CList* pNewList)
{
    ASSERT(pNewList != NULL);

    // add a list of same elements
    POSITION pos = pNewList->GetHeadPosition();
    
    while (pos != NULL)
    {
        AddTail(pNewList->GetNext(pos));
    }
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveHead()
{
    ASSERT(m_pNodeHead != NULL);  // don't call on empty list !!!

    CNode* pOldNode = m_pNodeHead;
    TYPE returnValue = pOldNode->data;

    m_pNodeHead = pOldNode->pNext;
    
    if (m_pNodeHead != NULL)
    {
        m_pNodeHead->pPrev = NULL;
    }
    else
    {
        m_pNodeTail = NULL;
    }
    
    FreeNode(pOldNode);
    
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveTail()
{
    ASSERT(m_pNodeTail != NULL);  // don't call on empty list !!!

    CNode* pOldNode = m_pNodeTail;
    TYPE returnValue = pOldNode->data;

    m_pNodeTail = pOldNode->pPrev;
    
    if (m_pNodeTail != NULL)
    {
        m_pNodeTail->pNext = NULL;
    }
    else
    {
        m_pNodeHead = NULL;
    }
    
    FreeNode(pOldNode);
    
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertBefore(POSITION position, ARG_TYPE newElement)
{

    if (position == NULL)
    {
        return AddHead(newElement); // insert before nothing -> head of the list
    }

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
    pNewNode->data = newElement;

    if (pOldNode->pPrev != NULL)
    {
        pOldNode->pPrev->pNext = pNewNode;
    }
    else
    {
        ASSERT(pOldNode == m_pNodeHead);
        m_pNodeHead = pNewNode;
    }
    
    pOldNode->pPrev = pNewNode;
    
    return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertAfter(POSITION position, ARG_TYPE newElement)
{

    if (position == NULL)
    {
        return AddTail(newElement); // insert after nothing -> tail of the list
    }

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
    pNewNode->data = newElement;

    if (pOldNode->pNext != NULL)
    {
        pOldNode->pNext->pPrev = pNewNode;
    }
    else
    {
        ASSERT(pOldNode == m_pNodeTail);
        m_pNodeTail = pNewNode;
    }
    
    pOldNode->pNext = pNewNode;
    
    return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAt(POSITION position)
{

    CNode* pOldNode = (CNode*) position;

    // remove pOldNode from list
    if (pOldNode == m_pNodeHead)
    {
        m_pNodeHead = pOldNode->pNext;
    }
    else
    {
        pOldNode->pPrev->pNext = pOldNode->pNext;
    }
    
    if (pOldNode == m_pNodeTail)
    {
        m_pNodeTail = pOldNode->pPrev;
    }
    else
    {
        pOldNode->pNext->pPrev = pOldNode->pPrev;
    }
    
    FreeNode(pOldNode);
}


template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::FindIndex(int nIndex) const
{
    ASSERT(nIndex >= 0);

    if (nIndex >= m_nCount)
    {
        return NULL;  // went too far
    }

    CNode* pNode = m_pNodeHead;
    
    while (nIndex--)
    {
        pNode = pNode->pNext;
    }
    
    return (POSITION) pNode;
}



// NOTE:
// dereferencing operator -> is not supported in this template
// because this is designed to allocate intrinsic data types only
//
template<class T>
class BufferPtr
{
public:
    BufferPtr(UINT Size) : m_pBase(NULL), m_Size(Size)
    {
        ASSERT(Size);
        m_pBase = new T[Size];
        m_pCur = m_pBase;
        
        if (!m_pBase)
        {
            throw &g_MemoryException;
        }
    }
    BufferPtr()
    {
        m_pBase = NULL;
        m_pCur = NULL;
        m_Size = 0;
    }
    ~BufferPtr()
    {
        if (m_pBase)
        {
            delete [] m_pBase;
        }
    }
    // casting operator
    operator T*()
    {
        return m_pCur;
    }
    operator T&()
    {
        ASSERT(m_pCur < m_pBase + m_Size);
        return *m_pCur;
    }
    operator void*()
    {
        return m_pCur;
    }
    T& operator*()
    {
        ASSERT(m_pCur < m_pBase + m_Size);
        return *m_pCur;
    }
    // increment/decrement
    T* operator+(UINT Inc)
    {
        ASSERT(m_pBase + m_Size > m_pCur + Inc);
        return (m_pBase + Inc);
    }
    T* operator-(UINT Dec)
    {
        ASSERT(m_pBase >= m_pCur - Dec);
        m_pCur -= Dec;
        return m_pCur;
    }
    //prefix
    T* operator++()
    {
        ASSERT(m_pBase + m_Size > m_pCur - 1);
        return ++m_pCur;
    }
    //postfix
    T* operator++(int inc)
    {
        pCur
        ASSERT(m_pBase + m_Size > m_pCur);
        return m_pCur++;
    }
    //prefix
    T* operator--()
    {
        ASSERT(m_pCur > m_pBase);
        return --m_pCur;
    }
    //postfix
    T* operator--(int inc)
    {
        ASSERT(m_pCur > m_pBase);
        return m_pCur--;
    }
    T** operator&()
    {
        return &m_pBase;
    }
    // subscripting
    T& operator[](UINT Index)
    {
        ASSERT(Index < m_Size);
        return m_pBase[Index];
    }
    void Attach(T* pT, UINT Size = 1)
    {
        ASSERT(!m_pBase);
        m_pBase = pT;
        m_pCur = m_pBase;
        m_Size = Size;
    }
    void Detach()
    {
        m_pBase = NULL;
    }
    UINT GetSize()
    {
        return m_Size;
    }

private:
    T*   m_pBase;
    T*   m_pCur;
    UINT    m_Size;
};

template<class T>
class SafePtr
{
public:
    SafePtr(T* p)
    {
        __p = p;
    }
    SafePtr()
    {
        __p = NULL;
    }
    ~SafePtr()
    {
        if (__p)
        {
            delete __p;
        }
    }
    void Attach(T* p)
    {
        ASSERT(NULL == __p);
        __p = p;
    }
    void Detach()
    {
        __p = NULL;
    }
    T* operator->()
    {
        ASSERT(__p);

        return __p;
    }
    T& operator*()
    {
        ASSERT(__p);

        return *__p;
    }
    operator T*()
    {
        return __p;
    }
    operator T&()
    {
        ASSERT(__p);
        return *__p;
    }

private:
    T*  __p;

};



class CPropPageProvider;

class CPropSheetData
{
public:
    CPropSheetData();
    ~CPropSheetData();
    virtual BOOL Create(HINSTANCE hInst, HWND hwndParent, UINT MaxPages, LONG_PTR lConsoleHandle = 0);
    BOOL InsertPage(HPROPSHEETPAGE hPage, int Index = -1);
    INT_PTR DoSheet()
    {
        return ::PropertySheet(&m_psh);
    }
    HWND GetWindowHandle()
    {
        return m_hWnd;
    }
    void PageCreateNotify(HWND hWnd);
    void PageDestroyNotify(HWND hWnd);
    PROPSHEETHEADER m_psh;
    BOOL PropertyChangeNotify(long lParam);
    void AddProvider(CPropPageProvider* pProvider)
    {
        m_listProvider.AddTail(pProvider);
    }

protected:
    UINT    m_MaxPages;
    LONG_PTR m_lConsoleHandle;
    HWND    m_hWnd;

private:
    CList<CPropPageProvider*, CPropPageProvider*> m_listProvider;
};


class CDialog
{
public:
    CDialog(int TemplateId) : m_hDlg(NULL), m_TemplateId(TemplateId)
    {}
    virtual ~CDialog()
    {}
    static INT_PTR CALLBACK DialogWndProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR DoModal(HWND hwndParent, LPARAM lParam )
    {
        return DialogBoxParam(g_hInstance, MAKEINTRESOURCE(m_TemplateId), hwndParent, DialogWndProc, lParam);
    }
    void DoModaless(HWND hwndParent, LPARAM lParam)
    {
        m_hDlg = CreateDialogParam(g_hInstance, MAKEINTRESOURCE(m_TemplateId), hwndParent, DialogWndProc, lParam);
    }
    virtual BOOL OnInitDialog()
    {
        return TRUE;
    }
    virtual void OnCommand(WPARAM wParam, LPARAM lParam)
    {}
    virtual BOOL OnNotify(LPNMHDR pnmhdr)
    {
        return FALSE;
    }
    virtual BOOL OnDestroy()
    {
        return FALSE;
    }
    virtual BOOL OnHelp(LPHELPINFO pHelpInfo)
    {
        return FALSE;
    }
    virtual BOOL OnContextMenu(HWND hWnd, WORD xPos, WORD yPos)
    {
        return FALSE;
    }

    HWND GetControl(int idControl)
    {
        return GetDlgItem(m_hDlg, idControl);
    }
    operator HWND()
    {
        return m_hDlg;
    }
    HWND    m_hDlg;

private:
    int     m_TemplateId;
};


class CFileHandle
{
public:
    CFileHandle(HANDLE hFile = INVALID_HANDLE_VALUE) : m_hFile(hFile)
    {}
    ~CFileHandle()
    {
        if (INVALID_HANDLE_VALUE != m_hFile)
        CloseHandle(m_hFile);
    }
    void Open(HANDLE hFile)
    {
        ASSERT(INVALID_HANDLE_VALUE == m_hFile);
        m_hFile = hFile;
    }
    void Close()
    {
        if (INVALID_HANDLE_VALUE != m_hFile)
        CloseHandle(m_hFile);
    }
    HANDLE hFile()
    {
        return m_hFile;
    }

private:
    HANDLE  m_hFile;
};

class CLogFile
{
public:
    CLogFile() : m_hFile(INVALID_HANDLE_VALUE)
    {}
    ~CLogFile()
    {
        Close();
    }
    BOOL Create(LPCTSTR LogFileName)
    {
        if (!LogFileName)
        {
            return FALSE;
        }

        m_strLogFileName = LogFileName;
        m_hFile = CreateFile(LogFileName,
                GENERIC_READ | GENERIC_WRITE,
                0,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL);
        return INVALID_HANDLE_VALUE != m_hFile;
    }
    void Close()
    {
        if (m_hFile)
        {
            CloseHandle(m_hFile);
            m_hFile = INVALID_HANDLE_VALUE;
        }
    }
    LPCTSTR LogFileName()
    {
        return m_strLogFileName.IsEmpty() ? NULL : (LPCTSTR)m_strLogFileName;
    }
    void Delete()
    {
        Close();
        if (m_strLogFileName)
        DeleteFile(m_strLogFileName);
    }
    BOOL LogLastError(LPCTSTR FunctionName);
    BOOL Logf(LPCTSTR Format, ...);
    BOOL Log(LPCTSTR Text);

private:
    HANDLE  m_hFile;
    String  m_strLogFileName;
};

STDAPI_(CONFIGRET) GetLocationInformation(
    DEVNODE dn,
    LPTSTR Location,
    ULONG LocationLen,  // In characters
    HMACHINE hMachine
    );

#endif  // __UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\snapins\devmgr\snapin\utils.cpp ===
/*++

Copyright (C) 1997-1999  Microsoft Corporation

Module Name:

    utils.cpp

Abstract:

    This module implements some utilities classes

Author:

    William Hsieh (williamh) created

Revision History:


--*/


#include "devmgr.h"


const TCHAR* const DEVMGR_DATAWINDOW_CASS_NAME = TEXT("DevMgrDataWindowClass");


//
// CPropSheetData implementation
//
// Every device or class has a CPropSheetData as a member.
// When m_hWnd contains a valid window handle, it indicates the device/class
// has a active property sheet. This helps us to do this:
// (1). We are sure that there is only one property sheet can be created
//  for the device/class at time in a single console no matter how many
//  IComponents(snapins, windows) are running in the same console.
//  For example, when users asks for the properties for the device/class
//  we can bring the active one to the foreground without creating a
//  new one.
// (2). We can warn the user that a removal of the device is not allowed
//  when the device has an active property sheet.
// (3). We can warn the user that there are property sheets active
//  when a "refresh" is requsted.
CPropSheetData::CPropSheetData()
{
    memset(&m_psh, 0, sizeof(m_psh));
    m_MaxPages = 0;
    m_lConsoleHandle = 0;
    m_hWnd = NULL;
}

// This function creates(or initialize) the propery sheet data header.
//
// INPUT: hInst -- the module instance handle
//    hwndParent -- parent window handle
//    MaxPages -- max pages allowed for this property sheet.
//    lConsoleHandle -- MMC property change notify handle.
//
// OUTPUT:  TRUE if succeeded.
//      FALSE if failed(mostly, memory allocation error). GetLastError
//      will report the error code.
//

BOOL
CPropSheetData::Create(
    HINSTANCE hInst,
    HWND hwndParent,
    UINT MaxPages,
    LONG_PTR lConsoleHandle
    )
{

    // nobody should try to create the property sheet while it is
    // still alive.
    ASSERT (NULL == m_hWnd);

    if (MaxPages > 64 || NULL == hInst)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    // if not page array is allocated or the existing
    // array is too small, allocate a new array.
    if (!m_psh.phpage || m_MaxPages < MaxPages)
    {
        if (m_MaxPages)
        {
            ASSERT(m_psh.phpage);
            delete [] m_psh.phpage;
            m_psh.phpage = NULL;
        }
        
        m_psh.phpage = new HPROPSHEETPAGE[MaxPages];
        m_MaxPages = MaxPages;
    }
    
    // initialize the header
    m_psh.nPages = 0;
    m_psh.dwSize = sizeof(m_psh);
    m_psh.dwFlags = PSH_PROPTITLE | PSH_NOAPPLYNOW;
    m_psh.hwndParent = hwndParent;
    m_psh.hInstance = hInst;
    m_psh.pszCaption = NULL;
    m_lConsoleHandle = lConsoleHandle;
    
    return TRUE;
}

// This function inserts the given HPROPSHEETPAGE to the
// specific location.
//
// INPUT: hPage  -- the page to be inserted.
//    Position -- the location to be inserted.
//            Position < 0, then append the page
//
// OUTPUT:  TRUE if the page is inserted successfully.
//      FALSE if the page is not inserted. GetLastError will
//      return the error code.
//
BOOL
CPropSheetData::InsertPage(
    HPROPSHEETPAGE hPage,
    int Position
    )
{
    if (NULL == hPage || (Position > 0 && (UINT)Position >= m_MaxPages))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    // make sure we have space for a new page.
    if (m_psh.nPages >= m_MaxPages)
    {
        SetLastError(ERROR_BUFFER_OVERFLOW);
        return FALSE;
    }
    
    if (Position < 0 || (UINT)Position >= m_psh.nPages)
    {
        // append the page.  This also include the very first page.
        // Most pages are appened.
        m_psh.phpage[m_psh.nPages++] = hPage;
    }
    
    else
    {
    
        ASSERT(m_psh.nPages);
    
        // move the page around so that we
        // can insert the new page to the
        // specific location.
        // At this moment, we know we have space to accomodate the
        // new page(so we can assume that &m_psh.phpage[m_psh.nPage]
        // is valid. Also, we are here because there is at least one
        // pages in the array.
        for (int i = m_psh.nPages; i > Position; i--)
            m_psh.phpage[i] = m_psh.phpage[i - 1];
        
        m_psh.phpage[Position] = hPage;
        m_psh.nPages++;
    }
    
    return TRUE;
}
//
// This function receives notification from its attached
// property pages about their window(dialog) creation
// It takes a chance to record the property sheet window handle
// which we can use to dismiss the property sheet or bring it
// to the foreground.
// INPUT:
//  hWnd -- the property page's window handle
//
// OUTPUT:
//  NONE
//
void
CPropSheetData::PageCreateNotify(HWND hWnd)
{
    ASSERT(hWnd);
    hWnd = ::GetParent(hWnd);
    
    if (!m_hWnd)
        m_hWnd = hWnd;
}

//
// This function receives notification from its attached
// property pages about their window(dialog) destroy.
// When all attached pages are gone, this function
// reset its internal states and free memory allocation
// WARNING!!!! Do not delete the object when the attached
// window handle counts reaches 0 because we can be reused --
// the reason we have a separate Create functions.
//
// INPUT:
//  hWnd -- the property page's window handle
//
// OUTPUT:
//  NONE
//
void
CPropSheetData::PageDestroyNotify(HWND hWnd)
{
    //
    m_hWnd = NULL;
    delete [] m_psh.phpage;
    m_psh.phpage = NULL;
    m_MaxPages = 0;
    memset(&m_psh, 0, sizeof(m_psh));
    
    if (m_lConsoleHandle)
        MMCFreeNotifyHandle(m_lConsoleHandle);

    m_lConsoleHandle = 0;
    
    if (!m_listProvider.IsEmpty())
    {
        POSITION pos = m_listProvider.GetHeadPosition();
        
        while (NULL != pos)
        {
            delete m_listProvider.GetNext(pos);
        }
        
        m_listProvider.RemoveAll();
    }
}

CPropSheetData::~CPropSheetData()
{
    if (m_lConsoleHandle)
        MMCFreeNotifyHandle(m_lConsoleHandle);

    if (!m_listProvider.IsEmpty())
    {
        POSITION pos = m_listProvider.GetHeadPosition();
        
        while (NULL != pos)
        {
            delete m_listProvider.GetNext(pos);
        }
        
        m_listProvider.RemoveAll();
    }
    
    if (m_psh.phpage)
        delete [] m_psh.phpage;
}

BOOL
CPropSheetData::PropertyChangeNotify(
    long lParam
    )
{
    if (m_lConsoleHandle)
    {
        MMCPropertyChangeNotify(m_lConsoleHandle, lParam);
        return TRUE;
    }
    
    return FALSE;
}

//
// CDialog implementation
//

INT_PTR CALLBACK
CDialog::DialogWndProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CDialog* pThis = (CDialog *) GetWindowLongPtr(hDlg, DWLP_USER);
    BOOL Result;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
        pThis = (CDialog *)lParam;
        ASSERT(pThis);
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pThis);
        pThis->m_hDlg = hDlg;
        Result = pThis->OnInitDialog();
        break;
        }

    case WM_COMMAND:
        if (pThis) {
            pThis->OnCommand(wParam, lParam);
        }
        Result = FALSE;
        break;
    
    case WM_NOTIFY:
        if (pThis) {
            Result = pThis->OnNotify((LPNMHDR)lParam);
        } else {
            Result = FALSE;
        }
        break;

    case WM_DESTROY:
        if (pThis) {
            Result = pThis->OnDestroy();
        } else {
            Result = FALSE;
        }
        break;
    
    case WM_HELP:
        if (pThis) {
            pThis->OnHelp((LPHELPINFO)lParam);
        }
        Result = FALSE;
        break;
    
    case WM_CONTEXTMENU:
        if (pThis) {
            pThis->OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));
        }
        Result = FALSE;
        break;

    default:
        Result = FALSE;
        break;
    }

    return Result;
}


//
// class String implementation
//
String::String()
{
    m_pData = new StringData;
    if (!m_pData)
    throw &g_MemoryException;
}

String::String(
    const String& strSrc
    )
{
    m_pData = strSrc.m_pData;
    m_pData->AddRef();
}

String::String(
    int Len
    )
{
    StringData* pNewData = new StringData;
    TCHAR* ptszNew = new TCHAR[Len + 1];
    
    if (pNewData && ptszNew)
    {
        pNewData->Len = 0;
        pNewData->ptsz = ptszNew;
        m_pData = pNewData;
    }
    
    else
    {
        delete pNewData;
        delete [] ptszNew;
        throw &g_MemoryException;
    }
}

String::String(
    LPCTSTR lptsz
    )
{
    int Len = lstrlen(lptsz);
    StringData* pNewData = new StringData;
    TCHAR* ptszNew = new TCHAR[Len + 1];
    
    if (pNewData && ptszNew)
    {
        lstrcpy(ptszNew, lptsz);
        pNewData->Len = Len;
        pNewData->ptsz = ptszNew;
        m_pData = pNewData;
    }
    
    else
    {
        delete pNewData;
        delete [] ptszNew;
        throw &g_MemoryException;
    }
}

void
String::Empty()
{
    if (m_pData->Len)
    {
        StringData* pNewData = new StringData;
        
        if (pNewData)
        {
            m_pData->Release();
            m_pData = pNewData;
        }
        
        else
        {
            throw &g_MemoryException;
        }
    }
}
String&
String::operator=(
    const String&  strSrc
    )
{
    // look out for aliasings !!!!
    if (this != &strSrc)
    {
        // add the reference count first before release the old one
        // in case our string data is the same as strSrc's.
        strSrc.m_pData->AddRef();
        m_pData->Release();
        m_pData = strSrc.m_pData;
    }
    
    return *this;
}

String&
String::operator=(
    LPCTSTR ptsz
    )
{
    // if we are pointing to the same string,
    // do nothing
    if (ptsz == m_pData->ptsz)
        return *this;
    
    //
    // str = NULL --> empty the string
    //
    if (!ptsz)
    {
        Empty();
        return *this;
    }
    
    // a new assignment, allocate a new string data
    StringData* pNewData = new StringData;
    int len = lstrlen(ptsz);
    TCHAR* ptszNew = new TCHAR[len + 1];
    
    if (pNewData && ptszNew)
    {
        lstrcpy(ptszNew, ptsz);
        pNewData->Len = len;
        pNewData->ptsz = ptszNew;
        m_pData->Release();
        m_pData = pNewData;
    }
    
    else
    {
        //memory allocation failure
        delete pNewData;
        delete [] ptszNew;
        throw g_MemoryException;
    }
    
    return *this;
}

String&
String::operator+=(
    const String& strSrc
    )
{
    if (strSrc.GetLength())
    {
        int TotalLen = m_pData->Len + strSrc.GetLength();
        StringData* pNewData = new StringData;
        TCHAR* ptszNew = new TCHAR[TotalLen + 1];
        
        if (pNewData && ptszNew)
        {
            lstrcpy(ptszNew, m_pData->ptsz);
            lstrcat(ptszNew, (LPCTSTR)strSrc);
            pNewData->Len = TotalLen;
            pNewData->ptsz = ptszNew;
            m_pData->Release();
            m_pData = pNewData;
        }
        
        else
        {
            delete pNewData;
            delete [] ptszNew;
            throw &g_MemoryException;
        }
    }
    
    return *this;
}
String&
String::operator+=(
    LPCTSTR ptsz
    )
{
    if (ptsz)
    {
        int len = lstrlen(ptsz);
        if (len)
        {
            StringData* pNewData = new StringData;
            TCHAR* ptszNew = new TCHAR[len + m_pData->Len + 1];
            
            if (ptszNew && pNewData)
            {
                lstrcpy(ptszNew, m_pData->ptsz);
                lstrcat(ptszNew, ptsz);
                pNewData->Len = len + m_pData->Len;
                pNewData->ptsz = ptszNew;
                m_pData->Release();
                m_pData = pNewData;
            }
            
            else
            {
                delete pNewData;
                delete [] ptszNew;
                throw &g_MemoryException;
            }
        }
    }
    
    return *this;
}

TCHAR&
String::operator[](
    int Index
    )
{
    ASSERT(Index < m_pData->Len);
    // make a separate copy of the string data
    TCHAR* ptszNew = new TCHAR[m_pData->Len + 1];
    StringData* pNewData = new StringData;
    
    if (ptszNew && pNewData)
    {
        lstrcpy(ptszNew, m_pData->ptsz);
        pNewData->ptsz = ptszNew;
        pNewData->Len = m_pData->Len;
        m_pData->Release();
        m_pData = pNewData;
        return ptszNew[Index];
    }
    
    else
    {
        delete pNewData;
        delete [] ptszNew;
        throw &g_MemoryException;
        return m_pData->ptsz[Index];
    }
}

String::operator LPTSTR()
{
    StringData* pNewData = new StringData;
    if (pNewData)
    {
        if (m_pData->Len)
        {
            TCHAR* ptszNew = new TCHAR[m_pData->Len + 1];
            
            if (ptszNew)
            {
                lstrcpy(ptszNew, m_pData->ptsz);
                pNewData->ptsz = ptszNew;
            }
            
            else
            {
                throw &g_MemoryException;
                delete pNewData;
                return NULL;
            }
        }
        
        pNewData->Len = m_pData->Len;
        m_pData->Release();
        m_pData = pNewData;
        return  m_pData->ptsz;
    }
    
    else
    {
        throw &g_MemoryException ;
        return NULL;
    }
}

//
// This is a friend function to String
// Remember that we can NOT return a reference or a pointer.
// This function must return "by-value"
String
operator+(
    const String& str1,
    const String& str2
    )
{
    int TotalLen = str1.GetLength() + str2.GetLength();
    String strThis(TotalLen);
    lstrcpy(strThis.m_pData->ptsz, str1);
    lstrcat(strThis.m_pData->ptsz, str2);
    strThis.m_pData->Len = TotalLen;
    return strThis;
}

BOOL
String::LoadString(
    HINSTANCE hInstance,
    int ResourceId
    )
{
    // we have no idea how long the string will be.
    // The strategy here is to allocate a stack-based buffer which
    // is large enough for most cases. If the buffer is too small,
    // we then use heap-based buffer and increment the buffer size
    // on each try.
    TCHAR tszTemp[256];
    long FinalSize, BufferSize;
    BufferSize = ARRAYLEN(tszTemp);
    TCHAR* HeapBuffer = NULL;
    
    // first try
    FinalSize = ::LoadString(hInstance, ResourceId, tszTemp, BufferSize);

    //
    // LoadString returns the size of the string it loaded, not including the
    // NULL termiated char. So if the returned len is one less then the
    // provided buffer size, our buffer is too small.
    //
    if (FinalSize < (BufferSize - 1))
    {
        // we got what we want
        HeapBuffer = tszTemp;
    }
    
    else
    {
        // the stack based buffer is too small, we have to switch to heap
        // based.
        BufferSize = ARRAYLEN(tszTemp);
    
        // should 32k chars big enough????
        while (BufferSize < 0x8000)
        {
            BufferSize += 256;
    
            // make sure there is no memory leak
            ASSERT(NULL == HeapBuffer);
    
            // allocate a new buffer
            HeapBuffer = new TCHAR[BufferSize];
            
            if (HeapBuffer)
            {
                // got a new buffer, another try...
                FinalSize = ::LoadString(hInstance, ResourceId, HeapBuffer,
                              BufferSize);

                if (FinalSize < (BufferSize - 1))
                {
                    //got it!
                    break;
                }
            }

            else
            {
                throw &g_MemoryException;
            }

            // discard the buffer
            delete [] HeapBuffer;
            HeapBuffer = NULL;
        }
    }

    if (HeapBuffer)
    {
        TCHAR* ptszNew = new TCHAR[FinalSize + 1];
        StringData* pNewData = new StringData;
        
        if (pNewData && ptszNew)
        {
            lstrcpy(ptszNew, HeapBuffer);
            
            // release the old string data because we will have a new one
            m_pData->Release();
            m_pData = pNewData;
            m_pData->ptsz = ptszNew;
            m_pData->Len = FinalSize;
            
            if (HeapBuffer != tszTemp) {
            
                delete [] HeapBuffer;
            }

            return TRUE;
        }
        
        else
        {
            delete [] ptszNew;
            delete pNewData;

            if (HeapBuffer != tszTemp) {
            
                delete [] HeapBuffer;
            }

            throw &g_MemoryException;
        }
    }

    return FALSE;
}

//
// This function creates an full-qualified machine name for the
// local computer.
//
BOOL
String::GetComputerName()
{
    TCHAR tszTemp[MAX_PATH];
    // the GetComputerName api only return the name only.
    // we must prepend the UNC signature.
    tszTemp[0] = _T('\\');
    tszTemp[1] = _T('\\');
    ULONG NameLength = ARRAYLEN(tszTemp) - 2;
    
    if (::GetComputerName(tszTemp + 2, &NameLength))
    {
        int Len = lstrlen(tszTemp);
        StringData* pNewData = new StringData;
        TCHAR* ptszNew = new TCHAR[Len + 1];
        
        if (pNewData && ptszNew)
        {
            pNewData->Len = Len;
            lstrcpy(ptszNew, tszTemp);
            pNewData->ptsz = ptszNew;
            m_pData->Release();
            m_pData = pNewData;
            return TRUE;
        }
        
        else
        {
            delete pNewData;
            delete []ptszNew;
            throw &g_MemoryException;
        }
    }
    
    return FALSE;
}

BOOL
String::GetSystemWindowsDirectory()
{
    TCHAR tszTemp[MAX_PATH];
    
    if (::GetSystemWindowsDirectory(tszTemp, ARRAYLEN(tszTemp))) {
        int Len = lstrlen(tszTemp);
        StringData* pNewData = new StringData;
        TCHAR* ptszNew = new TCHAR[Len + 1];
        
        if (pNewData && ptszNew) {

            pNewData->Len = Len;
            lstrcpy(ptszNew, tszTemp);
            pNewData->ptsz = ptszNew;
            m_pData->Release();
            m_pData = pNewData;
            return TRUE;
        
        } else {

            delete pNewData;
            delete []ptszNew;
            throw &g_MemoryException;
        }
    }
    
    return FALSE;
}

void
String::Format(
    LPCTSTR FormatString,
    ...
    )
{
    // according to wsprintf specification, the max buffer size is
    // 1024
    TCHAR* pBuffer = new TCHAR[1024];
    if (pBuffer)
    {
        va_list arglist;
        va_start(arglist, FormatString);
        int len;
        len = wvsprintf(pBuffer, FormatString, arglist);
        va_end(arglist);
    
        if (len)
        {
            TCHAR* ptszNew = new TCHAR[len + 1];
            StringData* pNewData = new StringData;
            
            if (pNewData && ptszNew)
            {
                pNewData->Len = len;
                lstrcpy(ptszNew, pBuffer);
                pNewData->ptsz = ptszNew;
                m_pData->Release();
                m_pData = pNewData;
                delete [] pBuffer;
                return;
            }
            
            else
            {
                delete [] pBuffer;
                delete [] ptszNew;
                delete [] pNewData;
                throw &g_MemoryException;
            }
        }
    }

    throw &g_MemoryException;
}


//
// templates
//

template <class T>
inline void ContructElements(T* pElements, int Count)
{
    ASSERT(Count > 0);
    memset((void*)pElements, Count * sizeof(T));
    for (; Count; pElments++, Count--)
    {
        // call the class's ctor
        // note the placement.
        new((void*)pElements) T;
    }
}


//
// CCommandLine implementation
//

// code adapted from C startup code -- see stdargv.c
// It walks through the given CmdLine and calls ParseParam
// when an argument is encountered.
// An argument must in this format:
// </command arg_to_command>  or <-command arg_to_command>
void
CCommandLine::ParseCommandLine(
    LPCTSTR CmdLine
    )
{
    LPCTSTR p;
    LPTSTR args, pDst;
    BOOL bInQuote;
    BOOL bCopyTheChar;
    int  nSlash;
    p = CmdLine;
    args = new TCHAR[lstrlen(CmdLine) + 1];
    
    if (!args)
        return;
    
    for (;;)
    {
        // skip blanks
        while (_T(' ') == *p || _T('\t') == *p)
            p++;
        
        // nothing left, bail
        if (_T('\0') == *p)
            break;
        
        // 2N backslashes + '\"' ->N backslashes plus string delimiter
        // 2N + 1 baclslashes + '\"' ->N backslashes plus literal '\"'
        // N backslashes -> N backslashes
        nSlash = 0;
        bInQuote = FALSE;
        pDst = args;
        
        for (;;)
        {
            bCopyTheChar = TRUE;
            //count how may backslashes
            while(_T('\\') == *p)
            {
                p++;
                nSlash++;
            }
            
            if (_T('\"') == *p)
            {
                if (0 == (nSlash % 2))
                {
                    // 2N backslashes plus '\"' ->N baskslashes plus
                    // delimiter
                    if (bInQuote)
                    // double quote inside quoted string
                    // skip the first and copy the second.
                    if (_T('\"') == p[1])
                        p++;
                    else
                        bCopyTheChar = FALSE;
                    else
                    bCopyTheChar = FALSE;
                    // toggle quoted status
                    bInQuote = !bInQuote;
                }
            
                nSlash /= 2;
            }
            
            while (nSlash)
            {
                *pDst++ = _T('\\');
                nSlash--;
            }
    
            if (_T('\0') == *p || (!bInQuote && (_T(' ') == *p || _T('\t') == *p)))
            {
               break;
            }

            // copy char to args
            if (bCopyTheChar)
            {
                *pDst++ = *p;
            }
            p++;
        }
        // we have a complete argument now. Null terminates it and
        // let the derived class parse the argument.
        *pDst = _T('\0');
        // skip blanks to see if this is the last argument
        while (_T(' ') == *p || _T('\t') == *p)
            p++;
        BOOL bFlag;
        bFlag = (_T('/') == *args || _T('-') == *args);
        pDst = (bFlag) ? args + 1 : args;
        ParseParam(pDst, bFlag, _T('\0') == *p);
    }
    
    delete [] args;
}


//
// CSafeRegistry implementation
//

BOOL
CSafeRegistry::Open(
    HKEY hKeyAncestor,
    LPCTSTR KeyName,
    REGSAM Access
    )
{
    DWORD LastError;
    // we shouldn't has a valid key -- or memory leak
    // Also, a key name must be provided -- or open nothing
    ASSERT(!m_hKey && KeyName);
    LastError =  ::RegOpenKeyEx(hKeyAncestor, KeyName, 0, Access, &m_hKey);
    SetLastError(LastError);
    return ERROR_SUCCESS == LastError;
}


BOOL
CSafeRegistry::Create(
    HKEY hKeyAncestor,
    LPCTSTR KeyName,
    REGSAM Access,
    DWORD* pDisposition,
    DWORD Options,
    LPSECURITY_ATTRIBUTES pSecurity
    )
{
    ASSERT(KeyName && !m_hKey);
    DWORD Disposition;
    DWORD LastError;
    LastError = ::RegCreateKeyEx(hKeyAncestor, KeyName, 0, TEXT(""),
                   Options, Access, pSecurity,
                   &m_hKey, &Disposition
                   );
    SetLastError(LastError);
    
    if (ERROR_SUCCESS == LastError && pDisposition)
    {
        *pDisposition = Disposition;
    }
    
    if (ERROR_SUCCESS != LastError)
        m_hKey = NULL;
    
    return ERROR_SUCCESS == LastError;
}

BOOL
CSafeRegistry::SetValue(
    LPCTSTR ValueName,
    DWORD Type,
    const PBYTE pData,
    DWORD DataLen
    )
{
    ASSERT(m_hKey);
    DWORD LastError;
    LastError = ::RegSetValueEx(m_hKey, ValueName, 0, Type, pData, DataLen);
    SetLastError(LastError);
    return ERROR_SUCCESS == LastError;
}

BOOL
CSafeRegistry::SetValue(
    LPCTSTR ValueName,
    LPCTSTR Value
    )
{
    return  SetValue(ValueName,
             REG_SZ,
             (PBYTE)Value,
             (lstrlen(Value) + 1) * sizeof(TCHAR)
            );
}
BOOL
CSafeRegistry::GetValue(
    LPCTSTR ValueName,
    DWORD* pType,
    const PBYTE pData,
    DWORD* pDataLen
    )
{
    ASSERT(m_hKey);
    DWORD LastError;
    LastError = ::RegQueryValueEx(m_hKey, ValueName, NULL, pType, pData,
                    pDataLen);
    SetLastError(LastError);
    return ERROR_SUCCESS == LastError;
}

BOOL
CSafeRegistry::GetValue(
    LPCTSTR ValueName,
    String& str
    )
{
    DWORD Type, Size;
    PBYTE Buffer = NULL;
    Size = 0;
    BOOL Result = FALSE;

    // check size before Type because when the size is zero, type contains
    // undefined data.
    if (GetValue(ValueName, &Type, NULL, &Size) && Size && REG_SZ == Type)
    {
        // we do not want to throw an exception here.
        // so guard it
        try
        {
            BufferPtr<BYTE> BufferPtr(Size);
            Result = GetValue(ValueName, &Type, BufferPtr, &Size);
            if (Result)
            str = (LPCTSTR)(BYTE*)BufferPtr;
        }
        
        catch(CMemoryException* e)
        {
            e->Delete();
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            Result = FALSE;
        }
    }
    
    return Result;
}

BOOL
CSafeRegistry::EnumerateSubkey(
    DWORD Index,
    LPTSTR Buffer,
    DWORD* BufferSize
    )
{
    DWORD LastError;
    FILETIME LastWrite;
    LastError = ::RegEnumKeyEx(m_hKey, Index, Buffer, BufferSize,
                   NULL, NULL, NULL, &LastWrite);
    SetLastError(LastError);
    return ERROR_SUCCESS == LastError;
}

BOOL
CSafeRegistry::DeleteValue(
    LPCTSTR ValueName
    )
{
    ASSERT(m_hKey);
    DWORD LastError = ::RegDeleteValue(m_hKey, ValueName);
    SetLastError(LastError);
    return ERROR_SUCCESS == LastError;
}

BOOL
CSafeRegistry::DeleteSubkey(
    LPCTSTR SubkeyName
    )
{
    ASSERT(m_hKey);
    CSafeRegistry regSubkey;
    TCHAR KeyName[MAX_PATH];
    FILETIME LastWrite;
    DWORD KeyNameLen;
    
    while (TRUE)
    {
        KeyNameLen = ARRAYLEN(KeyName);
        // always uses index 0(the first subkey)
        if (!regSubkey.Open(m_hKey, SubkeyName, KEY_WRITE | KEY_ENUMERATE_SUB_KEYS) ||
            ERROR_SUCCESS != ::RegEnumKeyEx(regSubkey, 0, KeyName,
                        &KeyNameLen, NULL, NULL, NULL,
                        &LastWrite) ||
            !regSubkey.DeleteSubkey(KeyName))
        {
            break;
        }
        
        // close the key so that we will re-open it on each loop
        // -- we have deleted one subkey and without closing
        // the key, the index to RegEnumKeyEx will be confusing
        regSubkey.Close();
    }
    
    // now delete the subkey
    ::RegDeleteKey(m_hKey, SubkeyName);
    
    return TRUE;
}


//
//CLogFile::Log implementation
//

BOOL
CLogFile::Log(
    LPCTSTR Text
    )
{
    DWORD BytesWritten;
    if (Text && m_hFile)
    {
    int Size = lstrlen(Text);
#ifdef UNICODE
    BufferPtr<CHAR> Buffer(Size * sizeof(WCHAR));
    Size = WideCharToMultiByte(CP_ACP, 0, Text, Size, Buffer, Size*sizeof(WCHAR), NULL, NULL);
    return WriteFile(m_hFile, Buffer, Size, &BytesWritten, NULL);
#else
    retrun WriteFile(m_hFile, Text, Size, &BytesWritten, NULL);
#endif
    }
    return TRUE;
}
//
// CLogFile::Logf implementation
//

BOOL
CLogFile::Logf(
    LPCTSTR Format,
    ...
    )
{
    if (m_hFile)
    {
        // according to wsprintf specification, the max buffer size is
        // 1024
        TCHAR Buffer[1024];
        va_list arglist;
        va_start(arglist, Format);
        wvsprintf(Buffer, Format, arglist);
        va_end(arglist);
        return Log(Buffer);
    }
    
    return TRUE;
}

//
// CLogFile::LogLastError implementation
//

BOOL
CLogFile::LogLastError(
    LPCTSTR FunctionName
    )
{
    if (m_hFile && FunctionName)
    {
        TCHAR szMsg[MAX_PATH];
        FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
              NULL, GetLastError(), MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
              szMsg, ARRAYLEN(szMsg), NULL);
        Logf(TEXT("%s: error(%ld) : %s\n"), FunctionName, GetLastError(), szMsg);
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\cpl\thm_cpl.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by themes.rc
//
// Microsoft Desktop Themes
// Copyright (c) 1994-1999 Microsoft Corporation.  All rights reserved.
//
#define CPCAPTION                       1
#define THEMES_CPL_NAME                 2
#define THEMES_CPL_CAPTION              3
#define EXE_NAME                        4
#define THEMES_ICON                     101

LONG CALLBACK CPlApplet(HWND, UINT, LPARAM, LPARAM);

#define ARRAYSIZE(x)       (sizeof(x)/sizeof(x[0]))
#define SZSIZEINBYTES(x)   (lstrlen(x)*sizeof(TCHAR)+1)

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

#ifdef DBG
 #define DEBUG
#endif

#ifdef _DEBUG
 #define DEBUG
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\taskman\taskman.h ===
/****************************************************************************/
/*                                                                                                                  */
/*  TASKMAN.H -                                                                                             */
/*                                                                                                                  */
/*      Include for TASKMAN program                                                                 */
/*                                                                                                                       */
/****************************************************************************/

#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <winuserp.h>

/*--------------------------------------------------------------------------*/
/*                                                                                                                  */
/*  Function Templates                                                                                    */
/*                                                                                                                  */
/*--------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------*/
/*                                                                                                                  */
/*  Defines                                                                                                        */
/*                                                                                                                  */
/*--------------------------------------------------------------------------*/

#define LBS_MYSTYLE         (LBS_NOTIFY | LBS_OWNERDRAWFIXED | WS_VSCROLL)

#define SHOVEIT(x)          (MAKELONG((x),0))

#define MAXTASKNAMELEN      80
#define MAXMSGBOXLEN        513

#define PWRTASKMANDLG       10
#define WMPTASKMANDLG       11

#define IDD_TEXT            99
#define IDD_TASKLISTBOX     100
#define IDD_TERMINATE       101
#define IDD_CASCADE         102
#define IDD_TILE            103
#define IDD_ARRANGEICONS    104
#define IDD_RUN             105
#define IDD_PATH            106
#define IDD_CLTEXT          107
#define IDD_SWITCH          108

#define IDS_MSGBOXSTR1        201
#define IDS_MSGBOXSTR2        202
#define IDS_EXECERRTITLE      203
#define IDS_NOMEMORYMSG       204
#define IDS_FILENOTFOUNDMSG   205
#define IDS_BADPATHMSG        206
#define IDS_MANYOPENFILESMSG  207
#define IDS_ACCESSDENIED      208
#define IDS_NEWWINDOWSMSG     209
#define IDS_OS2APPMSG         210
#define IDS_MULTIPLEDSMSG     211
#define IDS_PMODEONLYMSG      212
#define IDS_COMPRESSEDEXE     213
#define IDS_INVALIDDLL        214
#define IDS_SHAREERROR        215
#define IDS_ASSOCINCOMPLETE   216
#define IDS_DDEFAIL           217
#define IDS_NOASSOCMSG        218
#define IDS_OOMEXITTITLE      219
#define IDS_OOMEXITMSG        220
#define IDS_UNKNOWNMSG        221



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\cpl\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=themes
TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETEXT=cpl
DLLENTRY=DllMain
DLLDEF=..\thm_cpl.def

SOURCES=          \
    ..\thm_cpl.rc \
    ..\thm_cpl.c

MSC_WARNING_LEVEL=/W3 /WX

UMTYPE=windows

USE_NOLIBS=1
TARGETLIBS= \
    $(SDK_LIB_PATH)\kernel32.lib  \
    $(SDK_LIB_PATH)\user32.lib    \
    $(SDK_LIB_PATH)\shell32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\cpl\thm_cpl.c ===
/****************************************************************************
*
*
*    PROGRAM: Themes.c
*
*    PURPOSE: Themes Control Panel applet
*
*    FUNCTIONS:
*
*        DllMain()
*        InitThemesApplet()
*        TermThemesApplet()
*        CPIApplet()
*
*    Copyright (C) 1994 - 1998 Microsoft Corporation.  All rights reserved.
*
****************************************************************************/

#include <windows.h>
#include <cpl.h>
#include <shellapi.h>
#include "thm_cpl.h"

#define NUM_APPLETS 1
#define EXE_NAME_SIZE 14

HANDLE hModule = NULL;

TCHAR szCtlPanel[30];

/****************************************************************************
*
*    FUNCTION: DllMain(PVOID, ULONG, PCONTEXT)
*
*    PURPOSE: Win 32 Initialization DLL
*
*    COMMENTS:
*
*
****************************************************************************/

BOOL WINAPI DllMain(
IN PVOID hmod,
IN ULONG ulReason,
IN PCONTEXT pctx OPTIONAL)
{
    if (ulReason != DLL_PROCESS_ATTACH)
    {
        return TRUE;
    }
    else
    {
        hModule = hmod;
    }

    return TRUE;

    UNREFERENCED_PARAMETER(pctx);
}


/****************************************************************************
*
*    FUNCTION: InitThemesApplet (HWND)
*
*    PURPOSE: loads the caption string for the Control Panel
*
*    COMMENTS:
*
*
****************************************************************************/

BOOL InitThemesApplet (HWND hwndParent)
{
    LoadString (hModule, CPCAPTION, szCtlPanel, ARRAYSIZE(szCtlPanel));

    return TRUE;

    UNREFERENCED_PARAMETER(hwndParent);
}


/****************************************************************************
*
*    FUNCTION: TermThemesApplet()
*
*    PURPOSE: termination procedure for the stereo applets
*
*    COMMENTS:
*
*
****************************************************************************/

void TermThemesApplet()
{
    return;
}



/****************************************************************************
*
*    FUNCTION: CPIApplet(HWND, UINT, lPARAM, lPARAM)
*
*    PURPOSE: Processes messages for control panel applet
*
*    COMMENTS:
*
*
****************************************************************************/
LONG CALLBACK CPlApplet (hwndCPL, uMsg, lParam1, lParam2)
HWND hwndCPL;       // handle of Control Panel window
UINT uMsg;          // message
LPARAM lParam1;       // first message parameter
LPARAM lParam2;       // second message parameter
{
    LPNEWCPLINFO lpNewCPlInfo;
    LPCPLINFO lpCPlInfo;
    static iInitCount = 0;
    
    TCHAR szEXE_Name[ EXE_NAME_SIZE ];
            
    switch (uMsg) {
        case CPL_INIT:              // first message, sent once
            if (!iInitCount)
            {
                if (!InitThemesApplet(hwndCPL))
                    return FALSE;
            }
            iInitCount++;
            return TRUE;

        case CPL_GETCOUNT:          // second message, sent once
            return (LONG)NUM_APPLETS;
            break;

        case CPL_NEWINQUIRE:        // third message, sent once per app
            lpNewCPlInfo = (LPNEWCPLINFO) lParam2;
            lpNewCPlInfo->dwSize = (DWORD) sizeof(NEWCPLINFO);
            lpNewCPlInfo->dwFlags = 0;
            lpNewCPlInfo->dwHelpContext = 0;
            lpNewCPlInfo->lData = 0;
            lpNewCPlInfo->hIcon = LoadIcon (hModule,
                (LPCTSTR) MAKEINTRESOURCE(THEMES_ICON));
            lpNewCPlInfo->szHelpFile[0] = TEXT('\0');

            LoadString (hModule, THEMES_CPL_NAME,
                        lpNewCPlInfo->szName, 32);

            LoadString (hModule, THEMES_CPL_CAPTION,
                        lpNewCPlInfo->szInfo, 64);

#ifdef DEBUG
            OutputDebugString(TEXT("\nCPL_NEWINQUIRE Name: "));
            OutputDebugString(lpNewCPlInfo->szName);
            OutputDebugString(TEXT("\n"));

            OutputDebugString(TEXT("\nCPL_NEWINQUIRE Caption: "));
            OutputDebugString(lpNewCPlInfo->szInfo);
            OutputDebugString(TEXT("\n"));
#endif // DEBUG

            break;

        case CPL_INQUIRE:        // for backward compat & speed
            lpCPlInfo = (LPCPLINFO) lParam2;
            lpCPlInfo->lData = 0;
            lpCPlInfo->idIcon = THEMES_ICON; // MAKEINTRESOURCE(THEMES_ICON);
            lpCPlInfo->idName = THEMES_CPL_NAME; // MAKEINTRESOURCE(THEMES_CPL_NAME);
            lpCPlInfo->idInfo = THEMES_CPL_CAPTION; // MAKEINTRESOURCE(THEMES_CPL_CAPTION);
            break;


        case CPL_SELECT:            // application icon selected
            break;


        case CPL_DBLCLK:            // application icon double-clicked
			LoadString( hModule, 
						EXE_NAME,
						szEXE_Name,
						EXE_NAME_SIZE );

			ShellExecute( hwndCPL,
                                 TEXT("open"),
                                   szEXE_Name,
                                         NULL,
                                         NULL,
                                             1 );
            break;

         case CPL_STOP:              // sent once per app. before CPL_EXIT
            break;

         case CPL_EXIT:              // sent once before FreeLibrary called
            iInitCount--;
            if (!iInitCount)
                TermThemesApplet();
            break;

         default:
            break;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\taskman\taskman.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    taskman.c

Abstract:

    This file contains the source for the windows Task Manager.
    Taskman basically is a dialog box, which enumerates active windows
    keep in the user window manager, then sets active focus to the selected
    dialog box element(ie active window).

--*/

#define UNICODE

#include "taskman.h"
#include <port1632.h>
#include <shellapi.h>
#include <shlapip.h>

//LATER find correct define for NT
#if !defined(NTWIN) && !defined(DOSWIN32) && !defined(WIN16)
#define NTWIN   1
#endif

#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))

#define MAXPATHFIELD 260

#define INIT_MAX_FILES 4
#define FILES_KEY  L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Program Manager\\Recent File List"
#define MAXFILES_ENTRY L"Max Files"
#define FILE_ENTRY L"File%lu"

#define WM_CONTENTSCHANGED (WM_USER+5)

TCHAR szPathField[MAXPATHFIELD];
TCHAR szDirField[MAXPATHFIELD];
TCHAR szTitle[MAXPATHFIELD];
TCHAR szMessage[MAXMSGBOXLEN];

TCHAR szUserHomeDir[MAXPATHFIELD];
TCHAR szWindowsDirectory[MAXPATHFIELD];

TCHAR szOOMExitMsg[64] = TEXT("Close an application and try again."); // 64
TCHAR szOOMExitTitle[32] = TEXT("Extremely Low on Memory"); // 32

TCHAR szNoRun[] = TEXT("NoRun");
// registry key for groups

HANDLE hInst;

BOOL bChangedDefaultButton;

INT_PTR APIENTRY TaskmanDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);

WORD APIENTRY ExecProgram(LPTSTR lpszPath,LPTSTR lpDir,LPTSTR lpTitle);
void APIENTRY SaveRecentFileList (HWND, LPTSTR);

VOID GetPathInfo(PTSTR szPath,PTSTR *pszFileName,PTSTR *pszExt,WORD *pich,BOOL *pfUnc);
VOID GetFilenameFromPath(PTSTR szPath, PTSTR szFilename);
VOID GetDirectoryFromPath(PTSTR szFilePath, PTSTR szDir);
BOOL IsUserAdmin();
BOOL OKToExec();
BOOL TestTokenForAdmin(HANDLE Token);
VOID SetDefButton(HWND hwndDlg, INT  idButton);

WINUSERAPI VOID SwitchToThisWindow(HWND, BOOL);
INT MyMessageBox(HWND hWnd,WORD idTitle,WORD idMessage,PWSTR psz,WORD wStyle);

INT MyX = 0;
INT MyY = 0;
INT dxTaskman;
INT dyTaskman;
INT dxScreen;
INT dyScreen;

HWND ghwndDialog;
BOOL fExecOK = TRUE;
BOOL fMsgBox = FALSE;


PVOID Alloc(
    DWORD   Bytes)
{
    HANDLE  hMem;
    PVOID   Buffer;

    hMem = LocalAlloc(LMEM_MOVEABLE, Bytes + sizeof(hMem));

    if (hMem == NULL) {
        return(NULL);
    }

    Buffer = LocalLock(hMem);
    if (Buffer == NULL) {
        LocalFree(hMem);
        return(NULL);
    }

    *((PHANDLE)Buffer) = hMem;

    return (PVOID)(((PHANDLE)Buffer)+1);
}


BOOL Free(
    PVOID   Buffer)
{
    HANDLE  hMem;

    hMem = *(((PHANDLE)Buffer) - 1);

    LocalUnlock(hMem);

    return(LocalFree(hMem) == NULL);
}


VOID
HideWindow(HWND hwnd)
{
   if (!fMsgBox) {

      if (fExecOK) {
         SetDlgItemText(ghwndDialog, IDD_PATH, TEXT(""));
      }

      // redundant?  why do they do the reverse twice for show below?
      ShowWindow(ghwndDialog, SW_HIDE);

      SetWindowPos(ghwndDialog, HWND_NOTOPMOST, 0, 0, 0, 0,
         SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
   }

   // Erase dark border from depressed pushbuttons
   SendMessage(GetDlgItem(hwnd, IDCANCEL), // IDCANCEL
      BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE, 0));
   SendMessage(GetDlgItem(hwnd, IDD_TERMINATE),
      BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE, 0));
   SendMessage(GetDlgItem(hwnd, IDD_CASCADE),
      BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE, 0));
   SendMessage(GetDlgItem(hwnd, IDD_TILE),
      BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE, 0));
   SendMessage(GetDlgItem(hwnd, IDD_ARRANGEICONS),
      BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE, 0));
}

/*
 * We call HideTasklist() when we want to remove the tasklist window
 * from the screen but not select another window (ie. when we're about
 * to select another app.  We call ShowWindow(SW_HIDE) directly when
 * we're doing something like tiling or cascading so a window other than
 * the tasklist will become the foreground window.
 */
VOID HideTasklist(VOID)
{
    if (fExecOK) {
       SetDlgItemText(ghwndDialog, IDD_PATH, TEXT(""));
    }

    SetWindowPos(ghwndDialog, HWND_TOP, 0, 0, 0, 0, SWP_HIDEWINDOW |
            SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER);

}


VOID ShowTasklist(
   POINT pt)
{
    /*
     * Retract the drop down listbox.
     */

     if (fExecOK) {
        SendDlgItemMessage(ghwndDialog, IDD_PATH,
                           CB_SHOWDROPDOWN,0,0);
     }

    SetWindowPos(ghwndDialog, HWND_TOPMOST, pt.x, pt.y, 0, 0,
       SWP_NOSIZE | SWP_NOACTIVATE );
    SetForegroundWindow(ghwndDialog);

    ShowWindow(ghwndDialog, SW_NORMAL);
}


/*** ActivateSelectedWindow --         Calls user, to set active window, selected
 *                                                                 by the user.
 *
 *
 * ActivateSelectedWindow(HWND hwndLB)
 *
 * ENTRY -         HWND hwndLB - handle to window, which is to become the active
 *                                                  window, with focus.
 * EXIT  -
 * SYNOPSIS -  This function takes the hwnd passed into it, calls user
 *                                to set active focus to that window.
 * WARNINGS -
 * EFFECTS  -
 *
 */

VOID ActivateSelectedWindow(
    HWND hwndLB)
{
   INT nIndex;
   HWND hwndT;
   HWND hwndLastActive;
   DWORD lTemp;

    /*
     * Get the hwnd of the item which was selected.
     */
    nIndex = (int)SendMessage(hwndLB, LB_GETCURSEL, 0, 0);
    hwndT = (HWND)SendMessage(hwndLB, LB_GETITEMDATA, nIndex, 0);

    if (!IsWindow(hwndT)) {
        /*
         * We gotta make sure the window is valid before doing stuff with it.
         * An app may terminate itself in the background rendering these
         * window handles invalid.
         */
        goto Beep;
    }

    /*
     * Switch to that task.
     * HACK! Activate the window in the hwndLastActive field of the WndStruct.
     */
    hwndLastActive = GetLastActivePopup(hwndT);

    if (!IsWindow(hwndLastActive)) {
        goto Beep;
    }

    /*
     * But only if it isn't disabled.
     */
    lTemp = GetWindowLong(hwndLastActive, GWL_STYLE);
    if (!(lTemp & WS_DISABLED)) {
        /*
         * HACK!! Use SwitchToThisWindow() to bring dialog parents as well.
         */
        SwitchToThisWindow(hwndLastActive, TRUE);

    } else {
Beep:
        MessageBeep(0);
    }
}

#ifdef NTWIN
/*** DoEndTask --
 *
 * void DoEndTask( HWND hwnd )
 */
VOID DoEndTask(
   HWND hwnd )
{
   TCHAR szMsgBoxText[MAXMSGBOXLEN];
   TCHAR szTempField[MAXTASKNAMELEN];
   INT nch;


   if (!EndTask(hwnd, FALSE, FALSE)) {
      /* App does not want to close, ask user if
       * he wants to blow it away
       */

       InternalGetWindowText(hwnd, (LPTSTR)szTempField, MAXTASKNAMELEN);

       /* Load the message box string, it is very long (greater than 255 chars
        * which is why we load it in two pieces
        */
        nch = LoadString(NULL, IDS_MSGBOXSTR1, szMsgBoxText, MAXMSGBOXLEN);
        LoadString(NULL, IDS_MSGBOXSTR2, &szMsgBoxText[nch], MAXMSGBOXLEN-nch);

        if( MessageBox( NULL, szMsgBoxText, szTempField,
                MB_SETFOREGROUND | MB_SYSTEMMODAL | MB_YESNO ) == IDYES) {
            EndTask(hwnd, FALSE, TRUE);
        }
    }
}


/*** CallEndTask --                 A separate thread to instigate EndTask
 *
 * CallEndTask( HWND hwnd );
 *
 * ENTRY -      HWND hwnd - window handle for the task to be killed
 * EXIT  -
 * SYNOPSIS -  This function calls EndTask on the given window to kill the
 *              task that owns that window.
 *
 * WARNINGS -
 * EFFECTS  -   Kills the task that owns hwnd.
 *
 */

DWORD CallEndTask(
    HWND hwnd)
{
    DoEndTask(hwnd);

    ExitThread(0);
    return 0; /* placate compiler */
}
#endif


/*** TaskmanDlgProc --         Dialog Procedure for Taskman Window
 *
 *
 *
 * TaskmanDlgProc(HWND hDlg, WORD wMSG, DWORD wParam, LPARAM lParam)
 *
 * ENTRY -         HWND hhDlg                 - handle to dialog box.
 *                        WORD wMsg                  - message to be acted upon.
 *                        DWORD wParam        - value specific to wMsg.
 *                        LPARAM lParam                - value specific to wMsg.
 *
 * EXIT  -           True if success, False if not.
 * SYNOPSIS -  Dialog box message processing function.
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */

INT_PTR TaskmanDlgProc(
    HWND hwnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    int nIndex;
    RECT rc;
    HWND hwndLB;
    HWND hwndNext;
    TCHAR szTempField[MAXTASKNAMELEN];
    POINT pt;
    HKEY  hKey;
    DWORD dwDisp;
    DWORD dwDataType, dwMaxFiles=INIT_MAX_FILES, dwMaxFilesSize, dwCount;
    TCHAR szFileEntry[20];
    TCHAR szFullPath[MAXPATHFIELD];
#ifndef NTWIN
    LONG lTemp;
#endif

    hwndLB = GetDlgItem(hwnd, IDD_TASKLISTBOX);

    switch (wMsg) {

    case WM_INITDIALOG:
        /*
         * call private api to mark task man as a system app. This causes
         * it to be killed after all other non-system apps during shutdown.
         */
//      MarkProcess(MP_SYSTEMAPP);
        GetWindowRect(hwnd, &rc);
        dxTaskman = rc.right - rc.left;
        dyTaskman = rc.bottom - rc.top;
        dxScreen = GetSystemMetrics(SM_CXSCREEN);
        dyScreen = GetSystemMetrics(SM_CYSCREEN);

        pt.x = (dxScreen - dxTaskman) / 2;
        pt.y = (dyScreen - dyTaskman) / 2;

        SetWindowPos(hwnd, HWND_NOTOPMOST, pt.x, pt.y, 0, 0,
           SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);

        SendDlgItemMessage(hwnd, IDD_PATH, EM_LIMITTEXT, MAXPATHFIELD-4, 0L);
        szPathField[0] = TEXT('\0');

        bChangedDefaultButton = FALSE;

        return FALSE;

    case WM_SHOWWINDOW:
        /*
         * If we're being shown fill in the listbox.  We do this here
         * rather than in WM_ACTIVATE process so we can do it while the
         * dialog is still invisible.
         */
        if (wParam != 0) {
            DWORD pidTaskMan = GetCurrentProcessId();

            /*
             * First delete any previous entries.
             */
            while ((int)SendMessage(hwndLB, LB_DELETESTRING, 0, 0) != LB_ERR);

            /*
             * Search the window list for enabled top level windows.
             */
            hwndNext = GetWindow(hwnd, GW_HWNDFIRST);
            while (hwndNext) {

                /*
                 * Only add non-owned, visible, non-Taskman, Top Level Windows.
                 */
                if ((hwndNext != hwnd) && (IsWindowVisible(hwndNext)) &&
                        (!GetWindow(hwndNext, GW_OWNER))) {
                    DWORD pidNext;
                    GetWindowThreadProcessId(hwndNext, &pidNext);
                    if (pidNext != pidTaskMan) {
                        if (InternalGetWindowText(hwndNext, (LPTSTR)szTempField,
                                MAXTASKNAMELEN)) {
                            nIndex = (int)SendMessage(hwndLB, LB_ADDSTRING, 0,
                                    (DWORD_PTR)(LPTSTR)szTempField);
                            SendMessage(hwndLB, LB_SETITEMDATA, nIndex,
                                    (DWORD_PTR)hwndNext);
                        }
                    }
                }

                hwndNext = GetWindow(hwndNext, GW_HWNDNEXT);
            }
            SendMessage(hwndLB, LB_SETCURSEL, 0, 0);

            //
            // Set the default button to "Switch To"
            //

            SetDefButton(hwnd,IDD_SWITCH);

            //
            // Load the combobox with the recently used files.
            //

            if (GetDlgItem(hwnd, IDD_PATH)) {

                //
                // FIrst empty the combo box from the last time.
                //

                SendDlgItemMessage (hwnd, IDD_PATH,
                                    CB_RESETCONTENT, 0, 0);


                //
                // Load the combobox with recently used files from the registry.
                //
                // Query the max number of files first.
                //

                if (RegCreateKeyEx (HKEY_CURRENT_USER, FILES_KEY, 0, 0,
                                    REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                                    NULL, &hKey, &dwDisp) == ERROR_SUCCESS) {

                    if (dwDisp == REG_OPENED_EXISTING_KEY) {

                        //
                        //  Query the max number of entries
                        //

                        dwMaxFilesSize = sizeof (DWORD);

                        if (RegQueryValueEx (hKey, MAXFILES_ENTRY, NULL, &dwDataType,
                                       (LPBYTE)&dwMaxFiles, &dwMaxFilesSize) == ERROR_SUCCESS) {

                            //
                            //  Now Query each entry and add it to the list box.
                            //

                            for (dwCount=0; dwCount < dwMaxFiles; dwCount++) {

                                wsprintf (szFileEntry, FILE_ENTRY, dwCount);
                                dwMaxFilesSize = MAXPATHFIELD+1;

                                if (RegQueryValueEx (hKey, szFileEntry, NULL, &dwDataType,
                                                 (LPBYTE) szFullPath, &dwMaxFilesSize) == ERROR_SUCCESS) {

                                    //
                                    // Found an entry.  Add it to the combo box.
                                    //

                                    SendDlgItemMessage (hwnd, IDD_PATH,
                                                        CB_ADDSTRING, 0,
                                                        (LPARAM)szFullPath);

                                } else {
                                    break;
                                }
                            }
                        }
                    } else {
                        //
                        // We are working with a new key, so we need to
                        // set the default number of files.
                        //

                        RegSetValueEx (hKey, MAXFILES_ENTRY, 0, REG_DWORD,
                                       (CONST BYTE *) &dwMaxFiles, sizeof (DWORD));
                    }

                    //
                    //  Close the registry key
                    //

                    RegCloseKey (hKey);

                }
            }

            //
            // Disable the Run button and set the focus to the
            // listbox.
            //

            EnableWindow(GetDlgItem(hwnd, IDD_RUN), FALSE);
            SetFocus(hwndLB);
        }
        break;

    case WM_ACTIVATE:
        /*
         * If we're being deactivated clear the listbox so we
         * can fill it in afresh when we're re-activated.
         */
        if (wParam == 0) {
            /*
             * If we're not already invisible, hide ourself.
             */
            if (IsWindowVisible(hwnd)) {
                HideWindow(hwnd);
            }
        }

        if (!bChangedDefaultButton) {
           SetDefButton(hwnd,IDD_SWITCH);
        }

        break;

    case WM_ACTIVATEAPP:
        if (wParam)
            return FALSE;

        /*
         * If we are not visible when we get this message it is because
         * we are already in the process of terminating.  If we don't
         * ignore this we get into a weird race condition and the frame
         * of the window being activated doesn't get fully drawn.  (BG)
         */
        if (IsWindowVisible(hwnd)) {
            HideWindow(hwnd);
        }
        break;

#ifdef JAPAN // bug fix
    //
    // Do nothing. Let the progman main thread do the work.
    //
#else // not JAPAN
    case WM_WININICHANGE:
        //
        // Check if the user's environment variables have changed, if so
        // regenerate the environment, so that new apps started from
        // taskman will have the latest environment.
        //
        if (lParam && (!lstrcmpi((LPTSTR)lParam, (LPTSTR) TEXT("Environment")))) {
            PVOID pEnv;

            RegenerateUserEnvironment(&pEnv, TRUE);
            break;
        }
        else {
            return FALSE;
        }
#endif // JAPAN

    case WM_CONTENTSCHANGED:
       if (fExecOK) {
          if (GetDlgItemText(hwnd, IDD_PATH, (LPTSTR)szPathField, MAXPATHFIELD)) {
             EnableWindow(GetDlgItem(hwnd, IDD_RUN), TRUE);
             if (!bChangedDefaultButton) {
                SetDefButton(hwnd,IDD_RUN);
                bChangedDefaultButton = TRUE;
             }
          } else {
             EnableWindow(GetDlgItem(hwnd, IDD_RUN), FALSE);
             if (bChangedDefaultButton) {
                SetDefButton(hwnd,IDD_SWITCH);
                bChangedDefaultButton = FALSE;
             }
          }
       }

       break;


    case WM_COMMAND:
        switch(LOWORD(wParam)) {

        case IDD_TASKLISTBOX:

            switch(HIWORD(wParam)) {

            case LBN_DBLCLK:
                HideTasklist();
                ActivateSelectedWindow(hwndLB);
                break;

            default:
                return FALSE;
            }
            break;

        case IDD_PATH:
           PostMessage (hwnd, WM_CONTENTSCHANGED, 0, 0);
           break;


        case IDOK:
           if (!bChangedDefaultButton) {
              goto Switchem;
           }

        case IDD_RUN:
           if (fExecOK) {
              TCHAR szFilename[MAXPATHFIELD+4];
              WORD ret;

              GetDlgItemText(hwnd, IDD_PATH, szPathField, MAXPATHFIELD);
              DoEnvironmentSubst(szPathField, MAXPATHFIELD);
              GetDirectoryFromPath(szPathField, szDirField);
              if (*szDirField) {
                  // Convert path into a .\foo.exe style thing.
                  lstrcpy(szFilename, L".\\");
                  // Tag the filename and params on to the end of the dot slash.
                  GetFilenameFromPath(szPathField, szFilename+2);
                  if (*(szFilename+2) == L'"' ) {
                      SheRemoveQuotes(szFilename+2);
                      CheckEscapes(szFilename, ARRAYSIZE(szFilename));
                  }
              }
              else {
                  GetFilenameFromPath(szPathField, szFilename);
              }

              ret = ExecProgram(szFilename, szDirField, szFilename);

              if (ret) {
                 fMsgBox = TRUE;
                 MyMessageBox( hwnd, IDS_EXECERRTITLE, ret, szPathField,
                    MB_SYSTEMMODAL | MB_OK | MB_ICONEXCLAMATION );
                 fMsgBox = FALSE;

                 SetFocus(GetDlgItem(hwnd, IDD_PATH));
              } else {
                 GetDlgItemText(hwnd, IDD_PATH, szPathField, MAXPATHFIELD);
                 SaveRecentFileList (hwnd, szPathField);
                 HideWindow(hwnd);
              }

           }
           break;

Switchem:

        case IDD_SWITCH:
            HideTasklist();
            ActivateSelectedWindow(hwndLB);
            break;

        case IDCANCEL:
           HideWindow(hwnd);
           break;

        case IDD_TERMINATE:
            /*
             * Get the hwnd of the item which was selected.
             */
            nIndex = (int)SendMessage(hwndLB, LB_GETCURSEL, 0, 0);
            hwndNext = (HWND)SendMessage(hwndLB, LB_GETITEMDATA, nIndex, 0);

            if (!IsWindow(hwndNext)) {
                HideWindow(hwnd);
                MessageBeep(0);
                break;
            }

#ifndef NTWIN   /* Since NTWIN uses WM_ENDSESSION to kill the app,
                 * It is OK to kill it when it is disabled
                 */
            /*
             * Test if the toplevel window is disabled. If it is
             * diabled, we don't want to send a WM_CLOSE message to
             * the parent. This is because the app could have a dialog
             * box up and it's not expecting a CLOSE message...
             * Nasty rips can happen... Instead, active the window so
             * that the user can dismis any dialog box or fix whatever
             * is causing the top level window to be disabled...
             */
            lTemp = GetWindowLong(hwndNext, GWL_STYLE);
            if (lTemp & WS_DISABLED) {
                HideTasklist();
                MessageBeep(0);
                ActivateSelectedWindow(hwndLB);

            } else
#endif
            {
                /* Always activate the window first.  This prevents
                 * apps from going to Beep mode.  Failing to do this
                 * can cause re-entrancy problems in the app if we
                 * do this again before activating the app.
                 *
                 * However, don't do this if it is a old app task.
                 */

#ifdef WIN16    /* if NTWIN, then always do this, as is no winoldapp */
                if (!IsWinoldapTask(GetTaskFromHwnd(hwndNext)))
#endif
                HideWindow(hwnd);
                ActivateSelectedWindow(hwndLB);
#ifdef NTWIN
                {
                    DWORD idt;
                    HANDLE hThread;

                    hThread = CreateThread(NULL, 0,
                             (LPTHREAD_START_ROUTINE)CallEndTask,
                             (LPVOID)hwndNext, 0,
                             &idt);

                    if (hThread == NULL) {
                        /*
                         * Can not create thread, just call EndTask
                         * syncronously
                         */
                        DoEndTask( hwndNext );
                    } else {
                        CloseHandle(hThread);
                    }
                }
#else
                EndTask(hwndNext, FALSE, FALSE);
#endif
            }

            break;

        case IDD_TILE:
        case IDD_CASCADE:
            {
                HWND hwndDesktop;

                HideWindow(hwnd);

                hwndDesktop = GetDesktopWindow();

                if (wParam == IDD_CASCADE) {
                    CascadeChildWindows(hwndDesktop, 0);

                } else {
                    /*
                     * If shift is down, tile vertically, else horizontally.
                     */
                    TileChildWindows(hwndDesktop, ((GetKeyState(VK_SHIFT) &
                            0x8000) ? MDITILE_HORIZONTAL : MDITILE_VERTICAL));
                }
                break;
            }

        case IDD_ARRANGEICONS:
            /*
             * Let's restore the saved bits before ArrangeIcons
             * FIX for Bug #4884; --SANKAR-- 10-02-89
             */
            HideWindow(hwnd);
            ArrangeIconicWindows(GetDesktopWindow());
            break;
        }

        break;


    case WM_CLOSE:
        /*
         * If wParam != 0, this is a shutdown request, so exit.
         */
        if (wParam != 0)
            ExitProcess(0);
        return FALSE;
        break;

    case WM_HOTKEY:
        if (wParam == 1) {
            pt.x = (dxScreen - dxTaskman) / 2;
            pt.y = (dyScreen - dyTaskman) / 2;
            ShowTasklist(pt);
        }
        break;

    case WM_LOGOFF:
        PostQuitMessage(0);
        break;

    default:
        return FALSE;
    }

    return TRUE;

    lParam;
}

//*************************************************************
//
//  SetDefButton()
//
//  Purpose:    Sets the default button
//
//  Parameters: HWND hDlg     - Window handle of dialog box
//              INT  idButton - ID of button
//
//  Return:     void
//
//*************************************************************

VOID SetDefButton(HWND hwndDlg, INT  idButton)
{
    LRESULT lr;

    if (HIWORD(lr = SendMessage(hwndDlg, DM_GETDEFID, 0, 0)) == DC_HASDEFID)
    {
        HWND hwndOldDefButton = GetDlgItem(hwndDlg, LOWORD(lr));

        SendMessage (hwndOldDefButton,
                     BM_SETSTYLE,
                     MAKEWPARAM(BS_PUSHBUTTON, 0),
                     MAKELPARAM(TRUE, 0));
    }

    SendMessage( hwndDlg, DM_SETDEFID, idButton, 0L );
    SendMessage( GetDlgItem(hwndDlg, idButton),
                 BM_SETSTYLE,
                 MAKEWPARAM( BS_DEFPUSHBUTTON, 0 ),
                 MAKELPARAM( TRUE, 0 ));

}


/*** SaveRecentFileList --    Save the list of recently used files
 *
 * void APIENTRY SaveRecentFileList (HWND hwnd, LPTSTR szCurrentFile);
 *
 *
 *
 * ENTRY - HWND   hwnd            - handle to dialog box.
 *         LPTSTR szCurrentFile   - pointer to selected filename
 *
 * EXIT  -
 * SYNOPSIS -
 *
 * WARNINGS -
 * EFFECTS  -
 *
 */


void APIENTRY SaveRecentFileList (HWND hwnd, LPTSTR szCurrentFile)
{
    HKEY  hKey;
    DWORD dwDisp;
    DWORD dwDataType, dwMaxFiles=INIT_MAX_FILES, dwMaxFilesSize, dwCount;
    TCHAR szFileEntry[20];
    DWORD dwEnd=0;
    DWORD dwFileNum=0;
    DWORD dwDup;
    static TCHAR szRecentFilePath[MAXPATHFIELD+1];

    //
    // Open registry key
    //

    if ( RegCreateKeyEx (HKEY_CURRENT_USER, FILES_KEY, 0, 0,
                             REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                             NULL, &hKey, &dwDisp) != ERROR_SUCCESS) {
        return;
    }


    //
    // Query the max number of files to save first.
    //

    dwMaxFilesSize = sizeof (DWORD);

    RegQueryValueEx (hKey, MAXFILES_ENTRY, NULL, &dwDataType,
                    (LPBYTE)&dwMaxFiles, &dwMaxFilesSize);

    //
    // If the user request 0 entries, then exit now.
    //
    if (dwMaxFiles == 0) {
        RegCloseKey (hKey);
        return;
    }

    //
    // Find out how many items are in the list box.
    //

    dwEnd = (DWORD)SendDlgItemMessage (hwnd, IDD_PATH, CB_GETCOUNT, 0, 0);

    //
    // If the max number of items we want to save is less than the
    // number of entries, then change the ending point.
    //

    if (dwMaxFiles < dwEnd) {
        dwEnd = dwMaxFiles;
    }

    //
    // Add the first entry (the current file)
    //

    wsprintf (szFileEntry, FILE_ENTRY, dwFileNum++);
    dwMaxFilesSize = MAXPATHFIELD+1;

    RegSetValueEx (hKey, szFileEntry, 0, REG_SZ, (CONST BYTE *)szCurrentFile,
                   sizeof (TCHAR) * (lstrlen (szCurrentFile)+1));


    //
    // Check for a duplicate string.
    //

    dwDup = (DWORD)SendDlgItemMessage (hwnd, IDD_PATH, CB_FINDSTRING,
                                (WPARAM) -1, (LPARAM) szCurrentFile);

    //
    // If we already have dwMaxFiles in the list and we don't have any
    // duplicates, then we only want to save dwMaxFiles - 1 entries
    // (drop the last entry).
    //
    //

    if ( (dwEnd == dwMaxFiles) && (dwDup == CB_ERR) ) {
        dwEnd--;
    }

    //
    // Now loop through the remaining entries
    //

    for (dwCount=0; dwCount < dwEnd; dwCount++) {

        //
        // Check to see if we are at the duplicate entry.  If
        // so skip on to the next item.
        //

        if ((dwDup != CB_ERR) && (dwCount == dwDup)) {
            continue;
        }

        //
        // Get an entry out of the listbox.
        //

        SendDlgItemMessage (hwnd, IDD_PATH, CB_GETLBTEXT, (WPARAM) dwCount,
                            (LPARAM) szRecentFilePath);

        //
        // If we get a NULL string, break out of the loop.
        //

        if (!(*szRecentFilePath) || !szRecentFilePath) {
            break;
        }

        //
        // Build the entry name
        //

        wsprintf (szFileEntry, FILE_ENTRY, dwFileNum);
        dwMaxFilesSize = MAXPATHFIELD+1;

        //
        // Save the entry
        //

        RegSetValueEx (hKey, szFileEntry, 0, REG_SZ,(CONST BYTE *) szRecentFilePath,
                       sizeof (TCHAR) * (lstrlen (szRecentFilePath)+1));

        //
        // Increment our current file number
        //

        dwFileNum++;
    }

    //
    // Close the key
    //

    RegCloseKey (hKey);

}



/*** Main --         Program entry point (was WinMain).
 *
 *
 *
 * Main(int argc, char *argv[], char *envp[])
 *
 * ENTRY -         int argc                - argument count.
 *                        char *argv[]        - argument list.
 *                        char *envp[]        - environment.
 *
 * EXIT  -           TRUE if success, FALSE if not.
 * SYNOPSIS -  Parses command line, for position to place dialog box, if no
 *                                position (came from ctl/esc) then center on screen.
 *                                Also make sure only one instance of taskman.
 *
 * WARNINGS -
 * EFFECTS  -
 */

INT __cdecl main(
   INT argc,
   CHAR *argv[],
   CHAR *envp[])
{
   MSG msg;

   /*
    * First set the priority of taskman so it is higher than foreground apps
    * that spin in loops - this way it'll always come up when you hit
    * ctrl-esc.
    */
   hInst = GetModuleHandle(NULL);

   SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);

   {
       //
       // Set the working set size to 200k.
       //

       QUOTA_LIMITS QuotaLimits;
       NTSTATUS status;

       status = NtQueryInformationProcess( NtCurrentProcess(),
                                           ProcessQuotaLimits,
                                           &QuotaLimits,
                                           sizeof(QUOTA_LIMITS),
                                           NULL );
       if (NT_SUCCESS(status)) {
           QuotaLimits.MinimumWorkingSetSize = 300 * 1024;
           QuotaLimits.MaximumWorkingSetSize = 372 * 1024;

           NtSetInformationProcess( NtCurrentProcess(),
                                    ProcessQuotaLimits,
                                    &QuotaLimits,
                                    sizeof(QUOTA_LIMITS) );
       }
   }

   /*
    * Taskman will work in the windows directory, and switch to the
    * original directory (home directory) before execing programs.
    * This is to prevent weird popups if a UNC original directory is
    * disconnected.
    */

   GetCurrentDirectory(MAXPATHFIELD, szUserHomeDir);
   GetWindowsDirectory(szWindowsDirectory, MAXPATHFIELD);
   SetCurrentDirectory(szWindowsDirectory);

   fExecOK = OKToExec();
   if (!IsUserAdmin() && !fExecOK) {
      ghwndDialog = CreateDialog(hInst, MAKEINTRESOURCE(WMPTASKMANDLG), NULL,
         TaskmanDlgProc);
   } else {
      ghwndDialog = CreateDialog(hInst, MAKEINTRESOURCE(PWRTASKMANDLG), NULL,
         TaskmanDlgProc);
   }

   if (ghwndDialog == NULL)
       return 0;

   LoadString(hInst, IDS_OOMEXITTITLE, szOOMExitTitle, 32);
   LoadString(hInst, IDS_OOMEXITMSG, szOOMExitMsg, 64);

   if (!RegisterHotKey(ghwndDialog, 1, MOD_CONTROL, VK_ESCAPE) ||
           !RegisterTasklist(ghwndDialog)) {
       goto exit;
   }

   while (GetMessage(&msg, (HWND)NULL, (UINT)0, (UINT)0)) {
       if (!IsDialogMessage(ghwndDialog, &msg)) {
          if ((msg.message == WM_SYSCOMMAND) && (msg.wParam == SC_TASKLIST)) {
             POINT pt;

             GetCursorPos(&pt);
             pt.x = max(pt.x - (dyTaskman / 2), 0);
             pt.x = min(pt.x, dxScreen - dxTaskman);
             pt.y = max(pt.y - (GetSystemMetrics(SM_CYCAPTION) * 2), 0);
             pt.y = min(pt.y, dyScreen - dyTaskman);

             ShowTasklist(pt);
          } else {

              //
              //  We need to have a regular message loop in order
              //  to handle the DDE messages generated by spawning
              //  an application via an association.
              //

              TranslateMessage (&msg);
              DispatchMessage (&msg);
          }

       }
   }

exit:
    DestroyWindow(ghwndDialog);
    return 0;

    argc;
    argv;
    envp;
}


WORD APIENTRY
ExecProgram(
    LPTSTR lpszPath,
    LPTSTR lpDir,
    LPTSTR lpTitle
    )
{
  WORD      ret;
  HCURSOR   hCursor;
  LPTSTR     lpP;
  TCHAR cSeparator;
  TCHAR lpReservedFormat[] = TEXT("dde.%d,hotkey.%d");
  TCHAR lpReserved[100];  // used for DDE request of icons from console apps
                         // add for passing the hotkey associated with an item.
  HANDLE hProcess;

  ret = 0;

  /*
   * Set the current directory to the user's home directory if possible.
   */
  SetCurrentDirectory(szUserHomeDir);

  hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

  /* Don't mess with the mouse state; unless we're on a mouseless system.
   */
  if (!GetSystemMetrics(SM_MOUSEPRESENT))
      ShowCursor(TRUE);

  /* skip leading spaces
   */
  while (*lpszPath == TEXT(' '))
      lpszPath++;

  /* skip past path
   */
  lpP = lpszPath;
  if (*lpszPath == TEXT('"')) {
     cSeparator = TEXT('"');
     lpP++;
  }
  else {
     cSeparator = TEXT(' ');
  }

  for (; *lpP && *lpP != cSeparator; lpP = CharNext(lpP))
      ;
  if (*lpP == TEXT('"')) {
     lpP++;
  }

  /* if stuff on end, separate it
   */
  if (*lpP)
      *lpP++ = 0;


  /* Try to exec 'szCommandLine'. */

  /*changed order, since wPendINstance is a 32b HANDLE, and ret is WORD*/
    if (!lpP)
        lpP = TEXT("");

    wsprintf(lpReserved, lpReservedFormat, 0, 0);

    ret = (WORD)RealShellExecute(ghwndDialog, NULL, lpszPath, lpP,
                            lpDir, NULL, lpTitle, lpReserved,
                            (WORD)SW_SHOWNORMAL, &hProcess);

  /*BUG BUG these are DOS exec function return codes, no map yet to NT return codes!*/
  switch (ret) {
      case 0:
      case SE_ERR_OOM:    // 8
          ret = IDS_NOMEMORYMSG;
          break;

      case SE_ERR_FNF:    // 2
          ret = IDS_FILENOTFOUNDMSG;
          break;

      case SE_ERR_PNF:    // 3
          ret = IDS_BADPATHMSG;
          break;

      case 4:
          ret = IDS_MANYOPENFILESMSG;
          break;

      case 5:
          ret = IDS_ACCESSDENIED;
          break;

      case 10:
          ret = IDS_NEWWINDOWSMSG;
          break;

      case 12:
          ret = IDS_OS2APPMSG;
          break;

      case 15:
          /* KERNEL has already put up a messagebox for this one. */
          ret = 0;
          break;

      case 16:
          ret = IDS_MULTIPLEDSMSG;
          break;

      case 18:
          ret = IDS_PMODEONLYMSG;
          break;

      case 19:
          ret = IDS_COMPRESSEDEXE;
          break;

      case 20:
          ret = IDS_INVALIDDLL;
          break;

      case SE_ERR_SHARE:
          ret = IDS_SHAREERROR;
          break;

      case SE_ERR_ASSOCINCOMPLETE:
          ret = IDS_ASSOCINCOMPLETE;
          break;

      case SE_ERR_DDETIMEOUT:
      case SE_ERR_DDEFAIL:
      case SE_ERR_DDEBUSY:
          ret = IDS_DDEFAIL;
          break;

      case SE_ERR_NOASSOC:
          ret = IDS_NOASSOCMSG;
          break;

      default:
          ret = 0;
          break;
  }

  if (!GetSystemMetrics(SM_MOUSEPRESENT)) {
      /*
       * We want to turn the mouse off here on mouseless systems, but
       * the mouse will already have been turned off by USER if the
       * app has GP'd so make sure everything's kosher.
       */
      if (ShowCursor(FALSE) != -1)
          ShowCursor(TRUE);
  }

  SetCursor(hCursor);

  /*
   * Reset the working directory to the windows directory.
   */
  SetCurrentDirectory(szWindowsDirectory);

  return(ret);
}


VOID
GetDirectoryFromPath(
   PTSTR szFilePath,
   PTSTR szDir)
{
   PTSTR pFileName;
   PTSTR pExt;
   WORD ich;
   BOOL fUnc;

   *szDir = TEXT('\0');

   /* Get info about file path. */
   GetPathInfo(szFilePath, &pFileName, &pExt, &ich, &fUnc);

   /* UNC paths don't (conceptually to Progman) have a directory component. */
   if (fUnc)
      return;

   /* Does it have a directory component ? */
   if (pFileName != szFilePath) { // Yep.
      /* copy path to temp. */
      if (*szFilePath == TEXT('"')) {
         szFilePath++;
      }
      lstrcpy(szDir, szFilePath);
      /* check path style. */
      if (ich <= 3 && *(szDir+1) == TEXT(':')) {
         /*
          * The path is "c:\foo.c" or "c:foo.c" style.
          * Don't remove the last slash/colon, just the filename.
          */
         szDir[pFileName-szFilePath] = TEXT('\0');
      }

      else if (ich == 1) {
         /*
          * something like "\foo.c"
          * Don't remove the last slash/colon, just the filename.
          */
          szDir[pFileName-szFilePath] = TEXT('\0');
       }
       else {
          /*
           * The filepath is a full normal path.
           * Could be something like "..\foo.c" or ".\foo.c" though.
           * Stomp on the last slash to get just the path.
           */
           szDir[pFileName-szFilePath-1] = TEXT('\0');
       }
    }

    /* else just a filename with no path. */
}

VOID
GetFilenameFromPath(
   PTSTR szPath,
   PTSTR szFilename)
{
   DWORD dummy;
   PTSTR pFileName;
   BOOL fUNC;

   GetPathInfo(szPath, &pFileName, (PTSTR*) &dummy, (WORD*) &dummy,
      &fUNC);

   /* If it's a UNC then the 'filename' part is the whole thing. */
   if (fUNC || (szPath == pFileName))
      lstrcpy(szFilename, szPath);
   else {
      if (*szPath == TEXT('"')) {
         *szFilename++ = TEXT('"');
      }
      lstrcpy(szFilename, pFileName);
   }
}


VOID
GetPathInfo(
   PTSTR szPath,
   PTSTR *pszFileName,
   PTSTR *pszExt,
   WORD *pich,
   BOOL *pfUnc)
{
   TCHAR *pch;          // Temp variable.
   WORD ich = 0;       // Temp.
   BOOL InQuotes;

   *pszExt = NULL;         // If no extension, return NULL.
   *pszFileName = szPath;  // If no seperate filename component, return path.
   *pich = 0;
   *pfUnc = FALSE;         // Default to not UNC style.

   //
   // Check if path is in quotes.
   //
   if (InQuotes = (*szPath == TEXT('"'))) {
      szPath++;
   }

   // Check for UNC style paths.
   if (*szPath == TEXT('\\') && *(szPath+1) == TEXT('\\'))
      *pfUnc = TRUE;

   // Search forward to find the last backslash or colon in the path.
   // While we're at it, look for the last dot.
   for (pch = szPath; *pch; pch = CharNext(pch)) {

      if ((*pch == TEXT(' ')) && (!InQuotes)) {
         // Found a space - stop here.
         break;
      }
      if (*pch == TEXT('"')) {
         // Found a the second quote - stop here.
         pch++;
         break;
      }
      if (*pch == TEXT('\\') || *pch == TEXT(':')) {
         // Found it, record ptr to it and it's index.
         *pszFileName = pch+1;
         *pich = ich + (WORD)1;
      }
      if (*pch == TEXT('.')) {
         // Found a dot.
         *pszExt = pch;
      }
      ich++;
   }

   /* Check that the last dot is part of the last filename. */
   if (*pszExt < *pszFileName)
      *pszExt = NULL;
}


BOOL
IsUserAdmin()
{
    BOOL UserIsAdmin = FALSE;
    HANDLE Token;
    PSID    AdminAliasSid = NULL;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    //
    // Get the token of the current process.
    //

    if (!OpenProcessToken(
          GetCurrentProcess(),
          TOKEN_QUERY,
          &Token) ) {
       return(FALSE);
    }

    UserIsAdmin = TestTokenForAdmin(Token);


    CloseHandle(Token);

    return(UserIsAdmin);
}

BOOL
TestTokenForAdmin(
   HANDLE Token
   )
{
   NTSTATUS    Status;
   DWORD       InfoLength;
   PTOKEN_GROUPS TokenGroupList;
   DWORD       GroupIndex;
   PSID        AdminSid;
   BOOL        FoundAdmin;
   SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;

   //
   // Get a list of groups in the token
   //

   Status = NtQueryInformationToken(
      Token,                    // Handle
      TokenGroups,              // TokenInformationClass
      NULL,                     // TokenInformation
      0,                        // TokenInformationLength
      &InfoLength               // ReturnLength
   );

   if ((Status != STATUS_SUCCESS) && (Status != STATUS_BUFFER_TOO_SMALL)) {
      return(FALSE);
   }

   TokenGroupList = Alloc(InfoLength);

   if (TokenGroupList == NULL) {
      return(FALSE);
   }

   Status = NtQueryInformationToken(
      Token,                    // Handle
      TokenGroups,              // TokenInformationClass
      TokenGroupList,           // TokenInformation
      InfoLength,               // TokenInformationLength
      &InfoLength               // ReturnLength
   );

   if (!NT_SUCCESS(Status)) {
      LocalFree(TokenGroupList);
      return(FALSE);
   }

   //
   // Create the admin sid
   //
   Status = RtlAllocateAndInitializeSid(
      &SystemSidAuthority, 2,
      SECURITY_BUILTIN_DOMAIN_RID,
      DOMAIN_ALIAS_RID_ADMINS,
      0, 0, 0, 0, 0, 0,
      &AdminSid);

   if (!NT_SUCCESS(Status)) {
      Free(TokenGroupList);
      return(FALSE);
   }

   //
   // Search group list for admin alias
   //
   FoundAdmin = FALSE;

   for (GroupIndex=0; GroupIndex < TokenGroupList->GroupCount; GroupIndex++ ) {
      if (RtlEqualSid(TokenGroupList->Groups[GroupIndex].Sid, AdminSid)) {
         FoundAdmin = TRUE;
         break;
      }
   }

   //
   // Tidy up
   //

   RtlFreeSid(AdminSid);
   Free(TokenGroupList);

   return(FoundAdmin);
}

BOOL
OKToExec()
{
   TCHAR szRestrict[]        = TEXT("Restrictions");
   TCHAR szProgramManager[]  = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Program Manager");
   HKEY hkeyProgramManager  = NULL;  // progman.ini key
   HKEY hkeyPMRestrict      = NULL;
   DWORD cbData, dwType;
   BOOL fNoRun = FALSE;

  /*
   * Create/Open the registry keys corresponding to progman.ini sections.
   */
  if (!RegCreateKeyEx(HKEY_CURRENT_USER, szProgramManager, 0, szProgramManager, 0,
                         KEY_READ | KEY_WRITE, NULL, &hkeyProgramManager, NULL)) {

      RegCreateKeyEx(hkeyProgramManager, szRestrict, 0, szProgramManager, 0,
                         KEY_READ, NULL, &hkeyPMRestrict, NULL);

  } else {
    return(FALSE);
  }

  if (hkeyPMRestrict) {
      cbData = sizeof(fNoRun);
      RegQueryValueEx(hkeyPMRestrict, szNoRun, 0, &dwType, (LPBYTE)&fNoRun,
         &cbData);
  }

  if (hkeyPMRestrict) {
      RegCloseKey(hkeyPMRestrict);
      hkeyPMRestrict = NULL;
  }

  RegCloseKey(hkeyProgramManager);

  return(!fNoRun);

}

INT
MyMessageBox(
   HWND hWnd,
   WORD idTitle,
   WORD idMessage,
   PWSTR psz,
   WORD wStyle)
{
    WCHAR    szTempField[MAXMSGBOXLEN];
    INT     iMsgResult;

    if (!LoadString(hInst, idTitle, szTitle, ARRAYSIZE(szTitle))){
        goto MessageBoxOOM;
    }
    if (idMessage < 32){
        if (!LoadString(hInst, IDS_UNKNOWNMSG, szTempField, ARRAYSIZE(szTempField))){
            goto MessageBoxOOM;
        }
        wsprintf(szMessage, szTempField, idMessage);
    }
    else{
        if (!LoadString(hInst, idMessage, szTempField, ARRAYSIZE(szTempField)))
            goto MessageBoxOOM;

        if (psz) {
            wsprintf(szMessage, szTempField, (LPTSTR)psz);
        }
        else
            lstrcpy(szMessage, szTempField);
    }

    iMsgResult = MessageBox(hWnd, szMessage, szTitle, wStyle );

    if (iMsgResult == -1){

MessageBoxOOM:
        MessageBox(hWnd, szOOMExitMsg, szOOMExitTitle, MB_SYSTEMMODAL | MB_ICONHAND | MB_OK);
    }

    return(iMsgResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\inc\addon.h ===
// ADDON.H
//
// Copyright (c) 1994-1999 Microsoft Corporation.  All rights reserved.
//

// Common strings

#define NO_HELP                         ((DWORD) -1)
#define IDH_COMM_GROUPBOX               0001

// Welcome Help after Setup: Jessev

#define GET_WELCOME			0002

// Enhanced Property Sheet ID's: Shawnb


#define IDH_COMPDRV_TABLE_ULTRA		1002
#define IDH_COMPDRV_TABLE_HIPACK	1003
#define IDH_COMPDRV_TABLE_STD		1004
#define IDH_COMPDRV_TABLE_UNCOMP	1005
#define IDH_COMPDRV_TABLE_FREESP	1006
#define IDH_COMPDRV_TABLE_REDUCED	1007
#define IDH_COMPDRV_PIE                 1008
#define IDH_COMPDRV_TABLE               1009
#define IDH_COMPDRV_RECOMPNOW           1010
#define IDH_COMPDRV_UPGRADENOW		1011
#define IDH_COMPDRV_ADV                 1012
#define IDH_COMPDRV_ADV_HIDEHOST        1013
#define IDH_UNCOMPDRV_COMPDRIVE         1014
#define IDH_UNCOMPDRV_COMPPIE           1015
#define IDH_UNCOMPDRV_CREATENEW         1016
#define IDH_UNCOMPDRV_CREATEPIE         1017
#define IDH_HOSTDRV_PIE                 1018
#define IDH_HOSTDRV_TABLE           	1019
#define IDH_RUN_DRVSPACE                1020
#define IDH_COMPDRV_GAUGE		1021
#define IDH_COMPDRV_TABLE_TOTAL		1022


//ID's for the Theme Picker applet

#define IDH_THEME_LIST			2001		
#define IDH_THEME_SAVEAS		2002
#define IDH_THEME_DELETE		2003
#define IDH_THEME_PREVSCRN		2004
#define IDH_THEME_PREVETC		2005
#define IDH_THEME_PREVIEW		2006
#define IDH_THEME_SCRNSAVER		2007
#define IDH_THEMES_SOUNDS		2008
#define IDH_THEME_POINTERS		2009
#define IDH_THEME_WALLPAPER		2010
#define IDH_THEME_ICONS			2011
#define IDH_THEME_COLORS		2012
#define IDH_THEME_FONTS			2013
#define IDH_THEME_BORDER		2014
#define IDH_THEME_POINTERS_LIST		2015
#define IDH_THEME_POINTERS_PREV		2016
#define IDH_THEME_POINTERS_FILE		2018
#define IDH_THEME_SOUNDS_LIST		2019
#define IDH_THEME_SOUNDS_ICON_PREV	2020
#define IDH_THEME_SOUNDS_PLAYS		2021
#define IDH_THEME_SOUNDS_FILE		2022
#define IDH_THEME_PICS_LIST		2023
#define IDH_THEME_PICS_PREV		2024
#define IDH_THEME_PICS_FILE		2025
// #define IDH_THEME_SAVE_NAME		2026
#define IDH_THEME_ICON_SIZESPACE	2027
#define IDH_THEME_ROTATE                2028

// Lens settings ID's

#define IDH_LENS_FLIP			3000		// Temporary
#define IDH_LENS_GLASS_SPHERE		3001
#define IDH_LENS_INSIDE_OUT		3002
#define IDH_LENS_BLACK_HOLE		3003
#define IDH_LENS_DENT			3004
#define IDH_LENS_SPIRAL			3005
#define IDH_LENS_SIZE			3006
#define IDH_LENS_SPEED			3007
#define IDH_LENS_INDEX			3008
#define IDH_LENS_ALTITUDE		3009
#define IDH_LENS_MASS			3010
#define IDH_LENS_HEIGHT			3011
#define IDH_LENS_TWIST			3012
#define IDH_LENS_WALLPAPER		3013

//Blocks settings ID's

#define IDH_BLOCKS_SIZE			3050
#define IDH_BLOCKS_SPEED		3051

//Socha Settings ID's

#define IDH_SCRNSAVER_GEN_MONITOR	3100
#define IDH_SCRNSAVER_GEN_MOUSESEN	3101
#define IDH_SCRNSAVER_GEN_PASSREQUIRED	3102
#define IDH_SCRNSAVER_GEN_ABOUT		3103
#define IDH_SCRNSAVER_PREVIEW		3104
#define IDH_SCRNSAVER_GEN_NOSOUND	3105

// Plus Display Properties ID's

#define IDH_DISPLAY_PLUSPACK_LIST	4100
#define IDH_DISPLAY_PLUSPACK_CHANGEICON	4101
#define IDH_DISPLAY_PLUSPACK_ALLCOLORS	4102
#define IDH_DISPLAY_PLUSPACK_FULLWINDOW	4103
#define IDH_DISPLAY_PLUSPACK_FONTSMOOTH	4104
#define IDH_DISPLAY_PLUSPACK_STRETCH	4105 
#define IDH_DISPLAY_PLUSPACK_LARGEICONS	4106


// RNA dial-in ID's

#define IDH_RNA_IN_NOACC                4259
#define IDH_RNA_IN_ENABLEACC            4260
#define IDH_RNA_IN_PASSWORD             4263
#define IDH_RNA_IN_COMMENT              4264
#define IDH_RNA_IN_STATUS               4265
#define IDH_RNA_IN_DISCONNECT           4266
#define IDH_RNA_MODEM_SERVER		4275

// Internet Shortcut Target URL

#define IDH_INTERNET_SHORTCUT_TARGET	6001

// Disk Troubleshooter ID's

#define IDH_DSKTRB_FREESPACE		5001
#define IDH_COMPSET_TRB_MAIN            5002    // Must match DOS\DOS86\DBLSPACE\UTILITY\FROSTHLP.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\inc\frosting.h ===
// FROSTING.H
//
// Copyright (c) 1994-1999 Microsoft Corporation.  All rights reserved.
//

// Enhanced Property Sheet ID's: Richj	

#define IDH_GENDRV_CHKWARN		1000
#define IDH_FPROP_COMP_DEFAULT		1001
#define IDH_FPROP_COMP_ALWAYSCOMP	1002
#define IDH_FPROP_COMP_DONTCOMP		1003
#define IDH_FPROP_COMP_ALWAYSARCH	1004
#define IDH_FPROP_COMP_DONTARCH		1005
#define IDH_FPROP_COMP_DEARCHNOW	1006
#define IDH_FPROP_COMP_ARCHNOW		1007
#define IDH_DRVFRAG_INFO		1008
#define IDH_DRVFRAG_DEFRAG_NOW		1009
#define IDH_DRVFRAG_CHKWARN		1010
#define IDH_DRVSCAN_INFO		1011
#define IDH_DRVSCAN_DET			1012

// System Agent Alarms/Notifications ID's: Developer TBD	

#define IDH_SPACEALARM_SPACENOTIFY	2000
#define IDH_SPACEALARM_TIMENOTIFY	2001
#define IDH_SPACEALARM_DONTNOTIFY	2002
#define IDH_SCANALARM_TIMENOTIFY	2003
#define IDH_SCANALARM_DONT		2004
#define IDH_BACKALARM_TIMENOTIFY	2005
#define IDH_BACKALARM_DONT		2006
#define IDH_UPALARM_NOW			2007
#define IDH_UPALARM_STARTNOTIFY		2008
#define IDH_UPALARM_TIMENOTIFY		2009
#define IDH_UPALARM_DONT		2010

// System Agent/Compression Manager ID's: Richj	

#define IDH_RECOMPSET_ARCHDAYS		3000
#define IDH_RECOMPSET_ARCHNORM		3001
#define IDH_RECOMPSET_COMPTYPE		3002
#define IDH_RECOMPSET_PREVIEW		3003
#define IDH_RECOMPSET_RESTORE		3004
#define IDH_RECOMPSET_SAVESET		3005
#define IDH_COMPSET_EXCEPT		3006
#define IDH_DRVSPACE_SET_SPEED		3007
#define IDH_DRVSPACE_SET_SPACE		3008
#define IDH_EXCEPTDLG_LIST		3009
#define IDH_EXCEPTDLG_ADD		3010
#define IDH_EXCEPTDLG_REMOVE		3011
#define IDH_EXCEPTDLG_DROPLIST		3012
#define IDH_EXCEPTDLG_BROWSE		3013
#define IDH_EXCEPTDLG_FILENAME		3014
#define IDH_EXCEPTDLG_FILETYPE		3015
#define IDH_CIMPPREV_PIE		3016
#define IDH_COMPREV_TABLE		3017

#define IDH_TSKORD_LIST			4000
#define IDH_TSKORD_ARROWS		4001
#define IDH_TSKORD_ADD			4002
#define IDH_TSKORD_REMOVE		4003
#define IDH_TSKORD_SETTINGS		4004
#define IDH_DEFRAG_SCHEDSET_SHOWPROG	4005
#define IDH_DEFRAG_SCHEDSET_PERCENTCHK	4006
#define IDH_DEFRAG_SCHEDSET_ADV		4007
#define IDH_DEFRAG_SCHEDSET_ALLDRVS	4008
#define IDH_DEFRAG_SCHEDSET_SPECDRVS	4009
#define IDH_SCANDSK_SCHEDSET_SHOWPROG	4010
#define IDH_SCANDSK_SCHEDSET_STAND	4011
#define IDH_SCANDSK_SCHEDSET_ANAL	4012
#define IDH_SCANDSK_SCHEDSET_FIX	4013
#define IDH_SCANDSK_SCHEDSET_ADV	4014
#define IDH_SCANDSK_SCHEDSET_ALLDRVS	4015
#define IDH_SCANDSK_SCHEDSET_SPECDRVS	4016
#define IDH_RECOMP_SCHEDSET_SHOWPROG	4017
#define IDH_RECOMP_SCHEDSET_ALLDRVS	4018
#define IDH_RECOMP_SCHEDSET_SPECDRVS	4019
#define IDH_RECOMP_SCHEDSET_SET		4020
#define IDH_BACKSET_SHOWFILE		4021
#define IDH_BACKSET_BROWSE		4022
#define IDH_BACKSET_RETRY		4023
#define IDH_BACKSET_NUMTIMES		4024
#define IDH_BACKSET_TIME		4025
#define IDH_BACKSET_ERRORMSG		4026
#define IDH_NORUN_RUNNOW		4027
#define IDH_NORUN_IDLE			4028
#define IDH_NORUN_SKIP			4029
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\inc\mstask.h ===
// MSTASK.H
//
// Copyright (c) 1991-1997 Microsoft Corporation.  All rights reserved.
//

/* File created by MIDL compiler version 3.03.0110 */
/* at Fri Aug 29 13:53:36 1997
 */
/* Compiler settings for mstask.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mstask_h__
#define __mstask_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ITaskTrigger_FWD_DEFINED__
#define __ITaskTrigger_FWD_DEFINED__
typedef interface ITaskTrigger ITaskTrigger;
#endif 	/* __ITaskTrigger_FWD_DEFINED__ */


#ifndef __IScheduledWorkItem_FWD_DEFINED__
#define __IScheduledWorkItem_FWD_DEFINED__
typedef interface IScheduledWorkItem IScheduledWorkItem;
#endif 	/* __IScheduledWorkItem_FWD_DEFINED__ */


#ifndef __ITask_FWD_DEFINED__
#define __ITask_FWD_DEFINED__
typedef interface ITask ITask;
#endif 	/* __ITask_FWD_DEFINED__ */


#ifndef __IEnumWorkItems_FWD_DEFINED__
#define __IEnumWorkItems_FWD_DEFINED__
typedef interface IEnumWorkItems IEnumWorkItems;
#endif 	/* __IEnumWorkItems_FWD_DEFINED__ */


#ifndef __ITaskScheduler_FWD_DEFINED__
#define __ITaskScheduler_FWD_DEFINED__
typedef interface ITaskScheduler ITaskScheduler;
#endif 	/* __ITaskScheduler_FWD_DEFINED__ */


#ifndef __IProvideTaskPage_FWD_DEFINED__
#define __IProvideTaskPage_FWD_DEFINED__
typedef interface IProvideTaskPage IProvideTaskPage;
#endif 	/* __IProvideTaskPage_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "oleidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_mstask_0000
 * at Fri Aug 29 13:53:36 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


#define TASK_SUNDAY       (0x1)
#define TASK_MONDAY       (0x2)
#define TASK_TUESDAY      (0x4)
#define TASK_WEDNESDAY    (0x8)
#define TASK_THURSDAY     (0x10)
#define TASK_FRIDAY       (0x20)
#define TASK_SATURDAY     (0x40)
#define TASK_FIRST_WEEK   (1)
#define TASK_SECOND_WEEK  (2)
#define TASK_THIRD_WEEK   (3)
#define TASK_FOURTH_WEEK  (4)
#define TASK_LAST_WEEK    (5)
#define TASK_JANUARY      (0x1)
#define TASK_FEBRUARY     (0x2)
#define TASK_MARCH        (0x4)
#define TASK_APRIL        (0x8)
#define TASK_MAY          (0x10)
#define TASK_JUNE         (0x20)
#define TASK_JULY         (0x40)
#define TASK_AUGUST       (0x80)
#define TASK_SEPTEMBER    (0x100)
#define TASK_OCTOBER      (0x200)
#define TASK_NOVEMBER     (0x400)
#define TASK_DECEMBER     (0x800)
#define TASK_FLAG_INTERACTIVE                  (0x1)
#define TASK_FLAG_DELETE_WHEN_DONE             (0x2)
#define TASK_FLAG_DISABLED                     (0x4)
#define TASK_FLAG_START_ONLY_IF_IDLE           (0x10)
#define TASK_FLAG_KILL_ON_IDLE_END             (0x20)
#define TASK_FLAG_DONT_START_IF_ON_BATTERIES   (0x40)
#define TASK_FLAG_KILL_IF_GOING_ON_BATTERIES   (0x80)
#define TASK_FLAG_RUN_ONLY_IF_DOCKED           (0x100)
#define TASK_FLAG_HIDDEN                       (0x200)
#define TASK_FLAG_RUN_IF_CONNECTED_TO_INTERNET (0x400)
#define TASK_FLAG_RESTART_ON_IDLE_RESUME       (0x800)
#define TASK_TRIGGER_FLAG_HAS_END_DATE         (0x1)
#define TASK_TRIGGER_FLAG_KILL_AT_DURATION_END (0x2)
#define TASK_TRIGGER_FLAG_DISABLED             (0x4)
#define	TASK_MAX_RUN_TIMES	( 1440 )

typedef 
enum _TASK_TRIGGER_TYPE
    {	TASK_TIME_TRIGGER_ONCE	= 0,
	TASK_TIME_TRIGGER_DAILY	= 1,
	TASK_TIME_TRIGGER_WEEKLY	= 2,
	TASK_TIME_TRIGGER_MONTHLYDATE	= 3,
	TASK_TIME_TRIGGER_MONTHLYDOW	= 4,
	TASK_EVENT_TRIGGER_ON_IDLE	= 5,
	TASK_EVENT_TRIGGER_AT_SYSTEMSTART	= 6,
	TASK_EVENT_TRIGGER_AT_LOGON	= 7
    }	TASK_TRIGGER_TYPE;

typedef enum _TASK_TRIGGER_TYPE __RPC_FAR *PTASK_TRIGGER_TYPE;

typedef struct  _DAILY
    {
    WORD DaysInterval;
    }	DAILY;

typedef struct  _WEEKLY
    {
    WORD WeeksInterval;
    WORD rgfDaysOfTheWeek;
    }	WEEKLY;

typedef struct  _MONTHLYDATE
    {
    DWORD rgfDays;
    WORD rgfMonths;
    }	MONTHLYDATE;

typedef struct  _MONTHLYDOW
    {
    WORD wWhichWeek;
    WORD rgfDaysOfTheWeek;
    WORD rgfMonths;
    }	MONTHLYDOW;

typedef union _TRIGGER_TYPE_UNION
    {
    DAILY Daily;
    WEEKLY Weekly;
    MONTHLYDATE MonthlyDate;
    MONTHLYDOW MonthlyDOW;
    }	TRIGGER_TYPE_UNION;

typedef struct  _TASK_TRIGGER
    {
    WORD cbTriggerSize;
    WORD Reserved1;
    WORD wBeginYear;
    WORD wBeginMonth;
    WORD wBeginDay;
    WORD wEndYear;
    WORD wEndMonth;
    WORD wEndDay;
    WORD wStartHour;
    WORD wStartMinute;
    DWORD MinutesDuration;
    DWORD MinutesInterval;
    DWORD rgFlags;
    TASK_TRIGGER_TYPE TriggerType;
    TRIGGER_TYPE_UNION Type;
    WORD Reserved2;
    WORD wRandomMinutesInterval;
    }	TASK_TRIGGER;

typedef struct _TASK_TRIGGER __RPC_FAR *PTASK_TRIGGER;

// {148BD52B-A2AB-11CE-B11F-00AA00530503}
DEFINE_GUID(IID_ITaskTrigger, 0x148BD52BL, 0xA2AB, 0x11CE, 0xB1, 0x1F, 0x00, 0xAA, 0x00, 0x53, 0x05, 0x03);



extern RPC_IF_HANDLE __MIDL_itf_mstask_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mstask_0000_v0_0_s_ifspec;

#ifndef __ITaskTrigger_INTERFACE_DEFINED__
#define __ITaskTrigger_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITaskTrigger
 * at Fri Aug 29 13:53:36 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_ITaskTrigger;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("148BD52B-A2AB-11CE-B11F-00AA00530503")
    ITaskTrigger : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetTrigger( 
            /* [in] */ const PTASK_TRIGGER pTrigger) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTrigger( 
            /* [out] */ PTASK_TRIGGER pTrigger) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTriggerString( 
            /* [out] */ LPWSTR __RPC_FAR *ppwszTrigger) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITaskTriggerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITaskTrigger __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITaskTrigger __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITaskTrigger __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTrigger )( 
            ITaskTrigger __RPC_FAR * This,
            /* [in] */ const PTASK_TRIGGER pTrigger);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTrigger )( 
            ITaskTrigger __RPC_FAR * This,
            /* [out] */ PTASK_TRIGGER pTrigger);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTriggerString )( 
            ITaskTrigger __RPC_FAR * This,
            /* [out] */ LPWSTR __RPC_FAR *ppwszTrigger);
        
        END_INTERFACE
    } ITaskTriggerVtbl;

    interface ITaskTrigger
    {
        CONST_VTBL struct ITaskTriggerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITaskTrigger_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITaskTrigger_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITaskTrigger_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITaskTrigger_SetTrigger(This,pTrigger)	\
    (This)->lpVtbl -> SetTrigger(This,pTrigger)

#define ITaskTrigger_GetTrigger(This,pTrigger)	\
    (This)->lpVtbl -> GetTrigger(This,pTrigger)

#define ITaskTrigger_GetTriggerString(This,ppwszTrigger)	\
    (This)->lpVtbl -> GetTriggerString(This,ppwszTrigger)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITaskTrigger_SetTrigger_Proxy( 
    ITaskTrigger __RPC_FAR * This,
    /* [in] */ const PTASK_TRIGGER pTrigger);


void __RPC_STUB ITaskTrigger_SetTrigger_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITaskTrigger_GetTrigger_Proxy( 
    ITaskTrigger __RPC_FAR * This,
    /* [out] */ PTASK_TRIGGER pTrigger);


void __RPC_STUB ITaskTrigger_GetTrigger_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITaskTrigger_GetTriggerString_Proxy( 
    ITaskTrigger __RPC_FAR * This,
    /* [out] */ LPWSTR __RPC_FAR *ppwszTrigger);


void __RPC_STUB ITaskTrigger_GetTriggerString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITaskTrigger_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_mstask_0118
 * at Fri Aug 29 13:53:36 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


// {a6b952f0-a4b1-11d0-997d-00aa006887ec}
DEFINE_GUID(IID_IScheduledWorkItem, 0xa6b952f0L, 0xa4b1, 0x11d0, 0x99, 0x7d, 0x00, 0xaa, 0x00, 0x68, 0x87, 0xec);



extern RPC_IF_HANDLE __MIDL_itf_mstask_0118_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mstask_0118_v0_0_s_ifspec;

#ifndef __IScheduledWorkItem_INTERFACE_DEFINED__
#define __IScheduledWorkItem_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IScheduledWorkItem
 * at Fri Aug 29 13:53:36 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IScheduledWorkItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a6b952f0-a4b1-11d0-997d-00aa006887ec")
    IScheduledWorkItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateTrigger( 
            /* [out] */ WORD __RPC_FAR *piNewTrigger,
            /* [out] */ ITaskTrigger __RPC_FAR *__RPC_FAR *ppTrigger) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteTrigger( 
            /* [in] */ WORD iTrigger) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTriggerCount( 
            /* [out] */ WORD __RPC_FAR *pwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTrigger( 
            /* [in] */ WORD iTrigger,
            /* [out] */ ITaskTrigger __RPC_FAR *__RPC_FAR *ppTrigger) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTriggerString( 
            /* [in] */ WORD iTrigger,
            /* [out] */ LPWSTR __RPC_FAR *ppwszTrigger) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRunTimes( 
            /* [in] */ const LPSYSTEMTIME pstBegin,
            /* [in] */ const LPSYSTEMTIME pstEnd,
            /* [out][in] */ WORD __RPC_FAR *pCount,
            /* [out] */ LPSYSTEMTIME __RPC_FAR *rgstTaskTimes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextRunTime( 
            /* [out][in] */ SYSTEMTIME __RPC_FAR *pstNextRun) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIdleWait( 
            /* [in] */ WORD wIdleMinutes,
            /* [in] */ WORD wDeadlineMinutes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIdleWait( 
            /* [out] */ WORD __RPC_FAR *pwIdleMinutes,
            /* [out] */ WORD __RPC_FAR *pwDeadlineMinutes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Run( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Terminate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EditWorkItem( 
            /* [in] */ HWND hParent,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMostRecentRunTime( 
            /* [out] */ SYSTEMTIME __RPC_FAR *pstLastRun) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ HRESULT __RPC_FAR *phrStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExitCode( 
            /* [out] */ DWORD __RPC_FAR *pdwExitCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetComment( 
            /* [in] */ LPCWSTR pwszComment) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetComment( 
            /* [out] */ LPWSTR __RPC_FAR *ppwszComment) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCreator( 
            /* [in] */ LPCWSTR pwszCreator) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCreator( 
            /* [out] */ LPWSTR __RPC_FAR *ppwszCreator) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWorkItemData( 
            /* [in] */ WORD cbData,
            /* [in] */ BYTE __RPC_FAR rgbData[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWorkItemData( 
            /* [out] */ WORD __RPC_FAR *pcbData,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetErrorRetryCount( 
            /* [in] */ WORD wRetryCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorRetryCount( 
            /* [out] */ WORD __RPC_FAR *pwRetryCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetErrorRetryInterval( 
            /* [in] */ WORD wRetryInterval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorRetryInterval( 
            /* [out] */ WORD __RPC_FAR *pwRetryInterval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [out] */ DWORD __RPC_FAR *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAccountInformation( 
            /* [in] */ LPCWSTR pwszAccountName,
            /* [in] */ LPCWSTR pwszPassword) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAccountInformation( 
            /* [out] */ LPWSTR __RPC_FAR *ppwszAccountName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScheduledWorkItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IScheduledWorkItem __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IScheduledWorkItem __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IScheduledWorkItem __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateTrigger )( 
            IScheduledWorkItem __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *piNewTrigger,
            /* [out] */ ITaskTrigger __RPC_FAR *__RPC_FAR *ppTrigger);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteTrigger )( 
            IScheduledWorkItem __RPC_FAR * This,
            /* [in] */ WORD iTrigger);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTriggerCount )( 
            IScheduledWorkItem __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pwCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTrigger )( 
            IScheduledWorkItem __RPC_FAR * This,
            /* [in] */ WORD iTrigger,
            /* [out] */ ITaskTrigger __RPC_FAR *__RPC_FAR *ppTrigger);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTriggerString )( 
            IScheduledWorkItem __RPC_FAR * This,
            /* [in] */ WORD iTrigger,
            /* [out] */ LPWSTR __RPC_FAR *ppwszTrigger);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRunTimes )( 
            IScheduledWorkItem __RPC_FAR * This,
            /* [in] */ const LPSYSTEMTIME pstBegin,
            /* [in] */ const LPSYSTEMTIME pstEnd,
            /* [out][in] */ WORD __RPC_FAR *pCount,
            /* [out] */ LPSYSTEMTIME __RPC_FAR *rgstTaskTimes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextRunTime )( 
            IScheduledWorkItem __RPC_FAR * This,
            /* [out][in] */ SYSTEMTIME __RPC_FAR *pstNextRun);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIdleWait )( 
            IScheduledWorkItem __RPC_FAR * This,
            /* [in] */ WORD wIdleMinutes,
            /* [in] */ WORD wDeadlineMinutes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIdleWait )( 
            IScheduledWorkItem __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pwIdleMinutes,
            /* [out] */ WORD __RPC_FAR *pwDeadlineMinutes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Run )( 
            IScheduledWorkItem __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Terminate )( 
            IScheduledWorkItem __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EditWorkItem )( 
            IScheduledWorkItem __RPC_FAR * This,
            /* [in] */ HWND hParent,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMostRecentRunTime )( 
            IScheduledWorkItem __RPC_FAR * This,
            /* [out] */ SYSTEMTIME __RPC_FAR *pstLastRun);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            IScheduledWorkItem __RPC_FAR * This,
            /* [out] */ HRESULT __RPC_FAR *phrStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExitCode )( 
            IScheduledWorkItem __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwExitCode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetComment )( 
            IScheduledWorkItem __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszComment);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetComment )( 
            IScheduledWorkItem __RPC_FAR * This,
            /* [out] */ LPWSTR __RPC_FAR *ppwszComment);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCreator )( 
            IScheduledWorkItem __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszCreator);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCreator )( 
            IScheduledWorkItem __RPC_FAR * This,
            /* [out] */ LPWSTR __RPC_FAR *ppwszCreator);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetWorkItemData )( 
            IScheduledWorkItem __RPC_FAR * This,
            /* [in] */ WORD cbData,
            /* [in] */ BYTE __RPC_FAR rgbData[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWorkItemData )( 
            IScheduledWorkItem __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pcbData,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetErrorRetryCount )( 
            IScheduledWorkItem __RPC_FAR * This,
            /* [in] */ WORD wRetryCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorRetryCount )( 
            IScheduledWorkItem __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pwRetryCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetErrorRetryInterval )( 
            IScheduledWorkItem __RPC_FAR * This,
            /* [in] */ WORD wRetryInterval);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorRetryInterval )( 
            IScheduledWorkItem __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pwRetryInterval);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFlags )( 
            IScheduledWorkItem __RPC_FAR * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )( 
            IScheduledWorkItem __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAccountInformation )( 
            IScheduledWorkItem __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszAccountName,
            /* [in] */ LPCWSTR pwszPassword);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAccountInformation )( 
            IScheduledWorkItem __RPC_FAR * This,
            /* [out] */ LPWSTR __RPC_FAR *ppwszAccountName);
        
        END_INTERFACE
    } IScheduledWorkItemVtbl;

    interface IScheduledWorkItem
    {
        CONST_VTBL struct IScheduledWorkItemVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScheduledWorkItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScheduledWorkItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScheduledWorkItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IScheduledWorkItem_CreateTrigger(This,piNewTrigger,ppTrigger)	\
    (This)->lpVtbl -> CreateTrigger(This,piNewTrigger,ppTrigger)

#define IScheduledWorkItem_DeleteTrigger(This,iTrigger)	\
    (This)->lpVtbl -> DeleteTrigger(This,iTrigger)

#define IScheduledWorkItem_GetTriggerCount(This,pwCount)	\
    (This)->lpVtbl -> GetTriggerCount(This,pwCount)

#define IScheduledWorkItem_GetTrigger(This,iTrigger,ppTrigger)	\
    (This)->lpVtbl -> GetTrigger(This,iTrigger,ppTrigger)

#define IScheduledWorkItem_GetTriggerString(This,iTrigger,ppwszTrigger)	\
    (This)->lpVtbl -> GetTriggerString(This,iTrigger,ppwszTrigger)

#define IScheduledWorkItem_GetRunTimes(This,pstBegin,pstEnd,pCount,rgstTaskTimes)	\
    (This)->lpVtbl -> GetRunTimes(This,pstBegin,pstEnd,pCount,rgstTaskTimes)

#define IScheduledWorkItem_GetNextRunTime(This,pstNextRun)	\
    (This)->lpVtbl -> GetNextRunTime(This,pstNextRun)

#define IScheduledWorkItem_SetIdleWait(This,wIdleMinutes,wDeadlineMinutes)	\
    (This)->lpVtbl -> SetIdleWait(This,wIdleMinutes,wDeadlineMinutes)

#define IScheduledWorkItem_GetIdleWait(This,pwIdleMinutes,pwDeadlineMinutes)	\
    (This)->lpVtbl -> GetIdleWait(This,pwIdleMinutes,pwDeadlineMinutes)

#define IScheduledWorkItem_Run(This)	\
    (This)->lpVtbl -> Run(This)

#define IScheduledWorkItem_Terminate(This)	\
    (This)->lpVtbl -> Terminate(This)

#define IScheduledWorkItem_EditWorkItem(This,hParent,dwReserved)	\
    (This)->lpVtbl -> EditWorkItem(This,hParent,dwReserved)

#define IScheduledWorkItem_GetMostRecentRunTime(This,pstLastRun)	\
    (This)->lpVtbl -> GetMostRecentRunTime(This,pstLastRun)

#define IScheduledWorkItem_GetStatus(This,phrStatus)	\
    (This)->lpVtbl -> GetStatus(This,phrStatus)

#define IScheduledWorkItem_GetExitCode(This,pdwExitCode)	\
    (This)->lpVtbl -> GetExitCode(This,pdwExitCode)

#define IScheduledWorkItem_SetComment(This,pwszComment)	\
    (This)->lpVtbl -> SetComment(This,pwszComment)

#define IScheduledWorkItem_GetComment(This,ppwszComment)	\
    (This)->lpVtbl -> GetComment(This,ppwszComment)

#define IScheduledWorkItem_SetCreator(This,pwszCreator)	\
    (This)->lpVtbl -> SetCreator(This,pwszCreator)

#define IScheduledWorkItem_GetCreator(This,ppwszCreator)	\
    (This)->lpVtbl -> GetCreator(This,ppwszCreator)

#define IScheduledWorkItem_SetWorkItemData(This,cbData,rgbData)	\
    (This)->lpVtbl -> SetWorkItemData(This,cbData,rgbData)

#define IScheduledWorkItem_GetWorkItemData(This,pcbData,prgbData)	\
    (This)->lpVtbl -> GetWorkItemData(This,pcbData,prgbData)

#define IScheduledWorkItem_SetErrorRetryCount(This,wRetryCount)	\
    (This)->lpVtbl -> SetErrorRetryCount(This,wRetryCount)

#define IScheduledWorkItem_GetErrorRetryCount(This,pwRetryCount)	\
    (This)->lpVtbl -> GetErrorRetryCount(This,pwRetryCount)

#define IScheduledWorkItem_SetErrorRetryInterval(This,wRetryInterval)	\
    (This)->lpVtbl -> SetErrorRetryInterval(This,wRetryInterval)

#define IScheduledWorkItem_GetErrorRetryInterval(This,pwRetryInterval)	\
    (This)->lpVtbl -> GetErrorRetryInterval(This,pwRetryInterval)

#define IScheduledWorkItem_SetFlags(This,dwFlags)	\
    (This)->lpVtbl -> SetFlags(This,dwFlags)

#define IScheduledWorkItem_GetFlags(This,pdwFlags)	\
    (This)->lpVtbl -> GetFlags(This,pdwFlags)

#define IScheduledWorkItem_SetAccountInformation(This,pwszAccountName,pwszPassword)	\
    (This)->lpVtbl -> SetAccountInformation(This,pwszAccountName,pwszPassword)

#define IScheduledWorkItem_GetAccountInformation(This,ppwszAccountName)	\
    (This)->lpVtbl -> GetAccountInformation(This,ppwszAccountName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IScheduledWorkItem_CreateTrigger_Proxy( 
    IScheduledWorkItem __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *piNewTrigger,
    /* [out] */ ITaskTrigger __RPC_FAR *__RPC_FAR *ppTrigger);


void __RPC_STUB IScheduledWorkItem_CreateTrigger_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScheduledWorkItem_DeleteTrigger_Proxy( 
    IScheduledWorkItem __RPC_FAR * This,
    /* [in] */ WORD iTrigger);


void __RPC_STUB IScheduledWorkItem_DeleteTrigger_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScheduledWorkItem_GetTriggerCount_Proxy( 
    IScheduledWorkItem __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *pwCount);


void __RPC_STUB IScheduledWorkItem_GetTriggerCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScheduledWorkItem_GetTrigger_Proxy( 
    IScheduledWorkItem __RPC_FAR * This,
    /* [in] */ WORD iTrigger,
    /* [out] */ ITaskTrigger __RPC_FAR *__RPC_FAR *ppTrigger);


void __RPC_STUB IScheduledWorkItem_GetTrigger_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScheduledWorkItem_GetTriggerString_Proxy( 
    IScheduledWorkItem __RPC_FAR * This,
    /* [in] */ WORD iTrigger,
    /* [out] */ LPWSTR __RPC_FAR *ppwszTrigger);


void __RPC_STUB IScheduledWorkItem_GetTriggerString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScheduledWorkItem_GetRunTimes_Proxy( 
    IScheduledWorkItem __RPC_FAR * This,
    /* [in] */ const LPSYSTEMTIME pstBegin,
    /* [in] */ const LPSYSTEMTIME pstEnd,
    /* [out][in] */ WORD __RPC_FAR *pCount,
    /* [out] */ LPSYSTEMTIME __RPC_FAR *rgstTaskTimes);


void __RPC_STUB IScheduledWorkItem_GetRunTimes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScheduledWorkItem_GetNextRunTime_Proxy( 
    IScheduledWorkItem __RPC_FAR * This,
    /* [out][in] */ SYSTEMTIME __RPC_FAR *pstNextRun);


void __RPC_STUB IScheduledWorkItem_GetNextRunTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScheduledWorkItem_SetIdleWait_Proxy( 
    IScheduledWorkItem __RPC_FAR * This,
    /* [in] */ WORD wIdleMinutes,
    /* [in] */ WORD wDeadlineMinutes);


void __RPC_STUB IScheduledWorkItem_SetIdleWait_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScheduledWorkItem_GetIdleWait_Proxy( 
    IScheduledWorkItem __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *pwIdleMinutes,
    /* [out] */ WORD __RPC_FAR *pwDeadlineMinutes);


void __RPC_STUB IScheduledWorkItem_GetIdleWait_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScheduledWorkItem_Run_Proxy( 
    IScheduledWorkItem __RPC_FAR * This);


void __RPC_STUB IScheduledWorkItem_Run_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScheduledWorkItem_Terminate_Proxy( 
    IScheduledWorkItem __RPC_FAR * This);


void __RPC_STUB IScheduledWorkItem_Terminate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScheduledWorkItem_EditWorkItem_Proxy( 
    IScheduledWorkItem __RPC_FAR * This,
    /* [in] */ HWND hParent,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IScheduledWorkItem_EditWorkItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScheduledWorkItem_GetMostRecentRunTime_Proxy( 
    IScheduledWorkItem __RPC_FAR * This,
    /* [out] */ SYSTEMTIME __RPC_FAR *pstLastRun);


void __RPC_STUB IScheduledWorkItem_GetMostRecentRunTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScheduledWorkItem_GetStatus_Proxy( 
    IScheduledWorkItem __RPC_FAR * This,
    /* [out] */ HRESULT __RPC_FAR *phrStatus);


void __RPC_STUB IScheduledWorkItem_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScheduledWorkItem_GetExitCode_Proxy( 
    IScheduledWorkItem __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwExitCode);


void __RPC_STUB IScheduledWorkItem_GetExitCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScheduledWorkItem_SetComment_Proxy( 
    IScheduledWorkItem __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszComment);


void __RPC_STUB IScheduledWorkItem_SetComment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScheduledWorkItem_GetComment_Proxy( 
    IScheduledWorkItem __RPC_FAR * This,
    /* [out] */ LPWSTR __RPC_FAR *ppwszComment);


void __RPC_STUB IScheduledWorkItem_GetComment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScheduledWorkItem_SetCreator_Proxy( 
    IScheduledWorkItem __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszCreator);


void __RPC_STUB IScheduledWorkItem_SetCreator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScheduledWorkItem_GetCreator_Proxy( 
    IScheduledWorkItem __RPC_FAR * This,
    /* [out] */ LPWSTR __RPC_FAR *ppwszCreator);


void __RPC_STUB IScheduledWorkItem_GetCreator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScheduledWorkItem_SetWorkItemData_Proxy( 
    IScheduledWorkItem __RPC_FAR * This,
    /* [in] */ WORD cbData,
    /* [in] */ BYTE __RPC_FAR rgbData[  ]);


void __RPC_STUB IScheduledWorkItem_SetWorkItemData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScheduledWorkItem_GetWorkItemData_Proxy( 
    IScheduledWorkItem __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *pcbData,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbData);


void __RPC_STUB IScheduledWorkItem_GetWorkItemData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScheduledWorkItem_SetErrorRetryCount_Proxy( 
    IScheduledWorkItem __RPC_FAR * This,
    /* [in] */ WORD wRetryCount);


void __RPC_STUB IScheduledWorkItem_SetErrorRetryCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScheduledWorkItem_GetErrorRetryCount_Proxy( 
    IScheduledWorkItem __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *pwRetryCount);


void __RPC_STUB IScheduledWorkItem_GetErrorRetryCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScheduledWorkItem_SetErrorRetryInterval_Proxy( 
    IScheduledWorkItem __RPC_FAR * This,
    /* [in] */ WORD wRetryInterval);


void __RPC_STUB IScheduledWorkItem_SetErrorRetryInterval_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScheduledWorkItem_GetErrorRetryInterval_Proxy( 
    IScheduledWorkItem __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *pwRetryInterval);


void __RPC_STUB IScheduledWorkItem_GetErrorRetryInterval_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScheduledWorkItem_SetFlags_Proxy( 
    IScheduledWorkItem __RPC_FAR * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IScheduledWorkItem_SetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScheduledWorkItem_GetFlags_Proxy( 
    IScheduledWorkItem __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwFlags);


void __RPC_STUB IScheduledWorkItem_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScheduledWorkItem_SetAccountInformation_Proxy( 
    IScheduledWorkItem __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszAccountName,
    /* [in] */ LPCWSTR pwszPassword);


void __RPC_STUB IScheduledWorkItem_SetAccountInformation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScheduledWorkItem_GetAccountInformation_Proxy( 
    IScheduledWorkItem __RPC_FAR * This,
    /* [out] */ LPWSTR __RPC_FAR *ppwszAccountName);


void __RPC_STUB IScheduledWorkItem_GetAccountInformation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IScheduledWorkItem_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_mstask_0119
 * at Fri Aug 29 13:53:36 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


// {148BD524-A2AB-11CE-B11F-00AA00530503}
DEFINE_GUID(IID_ITask, 0x148BD524L, 0xA2AB, 0x11CE, 0xB1, 0x1F, 0x00, 0xAA, 0x00, 0x53, 0x05, 0x03);



extern RPC_IF_HANDLE __MIDL_itf_mstask_0119_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mstask_0119_v0_0_s_ifspec;

#ifndef __ITask_INTERFACE_DEFINED__
#define __ITask_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITask
 * at Fri Aug 29 13:53:36 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_ITask;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("148BD524-A2AB-11CE-B11F-00AA00530503")
    ITask : public IScheduledWorkItem
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetApplicationName( 
            /* [in] */ LPCWSTR pwszApplicationName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplicationName( 
            /* [out] */ LPWSTR __RPC_FAR *ppwszApplicationName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetParameters( 
            /* [in] */ LPCWSTR pwszParameters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParameters( 
            /* [out] */ LPWSTR __RPC_FAR *ppwszParameters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWorkingDirectory( 
            /* [in] */ LPCWSTR pwszWorkingDirectory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWorkingDirectory( 
            /* [out] */ LPWSTR __RPC_FAR *ppwszWorkingDirectory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPriority( 
            /* [in] */ DWORD dwPriority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPriority( 
            /* [out] */ DWORD __RPC_FAR *pdwPriority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTaskFlags( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTaskFlags( 
            /* [out] */ DWORD __RPC_FAR *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxRunTime( 
            /* [in] */ DWORD dwMaxRunTimeMS) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxRunTime( 
            /* [out] */ DWORD __RPC_FAR *pdwMaxRunTimeMS) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITaskVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITask __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITask __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITask __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateTrigger )( 
            ITask __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *piNewTrigger,
            /* [out] */ ITaskTrigger __RPC_FAR *__RPC_FAR *ppTrigger);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteTrigger )( 
            ITask __RPC_FAR * This,
            /* [in] */ WORD iTrigger);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTriggerCount )( 
            ITask __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pwCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTrigger )( 
            ITask __RPC_FAR * This,
            /* [in] */ WORD iTrigger,
            /* [out] */ ITaskTrigger __RPC_FAR *__RPC_FAR *ppTrigger);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTriggerString )( 
            ITask __RPC_FAR * This,
            /* [in] */ WORD iTrigger,
            /* [out] */ LPWSTR __RPC_FAR *ppwszTrigger);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRunTimes )( 
            ITask __RPC_FAR * This,
            /* [in] */ const LPSYSTEMTIME pstBegin,
            /* [in] */ const LPSYSTEMTIME pstEnd,
            /* [out][in] */ WORD __RPC_FAR *pCount,
            /* [out] */ LPSYSTEMTIME __RPC_FAR *rgstTaskTimes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextRunTime )( 
            ITask __RPC_FAR * This,
            /* [out][in] */ SYSTEMTIME __RPC_FAR *pstNextRun);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIdleWait )( 
            ITask __RPC_FAR * This,
            /* [in] */ WORD wIdleMinutes,
            /* [in] */ WORD wDeadlineMinutes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIdleWait )( 
            ITask __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pwIdleMinutes,
            /* [out] */ WORD __RPC_FAR *pwDeadlineMinutes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Run )( 
            ITask __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Terminate )( 
            ITask __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EditWorkItem )( 
            ITask __RPC_FAR * This,
            /* [in] */ HWND hParent,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMostRecentRunTime )( 
            ITask __RPC_FAR * This,
            /* [out] */ SYSTEMTIME __RPC_FAR *pstLastRun);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            ITask __RPC_FAR * This,
            /* [out] */ HRESULT __RPC_FAR *phrStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExitCode )( 
            ITask __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwExitCode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetComment )( 
            ITask __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszComment);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetComment )( 
            ITask __RPC_FAR * This,
            /* [out] */ LPWSTR __RPC_FAR *ppwszComment);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCreator )( 
            ITask __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszCreator);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCreator )( 
            ITask __RPC_FAR * This,
            /* [out] */ LPWSTR __RPC_FAR *ppwszCreator);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetWorkItemData )( 
            ITask __RPC_FAR * This,
            /* [in] */ WORD cbData,
            /* [in] */ BYTE __RPC_FAR rgbData[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWorkItemData )( 
            ITask __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pcbData,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetErrorRetryCount )( 
            ITask __RPC_FAR * This,
            /* [in] */ WORD wRetryCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorRetryCount )( 
            ITask __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pwRetryCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetErrorRetryInterval )( 
            ITask __RPC_FAR * This,
            /* [in] */ WORD wRetryInterval);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorRetryInterval )( 
            ITask __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pwRetryInterval);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFlags )( 
            ITask __RPC_FAR * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )( 
            ITask __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAccountInformation )( 
            ITask __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszAccountName,
            /* [in] */ LPCWSTR pwszPassword);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAccountInformation )( 
            ITask __RPC_FAR * This,
            /* [out] */ LPWSTR __RPC_FAR *ppwszAccountName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetApplicationName )( 
            ITask __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszApplicationName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetApplicationName )( 
            ITask __RPC_FAR * This,
            /* [out] */ LPWSTR __RPC_FAR *ppwszApplicationName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetParameters )( 
            ITask __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszParameters);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParameters )( 
            ITask __RPC_FAR * This,
            /* [out] */ LPWSTR __RPC_FAR *ppwszParameters);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetWorkingDirectory )( 
            ITask __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszWorkingDirectory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWorkingDirectory )( 
            ITask __RPC_FAR * This,
            /* [out] */ LPWSTR __RPC_FAR *ppwszWorkingDirectory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPriority )( 
            ITask __RPC_FAR * This,
            /* [in] */ DWORD dwPriority);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPriority )( 
            ITask __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPriority);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTaskFlags )( 
            ITask __RPC_FAR * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTaskFlags )( 
            ITask __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMaxRunTime )( 
            ITask __RPC_FAR * This,
            /* [in] */ DWORD dwMaxRunTimeMS);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxRunTime )( 
            ITask __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwMaxRunTimeMS);
        
        END_INTERFACE
    } ITaskVtbl;

    interface ITask
    {
        CONST_VTBL struct ITaskVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITask_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITask_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITask_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITask_CreateTrigger(This,piNewTrigger,ppTrigger)	\
    (This)->lpVtbl -> CreateTrigger(This,piNewTrigger,ppTrigger)

#define ITask_DeleteTrigger(This,iTrigger)	\
    (This)->lpVtbl -> DeleteTrigger(This,iTrigger)

#define ITask_GetTriggerCount(This,pwCount)	\
    (This)->lpVtbl -> GetTriggerCount(This,pwCount)

#define ITask_GetTrigger(This,iTrigger,ppTrigger)	\
    (This)->lpVtbl -> GetTrigger(This,iTrigger,ppTrigger)

#define ITask_GetTriggerString(This,iTrigger,ppwszTrigger)	\
    (This)->lpVtbl -> GetTriggerString(This,iTrigger,ppwszTrigger)

#define ITask_GetRunTimes(This,pstBegin,pstEnd,pCount,rgstTaskTimes)	\
    (This)->lpVtbl -> GetRunTimes(This,pstBegin,pstEnd,pCount,rgstTaskTimes)

#define ITask_GetNextRunTime(This,pstNextRun)	\
    (This)->lpVtbl -> GetNextRunTime(This,pstNextRun)

#define ITask_SetIdleWait(This,wIdleMinutes,wDeadlineMinutes)	\
    (This)->lpVtbl -> SetIdleWait(This,wIdleMinutes,wDeadlineMinutes)

#define ITask_GetIdleWait(This,pwIdleMinutes,pwDeadlineMinutes)	\
    (This)->lpVtbl -> GetIdleWait(This,pwIdleMinutes,pwDeadlineMinutes)

#define ITask_Run(This)	\
    (This)->lpVtbl -> Run(This)

#define ITask_Terminate(This)	\
    (This)->lpVtbl -> Terminate(This)

#define ITask_EditWorkItem(This,hParent,dwReserved)	\
    (This)->lpVtbl -> EditWorkItem(This,hParent,dwReserved)

#define ITask_GetMostRecentRunTime(This,pstLastRun)	\
    (This)->lpVtbl -> GetMostRecentRunTime(This,pstLastRun)

#define ITask_GetStatus(This,phrStatus)	\
    (This)->lpVtbl -> GetStatus(This,phrStatus)

#define ITask_GetExitCode(This,pdwExitCode)	\
    (This)->lpVtbl -> GetExitCode(This,pdwExitCode)

#define ITask_SetComment(This,pwszComment)	\
    (This)->lpVtbl -> SetComment(This,pwszComment)

#define ITask_GetComment(This,ppwszComment)	\
    (This)->lpVtbl -> GetComment(This,ppwszComment)

#define ITask_SetCreator(This,pwszCreator)	\
    (This)->lpVtbl -> SetCreator(This,pwszCreator)

#define ITask_GetCreator(This,ppwszCreator)	\
    (This)->lpVtbl -> GetCreator(This,ppwszCreator)

#define ITask_SetWorkItemData(This,cbData,rgbData)	\
    (This)->lpVtbl -> SetWorkItemData(This,cbData,rgbData)

#define ITask_GetWorkItemData(This,pcbData,prgbData)	\
    (This)->lpVtbl -> GetWorkItemData(This,pcbData,prgbData)

#define ITask_SetErrorRetryCount(This,wRetryCount)	\
    (This)->lpVtbl -> SetErrorRetryCount(This,wRetryCount)

#define ITask_GetErrorRetryCount(This,pwRetryCount)	\
    (This)->lpVtbl -> GetErrorRetryCount(This,pwRetryCount)

#define ITask_SetErrorRetryInterval(This,wRetryInterval)	\
    (This)->lpVtbl -> SetErrorRetryInterval(This,wRetryInterval)

#define ITask_GetErrorRetryInterval(This,pwRetryInterval)	\
    (This)->lpVtbl -> GetErrorRetryInterval(This,pwRetryInterval)

#define ITask_SetFlags(This,dwFlags)	\
    (This)->lpVtbl -> SetFlags(This,dwFlags)

#define ITask_GetFlags(This,pdwFlags)	\
    (This)->lpVtbl -> GetFlags(This,pdwFlags)

#define ITask_SetAccountInformation(This,pwszAccountName,pwszPassword)	\
    (This)->lpVtbl -> SetAccountInformation(This,pwszAccountName,pwszPassword)

#define ITask_GetAccountInformation(This,ppwszAccountName)	\
    (This)->lpVtbl -> GetAccountInformation(This,ppwszAccountName)


#define ITask_SetApplicationName(This,pwszApplicationName)	\
    (This)->lpVtbl -> SetApplicationName(This,pwszApplicationName)

#define ITask_GetApplicationName(This,ppwszApplicationName)	\
    (This)->lpVtbl -> GetApplicationName(This,ppwszApplicationName)

#define ITask_SetParameters(This,pwszParameters)	\
    (This)->lpVtbl -> SetParameters(This,pwszParameters)

#define ITask_GetParameters(This,ppwszParameters)	\
    (This)->lpVtbl -> GetParameters(This,ppwszParameters)

#define ITask_SetWorkingDirectory(This,pwszWorkingDirectory)	\
    (This)->lpVtbl -> SetWorkingDirectory(This,pwszWorkingDirectory)

#define ITask_GetWorkingDirectory(This,ppwszWorkingDirectory)	\
    (This)->lpVtbl -> GetWorkingDirectory(This,ppwszWorkingDirectory)

#define ITask_SetPriority(This,dwPriority)	\
    (This)->lpVtbl -> SetPriority(This,dwPriority)

#define ITask_GetPriority(This,pdwPriority)	\
    (This)->lpVtbl -> GetPriority(This,pdwPriority)

#define ITask_SetTaskFlags(This,dwFlags)	\
    (This)->lpVtbl -> SetTaskFlags(This,dwFlags)

#define ITask_GetTaskFlags(This,pdwFlags)	\
    (This)->lpVtbl -> GetTaskFlags(This,pdwFlags)

#define ITask_SetMaxRunTime(This,dwMaxRunTimeMS)	\
    (This)->lpVtbl -> SetMaxRunTime(This,dwMaxRunTimeMS)

#define ITask_GetMaxRunTime(This,pdwMaxRunTimeMS)	\
    (This)->lpVtbl -> GetMaxRunTime(This,pdwMaxRunTimeMS)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITask_SetApplicationName_Proxy( 
    ITask __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszApplicationName);


void __RPC_STUB ITask_SetApplicationName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITask_GetApplicationName_Proxy( 
    ITask __RPC_FAR * This,
    /* [out] */ LPWSTR __RPC_FAR *ppwszApplicationName);


void __RPC_STUB ITask_GetApplicationName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITask_SetParameters_Proxy( 
    ITask __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszParameters);


void __RPC_STUB ITask_SetParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITask_GetParameters_Proxy( 
    ITask __RPC_FAR * This,
    /* [out] */ LPWSTR __RPC_FAR *ppwszParameters);


void __RPC_STUB ITask_GetParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITask_SetWorkingDirectory_Proxy( 
    ITask __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszWorkingDirectory);


void __RPC_STUB ITask_SetWorkingDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITask_GetWorkingDirectory_Proxy( 
    ITask __RPC_FAR * This,
    /* [out] */ LPWSTR __RPC_FAR *ppwszWorkingDirectory);


void __RPC_STUB ITask_GetWorkingDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITask_SetPriority_Proxy( 
    ITask __RPC_FAR * This,
    /* [in] */ DWORD dwPriority);


void __RPC_STUB ITask_SetPriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITask_GetPriority_Proxy( 
    ITask __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwPriority);


void __RPC_STUB ITask_GetPriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITask_SetTaskFlags_Proxy( 
    ITask __RPC_FAR * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITask_SetTaskFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITask_GetTaskFlags_Proxy( 
    ITask __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwFlags);


void __RPC_STUB ITask_GetTaskFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITask_SetMaxRunTime_Proxy( 
    ITask __RPC_FAR * This,
    /* [in] */ DWORD dwMaxRunTimeMS);


void __RPC_STUB ITask_SetMaxRunTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITask_GetMaxRunTime_Proxy( 
    ITask __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwMaxRunTimeMS);


void __RPC_STUB ITask_GetMaxRunTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITask_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_mstask_0120
 * at Fri Aug 29 13:53:36 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


// {148BD528-A2AB-11CE-B11F-00AA00530503}
DEFINE_GUID(IID_IEnumWorkItems, 0x148BD528L, 0xA2AB, 0x11CE, 0xB1, 0x1F, 0x00, 0xAA, 0x00, 0x53, 0x05, 0x03);



extern RPC_IF_HANDLE __MIDL_itf_mstask_0120_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mstask_0120_v0_0_s_ifspec;

#ifndef __IEnumWorkItems_INTERFACE_DEFINED__
#define __IEnumWorkItems_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumWorkItems
 * at Fri Aug 29 13:53:36 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IEnumWorkItems;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("148BD528-A2AB-11CE-B11F-00AA00530503")
    IEnumWorkItems : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ LPWSTR __RPC_FAR *__RPC_FAR *rgpwszNames,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumWorkItems __RPC_FAR *__RPC_FAR *ppEnumWorkItems) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumWorkItemsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumWorkItems __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumWorkItems __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumWorkItems __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumWorkItems __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ LPWSTR __RPC_FAR *__RPC_FAR *rgpwszNames,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumWorkItems __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumWorkItems __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumWorkItems __RPC_FAR * This,
            /* [out] */ IEnumWorkItems __RPC_FAR *__RPC_FAR *ppEnumWorkItems);
        
        END_INTERFACE
    } IEnumWorkItemsVtbl;

    interface IEnumWorkItems
    {
        CONST_VTBL struct IEnumWorkItemsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumWorkItems_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumWorkItems_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumWorkItems_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumWorkItems_Next(This,celt,rgpwszNames,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgpwszNames,pceltFetched)

#define IEnumWorkItems_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumWorkItems_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumWorkItems_Clone(This,ppEnumWorkItems)	\
    (This)->lpVtbl -> Clone(This,ppEnumWorkItems)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumWorkItems_Next_Proxy( 
    IEnumWorkItems __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ LPWSTR __RPC_FAR *__RPC_FAR *rgpwszNames,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumWorkItems_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumWorkItems_Skip_Proxy( 
    IEnumWorkItems __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumWorkItems_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumWorkItems_Reset_Proxy( 
    IEnumWorkItems __RPC_FAR * This);


void __RPC_STUB IEnumWorkItems_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumWorkItems_Clone_Proxy( 
    IEnumWorkItems __RPC_FAR * This,
    /* [out] */ IEnumWorkItems __RPC_FAR *__RPC_FAR *ppEnumWorkItems);


void __RPC_STUB IEnumWorkItems_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumWorkItems_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_mstask_0121
 * at Fri Aug 29 13:53:36 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


// {148BD527-A2AB-11CE-B11F-00AA00530503}
DEFINE_GUID(IID_ITaskScheduler, 0x148BD527L, 0xA2AB, 0x11CE, 0xB1, 0x1F, 0x00, 0xAA, 0x00, 0x53, 0x05, 0x03);



extern RPC_IF_HANDLE __MIDL_itf_mstask_0121_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mstask_0121_v0_0_s_ifspec;

#ifndef __ITaskScheduler_INTERFACE_DEFINED__
#define __ITaskScheduler_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITaskScheduler
 * at Fri Aug 29 13:53:36 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_ITaskScheduler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("148BD527-A2AB-11CE-B11F-00AA00530503")
    ITaskScheduler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetTargetComputer( 
            /* [in] */ LPCWSTR pwszComputer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTargetComputer( 
            /* [out] */ LPWSTR __RPC_FAR *ppwszComputer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enum( 
            /* [out] */ IEnumWorkItems __RPC_FAR *__RPC_FAR *ppEnumWorkItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ LPCWSTR pwszName,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ LPCWSTR pwszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewWorkItem( 
            /* [in] */ LPCWSTR pwszTaskName,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddWorkItem( 
            /* [in] */ LPCWSTR pwszTaskName,
            /* [in] */ IScheduledWorkItem __RPC_FAR *pWorkItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsOfType( 
            /* [in] */ LPCWSTR pwszName,
            /* [in] */ REFIID riid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITaskSchedulerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITaskScheduler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITaskScheduler __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITaskScheduler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTargetComputer )( 
            ITaskScheduler __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszComputer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTargetComputer )( 
            ITaskScheduler __RPC_FAR * This,
            /* [out] */ LPWSTR __RPC_FAR *ppwszComputer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Enum )( 
            ITaskScheduler __RPC_FAR * This,
            /* [out] */ IEnumWorkItems __RPC_FAR *__RPC_FAR *ppEnumWorkItems);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Activate )( 
            ITaskScheduler __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszName,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            ITaskScheduler __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewWorkItem )( 
            ITaskScheduler __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszTaskName,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddWorkItem )( 
            ITaskScheduler __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszTaskName,
            /* [in] */ IScheduledWorkItem __RPC_FAR *pWorkItem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsOfType )( 
            ITaskScheduler __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszName,
            /* [in] */ REFIID riid);
        
        END_INTERFACE
    } ITaskSchedulerVtbl;

    interface ITaskScheduler
    {
        CONST_VTBL struct ITaskSchedulerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITaskScheduler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITaskScheduler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITaskScheduler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITaskScheduler_SetTargetComputer(This,pwszComputer)	\
    (This)->lpVtbl -> SetTargetComputer(This,pwszComputer)

#define ITaskScheduler_GetTargetComputer(This,ppwszComputer)	\
    (This)->lpVtbl -> GetTargetComputer(This,ppwszComputer)

#define ITaskScheduler_Enum(This,ppEnumWorkItems)	\
    (This)->lpVtbl -> Enum(This,ppEnumWorkItems)

#define ITaskScheduler_Activate(This,pwszName,riid,ppUnk)	\
    (This)->lpVtbl -> Activate(This,pwszName,riid,ppUnk)

#define ITaskScheduler_Delete(This,pwszName)	\
    (This)->lpVtbl -> Delete(This,pwszName)

#define ITaskScheduler_NewWorkItem(This,pwszTaskName,rclsid,riid,ppUnk)	\
    (This)->lpVtbl -> NewWorkItem(This,pwszTaskName,rclsid,riid,ppUnk)

#define ITaskScheduler_AddWorkItem(This,pwszTaskName,pWorkItem)	\
    (This)->lpVtbl -> AddWorkItem(This,pwszTaskName,pWorkItem)

#define ITaskScheduler_IsOfType(This,pwszName,riid)	\
    (This)->lpVtbl -> IsOfType(This,pwszName,riid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITaskScheduler_SetTargetComputer_Proxy( 
    ITaskScheduler __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszComputer);


void __RPC_STUB ITaskScheduler_SetTargetComputer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITaskScheduler_GetTargetComputer_Proxy( 
    ITaskScheduler __RPC_FAR * This,
    /* [out] */ LPWSTR __RPC_FAR *ppwszComputer);


void __RPC_STUB ITaskScheduler_GetTargetComputer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITaskScheduler_Enum_Proxy( 
    ITaskScheduler __RPC_FAR * This,
    /* [out] */ IEnumWorkItems __RPC_FAR *__RPC_FAR *ppEnumWorkItems);


void __RPC_STUB ITaskScheduler_Enum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITaskScheduler_Activate_Proxy( 
    ITaskScheduler __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszName,
    /* [in] */ REFIID riid,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk);


void __RPC_STUB ITaskScheduler_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITaskScheduler_Delete_Proxy( 
    ITaskScheduler __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszName);


void __RPC_STUB ITaskScheduler_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITaskScheduler_NewWorkItem_Proxy( 
    ITaskScheduler __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszTaskName,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ REFIID riid,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk);


void __RPC_STUB ITaskScheduler_NewWorkItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITaskScheduler_AddWorkItem_Proxy( 
    ITaskScheduler __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszTaskName,
    /* [in] */ IScheduledWorkItem __RPC_FAR *pWorkItem);


void __RPC_STUB ITaskScheduler_AddWorkItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITaskScheduler_IsOfType_Proxy( 
    ITaskScheduler __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszName,
    /* [in] */ REFIID riid);


void __RPC_STUB ITaskScheduler_IsOfType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITaskScheduler_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_mstask_0122
 * at Fri Aug 29 13:53:36 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


EXTERN_C const CLSID CLSID_CTask;
EXTERN_C const CLSID CLSID_CTaskScheduler;
 
// {148BD520-A2AB-11CE-B11F-00AA00530503}
DEFINE_GUID(CLSID_CTask, 0x148BD520, 0xA2AB, 0x11CE, 0xB1, 0x1F, 0x00, 0xAA, 0x00, 0x53, 0x05, 0x03);
 
// {148BD52A-A2AB-11CE-B11F-00AA00530503}
DEFINE_GUID(CLSID_CTaskScheduler, 0x148BD52A, 0xA2AB, 0x11CE, 0xB1, 0x1F, 0x00, 0xAA, 0x00, 0x53, 0x05, 0x03);
 

typedef struct _PSP __RPC_FAR *HPROPSHEETPAGE;

typedef 
enum _TASKPAGE
    {	TASKPAGE_TASK	= 0,
	TASKPAGE_SCHEDULE	= 1,
	TASKPAGE_SETTINGS	= 2
    }	TASKPAGE;

// {4086658a-cbbb-11cf-b604-00c04fd8d565}
DEFINE_GUID(IID_IProvideTaskPage, 0x4086658aL, 0xcbbb, 0x11cf, 0xb6, 0x04, 0x00, 0xc0, 0x4f, 0xd8, 0xd5, 0x65);



extern RPC_IF_HANDLE __MIDL_itf_mstask_0122_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mstask_0122_v0_0_s_ifspec;

#ifndef __IProvideTaskPage_INTERFACE_DEFINED__
#define __IProvideTaskPage_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IProvideTaskPage
 * at Fri Aug 29 13:53:36 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IProvideTaskPage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4086658a-cbbb-11cf-b604-00c04fd8d565")
    IProvideTaskPage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPage( 
            /* [in] */ TASKPAGE tpType,
            /* [in] */ BOOL fPersistChanges,
            /* [out] */ HPROPSHEETPAGE __RPC_FAR *phPage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvideTaskPageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IProvideTaskPage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IProvideTaskPage __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IProvideTaskPage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPage )( 
            IProvideTaskPage __RPC_FAR * This,
            /* [in] */ TASKPAGE tpType,
            /* [in] */ BOOL fPersistChanges,
            /* [out] */ HPROPSHEETPAGE __RPC_FAR *phPage);
        
        END_INTERFACE
    } IProvideTaskPageVtbl;

    interface IProvideTaskPage
    {
        CONST_VTBL struct IProvideTaskPageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvideTaskPage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProvideTaskPage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProvideTaskPage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProvideTaskPage_GetPage(This,tpType,fPersistChanges,phPage)	\
    (This)->lpVtbl -> GetPage(This,tpType,fPersistChanges,phPage)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IProvideTaskPage_GetPage_Proxy( 
    IProvideTaskPage __RPC_FAR * This,
    /* [in] */ TASKPAGE tpType,
    /* [in] */ BOOL fPersistChanges,
    /* [out] */ HPROPSHEETPAGE __RPC_FAR *phPage);


void __RPC_STUB IProvideTaskPage_GetPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProvideTaskPage_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_mstask_0123
 * at Fri Aug 29 13:53:36 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


#define ISchedulingAgent       ITaskScheduler
#define IID_ISchedulingAgent   IID_ITaskScheduler
#define CLSID_CSchedulingAgent CLSID_CTaskScheduler


extern RPC_IF_HANDLE __MIDL_itf_mstask_0123_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mstask_0123_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\inc\shlguid.h ===
//===========================================================================
//
// Copyright (c) Microsoft Corporation 1995-1997
//
// File: shlguid.h
//
//===========================================================================

#ifndef _SHLGUID_H_
#define _SHLGUID_H_

#ifndef _WIN32_IE
#define _WIN32_IE 0x0400
#else
#if (_WIN32_IE < 0x0400) && defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0500)
#error _WIN32_IE setting conflicts with _WIN32_WINNT setting
#endif
#endif

//
// For shell-reserved GUID
//
//  The Win95 Shell has been allocated a block of 256 GUIDs,
// which follow the general format:
//
//  000214xx-0000-0000-C000-000000000046
//
//
#define DEFINE_SHLGUID(name, l, w1, w2) DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)


//
// Class IDs        xx=00-8F
//
DEFINE_SHLGUID(CLSID_ShellDesktop,      0x00021400L, 0, 0);
DEFINE_SHLGUID(CLSID_ShellLink,         0x00021401L, 0, 0);


#if (_WIN32_IE >= 0x0400)
//
// CatInformation IDs   xx=90-9F
//
DEFINE_SHLGUID(CATID_BrowsableShellExt, 0x00021490L, 0, 0);
DEFINE_SHLGUID(CATID_BrowseInPlace,     0x00021491L, 0, 0);
DEFINE_SHLGUID(CATID_DeskBand,          0x00021492L, 0, 0);
DEFINE_SHLGUID(CATID_InfoBand,          0x00021493L, 0, 0);
DEFINE_SHLGUID(CATID_CommBand,          0x00021494L, 0, 0);
#endif

// Format IDs       xx=A0-CF
DEFINE_SHLGUID(FMTID_Intshcut,          0x000214A0L, 0, 0);
DEFINE_SHLGUID(FMTID_InternetSite,      0x000214A1L, 0, 0);

// command group ids xx=D0-DF
DEFINE_SHLGUID(CGID_Explorer,           0x000214D0L, 0, 0);
DEFINE_SHLGUID(CGID_ShellDocView,       0x000214D1L, 0, 0);

#if (_WIN32_IE >= 0x0400)
DEFINE_SHLGUID(CGID_ShellServiceObject, 0x000214D2L, 0, 0);
DEFINE_SHLGUID(CGID_ExplorerBarDoc,     0x000214D3L, 0, 0);
#endif



//
// Interface IDs    xx=E0-FF
//
DEFINE_SHLGUID(IID_INewShortcutHookA,   0x000214E1L, 0, 0);
DEFINE_SHLGUID(IID_IShellBrowser,       0x000214E2L, 0, 0);
DEFINE_SHLGUID(IID_IShellView,          0x000214E3L, 0, 0);
DEFINE_SHLGUID(IID_IContextMenu,        0x000214E4L, 0, 0);
DEFINE_SHLGUID(IID_IShellIcon,          0x000214E5L, 0, 0);
DEFINE_SHLGUID(IID_IShellFolder,        0x000214E6L, 0, 0);

DEFINE_SHLGUID(IID_IShellExtInit,       0x000214E8L, 0, 0);
DEFINE_SHLGUID(IID_IShellPropSheetExt,  0x000214E9L, 0, 0);
DEFINE_SHLGUID(IID_IPersistFolder,      0x000214EAL, 0, 0);
DEFINE_SHLGUID(IID_IExtractIconA,       0x000214EBL, 0, 0);
DEFINE_SHLGUID(IID_IShellDetails,       0x000214ECL, 0, 0);
DEFINE_SHLGUID(IID_IDelayedRelease,     0x000214EDL, 0, 0);
DEFINE_SHLGUID(IID_IShellLinkA,         0x000214EEL, 0, 0);
DEFINE_SHLGUID(IID_IShellCopyHookA,     0x000214EFL, 0, 0);
DEFINE_SHLGUID(IID_IFileViewerA,        0x000214F0L, 0, 0);
DEFINE_SHLGUID(IID_ICommDlgBrowser,     0x000214F1L, 0, 0);
DEFINE_SHLGUID(IID_IEnumIDList,         0x000214F2L, 0, 0);
DEFINE_SHLGUID(IID_IFileViewerSite,     0x000214F3L, 0, 0);
DEFINE_SHLGUID(IID_IContextMenu2,       0x000214F4L, 0, 0);
DEFINE_SHLGUID(IID_IShellExecuteHookA,  0x000214F5L, 0, 0);
DEFINE_SHLGUID(IID_IPropSheetPage,      0x000214F6L, 0, 0);
DEFINE_SHLGUID(IID_INewShortcutHookW,   0x000214F7L, 0, 0);
DEFINE_SHLGUID(IID_IFileViewerW,        0x000214F8L, 0, 0);
DEFINE_SHLGUID(IID_IShellLinkW,         0x000214F9L, 0, 0);
DEFINE_SHLGUID(IID_IExtractIconW,       0x000214FAL, 0, 0);
DEFINE_SHLGUID(IID_IShellExecuteHookW,  0x000214FBL, 0, 0);
DEFINE_SHLGUID(IID_IShellCopyHookW,     0x000214FCL, 0, 0);
DEFINE_SHLGUID(IID_IRemoteComputerA,    0x000214FDL, 0, 0);
DEFINE_SHLGUID(IID_IRemoteComputerW,    0x000214FEL, 0, 0);

#if (_WIN32_IE >= 0x0400)
DEFINE_SHLGUID(IID_IQueryInfo,          0x00021500L, 0, 0);
#endif

DEFINE_GUID(IID_IBriefcaseStg,          0x8BCE1FA1L, 0x0921, 0x101B, 0xB1, 0xFF, 0x00, 0xDD, 0x01, 0x0C, 0xCC, 0x48);
DEFINE_GUID(IID_IShellView2,            0x88E39E80L, 0x3578, 0x11CF, 0xAE, 0x69, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);

#if (_WIN32_IE >= 0x0400)
DEFINE_GUID(IID_IURLSearchHook,         0xAC60F6A0L, 0x0FD9, 0x11D0, 0x99, 0xCB, 0x00, 0xC0, 0x4F, 0xD6, 0x44, 0x97);
DEFINE_GUID(IID_IDelegateFolder,        0xADD8BA80L, 0x002B, 0x11D0, 0x8F, 0x0F, 0x00, 0xC0, 0x4F, 0xD7, 0xD0, 0x62);

DEFINE_GUID(IID_IInputObject,           0x68284faa, 0x6a48, 0x11d0, 0x8c, 0x78, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xb4);
DEFINE_GUID(IID_IInputObjectSite,       0xf1db8392, 0x7331, 0x11d0, 0x8c, 0x99, 0x0, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8);

DEFINE_GUID(IID_IDockingWindow,         0x12dd920, 0x7b26, 0x11d0, 0x8c, 0xa9, 0x0, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8);
DEFINE_GUID(IID_IDockingWindowSite,     0x2a342fc2, 0x7b26, 0x11d0, 0x8c, 0xa9, 0x0, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8);
DEFINE_GUID(IID_IDockingWindowFrame,    0x47d2657a, 0x7b27, 0x11d0, 0x8c, 0xa9, 0x0, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8);

DEFINE_GUID(IID_IShellIconOverlay,      0x7D688A70L, 0xC613, 0x11D0, 0x99, 0x9B, 0x00, 0xC0, 0x4F, 0xD6, 0x55, 0xE1);
DEFINE_GUID(IID_IShellIconOverlayManager, 0x63B51F80L, 0xC868, 0x11D0, 0x99, 0x9C, 0x00, 0xC0, 0x4F, 0xD6, 0x55, 0xE1);
DEFINE_GUID(IID_IShellIconOverlayIdentifier,  0x0C6C4200L, 0xC589, 0x11D0, 0x99, 0x9A, 0x00, 0xC0, 0x4F, 0xD6, 0x55, 0xE1);

// {1AC3D9F0-175C-11d1-95BE-00609797EA4F}
DEFINE_GUID(IID_IPersistFolder2,        0x1ac3d9f0, 0x175c, 0x11d1, 0x95, 0xbe, 0x0, 0x60, 0x97, 0x97, 0xea, 0x4f);

// {63B51F81-C868-11D0-999C-00C04FD655E1}
DEFINE_GUID(CLSID_CFSIconOverlayManager, 0x63B51F81L, 0xC868, 0x11D0, 0x99, 0x9C, 0x00, 0xC0, 0x4F, 0xD6, 0x55, 0xE1);

// Shell Icon Overlay Identifiers
// {7D688A77-C613-11D0-999B-00C04FD655E1}
DEFINE_GUID(CLSID_OverlayIdentifier_SlowFile, 0x7D688A77L, 0xC613, 0x11D0, 0x99, 0x9B, 0x00, 0xC0, 0x4F, 0xD6, 0x55, 0xE1);


// {BCFCE0A0-EC17-11d0-8D10-00A0C90F2719}
DEFINE_GUID(IID_IContextMenu3,          0xbcfce0a0, 0xec17, 0x11d0, 0x8d, 0x10, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);


/// DeskBar stuff
DEFINE_GUID(IID_IDeskBand,              0xEB0FE172L, 0x1A3A, 0x11D0, 0x89, 0xB3, 0x00, 0xA0, 0xC9, 0x0A, 0x90, 0xAC);
#define CGID_DeskBand IID_IDeskBand
#ifdef ISHELLTOOLBAND_COMPAT
DEFINE_GUID(IID_IShellToolband,         0xEB0FE171L, 0x1A3A, 0x11D0, 0x89, 0xB3, 0x00, 0xA0, 0xC9, 0x0A, 0x90, 0xAC);
#endif
#endif


#define SID_SShellBrowser IID_IShellBrowser
#if (_WIN32_IE >= 0x0400)
#define SID_SShellDesktop CLSID_ShellDesktop
#endif

//
//  IShellDiscardable is an IID-only interface. If the object supports this
// interface it can be discarded anytime. IWebBrowser::PutProperty QI's for
// this interface to detect discardable properties. 
//
DEFINE_GUID(IID_IDiscardableBrowserProperty, 0x49c3de7c, 0xd329, 0x11d0, 0xab, 0x73, 0x00, 0xc0, 0x4f, 0xc3, 0x3e, 0x80);

#ifdef UNICODE
#define IID_IFileViewer         IID_IFileViewerW
#define IID_IShellLink          IID_IShellLinkW
#define IID_IExtractIcon        IID_IExtractIconW
#define IID_IShellCopyHook      IID_IShellCopyHookW
#define IID_IShellExecuteHook   IID_IShellExecuteHookW
#define IID_INewShortcutHook    IID_INewShortcutHookW
#else
#define IID_IFileViewer         IID_IFileViewerA
#define IID_IShellLink          IID_IShellLinkA
#define IID_IExtractIcon        IID_IExtractIconA
#define IID_IShellCopyHook      IID_IShellCopyHookA
#define IID_IShellExecuteHook   IID_IShellExecuteHookA
#define IID_INewShortcutHook    IID_INewShortcutHookA
#endif


#ifndef NO_INTSHCUT_GUIDS
// Include internet shortcut GUIDs
#include <isguids.h>
#endif

#ifndef NO_SHDOCVW_GUIDS

#include <exdisp.h>


#if (_WIN32_IE >= 0x0400)
// UrlHistory Guids
DEFINE_GUID(CLSID_CUrlHistory,          0x3C374A40L, 0xBAE4, 0x11CF, 0xBF, 0x7D, 0x00, 0xAA, 0x00, 0x69, 0x46, 0xEE);
#define SID_SUrlHistory         CLSID_CUrlHistory

//UrlSearchHook Guids
DEFINE_GUID(CLSID_CURLSearchHook,       0xCFBFAE00L, 0x17A6, 0x11D0, 0x99, 0xCB, 0x00, 0xC0, 0x4F, 0xD6, 0x44, 0x97);


#define SID_SInternetExplorer IID_IWebBrowserApp
#define SID_SWebBrowserApp    IID_IWebBrowserApp


//
// Top-most browser implementation in the heirarchy. use IServiceProvider::QueryService()
// to get to interfaces (IID_IShellBrowser, IID_IBrowserService, etc.)
//
DEFINE_GUID(SID_STopLevelBrowser,       0x4C96BE40L, 0x915C, 0x11CF, 0x99, 0xD3, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

#endif

#endif


#if (_WIN32_IE >= 0x0400)

// {75048700-EF1F-11D0-9888-006097DEACF9}
DEFINE_GUID( CLSID_ActiveDesktop, 0x75048700L, 0xEF1F, 0x11D0, 0x98, 0x88, 0x00, 0x60, 0x97, 0xDE, 0xAC, 0xF9);

// {F490EB00-1240-11D1-9888-006097DEACF9}
DEFINE_GUID(IID_IActiveDesktop, 0xF490EB00L, 0x1240, 0x11D1, 0x98, 0x88, 0x00, 0x60, 0x97, 0xDE, 0xAC, 0xF9);


// {56FDF344-FD6D-11d0-958A-006097C9A090}
DEFINE_GUID(CLSID_TaskbarList, 0x56fdf344, 0xfd6d, 0x11d0, 0x95, 0x8a, 0x0, 0x60, 0x97, 0xc9, 0xa0, 0x90);

// {56FDF342-FD6D-11d0-958A-006097C9A090}
DEFINE_GUID(IID_ITaskbarList, 0x56fdf342, 0xfd6d, 0x11d0, 0x95, 0x8a, 0x0, 0x60, 0x97, 0xc9, 0xa0, 0x90);

#endif  // _WIN32_IE

#endif // _SHLGUID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\inc\thmbobj.h ===
//===========================================================================
//
// Copyright (c) Microsoft Corporation 1991-1998
//
// File: shlobj.h
//
//===========================================================================

//;begin_both
#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */
//;end_both


// --- IExtractImage
//-------------------------------------------------------------------------
//
// IThumbnail interface
//
//
// [Member functions]
//
// IThumbnail::Init(HWND hwnd, UINT uMsg)
//   Must initialize interface before use.  The hwnd given will receive the
//   uMsg message when the bitmap is computed (cf. GetBitmap()).
//
// IThumbnail::GetBitmap(LPCWSTR pwszFile, DWORD dwItem, LONG lWidth, LONG lHeight)
//   Call this function to actually compute and return the bitmap.  pszFile is
//   the file UNC whose bitmap is to be computed.  lWidth and lHeight are the
//   width and height respectively of the rectangle containing the thumbnail,
//   i.e. the size of the resultant bitmap.  When the bitmap is computed, the
//   uMsg is sent to the hwnd (cf. Init()) where LPARAM is the HBITMAP, and
//   WPARAM is dwItem (so it's an ID to identify the bitmap).
//   NOTE: Call GetBitmap(NULL,...) to cancel any pending requests.
//
//-------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE IThumbnail

DECLARE_INTERFACE_(IThumbnail, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IThumbnail specific methods ***
    STDMETHOD(Init) (THIS_ HWND hwnd, UINT uMsg) PURE;
    STDMETHOD(GetBitmap) (THIS_ LPCWSTR wszFile, DWORD dwItem, LONG lWidth, LONG lHeight) PURE;
};


//;begin_both
#ifdef __cplusplus
}

#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */
//;end_both
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\inc\shlobj.h ===
//===========================================================================
//
// Copyright (c) Microsoft Corporation 1991-1997
//
// File: shlobj.h
//
//===========================================================================

#ifndef _SHLOBJ_H_
#define _SHLOBJ_H_

#ifndef SNDMSG
#ifdef __cplusplus
#define SNDMSG ::SendMessage
#else
#define SNDMSG SendMessage
#endif
#endif // ifndef SNDMSG

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINSHELLAPI
#if !defined(_SHELL32_)
#define WINSHELLAPI       DECLSPEC_IMPORT
#else
#define WINSHELLAPI
#endif
#endif // WINSHELLAPI

#ifndef SHSTDAPI
#if !defined(_SHELL32_)
#define SHSTDAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define SHSTDAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#else
#define SHSTDAPI          STDAPI
#define SHSTDAPI_(type)   STDAPI_(type)
#endif
#endif // SHSTDAPI

#ifndef SHDOCAPI
#if !defined(_SHDOCVW_)
#define SHDOCAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define SHDOCAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#else
#define SHDOCAPI          STDAPI
#define SHDOCAPI_(type)   STDAPI_(type)
#endif
#endif // SHDOCAPI


#include <ole2.h>
#ifndef _PRSHT_H_
#include <prsht.h>
#endif
#ifndef _INC_COMMCTRL
#include <commctrl.h>   // for LPTBBUTTON
#endif

#ifndef INITGUID
#include <shlguid.h>
#endif /* !INITGUID */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */


//===========================================================================
//
// Object identifiers in the explorer's name space (ItemID and IDList)
//
//  All the items that the user can browse with the explorer (such as files,
// directories, servers, work-groups, etc.) has an identifier which is unique
// among items within the parent folder. Those identifiers are called item
// IDs (SHITEMID). Since all its parent folders have their own item IDs,
// any items can be uniquely identified by a list of item IDs, which is called
// an ID list (ITEMIDLIST).
//
//  ID lists are almost always allocated by the task allocator (see some
// description below as well as OLE 2.0 SDK) and may be passed across
// some of shell interfaces (such as IShellFolder). Each item ID in an ID list
// is only meaningful to its parent folder (which has generated it), and all
// the clients must treat it as an opaque binary data except the first two
// bytes, which indicates the size of the item ID.
//
//  When a shell extension -- which implements the IShellFolder interace --
// generates an item ID, it may put any information in it, not only the data
// with that it needs to identifies the item, but also some additional
// information, which would help implementing some other functions efficiently.
// For example, the shell's IShellFolder implementation of file system items
// stores the primary (long) name of a file or a directory as the item
// identifier, but it also stores its alternative (short) name, size and date
// etc.
//
//  When an ID list is passed to one of shell APIs (such as SHGetPathFromIDList),
// it is always an absolute path -- relative from the root of the name space,
// which is the desktop folder. When an ID list is passed to one of IShellFolder
// member function, it is always a relative path from the folder (unless it
// is explicitly specified).
//
//===========================================================================

//
// SHITEMID -- Item ID
//
typedef struct _SHITEMID        // mkid
{
    USHORT      cb;             // Size of the ID (including cb itself)
    BYTE        abID[1];        // The item ID (variable length)
} SHITEMID;
typedef UNALIGNED SHITEMID *LPSHITEMID;
typedef const UNALIGNED SHITEMID *LPCSHITEMID;

//
// ITEMIDLIST -- List if item IDs (combined with 0-terminator)
//
typedef struct _ITEMIDLIST      // idl
{
    SHITEMID    mkid;
} ITEMIDLIST;
typedef UNALIGNED ITEMIDLIST * LPITEMIDLIST;
typedef const UNALIGNED ITEMIDLIST * LPCITEMIDLIST;


//===========================================================================
//
// Task allocator API
//
//  All the shell extensions MUST use the task allocator (see OLE 2.0
// programming guild for its definition) when they allocate or free
// memory objects (mostly ITEMIDLIST) that are returned across any
// shell interfaces. There are two ways to access the task allocator
// from a shell extension depending on whether or not it is linked with
// OLE32.DLL or not (purely for efficiency).
//
// (1) A shell extension which calls any OLE API (i.e., linked with
//  OLE32.DLL) should call OLE's task allocator (by retrieving
//  the task allocator by calling CoGetMalloc API).
//
// (2) A shell extension which does not call any OLE API (i.e., not linked
//  with OLE32.DLL) should call the shell task allocator API (defined
//  below), so that the shell can quickly loads it when OLE32.DLL is not
//  loaded by any application at that point.
//
// Notes:
//  In next version of Windowso release, SHGetMalloc will be replaced by
// the following macro.
//
// #define SHGetMalloc(ppmem)   CoGetMalloc(MEMCTX_TASK, ppmem)
//
//===========================================================================

WINSHELLAPI HRESULT WINAPI SHGetMalloc(LPMALLOC * ppMalloc);


//===========================================================================
//
// IContextMenu interface
//
// [OverView]
//
//  The shell uses the IContextMenu interface in following three cases.
//
// case-1: The shell is loading context menu extensions.
//
//   When the user clicks the right mouse button on an item within the shell's
//  name space (i.g., file, directory, server, work-group, etc.), it creates
//  the default context menu for its type, then loads context menu extensions
//  that are registered for that type (and its base type) so that they can
//  add extra menu items. Those context menu extensions are registered at
//  HKCR\{ProgID}\shellex\ContextMenuHandlers.
//
// case-2: The shell is retrieving a context menu of sub-folders in extended
//   name-space.
//
//   When the explorer's name space is extended by name space extensions,
//  the shell calls their IShellFolder::GetUIObjectOf to get the IContextMenu
//  objects when it creates context menus for folders under those extended
//  name spaces.
//
// case-3: The shell is loading non-default drag and drop handler for directories.
//
//   When the user performed a non-default drag and drop onto one of file
//  system folders (i.e., directories), it loads shell extensions that are
//  registered at HKCR\{ProgID}\DragDropHandlers.
//
//
// [Member functions]
//
//
// IContextMenu::QueryContextMenu
//
//   This member function may insert one or more menuitems to the specified
//  menu (hmenu) at the specified location (indexMenu which is never be -1).
//  The IDs of those menuitem must be in the specified range (idCmdFirst and
//  idCmdLast). It returns the maximum menuitem ID offset (ushort) in the
//  'code' field (low word) of the scode.
//
//   The uFlags specify the context. It may have one or more of following
//  flags.
//
//  CMF_DEFAULTONLY: This flag is passed if the user is invoking the default
//   action (typically by double-clicking, case 1 and 2 only). Context menu
//   extensions (case 1) should not add any menu items, and returns NOERROR.
//
//  CMF_VERBSONLY: The explorer passes this flag if it is constructing
//   a context menu for a short-cut object (case 1 and case 2 only). If this
//   flag is passed, it should not add any menu-items that is not appropriate
//   from a short-cut.
//    A good example is the "Delete" menuitem, which confuses the user
//   because it is not clear whether it deletes the link source item or the
//   link itself.
//
//  CMF_EXPLORER: The explorer passes this flag if it has the left-side pane
//   (case 1 and 2 only). Context menu extensions should ignore this flag.
//
//   High word (16-bit) are reserved for context specific communications
//  and the rest of flags (13-bit) are reserved by the system.
//
//
// IContextMenu::InvokeCommand
//
//   This member is called when the user has selected one of menuitems that
//  are inserted by previous QueryContextMenu member. In this case, the
//  LOWORD(lpici->lpVerb) contains the menuitem ID offset (menuitem ID -
//  idCmdFirst).
//
//   This member function may also be called programmatically. In such a case,
//  lpici->lpVerb specifies the canonical name of the command to be invoked,
//  which is typically retrieved by GetCommandString member previously.
//
//  Parameters in lpci:
//    cbSize -- Specifies the size of this structure (sizeof(*lpci))
//    hwnd   -- Specifies the owner window for any message/dialog box.
//    fMask  -- Specifies whether or not dwHotkey/hIcon paramter is valid.
//    lpVerb -- Specifies the command to be invoked.
//    lpParameters -- Parameters (optional)
//    lpDirectory  -- Working directory (optional)
//    nShow -- Specifies the flag to be passed to ShowWindow (SW_*).
//    dwHotKey -- Hot key to be assigned to the app after invoked (optional).
//    hIcon -- Specifies the icon (optional).
//    hMonitor -- Specifies the default monitor (optional).
//
//
// IContextMenu::GetCommandString
//
//   This member function is called by the explorer either to get the
//  canonical (language independent) command name (uFlags == GCS_VERB) or
//  the help text ((uFlags & GCS_HELPTEXT) != 0) for the specified command.
//  The retrieved canonical string may be passed to its InvokeCommand
//  member function to invoke a command programmatically. The explorer
//  displays the help texts in its status bar; therefore, the length of
//  the help text should be reasonably short (<40 characters).
//
//  Parameters:
//   idCmd -- Specifies menuitem ID offset (from idCmdFirst)
//   uFlags -- Either GCS_VERB or GCS_HELPTEXT
//   pwReserved -- Reserved (must pass NULL when calling, must ignore when called)
//   pszName -- Specifies the string buffer.
//   cchMax -- Specifies the size of the string buffer.
//
//===========================================================================

// QueryContextMenu uFlags
#define CMF_NORMAL              0x00000000
#define CMF_DEFAULTONLY         0x00000001
#define CMF_VERBSONLY           0x00000002
#define CMF_EXPLORE             0x00000004
#define CMF_NOVERBS             0x00000008
#define CMF_CANRENAME           0x00000010
#define CMF_NODEFAULT           0x00000020
#define CMF_INCLUDESTATIC       0x00000040
#define CMF_RESERVED            0xffff0000      // View specific

// GetCommandString uFlags
#define GCS_VERBA        0x00000000     // canonical verb
#define GCS_HELPTEXTA    0x00000001     // help text (for status bar)
#define GCS_VALIDATEA    0x00000002     // validate command exists
#define GCS_VERBW        0x00000004     // canonical verb (unicode)
#define GCS_HELPTEXTW    0x00000005     // help text (unicode version)
#define GCS_VALIDATEW    0x00000006     // validate command exists (unicode)
#define GCS_UNICODE      0x00000004     // for bit testing - Unicode string

#ifdef UNICODE
#define GCS_VERB        GCS_VERBW
#define GCS_HELPTEXT    GCS_HELPTEXTW
#define GCS_VALIDATE    GCS_VALIDATEW
#else
#define GCS_VERB        GCS_VERBA
#define GCS_HELPTEXT    GCS_HELPTEXTA
#define GCS_VALIDATE    GCS_VALIDATEA
#endif

#define CMDSTR_NEWFOLDERA   "NewFolder"
#define CMDSTR_VIEWLISTA    "ViewList"
#define CMDSTR_VIEWDETAILSA "ViewDetails"
#define CMDSTR_NEWFOLDERW   L"NewFolder"
#define CMDSTR_VIEWLISTW    L"ViewList"
#define CMDSTR_VIEWDETAILSW L"ViewDetails"

#ifdef UNICODE
#define CMDSTR_NEWFOLDER    CMDSTR_NEWFOLDERW
#define CMDSTR_VIEWLIST     CMDSTR_VIEWLISTW
#define CMDSTR_VIEWDETAILS  CMDSTR_VIEWDETAILSW
#else
#define CMDSTR_NEWFOLDER    CMDSTR_NEWFOLDERA
#define CMDSTR_VIEWLIST     CMDSTR_VIEWLISTA
#define CMDSTR_VIEWDETAILS  CMDSTR_VIEWDETAILSA
#endif

#define CMIC_MASK_HOTKEY        SEE_MASK_HOTKEY
#define CMIC_MASK_ICON          SEE_MASK_ICON
#define CMIC_MASK_FLAG_NO_UI    SEE_MASK_FLAG_NO_UI
#define CMIC_MASK_UNICODE       SEE_MASK_UNICODE
#define CMIC_MASK_NO_CONSOLE    SEE_MASK_NO_CONSOLE
#define CMIC_MASK_HASLINKNAME   SEE_MASK_HASLINKNAME
#define CMIC_MASK_FLAG_SEP_VDM  SEE_MASK_FLAG_SEPVDM
#define CMIC_MASK_HASTITLE      SEE_MASK_HASTITLE
#define CMIC_MASK_ASYNCOK       SEE_MASK_ASYNCOK

#if (_WIN32_IE >= 0x0400)
#define CMIC_MASK_PTINVOKE      0x20000000
#endif


//NOTE: When SEE_MASK_HMONITOR is set, hIcon is treated as hMonitor 
typedef struct _CMINVOKECOMMANDINFO {
    DWORD cbSize;        // sizeof(CMINVOKECOMMANDINFO)
    DWORD fMask;         // any combination of CMIC_MASK_*
    HWND hwnd;           // might be NULL (indicating no owner window)
    LPCSTR lpVerb;       // either a string or MAKEINTRESOURCE(idOffset)
    LPCSTR lpParameters; // might be NULL (indicating no parameter)
    LPCSTR lpDirectory;  // might be NULL (indicating no specific directory)
    int nShow;           // one of SW_ values for ShowWindow() API

    DWORD dwHotKey;
    HANDLE hIcon;
} CMINVOKECOMMANDINFO,  *LPCMINVOKECOMMANDINFO;

typedef struct _CMInvokeCommandInfoEx {
    DWORD cbSize;        // must be sizeof(CMINVOKECOMMANDINFOEX)
    DWORD fMask;         // any combination of CMIC_MASK_*
    HWND hwnd;           // might be NULL (indicating no owner window)
    LPCSTR lpVerb;       // either a string or MAKEINTRESOURCE(idOffset)
    LPCSTR lpParameters; // might be NULL (indicating no parameter)
    LPCSTR lpDirectory;  // might be NULL (indicating no specific directory)
    int nShow;           // one of SW_ values for ShowWindow() API

    DWORD dwHotKey;
    
    HANDLE hIcon;
    LPCSTR lpTitle;      // For CreateProcess-StartupInfo.lpTitle
    LPCWSTR lpVerbW;        // Unicode verb (for those who can use it)
    LPCWSTR lpParametersW;  // Unicode parameters (for those who can use it)
    LPCWSTR lpDirectoryW;   // Unicode directory (for those who can use it)
    LPCWSTR lpTitleW;       // Unicode title (for those who can use it)
#if (_WIN32_IE >= 0x0400)
    POINT   ptInvoke;       // Point where it's invoked
#endif
} CMINVOKECOMMANDINFOEX,  *LPCMINVOKECOMMANDINFOEX;

#undef  INTERFACE
#define INTERFACE   IContextMenu

DECLARE_INTERFACE_(IContextMenu, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(QueryContextMenu)(THIS_
                                HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags) PURE;

    STDMETHOD(InvokeCommand)(THIS_
                             LPCMINVOKECOMMANDINFO lpici) PURE;

    STDMETHOD(GetCommandString)(THIS_
                                UINT        idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax) PURE;
};

typedef IContextMenu *  LPCONTEXTMENU;

//
// IContextMenu2 (IContextMenu with one new member)
//
// IContextMenu2::HandleMenuMsg
//
//  This function is called, if the client of IContextMenu is aware of
// IContextMenu2 interface and receives one of following messages while
// it is calling TrackPopupMenu (in the window proc of hwndOwner):
//      WM_INITPOPUP, WM_DRAWITEM and WM_MEASUREITEM
//  The callee may handle these messages to draw owner draw menuitems.
//

#undef  INTERFACE
#define INTERFACE   IContextMenu2

DECLARE_INTERFACE_(IContextMenu2, IContextMenu)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IContextMenu methods ***
    
    STDMETHOD(QueryContextMenu)(THIS_
                                HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags) PURE;

    STDMETHOD(InvokeCommand)(THIS_
                             LPCMINVOKECOMMANDINFO lpici) PURE;

    STDMETHOD(GetCommandString)(THIS_
                                UINT        idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax) PURE;

    // *** IContextMenu2 methods ***
    
    STDMETHOD(HandleMenuMsg)(THIS_
                             UINT uMsg,
                             WPARAM wParam,
                             LPARAM lParam) PURE;
};

typedef IContextMenu2 * LPCONTEXTMENU2;

//
// IContextMenu3 (IContextMenu with one new member)
//
// IContextMenu3::HandleMenuMsg2
//
//  This function is called, if the client of IContextMenu is aware of
// IContextMenu3 interface and receives a menu message while
// it is calling TrackPopupMenu (in the window proc of hwndOwner):
//

#undef  INTERFACE
#define INTERFACE   IContextMenu3

DECLARE_INTERFACE_(IContextMenu3, IContextMenu2)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IContextMenu methods ***
    
    STDMETHOD(QueryContextMenu)(THIS_
                                HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags) PURE;

    STDMETHOD(InvokeCommand)(THIS_
                             LPCMINVOKECOMMANDINFO lpici) PURE;

    STDMETHOD(GetCommandString)(THIS_
                                UINT        idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax) PURE;

    // *** IContextMenu2 methods ***
    
    STDMETHOD(HandleMenuMsg)(THIS_
                             UINT uMsg,
                             WPARAM wParam,
                             LPARAM lParam) PURE;

    // *** IContextMenu3 methods ***
    
    STDMETHOD(HandleMenuMsg2)(THIS_
                             UINT uMsg,
                             WPARAM wParam,
                             LPARAM lParam,
                             LRESULT* plResult) PURE;
};

typedef IContextMenu3 * LPCONTEXTMENU3;


//===========================================================================
//
// Interface: IShellExtInit
//
//  The IShellExtInit interface is used by the explorer to initialize shell
// extension objects. The explorer (1) calls CoCreateInstance (or equivalent)
// with the registered CLSID and IID_IShellExtInit, (2) calls its Initialize
// member, then (3) calls its QueryInterface to a particular interface (such
// as IContextMenu or IPropSheetExt and (4) performs the rest of operation.
//
//
// [Member functions]
//
// IShellExtInit::Initialize
//
//  This member function is called when the explorer is initializing either
// context menu extension, property sheet extension or non-default drag-drop
// extension.
//
//  Parameters: (context menu or property sheet extension)
//   pidlFolder -- Specifies the parent folder
//   lpdobj -- Spefifies the set of items selected in that folder.
//   hkeyProgID -- Specifies the type of the focused item in the selection.
//
//  Parameters: (non-default drag-and-drop extension)
//   pidlFolder -- Specifies the target (destination) folder
//   lpdobj -- Specifies the items that are dropped (see the description
//    about shell's clipboard below for clipboard formats).
//   hkeyProgID -- Specifies the folder type.
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellExtInit

DECLARE_INTERFACE_(IShellExtInit, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellExtInit methods ***
    STDMETHOD(Initialize)(THIS_ LPCITEMIDLIST pidlFolder,
                          LPDATAOBJECT lpdobj, HKEY hkeyProgID) PURE;
};

typedef IShellExtInit * LPSHELLEXTINIT;


//===========================================================================
//
// Interface: IShellPropSheetExt
//
//  The explorer uses the IShellPropSheetExt to allow property sheet
// extensions or control panel extensions to add additional property
// sheet pages.
//
//
// [Member functions]
//
// IShellPropSheetExt::AddPages
//
//  The explorer calls this member function when it finds a registered
// property sheet extension for a particular type of object. For each
// additional page, the extension creates a page object by calling
// CreatePropertySheetPage API and calls lpfnAddPage.
//
//  Parameters:
//   lpfnAddPage -- Specifies the callback function.
//   lParam -- Specifies the opaque handle to be passed to the callback function.
//
//
// IShellPropSheetExt::ReplacePage
//
//  The explorer never calls this member of property sheet extensions. The
// explorer calls this member of control panel extensions, so that they
// can replace some of default control panel pages (such as a page of
// mouse control panel).
//
//  Parameters:
//   uPageID -- Specifies the page to be replaced.
//   lpfnReplace Specifies the callback function.
//   lParam -- Specifies the opaque handle to be passed to the callback function.
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellPropSheetExt

DECLARE_INTERFACE_(IShellPropSheetExt, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellPropSheetExt methods ***
    STDMETHOD(AddPages)(THIS_ LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam) PURE;
    STDMETHOD(ReplacePage)(THIS_ UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam) PURE;
};

typedef IShellPropSheetExt * LPSHELLPROPSHEETEXT;


//===========================================================================
//
// IPersistFolder Interface
//
//  The IPersistFolder interface is used by the file system implementation of
// IShellFolder::BindToObject when it is initializing a shell folder object.
//
//
// [Member functions]
//
// IPersistFolder::Initialize
//
//  This member function is called when the explorer is initializing a
// shell folder object.
//
//  Parameters:
//   pidl -- Specifies the absolute location of the folder.
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IPersistFolder

DECLARE_INTERFACE_(IPersistFolder, IPersist)    // fld
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID)(THIS_ LPCLSID lpClassID) PURE;

    // *** IPersistFolder methods ***
    STDMETHOD(Initialize)(THIS_ LPCITEMIDLIST pidl) PURE;
};

typedef IPersistFolder *LPPERSISTFOLDER;

#undef  INTERFACE
#define INTERFACE   IPersistFolder2

DECLARE_INTERFACE_(IPersistFolder2, IPersistFolder)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID)(THIS_ LPCLSID lpClassID) PURE;

    // *** IPersistFolder methods ***
    STDMETHOD(Initialize)(THIS_ LPCITEMIDLIST pidl) PURE;

    // *** IPersistFolder2 methods ***
    STDMETHOD(GetCurFolder)(THIS_ LPITEMIDLIST *ppidl) PURE;
};



//===========================================================================
//
// IExtractIcon interface
//
//  This interface is used in two different places in the shell.
//
// Case-1: Icons of sub-folders for the scope-pane of the explorer.
//
//  It is used by the explorer to get the "icon location" of
// sub-folders from each shell folders. When the user expands a folder
// in the scope pane of the explorer, the explorer does following:
//  (1) binds to the folder (gets IShellFolder),
//  (2) enumerates its sub-folders by calling its EnumObjects member,
//  (3) calls its GetUIObjectOf member to get IExtractIcon interface
//     for each sub-folders.
//  In this case, the explorer uses only IExtractIcon::GetIconLocation
// member to get the location of the appropriate icon. An icon location
// always consists of a file name (typically DLL or EXE) and either an icon
// resource or an icon index.
//
//
// Case-2: Extracting an icon image from a file
//
//  It is used by the shell when it extracts an icon image
// from a file. When the shell is extracting an icon from a file,
// it does following:
//  (1) creates the icon extraction handler object (by getting its CLSID
//     under the {ProgID}\shell\ExtractIconHanler key and calling
//     CoCreateInstance requesting for IExtractIcon interface).
//  (2) Calls IExtractIcon::GetIconLocation.
//  (3) Then, calls IExtractIcon::ExtractIcon with the location/index pair.
//  (4) If (3) returns NOERROR, it uses the returned icon.
//  (5) Otherwise, it recursively calls this logic with new location
//     assuming that the location string contains a fully qualified path name.
//
//  From extension programmer's point of view, there are only two cases
// where they provide implementations of IExtractIcon:
//  Case-1) providing explorer extensions (i.e., IShellFolder).
//  Case-2) providing per-instance icons for some types of files.
//
// Because Case-1 is described above, we'll explain only Case-2 here.
//
// When the shell is about display an icon for a file, it does following:
//  (1) Finds its ProgID and ClassID.
//  (2) If the file has a ClassID, it gets the icon location string from the
//    "DefaultIcon" key under it. The string indicates either per-class
//    icon (e.g., "FOOBAR.DLL,2") or per-instance icon (e.g., "%1,1").
//  (3) If a per-instance icon is specified, the shell creates an icon
//    extraction handler object for it, and extracts the icon from it
//    (which is described above).
//
//  It is important to note that the shell calls IExtractIcon::GetIconLocation
// first, then calls IExtractIcon::Extract. Most application programs
// that support per-instance icons will probably store an icon location
// (DLL/EXE name and index/id) rather than an icon image in each file.
// In those cases, a programmer needs to implement only the GetIconLocation
// member and it Extract member simply returns S_FALSE. They need to
// implement Extract member only if they decided to store the icon images
// within files themselved or some other database (which is very rare).
//
//
//
// [Member functions]
//
//
// IExtractIcon::GetIconLocation
//
//  This function returns an icon location.
//
//  Parameters:
//   uFlags     [in]  -- Specifies if it is opened or not (GIL_OPENICON or 0)
//   szIconFile [out] -- Specifies the string buffer buffer for a location name.
//   cchMax     [in]  -- Specifies the size of szIconFile (almost always MAX_PATH)
//   piIndex    [out] -- Sepcifies the address of UINT for the index.
//   pwFlags    [out] -- Returns GIL_* flags
//  Returns:
//   NOERROR, if it returns a valid location; S_FALSE, if the shell use a
//   default icon.
//
//  Notes: The location may or may not be a path to a file. The caller can
//   not assume anything unless the subsequent Extract member call returns
//   S_FALSE.
//
//   if the returned location is not a path to a file, GIL_NOTFILENAME should
//   be set in the returned flags.
//
// IExtractIcon::Extract
//
//  This function extracts an icon image from a specified file.
//
//  Parameters:
//   pszFile [in] -- Specifies the icon location (typically a path to a file).
//   nIconIndex [in] -- Specifies the icon index.
//   phiconLarge [out] -- Specifies the HICON variable for large icon.
//   phiconSmall [out] -- Specifies the HICON variable for small icon.
//   nIconSize [in] -- Specifies the size icon required (size of large icon)
//                     LOWORD is the requested large icon size
//                     HIWORD is the requested small icon size
//  Returns:
//   NOERROR, if it extracted the from the file.
//   S_FALSE, if the caller should extract from the file specified in the
//           location.
//
//===========================================================================

// GetIconLocation() input flags

#define GIL_OPENICON     0x0001      // allows containers to specify an "open" look
#define GIL_FORSHELL     0x0002      // icon is to be displayed in a ShellFolder
#define GIL_ASYNC        0x0020      // this is an async extract, return E_ASYNC

// GetIconLocation() return flags

#define GIL_SIMULATEDOC  0x0001      // simulate this document icon for this
#define GIL_PERINSTANCE  0x0002      // icons from this class are per instance (each file has its own)
#define GIL_PERCLASS     0x0004      // icons from this class per class (shared for all files of this type)
#define GIL_NOTFILENAME  0x0008      // location is not a filename, must call ::ExtractIcon
#define GIL_DONTCACHE    0x0010      // this icon should not be cached

#undef  INTERFACE
#define INTERFACE   IExtractIconA

DECLARE_INTERFACE_(IExtractIconA, IUnknown)     // exic
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExtractIcon methods ***
    STDMETHOD(GetIconLocation)(THIS_
                         UINT   uFlags,
                         LPSTR  szIconFile,
                         UINT   cchMax,
                         int   * piIndex,
                         UINT  * pwFlags) PURE;

    STDMETHOD(Extract)(THIS_
                           LPCSTR pszFile,
                           UINT   nIconIndex,
                           HICON   *phiconLarge,
                           HICON   *phiconSmall,
                           UINT    nIconSize) PURE;
};

typedef IExtractIconA * LPEXTRACTICONA;

#undef  INTERFACE
#define INTERFACE   IExtractIconW

DECLARE_INTERFACE_(IExtractIconW, IUnknown)     // exic
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExtractIcon methods ***
    STDMETHOD(GetIconLocation)(THIS_
                         UINT   uFlags,
                         LPWSTR szIconFile,
                         UINT   cchMax,
                         int   * piIndex,
                         UINT  * pwFlags) PURE;

    STDMETHOD(Extract)(THIS_
                           LPCWSTR pszFile,
                           UINT   nIconIndex,
                           HICON   *phiconLarge,
                           HICON   *phiconSmall,
                           UINT    nIconSize) PURE;
};

typedef IExtractIconW * LPEXTRACTICONW;

#ifdef UNICODE
#define IExtractIcon        IExtractIconW
#define IExtractIconVtbl    IExtractIconWVtbl
#define LPEXTRACTICON       LPEXTRACTICONW
#else
#define IExtractIcon        IExtractIconA
#define IExtractIconVtbl    IExtractIconAVtbl
#define LPEXTRACTICON       LPEXTRACTICONA
#endif

//===========================================================================
//
// IShellIcon Interface
//
// used to get a icon index for a IShellFolder object.
//
// this interface can be implemented by a IShellFolder, as a quick way to
// return the icon for a object in the folder.
//
// a instance of this interface is only created once for the folder, unlike
// IExtractIcon witch is created once for each object.
//
// if a ShellFolder does not implement this interface, the standard
// GetUIObject(....IExtractIcon) method will be used to get a icon
// for all objects.
//
// the following standard imagelist indexs can be returned:
//
//      0   document (blank page) (not associated)
//      1   document (with stuff on the page)
//      2   application (exe, com, bat)
//      3   folder (plain)
//      4   folder (open)
//
// IShellIcon:GetIconOf(pidl, flags, lpIconIndex)
//
//      pidl            object to get icon for.
//      flags           GIL_* input flags (GIL_OPEN, ...)
//      lpIconIndex     place to return icon index.
//
//  returns:
//      NOERROR, if lpIconIndex contains the correct system imagelist index.
//      S_FALSE, if unable to get icon for this object, go through
//               GetUIObject, IExtractIcon, methods.
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellIcon

DECLARE_INTERFACE_(IShellIcon, IUnknown)      // shi
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellIcon methods ***
    STDMETHOD(GetIconOf)(THIS_ LPCITEMIDLIST pidl, UINT flags,
                    LPINT lpIconIndex) PURE;
};

typedef IShellIcon *LPSHELLICON;

//===========================================================================
//
// IShellIconOverlayIdentifier
//
// Used to identify a file as a member of the group of files that have this specific 
// icon overlay
//
// Users can create new IconOverlayIdentifiers and place them in the following registry
// location together with the Icon overlay image and their priority. 
// HKEY_LOCAL_MACHINE "Software\\Microsoft\\Windows\\CurrentVersion\\ShellIconOverlayIdentifiers"
// 
// The shell will enumerate through all IconOverlayIdentifiers at start, and prioritize 
// them according to internal rules, in case the internal rules don't apply, we use their 
// input priority
//
// IShellIconOverlayIdentifier:IsMemberOf(LPCWSTR pwszPath, DWORD dwAttrib)
//      pwszPath        full path of the file
//      dwAttrib        attribute of this file 
//
//  returns:
//      S_OK,    if the file is a member
//      S_FALSE, if the file is not a member
//      E_FAIL,  if the operation failed due to bad WIN32_FIND_DATA
//
// IShellIconOverlayIdentifier::GetOverlayInfo(LPWSTR pwszIconFile, int * pIndex, DWORD * dwFlags) PURE;
//      pszIconFile    the path of the icon file
//      pIndex         Depend on the flags, this could contain the IconIndex or the Sytem Imagelist Index
//      dwFlags        defined below
//
// IShellIconOverlayIdentifier::GetPriority(int * pIPriority) PURE;
//      pIPriority     the priority of this Overlay Identifier
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellIconOverlayIdentifier

DECLARE_INTERFACE_(IShellIconOverlayIdentifier, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellIconOverlayIdentifier methods ***
    STDMETHOD (IsMemberOf)(THIS_ LPCWSTR pwszPath, DWORD dwAttrib) PURE;  
    STDMETHOD (GetOverlayInfo)(THIS_ LPWSTR pwszIconFile, int cchMax, int * pIndex, DWORD * pdwFlags) PURE;  
    STDMETHOD (GetPriority)(THIS_ int * pIPriority) PURE;
};

#define ISIOI_ICONFILE            0x00000001          // path is returned through pwszIconFile
#define ISIOI_ICONINDEX           0x00000002          // icon index in pwszIconFile is returned through pIndex 
#define ISIOI_SYSIMAGELISTINDEX   0x00000004          // system imagelist icon index is returned through pIndex


//===========================================================================
//
// IShellIconOverlay
//
// Used to return the icon overlay index or its icon index for an IShellFolder object, 
// this is always implemented with IShellFolder 
//
// IShellIconOverlay:GetOverlayIndex(LPCITEMIDLIST pidl, DWORD * pdwIndex)
//      pidl            object to identify icon overlay for.
//      pdwIndex        the Overlay Index in the system image list
//
// IShellIconOverlay:GetOverlayIconIndex(LPCITEMIDLIST pidl, DWORD * pdwIndex)
//      pdwIconIndex    the Overlay Icon index in the system image list 
// This method is only used for those who are interested in seeing the real bits 
// of the Overlay Icon
//
//  returns:
//      S_OK,  if the index of an Overlay is found
//      S_FALSE, if no Overlay exists for this file
//      E_FAIL, if pidl is bad 
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellIconOverlay

DECLARE_INTERFACE_(IShellIconOverlay, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellIconOverlay methods ***
    STDMETHOD(GetOverlayIndex)(THIS_ LPCITEMIDLIST pidl, int * pIndex) PURE;
    STDMETHOD(GetOverlayIconIndex)(THIS_ LPCITEMIDLIST pidl, int * pIconIndex) PURE;
};

//===========================================================================
//
// IShellLink Interface
//
//===========================================================================

#ifdef UNICODE
#define IShellLink      IShellLinkW
#define IShellLinkVtbl  IShellLinkWVtbl
#else
#define IShellLink      IShellLinkA
#define IShellLinkVtbl  IShellLinkAVtbl
#endif

// IShellLink::Resolve fFlags
typedef enum {
    SLR_NO_UI           = 0x0001,
    SLR_ANY_MATCH       = 0x0002,
    SLR_UPDATE          = 0x0004,
    SLR_NOUPDATE        = 0x0008,
} SLR_FLAGS;

// IShellLink::GetPath fFlags
typedef enum {
    SLGP_SHORTPATH      = 0x0001,
    SLGP_UNCPRIORITY    = 0x0002,
    SLGP_RAWPATH        = 0x0004,
} SLGP_FLAGS;

#undef  INTERFACE
#define INTERFACE   IShellLinkA

DECLARE_INTERFACE_(IShellLinkA, IUnknown)       // sl
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellLink methods ***
    STDMETHOD(GetPath)(THIS_ LPSTR pszFile, int cchMaxPath, WIN32_FIND_DATAA *pfd, DWORD fFlags) PURE;

    STDMETHOD(GetIDList)(THIS_ LPITEMIDLIST * ppidl) PURE;
    STDMETHOD(SetIDList)(THIS_ LPCITEMIDLIST pidl) PURE;

    STDMETHOD(GetDescription)(THIS_ LPSTR pszName, int cchMaxName) PURE;
    STDMETHOD(SetDescription)(THIS_ LPCSTR pszName) PURE;

    STDMETHOD(GetWorkingDirectory)(THIS_ LPSTR pszDir, int cchMaxPath) PURE;
    STDMETHOD(SetWorkingDirectory)(THIS_ LPCSTR pszDir) PURE;

    STDMETHOD(GetArguments)(THIS_ LPSTR pszArgs, int cchMaxPath) PURE;
    STDMETHOD(SetArguments)(THIS_ LPCSTR pszArgs) PURE;

    STDMETHOD(GetHotkey)(THIS_ WORD *pwHotkey) PURE;
    STDMETHOD(SetHotkey)(THIS_ WORD wHotkey) PURE;

    STDMETHOD(GetShowCmd)(THIS_ int *piShowCmd) PURE;
    STDMETHOD(SetShowCmd)(THIS_ int iShowCmd) PURE;

    STDMETHOD(GetIconLocation)(THIS_ LPSTR pszIconPath, int cchIconPath, int *piIcon) PURE;
    STDMETHOD(SetIconLocation)(THIS_ LPCSTR pszIconPath, int iIcon) PURE;

    STDMETHOD(SetRelativePath)(THIS_ LPCSTR pszPathRel, DWORD dwReserved) PURE;

    STDMETHOD(Resolve)(THIS_ HWND hwnd, DWORD fFlags) PURE;

    STDMETHOD(SetPath)(THIS_ LPCSTR pszFile) PURE;
};

#undef  INTERFACE
#define INTERFACE   IShellLinkW

DECLARE_INTERFACE_(IShellLinkW, IUnknown)       // sl
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellLink methods ***
    STDMETHOD(GetPath)(THIS_ LPWSTR pszFile, int cchMaxPath, WIN32_FIND_DATAW *pfd, DWORD fFlags) PURE;

    STDMETHOD(GetIDList)(THIS_ LPITEMIDLIST * ppidl) PURE;
    STDMETHOD(SetIDList)(THIS_ LPCITEMIDLIST pidl) PURE;

    STDMETHOD(GetDescription)(THIS_ LPWSTR pszName, int cchMaxName) PURE;
    STDMETHOD(SetDescription)(THIS_ LPCWSTR pszName) PURE;

    STDMETHOD(GetWorkingDirectory)(THIS_ LPWSTR pszDir, int cchMaxPath) PURE;
    STDMETHOD(SetWorkingDirectory)(THIS_ LPCWSTR pszDir) PURE;

    STDMETHOD(GetArguments)(THIS_ LPWSTR pszArgs, int cchMaxPath) PURE;
    STDMETHOD(SetArguments)(THIS_ LPCWSTR pszArgs) PURE;

    STDMETHOD(GetHotkey)(THIS_ WORD *pwHotkey) PURE;
    STDMETHOD(SetHotkey)(THIS_ WORD wHotkey) PURE;

    STDMETHOD(GetShowCmd)(THIS_ int *piShowCmd) PURE;
    STDMETHOD(SetShowCmd)(THIS_ int iShowCmd) PURE;

    STDMETHOD(GetIconLocation)(THIS_ LPWSTR pszIconPath, int cchIconPath, int *piIcon) PURE;
    STDMETHOD(SetIconLocation)(THIS_ LPCWSTR pszIconPath, int iIcon) PURE;

    STDMETHOD(SetRelativePath)(THIS_ LPCWSTR pszPathRel, DWORD dwReserved) PURE;

    STDMETHOD(Resolve)(THIS_ HWND hwnd, DWORD fFlags) PURE;

    STDMETHOD(SetPath)(THIS_ LPCWSTR pszFile) PURE;
};


#ifdef _INC_SHELLAPI    /* for LPSHELLEXECUTEINFO */
//===========================================================================
//
// IShellExecuteHook Interface
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellExecuteHookA

DECLARE_INTERFACE_(IShellExecuteHookA, IUnknown) // shexhk
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IShellExecuteHookA methods ***
    STDMETHOD(Execute)(THIS_ LPSHELLEXECUTEINFOA pei) PURE;
};

#undef  INTERFACE
#define INTERFACE   IShellExecuteHookW

DECLARE_INTERFACE_(IShellExecuteHookW, IUnknown) // shexhk
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IShellExecuteHookW methods ***
    STDMETHOD(Execute)(THIS_ LPSHELLEXECUTEINFOW pei) PURE;
};

#ifdef UNICODE
#define IShellExecuteHook       IShellExecuteHookW
#define IShellExecuteHookVtbl   IShellExecuteHookWVtbl
#else
#define IShellExecuteHook       IShellExecuteHookA
#define IShellExecuteHookVtbl   IShellExecuteHookAVtbl
#endif
#endif

//===========================================================================
//
// IURLSearchHook Interface
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IURLSearchHook

DECLARE_INTERFACE_(IURLSearchHook, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IURLSearchHook methods ***
    STDMETHOD(Translate)(THIS_ LPWSTR lpwszSearchURL, DWORD cchBufferSize) PURE;
};

//===========================================================================
//
// INewShortcutHook Interface
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   INewShortcutHookA

DECLARE_INTERFACE_(INewShortcutHookA, IUnknown) // nshhk
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** INewShortcutHook methods ***
    STDMETHOD(SetReferent)(THIS_ LPCSTR pcszReferent, HWND hwnd) PURE;
    STDMETHOD(GetReferent)(THIS_ LPSTR pszReferent, int cchReferent) PURE;
    STDMETHOD(SetFolder)(THIS_ LPCSTR pcszFolder) PURE;
    STDMETHOD(GetFolder)(THIS_ LPSTR pszFolder, int cchFolder) PURE;
    STDMETHOD(GetName)(THIS_ LPSTR pszName, int cchName) PURE;
    STDMETHOD(GetExtension)(THIS_ LPSTR pszExtension, int cchExtension) PURE;
};

#undef  INTERFACE
#define INTERFACE   INewShortcutHookW

DECLARE_INTERFACE_(INewShortcutHookW, IUnknown) // nshhk
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** INewShortcutHook methods ***
    STDMETHOD(SetReferent)(THIS_ LPCWSTR pcszReferent, HWND hwnd) PURE;
    STDMETHOD(GetReferent)(THIS_ LPWSTR pszReferent, int cchReferent) PURE;
    STDMETHOD(SetFolder)(THIS_ LPCWSTR pcszFolder) PURE;
    STDMETHOD(GetFolder)(THIS_ LPWSTR pszFolder, int cchFolder) PURE;
    STDMETHOD(GetName)(THIS_ LPWSTR pszName, int cchName) PURE;
    STDMETHOD(GetExtension)(THIS_ LPWSTR pszExtension, int cchExtension) PURE;
};

#ifdef UNICODE
#define INewShortcutHook        INewShortcutHookW
#define INewShortcutHookVtbl    INewShortcutHookWVtbl
#else
#define INewShortcutHook        INewShortcutHookA
#define INewShortcutHookVtbl    INewShortcutHookAVtbl
#endif

//===========================================================================
//
// ICopyHook Interface
//
//  The copy hook is called whenever file system directories are
//  copy/moved/deleted/renamed via the shell.  It is also called by the shell
//  on changes of status of printers.
//
//  Clients register their id under STRREG_SHEX_COPYHOOK for file system hooks
//  and STRREG_SHEx_PRNCOPYHOOK for printer hooks.
//  the CopyCallback is called prior to the action, so the hook has the chance
//  to allow, deny or cancel the operation by returning the falues:
//     IDYES  -  means allow the operation
//     IDNO   -  means disallow the operation on this file, but continue with
//              any other operations (eg. batch copy)
//     IDCANCEL - means disallow the current operation and cancel any pending
//              operations
//
//   arguments to the CopyCallback
//      hwnd - window to use for any UI
//      wFunc - what operation is being done
//      wFlags - and flags (FOF_*) set in the initial call to the file operation
//      pszSrcFile - name of the source file
//      dwSrcAttribs - file attributes of the source file
//      pszDestFile - name of the destiation file (for move and renames)
//      dwDestAttribs - file attributes of the destination file
//
//
//===========================================================================

#ifndef FO_MOVE //these need to be kept in sync with the ones in shellapi.h

// file operations

#define FO_MOVE           0x0001
#define FO_COPY           0x0002
#define FO_DELETE         0x0003
#define FO_RENAME         0x0004

#define FOF_MULTIDESTFILES         0x0001
#define FOF_CONFIRMMOUSE           0x0002
#define FOF_SILENT                 0x0004  // don't create progress/report
#define FOF_RENAMEONCOLLISION      0x0008
#define FOF_NOCONFIRMATION         0x0010  // Don't prompt the user.
#define FOF_WANTMAPPINGHANDLE      0x0020  // Fill in SHFILEOPSTRUCT.hNameMappings
                                      // Must be freed using SHFreeNameMappings
#define FOF_ALLOWUNDO              0x0040
#define FOF_FILESONLY              0x0080  // on *.*, do only files
#define FOF_SIMPLEPROGRESS         0x0100  // means don't show names of files
#define FOF_NOCONFIRMMKDIR         0x0200  // don't confirm making any needed dirs
#define FOF_NOERRORUI              0x0400  // don't put up error UI
#define FOF_NOCOPYSECURITYATTRIBS  0x0800  // dont copy NT file Security Attributes

typedef UINT FILEOP_FLAGS;

// printer operations

#define PO_DELETE       0x0013  // printer is being deleted
#define PO_RENAME       0x0014  // printer is being renamed
#define PO_PORTCHANGE   0x0020  // port this printer connected to is being changed
                                // if this id is set, the strings received by
                                // the copyhook are a doubly-null terminated
                                // list of strings.  The first is the printer
                                // name and the second is the printer port.
#define PO_REN_PORT     0x0034  // PO_RENAME and PO_PORTCHANGE at same time.

// no POF_ flags currently defined

typedef UINT PRINTEROP_FLAGS;

#endif // FO_MOVE

#undef  INTERFACE
#define INTERFACE   ICopyHookA

DECLARE_INTERFACE_(ICopyHookA, IUnknown)        // sl
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ICopyHook methods ***
    STDMETHOD_(UINT,CopyCallback) (THIS_ HWND hwnd, UINT wFunc, UINT wFlags, LPCSTR pszSrcFile, DWORD dwSrcAttribs,
                                   LPCSTR pszDestFile, DWORD dwDestAttribs) PURE;
};

typedef ICopyHookA *    LPCOPYHOOKA;

#undef  INTERFACE
#define INTERFACE   ICopyHookW

DECLARE_INTERFACE_(ICopyHookW, IUnknown)        // sl
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ICopyHook methods ***
    STDMETHOD_(UINT,CopyCallback) (THIS_ HWND hwnd, UINT wFunc, UINT wFlags, LPCWSTR pszSrcFile, DWORD dwSrcAttribs,
                                   LPCWSTR pszDestFile, DWORD dwDestAttribs) PURE;
};

typedef ICopyHookW *    LPCOPYHOOKW;

#ifdef UNICODE
#define ICopyHook       ICopyHookW
#define ICopyHookVtbl   ICopyHookWVtbl
#define LPCOPYHOOK      LPCOPYHOOKW
#else
#define ICopyHook       ICopyHookA
#define ICopyHookVtbl   ICopyHookAVtbl
#define LPCOPYHOOK      LPCOPYHOOKA
#endif

//===========================================================================
//
// IFileViewerSite Interface
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IFileViewerSite

DECLARE_INTERFACE_(IFileViewerSite, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IFileViewerSite methods ***
    STDMETHOD(SetPinnedWindow) (THIS_ HWND hwnd) PURE;
    STDMETHOD(GetPinnedWindow) (THIS_ HWND *phwnd) PURE;
};

typedef IFileViewerSite * LPFILEVIEWERSITE;


//===========================================================================
//
// IFileViewer Interface
//
// Implemented in a FileViewer component object.  Used to tell a
// FileViewer to PrintTo or to view, the latter happening though
// ShowInitialize and Show.  The filename is always given to the
// viewer through IPersistFile.
//
//===========================================================================

typedef struct
{
    // Stuff passed into viewer (in)
    DWORD cbSize;           // Size of structure for future expansion...
    HWND hwndOwner;         // who is the owner window.
    int iShow;              // The show command

    // Passed in and updated  (in/Out)
    DWORD dwFlags;          // flags
    RECT rect;              // Where to create the window may have defaults
    LPUNKNOWN punkRel;      // Relese this interface when window is visible

    // Stuff that might be returned from viewer (out)
    OLECHAR strNewFile[MAX_PATH];   // New File to view.

} FVSHOWINFO, *LPFVSHOWINFO;

    // Define File View Show Info Flags.
#define FVSIF_RECT      0x00000001      // The rect variable has valid data.
#define FVSIF_PINNED    0x00000002      // We should Initialize pinned

#define FVSIF_NEWFAILED 0x08000000      // The new file passed back failed
                                        // to be viewed.

#define FVSIF_NEWFILE   0x80000000      // A new file to view has been returned
#define FVSIF_CANVIEWIT 0x40000000      // The viewer can view it.

#undef  INTERFACE
#define INTERFACE   IFileViewerA

DECLARE_INTERFACE(IFileViewerA)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IFileViewer methods ***
    STDMETHOD(ShowInitialize) (THIS_ LPFILEVIEWERSITE lpfsi) PURE;
    STDMETHOD(Show) (THIS_ LPFVSHOWINFO pvsi) PURE;
    STDMETHOD(PrintTo) (THIS_ LPSTR pszDriver, BOOL fSuppressUI) PURE;
};

typedef IFileViewerA * LPFILEVIEWERA;

#undef  INTERFACE
#define INTERFACE   IFileViewerW

DECLARE_INTERFACE(IFileViewerW)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IFileViewer methods ***
    STDMETHOD(ShowInitialize) (THIS_ LPFILEVIEWERSITE lpfsi) PURE;
    STDMETHOD(Show) (THIS_ LPFVSHOWINFO pvsi) PURE;
    STDMETHOD(PrintTo) (THIS_ LPWSTR pszDriver, BOOL fSuppressUI) PURE;
};

typedef IFileViewerW * LPFILEVIEWERW;

#ifdef UNICODE
#define IFileViewer IFileViewerW
#define LPFILEVIEWER LPFILEVIEWERW
#else
#define IFileViewer IFileViewerA
#define LPFILEVIEWER LPFILEVIEWERA
#endif



//==========================================================================
//
// IShellBrowser/IShellView/IShellFolder interface
//
//  These three interfaces are used when the shell communicates with
// name space extensions. The shell (explorer) provides IShellBrowser
// interface, and extensions implements IShellFolder and IShellView
// interfaces.
//
//==========================================================================


//--------------------------------------------------------------------------
//
// Command/menuitem IDs
//
//  The explorer dispatches WM_COMMAND messages based on the range of
// command/menuitem IDs. All the IDs of menuitems that the view (right
// pane) inserts must be in FCIDM_SHVIEWFIRST/LAST (otherwise, the explorer
// won't dispatch them). The view should not deal with any menuitems
// in FCIDM_BROWSERFIRST/LAST (otherwise, it won't work with the future
// version of the shell).
//
//  FCIDM_SHVIEWFIRST/LAST      for the right pane (IShellView)
//  FCIDM_BROWSERFIRST/LAST     for the explorer frame (IShellBrowser)
//  FCIDM_GLOBAL/LAST           for the explorer's submenu IDs
//
//--------------------------------------------------------------------------

#define FCIDM_SHVIEWFIRST           0x0000
#define FCIDM_SHVIEWLAST            0x7fff
#define FCIDM_BROWSERFIRST          0xa000
#define FCIDM_BROWSERLAST           0xbf00
#define FCIDM_GLOBALFIRST           0x8000
#define FCIDM_GLOBALLAST            0x9fff

//
// Global submenu IDs and separator IDs
//
#define FCIDM_MENU_FILE             (FCIDM_GLOBALFIRST+0x0000)
#define FCIDM_MENU_EDIT             (FCIDM_GLOBALFIRST+0x0040)
#define FCIDM_MENU_VIEW             (FCIDM_GLOBALFIRST+0x0080)
#define FCIDM_MENU_VIEW_SEP_OPTIONS (FCIDM_GLOBALFIRST+0x0081)
#define FCIDM_MENU_TOOLS            (FCIDM_GLOBALFIRST+0x00c0)
#define FCIDM_MENU_TOOLS_SEP_GOTO   (FCIDM_GLOBALFIRST+0x00c1)
#define FCIDM_MENU_HELP             (FCIDM_GLOBALFIRST+0x0100)
#define FCIDM_MENU_FIND             (FCIDM_GLOBALFIRST+0x0140)
#define FCIDM_MENU_EXPLORE          (FCIDM_GLOBALFIRST+0x0150)
#define FCIDM_MENU_FAVORITES        (FCIDM_GLOBALFIRST+0x0170)

//--------------------------------------------------------------------------
// control IDs known to the view
//--------------------------------------------------------------------------

#define FCIDM_TOOLBAR      (FCIDM_BROWSERFIRST + 0)
#define FCIDM_STATUS       (FCIDM_BROWSERFIRST + 1)

#if (_WIN32_IE >= 0x0400)
//--------------------------------------------------------------------------
//
// The resource id of the offline cursor
// This cursor is avaialble in shdocvw.dll 
#define IDC_OFFLINE_HAND        103
//
//--------------------------------------------------------------------------
#endif

//--------------------------------------------------------------------------
//
// FOLDERSETTINGS
//
//  FOLDERSETTINGS is a data structure that explorer passes from one folder
// view to another, when the user is browsing. It calls ISV::GetCurrentInfo
// member to get the current settings and pass it to ISV::CreateViewWindow
// to allow the next folder view "inherit" it. These settings assumes a
// particular UI (which the shell's folder view has), and shell extensions
// may or may not use those settings.
//
//--------------------------------------------------------------------------

typedef LPBYTE LPVIEWSETTINGS;

// NB Bitfields.
// FWF_DESKTOP implies FWF_TRANSPARENT/NOCLIENTEDGE/NOSCROLL
typedef enum
    {
    FWF_AUTOARRANGE =       0x0001,
    FWF_ABBREVIATEDNAMES =  0x0002,
    FWF_SNAPTOGRID =        0x0004,
    FWF_OWNERDATA =         0x0008,
    FWF_BESTFITWINDOW =     0x0010,
    FWF_DESKTOP =           0x0020,
    FWF_SINGLESEL =         0x0040,
    FWF_NOSUBFOLDERS =      0x0080,
    FWF_TRANSPARENT  =      0x0100,
    FWF_NOCLIENTEDGE =      0x0200,
    FWF_NOSCROLL     =      0x0400,
    FWF_ALIGNLEFT    =      0x0800,
    FWF_NOICONS      =      0x1000,
    FWF_SINGLECLICKACTIVATE=0x8000  // TEMPORARY -- NO UI FOR THIS
    } FOLDERFLAGS;

typedef enum
    {
    FVM_ICON =              1,
    FVM_SMALLICON =         2,
    FVM_LIST =              3,
    FVM_DETAILS =           4,
    } FOLDERVIEWMODE;

typedef struct
    {
    UINT ViewMode;       // View mode (FOLDERVIEWMODE values)
    UINT fFlags;         // View options (FOLDERFLAGS bits)
    } FOLDERSETTINGS, *LPFOLDERSETTINGS;

typedef const FOLDERSETTINGS * LPCFOLDERSETTINGS;

//--------------------------------------------------------------------------
//
// Interface:   IShellBrowser
//
//  IShellBrowser interface is the interface that is provided by the shell
// explorer/folder frame window. When it creates the "contents pane" of
// a shell folder (which provides IShellFolder interface), it calls its
// CreateViewObject member function to create an IShellView object. Then,
// it calls its CreateViewWindow member to create the "contents pane"
// window. The pointer to the IShellBrowser interface is passed to
// the IShellView object as a parameter to this CreateViewWindow member
// function call.
//
//    +--------------------------+  <-- Explorer window
//    | [] Explorer              |
//    |--------------------------+       IShellBrowser
//    | File Edit View ..        |
//    |--------------------------|
//    |        |                 |
//    |        |              <-------- Content pane
//    |        |                 |
//    |        |                 |       IShellView
//    |        |                 |
//    |        |                 |
//    +--------------------------+
//
//
//
// [Member functions]
//
//
// IShellBrowser::GetWindow(phwnd)
//
//   Inherited from IOleWindow::GetWindow.
//
//
// IShellBrowser::ContextSensitiveHelp(fEnterMode)
//
//   Inherited from IOleWindow::ContextSensitiveHelp.
//
//
// IShellBrowser::InsertMenusSB(hmenuShared, lpMenuWidths)
//
//   Similar to the IOleInPlaceFrame::InsertMenus. The explorer will put
//  "File" and "Edit" pulldown in the File menu group, "View" and "Tools"
//  in the Container menu group and "Help" in the Window menu group. Each
//  pulldown menu will have a uniqu ID, FCIDM_MENU_FILE/EDIT/VIEW/TOOLS/HELP.
//  The view is allowed to insert menuitems into those sub-menus by those
//  IDs must be between FCIDM_SHVIEWFIRST and FCIDM_SHVIEWLAST.
//
//
// IShellBrowser::SetMenuSB(hmenuShared, holemenu, hwndActiveObject)
//
//   Similar to the IOleInPlaceFrame::SetMenu. The explorer ignores the
//  holemenu parameter (reserved for future enhancement)  and performs
//  menu-dispatch based on the menuitem IDs (see the description above).
//  It is important to note that the explorer will add different
//  set of menuitems depending on whether the view has a focus or not.
//  Therefore, it is very important to call ISB::OnViewWindowActivate
//  whenever the view window (or its children) gets the focus.
//
//
// IShellBrowser::RemoveMenusSB(hmenuShared)
//
//   Same as the IOleInPlaceFrame::RemoveMenus.
//
//
// IShellBrowser::SetStatusTextSB(lpszStatusText)
//
//   Same as the IOleInPlaceFrame::SetStatusText. It is also possible to
//  send messages directly to the status window via SendControlMsg.
//
//
// IShellBrowser::EnableModelessSB(fEnable)
//
//   Same as the IOleInPlaceFrame::EnableModeless.
//
//
// IShellBrowser::TranslateAcceleratorSB(lpmsg, wID)
//
//   Same as the IOleInPlaceFrame::TranslateAccelerator, but will be
//  never called because we don't support EXEs (i.e., the explorer has
//  the message loop). This member function is defined here for possible
//  future enhancement.
//
//
// IShellBrowser::BrowseObject(pidl, wFlags)
//
//   The view calls this member to let shell explorer browse to another
//  folder. The pidl and wFlags specifies the folder to be browsed.
//
//  Following three flags specifies whether it creates another window or not.
//   SBSP_SAMEBROWSER  -- Browse to another folder with the same window.
//   SBSP_NEWBROWSER   -- Creates another window for the specified folder.
//   SBSP_DEFBROWSER   -- Default behavior (respects the view option).
//
//  Following three flags specifies open, explore, or default mode. These   .
//  are ignored if SBSP_SAMEBROWSER or (SBSP_DEFBROWSER && (single window   .
//  browser || explorer)).                                                  .
//   SBSP_OPENMODE     -- Use a normal folder window
//   SBSP_EXPLOREMODE  -- Use an explorer window
//   SBSP_DEFMODE      -- Use the same as the current window
//
//  Following three flags specifies the pidl.
//   SBSP_ABSOLUTE -- pidl is an absolute pidl (relative from desktop)
//   SBSP_RELATIVE -- pidl is relative from the current folder.
//   SBSP_PARENT   -- Browse the parent folder (ignores the pidl)
//   SBSP_NAVIGATEBACK    -- Navigate back (ignores the pidl)
//   SBSP_NAVIGATEFORWARD -- Navigate forward (ignores the pidl)
//
//  Following two flags control history manipulation as result of navigate
//   SBSP_WRITENOHISTORY -- write no history (shell folder) entry
//   SBSP_NOAUTOSELECT -- suppress selection in history pane
//
// IShellBrowser::GetViewStateStream(grfMode, ppstm)
//
//   The browser returns an IStream interface as the storage for view
//  specific state information.
//
//   grfMode -- Specifies the read/write access (STGM_READ/WRITE/READWRITE)
//   ppstm   -- Specifies the LPSTREAM variable to be filled.
//
//
// IShellBrowser::GetControlWindow(id, phwnd)
//
//   The shell view may call this member function to get the window handle
//  of Explorer controls (toolbar or status winodw -- FCW_TOOLBAR or
//  FCW_STATUS).
//
//
// IShellBrowser::SendControlMsg(id, uMsg, wParam, lParam, pret)
//
//   The shell view calls this member function to send control messages to
//  one of Explorer controls (toolbar or status window -- FCW_TOOLBAR or
//  FCW_STATUS).
//
//
// IShellBrowser::QueryActiveShellView(IShellView * ppshv)
//
//   This member returns currently activated (displayed) shellview object.
//  A shellview never need to call this member function.
//
//
// IShellBrowser::OnViewWindowActive(pshv)
//
//   The shell view window calls this member function when the view window
//  (or one of its children) got the focus. It MUST call this member before
//  calling IShellBrowser::InsertMenus, because it will insert different
//  set of menu items depending on whether the view has the focus or not.
//
//
// IShellBrowser::SetToolbarItems(lpButtons, nButtons, uFlags)
//
//   The view calls this function to add toolbar items to the exporer's
//  toolbar. "lpButtons" and "nButtons" specifies the array of toolbar
//  items. "uFlags" must be one of FCT_MERGE, FCT_CONFIGABLE, FCT_ADDTOEND.
//
//-------------------------------------------------------------------------

//
// Values for wFlags parameter of ISB::BrowseObject() member.
//
#define SBSP_DEFBROWSER         0x0000
#define SBSP_SAMEBROWSER        0x0001
#define SBSP_NEWBROWSER         0x0002

#define SBSP_DEFMODE            0x0000
#define SBSP_OPENMODE           0x0010
#define SBSP_EXPLOREMODE        0x0020

#define SBSP_ABSOLUTE           0x0000
#define SBSP_RELATIVE           0x1000
#define SBSP_PARENT             0x2000
#define SBSP_NAVIGATEBACK       0x4000
#define SBSP_NAVIGATEFORWARD    0x8000

#define SBSP_ALLOW_AUTONAVIGATE 0x10000

#define SBSP_INITIATEDBYHLINKFRAME        0x80000000
#define SBSP_REDIRECT                     0x40000000

#define SBSP_WRITENOHISTORY     0x08000000
#define SBSP_NOAUTOSELECT       0x04000000


//
// Values for id parameter of ISB::GetWindow/SendControlMsg members.
//
// WARNING:
//  Any shell extensions which sends messages to those control windows
// might not work in the future version of windows. If you really need
// to send messages to them, (1) don't assume that those control window
// always exist (i.e. GetControlWindow may fail) and (2) verify the window
// class of the window before sending any messages.
//
#define FCW_STATUS      0x0001
#define FCW_TOOLBAR     0x0002
#define FCW_TREE        0x0003
#define FCW_INTERNETBAR 0x0006
#define FCW_PROGRESS    0x0008

#if (_WIN32_IE >= 0x0400)
#endif

//
// Values for uFlags paremeter of ISB::SetToolbarItems member.
//
#define FCT_MERGE       0x0001
#define FCT_CONFIGABLE  0x0002
#define FCT_ADDTOEND    0x0004


#undef  INTERFACE
#define INTERFACE   IShellBrowser

DECLARE_INTERFACE_(IShellBrowser, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IShellBrowser methods *** (same as IOleInPlaceFrame)
    STDMETHOD(InsertMenusSB) (THIS_ HMENU hmenuShared,
                                LPOLEMENUGROUPWIDTHS lpMenuWidths) PURE;
    STDMETHOD(SetMenuSB) (THIS_ HMENU hmenuShared, HOLEMENU holemenuReserved,
                HWND hwndActiveObject) PURE;
    STDMETHOD(RemoveMenusSB) (THIS_ HMENU hmenuShared) PURE;
    STDMETHOD(SetStatusTextSB) (THIS_ LPCOLESTR lpszStatusText) PURE;
    STDMETHOD(EnableModelessSB) (THIS_ BOOL fEnable) PURE;
    STDMETHOD(TranslateAcceleratorSB) (THIS_ LPMSG lpmsg, WORD wID) PURE;

    // *** IShellBrowser methods ***
    STDMETHOD(BrowseObject)(THIS_ LPCITEMIDLIST pidl, UINT wFlags) PURE;
    STDMETHOD(GetViewStateStream)(THIS_ DWORD grfMode,
                LPSTREAM  *ppStrm) PURE;
    STDMETHOD(GetControlWindow)(THIS_ UINT id, HWND * lphwnd) PURE;
    STDMETHOD(SendControlMsg)(THIS_ UINT id, UINT uMsg, WPARAM wParam,
                LPARAM lParam, LRESULT * pret) PURE;
    STDMETHOD(QueryActiveShellView)(THIS_ struct IShellView ** ppshv) PURE;
    STDMETHOD(OnViewWindowActive)(THIS_ struct IShellView * ppshv) PURE;
    STDMETHOD(SetToolbarItems)(THIS_ LPTBBUTTON lpButtons, UINT nButtons,
                UINT uFlags) PURE;
};
#define __IShellBrowser_INTERFACE_DEFINED__

typedef IShellBrowser * LPSHELLBROWSER;

enum {
    SBSC_HIDE = 0,
    SBSC_SHOW = 1,
    SBSC_TOGGLE = 2,
    SBSC_QUERY =  3
};

enum {
        SBO_DEFAULT = 0 ,
        SBO_NOBROWSERPAGES = 1
};


#if (_WIN32_IE >= 0x0400)
#endif

//-------------------------------------------------------------------------
// ICommDlgBrowser interface
//
//  ICommDlgBrowser interface is the interface that is provided by the new
// common dialog window to hook and modify the behavior of IShellView.  When
// a default view is created, it queries its parent IShellBrowser for the
// ICommDlgBrowser interface.  If supported, it calls out to that interface
// in several cases that need to behave differently in a dialog.
//
// Member functions:
//
//  ICommDlgBrowser::OnDefaultCommand()
//    Called when the user double-clicks in the view or presses Enter.  The
//   browser should return S_OK if it processed the action itself, S_FALSE
//   to let the view perform the default action.
//
//  ICommDlgBrowser::OnStateChange(ULONG uChange)
//    Called when some states in the view change.  'uChange' is one of the
//   CDBOSC_* values.  This call is made after the state (selection, focus,
//   etc) has changed.  There is no return value.
//
//  ICommDlgBrowser::IncludeObject(LPCITEMIDLIST pidl)
//    Called when the view is enumerating objects.  'pidl' is a relative
//   IDLIST.  The browser should return S_OK to include the object in the
//   view, S_FALSE to hide it
//
//-------------------------------------------------------------------------

#define CDBOSC_SETFOCUS     0x00000000
#define CDBOSC_KILLFOCUS    0x00000001
#define CDBOSC_SELCHANGE    0x00000002
#define CDBOSC_RENAME       0x00000003

#undef  INTERFACE
#define INTERFACE   ICommDlgBrowser

DECLARE_INTERFACE_(ICommDlgBrowser, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ICommDlgBrowser methods ***
    STDMETHOD(OnDefaultCommand) (THIS_ struct IShellView * ppshv) PURE;
    STDMETHOD(OnStateChange) (THIS_ struct IShellView * ppshv,
                ULONG uChange) PURE;
    STDMETHOD(IncludeObject) (THIS_ struct IShellView * ppshv,
                LPCITEMIDLIST pidl) PURE;
};

typedef ICommDlgBrowser * LPCOMMDLGBROWSER;


//==========================================================================
//
// Interface:   IShellView
//
// IShellView::GetWindow(phwnd)
//
//   Inherited from IOleWindow::GetWindow.
//
//
// IShellView::ContextSensitiveHelp(fEnterMode)
//
//   Inherited from IOleWindow::ContextSensitiveHelp.
//
//
// IShellView::TranslateAccelerator(lpmsg)
//
//   Similar to IOleInPlaceActiveObject::TranlateAccelerator. The explorer
//  calls this function BEFORE any other translation. Returning S_OK
//  indicates that the message was translated (eaten) and should not be
//  translated or dispatched by the explorer.
//
//
// IShellView::EnableModeless(fEnable)
//   Similar to IOleInPlaceActiveObject::EnableModeless.
//
//
// IShellView::UIActivate(uState)
//
//   The explorer calls this member function whenever the activation
//  state of the view window is changed by a certain event that is
//  NOT caused by the shell view itself.
//
//   SVUIA_DEACTIVATE will be passed when the explorer is about to
//  destroy the shell view window; the shell view is supposed to remove
//  all the extended UIs (typically merged menu and modeless popup windows).
//
//   SVUIA_ACTIVATE_NOFOCUS will be passsed when the shell view is losing
//  the input focus or the shell view has been just created without the
//  input focus; the shell view is supposed to set menuitems appropriate
//  for non-focused state (no selection specific items should be added).
//
//   SVUIA_ACTIVATE_FOCUS will be passed when the explorer has just
//  created the view window with the input focus; the shell view is
//  supposed to set menuitems appropriate for focused state.
//
//   SVUIA_INPLACEACTIVATE(new) will be passed when the shell view is opened
//  within an ActiveX control, which is not a UI active. In this case,
//  the shell view should not merge menus or put toolbas. To be compatible
//  with Win95 client, we don't pass this value unless the view supports
//  IShellView2.
//
//   The shell view should not change focus within this member function.
//  The shell view should not hook the WM_KILLFOCUS message to remerge
//  menuitems. However, the shell view typically hook the WM_SETFOCUS
//  message, and re-merge the menu after calling IShellBrowser::
//  OnViewWindowActivated.
//
//
// IShellView::Refresh()
//
//   The explorer calls this member when the view needs to refresh its
//  contents (such as when the user hits F5 key).
//
//
// IShellView::CreateViewWindow
//
//   This member creates the view window (right-pane of the explorer or the
//  client window of the folder window).
//
//
// IShellView::DestroyViewWindow
//
//   This member destroys the view window.
//
//
// IShellView::GetCurrentInfo
//
//   This member returns the folder settings.
//
//
// IShellView::AddPropertySHeetPages
//
//   The explorer calls this member when it is opening the option property
//  sheet. This allows the view to add additional pages to it.
//
//
// IShellView::SaveViewState()
//
//   The explorer calls this member when the shell view is supposed to
//  store its view settings. The shell view is supposed to get a view
//  stream by calling IShellBrowser::GetViewStateStream and store the
//  current view state into that stream.
//
//
// IShellView::SelectItem(pidlItem, uFlags)
//
//   The explorer calls this member to change the selection state of
//  item(s) within the shell view window.  If pidlItem is NULL and uFlags
//  is SVSI_DESELECTOTHERS, all items should be deselected.
//
//-------------------------------------------------------------------------

//
// shellview select item flags
//
#define SVSI_DESELECT   0x0000
#define SVSI_SELECT     0x0001
#define SVSI_EDIT       0x0003  // includes select
#define SVSI_DESELECTOTHERS 0x0004
#define SVSI_ENSUREVISIBLE  0x0008
#define SVSI_FOCUSED        0x0010
#define SVSI_TRANSLATEPT    0x0020

//
// shellview get item object flags
//
#define SVGIO_BACKGROUND    0x00000000
#define SVGIO_SELECTION     0x00000001
#define SVGIO_ALLVIEW       0x00000002

//
// uState values for IShellView::UIActivate
//
typedef enum {
    SVUIA_DEACTIVATE       = 0,
    SVUIA_ACTIVATE_NOFOCUS = 1,
    SVUIA_ACTIVATE_FOCUS   = 2,
    SVUIA_INPLACEACTIVATE  = 3          // new flag for IShellView2
} SVUIA_STATUS;

#undef  INTERFACE
#define INTERFACE   IShellView

DECLARE_INTERFACE_(IShellView, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IShellView methods ***
    STDMETHOD(TranslateAccelerator) (THIS_ LPMSG lpmsg) PURE;
#ifdef _FIX_ENABLEMODELESS_CONFLICT
    STDMETHOD(EnableModelessSV) (THIS_ BOOL fEnable) PURE;
#else
    STDMETHOD(EnableModeless) (THIS_ BOOL fEnable) PURE;
#endif
    STDMETHOD(UIActivate) (THIS_ UINT uState) PURE;
    STDMETHOD(Refresh) (THIS) PURE;

    STDMETHOD(CreateViewWindow)(THIS_ IShellView  *lpPrevView,
                    LPCFOLDERSETTINGS lpfs, IShellBrowser  * psb,
                    RECT * prcView, HWND  *phWnd) PURE;
    STDMETHOD(DestroyViewWindow)(THIS) PURE;
    STDMETHOD(GetCurrentInfo)(THIS_ LPFOLDERSETTINGS lpfs) PURE;
    STDMETHOD(AddPropertySheetPages)(THIS_ DWORD dwReserved,
                    LPFNADDPROPSHEETPAGE lpfn, LPARAM lparam) PURE;
    STDMETHOD(SaveViewState)(THIS) PURE;
    STDMETHOD(SelectItem)(THIS_ LPCITEMIDLIST pidlItem, UINT uFlags) PURE;
    STDMETHOD(GetItemObject)(THIS_ UINT uItem, REFIID riid,
                    LPVOID *ppv) PURE;
};

typedef IShellView *    LPSHELLVIEW;

typedef GUID SHELLVIEWID;

#define SV2GV_CURRENTVIEW ((UINT)-1)
#define SV2GV_DEFAULTVIEW ((UINT)-2)

#include <pshpack8.h>
typedef struct _SV2CVW2_PARAMS
{
    DWORD cbSize;

    IShellView *psvPrev;
    FOLDERSETTINGS const *pfs;
    IShellBrowser *psbOwner;
    RECT *prcView;
    SHELLVIEWID const *pvid;

    HWND hwndView;
} SV2CVW2_PARAMS;
typedef SV2CVW2_PARAMS *LPSV2CVW2_PARAMS;
#include <poppack.h>

#undef  INTERFACE
#define INTERFACE   IShellView2

DECLARE_INTERFACE_(IShellView2, IShellView)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IShellView methods ***
    STDMETHOD(TranslateAccelerator) (THIS_ LPMSG lpmsg) PURE;
#ifdef _FIX_ENABLEMODELESS_CONFLICT
    STDMETHOD(EnableModelessSV) (THIS_ BOOL fEnable) PURE;
#else
    STDMETHOD(EnableModeless) (THIS_ BOOL fEnable) PURE;
#endif
    STDMETHOD(UIActivate) (THIS_ UINT uState) PURE;
    STDMETHOD(Refresh) (THIS) PURE;

    STDMETHOD(CreateViewWindow)(THIS_ IShellView  *lpPrevView,
                    LPCFOLDERSETTINGS lpfs, IShellBrowser  * psb,
                    RECT * prcView, HWND  *phWnd) PURE;
    STDMETHOD(DestroyViewWindow)(THIS) PURE;
    STDMETHOD(GetCurrentInfo)(THIS_ LPFOLDERSETTINGS lpfs) PURE;
    STDMETHOD(AddPropertySheetPages)(THIS_ DWORD dwReserved,
                    LPFNADDPROPSHEETPAGE lpfn, LPARAM lparam) PURE;
    STDMETHOD(SaveViewState)(THIS) PURE;
    STDMETHOD(SelectItem)(THIS_ LPCITEMIDLIST pidlItem, UINT uFlags) PURE;
    STDMETHOD(GetItemObject)(THIS_ UINT uItem, REFIID riid,
                    LPVOID *ppv) PURE;

    // *** IShellView2 methods ***
    STDMETHOD(GetView)(THIS_ SHELLVIEWID* pvid, ULONG uView) PURE;
    STDMETHOD(CreateViewWindow2)(THIS_ LPSV2CVW2_PARAMS lpParams) PURE;
    STDMETHOD(HandleRename)(THIS_ LPCITEMIDLIST pidlNew) PURE;
    STDMETHOD(SelectAndPositionItem) (THIS_ LPCITEMIDLIST pidlItem,
        UINT uFlags,POINT* point) PURE; 
};

//-------------------------------------------------------------------------
//
// struct STRRET
//
// structure for returning strings from IShellFolder member functions
//
//-------------------------------------------------------------------------
#define STRRET_WSTR     0x0000          // Use STRRET.pOleStr
#define STRRET_OFFSET   0x0001          // Use STRRET.uOffset to Ansi
#define STRRET_CSTR     0x0002          // Use STRRET.cStr


typedef struct _STRRET
{
    UINT uType; // One of the STRRET_* values
    union
    {
        LPWSTR          pOleStr;        // must be freed by caller of GetDisplayNameOf
        LPSTR           pStr;           // NOT USED
        UINT            uOffset;        // Offset into SHITEMID
        char            cStr[MAX_PATH]; // Buffer to fill in (ANSI)
    } DUMMYUNIONNAME;
} STRRET, *LPSTRRET;


//-------------------------------------------------------------------------
//
// SHGetPathFromIDList
//
//  This function assumes the size of the buffer (MAX_PATH). The pidl
// should point to a file system object.
//
//-------------------------------------------------------------------------

WINSHELLAPI BOOL WINAPI SHGetPathFromIDListA(LPCITEMIDLIST pidl, LPSTR pszPath);
WINSHELLAPI BOOL WINAPI SHGetPathFromIDListW(LPCITEMIDLIST pidl, LPWSTR pszPath);

#ifdef UNICODE
#define SHGetPathFromIDList SHGetPathFromIDListW
#else
#define SHGetPathFromIDList SHGetPathFromIDListA
#endif


//-------------------------------------------------------------------------
//
// SHGetSpecialFolderLocation
//
//  Caller should use SHGetMalloc to obtain an allocator that can free the pidl
//  
//
//-------------------------------------------------------------------------
//
// registry entries for special paths are kept in :
#define REGSTR_PATH_SPECIAL_FOLDERS    REGSTR_PATH_EXPLORER TEXT("\\Shell Folders")


#define CSIDL_DESKTOP                   0x0000
#define CSIDL_INTERNET                  0x0001
#define CSIDL_PROGRAMS                  0x0002
#define CSIDL_CONTROLS                  0x0003
#define CSIDL_PRINTERS                  0x0004
#define CSIDL_PERSONAL                  0x0005
#define CSIDL_FAVORITES                 0x0006
#define CSIDL_STARTUP                   0x0007
#define CSIDL_RECENT                    0x0008
#define CSIDL_SENDTO                    0x0009
#define CSIDL_BITBUCKET                 0x000a
#define CSIDL_STARTMENU                 0x000b
#define CSIDL_DESKTOPDIRECTORY          0x0010
#define CSIDL_DRIVES                    0x0011
#define CSIDL_NETWORK                   0x0012
#define CSIDL_NETHOOD                   0x0013
#define CSIDL_FONTS                     0x0014
#define CSIDL_TEMPLATES                 0x0015
#define CSIDL_COMMON_STARTMENU          0x0016
#define CSIDL_COMMON_PROGRAMS           0X0017
#define CSIDL_COMMON_STARTUP            0x0018
#define CSIDL_COMMON_DESKTOPDIRECTORY   0x0019
#define CSIDL_APPDATA                   0x001a
#define CSIDL_PRINTHOOD                 0x001b
#define CSIDL_ALTSTARTUP                0x001d         // DBCS
#define CSIDL_COMMON_ALTSTARTUP         0x001e         // DBCS
#define CSIDL_COMMON_FAVORITES          0x001f
#define CSIDL_INTERNET_CACHE            0x0020
#define CSIDL_COOKIES                   0x0021
#define CSIDL_HISTORY                   0x0022

WINSHELLAPI HRESULT WINAPI SHGetSpecialFolderLocation(HWND hwndOwner, int nFolder, LPITEMIDLIST * ppidl);

#if (_WIN32_IE >= 0x0400)

WINSHELLAPI BOOL WINAPI SHGetSpecialFolderPathA(HWND hwndOwner, LPSTR lpszPath, int nFolder, BOOL fCreate);
WINSHELLAPI BOOL WINAPI SHGetSpecialFolderPathW(HWND hwndOwner, LPWSTR lpszPath, int nFolder, BOOL fCreate);
#ifdef UNICODE
#define SHGetSpecialFolderPath  SHGetSpecialFolderPathW
#else
#define SHGetSpecialFolderPath  SHGetSpecialFolderPathA
#endif

#endif      // _WIN32_IE >= 0x0400

//-------------------------------------------------------------------------
//
// SHBrowseForFolder API
//
//-------------------------------------------------------------------------

typedef int (CALLBACK* BFFCALLBACK)(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData);

typedef struct _browseinfoA {
    HWND        hwndOwner;
    LPCITEMIDLIST pidlRoot;
    LPSTR        pszDisplayName;// Return display name of item selected.
    LPCSTR       lpszTitle;      // text to go in the banner over the tree.
    UINT         ulFlags;       // Flags that control the return stuff
    BFFCALLBACK  lpfn;
    LPARAM      lParam;         // extra info that's passed back in callbacks

    int          iImage;      // output var: where to return the Image index.
} BROWSEINFOA, *PBROWSEINFOA, *LPBROWSEINFOA;

typedef struct _browseinfoW {
    HWND        hwndOwner;
    LPCITEMIDLIST pidlRoot;
    LPWSTR       pszDisplayName;// Return display name of item selected.
    LPCWSTR      lpszTitle;      // text to go in the banner over the tree.
    UINT         ulFlags;       // Flags that control the return stuff
    BFFCALLBACK  lpfn;
    LPARAM      lParam;         // extra info that's passed back in callbacks

    int          iImage;      // output var: where to return the Image index.
} BROWSEINFOW, *PBROWSEINFOW, *LPBROWSEINFOW;

#ifdef UNICODE
#define BROWSEINFO      BROWSEINFOW
#define PBROWSEINFO     PBROWSEINFOW
#define LPBROWSEINFO    LPBROWSEINFOW
#else
#define BROWSEINFO      BROWSEINFOA
#define PBROWSEINFO     PBROWSEINFOA
#define LPBROWSEINFO    LPBROWSEINFOA
#endif

// Browsing for directory.
#define BIF_RETURNONLYFSDIRS   0x0001  // For finding a folder to start document searching
#define BIF_DONTGOBELOWDOMAIN  0x0002  // For starting the Find Computer
#define BIF_STATUSTEXT         0x0004
#define BIF_RETURNFSANCESTORS  0x0008
#define BIF_EDITBOX            0x0010
#define BIF_VALIDATE           0x0020   // insist on valid result (or CANCEL)

#define BIF_BROWSEFORCOMPUTER  0x1000  // Browsing for Computers.
#define BIF_BROWSEFORPRINTER   0x2000  // Browsing for Printers
#define BIF_BROWSEINCLUDEFILES 0x4000  // Browsing for Everything

// message from browser
#define BFFM_INITIALIZED        1
#define BFFM_SELCHANGED         2
#define BFFM_VALIDATEFAILEDA    3   // lParam:szPath ret:1(cont),0(EndDialog)
#define BFFM_VALIDATEFAILEDW    4   // lParam:wzPath ret:1(cont),0(EndDialog)

// messages to browser
#define BFFM_SETSTATUSTEXTA     (WM_USER + 100)
#define BFFM_ENABLEOK           (WM_USER + 101)
#define BFFM_SETSELECTIONA      (WM_USER + 102)
#define BFFM_SETSELECTIONW      (WM_USER + 103)
#define BFFM_SETSTATUSTEXTW     (WM_USER + 104)

WINSHELLAPI LPITEMIDLIST WINAPI SHBrowseForFolderA(LPBROWSEINFOA lpbi);
WINSHELLAPI LPITEMIDLIST WINAPI SHBrowseForFolderW(LPBROWSEINFOW lpbi);

#ifdef UNICODE
#define SHBrowseForFolder   SHBrowseForFolderW
#define BFFM_SETSTATUSTEXT  BFFM_SETSTATUSTEXTW
#define BFFM_SETSELECTION   BFFM_SETSELECTIONW

#define BFFM_VALIDATEFAILED BFFM_VALIDATEFAILEDW
#else
#define SHBrowseForFolder   SHBrowseForFolderA
#define BFFM_SETSTATUSTEXT  BFFM_SETSTATUSTEXTA
#define BFFM_SETSELECTION   BFFM_SETSELECTIONA

#define BFFM_VALIDATEFAILED BFFM_VALIDATEFAILEDA
#endif

//-------------------------------------------------------------------------
//
// SHLoadInProc
//
//   When this function is called, the shell calls CoCreateInstance
//  (or equivalent) with CLSCTX_INPROC_SERVER and the specified CLSID
//  from within the shell's process and release it immediately.
//
//-------------------------------------------------------------------------

WINSHELLAPI HRESULT WINAPI SHLoadInProc(REFCLSID rclsid);


//-------------------------------------------------------------------------
//
// IEnumIDList interface
//
//  IShellFolder::EnumObjects member returns an IEnumIDList object.
//
//-------------------------------------------------------------------------

typedef struct IEnumIDList      *LPENUMIDLIST;

#undef  INTERFACE
#define INTERFACE       IEnumIDList

DECLARE_INTERFACE_(IEnumIDList, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumIDList methods ***
    STDMETHOD(Next)  (THIS_ ULONG celt,
                      LPITEMIDLIST *rgelt,
                      ULONG *pceltFetched) PURE;
    STDMETHOD(Skip)  (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumIDList **ppenum) PURE;
};


//-------------------------------------------------------------------------
//
// IShellFolder interface
//
//
// [Member functions]
//
// IShellFolder::BindToObject(pidl, pbc, riid, ppvOut)
//   This function returns an instance of a sub-folder which is specified
//  by the IDList (pidl).
//
// IShellFolder::BindToStorage(pidl, pbc, riid, ppvObj)
//   This function returns a storage instance of a sub-folder which is
//  specified by the IDList (pidl). The shell never calls this member
//  function in the first release of Win95.
//
// IShellFolder::CompareIDs(lParam, pidl1, pidl2)
//   This function compares two IDLists and returns the result. The shell
//  explorer always passes 0 as lParam, which indicates "sort by name".
//  It should return 0 (as CODE of the scode), if two id indicates the
//  same object; negative value if pidl1 should be placed before pidl2;
//  positive value if pidl2 should be placed before pidl1.
//
// IShellFolder::CreateViewObject(hwndOwner, riid, ppvOut)
//   This function creates a view object of the folder itself. The view
//  object is a difference instance from the shell folder object.
//   "hwndOwner" can be used  as the owner window of its dialog box or
//  menu during the lifetime of the view object.
//  instance which has only one reference count. The explorer may create
//  more than one instances of view object from one shell folder object
//  and treat them as separate instances.
//
// IShellFolder::GetAttributesOf(cidl, apidl, prgfInOut)
//   This function returns the attributes of specified objects in that
//  folder. "cidl" and "apidl" specifies objects. "apidl" contains only
//  simple IDLists. The explorer initializes *prgfInOut with a set of
//  flags to be evaluated. The shell folder may optimize the operation
//  by not returning unspecified flags.
//
// IShellFolder::GetUIObjectOf(hwndOwner, cidl, apidl, riid, prgfInOut, ppvOut)
//   This function creates a UI object to be used for specified objects.
//  The shell explorer passes either IID_IDataObject (for transfer operation)
//  or IID_IContextMenu (for context menu operation) as riid.
//
// IShellFolder::GetDisplayNameOf
//   This function returns the display name of the specified object.
//  If the ID contains the display name (in the locale character set),
//  it returns the offset to the name. Otherwise, it returns a pointer
//  to the display name string (UNICODE), which is allocated by the
//  task allocator, or fills in a buffer.
//
// IShellFolder::SetNameOf
//   This function sets the display name of the specified object.
//  If it changes the ID as well, it returns the new ID which is
//  alocated by the task allocator.
//
//-------------------------------------------------------------------------

// IShellFolder::GetDisplayNameOf/SetNameOf uFlags
typedef enum tagSHGDN
{
    SHGDN_NORMAL            = 0,        // default (display purpose)
    SHGDN_INFOLDER          = 1,        // displayed under a folder (relative)
    SHGDN_INCLUDE_NONFILESYS = 0x2000,   // if not set, display names for shell name space items that are not in the file system will fail.
    SHGDN_FORADDRESSBAR     = 0x4000,   // for displaying in the address (drives dropdown) bar
    SHGDN_FORPARSING        = 0x8000,   // for ParseDisplayName or path
} SHGNO;

// IShellFolder::EnumObjects
typedef enum tagSHCONTF
{
    SHCONTF_FOLDERS         = 32,       // for shell browser
    SHCONTF_NONFOLDERS      = 64,       // for default view
    SHCONTF_INCLUDEHIDDEN   = 128,      // for hidden/system objects
} SHCONTF;

// IShellFolder::GetAttributesOf flags
#define SFGAO_CANCOPY           DROPEFFECT_COPY // Objects can be copied
#define SFGAO_CANMOVE           DROPEFFECT_MOVE // Objects can be moved
#define SFGAO_CANLINK           DROPEFFECT_LINK // Objects can be linked
#define SFGAO_CANRENAME         0x00000010L     // Objects can be renamed
#define SFGAO_CANDELETE         0x00000020L     // Objects can be deleted
#define SFGAO_HASPROPSHEET      0x00000040L     // Objects have property sheets
#define SFGAO_DROPTARGET        0x00000100L     // Objects are drop target
#define SFGAO_CAPABILITYMASK    0x00000177L
#define SFGAO_LINK              0x00010000L     // Shortcut (link)
#define SFGAO_SHARE             0x00020000L     // shared
#define SFGAO_READONLY          0x00040000L     // read-only
#define SFGAO_GHOSTED           0x00080000L     // ghosted icon
#define SFGAO_HIDDEN            0x00080000L     // hidden object
#define SFGAO_DISPLAYATTRMASK   0x000F0000L
#define SFGAO_FILESYSANCESTOR   0x10000000L     // It contains file system folder
#define SFGAO_FOLDER            0x20000000L     // It's a folder.
#define SFGAO_FILESYSTEM        0x40000000L     // is a file system thing (file/folder/root)
#define SFGAO_HASSUBFOLDER      0x80000000L     // Expandable in the map pane
#define SFGAO_CONTENTSMASK      0x80000000L
#define SFGAO_VALIDATE          0x01000000L     // invalidate cached information
#define SFGAO_REMOVABLE         0x02000000L     // is this removeable media?
#define SFGAO_COMPRESSED        0x04000000L     // Object is compressed (use alt color)
#define SFGAO_BROWSABLE         0x08000000L     // is in-place browsable
#define SFGAO_NONENUMERATED     0x00100000L     // is a non-enumerated object
#define SFGAO_NEWCONTENT        0x00200000L     // should show bold in explorer tree

#undef  INTERFACE
#define INTERFACE       IShellFolder

DECLARE_INTERFACE_(IShellFolder, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolder methods ***
    STDMETHOD(ParseDisplayName) (THIS_ HWND hwndOwner,
        LPBC pbcReserved, LPOLESTR lpszDisplayName,
        ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes) PURE;

    STDMETHOD(EnumObjects) ( THIS_ HWND hwndOwner, DWORD grfFlags, LPENUMIDLIST * ppenumIDList) PURE;

    STDMETHOD(BindToObject)     (THIS_ LPCITEMIDLIST pidl, LPBC pbcReserved,
                                 REFIID riid, LPVOID * ppvOut) PURE;
    STDMETHOD(BindToStorage)    (THIS_ LPCITEMIDLIST pidl, LPBC pbcReserved,
                                 REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD(CompareIDs)       (THIS_ LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) PURE;
    STDMETHOD(CreateViewObject) (THIS_ HWND hwndOwner, REFIID riid, LPVOID * ppvOut) PURE;
    STDMETHOD(GetAttributesOf)  (THIS_ UINT cidl, LPCITEMIDLIST * apidl,
                                    ULONG * rgfInOut) PURE;
    STDMETHOD(GetUIObjectOf)    (THIS_ HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                                 REFIID riid, UINT * prgfInOut, LPVOID * ppvOut) PURE;
    STDMETHOD(GetDisplayNameOf) (THIS_ LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName) PURE;
    STDMETHOD(SetNameOf)        (THIS_ HWND hwndOwner, LPCITEMIDLIST pidl,
                                 LPCOLESTR lpszName, DWORD uFlags,
                                 LPITEMIDLIST * ppidlOut) PURE;
};

typedef IShellFolder * LPSHELLFOLDER;

//
//  Helper function which returns a IShellFolder interface to the desktop
// folder. This is equivalent to call CoCreateInstance with CLSID_ShellDesktop.
//
//  CoCreateInstance(CLSID_Desktop, NULL,
//                   CLSCTX_INPROC, IID_IShellFolder, &pshf);
//
WINSHELLAPI HRESULT WINAPI SHGetDesktopFolder(LPSHELLFOLDER *ppshf);


//==========================================================================
// IInputObjectSite/IInputObject interfaces
//
//  These interfaces allow us (or ISVs) to install/update external Internet
// Toolbar for IE and the shell. The frame will simply get the CLSID from
// registry (to be defined) and CoCreateInstance it.
//
//==========================================================================

//-------------------------------------------------------------------------
//
// IInputObjectSite interface
//
//   A site implements this interface so the object can communicate
// focus change to it.
//
// [Member functions]
//
// IInputObjectSite::OnFocusChangeIS(punkObj, fSetFocus)
//   Object (punkObj) is getting or losing the focus.  
//
//-------------------------------------------------------------------------


#undef  INTERFACE
#define INTERFACE   IInputObjectSite

DECLARE_INTERFACE_(IInputObjectSite, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IInputObjectSite specific methods ***
    STDMETHOD(OnFocusChangeIS)(THIS_ IUnknown* punkObj, BOOL fSetFocus) PURE;
};


//-------------------------------------------------------------------------
//
// IInputObject interface
//
//   An object implements this interface so the site can communicate
// activation and accelerator events to it.
//
// [Member functions]
//
// IInputObject::UIActivateIO(fActivate, lpMsg)
//   Activates or deactivates the object.  lpMsg may be NULL.  Returns
//   S_OK if the activation succeeded.
//
// IInputObject::HasFocusIO()
//   Returns S_OK if the object has the focus, S_FALSE if not.
//
// IInputObject::TranslateAcceleratorIO(lpMsg)
//   Allow the object to process the message.  Returns S_OK if the 
//   message was processed (eaten).
//
//-------------------------------------------------------------------------


#undef  INTERFACE
#define INTERFACE   IInputObject

DECLARE_INTERFACE_(IInputObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IInputObject specific methods ***
    STDMETHOD(UIActivateIO)(THIS_ BOOL fActivate, LPMSG lpMsg) PURE;
    STDMETHOD(HasFocusIO)(THIS) PURE;
    STDMETHOD(TranslateAcceleratorIO)(THIS_ LPMSG lpMsg) PURE;
};


//==========================================================================
// IDockingWindowSite/IDockingWindow/IDockingWindowFrame interfaces
// IInputObjectSite/IInputObject interfaces
//
//  These interfaces allow us (or ISVs) to install/update external Internet
// Toolbar for IE and the shell. The frame will simply get the CLSID from
// registry (to be defined) and CoCreateInstance it.
//
//==========================================================================


//-------------------------------------------------------------------------
//
// IDockingWindowSite interface
//
//   A site implements this interface so the object can negotiate for
// and inquire about real estate on the site.
//
// [Member functions]
//
// IDockingWindowSite::GetBorderDW(punkObj, prcBorder)
//   Site returns the bounding rectangle of the given source object 
//   (punkObj).
//
// IDockingWindowSite::RequestBorderSpaceDW(punkObj, pbw)
//   Object requests that the site makes room for it, as specified in
//   *pbw.
//
// IDockingWindowSite::SetBorderSpaceDW(punkObj, pbw)
//   Object requests that the site set the border spacing to the size 
//   specified in *pbw.
//
//-------------------------------------------------------------------------


#undef  INTERFACE
#define INTERFACE   IDockingWindowSite

DECLARE_INTERFACE_(IDockingWindowSite, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IDockingWindowSite methods ***
    STDMETHOD(GetBorderDW) (THIS_ IUnknown* punkObj, LPRECT prcBorder) PURE;
    STDMETHOD(RequestBorderSpaceDW) (THIS_ IUnknown* punkObj, LPCBORDERWIDTHS pbw) PURE;
    STDMETHOD(SetBorderSpaceDW) (THIS_ IUnknown* punkObj, LPCBORDERWIDTHS pbw) PURE;
};



//-------------------------------------------------------------------------
//
// IDockingWindowFrame interface
//
//
// [Member functions]
//
// IDockingWindowFrame::AddToolbar(punkSrc, pwszItem, dwReserved)
//
// IDockingWindowFrame::RemoveToolbar(punkSrc, dwRemoveFlags)
//
// IDockingWindowFrame::FindToolbar(pwszItem, riid, ppvObj)
//
//-------------------------------------------------------------------------


// flags for RemoveToolbar
#define DWFRF_NORMAL            0x0000
#define DWFRF_DELETECONFIGDATA  0x0001


// flags for AddToolbar
#define DWFAF_HIDDEN  0x0001   // add hidden

#undef  INTERFACE
#define INTERFACE   IDockingWindowFrame

DECLARE_INTERFACE_(IDockingWindowFrame, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IDockingWindowFrame methods ***
    STDMETHOD(AddToolbar) (THIS_ IUnknown* punkSrc, LPCWSTR pwszItem, DWORD dwAddFlags) PURE;
    STDMETHOD(RemoveToolbar) (THIS_ IUnknown* punkSrc, DWORD dwRemoveFlags) PURE;
    STDMETHOD(FindToolbar) (THIS_ LPCWSTR pwszItem, REFIID riid, LPVOID* ppvObj) PURE;
};



//-------------------------------------------------------------------------
//
// IDockingWindow interface
//
//   An object (docking window) implements this interface so the site can 
// communicate with it.  An example of a docking window is a toolbar.
//
// [Member functions]
//
// IDockingWindow::ShowDW(fShow)
//   Shows or hides the docking window.
//
// IDockingWindow::CloseDW(dwReserved)
//   Closes the docking window.  dwReserved must be 0.
//
// IDockingWindow::ResizeBorderDW(prcBorder, punkToolbarSite, fReserved)
//   Resizes the docking window's border to *prcBorder.  fReserved must
//   be 0.
// IObjectWithSite::SetSite(punkSite)
//   IDockingWindow usually paired with IObjectWithSite.
//   Provides the IUnknown pointer of the site to the docking window.
//
//
//-------------------------------------------------------------------------


#undef  INTERFACE
#define INTERFACE   IDockingWindow

DECLARE_INTERFACE_(IDockingWindow, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IDockingWindow methods ***
    STDMETHOD(ShowDW)         (THIS_ BOOL fShow) PURE;
    STDMETHOD(CloseDW)        (THIS_ DWORD dwReserved) PURE;
    STDMETHOD(ResizeBorderDW) (THIS_ LPCRECT   prcBorder,
                                     IUnknown* punkToolbarSite,
                                     BOOL      fReserved) PURE;
};


//-------------------------------------------------------------------------
//
// IDeskBand interface
//
//
// [Member functions]
//
// IDeskBand::GetBandInfo(dwBandID, dwViewMode, pdbi)
//   Returns info on the given band in *pdbi, according to the mask
//   field in the DESKBANDINFO structure and the given viewmode.
//
//-------------------------------------------------------------------------


// Mask values for DESKBANDINFO
#define DBIM_MINSIZE    0x0001
#define DBIM_MAXSIZE    0x0002
#define DBIM_INTEGRAL   0x0004
#define DBIM_ACTUAL     0x0008
#define DBIM_TITLE      0x0010
#define DBIM_MODEFLAGS  0x0020
#define DBIM_BKCOLOR    0x0040

typedef struct {
    DWORD       dwMask;
    POINTL      ptMinSize;
    POINTL      ptMaxSize;
    POINTL      ptIntegral;
    POINTL      ptActual;
    WCHAR       wszTitle[256];
    DWORD       dwModeFlags;
    COLORREF    crBkgnd;
} DESKBANDINFO;

// DESKBANDINFO dwModeFlags values
#define DBIMF_NORMAL            0x0000
#define DBIMF_VARIABLEHEIGHT    0x0008
#define DBIMF_DEBOSSED          0x0020
#define DBIMF_BKCOLOR           0x0040

// GetBandInfo view mode values 
#define DBIF_VIEWMODE_NORMAL         0x0000
#define DBIF_VIEWMODE_VERTICAL       0x0001
#define DBIF_VIEWMODE_FLOATING       0x0002
#define DBIF_VIEWMODE_TRANSPARENT    0x0004


#undef  INTERFACE
#define INTERFACE   IDeskBand

DECLARE_INTERFACE_(IDeskBand, IDockingWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IDockingWindow methods ***
    STDMETHOD(ShowDW)         (THIS_ BOOL fShow) PURE;
    STDMETHOD(CloseDW)        (THIS_ DWORD dwReserved) PURE;
    STDMETHOD(ResizeBorderDW) (THIS_ LPCRECT   prcBorder,
                                     IUnknown* punkToolbarSite,
                                     BOOL      fReserved) PURE;
    // *** IDeskBand methods ***
    STDMETHOD(GetBandInfo)    (THIS_ DWORD dwBandID, DWORD dwViewMode, 
                                DESKBANDINFO* pdbi) PURE;

};

// Command Target IDs
enum {
    DBID_BANDINFOCHANGED = 0,
    // 
    DBID_SHOWONLY = 1,         
    DBID_MAXIMIZEBAND,      // Maximize the specified band (VT_UI4 == dwID)
};



#if (_WIN32_IE >= 0x400)
//
// We need to make sure that WININET.H is included before this interface is
// used because the COMPONENT structure uses INTERNET_MAX_URL_LENGTH
//
#ifdef _WININET_
//
//  Flags and structures used by IActiveDesktop
//

typedef struct _tagWALLPAPEROPT
{
    DWORD   dwSize;     // size of this Structure.
    DWORD   dwStyle;    // WPSTYLE_* mentioned above
}
WALLPAPEROPT;

typedef WALLPAPEROPT  *LPWALLPAPEROPT;
typedef const WALLPAPEROPT *LPCWALLPAPEROPT;

typedef struct _tagCOMPONENTSOPT
{
    DWORD   dwSize;             //Size of this structure
    BOOL    fEnableComponents;  //Enable components?
    BOOL    fActiveDesktop;     // Active desktop enabled ?
}
COMPONENTSOPT;

typedef COMPONENTSOPT   *LPCOMPONENTSOPT;
typedef const COMPONENTSOPT   *LPCCOMPONENTSOPT;

typedef struct _tagCOMPPOS
{
    DWORD   dwSize;             //Size of this structure
    int     iLeft;              //Left of top-left corner in screen co-ordinates.
    int     iTop;               //Top of top-left corner in screen co-ordinates.
    DWORD   dwWidth;            // Width in pixels.
    DWORD   dwHeight;           // Height in pixels.
    int     izIndex;            // Indicates the Z-order of the component.
    BOOL    fCanResize;         // Is the component resizeable?
    BOOL    fCanResizeX;        // Resizeable in X-direction?
    BOOL    fCanResizeY;        // Resizeable in Y-direction?
    int     iPreferredLeftPercent;    //Left of top-left corner as percent of screen width
    int     iPreferredTopPercent;     //Top of top-left corner as percent of screen height
}
COMPPOS;

typedef COMPPOS *LPCOMPPOS;
typedef const COMPPOS *LPCCOMPPOS;




#define COMPONENT_TOP (0x7fffffff)  // izOrder value meaning component is at the top


// iCompType values
#define COMP_TYPE_HTMLDOC       0
#define COMP_TYPE_PICTURE       1
#define COMP_TYPE_WEBSITE       2
#define COMP_TYPE_CONTROL       3
#define COMP_TYPE_CFHTML        4
#define COMP_TYPE_MAX           4

typedef struct _tagCOMPONENT
{
    DWORD   dwSize;             //Size of this structure
    DWORD   dwID;               //Reserved: Set it always to zero.
    int     iComponentType;     //One of COMP_TYPE_*
    BOOL    fChecked;           // Is this component enabled? 
    BOOL    fDirty;             // Had the component been modified and not yet saved to disk?
    BOOL    fNoScroll;          // Is the component scrollable?
    COMPPOS cpPos;              // Width, height etc.,
    WCHAR   wszFriendlyName[MAX_PATH];          // Friendly name of component.
    WCHAR   wszSource[INTERNET_MAX_URL_LENGTH]; //URL of the component.
    WCHAR   wszSubscribedURL[INTERNET_MAX_URL_LENGTH]; //Subscrined URL
}
COMPONENT;

typedef COMPONENT *LPCOMPONENT;
typedef const COMPONENT *LPCCOMPONENT;




////////////////////////////////////////////
// Flags for IActiveDesktop::ApplyChanges()
#define AD_APPLY_SAVE         0x00000001
#define AD_APPLY_HTMLGEN      0x00000002
#define AD_APPLY_REFRESH      0x00000004
#define AD_APPLY_ALL     (AD_APPLY_SAVE | AD_APPLY_HTMLGEN | AD_APPLY_REFRESH)
#define AD_APPLY_FORCE        0x00000008
#define AD_APPLY_BUFFERED_REFRESH 0x00000010

////////////////////////////////////////////
// Flags for IActiveDesktop::GetWallpaperOptions()
//           IActiveDesktop::SetWallpaperOptions()
#define WPSTYLE_CENTER      0
#define WPSTYLE_TILE        1
#define WPSTYLE_STRETCH     2
#define WPSTYLE_MAX         3


////////////////////////////////////////////
// Flags for IActiveDesktop::ModifyComponent()

#define COMP_ELEM_TYPE          0x00000001
#define COMP_ELEM_CHECKED       0x00000002
#define COMP_ELEM_DIRTY         0x00000004
#define COMP_ELEM_NOSCROLL      0x00000008
#define COMP_ELEM_POS_LEFT      0x00000010
#define COMP_ELEM_POS_TOP       0x00000020
#define COMP_ELEM_SIZE_WIDTH    0x00000040
#define COMP_ELEM_SIZE_HEIGHT   0x00000080
#define COMP_ELEM_POS_ZINDEX    0x00000100
#define COMP_ELEM_SOURCE        0x00000200
#define COMP_ELEM_FRIENDLYNAME  0x00000400
#define COMP_ELEM_SUBSCRIBEDURL 0x00000800

#define COMP_ELEM_ALL   (COMP_ELEM_TYPE | COMP_ELEM_CHECKED | COMP_ELEM_DIRTY |          \
                         COMP_ELEM_NOSCROLL | COMP_ELEM_POS_LEFT | COMP_ELEM_SIZE_WIDTH  \
                         COMP_ELEM_SIZE_HEIGHT | COMP_ELEM_POS_ZINDEX | COMP_ELEM_SOURCE \
                         COMP_ELEM_FRIENDLYNAME )


////////////////////////////////////////////
// Flags for IActiveDesktop::AddDesktopItemWithUI()
typedef enum tagDTI_ADTIWUI
{
    DTI_ADDUI_DEFAULT               = 0x00000000,
    DTI_ADDUI_DISPSUBWIZARD         = 0x00000001,
};


////////////////////////////////////////////
// Flags for IActiveDesktop::AddUrl()
#define ADDURL_SILENT           0X0001





//
//  Interface for manipulating the Active Desktop.
//

#undef INTERFACE
#define INTERFACE IActiveDesktop

DECLARE_INTERFACE_( IActiveDesktop, IUnknown )
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void ** ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // IActiveDesktop methods
    STDMETHOD (ApplyChanges)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD (GetWallpaper)(THIS_ LPWSTR pwszWallpaper, UINT cchWallpaper, DWORD dwReserved) PURE;
    STDMETHOD (SetWallpaper)(THIS_ LPCWSTR pwszWallpaper, DWORD dwReserved) PURE;
    STDMETHOD (GetWallpaperOptions)(THIS_ LPWALLPAPEROPT pwpo, DWORD dwReserved) PURE;
    STDMETHOD (SetWallpaperOptions)(THIS_ LPCWALLPAPEROPT pwpo, DWORD dwReserved) PURE;
    STDMETHOD (GetPattern)(THIS_ LPWSTR pwszPattern, UINT cchPattern, DWORD dwReserved) PURE;
    STDMETHOD (SetPattern)(THIS_ LPCWSTR pwszPattern, DWORD dwReserved) PURE;
    STDMETHOD (GetDesktopItemOptions)(THIS_ LPCOMPONENTSOPT pco, DWORD dwReserved) PURE;
    STDMETHOD (SetDesktopItemOptions)(THIS_ LPCCOMPONENTSOPT pco, DWORD dwReserved) PURE;
    STDMETHOD (AddDesktopItem)(THIS_ LPCCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (AddDesktopItemWithUI)(THIS_ HWND hwnd, LPCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (ModifyDesktopItem)(THIS_ LPCCOMPONENT pcomp, DWORD dwFlags) PURE;
    STDMETHOD (RemoveDesktopItem)(THIS_ LPCCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (GetDesktopItemCount)(THIS_ LPINT lpiCount, DWORD dwReserved) PURE;
    STDMETHOD (GetDesktopItem)(THIS_ int nComponent, LPCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (GetDesktopItemByID)(THIS_ DWORD dwID, LPCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (GenerateDesktopItemHtml)(THIS_ LPCWSTR pwszFileName, LPCOMPONENT pcomp, DWORD dwReserved) PURE;
    STDMETHOD (AddUrl)(THIS_ HWND hwnd, LPCWSTR pszSource, LPCOMPONENT pcomp, DWORD dwFlags) PURE;
    STDMETHOD (GetDesktopItemBySource)(THIS_ LPCWSTR pwszSource, LPCOMPONENT pcomp, DWORD dwReserved) PURE;
};

typedef IActiveDesktop * LPACTIVEDESKTOP;


#endif // _WININET_

#endif // _WIN32_IE

//==========================================================================
// Clipboard format which may be supported by IDataObject from system
// defined shell folders (such as directories, network, ...).
//==========================================================================

#define CFSTR_SHELLIDLIST       TEXT("Shell IDList Array")      // CF_IDLIST
#define CFSTR_SHELLIDLISTOFFSET TEXT("Shell Object Offsets")    // CF_OBJECTPOSITIONS
#define CFSTR_NETRESOURCES      TEXT("Net Resource")            // CF_NETRESOURCE
#define CFSTR_FILEDESCRIPTORA   TEXT("FileGroupDescriptor")     // CF_FILEGROUPDESCRIPTORA
#define CFSTR_FILEDESCRIPTORW   TEXT("FileGroupDescriptorW")    // CF_FILEGROUPDESCRIPTORW
#define CFSTR_FILECONTENTS      TEXT("FileContents")            // CF_FILECONTENTS
#define CFSTR_FILENAMEA         TEXT("FileName")                // CF_FILENAMEA
#define CFSTR_FILENAMEW         TEXT("FileNameW")               // CF_FILENAMEW
#define CFSTR_PRINTERGROUP      TEXT("PrinterFriendlyName")     // CF_PRINTERS
#define CFSTR_FILENAMEMAPA      TEXT("FileNameMap")             // CF_FILENAMEMAPA
#define CFSTR_FILENAMEMAPW      TEXT("FileNameMapW")            // CF_FILENAMEMAPW
#define CFSTR_SHELLURL          TEXT("UniformResourceLocator")
#define CFSTR_PREFERREDDROPEFFECT TEXT("Preferred DropEffect")
#define CFSTR_PERFORMEDDROPEFFECT TEXT("Performed DropEffect") 
#define CFSTR_PASTESUCCEEDED    TEXT("Paste Succeeded")
#define CFSTR_INDRAGLOOP        TEXT("InShellDragLoop")

#ifdef UNICODE
#define CFSTR_FILEDESCRIPTOR    CFSTR_FILEDESCRIPTORW
#define CFSTR_FILENAME          CFSTR_FILENAMEW
#define CFSTR_FILENAMEMAP       CFSTR_FILENAMEMAPW
#else
#define CFSTR_FILEDESCRIPTOR    CFSTR_FILEDESCRIPTORA
#define CFSTR_FILENAME          CFSTR_FILENAMEA
#define CFSTR_FILENAMEMAP       CFSTR_FILENAMEMAPA
#endif

//
// CF_OBJECTPOSITIONS
//
//



#define DVASPECT_SHORTNAME      2 // use for CF_HDROP to get short name version
//
// format of CF_NETRESOURCE
//
typedef struct _NRESARRAY {     // anr
    UINT cItems;
    NETRESOURCE nr[1];
} NRESARRAY, * LPNRESARRAY;

//
// format of CF_IDLIST
//
typedef struct _IDA {
    UINT cidl;          // number of relative IDList
    UINT aoffset[1];    // [0]: folder IDList, [1]-[cidl]: item IDList
} CIDA, * LPIDA;

//
// FILEDESCRIPTOR.dwFlags field indicate which fields are to be used
//
typedef enum {
    FD_CLSID            = 0x0001,
    FD_SIZEPOINT        = 0x0002,
    FD_ATTRIBUTES       = 0x0004,
    FD_CREATETIME       = 0x0008,
    FD_ACCESSTIME       = 0x0010,
    FD_WRITESTIME       = 0x0020,
    FD_FILESIZE         = 0x0040,
    FD_LINKUI           = 0x8000,       // 'link' UI is prefered
} FD_FLAGS;

typedef struct _FILEDESCRIPTORA { // fod
    DWORD dwFlags;

    CLSID clsid;
    SIZEL sizel;
    POINTL pointl;

    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    CHAR   cFileName[ MAX_PATH ];
} FILEDESCRIPTORA, *LPFILEDESCRIPTORA;

typedef struct _FILEDESCRIPTORW { // fod
    DWORD dwFlags;

    CLSID clsid;
    SIZEL sizel;
    POINTL pointl;

    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    WCHAR  cFileName[ MAX_PATH ];
} FILEDESCRIPTORW, *LPFILEDESCRIPTORW;

#ifdef UNICODE
#define FILEDESCRIPTOR      FILEDESCRIPTORW
#define LPFILEDESCRIPTOR    LPFILEDESCRIPTORW
#else
#define FILEDESCRIPTOR      FILEDESCRIPTORA
#define LPFILEDESCRIPTOR    LPFILEDESCRIPTORA
#endif

//
// format of CF_FILEGROUPDESCRIPTOR
//
typedef struct _FILEGROUPDESCRIPTORA { // fgd
     UINT cItems;
     FILEDESCRIPTORA fgd[1];
} FILEGROUPDESCRIPTORA, * LPFILEGROUPDESCRIPTORA;

typedef struct _FILEGROUPDESCRIPTORW { // fgd
     UINT cItems;
     FILEDESCRIPTORW fgd[1];
} FILEGROUPDESCRIPTORW, * LPFILEGROUPDESCRIPTORW;

#ifdef UNICODE
#define FILEGROUPDESCRIPTOR     FILEGROUPDESCRIPTORW
#define LPFILEGROUPDESCRIPTOR   LPFILEGROUPDESCRIPTORW
#else
#define FILEGROUPDESCRIPTOR     FILEGROUPDESCRIPTORA
#define LPFILEGROUPDESCRIPTOR   LPFILEGROUPDESCRIPTORA
#endif

//
// format of CF_HDROP and CF_PRINTERS, in the HDROP case the data that follows
// is a double null terinated list of file names, for printers they are printer
// friendly names
//
typedef struct _DROPFILES {
   DWORD pFiles;                       // offset of file list
   POINT pt;                           // drop point (client coords)
   BOOL fNC;                           // is it on NonClient area
                                       // and pt is in screen coords
   BOOL fWide;                         // WIDE character switch
} DROPFILES, FAR * LPDROPFILES;


//====== File System Notification APIs ===============================
//

//
//  File System Notification flags
//

#define SHCNE_RENAMEITEM          0x00000001L
#define SHCNE_CREATE              0x00000002L
#define SHCNE_DELETE              0x00000004L
#define SHCNE_MKDIR               0x00000008L
#define SHCNE_RMDIR               0x00000010L
#define SHCNE_MEDIAINSERTED       0x00000020L
#define SHCNE_MEDIAREMOVED        0x00000040L
#define SHCNE_DRIVEREMOVED        0x00000080L
#define SHCNE_DRIVEADD            0x00000100L
#define SHCNE_NETSHARE            0x00000200L
#define SHCNE_NETUNSHARE          0x00000400L
#define SHCNE_ATTRIBUTES          0x00000800L
#define SHCNE_UPDATEDIR           0x00001000L
#define SHCNE_UPDATEITEM          0x00002000L
#define SHCNE_SERVERDISCONNECT    0x00004000L
#define SHCNE_UPDATEIMAGE         0x00008000L
#define SHCNE_DRIVEADDGUI         0x00010000L
#define SHCNE_RENAMEFOLDER        0x00020000L
#define SHCNE_FREESPACE           0x00040000L

#if (_WIN32_IE >= 0x0400)
#define SHCNE_EXTENDED_EVENT      0x04000000L
#endif      // _WIN32_IE >= 0x0400

#define SHCNE_ASSOCCHANGED        0x08000000L

#define SHCNE_DISKEVENTS          0x0002381FL
#define SHCNE_GLOBALEVENTS        0x0C0581E0L // Events that dont match pidls first
#define SHCNE_ALLEVENTS           0x7FFFFFFFL
#define SHCNE_INTERRUPT           0x80000000L // The presence of this flag indicates
                                            // that the event was generated by an
                                            // interrupt.  It is stripped out before
                                            // the clients of SHCNNotify_ see it.

#if (_WIN32_IE >= 0x0400)
#define SHCNEE_ORDERCHANGED       0x00000002L  // dwItem2 is the pidl of the changed folder
#endif


// Flags
// uFlags & SHCNF_TYPE is an ID which indicates what dwItem1 and dwItem2 mean
#define SHCNF_IDLIST      0x0000        // LPITEMIDLIST
#define SHCNF_PATHA       0x0001        // path name
#define SHCNF_PRINTERA    0x0002        // printer friendly name
#define SHCNF_DWORD       0x0003        // DWORD
#define SHCNF_PATHW       0x0005        // path name
#define SHCNF_PRINTERW    0x0006        // printer friendly name
#define SHCNF_TYPE        0x00FF
#define SHCNF_FLUSH       0x1000
#define SHCNF_FLUSHNOWAIT 0x2000

#ifdef UNICODE
#define SHCNF_PATH      SHCNF_PATHW
#define SHCNF_PRINTER   SHCNF_PRINTERW
#else
#define SHCNF_PATH      SHCNF_PATHA
#define SHCNF_PRINTER   SHCNF_PRINTERA
#endif


//
//  APIs
//
WINSHELLAPI void WINAPI SHChangeNotify(LONG wEventId, UINT uFlags,
                                LPCVOID dwItem1, LPCVOID dwItem2);

//
// IShellChangeNotify
//
#undef  INTERFACE
#define INTERFACE  IShellChangeNotify

DECLARE_INTERFACE_(IShellChangeNotify, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellChangeNotify methods ***
    STDMETHOD(OnChange) (THIS_ LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) PURE;
} ;

//
// IQueryInfo
//
#undef  INTERFACE
#define INTERFACE  IQueryInfo

DECLARE_INTERFACE_(IQueryInfo, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IQueryInfo methods ***
    STDMETHOD(GetInfoTip)(THIS_ DWORD dwFlags, WCHAR **ppwszTip) PURE;
    STDMETHOD(GetInfoFlags)(THIS_ DWORD *pdwFlags) PURE;
} ;


#define QIF_CACHED           0x00000001
#define QIF_DONTEXPANDFOLDER 0x00000002


//
// SHAddToRecentDocs
//
#define SHARD_PIDL      0x00000001L
#define SHARD_PATHA     0x00000002L
#define SHARD_PATHW     0x00000003L

#ifdef UNICODE
#define SHARD_PATH  SHARD_PATHW
#else
#define SHARD_PATH  SHARD_PATHA
#endif

WINSHELLAPI void WINAPI SHAddToRecentDocs(UINT uFlags, LPCVOID pv);

WINSHELLAPI HRESULT WINAPI SHGetInstanceExplorer(IUnknown **ppunk);

//
// SHGetDataFromIDListA/W
//
#define SHGDFIL_FINDDATA        1
#define SHGDFIL_NETRESOURCE     2
#define SHGDFIL_DESCRIPTIONID   3

#define SHDID_ROOT_REGITEM          1
#define SHDID_FS_FILE               2
#define SHDID_FS_DIRECTORY          3
#define SHDID_FS_OTHER              4
#define SHDID_COMPUTER_DRIVE35      5
#define SHDID_COMPUTER_DRIVE525     6
#define SHDID_COMPUTER_REMOVABLE    7
#define SHDID_COMPUTER_FIXED        8
#define SHDID_COMPUTER_NETDRIVE     9
#define SHDID_COMPUTER_CDROM        10
#define SHDID_COMPUTER_RAMDISK      11
#define SHDID_COMPUTER_OTHER        12
#define SHDID_NET_DOMAIN            13
#define SHDID_NET_SERVER            14
#define SHDID_NET_SHARE             15
#define SHDID_NET_RESTOFNET         16
#define SHDID_NET_OTHER             17

typedef struct _SHDESCRIPTIONID {
    DWORD   dwDescriptionId;
    CLSID   clsid;
} SHDESCRIPTIONID, *LPSHDESCRIPTIONID;

WINSHELLAPI HRESULT WINAPI SHGetDataFromIDListA(LPSHELLFOLDER psf, LPCITEMIDLIST pidl,
        int nFormat, PVOID pv, int cb);
WINSHELLAPI HRESULT WINAPI SHGetDataFromIDListW(LPSHELLFOLDER psf, LPCITEMIDLIST pidl,
        int nFormat, PVOID pv, int cb);

#ifdef UNICODE
#define SHGetDataFromIDList SHGetDataFromIDListW
#else
#define SHGetDataFromIDList SHGetDataFromIDListA
#endif


//===========================================================================


//
// PROPIDs for Internet Shortcuts (FMTID_Intshcut) to be used with 
// IPropertySetStorage/IPropertyStorage
//
// The known property ids and their variant types are:
//      PID_IS_URL          [VT_LPWSTR]   URL
//      PID_IS_NAME         [VT_LPWSTR]   Name of the internet shortcut
//      PID_IS_WORKINGDIR   [VT_LPWSTR]   Working directory for the shortcut
//      PID_IS_HOTKEY       [VT_UI2]      Hotkey for the shortcut
//      PID_IS_SHOWCMD      [VT_I4]       Show command for shortcut
//      PID_IS_ICONINDEX    [VT_I4]       Index into file that has icon
//      PID_IS_ICONFILE     [VT_LPWSTR]   File that has the icon
//      PID_IS_WHATSNEW     [VT_LPWSTR]   What's New text
//      PID_IS_AUTHOR       [VT_LPWSTR]   Author
//      PID_IS_DESCRIPTION  [VT_LPWSTR]   Description text of site
//      PID_IS_COMMENT      [VT_LPWSTR]   User annotated comment
//

#define PID_IS_URL           2
#define PID_IS_NAME          4
#define PID_IS_WORKINGDIR    5
#define PID_IS_HOTKEY        6
#define PID_IS_SHOWCMD       7
#define PID_IS_ICONINDEX     8
#define PID_IS_ICONFILE      9
#define PID_IS_WHATSNEW      10
#define PID_IS_AUTHOR        11
#define PID_IS_DESCRIPTION   12
#define PID_IS_COMMENT       13

//
// PROPIDs for Internet Sites (FMTID_InternetSite) to be used with 
// IPropertySetStorage/IPropertyStorage
//
// The known property ids and their variant types are:
//      PID_INTSITE_WHATSNEW     [VT_LPWSTR]   What's New text
//      PID_INTSITE_AUTHOR       [VT_LPWSTR]   Author
//      PID_INTSITE_LASTVISIT    [VT_FILETIME] Time site was last visited
//      PID_INTSITE_LASTMOD      [VT_FILETIME] Time site was last modified
//      PID_INTSITE_VISITCOUNT   [VT_UI4]      Number of times user has visited
//      PID_INTSITE_DESCRIPTION  [VT_LPWSTR]   Description text of site
//      PID_INTSITE_COMMENT      [VT_LPWSTR]   User annotated comment
//      PID_INTSITE_RECURSE      [VT_UI4]      Levels to recurse (0-3)
//      PID_INTSITE_WATCH        [VT_UI4]      PIDISM_ flags
//      PID_INTSITE_SUBSCRIPTION [VT_UI8]      Subscription cookie
//      PID_INTSITE_URL          [VT_LPWSTR]   URL
//      PID_INTSITE_TITLE        [VT_LPWSTR]   Title
//      PID_INTSITE_CODEPAGE     [VT_UI4]      Codepage of the document
//      PID_INTSITE_TRACKING     [VT_UI4]      Tracking
//


#define PID_INTSITE_WHATSNEW      2
#define PID_INTSITE_AUTHOR        3
#define PID_INTSITE_LASTVISIT     4
#define PID_INTSITE_LASTMOD       5
#define PID_INTSITE_VISITCOUNT    6
#define PID_INTSITE_DESCRIPTION   7
#define PID_INTSITE_COMMENT       8
#define PID_INTSITE_FLAGS         9                         
#define PID_INTSITE_CONTENTLEN    10                        
#define PID_INTSITE_CONTENTCODE   11                        
#define PID_INTSITE_RECURSE       12
#define PID_INTSITE_WATCH         13
#define PID_INTSITE_SUBSCRIPTION  14
#define PID_INTSITE_URL           15
#define PID_INTSITE_TITLE         16
#define PID_INTSITE_CODEPAGE      18
#define PID_INTSITE_TRACKING      19

// Flags for PID_IS_FLAGS                               
#define PIDISF_RECENTLYCHANGED  0x00000001              
#define PIDISF_CACHEDSTICKY     0x00000002              
#define PIDISF_CACHEIMAGES      0x00000010              
#define PIDISF_FOLLOWALLLINKS   0x00000020              

// Values for PID_INTSITE_WATCH
#define PIDISM_GLOBAL           0       // Monitor based on global setting
#define PIDISM_WATCH            1       // User says watch
#define PIDISM_DONTWATCH        2       // User says don't watch


////////////////////////////////////////////////////////////////////
//
// The shell keeps track of some per-user state to handle display
// options that is of major interest to ISVs.
// The key one requested right now is "DoubleClickInWebView".
typedef struct {
    BOOL fShowAllObjects : 1;
    BOOL fShowExtensions : 1;
    BOOL fNoConfirmRecycle : 1;
    BOOL fShowSysFiles : 1;
    BOOL fShowCompColor : 1;
    BOOL fDoubleClickInWebView : 1;
    BOOL fDesktopHTML : 1;
    BOOL fWin95Classic : 1;
    BOOL fDontPrettyPath : 1;
    BOOL fShowAttribCol : 1;
    BOOL fMapNetDrvBtn : 1;
    BOOL fShowInfoTip : 1;
    BOOL fHideIcons : 1;
    UINT fRestFlags : 3;
} SHELLFLAGSTATE, * LPSHELLFLAGSTATE;

#define SSF_SHOWALLOBJECTS          0x0001
#define SSF_SHOWEXTENSIONS          0x0002
#define SSF_SHOWCOMPCOLOR           0x0008
#define SSF_SHOWSYSFILES            0x0020
#define SSF_DOUBLECLICKINWEBVIEW    0x0080
#define SSF_SHOWATTRIBCOL           0x0100
#define SSF_DESKTOPHTML             0x0200
#define SSF_WIN95CLASSIC            0x0400
#define SSF_DONTPRETTYPATH          0x0800
#define SSF_SHOWINFOTIP             0x2000
#define SSF_MAPNETDRVBUTTON         0x1000
#define SSF_NOCONFIRMRECYCLE        0x8000
#define SSF_HIDEICONS               0x4000


// SHGetSettings(LPSHELLFLAGSTATE lpss, DWORD dwMask)
//
// Specify the bits you are interested in in dwMask and they will be
// filled out in the lpss structure.
//
// When these settings change, a WM_SETTINGCHANGE message is sent
// with the string lParam value of "ShellState".
//
void WINAPI SHGetSettings(LPSHELLFLAGSTATE lpsfs, DWORD dwMask);

#ifdef __urlmon_h__
//    NOTE: urlmon.h must be included before shlobj.h to access this function.
//
//    SoftwareUpdateMessageBox
//
//    Provides a standard message box for the alerting the user that a software
//    update is available or installed. No UI will be displayed if there is no
//    update available or if the available update version is less than or equal
//    to the Advertised update version.
//
//    hWnd                - [in] Handle of owner window
//    szDistUnit          - [in] Unique identifier string for a code distribution unit. For
//                               ActiveX controls and Active Setup installed components, this
//                               is typically a GUID string.
//    dwFlags             - [in] Must be 0.
//    psdi                - [in,out] Pointer to SOFTDISTINFO ( see URLMon.h ). May be NULL.
//                                cbSize should be initialized
//                                by the caller to sizeof(SOFTDISTINFO), dwReserved should be set to 0.
//
//    RETURNS:
//
//    IDNO     - The user chose cancel. If *pbRemind is FALSE, the caller should save the 
//               update version from the SOFTDISTINFO and pass it in as the Advertised
//               version in future calls.
//
//    IDYES    - The user has selected Update Now/About Update. The caller should navigate to
//               the SOFTDISTINFO's pszHREF to initiate the install or learn about it.
//               The caller should save the update version from the SOFTDISTINFO and pass
//               it in as the Advertised version in future calls.
//
//    IDIGNORE - There is no pending software update. Note: There is
//               no Ignore button in the standard UI. This occurs if the available
//               version is less than the installed version or is not present or if the
//               Advertised version is greater than or equal to the update version.
//
//    IDABORT  - An error occured. Call GetSoftwareUpdateInfo() for a more specific HRESULT.
//               Note: There is no Abort button in the standard UI.


SHDOCAPI_(DWORD) SoftwareUpdateMessageBox( HWND hWnd,
                                           LPCWSTR szDistUnit,
                                           DWORD dwFlags,
                                           LPSOFTDISTINFO psdi );
#endif // if __urlmon_h__

#ifdef __cplusplus
}

#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif // _SHLOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\inc\rpc.h ===
/*++

Copyright (c) 1991-1997 Microsoft Corporation

Module Name:

    rpc.h

Abstract:

    Master include file for RPC applications.

--*/

#if !defined( RPC_NO_WINDOWS_H ) && !defined( MAC ) && !defined( _MAC )
#include <windows.h>
#endif // RPC_NO_WINDOWS_H

#ifndef __RPC_H__
#define __RPC_H__

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------------------------
// platform specific defines
//-------------------------------------------------------------

//-------------------  MAC ---------------------------
#if defined( MAC ) || defined( _MAC )

#define __RPC_MAC__
// Set the packing level for RPC structures.

#include <pshpack2.h>

//-------------------  WIN32 ---------------------------
#else // win32 platforms

#define __RPC_WIN32__

#endif


#ifndef __MIDL_USER_DEFINED
#define midl_user_allocate MIDL_user_allocate
#define midl_user_free     MIDL_user_free
#define __MIDL_USER_DEFINED
#endif

typedef void * I_RPC_HANDLE;
typedef long RPC_STATUS;

#ifndef _MAC
#define RPC_UNICODE_SUPPORTED
#endif //_MAC


#ifdef __RPC_MAC__
#	define __RPC_FAR
#	define __RPC_API
#	define __RPC_USER
#	define __RPC_STUB
#	define RPC_ENTRY
#elif   (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#	define __RPC_FAR
#	define __RPC_API  __stdcall
#	define __RPC_USER __stdcall
#	define __RPC_STUB __stdcall
#	define  RPC_ENTRY __stdcall
#else
#	define __RPC_FAR
#	define __RPC_API
#	define __RPC_USER
#	define __RPC_STUB
#endif

// Some RPC platforms don't define DECLSPEC_IMPORT
#if !defined(DECLSPEC_IMPORT)
#if (defined(_M_MRX000) || defined(_M_IX86) || defined(_M_ALPHA) || defined(_M_PPC)) && !defined(MIDL_PASS)
#define DECLSPEC_IMPORT __declspec(dllimport)
#else
#define DECLSPEC_IMPORT
#endif
#endif

#if !defined(_RPCRT4_)
#define RPCRTAPI DECLSPEC_IMPORT
#else
#define RPCRTAPI
#endif

#if !defined(_RPCNS4_)
#define RPCNSAPI DECLSPEC_IMPORT
#else
#define RPCNSAPI
#endif

#ifdef IN
#undef IN
#undef OUT
#undef OPTIONAL
#endif /* IN */

#ifdef __RPC_MAC__

#include <setjmp.h>

#define RPCXCWORD (sizeof(jmp_buf)/sizeof(int))

#pragma warning( disable: 4005 ) 
#include <rpcdce.h>
#include <rpcnsi.h>
#include <rpcerr.h>
#include <rpcmac.h>
#pragma warning( default :  4005 )

typedef void  (RPC_ENTRY *MACYIELDCALLBACK)(/*OSErr*/ short *) ; 
RPC_STATUS RPC_ENTRY
RpcMacSetYieldInfo(
	MACYIELDCALLBACK pfnCallback) ;

#if !defined(UNALIGNED)
#define UNALIGNED
#endif

#include <poppack.h>

#else // __RPC_MAC__

#include <rpcdce.h>
#include <rpcnsi.h>
#include <rpcnterr.h>
#include <excpt.h>
#include <winerror.h>

#define RpcTryExcept \
    __try \
        {

// trystmts

#define RpcExcept(expr) \
        } \
    __except (expr) \
        {

// exceptstmts

#define RpcEndExcept \
        }

#define RpcTryFinally \
    __try \
        {

// trystmts

#define RpcFinally \
        } \
    __finally \
        {

// finallystmts

#define RpcEndFinally \
        }

#define RpcExceptionCode() GetExceptionCode()
#define RpcAbnormalTermination() AbnormalTermination()

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcImpersonateClient (
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcRevertToSelfEx (
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcRevertToSelf (
    );

RPCRTAPI
long
RPC_ENTRY
I_RpcMapWin32Status (
    IN RPC_STATUS Status
    );

#endif // __RPC_MAC__

// Definitions which depend on windows.h
#if !defined( RPC_NO_WINDOWS_H ) && !defined( MAC ) && !defined( _MAC )

#include <rpcasync.h>

#endif // RPC_NO_WINDOWS_H

#ifdef __cplusplus
}
#endif

#endif // __RPC_H__


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\inc\thmbguid.h ===
//===========================================================================
//
// Copyright (c) Microsoft Corporation 1995-1998
//
// File: shlguid.h
//
//===========================================================================


// Thumbnail Guids
DEFINE_GUID(IID_IThumbnail,             0x6d45a930L, 0xf71a, 0x11d0, 0x9e, 0xa7, 0x00, 0x80, 0x5f, 0x71, 0x47, 0x72);
DEFINE_GUID(CLSID_Thumbnail,            0x7487cd30L, 0xf71a, 0x11d0, 0x9e, 0xa7, 0x00, 0x80, 0x5f, 0x71, 0x47, 0x72);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\inc\rpcasync.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    rpcasync.h

Abstract:

    This module contains the RPC runtime APIs needed to use
    [async] RPC features.

--*/

#ifndef __RPCASYNC_H__
#define __RPCASYNC_H__

#ifdef __cplusplus
extern "C" {
#endif

#define RPC_ASYNC_VERSION_1_0     sizeof(RPC_ASYNC_STATE)

typedef
enum _RPC_NOTIFICATION_TYPES
{
    RpcNotificationTypeNone,
    RpcNotificationTypeEvent,
    RpcNotificationTypeApc, 
    RpcNotificationTypeIoc,
    RpcNotificationTypeHwnd,
    RpcNotificationTypeCallback
} RPC_NOTIFICATION_TYPES;

typedef
enum _RPC_ASYNC_EVENT {
    RpcCallComplete,
    RpcSendComplete,
    RpcReceiveComplete
    } RPC_ASYNC_EVENT;

typedef void RPC_ENTRY
RPCNOTIFICATION_ROUTINE (
                  struct _RPC_ASYNC_STATE *pAsync,
                  void *Context,                              
                  RPC_ASYNC_EVENT Event);
typedef RPCNOTIFICATION_ROUTINE *PFN_RPCNOTIFICATION_ROUTINE;
    
typedef struct _RPC_ASYNC_STATE {
    unsigned int    Size; // size of this structure
    unsigned long   Signature;
    long   Lock;
    unsigned long   Flags;
    void           *StubInfo;
    void           *UserInfo;
    void           *RuntimeInfo;
    RPC_ASYNC_EVENT Event;

    RPC_NOTIFICATION_TYPES NotificationType;
    union {
        //
        // Notification by APC
        //
        struct {
            PFN_RPCNOTIFICATION_ROUTINE NotificationRoutine;
            HANDLE hThread;
            } APC;

        //
        // Notification by IO completion port
        //
        struct {
            HANDLE hIOPort;
            DWORD dwNumberOfBytesTransferred;
            DWORD dwCompletionKey;
            LPOVERLAPPED lpOverlapped;
            } IOC;

        //
        // Notification by window message
        //
        struct {
            HWND hWnd;
            UINT Msg;
            } HWND;


        //
        // Notification by event
        //
        HANDLE hEvent;

        //
        // Notification by callback function
        //
        // This option is available only to OLE
        //
        PFN_RPCNOTIFICATION_ROUTINE NotificationRoutine;
        } u;

    long Reserved[4]; 
    } RPC_ASYNC_STATE, *PRPC_ASYNC_STATE;

// Possible values for Flags
#define RPC_C_NOTIFY_ON_SEND_COMPLETE      0x1
#define RPC_C_INFINITE_TIMEOUT             INFINITE

#define RpcAsyncGetCallHandle(pAsync) (((PRPC_ASYNC_STATE) pAsync)->RuntimeInfo)

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncInitializeHandle (
    PRPC_ASYNC_STATE pAsync,
    unsigned int     Size
    );
                      
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncRegisterInfo (
    PRPC_ASYNC_STATE pAsync
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncGetCallStatus (
    PRPC_ASYNC_STATE pAsync
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncCompleteCall (
    PRPC_ASYNC_STATE pAsync,
    void *Reply
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncAbortCall (
    PRPC_ASYNC_STATE pAsync,
    unsigned long ExceptionCode
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncCancelCall (
    IN PRPC_ASYNC_STATE pAsync,
    IN BOOL fAbort
    ) ;

//
// Internal APIs
//
RPC_STATUS RPC_ENTRY
I_RpcAsyncSetHandle (
    IN  PRPC_MESSAGE Message,
    IN  PRPC_ASYNC_STATE pAsync
    );

RPC_STATUS RPC_ENTRY
I_RpcAsyncAbortCall (
    IN PRPC_ASYNC_STATE pAsync,
    IN unsigned long ExceptionCode
    ) ;


//
// This stuff is in here so we don't break ole, stubs and the tests
// remove before we ship
//
#define RpcInitializeAsyncHandle  RpcAsyncInitializeHandle
#define RpcRegisterAsyncInfo  RpcAsyncRegisterInfo
#define RpcGetAsyncCallStatus  RpcAsyncGetCallStatus
#define RpcCompleteAsyncCall  RpcAsyncCompleteCall
#define RpcAbortAsyncCall  RpcAsyncAbortCall
#define RpcCancelAsyncCall  RpcAsyncCancelCall
#define I_RpcSetAsyncHandle  I_RpcAsyncSetHandle
#define I_RpcAbortAsyncCall  I_RpcAsyncAbortCall

#ifdef __cplusplus
}
#endif

#endif /* __RPCASYNC_H__ */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\inc\msterr.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1991 - 1997.
//
//  Contents:  Scheduling Agent interface error definitions.
//
//--------------------------------------------------------------------------
#ifndef _MSTERR_H_
#define _MSTERR_H_
// Define the status type.
// Define the severities
#ifdef FACILITY_ITF
#undef FACILITY_ITF
#endif
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_ITF                     0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_COERROR          0x2


//
// MessageId: SCHED_S_TASK_READY
//
// MessageText:
//
//  The task is ready to run at its next scheduled time.
//
#define SCHED_S_TASK_READY               ((HRESULT)0x00041300L)

//
// MessageId: SCHED_S_TASK_RUNNING
//
// MessageText:
//
//  The task is currently running.
//
#define SCHED_S_TASK_RUNNING             ((HRESULT)0x00041301L)

//
// MessageId: SCHED_S_TASK_DISABLED
//
// MessageText:
//
//  The task will not run at the scheduled times because it has been disabled.
//
#define SCHED_S_TASK_DISABLED            ((HRESULT)0x00041302L)

//
// MessageId: SCHED_S_TASK_HAS_NOT_RUN
//
// MessageText:
//
//  The task has not yet run.
//
#define SCHED_S_TASK_HAS_NOT_RUN         ((HRESULT)0x00041303L)

//
// MessageId: SCHED_S_TASK_NO_MORE_RUNS
//
// MessageText:
//
//  There are no more runs scheduled for this task.
//
#define SCHED_S_TASK_NO_MORE_RUNS        ((HRESULT)0x00041304L)

//
// MessageId: SCHED_S_TASK_NOT_SCHEDULED
//
// MessageText:
//
//  One or more of the properties that are needed to run this task on a schedule have not been set.
//
#define SCHED_S_TASK_NOT_SCHEDULED       ((HRESULT)0x00041305L)

//
// MessageId: SCHED_S_TASK_TERMINATED
//
// MessageText:
//
//  The last run of the task was terminated by the user.
//
#define SCHED_S_TASK_TERMINATED          ((HRESULT)0x00041306L)

//
// MessageId: SCHED_S_TASK_NO_VALID_TRIGGERS
//
// MessageText:
//
//  Either the task has no triggers or the existing triggers are disabled or not set.
//
#define SCHED_S_TASK_NO_VALID_TRIGGERS   ((HRESULT)0x00041307L)

//
// MessageId: SCHED_S_EVENT_TRIGGER
//
// MessageText:
//
//  Event triggers don't have set run times.
//
#define SCHED_S_EVENT_TRIGGER            ((HRESULT)0x00041308L)

//
// MessageId: SCHED_E_TRIGGER_NOT_FOUND
//
// MessageText:
//
//  Trigger not found.
//
#define SCHED_E_TRIGGER_NOT_FOUND        ((HRESULT)0x80041309L)

//
// MessageId: SCHED_E_TASK_NOT_READY
//
// MessageText:
//
//  One or more of the properties that are needed to run this task have not been set.
//
#define SCHED_E_TASK_NOT_READY           ((HRESULT)0x8004130AL)

//
// MessageId: SCHED_E_TASK_NOT_RUNNING
//
// MessageText:
//
//  There is no running instance of the task to terminate.
//
#define SCHED_E_TASK_NOT_RUNNING         ((HRESULT)0x8004130BL)

//
// MessageId: SCHED_E_SERVICE_NOT_INSTALLED
//
// MessageText:
//
//  The Task Scheduler Service is not installed on this computer.
//
#define SCHED_E_SERVICE_NOT_INSTALLED    ((HRESULT)0x8004130CL)

//
// MessageId: SCHED_E_CANNOT_OPEN_TASK
//
// MessageText:
//
//  The task object could not be opened.
//
#define SCHED_E_CANNOT_OPEN_TASK         ((HRESULT)0x8004130DL)

//
// MessageId: SCHED_E_INVALID_TASK
//
// MessageText:
//
//  The object is either an invalid task object or is not a task object.
//
#define SCHED_E_INVALID_TASK             ((HRESULT)0x8004130EL)

//
// MessageId: SCHED_E_ACCOUNT_INFORMATION_NOT_SET
//
// MessageText:
//
//  No account information could be found in the Task Scheduler security database for the task indicated.
//
#define SCHED_E_ACCOUNT_INFORMATION_NOT_SET ((HRESULT)0x8004130FL)

//
// MessageId: SCHED_E_ACCOUNT_NAME_NOT_FOUND
//
// MessageText:
//
//  Unable to establish existence of the account specified.
//
#define SCHED_E_ACCOUNT_NAME_NOT_FOUND   ((HRESULT)0x80041310L)

//
// MessageId: SCHED_E_ACCOUNT_DBASE_CORRUPT
//
// MessageText:
//
//  Corruption was detected in the Task Scheduler security database; the database has been reset.
//
#define SCHED_E_ACCOUNT_DBASE_CORRUPT    ((HRESULT)0x80041311L)

//
// MessageId: SCHED_E_NO_SECURITY_SERVICES
//
// MessageText:
//
//  Task Scheduler security services are available only on Windows NT.
//
#define SCHED_E_NO_SECURITY_SERVICES     ((HRESULT)0x80041312L)

//
// MessageId: SCHED_E_UNKNOWN_OBJECT_VERSION
//
// MessageText:
//
//  The task object version is either unsupported or invalid.
//
#define SCHED_E_UNKNOWN_OBJECT_VERSION   ((HRESULT)0x80041313L)

#endif // _MSTERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\inc\rpcndr.h ===
/*++

Copyright (c) 1992-1997 Microsoft Corporation

Module Name:

    rpcndr.h

Abstract:

    Definitions for stub data structures and prototypes of helper functions.

Author:

    DonnaLi (01-01-91)

Environment:

    DOS, Win 3.X, and Win/NT.

Revision History:

   DONNALI  08-29-91     Start recording history
   donnali  09-11-91     change conversion macros
   donnali  09-18-91     check in files for moving
   STEVEZ   10-15-91     Merge with NT tree
   donnali  10-28-91     add prototype
   donnali  11-19-91     bugfix for strings
   MIKEMON  12-17-91     DCE runtime API conversion
   donnali  03-24-92     change rpc public header f
   STEVEZ   04-04-92     add nsi include
   mikemon  04-18-92     security support and misc
   DovhH    04-24-24     Changed signature of <int>_from_ndr
                         (to unsigned <int>)
                         Added <base_type>_array_from_ndr routines
   RyszardK 06-17-93     Added support for hyper
   VibhasC  09-11-93     Created rpcndrn.h
   DKays    10-14-93     Fixed up rpcndrn.h MIDL 2.0
   RyszardK 01-15-94     Merged in the midl 2.0 changes from rpcndrn.h
   Stevebl  04-22-96     Hookole support changes to MIDL_*_INFO
   RyszardK 05-20-97     Added async support, started version at 450.

--*/

// This version of the rpcproxy.h file corresponds to MIDL version 3.3.106
// used with NT5 beta env from build #1574 on.

#ifndef __RPCNDR_H_VERSION__
#define __RPCNDR_H_VERSION__        ( 450 )
#endif // __RPCNDR_H_VERSION__


#ifndef __RPCNDR_H__
#define __RPCNDR_H__

#ifdef __REQUIRED_RPCNDR_H_VERSION__
    #if ( __RPCNDR_H_VERSION__ < __REQUIRED_RPCNDR_H_VERSION__ )
        #error incorrect <rpcndr.h> version. Use the header that matches with the MIDL compiler.
    #endif 
#endif


//
// Set the packing level for RPC structures for Dos, Windows and Mac.
//

#if defined(__RPC_DOS__) || defined(__RPC_WIN16__) || defined(__RPC_MAC__)
#pragma pack(2)
#endif

#if defined(__RPC_MAC__)
#define _MAC_
#endif

#include <rpcnsip.h>

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************

     Network Computing Architecture (NCA) definition:

     Network Data Representation: (NDR) Label format:
     An unsigned long (32 bits) with the following layout:

     3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
     1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
    +---------------+---------------+---------------+-------+-------+
    |   Reserved    |   Reserved    |Floating point | Int   | Char  |
    |               |               |Representation | Rep.  | Rep.  |
    +---------------+---------------+---------------+-------+-------+

     Where

         Reserved:

             Must be zero (0) for NCA 1.5 and NCA 2.0.

         Floating point Representation is:

             0 - IEEE
             1 - VAX
             2 - Cray
             3 - IBM

         Int Rep. is Integer Representation:

             0 - Big Endian
             1 - Little Endian

         Char Rep. is Character Representation:

             0 - ASCII
             1 - EBCDIC

     The Microsoft Local Data Representation (for all platforms which are
     of interest currently is edefined below:

 ****************************************************************************/

#define NDR_CHAR_REP_MASK               (unsigned long)0X0000000FL
#define NDR_INT_REP_MASK                (unsigned long)0X000000F0L
#define NDR_FLOAT_REP_MASK              (unsigned long)0X0000FF00L

#define NDR_LITTLE_ENDIAN               (unsigned long)0X00000010L
#define NDR_BIG_ENDIAN                  (unsigned long)0X00000000L

#define NDR_IEEE_FLOAT                  (unsigned long)0X00000000L
#define NDR_VAX_FLOAT                   (unsigned long)0X00000100L

#define NDR_ASCII_CHAR                  (unsigned long)0X00000000L
#define NDR_EBCDIC_CHAR                 (unsigned long)0X00000001L

#if defined(__RPC_MAC__)
#define NDR_LOCAL_DATA_REPRESENTATION   (unsigned long)0X00000000L
#define NDR_LOCAL_ENDIAN                NDR_BIG_ENDIAN
#else
#define NDR_LOCAL_DATA_REPRESENTATION   (unsigned long)0X00000010L
#define NDR_LOCAL_ENDIAN                NDR_LITTLE_ENDIAN
#endif


/****************************************************************************
 *  Macros for targeted platforms
 ****************************************************************************/

#if (0x500 <= _WIN32_WINNT)
#define TARGET_IS_NT50_OR_LATER                   1
#else
#define TARGET_IS_NT50_OR_LATER                   0
#endif

#if (defined(_WIN32_DCOM) || 0x400 <= _WIN32_WINNT)
#define TARGET_IS_NT40_OR_LATER                   1
#else
#define TARGET_IS_NT40_OR_LATER                   0
#endif

#if (0x400 <= WINVER)
#define TARGET_IS_NT351_OR_WIN95_OR_LATER         1
#else
#define TARGET_IS_NT351_OR_WIN95_OR_LATER         0
#endif

/****************************************************************************
 *  Other MIDL base types / predefined types:
 ****************************************************************************/

#define small char
typedef unsigned char byte;
typedef unsigned char boolean;

#ifndef _HYPER_DEFINED
#define _HYPER_DEFINED

#if !defined(__RPC_DOS__) && !defined(__RPC_WIN16__) && !defined(__RPC_MAC__) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64))
#define  hyper           __int64
#define MIDL_uhyper  unsigned __int64
#else
typedef double  hyper;
typedef double MIDL_uhyper;
#endif

#endif // _HYPER_DEFINED

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifdef __RPC_DOS__
#define __RPC_CALLEE       __far __pascal
#endif

#ifdef __RPC_WIN16__
#define __RPC_CALLEE       __far __pascal __export
#endif

#ifdef __RPC_WIN32__
#if   (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#define __RPC_CALLEE       __stdcall
#else
#define __RPC_CALLEE
#endif
#endif

#ifdef __RPC_MAC__
#define __RPC_CALLEE __far
#endif

#ifndef __MIDL_USER_DEFINED
#define midl_user_allocate MIDL_user_allocate
#define midl_user_free     MIDL_user_free
#define __MIDL_USER_DEFINED
#endif

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void             __RPC_USER MIDL_user_free( void __RPC_FAR * );

#ifdef __RPC_WIN16__
#define RPC_VAR_ENTRY __export __cdecl
#else
#define RPC_VAR_ENTRY __cdecl
#endif


/* winnt only */
#if defined(_M_MRX000) || defined(_M_IX86) || defined(_M_ALPHA)
#define __MIDL_DECLSPEC_DLLIMPORT   __declspec(dllimport)
#define __MIDL_DECLSPEC_DLLEXPORT   __declspec(dllexport)
#else
#define __MIDL_DECLSPEC_DLLIMPORT
#define __MIDL_DECLSPEC_DLLEXPORT
#endif




/****************************************************************************
 * Context handle management related definitions:
 *
 * Client and Server Contexts.
 *
 ****************************************************************************/

typedef void __RPC_FAR * NDR_CCONTEXT;

typedef struct
    {
    void __RPC_FAR * pad[2];
    void __RPC_FAR * userContext;
    } __RPC_FAR * NDR_SCONTEXT;

#define NDRSContextValue(hContext) (&(hContext)->userContext)

#define cbNDRContext 20         /* size of context on WIRE */

typedef void (__RPC_USER __RPC_FAR * NDR_RUNDOWN)(void __RPC_FAR * context);

typedef struct _SCONTEXT_QUEUE {
    unsigned long   NumberOfObjects;
    NDR_SCONTEXT  * ArrayOfObjects;
    } SCONTEXT_QUEUE, __RPC_FAR * PSCONTEXT_QUEUE;

RPCRTAPI
RPC_BINDING_HANDLE
RPC_ENTRY
NDRCContextBinding (
    IN NDR_CCONTEXT     CContext
    );

RPCRTAPI
void
RPC_ENTRY
NDRCContextMarshall (
    IN  NDR_CCONTEXT    CContext,
    OUT void __RPC_FAR *pBuff
    );

RPCRTAPI
void
RPC_ENTRY
NDRCContextUnmarshall (
    OUT NDR_CCONTEXT __RPC_FAR *pCContext,
    IN  RPC_BINDING_HANDLE      hBinding,
    IN  void __RPC_FAR *        pBuff,
    IN  unsigned long           DataRepresentation
    );

RPCRTAPI
void
RPC_ENTRY
NDRSContextMarshall (
    IN  NDR_SCONTEXT    CContext,
    OUT void __RPC_FAR *pBuff,
    IN  NDR_RUNDOWN     userRunDownIn
    );

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NDRSContextUnmarshall (
    IN  void __RPC_FAR *pBuff,
    IN  unsigned long   DataRepresentation
    );

RPCRTAPI
void 
RPC_ENTRY
NDRSContextMarshallEx (
    IN  RPC_BINDING_HANDLE  BindingHandle, 
    IN  NDR_SCONTEXT        CContext,
    OUT void __RPC_FAR     *pBuff,
    IN  NDR_RUNDOWN         userRunDownIn
    );

RPCRTAPI
NDR_SCONTEXT 
RPC_ENTRY
NDRSContextUnmarshallEx (
    IN  RPC_BINDING_HANDLE  BindingHandle, 
    IN  void __RPC_FAR     *pBuff,
    IN  unsigned long       DataRepresentation
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsDestroyClientContext (
    IN void __RPC_FAR * __RPC_FAR * ContextHandle
    );


/****************************************************************************
    NDR conversion related definitions.
 ****************************************************************************/

#define byte_from_ndr(source, target) \
    { \
    *(target) = *(*(char __RPC_FAR * __RPC_FAR *)&(source)->Buffer)++; \
    }

#define byte_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char __RPC_FAR *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long __RPC_FAR *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

#define boolean_from_ndr(source, target) \
    { \
    *(target) = *(*(char __RPC_FAR * __RPC_FAR *)&(source)->Buffer)++; \
    }

#define boolean_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char __RPC_FAR *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long __RPC_FAR *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

#define small_from_ndr(source, target) \
    { \
    *(target) = *(*(char __RPC_FAR * __RPC_FAR *)&(source)->Buffer)++; \
    }

#define small_from_ndr_temp(source, target, format) \
    { \
    *(target) = *(*(char __RPC_FAR * __RPC_FAR *)(source))++; \
    }

#define small_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char __RPC_FAR *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long __RPC_FAR *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

/****************************************************************************
    Platform specific mapping of c-runtime functions.
 ****************************************************************************/

#ifdef __RPC_DOS__
#define MIDL_ascii_strlen(string) \
    _fstrlen(string)
#define MIDL_ascii_strcpy(target,source) \
    _fstrcpy(target,source)
#define MIDL_memset(s,c,n) \
    _fmemset(s,c,n)
#endif

#ifdef __RPC_WIN16__
#define MIDL_ascii_strlen(string) \
    _fstrlen(string)
#define MIDL_ascii_strcpy(target,source) \
    _fstrcpy(target,source)
#define MIDL_memset(s,c,n) \
    _fmemset(s,c,n)
#endif

#if defined(__RPC_WIN32__) || defined(__RPC_MAC__)
#define MIDL_ascii_strlen(string) \
    strlen(string)
#define MIDL_ascii_strcpy(target,source) \
    strcpy(target,source)
#define MIDL_memset(s,c,n) \
    memset(s,c,n)
#endif

/****************************************************************************
    Ndr Library helper function prototypes for MIDL 1.0 ndr functions.
 ****************************************************************************/

RPCRTAPI
void
RPC_ENTRY
NDRcopy (
    IN void __RPC_FAR *pTarget,
    IN void __RPC_FAR *pSource,
    IN unsigned int size
    );

RPCRTAPI
size_t
RPC_ENTRY
MIDL_wchar_strlen (
    IN wchar_t __RPC_FAR *   s
    );

RPCRTAPI
void
RPC_ENTRY
MIDL_wchar_strcpy (
    OUT void __RPC_FAR *     t,
    IN wchar_t __RPC_FAR *   s
    );

RPCRTAPI
void
RPC_ENTRY
char_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT unsigned char __RPC_FAR *                 Target
    );

RPCRTAPI
void
RPC_ENTRY
char_array_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT unsigned char __RPC_FAR *                 Target
    );

RPCRTAPI
void
RPC_ENTRY
short_from_ndr (
    IN OUT PRPC_MESSAGE                           source,
    OUT unsigned short __RPC_FAR *                target
    );

RPCRTAPI
void
RPC_ENTRY
short_array_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT unsigned short __RPC_FAR *                Target
    );

RPCRTAPI
void
RPC_ENTRY
short_from_ndr_temp (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR *  source,
    OUT unsigned short __RPC_FAR *                target,
    IN unsigned long                              format
    );

RPCRTAPI
void
RPC_ENTRY
long_from_ndr (
    IN OUT PRPC_MESSAGE                           source,
    OUT unsigned long __RPC_FAR *                 target
    );

RPCRTAPI
void
RPC_ENTRY
long_array_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT unsigned long __RPC_FAR *                 Target
    );

RPCRTAPI
void
RPC_ENTRY
long_from_ndr_temp (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR *  source,
    OUT unsigned long __RPC_FAR *                 target,
    IN unsigned long                              format
    );

RPCRTAPI
void
RPC_ENTRY
enum_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT unsigned int __RPC_FAR *                  Target
    );

RPCRTAPI
void
RPC_ENTRY
float_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT void __RPC_FAR *                          Target
    );

RPCRTAPI
void
RPC_ENTRY
float_array_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT void __RPC_FAR *                          Target
    );

RPCRTAPI
void
RPC_ENTRY
double_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT void __RPC_FAR *                          Target
    );

RPCRTAPI
void
RPC_ENTRY
double_array_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT void __RPC_FAR *                          Target
    );

RPCRTAPI
void
RPC_ENTRY
hyper_from_ndr (
    IN OUT PRPC_MESSAGE                           source,
    OUT    hyper __RPC_FAR *                      target
    );

RPCRTAPI
void
RPC_ENTRY
hyper_array_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT          hyper __RPC_FAR *                Target
    );

RPCRTAPI
void
RPC_ENTRY
hyper_from_ndr_temp (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR *  source,
    OUT             hyper __RPC_FAR *             target,
    IN   unsigned   long                          format
    );

RPCRTAPI
void
RPC_ENTRY
data_from_ndr (
    PRPC_MESSAGE                                  source,
    void __RPC_FAR *                              target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void
RPC_ENTRY
data_into_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void
RPC_ENTRY
tree_into_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void
RPC_ENTRY
data_size_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void
RPC_ENTRY
tree_size_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void
RPC_ENTRY
tree_peek_ndr (
    PRPC_MESSAGE                                  source,
    unsigned char __RPC_FAR * __RPC_FAR *         buffer,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void __RPC_FAR *
RPC_ENTRY
midl_allocate (
    size_t      size
    );

/****************************************************************************
    MIDL 2.0 ndr definitions.
 ****************************************************************************/

typedef unsigned long error_status_t;

#define _midl_ma1( p, cast )    *(*( cast **)&p)++
#define _midl_ma2( p, cast )    *(*( cast **)&p)++
#define _midl_ma4( p, cast )    *(*( cast **)&p)++
#define _midl_ma8( p, cast )    *(*( cast **)&p)++

#define _midl_unma1( p, cast )  *(( cast *)p)++
#define _midl_unma2( p, cast )  *(( cast *)p)++
#define _midl_unma3( p, cast )  *(( cast *)p)++
#define _midl_unma4( p, cast )  *(( cast *)p)++

// Some alignment specific macros.


#define _midl_fa2( p )          (p = (RPC_BUFPTR )((unsigned long)(p+1) & 0xfffffffe))
#define _midl_fa4( p )          (p = (RPC_BUFPTR )((unsigned long)(p+3) & 0xfffffffc))
#define _midl_fa8( p )          (p = (RPC_BUFPTR )((unsigned long)(p+7) & 0xfffffff8))

#define _midl_addp( p, n )      (p += n)

// Marshalling macros

#define _midl_marsh_lhs( p, cast )  *(*( cast **)&p)++
#define _midl_marsh_up( mp, p )     *(*(unsigned long **)&mp)++ = (unsigned long)p
#define _midl_advmp( mp )           *(*(unsigned long **)&mp)++
#define _midl_unmarsh_up( p )       (*(*(unsigned long **)&p)++)


////////////////////////////////////////////////////////////////////////////
// Ndr macros.
////////////////////////////////////////////////////////////////////////////

#define NdrMarshConfStringHdr( p, s, l )    (_midl_ma4( p, unsigned long) = s, \
                                            _midl_ma4( p, unsigned long) = 0, \
                                            _midl_ma4( p, unsigned long) = l)

#define NdrUnMarshConfStringHdr(p, s, l)    ((s=_midl_unma4(p,unsigned long),\
                                            (_midl_addp(p,4)),               \
                                            (l=_midl_unma4(p,unsigned long))

#define NdrMarshCCtxtHdl(pc,p)  (NDRCContextMarshall( (NDR_CCONTEXT)pc, p ),p+20)

#define NdrUnMarshCCtxtHdl(pc,p,h,drep) \
        (NDRCContextUnmarshall((NDR_CONTEXT)pc,h,p,drep), p+20)

#define NdrUnMarshSCtxtHdl(pc, p,drep)  (pc = NdrSContextUnMarshall(p,drep ))


#define NdrMarshSCtxtHdl(pc,p,rd)   (NdrSContextMarshall((NDR_SCONTEXT)pc,p, (NDR_RUNDOWN)rd)

#define NdrFieldOffset(s,f)     (long)(& (((s __RPC_FAR *)0)->f))
#define NdrFieldPad(s,f,p,t)    (NdrFieldOffset(s,f) - NdrFieldOffset(s,p) - sizeof(t))

#if defined(__RPC_MAC__)
#define NdrFcShort(s)   (unsigned char)(s >> 8), (unsigned char)(s & 0xff)
#define NdrFcLong(s)    (unsigned char)(s >> 24), (unsigned char)((s & 0x00ff0000) >> 16), \
                        (unsigned char)((s & 0x0000ff00) >> 8), (unsigned char)(s & 0xff)
#else
#define NdrFcShort(s)   (unsigned char)(s & 0xff), (unsigned char)(s >> 8)
#define NdrFcLong(s)    (unsigned char)(s & 0xff), (unsigned char)((s & 0x0000ff00) >> 8), \
                        (unsigned char)((s & 0x00ff0000) >> 16), (unsigned char)(s >> 24)
#endif //  Mac

//
// On the server side, the following exceptions are mapped to
// the bad stub data exception if -error stub_data is used.
//

#define RPC_BAD_STUB_DATA_EXCEPTION_FILTER  \
                 ( (RpcExceptionCode() == STATUS_ACCESS_VIOLATION)  || \
                   (RpcExceptionCode() == STATUS_DATATYPE_MISALIGNMENT) || \
                   (RpcExceptionCode() == RPC_X_BAD_STUB_DATA) )

/////////////////////////////////////////////////////////////////////////////
// Some stub helper functions.
/////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// Stub helper structures.
////////////////////////////////////////////////////////////////////////////

struct _MIDL_STUB_MESSAGE;
struct _MIDL_STUB_DESC;
struct _FULL_PTR_XLAT_TABLES;

typedef unsigned char __RPC_FAR * RPC_BUFPTR;
typedef unsigned long             RPC_LENGTH;

// Expression evaluation callback routine prototype.
typedef void (__RPC_USER __RPC_FAR * EXPR_EVAL)( struct _MIDL_STUB_MESSAGE __RPC_FAR * );

typedef const unsigned char __RPC_FAR * PFORMAT_STRING;

/*
 * Multidimensional conformant/varying array struct.
 */
typedef struct
    {
    long                            Dimension;

    /* These fields MUST be (unsigned long *) */
    unsigned long __RPC_FAR *       BufferConformanceMark;
    unsigned long __RPC_FAR *       BufferVarianceMark;

    /* Count arrays, used for top level arrays in -Os stubs */
    unsigned long __RPC_FAR *       MaxCountArray;
    unsigned long __RPC_FAR *       OffsetArray;
    unsigned long __RPC_FAR *       ActualCountArray;
    } ARRAY_INFO, __RPC_FAR *PARRAY_INFO;

/*
 *  Pipe related definitions.
 */

typedef struct _NDR_PIPE_DESC *       PNDR_PIPE_DESC;
typedef struct _NDR_PIPE_MESSAGE *    PNDR_PIPE_MESSAGE;

typedef struct _NDR_ASYNC_MESSAGE *   PNDR_ASYNC_MESSAGE;

/*
 * MIDL Stub Message
 */
#if !defined(__RPC_DOS__) && !defined(__RPC_WIN16__) && !defined(__RPC_MAC__)
#include <pshpack4.h>
#endif

typedef struct _MIDL_STUB_MESSAGE
    {
    /* RPC message structure. */
    PRPC_MESSAGE                RpcMsg;

    /* Pointer into RPC message buffer. */
    unsigned char __RPC_FAR *   Buffer;

    /*
     * These are used internally by the Ndr routines to mark the beginning
     * and end of an incoming RPC buffer.
     */
    unsigned char __RPC_FAR *   BufferStart;
    unsigned char __RPC_FAR *   BufferEnd;

    /*
     * Used internally by the Ndr routines as a place holder in the buffer.
     * On the marshalling side it's used to mark the location where conformance
     * size should be marshalled.
     * On the unmarshalling side it's used to mark the location in the buffer
     * used during pointer unmarshalling to base pointer offsets off of.
     */
    unsigned char __RPC_FAR *   BufferMark;

    /* Set by the buffer sizing routines. */
    unsigned long               BufferLength;

    /* Set by the memory sizing routines. */
    unsigned long               MemorySize;

    /* Pointer to user memory. */
    unsigned char __RPC_FAR *   Memory;

    /* Is the Ndr routine begin called from a client side stub. */
    int                         IsClient;

    /* Can the buffer be re-used for memory on unmarshalling. */
    int                         ReuseBuffer;

    /* Holds the current pointer to an allocate all nodes memory block. */
    unsigned char __RPC_FAR *   AllocAllNodesMemory;

    /* Used for debugging asserts only, remove later. */
    unsigned char __RPC_FAR *   AllocAllNodesMemoryEnd;

    /*
     * Stuff needed while handling complex structures
     */

    /* Ignore imbeded pointers while computing buffer or memory sizes. */
    int                         IgnoreEmbeddedPointers;

    /*
     * This marks the location in the buffer where pointees of a complex
     * struct reside.
     */
    unsigned char __RPC_FAR *   PointerBufferMark;

    /*
     * Used to catch errors in SendReceive.
     */
    unsigned char               fBufferValid;

    /*
     * Obsolete unused field (formerly MaxContextHandleNumber).
     */
    unsigned char               Unused;

    /*
     * Used internally by the Ndr routines.  Holds the max counts for
     * a conformant array.
     */
    unsigned long               MaxCount;

    /*
     * Used internally by the Ndr routines.  Holds the offsets for a varying
     * array.
     */
    unsigned long               Offset;

    /*
     * Used internally by the Ndr routines.  Holds the actual counts for
     * a varying array.
     */
    unsigned long               ActualCount;

    /* Allocation and Free routine to be used by the Ndr routines. */
    void __RPC_FAR *    (__RPC_FAR __RPC_API * pfnAllocate)(size_t);
    void                (__RPC_FAR __RPC_API * pfnFree)(void __RPC_FAR *);

    /*
     * Top of parameter stack.  Used for "single call" stubs during marshalling
     * to hold the beginning of the parameter list on the stack.  Needed to
     * extract parameters which hold attribute values for top level arrays and
     * pointers.
     */
    unsigned char __RPC_FAR *       StackTop;

    /*
     *  Fields used for the transmit_as and represent_as objects.
     *  For represent_as the mapping is: presented=local, transmit=named.
     */
    unsigned char __RPC_FAR *       pPresentedType;
    unsigned char __RPC_FAR *       pTransmitType;

    /*
     * When we first construct a binding on the client side, stick it
     * in the rpcmessage and later call RpcGetBuffer, the handle field
     * in the rpcmessage is changed. That's fine except that we need to
     * have that original handle for use in unmarshalling context handles
     * (the second argument in NDRCContextUnmarshall to be exact). So
     * stash the contructed handle here and extract it when needed.
     */
    handle_t                        SavedHandle;

    /*
     * Pointer back to the stub descriptor.  Use this to get all handle info.
     */
    const struct _MIDL_STUB_DESC __RPC_FAR *    StubDesc;

    /*
     * Full pointer stuff.
     */
    struct _FULL_PTR_XLAT_TABLES __RPC_FAR *    FullPtrXlatTables;

    unsigned long                   FullPtrRefId;

    /*
     * flags
     */

    int                             fCheckBounds;

    int                             fInDontFree       :1;
    int                             fDontCallFreeInst :1;
    int                             fInOnlyParam      :1;
    int                             fHasReturn        :1;

    unsigned long                   dwDestContext;
    void __RPC_FAR *                pvDestContext;

    NDR_SCONTEXT *                  SavedContextHandles;

    long                            ParamNumber;

    struct IRpcChannelBuffer __RPC_FAR *    pRpcChannelBuffer;

    PARRAY_INFO                     pArrayInfo;

    /*
     * This is where the Beta2 stub message ends.
     */

    unsigned long __RPC_FAR *       SizePtrCountArray;
    unsigned long __RPC_FAR *       SizePtrOffsetArray;
    unsigned long __RPC_FAR *       SizePtrLengthArray;

    /*
     * Interpreter argument queue.  Used on server side only.
     */
    void __RPC_FAR *                pArgQueue;

    unsigned long                   dwStubPhase;

    /*
     * Pipe descriptor, defined for the 4.0 release.
     */
    PNDR_PIPE_DESC                  pPipeDesc;

    /*
     *  Async message pointer, an NT 5.0 feature.
     */
    PNDR_ASYNC_MESSAGE              pAsyncMsg;

    unsigned long                   Reserved[3];

    /*
     *  Fields up to this point present since the 3.50 release.
     */

    } MIDL_STUB_MESSAGE, __RPC_FAR *PMIDL_STUB_MESSAGE;

#if !defined(__RPC_DOS__) && !defined(__RPC_WIN16__) && !defined(__RPC_MAC__)
#include <poppack.h>
#endif

/*
 * Generic handle bind/unbind routine pair.
 */
typedef void __RPC_FAR *
        (__RPC_FAR __RPC_API * GENERIC_BINDING_ROUTINE)
        (void __RPC_FAR *);
typedef void
        (__RPC_FAR __RPC_API * GENERIC_UNBIND_ROUTINE)
        (void __RPC_FAR *, unsigned char __RPC_FAR *);

typedef struct _GENERIC_BINDING_ROUTINE_PAIR
    {
    GENERIC_BINDING_ROUTINE     pfnBind;
    GENERIC_UNBIND_ROUTINE      pfnUnbind;
    } GENERIC_BINDING_ROUTINE_PAIR, __RPC_FAR *PGENERIC_BINDING_ROUTINE_PAIR;

typedef struct __GENERIC_BINDING_INFO
    {
    void __RPC_FAR *            pObj;
    unsigned int                Size;
    GENERIC_BINDING_ROUTINE     pfnBind;
    GENERIC_UNBIND_ROUTINE      pfnUnbind;
    } GENERIC_BINDING_INFO, __RPC_FAR *PGENERIC_BINDING_INFO;

// typedef EXPR_EVAL - see above
// typedefs for xmit_as

#if (defined(_MSC_VER)) && !defined(MIDL_PASS)
// a Microsoft C++ compiler
#define NDR_SHAREABLE __inline
#else
#define NDR_SHAREABLE static
#endif


typedef void (__RPC_FAR __RPC_USER * XMIT_HELPER_ROUTINE)
    ( PMIDL_STUB_MESSAGE );

typedef struct _XMIT_ROUTINE_QUINTUPLE
    {
    XMIT_HELPER_ROUTINE     pfnTranslateToXmit;
    XMIT_HELPER_ROUTINE     pfnTranslateFromXmit;
    XMIT_HELPER_ROUTINE     pfnFreeXmit;
    XMIT_HELPER_ROUTINE     pfnFreeInst;
    } XMIT_ROUTINE_QUINTUPLE, __RPC_FAR *PXMIT_ROUTINE_QUINTUPLE;

typedef unsigned long
(__RPC_FAR __RPC_USER * USER_MARSHAL_SIZING_ROUTINE)
    (unsigned long __RPC_FAR *,
     unsigned long,
     void __RPC_FAR * );

typedef unsigned char __RPC_FAR *
(__RPC_FAR __RPC_USER * USER_MARSHAL_MARSHALLING_ROUTINE)
    (unsigned long __RPC_FAR *,
     unsigned char  __RPC_FAR * ,
     void __RPC_FAR * );

typedef unsigned char __RPC_FAR *
(__RPC_FAR __RPC_USER * USER_MARSHAL_UNMARSHALLING_ROUTINE)
    (unsigned long __RPC_FAR *,
     unsigned char  __RPC_FAR * ,
     void __RPC_FAR * );

typedef void (__RPC_FAR __RPC_USER * USER_MARSHAL_FREEING_ROUTINE)
    (unsigned long __RPC_FAR *,
     void __RPC_FAR * );

typedef struct _USER_MARSHAL_ROUTINE_QUADRUPLE
    {
    USER_MARSHAL_SIZING_ROUTINE          pfnBufferSize;
    USER_MARSHAL_MARSHALLING_ROUTINE     pfnMarshall;
    USER_MARSHAL_UNMARSHALLING_ROUTINE   pfnUnmarshall;
    USER_MARSHAL_FREEING_ROUTINE         pfnFree;
    } USER_MARSHAL_ROUTINE_QUADRUPLE;

typedef struct _USER_MARSHAL_CB
{
    unsigned long       Flags;
    PMIDL_STUB_MESSAGE  pStubMsg;
    PFORMAT_STRING      pReserve;
} USER_MARSHAL_CB;


#define USER_CALL_CTXT_MASK(f)  ((f) & 0x00ff)
#define USER_CALL_AUX_MASK(f)   ((f) & 0xff00)
#define GET_USER_DATA_REP(f)    ((f) >> 16)

#define USER_CALL_IS_ASYNC      0x0100      /* aux flag: in an [async] call */


typedef struct _MALLOC_FREE_STRUCT
    {
    void __RPC_FAR *    (__RPC_FAR __RPC_USER * pfnAllocate)(size_t);
    void                (__RPC_FAR __RPC_USER * pfnFree)(void __RPC_FAR *);
    } MALLOC_FREE_STRUCT;

typedef struct _COMM_FAULT_OFFSETS
    {
    short       CommOffset;
    short       FaultOffset;
    } COMM_FAULT_OFFSETS;

/*
 * MIDL Stub Descriptor
 */

typedef struct _MIDL_STUB_DESC
    {

    void __RPC_FAR *    RpcInterfaceInformation;

    void __RPC_FAR *    (__RPC_FAR __RPC_API * pfnAllocate)(size_t);
    void                (__RPC_FAR __RPC_API * pfnFree)(void __RPC_FAR *);

    union
        {
        handle_t __RPC_FAR *            pAutoHandle;
        handle_t __RPC_FAR *            pPrimitiveHandle;
        PGENERIC_BINDING_INFO           pGenericBindingInfo;
        } IMPLICIT_HANDLE_INFO;

    const NDR_RUNDOWN __RPC_FAR *                   apfnNdrRundownRoutines;
    const GENERIC_BINDING_ROUTINE_PAIR __RPC_FAR *  aGenericBindingRoutinePairs;

    const EXPR_EVAL __RPC_FAR *                     apfnExprEval;

    const XMIT_ROUTINE_QUINTUPLE __RPC_FAR *        aXmitQuintuple;

    const unsigned char __RPC_FAR *                 pFormatTypes;

    int                                             fCheckBounds;

    /* Ndr library version. */
    unsigned long                                   Version;

    /*
     * Reserved for future use. (no reserves )
     */

    MALLOC_FREE_STRUCT __RPC_FAR *                  pMallocFreeStruct;

    long                                MIDLVersion;

    const COMM_FAULT_OFFSETS __RPC_FAR *    CommFaultOffsets;

    // New fields for version 3.0+

    const USER_MARSHAL_ROUTINE_QUADRUPLE __RPC_FAR * aUserMarshalQuadruple;

    long                                    Reserved1;
    long                                    Reserved2;
    long                                    Reserved3;
    long                                    Reserved4;
    long                                    Reserved5;

    } MIDL_STUB_DESC;

typedef const MIDL_STUB_DESC __RPC_FAR * PMIDL_STUB_DESC;

typedef void __RPC_FAR * PMIDL_XMIT_TYPE;

/*
 * MIDL Stub Format String.  This is a const in the stub.
 */
#if !defined( RC_INVOKED )
#pragma warning( disable:4200 )
#endif
typedef struct _MIDL_FORMAT_STRING
    {
    short               Pad;
    unsigned char       Format[];
    } MIDL_FORMAT_STRING;
#if !defined( RC_INVOKED )
#pragma warning( default:4200 )
#endif

/*
 * Stub thunk used for some interpreted server stubs.
 */
typedef void (__RPC_FAR __RPC_API * STUB_THUNK)( PMIDL_STUB_MESSAGE );

typedef long (__RPC_FAR __RPC_API * SERVER_ROUTINE)();

/*
 * Server Interpreter's information strucuture.
 */
typedef struct  _MIDL_SERVER_INFO_
    {
    PMIDL_STUB_DESC             pStubDesc;
    const SERVER_ROUTINE *      DispatchTable;
    PFORMAT_STRING              ProcString;
    const unsigned short *      FmtStringOffset;
    const STUB_THUNK *          ThunkTable;
    PFORMAT_STRING              LocalFormatTypes;
    PFORMAT_STRING              LocalProcString;
    const unsigned short *      LocalFmtStringOffset;
    } MIDL_SERVER_INFO, *PMIDL_SERVER_INFO;

/*
 * Stubless object proxy information structure.
 */
typedef struct _MIDL_STUBLESS_PROXY_INFO
    {
    PMIDL_STUB_DESC                     pStubDesc;
    PFORMAT_STRING                      ProcFormatString;
    const unsigned short __RPC_FAR *    FormatStringOffset;
    PFORMAT_STRING                      LocalFormatTypes;
    PFORMAT_STRING                      LocalProcString;
    const unsigned short __RPC_FAR *    LocalFmtStringOffset;
    } MIDL_STUBLESS_PROXY_INFO;

typedef MIDL_STUBLESS_PROXY_INFO __RPC_FAR * PMIDL_STUBLESS_PROXY_INFO;

/*
 * This is the return value from NdrClientCall.
 */
typedef union _CLIENT_CALL_RETURN
    {
    void __RPC_FAR *        Pointer;
    long                    Simple;
    } CLIENT_CALL_RETURN;

/*
 * Full pointer data structures.
 */

typedef enum
        {
        XLAT_SERVER = 1,
        XLAT_CLIENT
        } XLAT_SIDE;

/*
 * Stores the translation for the conversion from a full pointer into it's
 * corresponding ref id.
 */
typedef struct _FULL_PTR_TO_REFID_ELEMENT
    {
    struct _FULL_PTR_TO_REFID_ELEMENT __RPC_FAR *  Next;

    void __RPC_FAR *            Pointer;
    unsigned long       RefId;
    unsigned char       State;
    } FULL_PTR_TO_REFID_ELEMENT, __RPC_FAR *PFULL_PTR_TO_REFID_ELEMENT;

/*
 * Full pointer translation tables.
 */
typedef struct _FULL_PTR_XLAT_TABLES
    {
    /*
     * Ref id to pointer translation information.
     */
    struct
        {
        void __RPC_FAR *__RPC_FAR *             XlatTable;
        unsigned char __RPC_FAR *     StateTable;
        unsigned long       NumberOfEntries;
        } RefIdToPointer;

    /*
     * Pointer to ref id translation information.
     */
    struct
        {
        PFULL_PTR_TO_REFID_ELEMENT __RPC_FAR *  XlatTable;
        unsigned long                   NumberOfBuckets;
        unsigned long                   HashMask;
        } PointerToRefId;

    /*
     * Next ref id to use.
     */
    unsigned long           NextRefId;

    /*
     * Keep track of the translation size we're handling : server or client.
     * This tells us when we have to do reverse translations when we insert
     * new translations.  On the server we must insert a pointer-to-refid
     * translation whenever we insert a refid-to-pointer translation, and
     * vica versa for the client.
     */
    XLAT_SIDE               XlatSide;
    } FULL_PTR_XLAT_TABLES, __RPC_FAR *PFULL_PTR_XLAT_TABLES;

/***************************************************************************
 ** New MIDL 2.0 Ndr routine templates
 ***************************************************************************/

/*
 * Marshall routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrSimpleTypeMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    unsigned char                       FormatChar
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrPointerMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Structures */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrSimpleStructMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantStructMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantVaryingStructMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrHardStructMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrComplexStructMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Arrays */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrFixedArrayMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantArrayMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantVaryingArrayMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrVaryingArrayMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrComplexArrayMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Strings */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrNonConformantStringMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantStringMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Unions */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrEncapsulatedUnionMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrNonEncapsulatedUnionMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Byte count pointer */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrByteCountPointerMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Transmit as and represent as*/

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrXmitOrRepAsMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* User_marshal */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrUserMarshalMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Cairo interface pointer */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrInterfacePointerMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Context handles */

RPCRTAPI
void
RPC_ENTRY
NdrClientContextMarshall(
    PMIDL_STUB_MESSAGE    pStubMsg,
    NDR_CCONTEXT          ContextHandle,
    int                   fCheck
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerContextMarshall(
    PMIDL_STUB_MESSAGE    pStubMsg,
    NDR_SCONTEXT          ContextHandle,
    NDR_RUNDOWN           RundownRoutine
    );

/*
 * Unmarshall routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrSimpleTypeUnmarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    unsigned char                       FormatChar
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrPointerUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Structures */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrSimpleStructUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantStructUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantVaryingStructUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrHardStructUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrComplexStructUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Arrays */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrFixedArrayUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantArrayUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantVaryingArrayUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrVaryingArrayUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrComplexArrayUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Strings */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrNonConformantStringUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantStringUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Unions */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrEncapsulatedUnionUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrNonEncapsulatedUnionUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Byte count pointer */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrByteCountPointerUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Transmit as and represent as*/

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrXmitOrRepAsUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* User_marshal */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrUserMarshalUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Cairo interface pointer */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrInterfacePointerUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Context handles */

RPCRTAPI
void
RPC_ENTRY
NdrClientContextUnmarshall(
    PMIDL_STUB_MESSAGE          pStubMsg,
    NDR_CCONTEXT __RPC_FAR *    pContextHandle,
    RPC_BINDING_HANDLE          BindHandle
    );

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NdrServerContextUnmarshall(
    PMIDL_STUB_MESSAGE          pStubMsg
    );

/*
 * Buffer sizing routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrPointerBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Structures */

RPCRTAPI
void
RPC_ENTRY
NdrSimpleStructBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantStructBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantVaryingStructBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrHardStructBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrComplexStructBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Arrays */

RPCRTAPI
void
RPC_ENTRY
NdrFixedArrayBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantArrayBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantVaryingArrayBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrVaryingArrayBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrComplexArrayBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Strings */

RPCRTAPI
void
RPC_ENTRY
NdrConformantStringBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrNonConformantStringBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Unions */

RPCRTAPI
void
RPC_ENTRY
NdrEncapsulatedUnionBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrNonEncapsulatedUnionBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Byte count pointer */

RPCRTAPI
void
RPC_ENTRY
NdrByteCountPointerBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Transmit as and represent as*/

RPCRTAPI
void
RPC_ENTRY
NdrXmitOrRepAsBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* User_marshal */

RPCRTAPI
void
RPC_ENTRY
NdrUserMarshalBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Cairo Interface pointer */

RPCRTAPI
void
RPC_ENTRY
NdrInterfacePointerBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

// Context Handle size
//
RPCRTAPI
void
RPC_ENTRY
NdrContextHandleSize(
    PMIDL_STUB_MESSAGE          pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/*
 * Memory sizing routines
 */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrPointerMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Structures */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrSimpleStructMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantStructMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantVaryingStructMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrHardStructMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrComplexStructMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Arrays */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrFixedArrayMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantArrayMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantVaryingArrayMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrVaryingArrayMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrComplexArrayMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Strings */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantStringMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrNonConformantStringMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Unions */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrEncapsulatedUnionMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrNonEncapsulatedUnionMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Transmit as and represent as*/

RPCRTAPI
unsigned long
RPC_ENTRY
NdrXmitOrRepAsMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* User_marshal */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrUserMarshalMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Cairo Interface pointer */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrInterfacePointerMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/*
 * Freeing routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrPointerFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Structures */

RPCRTAPI
void
RPC_ENTRY
NdrSimpleStructFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantStructFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantVaryingStructFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrHardStructFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrComplexStructFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Arrays */

RPCRTAPI
void
RPC_ENTRY
NdrFixedArrayFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantArrayFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantVaryingArrayFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrVaryingArrayFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrComplexArrayFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Unions */

RPCRTAPI
void
RPC_ENTRY
NdrEncapsulatedUnionFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrNonEncapsulatedUnionFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Byte count */

RPCRTAPI
void
RPC_ENTRY
NdrByteCountPointerFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Transmit as and represent as*/

RPCRTAPI
void
RPC_ENTRY
NdrXmitOrRepAsFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* User_marshal */

RPCRTAPI
void
RPC_ENTRY
NdrUserMarshalFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Cairo Interface pointer */

RPCRTAPI
void
RPC_ENTRY
NdrInterfacePointerFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/*
 * Endian conversion routine.
 */

RPCRTAPI
void
RPC_ENTRY
NdrConvert2(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    long                                NumberParams
    );

RPCRTAPI
void
RPC_ENTRY
NdrConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

#define USER_MARSHAL_FC_BYTE         1
#define USER_MARSHAL_FC_CHAR         2
#define USER_MARSHAL_FC_SMALL        3
#define USER_MARSHAL_FC_USMALL       4
#define USER_MARSHAL_FC_WCHAR        5
#define USER_MARSHAL_FC_SHORT        6
#define USER_MARSHAL_FC_USHORT       7
#define USER_MARSHAL_FC_LONG         8
#define USER_MARSHAL_FC_ULONG        9
#define USER_MARSHAL_FC_FLOAT       10
#define USER_MARSHAL_FC_HYPER       11
#define USER_MARSHAL_FC_DOUBLE      12

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrUserMarshalSimpleTypeConvert(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    unsigned char   FormatChar
    );

/*
 * Auxilary routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrClientInitializeNew(
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor,
    unsigned int                        ProcNum
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrServerInitializeNew(
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerInitializePartial(
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor,
    unsigned long                       RequestedBufferSize
    );

RPCRTAPI
void
RPC_ENTRY
NdrClientInitialize(
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor,
    unsigned int                        ProcNum
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrServerInitialize(
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrServerInitializeUnmarshall (
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor,
    PRPC_MESSAGE                        pRpcMsg
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerInitializeMarshall (
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrGetBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long                       BufferLength,
    RPC_BINDING_HANDLE                  Handle
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrNsGetBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long                       BufferLength,
    RPC_BINDING_HANDLE                  Handle
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrGetPipeBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long                       BufferLength,
    RPC_BINDING_HANDLE                  Handle );

RPCRTAPI
void
RPC_ENTRY
NdrGetPartialBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrSendReceive(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR*            pBufferEnd
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrNsSendReceive(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pBufferEnd,
    RPC_BINDING_HANDLE __RPC_FAR *      pAutoHandle
    );

RPCRTAPI
void
RPC_ENTRY
NdrPipeSendReceive(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PNDR_PIPE_DESC                      pPipeDesc
    );

RPCRTAPI
void
RPC_ENTRY
NdrFreeBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
NdrGetDcomProtocolVersion( 
    PMIDL_STUB_MESSAGE   pStubMsg,
    RPC_VERSION *        pVersion );


/*
 * Pipe specific calls
 */

RPCRTAPI
void
RPC_ENTRY
NdrPipesInitialize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pParamDesc,
    PNDR_PIPE_DESC                      pPipeDesc,
    PNDR_PIPE_MESSAGE                   pPipeMsg,
    char             __RPC_FAR *        pStackTop,
    unsigned long                       NumberParams );

RPCRTAPI
void
RPC_ENTRY
NdrPipePull(
    char          __RPC_FAR *           pState,
    void          __RPC_FAR *           buf,
    unsigned long                       esize,
    unsigned long __RPC_FAR *           ecount );

RPCRTAPI
void
RPC_ENTRY
NdrPipePush(
    char          __RPC_FAR *           pState,
    void          __RPC_FAR *           buf,
    unsigned long                       ecount );

RPCRTAPI
void
RPC_ENTRY
NdrIsAppDoneWithPipes(
    PNDR_PIPE_DESC                      pPipeDesc
    );

RPCRTAPI
void
RPC_ENTRY
NdrPipesDone(
    PMIDL_STUB_MESSAGE                  pStubMsg
    );


/*
 * Interpeter calls.
 */

/* client */

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrClientCall2(
    PMIDL_STUB_DESC                     pStubDescriptor,
    PFORMAT_STRING                      pFormat,
    ...
    );

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrClientCall(
    PMIDL_STUB_DESC                     pStubDescriptor,
    PFORMAT_STRING                      pFormat,
    ...
    );

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrAsyncClientCall(
    PMIDL_STUB_DESC     pStubDescriptor,
    PFORMAT_STRING      pFormat,
    ...
    );

/* server */
typedef enum {
    STUB_UNMARSHAL,
    STUB_CALL_SERVER,
    STUB_MARSHAL,
    STUB_CALL_SERVER_NO_HRESULT
}STUB_PHASE;

typedef enum {
    PROXY_CALCSIZE,
    PROXY_GETBUFFER,
    PROXY_MARSHAL,
    PROXY_SENDRECEIVE,
    PROXY_UNMARSHAL
}PROXY_PHASE;

struct IRpcStubBuffer;      // Forward declaration

RPCRTAPI
long
RPC_ENTRY
NdrAsyncStubCall(
    struct IRpcStubBuffer *             pThis,
    struct IRpcChannelBuffer *          pChannel,
    PRPC_MESSAGE                        pRpcMsg,
    unsigned long *                     pdwStubPhase
    );

RPCRTAPI
void
RPC_ENTRY
NdrAsyncServerCall(
    PRPC_MESSAGE                        pRpcMsg
    );

RPCRTAPI
long
RPC_ENTRY
NdrStubCall2(
    struct IRpcStubBuffer __RPC_FAR *    pThis,
    struct IRpcChannelBuffer __RPC_FAR * pChannel,
    PRPC_MESSAGE                         pRpcMsg,
    unsigned long __RPC_FAR *            pdwStubPhase
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerCall2(
    PRPC_MESSAGE                        pRpcMsg
    );

RPCRTAPI
long
RPC_ENTRY
NdrStubCall (
    struct IRpcStubBuffer __RPC_FAR *    pThis,
    struct IRpcChannelBuffer __RPC_FAR * pChannel,
    PRPC_MESSAGE                         pRpcMsg,
    unsigned long __RPC_FAR *            pdwStubPhase
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerCall(
    PRPC_MESSAGE                        pRpcMsg
    );

RPCRTAPI
int
RPC_ENTRY
NdrServerUnmarshall(
    struct IRpcChannelBuffer __RPC_FAR * pChannel,
    PRPC_MESSAGE                         pRpcMsg,
    PMIDL_STUB_MESSAGE                   pStubMsg,
    PMIDL_STUB_DESC                      pStubDescriptor,
    PFORMAT_STRING                       pFormat,
    void __RPC_FAR *                     pParamList
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerMarshall(
    struct IRpcStubBuffer __RPC_FAR *    pThis,
    struct IRpcChannelBuffer __RPC_FAR * pChannel,
    PMIDL_STUB_MESSAGE                   pStubMsg,
    PFORMAT_STRING                       pFormat
    );

/* Comm and Fault status */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
NdrMapCommAndFaultStatus(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long __RPC_FAR *                       pCommStatus,
    unsigned long __RPC_FAR *                       pFaultStatus,
    RPC_STATUS                          Status
    );

/* Helper routines */

RPCRTAPI
int
RPC_ENTRY
NdrSH_UPDecision(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    RPC_BUFPTR                          pBuffer
    );

RPCRTAPI
int
RPC_ENTRY
NdrSH_TLUPDecision(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem
    );

RPCRTAPI
int
RPC_ENTRY
NdrSH_TLUPDecisionBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem
    );

RPCRTAPI
int
RPC_ENTRY
NdrSH_IfAlloc(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

RPCRTAPI
int
RPC_ENTRY
NdrSH_IfAllocRef(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

RPCRTAPI
int
RPC_ENTRY
NdrSH_IfAllocSet(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

RPCRTAPI
RPC_BUFPTR
RPC_ENTRY
NdrSH_IfCopy(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

RPCRTAPI
RPC_BUFPTR
RPC_ENTRY
NdrSH_IfAllocCopy(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrSH_Copy(
    unsigned char           __RPC_FAR *         pStubMsg,
    unsigned char           __RPC_FAR *         pPtrInMem,
    unsigned long                       Count
    );

RPCRTAPI
void
RPC_ENTRY
NdrSH_IfFree(
    PMIDL_STUB_MESSAGE                  pMessage,
    unsigned char           __RPC_FAR *         pPtr );


RPCRTAPI
RPC_BUFPTR
RPC_ENTRY
NdrSH_StringMarshall(
    PMIDL_STUB_MESSAGE                  pMessage,
    unsigned char           __RPC_FAR *         pMemory,
    unsigned long                       Count,
    int                                 Size );

RPCRTAPI
RPC_BUFPTR
RPC_ENTRY
NdrSH_StringUnMarshall(
    PMIDL_STUB_MESSAGE                  pMessage,
    unsigned char           __RPC_FAR *__RPC_FAR *          pMemory,
    int                                 Size );

/****************************************************************************
    MIDL 2.0 memory package: rpc_ss_* rpc_sm_*
 ****************************************************************************/

typedef void __RPC_FAR * RPC_SS_THREAD_HANDLE;

typedef void __RPC_FAR * __RPC_API
RPC_CLIENT_ALLOC (
    IN size_t Size
    );

typedef void __RPC_API
RPC_CLIENT_FREE (
    IN void __RPC_FAR * Ptr
    );

/*++
     RpcSs* package
--*/

RPCRTAPI
void __RPC_FAR *
RPC_ENTRY
RpcSsAllocate (
    IN size_t Size
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsDisableAllocate (
    void
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsEnableAllocate (
    void
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsFree (
    IN void __RPC_FAR * NodeToFree
    );

RPCRTAPI
RPC_SS_THREAD_HANDLE
RPC_ENTRY
RpcSsGetThreadHandle (
    void
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsSetClientAllocFree (
    IN RPC_CLIENT_ALLOC __RPC_FAR * ClientAlloc,
    IN RPC_CLIENT_FREE __RPC_FAR * ClientFree
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsSetThreadHandle (
    IN RPC_SS_THREAD_HANDLE Id
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsSwapClientAllocFree (
    IN RPC_CLIENT_ALLOC __RPC_FAR * ClientAlloc,
    IN RPC_CLIENT_FREE __RPC_FAR * ClientFree,
    OUT RPC_CLIENT_ALLOC __RPC_FAR * __RPC_FAR * OldClientAlloc,
    OUT RPC_CLIENT_FREE __RPC_FAR * __RPC_FAR * OldClientFree
    );

/*++
     RpcSm* package
--*/

RPCRTAPI
void __RPC_FAR *
RPC_ENTRY
RpcSmAllocate (
    IN  size_t          Size,
    OUT RPC_STATUS __RPC_FAR *    pStatus
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmClientFree (
    IN  void __RPC_FAR * pNodeToFree
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmDestroyClientContext (
    IN void __RPC_FAR * __RPC_FAR * ContextHandle
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmDisableAllocate (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmEnableAllocate (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmFree (
    IN void __RPC_FAR * NodeToFree
    );

RPCRTAPI
RPC_SS_THREAD_HANDLE
RPC_ENTRY
RpcSmGetThreadHandle (
    OUT RPC_STATUS __RPC_FAR *    pStatus
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmSetClientAllocFree (
    IN RPC_CLIENT_ALLOC __RPC_FAR * ClientAlloc,
    IN RPC_CLIENT_FREE __RPC_FAR * ClientFree
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmSetThreadHandle (
    IN RPC_SS_THREAD_HANDLE Id
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmSwapClientAllocFree (
    IN RPC_CLIENT_ALLOC __RPC_FAR * ClientAlloc,
    IN RPC_CLIENT_FREE __RPC_FAR * ClientFree,
    OUT RPC_CLIENT_ALLOC __RPC_FAR * __RPC_FAR * OldClientAlloc,
    OUT RPC_CLIENT_FREE __RPC_FAR * __RPC_FAR * OldClientFree
    );

/*++
     Ndr stub entry points
--*/

RPCRTAPI
void
RPC_ENTRY
NdrRpcSsEnableAllocate(
    PMIDL_STUB_MESSAGE      pMessage );

RPCRTAPI
void
RPC_ENTRY
NdrRpcSsDisableAllocate(
    PMIDL_STUB_MESSAGE      pMessage );

RPCRTAPI
void
RPC_ENTRY
NdrRpcSmSetClientToOsf(
    PMIDL_STUB_MESSAGE      pMessage );

RPCRTAPI
void __RPC_FAR *
RPC_ENTRY
NdrRpcSmClientAllocate (
    IN size_t Size
    );

RPCRTAPI
void
RPC_ENTRY
NdrRpcSmClientFree (
    IN void __RPC_FAR * NodeToFree
    );

RPCRTAPI
void __RPC_FAR *
RPC_ENTRY
NdrRpcSsDefaultAllocate (
    IN size_t Size
    );

RPCRTAPI
void
RPC_ENTRY
NdrRpcSsDefaultFree (
    IN void __RPC_FAR * NodeToFree
    );

/****************************************************************************
    end of memory package: rpc_ss_* rpc_sm_*
 ****************************************************************************/

/****************************************************************************
 * Full Pointer APIs
 ****************************************************************************/

RPCRTAPI
PFULL_PTR_XLAT_TABLES
RPC_ENTRY
NdrFullPointerXlatInit(
    unsigned long           NumberOfPointers,
    XLAT_SIDE               XlatSide
    );

RPCRTAPI
void
RPC_ENTRY
NdrFullPointerXlatFree(
    PFULL_PTR_XLAT_TABLES   pXlatTables
    );

RPCRTAPI
int
RPC_ENTRY
NdrFullPointerQueryPointer(
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    void __RPC_FAR *                    pPointer,
    unsigned char           QueryType,
    unsigned long __RPC_FAR *           pRefId
    );

RPCRTAPI
int
RPC_ENTRY
NdrFullPointerQueryRefId(
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    unsigned long           RefId,
    unsigned char           QueryType,
    void __RPC_FAR *__RPC_FAR *                 ppPointer
    );

RPCRTAPI
void
RPC_ENTRY
NdrFullPointerInsertRefId(
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    unsigned long           RefId,
    void __RPC_FAR *                    pPointer
    );

RPCRTAPI
int
RPC_ENTRY
NdrFullPointerFree(
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    void __RPC_FAR *                    Pointer
    );

RPCRTAPI
void __RPC_FAR *
RPC_ENTRY
NdrAllocate(
    PMIDL_STUB_MESSAGE      pStubMsg,
    size_t                  Len
    );

RPCRTAPI
void
RPC_ENTRY
NdrClearOutParameters(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat,
    void __RPC_FAR *        ArgAddr
    );


/****************************************************************************
 * Proxy APIs
 ****************************************************************************/

RPCRTAPI
void __RPC_FAR *
RPC_ENTRY
NdrOleAllocate (
    IN size_t Size
    );

RPCRTAPI
void
RPC_ENTRY
NdrOleFree (
    IN void __RPC_FAR * NodeToFree
    );

#ifdef CONST_VTABLE
#define CONST_VTBL const
#else
#define CONST_VTBL
#endif

/****************************************************************************
 * Special things for VC5 Com support
 ****************************************************************************/

#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#define MIDL_INTERFACE(x)   struct __declspec(uuid(x)) __declspec(novtable)
#else
#define DECLSPEC_UUID(x)
#define MIDL_INTERFACE(x)   struct
#endif

#if _MSC_VER >= 1100
#define EXTERN_GUID(itf,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8)  \
  EXTERN_C const IID __declspec(selectany) itf = {l1,s1,s2,{c1,c2,c3,c4,c5,c6,c7,c8}}
#else
#define EXTERN_GUID(itf,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8) EXTERN_C const IID itf
#endif



#ifdef __cplusplus
}
#endif

// Reset the packing level for DOS, Windows and Mac.

#if defined(__RPC_DOS__) || defined(__RPC_WIN16__) || defined(__RPC_MAC__)
#pragma pack()
#endif

#endif /* __RPCNDR_H__ */







=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\inc\wininet.h ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    wininet.h

Abstract:

    Contains manifests, macros, types and prototypes for Microsoft Windows
    Internet Extensions

--*/

#if !defined(_WININET_)
#define _WININET_


/*
 * Set up Structure Packing to be 4 bytes
 * for all wininet structures
 */

#pragma pack(push, wininet, 4)



#if defined(__cplusplus)
extern "C" {
#endif


#if !defined(_WINX32_)
#define INTERNETAPI DECLSPEC_IMPORT
#define URLCACHEAPI DECLSPEC_IMPORT
#else
#define INTERNETAPI
#define URLCACHEAPI
#endif

#define BOOLAPI INTERNETAPI BOOL WINAPI

//
// internet types
//

typedef LPVOID HINTERNET;
typedef HINTERNET * LPHINTERNET;

typedef WORD INTERNET_PORT;
typedef INTERNET_PORT * LPINTERNET_PORT;

//
// Internet APIs
//

//
// manifests
//

#define INTERNET_INVALID_PORT_NUMBER    0           // use the protocol-specific default

#define INTERNET_DEFAULT_FTP_PORT       21          // default for FTP servers
#define INTERNET_DEFAULT_GOPHER_PORT    70          //    "     "  gopher "
#define INTERNET_DEFAULT_HTTP_PORT      80          //    "     "  HTTP   "
#define INTERNET_DEFAULT_HTTPS_PORT     443         //    "     "  HTTPS  "
#define INTERNET_DEFAULT_SOCKS_PORT     1080        // default for SOCKS firewall servers.


//
// maximum field lengths (arbitrary)
//

#define INTERNET_MAX_HOST_NAME_LENGTH   256
#define INTERNET_MAX_USER_NAME_LENGTH   128
#define INTERNET_MAX_PASSWORD_LENGTH    128
#define INTERNET_MAX_PORT_NUMBER_LENGTH 5           // INTERNET_PORT is unsigned short
#define INTERNET_MAX_PORT_NUMBER_VALUE  65535       // maximum unsigned short value
#define INTERNET_MAX_PATH_LENGTH        2048
#define INTERNET_MAX_SCHEME_LENGTH      32          // longest protocol name length
#define INTERNET_MAX_URL_LENGTH         (INTERNET_MAX_SCHEME_LENGTH \
                                        + sizeof("://") \
                                        + INTERNET_MAX_PATH_LENGTH)

//
// values returned by InternetQueryOption() with INTERNET_OPTION_KEEP_CONNECTION:
//

#define INTERNET_KEEP_ALIVE_UNKNOWN     ((DWORD)-1)
#define INTERNET_KEEP_ALIVE_ENABLED     1
#define INTERNET_KEEP_ALIVE_DISABLED    0

//
// flags returned by InternetQueryOption() with INTERNET_OPTION_REQUEST_FLAGS
//

#define INTERNET_REQFLAG_FROM_CACHE     0x00000001  // response came from cache
#define INTERNET_REQFLAG_ASYNC          0x00000002  // request was made asynchronously
#define INTERNET_REQFLAG_VIA_PROXY      0x00000004  // request was made via a proxy
#define INTERNET_REQFLAG_NO_HEADERS     0x00000008  // orginal response contained no headers
#define INTERNET_REQFLAG_PASSIVE        0x00000010  // FTP: passive-mode connection
#define INTERNET_REQFLAG_CACHE_WRITE_DISABLED 0x00000040  // HTTPS: this request not cacheable

//
// flags common to open functions (not InternetOpen()):
//

#define INTERNET_FLAG_RELOAD            0x80000000  // retrieve the original item

//
// flags for InternetOpenUrl():
//

#define INTERNET_FLAG_RAW_DATA          0x40000000  // FTP/gopher find: receive the item as raw (structured) data
#define INTERNET_FLAG_EXISTING_CONNECT  0x20000000  // FTP: use existing InternetConnect handle for server if possible

//
// flags for InternetOpen():
//

#define INTERNET_FLAG_ASYNC             0x10000000  // this request is asynchronous (where supported)

//
// protocol-specific flags:
//

#define INTERNET_FLAG_PASSIVE           0x08000000  // used for FTP connections

//
// additional cache flags
//

#define INTERNET_FLAG_NO_CACHE_WRITE    0x04000000  // don't write this item to the cache
#define INTERNET_FLAG_DONT_CACHE        INTERNET_FLAG_NO_CACHE_WRITE
#define INTERNET_FLAG_MAKE_PERSISTENT   0x02000000  // make this item persistent in cache
#define INTERNET_FLAG_FROM_CACHE        0x01000000  // use offline semantics
#define INTERNET_FLAG_OFFLINE           INTERNET_FLAG_FROM_CACHE

//
// additional flags
//

#define INTERNET_FLAG_SECURE            0x00800000  // use PCT/SSL if applicable (HTTP)
#define INTERNET_FLAG_KEEP_CONNECTION   0x00400000  // use keep-alive semantics
#define INTERNET_FLAG_NO_AUTO_REDIRECT  0x00200000  // don't handle redirections automatically
#define INTERNET_FLAG_READ_PREFETCH     0x00100000  // do background read prefetch
#define INTERNET_FLAG_NO_COOKIES        0x00080000  // no automatic cookie handling
#define INTERNET_FLAG_NO_AUTH           0x00040000  // no automatic authentication handling
#define INTERNET_FLAG_CACHE_IF_NET_FAIL 0x00010000  // return cache file if net request fails

//
// Security Ignore Flags, Allow HttpOpenRequest to overide
//  Secure Channel (SSL/PCT) failures of the following types.
//

#define INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTP   0x00008000 // ex: https:// to http://
#define INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS  0x00004000 // ex: http:// to https://
#define INTERNET_FLAG_IGNORE_CERT_DATE_INVALID  0x00002000 // expired X509 Cert.
#define INTERNET_FLAG_IGNORE_CERT_CN_INVALID    0x00001000 // bad common name in X509 Cert.

//
// more caching flags
//

#define INTERNET_FLAG_RESYNCHRONIZE     0x00000800  // asking wininet to update an item if it is newer
#define INTERNET_FLAG_HYPERLINK         0x00000400  // asking wininet to do hyperlinking semantic which works right for scripts
#define INTERNET_FLAG_NO_UI             0x00000200  // no cookie popup
#define INTERNET_FLAG_PRAGMA_NOCACHE    0x00000100  // asking wininet to add "pragma: no-cache"
#define INTERNET_FLAG_CACHE_ASYNC       0x00000080  // ok to perform lazy cache-write
#define INTERNET_FLAG_FORMS_SUBMIT      0x00000040  // this is a forms submit
#define INTERNET_FLAG_NEED_FILE         0x00000010  // need a file for this request
#define INTERNET_FLAG_MUST_CACHE_REQUEST INTERNET_FLAG_NEED_FILE

//
// flags for FTP
//

#define INTERNET_FLAG_TRANSFER_ASCII    FTP_TRANSFER_TYPE_ASCII     // 0x00000001
#define INTERNET_FLAG_TRANSFER_BINARY   FTP_TRANSFER_TYPE_BINARY    // 0x00000002

//
// flags field masks
//

#define SECURITY_INTERNET_MASK  (INTERNET_FLAG_IGNORE_CERT_CN_INVALID    |  \
                                 INTERNET_FLAG_IGNORE_CERT_DATE_INVALID  |  \
                                 INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS  |  \
                                 INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTP   )

#define INTERNET_FLAGS_MASK     (INTERNET_FLAG_RELOAD               \
                                | INTERNET_FLAG_RAW_DATA            \
                                | INTERNET_FLAG_EXISTING_CONNECT    \
                                | INTERNET_FLAG_ASYNC               \
                                | INTERNET_FLAG_PASSIVE             \
                                | INTERNET_FLAG_NO_CACHE_WRITE      \
                                | INTERNET_FLAG_MAKE_PERSISTENT     \
                                | INTERNET_FLAG_FROM_CACHE          \
                                | INTERNET_FLAG_SECURE              \
                                | INTERNET_FLAG_KEEP_CONNECTION     \
                                | INTERNET_FLAG_NO_AUTO_REDIRECT    \
                                | INTERNET_FLAG_READ_PREFETCH       \
                                | INTERNET_FLAG_NO_COOKIES          \
                                | INTERNET_FLAG_NO_AUTH             \
                                | INTERNET_FLAG_CACHE_IF_NET_FAIL   \
                                | SECURITY_INTERNET_MASK            \
                                | INTERNET_FLAG_RESYNCHRONIZE       \
                                | INTERNET_FLAG_HYPERLINK           \
                                | INTERNET_FLAG_NO_UI               \
                                | INTERNET_FLAG_PRAGMA_NOCACHE      \
                                | INTERNET_FLAG_CACHE_ASYNC         \
                                | INTERNET_FLAG_FORMS_SUBMIT        \
                                | INTERNET_FLAG_NEED_FILE           \
                                | INTERNET_FLAG_TRANSFER_BINARY     \
                                | INTERNET_FLAG_TRANSFER_ASCII      \
                                )

#define INTERNET_ERROR_MASK_INSERT_CDROM                    0x1

#define INTERNET_OPTIONS_MASK   (~INTERNET_FLAGS_MASK)

//
// common per-API flags (new APIs)
//

#define WININET_API_FLAG_ASYNC          0x00000001  // force async operation
#define WININET_API_FLAG_SYNC           0x00000004  // force sync operation
#define WININET_API_FLAG_USE_CONTEXT    0x00000008  // use value supplied in dwContext (even if 0)

//
// INTERNET_NO_CALLBACK - if this value is presented as the dwContext parameter
// then no call-backs will be made for that API
//

#define INTERNET_NO_CALLBACK            0

//
// structures/types
//

//
// INTERNET_SCHEME - enumerated URL scheme type
//

typedef enum {
    INTERNET_SCHEME_PARTIAL = -2,
    INTERNET_SCHEME_UNKNOWN = -1,
    INTERNET_SCHEME_DEFAULT = 0,
    INTERNET_SCHEME_FTP,
    INTERNET_SCHEME_GOPHER,
    INTERNET_SCHEME_HTTP,
    INTERNET_SCHEME_HTTPS,
    INTERNET_SCHEME_FILE,
    INTERNET_SCHEME_NEWS,
    INTERNET_SCHEME_MAILTO,
    INTERNET_SCHEME_SOCKS,
    INTERNET_SCHEME_FIRST = INTERNET_SCHEME_FTP,
    INTERNET_SCHEME_LAST = INTERNET_SCHEME_SOCKS
} INTERNET_SCHEME, * LPINTERNET_SCHEME;

//
// INTERNET_ASYNC_RESULT - this structure is returned to the application via
// the callback with INTERNET_STATUS_REQUEST_COMPLETE. It is not sufficient to
// just return the result of the async operation. If the API failed then the
// app cannot call GetLastError() because the thread context will be incorrect.
// Both the value returned by the async API and any resultant error code are
// made available. The app need not check dwError if dwResult indicates that
// the API succeeded (in this case dwError will be ERROR_SUCCESS)
//

typedef struct {

    //
    // dwResult - the HINTERNET, DWORD or BOOL return code from an async API
    //

    DWORD dwResult;

    //
    // dwError - the error code if the API failed
    //

    DWORD dwError;
} INTERNET_ASYNC_RESULT, * LPINTERNET_ASYNC_RESULT;


//
// INTERNET_PROXY_INFO - structure supplied with INTERNET_OPTION_PROXY to get/
// set proxy information on a InternetOpen() handle
//

typedef struct {

    //
    // dwAccessType - INTERNET_OPEN_TYPE_DIRECT, INTERNET_OPEN_TYPE_PROXY, or
    // INTERNET_OPEN_TYPE_PRECONFIG (set only)
    //

    DWORD dwAccessType;

    //
    // lpszProxy - proxy server list
    //

    LPCTSTR lpszProxy;

    //
    // lpszProxyBypass - proxy bypass list
    //

    LPCTSTR lpszProxyBypass;
} INTERNET_PROXY_INFO, * LPINTERNET_PROXY_INFO;

//
// INTERNET_VERSION_INFO - version information returned via
// InternetQueryOption(..., INTERNET_OPTION_VERSION, ...)
//

typedef struct {
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
} INTERNET_VERSION_INFO, * LPINTERNET_VERSION_INFO;

//
// HTTP_VERSION_INFO - query or set global HTTP version (1.0 or 1.1)
//

typedef struct {
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
} HTTP_VERSION_INFO, * LPHTTP_VERSION_INFO;

//
// INTERNET_CONNECTED_INFO - information used to set the global connected state
//

typedef struct {

    //
    // dwConnectedState - new connected/disconnected state.
    // See INTERNET_STATE_CONNECTED, etc.
    //

    DWORD dwConnectedState;

    //
    // dwFlags - flags controlling connected->disconnected (or disconnected->
    // connected) transition. See below
    //

    DWORD dwFlags;
} INTERNET_CONNECTED_INFO, * LPINTERNET_CONNECTED_INFO;


//
// flags for INTERNET_CONNECTED_INFO dwFlags
//

//
// ISO_FORCE_DISCONNECTED - if set when putting Wininet into disconnected mode,
// all outstanding requests will be aborted with a cancelled error
//

#define ISO_FORCE_DISCONNECTED  0x00000001


//
// URL_COMPONENTS - the constituent parts of an URL. Used in InternetCrackUrl()
// and InternetCreateUrl()
//
// For InternetCrackUrl(), if a pointer field and its corresponding length field
// are both 0 then that component is not returned. If the pointer field is NULL
// but the length field is not zero, then both the pointer and length fields are
// returned if both pointer and corresponding length fields are non-zero then
// the pointer field points to a buffer where the component is copied. The
// component may be un-escaped, depending on dwFlags
//
// For InternetCreateUrl(), the pointer fields should be NULL if the component
// is not required. If the corresponding length field is zero then the pointer
// field is the address of a zero-terminated string. If the length field is not
// zero then it is the string length of the corresponding pointer field
//

typedef struct {
    DWORD   dwStructSize;       // size of this structure. Used in version check
    LPSTR   lpszScheme;         // pointer to scheme name
    DWORD   dwSchemeLength;     // length of scheme name
    INTERNET_SCHEME nScheme;    // enumerated scheme type (if known)
    LPSTR   lpszHostName;       // pointer to host name
    DWORD   dwHostNameLength;   // length of host name
    INTERNET_PORT nPort;        // converted port number
    LPSTR   lpszUserName;       // pointer to user name
    DWORD   dwUserNameLength;   // length of user name
    LPSTR   lpszPassword;       // pointer to password
    DWORD   dwPasswordLength;   // length of password
    LPSTR   lpszUrlPath;        // pointer to URL-path
    DWORD   dwUrlPathLength;    // length of URL-path
    LPSTR   lpszExtraInfo;      // pointer to extra information (e.g. ?foo or #foo)
    DWORD   dwExtraInfoLength;  // length of extra information
} URL_COMPONENTSA, * LPURL_COMPONENTSA;
typedef struct {
    DWORD   dwStructSize;       // size of this structure. Used in version check
    LPWSTR  lpszScheme;         // pointer to scheme name
    DWORD   dwSchemeLength;     // length of scheme name
    INTERNET_SCHEME nScheme;    // enumerated scheme type (if known)
    LPWSTR  lpszHostName;       // pointer to host name
    DWORD   dwHostNameLength;   // length of host name
    INTERNET_PORT nPort;        // converted port number
    LPWSTR  lpszUserName;       // pointer to user name
    DWORD   dwUserNameLength;   // length of user name
    LPWSTR  lpszPassword;       // pointer to password
    DWORD   dwPasswordLength;   // length of password
    LPWSTR  lpszUrlPath;        // pointer to URL-path
    DWORD   dwUrlPathLength;    // length of URL-path
    LPWSTR  lpszExtraInfo;      // pointer to extra information (e.g. ?foo or #foo)
    DWORD   dwExtraInfoLength;  // length of extra information
} URL_COMPONENTSW, * LPURL_COMPONENTSW;
#ifdef UNICODE
typedef URL_COMPONENTSW URL_COMPONENTS;
typedef LPURL_COMPONENTSW LPURL_COMPONENTS;
#else
typedef URL_COMPONENTSA URL_COMPONENTS;
typedef LPURL_COMPONENTSA LPURL_COMPONENTS;
#endif // UNICODE


//
// INTERNET_CERTIFICATE_INFO lpBuffer - contains the certificate returned from
// the server
//

typedef struct {

    //
    // ftExpiry - date the certificate expires.
    //

    FILETIME ftExpiry;

    //
    // ftStart - date the certificate becomes valid.
    //

    FILETIME ftStart;

    //
    // lpszSubjectInfo - the name of organization, site, and server
    //   the cert. was issued for.
    //

    LPTSTR lpszSubjectInfo;

    //
    // lpszIssuerInfo - the name of orgainzation, site, and server
    //   the cert was issues by.
    //

    LPTSTR lpszIssuerInfo;

    //
    // lpszProtocolName - the name of the protocol used to provide the secure
    //   connection.
    //

    LPTSTR lpszProtocolName;

    //
    // lpszSignatureAlgName - the name of the algorithm used for signing
    //  the certificate.
    //

    LPTSTR lpszSignatureAlgName;

    //
    // lpszEncryptionAlgName - the name of the algorithm used for
    //  doing encryption over the secure channel (SSL/PCT) connection.
    //

    LPTSTR lpszEncryptionAlgName;

    //
    // dwKeySize - size of the key.
    //

    DWORD dwKeySize;

} INTERNET_CERTIFICATE_INFO, * LPINTERNET_CERTIFICATE_INFO;


//
// INTERNET_BUFFERS - combines headers and data. May be chained for e.g. file
// upload or scatter/gather operations. For chunked read/write, lpcszHeader
// contains the chunked-ext
//

typedef struct _INTERNET_BUFFERSA {
    DWORD dwStructSize;                 // used for API versioning. Set to sizeof(INTERNET_BUFFERS)
    struct _INTERNET_BUFFERSA * Next;   // chain of buffers
    LPCSTR   lpcszHeader;               // pointer to headers (may be NULL)
    DWORD dwHeadersLength;              // length of headers if not NULL
    DWORD dwHeadersTotal;               // size of headers if not enough buffer
    LPVOID lpvBuffer;                   // pointer to data buffer (may be NULL)
    DWORD dwBufferLength;               // length of data buffer if not NULL
    DWORD dwBufferTotal;                // total size of chunk, or content-length if not chunked
    DWORD dwOffsetLow;                  // used for read-ranges (only used in HttpSendRequest2)
    DWORD dwOffsetHigh;
} INTERNET_BUFFERSA, * LPINTERNET_BUFFERSA;
typedef struct _INTERNET_BUFFERSW {
    DWORD dwStructSize;                 // used for API versioning. Set to sizeof(INTERNET_BUFFERS)
    struct _INTERNET_BUFFERSW * Next;   // chain of buffers
    LPCWSTR  lpcszHeader;               // pointer to headers (may be NULL)
    DWORD dwHeadersLength;              // length of headers if not NULL
    DWORD dwHeadersTotal;               // size of headers if not enough buffer
    LPVOID lpvBuffer;                   // pointer to data buffer (may be NULL)
    DWORD dwBufferLength;               // length of data buffer if not NULL
    DWORD dwBufferTotal;                // total size of chunk, or content-length if not chunked
    DWORD dwOffsetLow;                  // used for read-ranges (only used in HttpSendRequest2)
    DWORD dwOffsetHigh;
} INTERNET_BUFFERSW, * LPINTERNET_BUFFERSW;
#ifdef UNICODE
typedef INTERNET_BUFFERSW INTERNET_BUFFERS;
typedef LPINTERNET_BUFFERSW LPINTERNET_BUFFERS;
#else
typedef INTERNET_BUFFERSA INTERNET_BUFFERS;
typedef LPINTERNET_BUFFERSA LPINTERNET_BUFFERS;
#endif // UNICODE

//
// prototypes
//

BOOLAPI
InternetTimeFromSystemTime(
    IN  CONST SYSTEMTIME *pst,  // input GMT time
    IN  DWORD dwRFC,            // RFC format
    OUT LPSTR lpszTime,         // output string buffer
    IN  DWORD cbTime            // output buffer size
    );

//
// constants for InternetTimeFromSystemTime
//

#define INTERNET_RFC1123_FORMAT     0
#define INTERNET_RFC1123_BUFSIZE   30

BOOLAPI
InternetTimeToSystemTime(
    IN  LPCSTR lpszTime,         // NULL terminated string
    OUT SYSTEMTIME *pst,         // output in GMT time
    IN  DWORD dwReserved
    );


BOOLAPI
InternetCrackUrlA(
    IN LPCSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTSA lpUrlComponents
    );
BOOLAPI
InternetCrackUrlW(
    IN LPCWSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTSW lpUrlComponents
    );
#ifdef UNICODE
#define InternetCrackUrl  InternetCrackUrlW
#else
#define InternetCrackUrl  InternetCrackUrlA
#endif // !UNICODE

BOOLAPI
InternetCreateUrlA(
    IN LPURL_COMPONENTSA lpUrlComponents,
    IN DWORD dwFlags,
    OUT LPSTR lpszUrl,
    IN OUT LPDWORD lpdwUrlLength
    );
BOOLAPI
InternetCreateUrlW(
    IN LPURL_COMPONENTSW lpUrlComponents,
    IN DWORD dwFlags,
    OUT LPWSTR lpszUrl,
    IN OUT LPDWORD lpdwUrlLength
    );
#ifdef UNICODE
#define InternetCreateUrl  InternetCreateUrlW
#else
#define InternetCreateUrl  InternetCreateUrlA
#endif // !UNICODE

BOOLAPI
InternetCanonicalizeUrlA(
    IN LPCSTR lpszUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );
BOOLAPI
InternetCanonicalizeUrlW(
    IN LPCWSTR lpszUrl,
    OUT LPWSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );
#ifdef UNICODE
#define InternetCanonicalizeUrl  InternetCanonicalizeUrlW
#else
#define InternetCanonicalizeUrl  InternetCanonicalizeUrlA
#endif // !UNICODE

BOOLAPI
InternetCombineUrlA(
    IN LPCSTR lpszBaseUrl,
    IN LPCSTR lpszRelativeUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );
BOOLAPI
InternetCombineUrlW(
    IN LPCWSTR lpszBaseUrl,
    IN LPCWSTR lpszRelativeUrl,
    OUT LPWSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );
#ifdef UNICODE
#define InternetCombineUrl  InternetCombineUrlW
#else
#define InternetCombineUrl  InternetCombineUrlA
#endif // !UNICODE

//
// flags for InternetCrackUrl() and InternetCreateUrl()
//

#define ICU_ESCAPE      0x80000000  // (un)escape URL characters
#define ICU_USERNAME    0x40000000  // use internal username & password

//
// flags for InternetCanonicalizeUrl() and InternetCombineUrl()
//

#define ICU_NO_ENCODE   0x20000000  // Don't convert unsafe characters to escape sequence
#define ICU_DECODE      0x10000000  // Convert %XX escape sequences to characters
#define ICU_NO_META     0x08000000  // Don't convert .. etc. meta path sequences
#define ICU_ENCODE_SPACES_ONLY 0x04000000  // Encode spaces only
#define ICU_BROWSER_MODE 0x02000000 // Special encode/decode rules for browser

INTERNETAPI
HINTERNET
WINAPI
InternetOpenA(
    IN LPCSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxy OPTIONAL,
    IN LPCSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    );
INTERNETAPI
HINTERNET
WINAPI
InternetOpenW(
    IN LPCWSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCWSTR lpszProxy OPTIONAL,
    IN LPCWSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    );
#ifdef UNICODE
#define InternetOpen  InternetOpenW
#else
#define InternetOpen  InternetOpenA
#endif // !UNICODE

//
// access types for InternetOpen()
//

#define INTERNET_OPEN_TYPE_PRECONFIG                    0   // use registry configuration
#define INTERNET_OPEN_TYPE_DIRECT                       1   // direct to net
#define INTERNET_OPEN_TYPE_PROXY                        3   // via named proxy
#define INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY  4   // prevent using java/script/INS

//
// old names for access types
//

#define PRE_CONFIG_INTERNET_ACCESS  INTERNET_OPEN_TYPE_PRECONFIG
#define LOCAL_INTERNET_ACCESS       INTERNET_OPEN_TYPE_DIRECT
#define CERN_PROXY_INTERNET_ACCESS  INTERNET_OPEN_TYPE_PROXY

BOOLAPI
InternetCloseHandle(
    IN HINTERNET hInternet
    );

INTERNETAPI
HINTERNET
WINAPI
InternetConnectA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCSTR lpszUserName OPTIONAL,
    IN LPCSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
HINTERNET
WINAPI
InternetConnectW(
    IN HINTERNET hInternet,
    IN LPCWSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCWSTR lpszUserName OPTIONAL,
    IN LPCWSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define InternetConnect  InternetConnectW
#else
#define InternetConnect  InternetConnectA
#endif // !UNICODE

//
// service types for InternetConnect()
//

#define INTERNET_SERVICE_URL    0
#define INTERNET_SERVICE_FTP    1
#define INTERNET_SERVICE_GOPHER 2
#define INTERNET_SERVICE_HTTP   3

//
// InternetConnectUrl() - a macro which allows you to specify an URL instead of
// the component parts to InternetConnect(). If any API which uses the returned
// connect handle specifies a NULL path then the URL-path part of the URL
// specified in InternetConnectUrl() will be used
//

#define InternetConnectUrl(hInternet, lpszUrl, dwFlags, dwContext) \
    InternetConnect(hInternet,                      \
                    lpszUrl,                        \
                    INTERNET_INVALID_PORT_NUMBER,   \
                    NULL,                           \
                    NULL,                           \
                    INTERNET_SERVICE_URL,           \
                    dwFlags,                        \
                    dwContext                       \
                    )

INTERNETAPI
HINTERNET
WINAPI
InternetOpenUrlA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
HINTERNET
WINAPI
InternetOpenUrlW(
    IN HINTERNET hInternet,
    IN LPCWSTR lpszUrl,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define InternetOpenUrl  InternetOpenUrlW
#else
#define InternetOpenUrl  InternetOpenUrlA
#endif // !UNICODE

BOOLAPI
InternetReadFile(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    );

INTERNETAPI
BOOL
WINAPI
InternetReadFileExA(
    IN HINTERNET hFile,
    OUT LPINTERNET_BUFFERSA lpBuffersOut,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
BOOL
WINAPI
InternetReadFileExW(
    IN HINTERNET hFile,
    OUT LPINTERNET_BUFFERSW lpBuffersOut,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define InternetReadFileEx  InternetReadFileExW
#else
#define InternetReadFileEx  InternetReadFileExA
#endif // !UNICODE

//
// flags for InternetReadFileEx()
//

#define IRF_ASYNC       WININET_API_FLAG_ASYNC
#define IRF_SYNC        WININET_API_FLAG_SYNC
#define IRF_USE_CONTEXT WININET_API_FLAG_USE_CONTEXT
#define IRF_NO_WAIT     0x00000008

INTERNETAPI
DWORD
WINAPI
InternetSetFilePointer(
    IN HINTERNET hFile,
    IN LONG  lDistanceToMove,
    IN PVOID pReserved,
    IN DWORD dwMoveMethod,
    IN DWORD dwContext
    );

BOOLAPI
InternetWriteFile(
    IN HINTERNET hFile,
    IN LPCVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten
    );


BOOLAPI
InternetQueryDataAvailable(
    IN HINTERNET hFile,
    OUT LPDWORD lpdwNumberOfBytesAvailable OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );

BOOLAPI
InternetFindNextFileA(
    IN HINTERNET hFind,
    OUT LPVOID lpvFindData
    );
BOOLAPI
InternetFindNextFileW(
    IN HINTERNET hFind,
    OUT LPVOID lpvFindData
    );
#ifdef UNICODE
#define InternetFindNextFile  InternetFindNextFileW
#else
#define InternetFindNextFile  InternetFindNextFileA
#endif // !UNICODE

BOOLAPI
InternetQueryOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
BOOLAPI
InternetQueryOptionW(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
#ifdef UNICODE
#define InternetQueryOption  InternetQueryOptionW
#else
#define InternetQueryOption  InternetQueryOptionA
#endif // !UNICODE

BOOLAPI
InternetSetOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    );
BOOLAPI
InternetSetOptionW(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    );
#ifdef UNICODE
#define InternetSetOption  InternetSetOptionW
#else
#define InternetSetOption  InternetSetOptionA
#endif // !UNICODE

BOOLAPI
InternetSetOptionExA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwFlags
    );
BOOLAPI
InternetSetOptionExW(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwFlags
    );
#ifdef UNICODE
#define InternetSetOptionEx  InternetSetOptionExW
#else
#define InternetSetOptionEx  InternetSetOptionExA
#endif // !UNICODE

BOOLAPI
InternetLockRequestFile(
    IN  HINTERNET hInternet,
    OUT HANDLE * lphLockRequestInfo
    );

BOOLAPI
InternetUnlockRequestFile(
    IN HANDLE hLockRequestInfo
    );

//
// flags for InternetSetOptionEx()
//

#define ISO_GLOBAL      0x00000001  // modify option globally
#define ISO_REGISTRY    0x00000002  // write option to registry (where applicable)

#define ISO_VALID_FLAGS (ISO_GLOBAL | ISO_REGISTRY)

//
// options manifests for Internet{Query|Set}Option
//

#define INTERNET_OPTION_CALLBACK                1
#define INTERNET_OPTION_CONNECT_TIMEOUT         2
#define INTERNET_OPTION_CONNECT_RETRIES         3
#define INTERNET_OPTION_CONNECT_BACKOFF         4
#define INTERNET_OPTION_SEND_TIMEOUT            5
#define INTERNET_OPTION_CONTROL_SEND_TIMEOUT    INTERNET_OPTION_SEND_TIMEOUT
#define INTERNET_OPTION_RECEIVE_TIMEOUT         6
#define INTERNET_OPTION_CONTROL_RECEIVE_TIMEOUT INTERNET_OPTION_RECEIVE_TIMEOUT
#define INTERNET_OPTION_DATA_SEND_TIMEOUT       7
#define INTERNET_OPTION_DATA_RECEIVE_TIMEOUT    8
#define INTERNET_OPTION_HANDLE_TYPE             9
#define INTERNET_OPTION_LISTEN_TIMEOUT          11
#define INTERNET_OPTION_READ_BUFFER_SIZE        12
#define INTERNET_OPTION_WRITE_BUFFER_SIZE       13

#define INTERNET_OPTION_ASYNC_ID                15
#define INTERNET_OPTION_ASYNC_PRIORITY          16

#define INTERNET_OPTION_PARENT_HANDLE           21
#define INTERNET_OPTION_KEEP_CONNECTION         22
#define INTERNET_OPTION_REQUEST_FLAGS           23
#define INTERNET_OPTION_EXTENDED_ERROR          24

#define INTERNET_OPTION_OFFLINE_MODE            26
#define INTERNET_OPTION_CACHE_STREAM_HANDLE     27
#define INTERNET_OPTION_USERNAME                28
#define INTERNET_OPTION_PASSWORD                29
#define INTERNET_OPTION_ASYNC                   30
#define INTERNET_OPTION_SECURITY_FLAGS          31
#define INTERNET_OPTION_SECURITY_CERTIFICATE_STRUCT 32
#define INTERNET_OPTION_DATAFILE_NAME           33
#define INTERNET_OPTION_URL                     34
#define INTERNET_OPTION_SECURITY_CERTIFICATE    35
#define INTERNET_OPTION_SECURITY_KEY_BITNESS    36
#define INTERNET_OPTION_REFRESH                 37
#define INTERNET_OPTION_PROXY                   38
#define INTERNET_OPTION_SETTINGS_CHANGED        39
#define INTERNET_OPTION_VERSION                 40
#define INTERNET_OPTION_USER_AGENT              41
#define INTERNET_OPTION_END_BROWSER_SESSION     42
#define INTERNET_OPTION_PROXY_USERNAME          43
#define INTERNET_OPTION_PROXY_PASSWORD          44
#define INTERNET_OPTION_CONTEXT_VALUE           45
#define INTERNET_OPTION_CONNECT_LIMIT           46
#define INTERNET_OPTION_SECURITY_SELECT_CLIENT_CERT 47
#define INTERNET_OPTION_POLICY                  48
#define INTERNET_OPTION_DISCONNECTED_TIMEOUT    49
#define INTERNET_OPTION_CONNECTED_STATE         50
#define INTERNET_OPTION_IDLE_STATE              51
#define INTERNET_OPTION_OFFLINE_SEMANTICS       52
#define INTERNET_OPTION_SECONDARY_CACHE_KEY     53
#define INTERNET_OPTION_CALLBACK_FILTER         54
#define INTERNET_OPTION_CONNECT_TIME            55
#define INTERNET_OPTION_SEND_THROUGHPUT         56
#define INTERNET_OPTION_RECEIVE_THROUGHPUT      57
#define INTERNET_OPTION_REQUEST_PRIORITY        58
#define INTERNET_OPTION_HTTP_VERSION            59
#define INTERNET_OPTION_RESET_URLCACHE_SESSION  60
#define INTERNET_OPTION_ERROR_MASK              62

#define INTERNET_FIRST_OPTION                   INTERNET_OPTION_CALLBACK
#define INTERNET_LAST_OPTION                    INTERNET_OPTION_ERROR_MASK


//
// values for INTERNET_OPTION_PRIORITY
//

#define INTERNET_PRIORITY_FOREGROUND            1000

//
// handle types
//

#define INTERNET_HANDLE_TYPE_INTERNET           1
#define INTERNET_HANDLE_TYPE_CONNECT_FTP        2
#define INTERNET_HANDLE_TYPE_CONNECT_GOPHER     3
#define INTERNET_HANDLE_TYPE_CONNECT_HTTP       4
#define INTERNET_HANDLE_TYPE_FTP_FIND           5
#define INTERNET_HANDLE_TYPE_FTP_FIND_HTML      6
#define INTERNET_HANDLE_TYPE_FTP_FILE           7
#define INTERNET_HANDLE_TYPE_FTP_FILE_HTML      8
#define INTERNET_HANDLE_TYPE_GOPHER_FIND        9
#define INTERNET_HANDLE_TYPE_GOPHER_FIND_HTML   10
#define INTERNET_HANDLE_TYPE_GOPHER_FILE        11
#define INTERNET_HANDLE_TYPE_GOPHER_FILE_HTML   12
#define INTERNET_HANDLE_TYPE_HTTP_REQUEST       13

//
// values for INTERNET_OPTION_SECURITY_FLAGS
//

// query only
#define SECURITY_FLAG_SECURE                    0x00000001 // can query only
#define SECURITY_FLAG_STRENGTH_WEAK             0x10000000
#define SECURITY_FLAG_STRENGTH_MEDIUM           0x40000000
#define SECURITY_FLAG_STRENGTH_STRONG           0x20000000
#define SECURITY_FLAG_UNKNOWNBIT                0x80000000
#define SECURITY_FLAG_NORMALBITNESS             SECURITY_FLAG_STRENGTH_WEAK



// The following are unused
#define SECURITY_FLAG_SSL                       0x00000002
#define SECURITY_FLAG_SSL3                      0x00000004
#define SECURITY_FLAG_PCT                       0x00000008
#define SECURITY_FLAG_PCT4                      0x00000010
#define SECURITY_FLAG_IETFSSL4                  0x00000020

// The following are for backwards compatability only.
#define SECURITY_FLAG_40BIT                     SECURITY_FLAG_STRENGTH_WEAK
#define SECURITY_FLAG_128BIT                    SECURITY_FLAG_STRENGTH_STRONG
#define SECURITY_FLAG_56BIT                     SECURITY_FLAG_STRENGTH_MEDIUM


// setable flags
#define SECURITY_FLAG_IGNORE_REVOCATION         0x00000080
#define SECURITY_FLAG_IGNORE_UNKNOWN_CA         0x00000100
#define SECURITY_FLAG_IGNORE_WRONG_USAGE        0x00000200

#define SECURITY_FLAG_IGNORE_CERT_CN_INVALID    INTERNET_FLAG_IGNORE_CERT_CN_INVALID
#define SECURITY_FLAG_IGNORE_CERT_DATE_INVALID  INTERNET_FLAG_IGNORE_CERT_DATE_INVALID


#define SECURITY_FLAG_IGNORE_REDIRECT_TO_HTTPS  INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS
#define SECURITY_FLAG_IGNORE_REDIRECT_TO_HTTP   INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTP



#define SECURITY_SET_MASK       (SECURITY_FLAG_IGNORE_REVOCATION |\
                                 SECURITY_FLAG_IGNORE_UNKNOWN_CA |\
                                 SECURITY_FLAG_IGNORE_CERT_CN_INVALID |\
                                 SECURITY_FLAG_IGNORE_CERT_DATE_INVALID |\
                                 SECURITY_FLAG_IGNORE_WRONG_USAGE)



BOOLAPI
InternetGetLastResponseInfoA(
    OUT LPDWORD lpdwError,
    OUT LPSTR lpszBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
BOOLAPI
InternetGetLastResponseInfoW(
    OUT LPDWORD lpdwError,
    OUT LPWSTR lpszBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
#ifdef UNICODE
#define InternetGetLastResponseInfo  InternetGetLastResponseInfoW
#else
#define InternetGetLastResponseInfo  InternetGetLastResponseInfoA
#endif // !UNICODE

//
// callback function for InternetSetStatusCallback
//

typedef
VOID
(CALLBACK * INTERNET_STATUS_CALLBACK)(
    IN HINTERNET hInternet,
    IN DWORD dwContext,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation OPTIONAL,
    IN DWORD dwStatusInformationLength
    );

typedef INTERNET_STATUS_CALLBACK * LPINTERNET_STATUS_CALLBACK;

INTERNETAPI
INTERNET_STATUS_CALLBACK
WINAPI
InternetSetStatusCallback(
    IN HINTERNET hInternet,
    IN INTERNET_STATUS_CALLBACK lpfnInternetCallback
    );

//
// status manifests for Internet status callback
//

#define INTERNET_STATUS_RESOLVING_NAME          10
#define INTERNET_STATUS_NAME_RESOLVED           11
#define INTERNET_STATUS_CONNECTING_TO_SERVER    20
#define INTERNET_STATUS_CONNECTED_TO_SERVER     21
#define INTERNET_STATUS_SENDING_REQUEST         30
#define INTERNET_STATUS_REQUEST_SENT            31
#define INTERNET_STATUS_RECEIVING_RESPONSE      40
#define INTERNET_STATUS_RESPONSE_RECEIVED       41
#define INTERNET_STATUS_CTL_RESPONSE_RECEIVED   42
#define INTERNET_STATUS_PREFETCH                43
#define INTERNET_STATUS_CLOSING_CONNECTION      50
#define INTERNET_STATUS_CONNECTION_CLOSED       51
#define INTERNET_STATUS_HANDLE_CREATED          60
#define INTERNET_STATUS_HANDLE_CLOSING          70
#define INTERNET_STATUS_REQUEST_COMPLETE        100
#define INTERNET_STATUS_REDIRECT                110
#define INTERNET_STATUS_INTERMEDIATE_RESPONSE   120
#define INTERNET_STATUS_STATE_CHANGE            200

//
// the following can be indicated in a state change notification:
//

#define INTERNET_STATE_CONNECTED                0x00000001  // connected state (mutually exclusive with disconnected)
#define INTERNET_STATE_DISCONNECTED             0x00000002  // disconnected from network
#define INTERNET_STATE_DISCONNECTED_BY_USER     0x00000010  // disconnected by user request
#define INTERNET_STATE_IDLE                     0x00000100  // no network requests being made (by Wininet)
#define INTERNET_STATE_BUSY                     0x00000200  // network requests being made (by Wininet)


//
// if the following value is returned by InternetSetStatusCallback, then
// probably an invalid (non-code) address was supplied for the callback
//

#define INTERNET_INVALID_STATUS_CALLBACK        ((INTERNET_STATUS_CALLBACK)(-1L))

//
// FTP
//

//
// manifests
//

#define FTP_TRANSFER_TYPE_UNKNOWN   0x00000000
#define FTP_TRANSFER_TYPE_ASCII     0x00000001
#define FTP_TRANSFER_TYPE_BINARY    0x00000002

#define FTP_TRANSFER_TYPE_MASK      (FTP_TRANSFER_TYPE_ASCII | FTP_TRANSFER_TYPE_BINARY)

//
// prototypes
//

INTERNETAPI
HINTERNET
WINAPI
FtpFindFirstFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszSearchFile OPTIONAL,
    OUT LPWIN32_FIND_DATA lpFindFileData OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
HINTERNET
WINAPI
FtpFindFirstFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszSearchFile OPTIONAL,
    OUT LPWIN32_FIND_DATA lpFindFileData OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define FtpFindFirstFile  FtpFindFirstFileW
#else
#define FtpFindFirstFile  FtpFindFirstFileA
#endif // !UNICODE

BOOLAPI
FtpGetFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszRemoteFile,
    IN LPCSTR lpszNewFile,
    IN BOOL fFailIfExists,
    IN DWORD dwFlagsAndAttributes,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
BOOLAPI
FtpGetFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszRemoteFile,
    IN LPCWSTR lpszNewFile,
    IN BOOL fFailIfExists,
    IN DWORD dwFlagsAndAttributes,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define FtpGetFile  FtpGetFileW
#else
#define FtpGetFile  FtpGetFileA
#endif // !UNICODE

BOOLAPI
FtpPutFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszLocalFile,
    IN LPCSTR lpszNewRemoteFile,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
BOOLAPI
FtpPutFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszLocalFile,
    IN LPCWSTR lpszNewRemoteFile,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define FtpPutFile  FtpPutFileW
#else
#define FtpPutFile  FtpPutFileA
#endif // !UNICODE

BOOLAPI
FtpDeleteFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszFileName
    );
BOOLAPI
FtpDeleteFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszFileName
    );
#ifdef UNICODE
#define FtpDeleteFile  FtpDeleteFileW
#else
#define FtpDeleteFile  FtpDeleteFileA
#endif // !UNICODE

BOOLAPI
FtpRenameFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszExisting,
    IN LPCSTR lpszNew
    );
BOOLAPI
FtpRenameFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszExisting,
    IN LPCWSTR lpszNew
    );
#ifdef UNICODE
#define FtpRenameFile  FtpRenameFileW
#else
#define FtpRenameFile  FtpRenameFileA
#endif // !UNICODE

INTERNETAPI
HINTERNET
WINAPI
FtpOpenFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
HINTERNET
WINAPI
FtpOpenFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define FtpOpenFile  FtpOpenFileW
#else
#define FtpOpenFile  FtpOpenFileA
#endif // !UNICODE

BOOLAPI
FtpCreateDirectoryA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszDirectory
    );
BOOLAPI
FtpCreateDirectoryW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszDirectory
    );
#ifdef UNICODE
#define FtpCreateDirectory  FtpCreateDirectoryW
#else
#define FtpCreateDirectory  FtpCreateDirectoryA
#endif // !UNICODE

BOOLAPI
FtpRemoveDirectoryA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszDirectory
    );
BOOLAPI
FtpRemoveDirectoryW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszDirectory
    );
#ifdef UNICODE
#define FtpRemoveDirectory  FtpRemoveDirectoryW
#else
#define FtpRemoveDirectory  FtpRemoveDirectoryA
#endif // !UNICODE

BOOLAPI
FtpSetCurrentDirectoryA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszDirectory
    );
BOOLAPI
FtpSetCurrentDirectoryW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszDirectory
    );
#ifdef UNICODE
#define FtpSetCurrentDirectory  FtpSetCurrentDirectoryW
#else
#define FtpSetCurrentDirectory  FtpSetCurrentDirectoryA
#endif // !UNICODE

BOOLAPI
FtpGetCurrentDirectoryA(
    IN HINTERNET hConnect,
    OUT LPSTR lpszCurrentDirectory,
    IN OUT LPDWORD lpdwCurrentDirectory
    );
BOOLAPI
FtpGetCurrentDirectoryW(
    IN HINTERNET hConnect,
    OUT LPWSTR lpszCurrentDirectory,
    IN OUT LPDWORD lpdwCurrentDirectory
    );
#ifdef UNICODE
#define FtpGetCurrentDirectory  FtpGetCurrentDirectoryW
#else
#define FtpGetCurrentDirectory  FtpGetCurrentDirectoryA
#endif // !UNICODE


//
// Gopher
//

//
// manifests
//

//
// string field lengths (in characters, not bytes)
//

#define MAX_GOPHER_DISPLAY_TEXT     128
#define MAX_GOPHER_SELECTOR_TEXT    256
#define MAX_GOPHER_HOST_NAME        INTERNET_MAX_HOST_NAME_LENGTH
#define MAX_GOPHER_LOCATOR_LENGTH   (1                                  \
                                    + MAX_GOPHER_DISPLAY_TEXT           \
                                    + 1                                 \
                                    + MAX_GOPHER_SELECTOR_TEXT          \
                                    + 1                                 \
                                    + MAX_GOPHER_HOST_NAME              \
                                    + 1                                 \
                                    + INTERNET_MAX_PORT_NUMBER_LENGTH   \
                                    + 1                                 \
                                    + 1                                 \
                                    + 2                                 \
                                    )

//
// structures/types
//

//
// GOPHER_FIND_DATA - returns the results of a GopherFindFirstFile()/
// InternetFindNextFile() request
//

typedef struct {
    CHAR   DisplayString[MAX_GOPHER_DISPLAY_TEXT + 1];
    DWORD GopherType;   // GOPHER_TYPE_, if known
    DWORD SizeLow;
    DWORD SizeHigh;
    FILETIME LastModificationTime;
    CHAR   Locator[MAX_GOPHER_LOCATOR_LENGTH + 1];
} GOPHER_FIND_DATAA, * LPGOPHER_FIND_DATAA;
typedef struct {
    WCHAR  DisplayString[MAX_GOPHER_DISPLAY_TEXT + 1];
    DWORD GopherType;   // GOPHER_TYPE_, if known
    DWORD SizeLow;
    DWORD SizeHigh;
    FILETIME LastModificationTime;
    WCHAR  Locator[MAX_GOPHER_LOCATOR_LENGTH + 1];
} GOPHER_FIND_DATAW, * LPGOPHER_FIND_DATAW;
#ifdef UNICODE
typedef GOPHER_FIND_DATAW GOPHER_FIND_DATA;
typedef LPGOPHER_FIND_DATAW LPGOPHER_FIND_DATA;
#else
typedef GOPHER_FIND_DATAA GOPHER_FIND_DATA;
typedef LPGOPHER_FIND_DATAA LPGOPHER_FIND_DATA;
#endif // UNICODE

//
// manifests for GopherType
//

#define GOPHER_TYPE_TEXT_FILE       0x00000001
#define GOPHER_TYPE_DIRECTORY       0x00000002
#define GOPHER_TYPE_CSO             0x00000004
#define GOPHER_TYPE_ERROR           0x00000008
#define GOPHER_TYPE_MAC_BINHEX      0x00000010
#define GOPHER_TYPE_DOS_ARCHIVE     0x00000020
#define GOPHER_TYPE_UNIX_UUENCODED  0x00000040
#define GOPHER_TYPE_INDEX_SERVER    0x00000080
#define GOPHER_TYPE_TELNET          0x00000100
#define GOPHER_TYPE_BINARY          0x00000200
#define GOPHER_TYPE_REDUNDANT       0x00000400
#define GOPHER_TYPE_TN3270          0x00000800
#define GOPHER_TYPE_GIF             0x00001000
#define GOPHER_TYPE_IMAGE           0x00002000
#define GOPHER_TYPE_BITMAP          0x00004000
#define GOPHER_TYPE_MOVIE           0x00008000
#define GOPHER_TYPE_SOUND           0x00010000
#define GOPHER_TYPE_HTML            0x00020000
#define GOPHER_TYPE_PDF             0x00040000
#define GOPHER_TYPE_CALENDAR        0x00080000
#define GOPHER_TYPE_INLINE          0x00100000
#define GOPHER_TYPE_UNKNOWN         0x20000000
#define GOPHER_TYPE_ASK             0x40000000
#define GOPHER_TYPE_GOPHER_PLUS     0x80000000

//
// gopher type macros
//

#define IS_GOPHER_FILE(type)            (BOOL)(((type) & GOPHER_TYPE_FILE_MASK) ? TRUE : FALSE)
#define IS_GOPHER_DIRECTORY(type)       (BOOL)(((type) & GOPHER_TYPE_DIRECTORY) ? TRUE : FALSE)
#define IS_GOPHER_PHONE_SERVER(type)    (BOOL)(((type) & GOPHER_TYPE_CSO) ? TRUE : FALSE)
#define IS_GOPHER_ERROR(type)           (BOOL)(((type) & GOPHER_TYPE_ERROR) ? TRUE : FALSE)
#define IS_GOPHER_INDEX_SERVER(type)    (BOOL)(((type) & GOPHER_TYPE_INDEX_SERVER) ? TRUE : FALSE)
#define IS_GOPHER_TELNET_SESSION(type)  (BOOL)(((type) & GOPHER_TYPE_TELNET) ? TRUE : FALSE)
#define IS_GOPHER_BACKUP_SERVER(type)   (BOOL)(((type) & GOPHER_TYPE_REDUNDANT) ? TRUE : FALSE)
#define IS_GOPHER_TN3270_SESSION(type)  (BOOL)(((type) & GOPHER_TYPE_TN3270) ? TRUE : FALSE)
#define IS_GOPHER_ASK(type)             (BOOL)(((type) & GOPHER_TYPE_ASK) ? TRUE : FALSE)
#define IS_GOPHER_PLUS(type)            (BOOL)(((type) & GOPHER_TYPE_GOPHER_PLUS) ? TRUE : FALSE)

#define IS_GOPHER_TYPE_KNOWN(type)      (BOOL)(((type) & GOPHER_TYPE_UNKNOWN) ? FALSE : TRUE)

//
// GOPHER_TYPE_FILE_MASK - use this to determine if a locator identifies a
// (known) file type
//

#define GOPHER_TYPE_FILE_MASK       (GOPHER_TYPE_TEXT_FILE          \
                                    | GOPHER_TYPE_MAC_BINHEX        \
                                    | GOPHER_TYPE_DOS_ARCHIVE       \
                                    | GOPHER_TYPE_UNIX_UUENCODED    \
                                    | GOPHER_TYPE_BINARY            \
                                    | GOPHER_TYPE_GIF               \
                                    | GOPHER_TYPE_IMAGE             \
                                    | GOPHER_TYPE_BITMAP            \
                                    | GOPHER_TYPE_MOVIE             \
                                    | GOPHER_TYPE_SOUND             \
                                    | GOPHER_TYPE_HTML              \
                                    | GOPHER_TYPE_PDF               \
                                    | GOPHER_TYPE_CALENDAR          \
                                    | GOPHER_TYPE_INLINE            \
                                    )

//
// structured gopher attributes (as defined in gopher+ protocol document)
//

typedef struct {
    LPCTSTR Comment;
    LPCTSTR EmailAddress;
} GOPHER_ADMIN_ATTRIBUTE_TYPE, * LPGOPHER_ADMIN_ATTRIBUTE_TYPE;

typedef struct {
    FILETIME DateAndTime;
} GOPHER_MOD_DATE_ATTRIBUTE_TYPE, * LPGOPHER_MOD_DATE_ATTRIBUTE_TYPE;

typedef struct {
    DWORD Ttl;
} GOPHER_TTL_ATTRIBUTE_TYPE, * LPGOPHER_TTL_ATTRIBUTE_TYPE;

typedef struct {
    INT Score;
} GOPHER_SCORE_ATTRIBUTE_TYPE, * LPGOPHER_SCORE_ATTRIBUTE_TYPE;

typedef struct {
    INT LowerBound;
    INT UpperBound;
} GOPHER_SCORE_RANGE_ATTRIBUTE_TYPE, * LPGOPHER_SCORE_RANGE_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR Site;
} GOPHER_SITE_ATTRIBUTE_TYPE, * LPGOPHER_SITE_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR Organization;
} GOPHER_ORGANIZATION_ATTRIBUTE_TYPE, * LPGOPHER_ORGANIZATION_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR Location;
} GOPHER_LOCATION_ATTRIBUTE_TYPE, * LPGOPHER_LOCATION_ATTRIBUTE_TYPE;

typedef struct {
    INT DegreesNorth;
    INT MinutesNorth;
    INT SecondsNorth;
    INT DegreesEast;
    INT MinutesEast;
    INT SecondsEast;
} GOPHER_GEOGRAPHICAL_LOCATION_ATTRIBUTE_TYPE, * LPGOPHER_GEOGRAPHICAL_LOCATION_ATTRIBUTE_TYPE;

typedef struct {
    INT Zone;
} GOPHER_TIMEZONE_ATTRIBUTE_TYPE, * LPGOPHER_TIMEZONE_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR Provider;
} GOPHER_PROVIDER_ATTRIBUTE_TYPE, * LPGOPHER_PROVIDER_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR Version;
} GOPHER_VERSION_ATTRIBUTE_TYPE, * LPGOPHER_VERSION_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR ShortAbstract;
    LPCTSTR AbstractFile;
} GOPHER_ABSTRACT_ATTRIBUTE_TYPE, * LPGOPHER_ABSTRACT_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR ContentType;
    LPCTSTR Language;
    DWORD Size;
} GOPHER_VIEW_ATTRIBUTE_TYPE, * LPGOPHER_VIEW_ATTRIBUTE_TYPE;

typedef struct {
    BOOL TreeWalk;
} GOPHER_VERONICA_ATTRIBUTE_TYPE, * LPGOPHER_VERONICA_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR QuestionType;
    LPCTSTR QuestionText;
} GOPHER_ASK_ATTRIBUTE_TYPE, * LPGOPHER_ASK_ATTRIBUTE_TYPE;

//
// GOPHER_UNKNOWN_ATTRIBUTE_TYPE - this is returned if we retrieve an attribute
// that is not specified in the current gopher/gopher+ documentation. It is up
// to the application to parse the information
//

typedef struct {
    LPCTSTR Text;
} GOPHER_UNKNOWN_ATTRIBUTE_TYPE, * LPGOPHER_UNKNOWN_ATTRIBUTE_TYPE;

//
// GOPHER_ATTRIBUTE_TYPE - returned in the user's buffer when an enumerated
// GopherGetAttribute call is made
//

typedef struct {
    DWORD CategoryId;   // e.g. GOPHER_CATEGORY_ID_ADMIN
    DWORD AttributeId;  // e.g. GOPHER_ATTRIBUTE_ID_ADMIN
    union {
        GOPHER_ADMIN_ATTRIBUTE_TYPE Admin;
        GOPHER_MOD_DATE_ATTRIBUTE_TYPE ModDate;
        GOPHER_TTL_ATTRIBUTE_TYPE Ttl;
        GOPHER_SCORE_ATTRIBUTE_TYPE Score;
        GOPHER_SCORE_RANGE_ATTRIBUTE_TYPE ScoreRange;
        GOPHER_SITE_ATTRIBUTE_TYPE Site;
        GOPHER_ORGANIZATION_ATTRIBUTE_TYPE Organization;
        GOPHER_LOCATION_ATTRIBUTE_TYPE Location;
        GOPHER_GEOGRAPHICAL_LOCATION_ATTRIBUTE_TYPE GeographicalLocation;
        GOPHER_TIMEZONE_ATTRIBUTE_TYPE TimeZone;
        GOPHER_PROVIDER_ATTRIBUTE_TYPE Provider;
        GOPHER_VERSION_ATTRIBUTE_TYPE Version;
        GOPHER_ABSTRACT_ATTRIBUTE_TYPE Abstract;
        GOPHER_VIEW_ATTRIBUTE_TYPE View;
        GOPHER_VERONICA_ATTRIBUTE_TYPE Veronica;
        GOPHER_ASK_ATTRIBUTE_TYPE Ask;
        GOPHER_UNKNOWN_ATTRIBUTE_TYPE Unknown;
    } AttributeType;
} GOPHER_ATTRIBUTE_TYPE, * LPGOPHER_ATTRIBUTE_TYPE;

#define MAX_GOPHER_CATEGORY_NAME    128     // arbitrary
#define MAX_GOPHER_ATTRIBUTE_NAME   128     //     "
#define MIN_GOPHER_ATTRIBUTE_LENGTH 256     //     "

//
// known gopher attribute categories. See below for ordinals
//

#define GOPHER_INFO_CATEGORY        TEXT("+INFO")
#define GOPHER_ADMIN_CATEGORY       TEXT("+ADMIN")
#define GOPHER_VIEWS_CATEGORY       TEXT("+VIEWS")
#define GOPHER_ABSTRACT_CATEGORY    TEXT("+ABSTRACT")
#define GOPHER_VERONICA_CATEGORY    TEXT("+VERONICA")

//
// known gopher attributes. These are the attribute names as defined in the
// gopher+ protocol document
//

#define GOPHER_ADMIN_ATTRIBUTE      TEXT("Admin")
#define GOPHER_MOD_DATE_ATTRIBUTE   TEXT("Mod-Date")
#define GOPHER_TTL_ATTRIBUTE        TEXT("TTL")
#define GOPHER_SCORE_ATTRIBUTE      TEXT("Score")
#define GOPHER_RANGE_ATTRIBUTE      TEXT("Score-range")
#define GOPHER_SITE_ATTRIBUTE       TEXT("Site")
#define GOPHER_ORG_ATTRIBUTE        TEXT("Org")
#define GOPHER_LOCATION_ATTRIBUTE   TEXT("Loc")
#define GOPHER_GEOG_ATTRIBUTE       TEXT("Geog")
#define GOPHER_TIMEZONE_ATTRIBUTE   TEXT("TZ")
#define GOPHER_PROVIDER_ATTRIBUTE   TEXT("Provider")
#define GOPHER_VERSION_ATTRIBUTE    TEXT("Version")
#define GOPHER_ABSTRACT_ATTRIBUTE   TEXT("Abstract")
#define GOPHER_VIEW_ATTRIBUTE       TEXT("View")
#define GOPHER_TREEWALK_ATTRIBUTE   TEXT("treewalk")

//
// identifiers for attribute strings
//

#define GOPHER_ATTRIBUTE_ID_BASE        0xabcccc00

#define GOPHER_CATEGORY_ID_ALL          (GOPHER_ATTRIBUTE_ID_BASE + 1)

#define GOPHER_CATEGORY_ID_INFO         (GOPHER_ATTRIBUTE_ID_BASE + 2)
#define GOPHER_CATEGORY_ID_ADMIN        (GOPHER_ATTRIBUTE_ID_BASE + 3)
#define GOPHER_CATEGORY_ID_VIEWS        (GOPHER_ATTRIBUTE_ID_BASE + 4)
#define GOPHER_CATEGORY_ID_ABSTRACT     (GOPHER_ATTRIBUTE_ID_BASE + 5)
#define GOPHER_CATEGORY_ID_VERONICA     (GOPHER_ATTRIBUTE_ID_BASE + 6)
#define GOPHER_CATEGORY_ID_ASK          (GOPHER_ATTRIBUTE_ID_BASE + 7)

#define GOPHER_CATEGORY_ID_UNKNOWN      (GOPHER_ATTRIBUTE_ID_BASE + 8)

#define GOPHER_ATTRIBUTE_ID_ALL         (GOPHER_ATTRIBUTE_ID_BASE + 9)

#define GOPHER_ATTRIBUTE_ID_ADMIN       (GOPHER_ATTRIBUTE_ID_BASE + 10)
#define GOPHER_ATTRIBUTE_ID_MOD_DATE    (GOPHER_ATTRIBUTE_ID_BASE + 11)
#define GOPHER_ATTRIBUTE_ID_TTL         (GOPHER_ATTRIBUTE_ID_BASE + 12)
#define GOPHER_ATTRIBUTE_ID_SCORE       (GOPHER_ATTRIBUTE_ID_BASE + 13)
#define GOPHER_ATTRIBUTE_ID_RANGE       (GOPHER_ATTRIBUTE_ID_BASE + 14)
#define GOPHER_ATTRIBUTE_ID_SITE        (GOPHER_ATTRIBUTE_ID_BASE + 15)
#define GOPHER_ATTRIBUTE_ID_ORG         (GOPHER_ATTRIBUTE_ID_BASE + 16)
#define GOPHER_ATTRIBUTE_ID_LOCATION    (GOPHER_ATTRIBUTE_ID_BASE + 17)
#define GOPHER_ATTRIBUTE_ID_GEOG        (GOPHER_ATTRIBUTE_ID_BASE + 18)
#define GOPHER_ATTRIBUTE_ID_TIMEZONE    (GOPHER_ATTRIBUTE_ID_BASE + 19)
#define GOPHER_ATTRIBUTE_ID_PROVIDER    (GOPHER_ATTRIBUTE_ID_BASE + 20)
#define GOPHER_ATTRIBUTE_ID_VERSION     (GOPHER_ATTRIBUTE_ID_BASE + 21)
#define GOPHER_ATTRIBUTE_ID_ABSTRACT    (GOPHER_ATTRIBUTE_ID_BASE + 22)
#define GOPHER_ATTRIBUTE_ID_VIEW        (GOPHER_ATTRIBUTE_ID_BASE + 23)
#define GOPHER_ATTRIBUTE_ID_TREEWALK    (GOPHER_ATTRIBUTE_ID_BASE + 24)

#define GOPHER_ATTRIBUTE_ID_UNKNOWN     (GOPHER_ATTRIBUTE_ID_BASE + 25)

//
// prototypes
//

BOOLAPI
GopherCreateLocatorA(
    IN LPCSTR lpszHost,
    IN INTERNET_PORT nServerPort,
    IN LPCSTR lpszDisplayString OPTIONAL,
    IN LPCSTR lpszSelectorString OPTIONAL,
    IN DWORD dwGopherType,
    OUT LPSTR lpszLocator OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
BOOLAPI
GopherCreateLocatorW(
    IN LPCWSTR lpszHost,
    IN INTERNET_PORT nServerPort,
    IN LPCWSTR lpszDisplayString OPTIONAL,
    IN LPCWSTR lpszSelectorString OPTIONAL,
    IN DWORD dwGopherType,
    OUT LPWSTR lpszLocator OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
#ifdef UNICODE
#define GopherCreateLocator  GopherCreateLocatorW
#else
#define GopherCreateLocator  GopherCreateLocatorA
#endif // !UNICODE

BOOLAPI
GopherGetLocatorTypeA(
    IN LPCSTR lpszLocator,
    OUT LPDWORD lpdwGopherType
    );
BOOLAPI
GopherGetLocatorTypeW(
    IN LPCWSTR lpszLocator,
    OUT LPDWORD lpdwGopherType
    );
#ifdef UNICODE
#define GopherGetLocatorType  GopherGetLocatorTypeW
#else
#define GopherGetLocatorType  GopherGetLocatorTypeA
#endif // !UNICODE

INTERNETAPI
HINTERNET
WINAPI
GopherFindFirstFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszLocator OPTIONAL,
    IN LPCSTR lpszSearchString OPTIONAL,
    OUT LPGOPHER_FIND_DATAA lpFindData OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
HINTERNET
WINAPI
GopherFindFirstFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszLocator OPTIONAL,
    IN LPCWSTR lpszSearchString OPTIONAL,
    OUT LPGOPHER_FIND_DATAW lpFindData OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define GopherFindFirstFile  GopherFindFirstFileW
#else
#define GopherFindFirstFile  GopherFindFirstFileA
#endif // !UNICODE

INTERNETAPI
HINTERNET
WINAPI
GopherOpenFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszLocator,
    IN LPCSTR lpszView OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
HINTERNET
WINAPI
GopherOpenFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszLocator,
    IN LPCWSTR lpszView OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define GopherOpenFile  GopherOpenFileW
#else
#define GopherOpenFile  GopherOpenFileA
#endif // !UNICODE

typedef
BOOL
(CALLBACK * GOPHER_ATTRIBUTE_ENUMERATOR)(
    LPGOPHER_ATTRIBUTE_TYPE lpAttributeInfo,
    DWORD dwError
    );

BOOLAPI
GopherGetAttributeA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszLocator,
    IN LPCSTR lpszAttributeName OPTIONAL,
    OUT LPBYTE lpBuffer,
    IN DWORD dwBufferLength,
    OUT LPDWORD lpdwCharactersReturned,
    IN GOPHER_ATTRIBUTE_ENUMERATOR lpfnEnumerator OPTIONAL,
    IN DWORD dwContext
    );
BOOLAPI
GopherGetAttributeW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszLocator,
    IN LPCWSTR lpszAttributeName OPTIONAL,
    OUT LPBYTE lpBuffer,
    IN DWORD dwBufferLength,
    OUT LPDWORD lpdwCharactersReturned,
    IN GOPHER_ATTRIBUTE_ENUMERATOR lpfnEnumerator OPTIONAL,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define GopherGetAttribute  GopherGetAttributeW
#else
#define GopherGetAttribute  GopherGetAttributeA
#endif // !UNICODE

//
// HTTP
//

//
// manifests
//

//
// the default major/minor HTTP version numbers
//

#define HTTP_MAJOR_VERSION      1
#define HTTP_MINOR_VERSION      0

#define HTTP_VERSION            TEXT("HTTP/1.0")

//
// HttpQueryInfo info levels. Generally, there is one info level
// for each potential RFC822/HTTP/MIME header that an HTTP server
// may send as part of a request response.
//
// The HTTP_QUERY_RAW_HEADERS info level is provided for clients
// that choose to perform their own header parsing.
//

#define HTTP_QUERY_MIME_VERSION                 0
#define HTTP_QUERY_CONTENT_TYPE                 1
#define HTTP_QUERY_CONTENT_TRANSFER_ENCODING    2
#define HTTP_QUERY_CONTENT_ID                   3
#define HTTP_QUERY_CONTENT_DESCRIPTION          4
#define HTTP_QUERY_CONTENT_LENGTH               5
#define HTTP_QUERY_CONTENT_LANGUAGE             6
#define HTTP_QUERY_ALLOW                        7
#define HTTP_QUERY_PUBLIC                       8
#define HTTP_QUERY_DATE                         9
#define HTTP_QUERY_EXPIRES                      10
#define HTTP_QUERY_LAST_MODIFIED                11
#define HTTP_QUERY_MESSAGE_ID                   12
#define HTTP_QUERY_URI                          13
#define HTTP_QUERY_DERIVED_FROM                 14
#define HTTP_QUERY_COST                         15
#define HTTP_QUERY_LINK                         16
#define HTTP_QUERY_PRAGMA                       17
#define HTTP_QUERY_VERSION                      18  // special: part of status line
#define HTTP_QUERY_STATUS_CODE                  19  // special: part of status line
#define HTTP_QUERY_STATUS_TEXT                  20  // special: part of status line
#define HTTP_QUERY_RAW_HEADERS                  21  // special: all headers as ASCIIZ
#define HTTP_QUERY_RAW_HEADERS_CRLF             22  // special: all headers
#define HTTP_QUERY_CONNECTION                   23
#define HTTP_QUERY_ACCEPT                       24
#define HTTP_QUERY_ACCEPT_CHARSET               25
#define HTTP_QUERY_ACCEPT_ENCODING              26
#define HTTP_QUERY_ACCEPT_LANGUAGE              27
#define HTTP_QUERY_AUTHORIZATION                28
#define HTTP_QUERY_CONTENT_ENCODING             29
#define HTTP_QUERY_FORWARDED                    30
#define HTTP_QUERY_FROM                         31
#define HTTP_QUERY_IF_MODIFIED_SINCE            32
#define HTTP_QUERY_LOCATION                     33
#define HTTP_QUERY_ORIG_URI                     34
#define HTTP_QUERY_REFERER                      35
#define HTTP_QUERY_RETRY_AFTER                  36
#define HTTP_QUERY_SERVER                       37
#define HTTP_QUERY_TITLE                        38
#define HTTP_QUERY_USER_AGENT                   39
#define HTTP_QUERY_WWW_AUTHENTICATE             40
#define HTTP_QUERY_PROXY_AUTHENTICATE           41
#define HTTP_QUERY_ACCEPT_RANGES                42
#define HTTP_QUERY_SET_COOKIE                   43
#define HTTP_QUERY_COOKIE                       44
#define HTTP_QUERY_REQUEST_METHOD               45  // special: GET/POST etc.
#define HTTP_QUERY_REFRESH                      46
#define HTTP_QUERY_CONTENT_DISPOSITION          47

//
// HTTP 1.1 defined headers
//

#define HTTP_QUERY_AGE                          48
#define HTTP_QUERY_CACHE_CONTROL                49
#define HTTP_QUERY_CONTENT_BASE                 50
#define HTTP_QUERY_CONTENT_LOCATION             51
#define HTTP_QUERY_CONTENT_MD5                  52
#define HTTP_QUERY_CONTENT_RANGE                53
#define HTTP_QUERY_ETAG                         54
#define HTTP_QUERY_HOST                         55
#define HTTP_QUERY_IF_MATCH                     56
#define HTTP_QUERY_IF_NONE_MATCH                57
#define HTTP_QUERY_IF_RANGE                     58
#define HTTP_QUERY_IF_UNMODIFIED_SINCE          59
#define HTTP_QUERY_MAX_FORWARDS                 60
#define HTTP_QUERY_PROXY_AUTHORIZATION          61
#define HTTP_QUERY_RANGE                        62
#define HTTP_QUERY_TRANSFER_ENCODING            63
#define HTTP_QUERY_UPGRADE                      64
#define HTTP_QUERY_VARY                         65
#define HTTP_QUERY_VIA                          66
#define HTTP_QUERY_WARNING                      67

#define HTTP_QUERY_MAX                          67

//
// HTTP_QUERY_CUSTOM - if this special value is supplied as the dwInfoLevel
// parameter of HttpQueryInfo() then the lpBuffer parameter contains the name
// of the header we are to query
//

#define HTTP_QUERY_CUSTOM                       65535

//
// HTTP_QUERY_FLAG_REQUEST_HEADERS - if this bit is set in the dwInfoLevel
// parameter of HttpQueryInfo() then the request headers will be queried for the
// request information
//

#define HTTP_QUERY_FLAG_REQUEST_HEADERS         0x80000000

//
// HTTP_QUERY_FLAG_SYSTEMTIME - if this bit is set in the dwInfoLevel parameter
// of HttpQueryInfo() AND the header being queried contains date information,
// e.g. the "Expires:" header then lpBuffer will contain a SYSTEMTIME structure
// containing the date and time information converted from the header string
//

#define HTTP_QUERY_FLAG_SYSTEMTIME              0x40000000

//
// HTTP_QUERY_FLAG_NUMBER - if this bit is set in the dwInfoLevel parameter of
// HttpQueryInfo(), then the value of the header will be converted to a number
// before being returned to the caller, if applicable
//

#define HTTP_QUERY_FLAG_NUMBER                  0x20000000

//
// HTTP_QUERY_FLAG_COALESCE - combine the values from several headers of the
// same name into the output buffer
//

#define HTTP_QUERY_FLAG_COALESCE                0x10000000


#define HTTP_QUERY_MODIFIER_FLAGS_MASK          (HTTP_QUERY_FLAG_REQUEST_HEADERS    \
                                                | HTTP_QUERY_FLAG_SYSTEMTIME        \
                                                | HTTP_QUERY_FLAG_NUMBER            \
                                                | HTTP_QUERY_FLAG_COALESCE          \
                                                )

#define HTTP_QUERY_HEADER_MASK                  (~HTTP_QUERY_MODIFIER_FLAGS_MASK)

//
// HTTP Response Status Codes:
//

#define HTTP_STATUS_CONTINUE            100 // OK to continue with request
#define HTTP_STATUS_SWITCH_PROTOCOLS    101 // server has switched protocols in upgrade header

#define HTTP_STATUS_OK                  200 // request completed
#define HTTP_STATUS_CREATED             201 // object created, reason = new URI
#define HTTP_STATUS_ACCEPTED            202 // async completion (TBS)
#define HTTP_STATUS_PARTIAL             203 // partial completion
#define HTTP_STATUS_NO_CONTENT          204 // no info to return
#define HTTP_STATUS_RESET_CONTENT       205 // request completed, but clear form
#define HTTP_STATUS_PARTIAL_CONTENT     206 // partial GET furfilled

#define HTTP_STATUS_AMBIGUOUS           300 // server couldn't decide what to return
#define HTTP_STATUS_MOVED               301 // object permanently moved
#define HTTP_STATUS_REDIRECT            302 // object temporarily moved
#define HTTP_STATUS_REDIRECT_METHOD     303 // redirection w/ new access method
#define HTTP_STATUS_NOT_MODIFIED        304 // if-modified-since was not modified
#define HTTP_STATUS_USE_PROXY           305 // redirection to proxy, location header specifies proxy to use
#define HTTP_STATUS_REDIRECT_KEEP_VERB  307 // HTTP/1.1: keep same verb

#define HTTP_STATUS_BAD_REQUEST         400 // invalid syntax
#define HTTP_STATUS_DENIED              401 // access denied
#define HTTP_STATUS_PAYMENT_REQ         402 // payment required
#define HTTP_STATUS_FORBIDDEN           403 // request forbidden
#define HTTP_STATUS_NOT_FOUND           404 // object not found
#define HTTP_STATUS_BAD_METHOD          405 // method is not allowed
#define HTTP_STATUS_NONE_ACCEPTABLE     406 // no response acceptable to client found
#define HTTP_STATUS_PROXY_AUTH_REQ      407 // proxy authentication required
#define HTTP_STATUS_REQUEST_TIMEOUT     408 // server timed out waiting for request
#define HTTP_STATUS_CONFLICT            409 // user should resubmit with more info
#define HTTP_STATUS_GONE                410 // the resource is no longer available
#define HTTP_STATUS_LENGTH_REQUIRED     411 // the server refused to accept request w/o a length
#define HTTP_STATUS_PRECOND_FAILED      412 // precondition given in request failed
#define HTTP_STATUS_REQUEST_TOO_LARGE   413 // request entity was too large
#define HTTP_STATUS_URI_TOO_LONG        414 // request URI too long
#define HTTP_STATUS_UNSUPPORTED_MEDIA   415 // unsupported media type

#define HTTP_STATUS_SERVER_ERROR        500 // internal server error
#define HTTP_STATUS_NOT_SUPPORTED       501 // required not supported
#define HTTP_STATUS_BAD_GATEWAY         502 // error response received from gateway
#define HTTP_STATUS_SERVICE_UNAVAIL     503 // temporarily overloaded
#define HTTP_STATUS_GATEWAY_TIMEOUT     504 // timed out waiting for gateway
#define HTTP_STATUS_VERSION_NOT_SUP     505 // HTTP version not supported

#define HTTP_STATUS_FIRST               HTTP_STATUS_CONTINUE
#define HTTP_STATUS_LAST                HTTP_STATUS_VERSION_NOT_SUP

//
// prototypes
//

INTERNETAPI
HINTERNET
WINAPI
HttpOpenRequestA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszVerb,
    IN LPCSTR lpszObjectName,
    IN LPCSTR lpszVersion,
    IN LPCSTR lpszReferrer OPTIONAL,
    IN LPCSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
HINTERNET
WINAPI
HttpOpenRequestW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszVerb,
    IN LPCWSTR lpszObjectName,
    IN LPCWSTR lpszVersion,
    IN LPCWSTR lpszReferrer OPTIONAL,
    IN LPCWSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define HttpOpenRequest  HttpOpenRequestW
#else
#define HttpOpenRequest  HttpOpenRequestA
#endif // !UNICODE

BOOLAPI
HttpAddRequestHeadersA(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    );
BOOLAPI
HttpAddRequestHeadersW(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    );
#ifdef UNICODE
#define HttpAddRequestHeaders  HttpAddRequestHeadersW
#else
#define HttpAddRequestHeaders  HttpAddRequestHeadersA
#endif // !UNICODE

//
// values for dwModifiers parameter of HttpAddRequestHeaders()
//

#define HTTP_ADDREQ_INDEX_MASK      0x0000FFFF
#define HTTP_ADDREQ_FLAGS_MASK      0xFFFF0000

//
// HTTP_ADDREQ_FLAG_ADD_IF_NEW - the header will only be added if it doesn't
// already exist
//

#define HTTP_ADDREQ_FLAG_ADD_IF_NEW 0x10000000

//
// HTTP_ADDREQ_FLAG_ADD - if HTTP_ADDREQ_FLAG_REPLACE is set but the header is
// not found then if this flag is set, the header is added anyway, so long as
// there is a valid header-value
//

#define HTTP_ADDREQ_FLAG_ADD        0x20000000

//
// HTTP_ADDREQ_FLAG_COALESCE - coalesce headers with same name. e.g.
// "Accept: text/*" and "Accept: audio/*" with this flag results in a single
// header: "Accept: text/*, audio/*"
//

#define HTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA       0x40000000
#define HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON   0x01000000
#define HTTP_ADDREQ_FLAG_COALESCE                  HTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA

//
// HTTP_ADDREQ_FLAG_REPLACE - replaces the specified header. Only one header can
// be supplied in the buffer. If the header to be replaced is not the first
// in a list of headers with the same name, then the relative index should be
// supplied in the low 8 bits of the dwModifiers parameter. If the header-value
// part is missing, then the header is removed
//

#define HTTP_ADDREQ_FLAG_REPLACE    0x80000000

BOOLAPI
HttpSendRequestA(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    );
BOOLAPI
HttpSendRequestW(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    );
#ifdef UNICODE
#define HttpSendRequest  HttpSendRequestW
#else
#define HttpSendRequest  HttpSendRequestA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
HttpSendRequestExA(
    IN HINTERNET hRequest,
    IN LPINTERNET_BUFFERSA lpBuffersIn OPTIONAL,
    OUT LPINTERNET_BUFFERSA lpBuffersOut OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
BOOL
WINAPI
HttpSendRequestExW(
    IN HINTERNET hRequest,
    IN LPINTERNET_BUFFERSW lpBuffersIn OPTIONAL,
    OUT LPINTERNET_BUFFERSW lpBuffersOut OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define HttpSendRequestEx  HttpSendRequestExW
#else
#define HttpSendRequestEx  HttpSendRequestExA
#endif // !UNICODE

//
// flags for HttpSendRequestEx(), HttpEndRequest()
//

#define HSR_ASYNC       WININET_API_FLAG_ASYNC          // force async
#define HSR_SYNC        WININET_API_FLAG_SYNC           // force sync
#define HSR_USE_CONTEXT WININET_API_FLAG_USE_CONTEXT    // use dwContext value
#define HSR_INITIATE    0x00000008                      // iterative operation (completed by HttpEndRequest)
#define HSR_DOWNLOAD    0x00000010                      // download to file
#define HSR_CHUNKED     0x00000020                      // operation is send of chunked data

INTERNETAPI
BOOL
WINAPI
HttpEndRequestA(
    IN HINTERNET hRequest,
    OUT LPINTERNET_BUFFERSA lpBuffersOut OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
BOOL
WINAPI
HttpEndRequestW(
    IN HINTERNET hRequest,
    OUT LPINTERNET_BUFFERSW lpBuffersOut OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define HttpEndRequest  HttpEndRequestW
#else
#define HttpEndRequest  HttpEndRequestA
#endif // !UNICODE

BOOLAPI
HttpQueryInfoA(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    );
BOOLAPI
HttpQueryInfoW(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    );
#ifdef UNICODE
#define HttpQueryInfo  HttpQueryInfoW
#else
#define HttpQueryInfo  HttpQueryInfoA
#endif // !UNICODE

//
// Cookie APIs
//


BOOLAPI
InternetSetCookieA(
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszCookieName,
    IN LPCSTR lpszCookieData
    );
BOOLAPI
InternetSetCookieW(
    IN LPCSTR lpszUrl,
    IN LPCWSTR lpszCookieName,
    IN LPCWSTR lpszCookieData
    );
#ifdef UNICODE
#define InternetSetCookie  InternetSetCookieW
#else
#define InternetSetCookie  InternetSetCookieA
#endif // !UNICODE

BOOLAPI
InternetGetCookieA(
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszCookieName,
    OUT LPSTR lpCookieData,
    IN OUT LPDWORD lpdwSize
    );
BOOLAPI
InternetGetCookieW(
    IN LPCSTR lpszUrl,
    IN LPCWSTR lpszCookieName,
    OUT LPWSTR lpCookieData,
    IN OUT LPDWORD lpdwSize
    );
#ifdef UNICODE
#define InternetGetCookie  InternetGetCookieW
#else
#define InternetGetCookie  InternetGetCookieA
#endif // !UNICODE


//
// offline browsing
//

INTERNETAPI
DWORD
WINAPI
InternetAttemptConnect(
    IN DWORD dwReserved
    );

BOOLAPI
InternetCheckConnectionA(
    IN LPCSTR lpszUrl,
    IN DWORD dwFlags,
    IN DWORD dwReserved
    );
BOOLAPI
InternetCheckConnectionW(
    IN LPCWSTR lpszUrl,
    IN DWORD dwFlags,
    IN DWORD dwReserved
    );
#ifdef UNICODE
#define InternetCheckConnection  InternetCheckConnectionW
#else
#define InternetCheckConnection  InternetCheckConnectionA
#endif // !UNICODE

#define FLAG_ICC_FORCE_CONNECTION       0x00000001

//
// Internet UI
//

//
// InternetErrorDlg - Provides UI for certain Errors.
//

#define FLAGS_ERROR_UI_FILTER_FOR_ERRORS        0x01
#define FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS     0x02
#define FLAGS_ERROR_UI_FLAGS_GENERATE_DATA      0x04
#define FLAGS_ERROR_UI_FLAGS_NO_UI              0x08
#define FLAGS_ERROR_UI_SERIALIZE_DIALOGS        0x10

//
// If SERIALIZE_DIALOGS flag set, client should implement thread-safe non-blocking callback...
//

DWORD InternetAuthNotifyCallback
(
    DWORD           dwContext,    // as passed to InternetErrorDlg
    DWORD           dwReturn,     // error code: success, resend, or cancel
    LPVOID          lpReserved    // reserved: will be set to null
);
typedef DWORD (CALLBACK * PFN_AUTH_NOTIFY) (DWORD, DWORD, LPVOID);

//
// ... and last parameter of InternetErrorDlg should point to...
//

typedef struct
{
    DWORD            cbStruct;    // size of this structure
    DWORD            dwOptions;   // reserved: must set to 0
    PFN_AUTH_NOTIFY  pfnNotify;   // notification callback to retry InternetErrorDlg
    DWORD            dwContext;   // context to pass to to notification function
}
    INTERNET_AUTH_NOTIFY_DATA;


INTERNETAPI
DWORD
WINAPI
InternetErrorDlg(
    IN HWND hWnd,
    IN OUT HINTERNET hRequest,
    IN DWORD dwError,
    IN DWORD dwFlags,
    IN OUT LPVOID * lppvData
    );

INTERNETAPI
DWORD
WINAPI
InternetConfirmZoneCrossing(
    IN HWND hWnd,
    IN LPSTR szUrlPrev,
    IN LPSTR szUrlNew,
    IN BOOL bPost
    );


//#if !defined(_WINERROR_)

//
// Internet API error returns
//

#define INTERNET_ERROR_BASE                     12000

#define ERROR_INTERNET_OUT_OF_HANDLES           (INTERNET_ERROR_BASE + 1)
#define ERROR_INTERNET_TIMEOUT                  (INTERNET_ERROR_BASE + 2)
#define ERROR_INTERNET_EXTENDED_ERROR           (INTERNET_ERROR_BASE + 3)
#define ERROR_INTERNET_INTERNAL_ERROR           (INTERNET_ERROR_BASE + 4)
#define ERROR_INTERNET_INVALID_URL              (INTERNET_ERROR_BASE + 5)
#define ERROR_INTERNET_UNRECOGNIZED_SCHEME      (INTERNET_ERROR_BASE + 6)
#define ERROR_INTERNET_NAME_NOT_RESOLVED        (INTERNET_ERROR_BASE + 7)
#define ERROR_INTERNET_PROTOCOL_NOT_FOUND       (INTERNET_ERROR_BASE + 8)
#define ERROR_INTERNET_INVALID_OPTION           (INTERNET_ERROR_BASE + 9)
#define ERROR_INTERNET_BAD_OPTION_LENGTH        (INTERNET_ERROR_BASE + 10)
#define ERROR_INTERNET_OPTION_NOT_SETTABLE      (INTERNET_ERROR_BASE + 11)
#define ERROR_INTERNET_SHUTDOWN                 (INTERNET_ERROR_BASE + 12)
#define ERROR_INTERNET_INCORRECT_USER_NAME      (INTERNET_ERROR_BASE + 13)
#define ERROR_INTERNET_INCORRECT_PASSWORD       (INTERNET_ERROR_BASE + 14)
#define ERROR_INTERNET_LOGIN_FAILURE            (INTERNET_ERROR_BASE + 15)
#define ERROR_INTERNET_INVALID_OPERATION        (INTERNET_ERROR_BASE + 16)
#define ERROR_INTERNET_OPERATION_CANCELLED      (INTERNET_ERROR_BASE + 17)
#define ERROR_INTERNET_INCORRECT_HANDLE_TYPE    (INTERNET_ERROR_BASE + 18)
#define ERROR_INTERNET_INCORRECT_HANDLE_STATE   (INTERNET_ERROR_BASE + 19)
#define ERROR_INTERNET_NOT_PROXY_REQUEST        (INTERNET_ERROR_BASE + 20)
#define ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND (INTERNET_ERROR_BASE + 21)
#define ERROR_INTERNET_BAD_REGISTRY_PARAMETER   (INTERNET_ERROR_BASE + 22)
#define ERROR_INTERNET_NO_DIRECT_ACCESS         (INTERNET_ERROR_BASE + 23)
#define ERROR_INTERNET_NO_CONTEXT               (INTERNET_ERROR_BASE + 24)
#define ERROR_INTERNET_NO_CALLBACK              (INTERNET_ERROR_BASE + 25)
#define ERROR_INTERNET_REQUEST_PENDING          (INTERNET_ERROR_BASE + 26)
#define ERROR_INTERNET_INCORRECT_FORMAT         (INTERNET_ERROR_BASE + 27)
#define ERROR_INTERNET_ITEM_NOT_FOUND           (INTERNET_ERROR_BASE + 28)
#define ERROR_INTERNET_CANNOT_CONNECT           (INTERNET_ERROR_BASE + 29)
#define ERROR_INTERNET_CONNECTION_ABORTED       (INTERNET_ERROR_BASE + 30)
#define ERROR_INTERNET_CONNECTION_RESET         (INTERNET_ERROR_BASE + 31)
#define ERROR_INTERNET_FORCE_RETRY              (INTERNET_ERROR_BASE + 32)
#define ERROR_INTERNET_INVALID_PROXY_REQUEST    (INTERNET_ERROR_BASE + 33)
#define ERROR_INTERNET_NEED_UI                  (INTERNET_ERROR_BASE + 34)

#define ERROR_INTERNET_HANDLE_EXISTS            (INTERNET_ERROR_BASE + 36)
#define ERROR_INTERNET_SEC_CERT_DATE_INVALID    (INTERNET_ERROR_BASE + 37)
#define ERROR_INTERNET_SEC_CERT_CN_INVALID      (INTERNET_ERROR_BASE + 38)
#define ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR   (INTERNET_ERROR_BASE + 39)
#define ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR   (INTERNET_ERROR_BASE + 40)
#define ERROR_INTERNET_MIXED_SECURITY           (INTERNET_ERROR_BASE + 41)
#define ERROR_INTERNET_CHG_POST_IS_NON_SECURE   (INTERNET_ERROR_BASE + 42)
#define ERROR_INTERNET_POST_IS_NON_SECURE       (INTERNET_ERROR_BASE + 43)
#define ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED  (INTERNET_ERROR_BASE + 44)
#define ERROR_INTERNET_INVALID_CA               (INTERNET_ERROR_BASE + 45)
#define ERROR_INTERNET_CLIENT_AUTH_NOT_SETUP    (INTERNET_ERROR_BASE + 46)
#define ERROR_INTERNET_ASYNC_THREAD_FAILED      (INTERNET_ERROR_BASE + 47)
#define ERROR_INTERNET_REDIRECT_SCHEME_CHANGE   (INTERNET_ERROR_BASE + 48)
#define ERROR_INTERNET_DIALOG_PENDING           (INTERNET_ERROR_BASE + 49)
#define ERROR_INTERNET_RETRY_DIALOG             (INTERNET_ERROR_BASE + 50)
#define ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR  (INTERNET_ERROR_BASE + 52)
#define ERROR_INTERNET_INSERT_CDROM             (INTERNET_ERROR_BASE + 53)


//
// FTP API errors
//

#define ERROR_FTP_TRANSFER_IN_PROGRESS          (INTERNET_ERROR_BASE + 110)
#define ERROR_FTP_DROPPED                       (INTERNET_ERROR_BASE + 111)
#define ERROR_FTP_NO_PASSIVE_MODE               (INTERNET_ERROR_BASE + 112)

//
// gopher API errors
//

#define ERROR_GOPHER_PROTOCOL_ERROR             (INTERNET_ERROR_BASE + 130)
#define ERROR_GOPHER_NOT_FILE                   (INTERNET_ERROR_BASE + 131)
#define ERROR_GOPHER_DATA_ERROR                 (INTERNET_ERROR_BASE + 132)
#define ERROR_GOPHER_END_OF_DATA                (INTERNET_ERROR_BASE + 133)
#define ERROR_GOPHER_INVALID_LOCATOR            (INTERNET_ERROR_BASE + 134)
#define ERROR_GOPHER_INCORRECT_LOCATOR_TYPE     (INTERNET_ERROR_BASE + 135)
#define ERROR_GOPHER_NOT_GOPHER_PLUS            (INTERNET_ERROR_BASE + 136)
#define ERROR_GOPHER_ATTRIBUTE_NOT_FOUND        (INTERNET_ERROR_BASE + 137)
#define ERROR_GOPHER_UNKNOWN_LOCATOR            (INTERNET_ERROR_BASE + 138)

//
// HTTP API errors
//

#define ERROR_HTTP_HEADER_NOT_FOUND             (INTERNET_ERROR_BASE + 150)
#define ERROR_HTTP_DOWNLEVEL_SERVER             (INTERNET_ERROR_BASE + 151)
#define ERROR_HTTP_INVALID_SERVER_RESPONSE      (INTERNET_ERROR_BASE + 152)
#define ERROR_HTTP_INVALID_HEADER               (INTERNET_ERROR_BASE + 153)
#define ERROR_HTTP_INVALID_QUERY_REQUEST        (INTERNET_ERROR_BASE + 154)
#define ERROR_HTTP_HEADER_ALREADY_EXISTS        (INTERNET_ERROR_BASE + 155)
#define ERROR_HTTP_REDIRECT_FAILED              (INTERNET_ERROR_BASE + 156)
#define ERROR_HTTP_NOT_REDIRECTED               (INTERNET_ERROR_BASE + 160)
#define ERROR_HTTP_COOKIE_NEEDS_CONFIRMATION    (INTERNET_ERROR_BASE + 161)
#define ERROR_HTTP_COOKIE_DECLINED              (INTERNET_ERROR_BASE + 162)
#define ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION  (INTERNET_ERROR_BASE + 168)

//
// additional Internet API error codes
//

#define ERROR_INTERNET_SECURITY_CHANNEL_ERROR   (INTERNET_ERROR_BASE + 157)
#define ERROR_INTERNET_UNABLE_TO_CACHE_FILE     (INTERNET_ERROR_BASE + 158)
#define ERROR_INTERNET_TCPIP_NOT_INSTALLED      (INTERNET_ERROR_BASE + 159)
#define ERROR_INTERNET_DISCONNECTED             (INTERNET_ERROR_BASE + 163)
#define ERROR_INTERNET_SERVER_UNREACHABLE       (INTERNET_ERROR_BASE + 164)
#define ERROR_INTERNET_PROXY_SERVER_UNREACHABLE (INTERNET_ERROR_BASE + 165)

#define ERROR_INTERNET_BAD_AUTO_PROXY_SCRIPT    (INTERNET_ERROR_BASE + 166)
#define ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT (INTERNET_ERROR_BASE + 167)
#define ERROR_INTERNET_SEC_INVALID_CERT    (INTERNET_ERROR_BASE + 169)
#define ERROR_INTERNET_SEC_CERT_REVOKED    (INTERNET_ERROR_BASE + 170)

// InternetAutodial specific errors

#define ERROR_INTERNET_FAILED_DUETOSECURITYCHECK  (INTERNET_ERROR_BASE + 171)

#define INTERNET_ERROR_LAST                       ERROR_INTERNET_FAILED_DUETOSECURITYCHECK


//#endif // !defined(_WINERROR_)

//
// URLCACHE APIs
//

//
// datatype definitions.
//

//
// cache entry type flags.
//

#define NORMAL_CACHE_ENTRY              0x00000001
#define COOKIE_CACHE_ENTRY              0x00100000
#define URLHISTORY_CACHE_ENTRY          0x00200000
#define TRACK_OFFLINE_CACHE_ENTRY       0x00000010
#define TRACK_ONLINE_CACHE_ENTRY        0x00000020
#define STICKY_CACHE_ENTRY              0x00000004
#define SPARSE_CACHE_ENTRY              0x00010000



#define URLCACHE_FIND_DEFAULT_FILTER    NORMAL_CACHE_ENTRY             \
                                    |   COOKIE_CACHE_ENTRY             \
                                    |   URLHISTORY_CACHE_ENTRY         \
                                    |   TRACK_OFFLINE_CACHE_ENTRY      \
                                    |   TRACK_ONLINE_CACHE_ENTRY       \
                                    |   STICKY_CACHE_ENTRY



//
// INTERNET_CACHE_ENTRY_INFO -
//


typedef struct _INTERNET_CACHE_ENTRY_INFOA {
    DWORD dwStructSize;         // version of cache system.
    LPSTR lpszSourceUrlName;    // embedded pointer to the URL name string.
    LPSTR   lpszLocalFileName;  // embedded pointer to the local file name.
    DWORD CacheEntryType;       // cache type bit mask.
    DWORD dwUseCount;           // current users count of the cache entry.
    DWORD dwHitRate;            // num of times the cache entry was retrieved.
    DWORD dwSizeLow;            // low DWORD of the file size.
    DWORD dwSizeHigh;           // high DWORD of the file size.
    FILETIME LastModifiedTime;  // last modified time of the file in GMT format.
    FILETIME ExpireTime;        // expire time of the file in GMT format
    FILETIME LastAccessTime;    // last accessed time in GMT format
    FILETIME LastSyncTime;      // last time the URL was synchronized
                                // with the source
    LPBYTE lpHeaderInfo;        // embedded pointer to the header info.
    DWORD dwHeaderInfoSize;     // size of the above header.
    LPSTR   lpszFileExtension;  // File extension used to retrive the urldata as a file.
        union {                     // Exemption delta from last access time.
                DWORD dwReserved;
                DWORD dwExemptDelta;
    };                          // Exemption delta from last access
} INTERNET_CACHE_ENTRY_INFOA, * LPINTERNET_CACHE_ENTRY_INFOA;
typedef struct _INTERNET_CACHE_ENTRY_INFOW {
    DWORD dwStructSize;         // version of cache system.
    LPSTR lpszSourceUrlName;    // embedded pointer to the URL name string.
    LPWSTR  lpszLocalFileName;  // embedded pointer to the local file name.
    DWORD CacheEntryType;       // cache type bit mask.
    DWORD dwUseCount;           // current users count of the cache entry.
    DWORD dwHitRate;            // num of times the cache entry was retrieved.
    DWORD dwSizeLow;            // low DWORD of the file size.
    DWORD dwSizeHigh;           // high DWORD of the file size.
    FILETIME LastModifiedTime;  // last modified time of the file in GMT format.
    FILETIME ExpireTime;        // expire time of the file in GMT format
    FILETIME LastAccessTime;    // last accessed time in GMT format
    FILETIME LastSyncTime;      // last time the URL was synchronized
                                // with the source
    LPBYTE lpHeaderInfo;        // embedded pointer to the header info.
    DWORD dwHeaderInfoSize;     // size of the above header.
    LPWSTR  lpszFileExtension;  // File extension used to retrive the urldata as a file.
        union {                     // Exemption delta from last access time.
                DWORD dwReserved;
                DWORD dwExemptDelta;
    };                          // Exemption delta from last access
} INTERNET_CACHE_ENTRY_INFOW, * LPINTERNET_CACHE_ENTRY_INFOW;
#ifdef UNICODE
typedef INTERNET_CACHE_ENTRY_INFOW INTERNET_CACHE_ENTRY_INFO;
typedef LPINTERNET_CACHE_ENTRY_INFOW LPINTERNET_CACHE_ENTRY_INFO;
#else
typedef INTERNET_CACHE_ENTRY_INFOA INTERNET_CACHE_ENTRY_INFO;
typedef LPINTERNET_CACHE_ENTRY_INFOA LPINTERNET_CACHE_ENTRY_INFO;
#endif // UNICODE


//
// Cache APIs
//

BOOLAPI
CreateUrlCacheEntryA(
    IN LPCSTR lpszUrlName,
    IN DWORD dwExpectedFileSize,
    IN LPCSTR lpszFileExtension,
    OUT LPSTR lpszFileName,
    IN DWORD dwReserved
    );
BOOLAPI
CreateUrlCacheEntryW(
    IN LPCSTR lpszUrlName,
    IN DWORD dwExpectedFileSize,
    IN LPCSTR lpszFileExtension,
    OUT LPWSTR lpszFileName,
    IN DWORD dwReserved
    );
#ifdef UNICODE
#define CreateUrlCacheEntry  CreateUrlCacheEntryW
#else
#define CreateUrlCacheEntry  CreateUrlCacheEntryA
#endif // !UNICODE

BOOLAPI
CommitUrlCacheEntryA(
    IN LPCSTR lpszUrlName,
    IN LPCSTR lpszLocalFileName,
    IN FILETIME ExpireTime,
    IN FILETIME LastModifiedTime,
    IN DWORD CacheEntryType,
    IN LPBYTE lpHeaderInfo,
    IN DWORD dwHeaderSize,
    IN LPCSTR lpszFileExtension,
    IN DWORD dwReserved
    );
BOOLAPI
CommitUrlCacheEntryW(
    IN LPCSTR lpszUrlName,
    IN LPCWSTR lpszLocalFileName,
    IN FILETIME ExpireTime,
    IN FILETIME LastModifiedTime,
    IN DWORD CacheEntryType,
    IN LPBYTE lpHeaderInfo,
    IN DWORD dwHeaderSize,
    IN LPCWSTR lpszFileExtension,
    IN DWORD dwReserved
    );
#ifdef UNICODE
#define CommitUrlCacheEntry  CommitUrlCacheEntryW
#else
#define CommitUrlCacheEntry  CommitUrlCacheEntryA
#endif // !UNICODE

BOOLAPI
RetrieveUrlCacheEntryFileA(
    IN LPCSTR  lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize,
    IN DWORD dwReserved
    );
BOOLAPI
RetrieveUrlCacheEntryFileW(
    IN LPCSTR  lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize,
    IN DWORD dwReserved
    );
#ifdef UNICODE
#define RetrieveUrlCacheEntryFile  RetrieveUrlCacheEntryFileW
#else
#define RetrieveUrlCacheEntryFile  RetrieveUrlCacheEntryFileA
#endif // !UNICODE

BOOLAPI
UnlockUrlCacheEntryFile(
    IN LPCSTR lpszUrlName,
    IN DWORD dwReserved
    );

INTERNETAPI
HANDLE
WINAPI
RetrieveUrlCacheEntryStreamA(
    IN LPCSTR  lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize,
    IN BOOL fRandomRead,
    IN DWORD dwReserved
    );
INTERNETAPI
HANDLE
WINAPI
RetrieveUrlCacheEntryStreamW(
    IN LPCSTR  lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize,
    IN BOOL fRandomRead,
    IN DWORD dwReserved
    );
#ifdef UNICODE
#define RetrieveUrlCacheEntryStream  RetrieveUrlCacheEntryStreamW
#else
#define RetrieveUrlCacheEntryStream  RetrieveUrlCacheEntryStreamA
#endif // !UNICODE

BOOLAPI
ReadUrlCacheEntryStream(
    IN HANDLE hUrlCacheStream,
    IN DWORD dwLocation,
    IN OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwLen,
    IN DWORD Reserved
    );

BOOLAPI
UnlockUrlCacheEntryStream(
    IN HANDLE hUrlCacheStream,
    IN DWORD Reserved
    );


BOOLAPI
GetUrlCacheEntryInfoA(
    IN LPCSTR lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize
    );
BOOLAPI
GetUrlCacheEntryInfoW(
    IN LPCSTR lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize
    );
#ifdef UNICODE
#define GetUrlCacheEntryInfo  GetUrlCacheEntryInfoW
#else
#define GetUrlCacheEntryInfo  GetUrlCacheEntryInfoA
#endif // !UNICODE


BOOLAPI
GetUrlCacheEntryInfoExA(
    IN LPCSTR lpszUrl,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufSize,
    OUT LPSTR      lpszReserved,  // must pass null
    IN OUT LPDWORD lpdwReserved,  // must pass null
    LPVOID         lpReserved,    // must pass null
    DWORD          dwFlags        // reserved
    );
BOOLAPI
GetUrlCacheEntryInfoExW(
    IN LPCSTR lpszUrl,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufSize,
    OUT LPSTR      lpszReserved,  // must pass null
    IN OUT LPDWORD lpdwReserved,  // must pass null
    LPVOID         lpReserved,    // must pass null
    DWORD          dwFlags        // reserved
    );
#ifdef UNICODE
#define GetUrlCacheEntryInfoEx  GetUrlCacheEntryInfoExW
#else
#define GetUrlCacheEntryInfoEx  GetUrlCacheEntryInfoExA
#endif // !UNICODE

#define CACHE_ENTRY_ATTRIBUTE_FC    0x00000004
#define CACHE_ENTRY_HITRATE_FC      0x00000010
#define CACHE_ENTRY_MODTIME_FC      0x00000040
#define CACHE_ENTRY_EXPTIME_FC      0x00000080
#define CACHE_ENTRY_ACCTIME_FC      0x00000100
#define CACHE_ENTRY_SYNCTIME_FC     0x00000200
#define CACHE_ENTRY_HEADERINFO_FC   0x00000400
#define CACHE_ENTRY_EXEMPT_DELTA_FC 0x00000800


BOOLAPI
SetUrlCacheEntryInfoA(
    IN LPCSTR lpszUrlName,
    IN LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN DWORD dwFieldControl
    );
BOOLAPI
SetUrlCacheEntryInfoW(
    IN LPCSTR lpszUrlName,
    IN LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN DWORD dwFieldControl
    );
#ifdef UNICODE
#define SetUrlCacheEntryInfo  SetUrlCacheEntryInfoW
#else
#define SetUrlCacheEntryInfo  SetUrlCacheEntryInfoA
#endif // !UNICODE

//
// Cache Group Functions
//

typedef LONGLONG GROUPID;

INTERNETAPI
GROUPID
WINAPI
CreateUrlCacheGroup(
    IN DWORD  dwFlags,
    IN LPVOID lpReserved  // must pass NULL
    );

BOOLAPI
DeleteUrlCacheGroup(
    IN  GROUPID GroupId,
    IN  DWORD   dwFlags,       // must pass 0
    IN  LPVOID  lpReserved     // must pass NULL
    );

// Flags for SetUrlCacheEntryGroup
#define INTERNET_CACHE_GROUP_ADD      0
#define INTERNET_CACHE_GROUP_REMOVE   1

BOOLAPI
SetUrlCacheEntryGroup(
    IN LPCSTR   lpszUrlName,
    IN DWORD    dwFlags,
    IN GROUPID  GroupId,
    IN LPBYTE   pbGroupAttributes, // must pass NULL
    IN DWORD    cbGroupAttributes, // must pass 0
    IN LPVOID   lpReserved         // must pass NULL
    );

INTERNETAPI
HANDLE
WINAPI
FindFirstUrlCacheEntryExA(
    IN     LPCSTR    lpszUrlSearchPattern,
    IN     DWORD     dwFlags,
    IN     DWORD     dwFilter,
    IN     GROUPID   GroupId,
    OUT    LPINTERNET_CACHE_ENTRY_INFOA lpFirstCacheEntryInfo,
    IN OUT LPDWORD   lpdwFirstCacheEntryInfoBufferSize,
    OUT    LPVOID    lpGroupAttributes,     // must pass NULL
    IN OUT LPDWORD   pcbGroupAttributes,    // must pass NULL
    IN     LPVOID    lpReserved             // must pass NULL
    );
INTERNETAPI
HANDLE
WINAPI
FindFirstUrlCacheEntryExW(
    IN     LPCSTR    lpszUrlSearchPattern,
    IN     DWORD     dwFlags,
    IN     DWORD     dwFilter,
    IN     GROUPID   GroupId,
    OUT    LPINTERNET_CACHE_ENTRY_INFOW lpFirstCacheEntryInfo,
    IN OUT LPDWORD   lpdwFirstCacheEntryInfoBufferSize,
    OUT    LPVOID    lpGroupAttributes,     // must pass NULL
    IN OUT LPDWORD   pcbGroupAttributes,    // must pass NULL
    IN     LPVOID    lpReserved             // must pass NULL
    );
#ifdef UNICODE
#define FindFirstUrlCacheEntryEx  FindFirstUrlCacheEntryExW
#else
#define FindFirstUrlCacheEntryEx  FindFirstUrlCacheEntryExA
#endif // !UNICODE

BOOLAPI
FindNextUrlCacheEntryExA(
    IN     HANDLE    hEnumHandle,
    OUT    LPINTERNET_CACHE_ENTRY_INFOA lpFirstCacheEntryInfo,
    IN OUT LPDWORD   lpdwFirstCacheEntryInfoBufferSize,
    OUT    LPVOID    lpGroupAttributes,     // must pass NULL
    IN OUT LPDWORD   pcbGroupAttributes,    // must pass NULL
    IN     LPVOID    lpReserved             // must pass NULL
    );
BOOLAPI
FindNextUrlCacheEntryExW(
    IN     HANDLE    hEnumHandle,
    OUT    LPINTERNET_CACHE_ENTRY_INFOW lpFirstCacheEntryInfo,
    IN OUT LPDWORD   lpdwFirstCacheEntryInfoBufferSize,
    OUT    LPVOID    lpGroupAttributes,     // must pass NULL
    IN OUT LPDWORD   pcbGroupAttributes,    // must pass NULL
    IN     LPVOID    lpReserved             // must pass NULL
    );
#ifdef UNICODE
#define FindNextUrlCacheEntryEx  FindNextUrlCacheEntryExW
#else
#define FindNextUrlCacheEntryEx  FindNextUrlCacheEntryExA
#endif // !UNICODE

INTERNETAPI
HANDLE
WINAPI
FindFirstUrlCacheEntryA(
    IN LPCSTR lpszUrlSearchPattern,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpFirstCacheEntryInfo,
    IN OUT LPDWORD lpdwFirstCacheEntryInfoBufferSize
    );
INTERNETAPI
HANDLE
WINAPI
FindFirstUrlCacheEntryW(
    IN LPCSTR lpszUrlSearchPattern,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpFirstCacheEntryInfo,
    IN OUT LPDWORD lpdwFirstCacheEntryInfoBufferSize
    );
#ifdef UNICODE
#define FindFirstUrlCacheEntry  FindFirstUrlCacheEntryW
#else
#define FindFirstUrlCacheEntry  FindFirstUrlCacheEntryA
#endif // !UNICODE

BOOLAPI
FindNextUrlCacheEntryA(
    IN HANDLE hEnumHandle,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpNextCacheEntryInfo,
    IN OUT LPDWORD lpdwNextCacheEntryInfoBufferSize
    );
BOOLAPI
FindNextUrlCacheEntryW(
    IN HANDLE hEnumHandle,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpNextCacheEntryInfo,
    IN OUT LPDWORD lpdwNextCacheEntryInfoBufferSize
    );
#ifdef UNICODE
#define FindNextUrlCacheEntry  FindNextUrlCacheEntryW
#else
#define FindNextUrlCacheEntry  FindNextUrlCacheEntryA
#endif // !UNICODE


BOOLAPI
FindCloseUrlCache(
    IN HANDLE hEnumHandle
    );

BOOLAPI
DeleteUrlCacheEntry(
    IN LPCSTR lpszUrlName
    );



//
// Autodial APIs
//

INTERNETAPI
DWORD
WINAPI
InternetDial(
    IN HWND     hwndParent,
    IN LPTSTR   lpszConnectoid,
    IN DWORD    dwFlags,
    OUT LPDWORD lpdwConnection,
    IN DWORD    dwReserved);

// Flags for InternetDial - must not conflict with InternetAutodial flags
//                          as they are valid here also.
#define INTERNET_DIAL_UNATTENDED       0x8000

INTERNETAPI
DWORD
WINAPI
InternetHangUp(
    IN DWORD    dwConnection,
    IN DWORD    dwReserved);

#define INTERENT_GOONLINE_REFRESH 0x00000001
#define INTERENT_GOONLINE_MASK 0x00000001
INTERNETAPI
BOOL
WINAPI
InternetGoOnline(
    IN LPTSTR   lpszURL,
    IN HWND     hwndParent,
    IN DWORD    dwFlags);

INTERNETAPI
BOOL
WINAPI
InternetAutodial(
    IN DWORD    dwFlags,
    IN DWORD    dwReserved);

// Flags for InternetAutodial
#define INTERNET_AUTODIAL_FORCE_ONLINE          1
#define INTERNET_AUTODIAL_FORCE_UNATTENDED      2
#define INTERNET_AUTODIAL_FAILIFSECURITYCHECK   4

#define INTERNET_AUTODIAL_FLAGS_MASK (INTERNET_AUTODIAL_FORCE_ONLINE | INTERNET_AUTODIAL_FORCE_UNATTENDED | INTERNET_AUTODIAL_FAILIFSECURITYCHECK)
INTERNETAPI
BOOL
WINAPI
InternetAutodialHangup(
    IN DWORD    dwReserved);

INTERNETAPI
BOOL
WINAPI
InternetGetConnectedState(
    OUT LPDWORD  lpdwFlags,
    IN DWORD    dwReserved);

// Flags for InternetGetConnectedState
#define INTERNET_CONNECTION_MODEM           1
#define INTERNET_CONNECTION_LAN             2
#define INTERNET_CONNECTION_PROXY           4
#define INTERNET_CONNECTION_MODEM_BUSY      8

//
// Custom dial handler functions
//

// Custom dial handler prototype
typedef DWORD (CALLBACK * PFN_DIAL_HANDLER) (HWND, LPCSTR, DWORD, LPDWORD);

// Flags for custom dial handler
#define INTERNET_CUSTOMDIAL_CONNECT         0
#define INTERNET_CUSTOMDIAL_UNATTENDED      1
#define INTERNET_CUSTOMDIAL_DISCONNECT      2

// Custom dial handler supported functionality flags
#define INTERNET_CUSTOMDIAL_SAFE_FOR_UNATTENDED 1
#define INTERNET_CUSTOMDIAL_WILL_SUPPLY_STATE   2
#define INTERNET_CUSTOMDIAL_CAN_HANGUP          4

INTERNETAPI
BOOL
WINAPI
InternetSetDialState(
    IN LPCTSTR  lpszConnectoid,
    IN DWORD    dwState,
    IN DWORD    dwReserved);

// States for InternetSetDialState
#define INTERNET_DIALSTATE_DISCONNECTED     1




#if defined(__cplusplus)
}
#endif


/*
 * Return packing to whatever it was before we
 * entered this file
 */
#pragma pack(pop, wininet)


#endif // !defined(_WININET_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\bkgd.c ===
/* BKGD.C
   Resident Code Segment      // Tweak: make non-resident?

   Most of this code is taken from the display CPLs adjusted to
   work with the Theme Switcher and cleaned up a little.

   Routines for painting the preview box in the main window
      Desktop (wallpaper/pattern/color)
      Icons
      Windows

   Frosting: Master Theme Selector for Windows '95
   Copyright (c) 1994-1998 Microsoft Corporation
*/

// ---------------------------------------------
// Brief file history:
// Alpha:
// Beta:
// Bug fixes
// ---------

#include "windows.h"
#include "frost.h"
#include "global.h"
#include "adutil.h"

#include "bkgd.h"
#include "LoadImag.h"
#include "htmlprev.h"
#include "schedule.h"  // IsPlatormNT and GetCurrentUser

// #define BMPOUT 333         // debugging aid
#ifdef BMPOUT
#define BmpOut(x,y,z);    hbmDebOld=SelectObject(hdcDeb,x);BitBlt(hdcOut,0,0,y,z,hdcDeb,0,0,SRCCOPY);SelectObject(hdcDeb,hbmDebOld);
#define PrevOut();    BitBlt(hdcOut,0,0,dxPreview,dyPreview,g_hdcMem,0,0,SRCCOPY);
#endif

// globals
extern BOOL bInGrphFilter;   // frost.c Currently in a graphics filter?
TCHAR szCP_DT[]    = TEXT("Control Panel\\Desktop");
TCHAR szWP[]       = TEXT("Wallpaper");
TCHAR szTileWP[]   = TEXT("TileWallpaper");
extern TCHAR szWPStyle[];
TCHAR szPat[]      = TEXT("Pattern");
extern TCHAR szSS_Active[];

extern HPALETTE hpal3D;         // fakewin.c

HBITMAP  g_hbmPreview = NULL;	// the bitmap used for previewing
HDC      g_hdcMem = NULL;

HBITMAP  g_hbmWall = NULL;      // bitmap image of wallpaper
HDC      g_hdcWall = NULL;      // memory DC with g_hbmWall selected
HPALETTE g_hpalWall = NULL;     // palette that goes with hbmWall bitmap
HBRUSH   g_hbrBack = NULL;      // brush for the desktop background

HBITMAP g_hbmDefault = NULL;
DWORD dwStyle = 0;              // WP Style for new ActiveDesktop interface

// L o c a l   R o u t i n e s
COLORREF GetThemeColor(LPTSTR, int);

extern TCHAR szFrostSection[];
extern TCHAR szThemeBPP[];
extern TCHAR szImageBPP[];
       TCHAR szImageDither[] = TEXT("Dither");
       TCHAR szImageStretch[] = TEXT("Stretch");
       TCHAR szPlusKey[] = TEXT("Software\\Microsoft\\Plus!\\Themes");

//
// if the theme is 8bpp only load 8bpp images (bpp=8)
// otherwise load the best for the display (bpp=-1)
//
// currently this is kind of bogus, we should mark the 8bit themes
// as 8bit not the other way around!
//
// return
//      -1      load the image at the depth of the display
//      8       load the image at 8bpp
//
int GetImageBPP(LPCTSTR lpszThemeFile)
{
    int bpp = -1;

    if (*lpszThemeFile && bCBStates[FC_WALL]) {

        bpp = GetPrivateProfileInt(szFrostSection, szImageBPP, -1, lpszThemeFile);

        if (bpp != 8)
            bpp = -1;
    }

    return bpp;
}

//
//
// When applying wallpaper (if decompressed from a .jpg), first check:
// are user profiles enabled?
// HKLM\Network\Logon, UserProfiles=<dword> will be non-zero if
// profiles are enabled.
//
// then
// Call WNetGetUser to get the username
// then look under:
// HKLM\Software\Microsoft\Windows\CurrentVersion\ProfileList\<username>
//  there should be a value ProfileImagePath which is the local path.
//
//then store Plus!.bmp there

void GetPlusBitmapName(LPTSTR szPlus)
{
    HKEY hkey;
    DWORD dw;
    UINT cb;
    TCHAR key[80];
    TCHAR ach[80];

    if (!GetWindowsDirectory(szPlus, MAX_PATH))
    {
        szPlus[0] = 0;
    }

    if (IsPlatformNT())
    {
       // User profiles are always enabled un NT so find the correct
       // path
       TCHAR szAccount[MAX_PATH];
       TCHAR szDomain[MAX_PATH];

       GetCurrentUser(szAccount, ARRAYSIZE(szAccount),
                      szDomain, ARRAYSIZE(szDomain),
                      szPlus, MAX_PATH);

       InstantiatePath(szPlus, ARRAYSIZE(szPlus));
       Assert(FALSE, TEXT("Plus!.BMP path: "));
       Assert(FALSE, szPlus);
       Assert(FALSE, TEXT("\n"));
    }
    else if (RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("Network\\Logon"), &hkey) == 0)
    {
        cb = sizeof(dw); dw = 0;
        RegQueryValueEx(hkey, TEXT("UserProfiles"), NULL, NULL, (LPVOID)&dw, &cb);
        RegCloseKey(hkey);

        if (dw != 0)
        {
            cb = ARRAYSIZE(ach); ach[0] = 0;
            WNetGetUser(NULL, ach, &cb);

            if (ach[0])
            {
                wsprintf(key, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\ProfileList\\%s"), ach);
                if (RegOpenKey(HKEY_LOCAL_MACHINE, key, &hkey) == 0)
                {
                    cb = sizeof(ach); ach[0] = 0;
                    RegQueryValueEx(hkey, TEXT("ProfileImagePath"), NULL, NULL, (LPBYTE)ach, &cb);
                    RegCloseKey(hkey);

                    if (ach[0] && GetFileAttributes(ach) != -1)
                    {
                        lstrcpy(szPlus, ach);
                        Assert(FALSE, TEXT("Plus!.BMP path: "));
                        Assert(FALSE, szPlus);
                        Assert(FALSE, TEXT("\n"));
                    }
                }
            }
        }
    }

    lstrcat(szPlus, TEXT("\\Plus!.bmp"));
}

//
//  LoadWallpaper
//
HBITMAP LoadWallpaper(LPTSTR szWallpaper, LPTSTR szThemeFile, BOOL fPreview)
{
    HBITMAP hbm=NULL;
    TCHAR plus_bmp[MAX_PATH];  //DSCHOTT switched from 128 to MAX_PATH
    TCHAR ach[MAX_PATH];       //DSCHOTT switched from 128 to MAX_PATH
    int dx, dy;
    DWORD dw;
    int bpp    = GetImageBPP(szThemeFile);
    int dither = DITHER_CUSTOM;
    int tile   = GetRegInt(HKEY_CURRENT_USER, szCP_DT, szTileWP, 0);
    int stretch= GetRegInt(HKEY_CURRENT_USER, szCP_DT, szWPStyle, 0) & 2;

    // If a theme is selected, and we are using a plus wall paper then
    // find out if tiling is on, and what style to use from the ini file.
    // Otherwise, we already got the information from the registry.
    if (szThemeFile && *szThemeFile && bCBStates[FC_WALL])
    {
        tile   = GetPrivateProfileInt(szCP_DT, szTileWP, tile, szThemeFile);
        stretch= GetPrivateProfileInt(szCP_DT, szWPStyle, stretch, szThemeFile) & 2;
        dither = GetPrivateProfileInt(szFrostSection, szImageDither, dither, szThemeFile);
        stretch= GetPrivateProfileInt(szFrostSection, szImageStretch, stretch, szThemeFile);
    }

    //
    // allow the user to override theme switches
    //
    bpp    = GetRegInt(HKEY_CURRENT_USER, szPlusKey, szImageBPP, bpp);
    dither = GetRegInt(HKEY_CURRENT_USER, szPlusKey, szImageDither, dither);

    // First try getting this stretch value from IActiveDesktop if
    // it's on.
    if (IsActiveDesktopOn()) {
       if (GetADWPOptions(&dw)) if (WPSTYLE_STRETCH == dw) stretch = 1;
    }
    // AD is off so get the Stretch value from the registry
    else stretch= GetRegInt(HKEY_CURRENT_USER, szPlusKey,
                                           szImageStretch, stretch);


    // If our wallpaper is an HTML page we need to force stretching
    // on and tiling off

    if (szWallpaper && ((lstrcmpi(FindExtension(szWallpaper),TEXT(".htm")) == 0) ||
                        (lstrcmpi(FindExtension(szWallpaper),TEXT(".html")) == 0)))
    {
       tile = 0;
       stretch = 1;
    }

    //
    // if the stretch wallpaper option is set (style & 2) then load the
    // wallpaper the size of our preview window, else we need to load the
    // wallpaper in the right proportion (passing a <0 size to
    // LoadImageFromFile will cause it to stretch it)
    //

    if (!tile && stretch)
    {
        dx  = fPreview ? dxPreview : GetSystemMetrics(SM_CXSCREEN);
        dy  = fPreview ? dyPreview : GetSystemMetrics(SM_CYSCREEN);
    }
    else
    {
        dx = fPreview ? -dxPreview : 0;
        dy = fPreview ? -dyPreview : 0;
    }

    // Build a full path to the plus!.bmp file
    GetPlusBitmapName(plus_bmp);
    ach[0] = 0;
    dw = GetImageTitle(plus_bmp, ach, sizeof(ach));

    //
    // see if we can use Plus!.bmp
    //
    if (ach[0] && lstrcmpi(ach, szWallpaper) == 0 && (dx==0 || (int)dw==MAKELONG(dx,dy)))
    {
        szWallpaper = plus_bmp;
    }
    return CacheLoadImageFromFile(szWallpaper, dx, dy, bpp, dither);
}

// PaintPreview
//
// This is the routine that draws the entire preview area: the
// background image, three icons, and the sample window preview.
// The sample window is drawn with MS-supplied code.
//
void FAR PaintPreview(HWND hDlg, HDC hdc, PRECT prect)
{
   HBITMAP hbmOld;

   //
   // inits
   //
   hbmOld = SelectObject(g_hdcMem, g_hbmPreview);
   if (g_hpalWall)
   {
       SelectPalette(hdc, g_hpalWall, FALSE);
       RealizePalette(hdc);
   }

   //
   // painting: assume clip rect set correctly already
   BitBlt(hdc, rView.left, rView.top, dxPreview, dyPreview, g_hdcMem, 0, 0, SRCCOPY);

   //
   // cleanup
   if (g_hpalWall)
      SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), TRUE);
   SelectObject(g_hdcMem, hbmOld);
}


/*--------------------------------------------------------------------
** Build the preview bitmap.

   Gets the settings from the current theme file and inits
   a preview bitmap for later painting.

   Start with the pattern or wallpaper or bkgd color.
   Add the icons and then the sample windows.

   Started with control panel code and did a lot of customization,
   including more comments, especially where made additions.
   Uses settings either from cur theme file, or if that is null
   then from system settings (i.e. for Cur Win Settings).

   Not as robust as I'd like, but seems to be acceptable for CPL.
   Tried to speed some things up, since this gets called on each
   combo box selection.

**--------------------------------------------------------------------*/

// virtual boolean: null theme name means Cur Win Settings, not from theme file
#define bThemed (*lpszThemeFile)


void FAR PASCAL BuildPreviewBitmap(LPTSTR lpszThemeFile)
{
   UINT uret;
   UINT style;
   UINT tile;
   HBRUSH hbr = NULL;
   HBITMAP hbmTemp;
   HBITMAP hbmOld;
   BITMAP bm;
   COLORREF clrOldBk, clrOldText;
   WORD patbits[CXYDESKPATTERN] = {0, 0, 0, 0, 0, 0, 0, 0};
   int     i;
   int     dxWall;          // size of wallpaper
   int     dyWall;

   #ifdef BMPOUT
   HDC hdcOut;
   HDC hdcDeb;
   HBITMAP hbmDebOld;

   hdcOut = GetDC(NULL);
   hdcDeb = CreateCompatibleDC(hdcOut);
   #endif

   Assert(FALSE, TEXT("Building Preview bitmap: "));
   Assert(FALSE, szCurThemeName);
   Assert(FALSE, TEXT("\n"));

   hbmOld = SelectObject(g_hdcMem, g_hbmPreview);

   /*
   ** first, fill in the pattern all over the bitmap
   */

	// get rid of old brush if there was one
   if (g_hbrBack)
	   DeleteObject(g_hbrBack);
   g_hbrBack = NULL;

   // get pattern from current theme file
   if (bThemed && bCBStates[FC_WALL]) {    // theme file and checkbox
      uret = (UINT) GetPrivateProfileString((LPTSTR)szCP_DT, (LPTSTR)szPat,
                                          (LPTSTR)szNULL,
                                          (LPTSTR)pValue, MAX_VALUELEN,
                                          lpszThemeFile);
      Assert(uret, TEXT("problem getting stored pattern for preview bmp\n"));
   }
   // or, from the system
   else {            // cur system settings
      // If ActiveDesktop is enabled we'll get the current settings
      // from the IActiveDesktop interface otherwise we'll do it
      // the "old" way by reading directly from the registry.
      if (IsActiveDesktopOn()) {
         if (!GetADWPPattern(pValue)) {
            // Failed to get pattern so invalidate the pattern
            // by making string look like (None).
            pValue[0] = TEXT('(');
         }
      }
      else {
         // No AD so do it the old way.
         GetRegString(HKEY_CURRENT_USER, szCP_DT, szPat,
                                   szNULL, pValue, (MAX_VALUELEN * sizeof(TCHAR)));
      }
   }

   // if you got a pattern, use it
        if (*pValue && (pValue[0] != TEXT('(')))  // INTERNATIONAL? null or (None) cases
                     // 5/95: "(None)" no longer written to registry by Win95
	{
      TranslatePattern(pValue, patbits);	
	   hbmTemp = CreateBitmap(8, 8, 1, 1, patbits);
	   if (hbmTemp)
	   {
         #ifdef BMPOUT
         BmpOut(hbmTemp,8,8);
         #endif

		   g_hbrBack = CreatePatternBrush(hbmTemp);
		   DeleteObject(hbmTemp);
	   }
	}
	else              // no pattern, so make a background brush
	{
      if (bThemed && bCBStates[FC_COLORS])   // theme file and checkbox
   	   g_hbrBack = CreateSolidBrush(GetThemeColor(lpszThemeFile, COLOR_BACKGROUND));
      else           // cur system settings
   	   g_hbrBack = CreateSolidBrush(GetSysColor(COLOR_BACKGROUND));
	}
	if (!g_hbrBack)
	   g_hbrBack = GetStockObject(BLACK_BRUSH);

   //
   // now do the actual pattern painting
   if (bThemed && bCBStates[FC_COLORS]) {    // theme file and checkbox
      clrOldText = SetTextColor(g_hdcMem, GetThemeColor(lpszThemeFile, COLOR_BACKGROUND));
      clrOldBk = SetBkColor(g_hdcMem, GetThemeColor(lpszThemeFile, COLOR_WINDOWTEXT));
   }
   else {            // cur system settings
      clrOldText = SetTextColor(g_hdcMem, GetSysColor(COLOR_BACKGROUND));
      clrOldBk = SetBkColor(g_hdcMem, GetSysColor(COLOR_WINDOWTEXT));
   }
   hbr = SelectObject(g_hdcMem, g_hbrBack);
   PatBlt(g_hdcMem, 0, 0, dxPreview, dyPreview, PATCOPY);
   SelectObject(g_hdcMem, hbr);

   #ifdef BMPOUT
   BmpOut(g_hbmPreview,dxPreview,dyPreview);
   PrevOut();
   #endif

   SetTextColor(g_hdcMem, clrOldText);
   SetBkColor(g_hdcMem, clrOldBk);

   /*
   ** now, position the wallpaper appropriately
   */

   // get rid of old wallpaper if there is any
   if (g_hbmWall)
   {
       SelectObject(g_hdcWall, g_hbmDefault);
       CacheDeleteBitmap(g_hbmWall);
       g_hbmWall = NULL;

       if (g_hpalWall)
       {
            if (g_hpalWall != hpal3D)
                DeleteObject(g_hpalWall);
            g_hpalWall = NULL;
       }
   }

   // call this early so hpal3D get setup (we will need it
   // to build the preview bitmap)
   FakewinSetTheme(lpszThemeFile);

   // get wallpaper bitmap from current theme file
   if (bThemed && bCBStates[FC_WALL]) {    // theme file and checkbox
      uret = (UINT) GetPrivateProfileString((LPTSTR)szCP_DT, (LPTSTR)szWP,
                                          (LPTSTR)szNULL,
                                          (LPTSTR)pValue, MAX_VALUELEN,
                                          lpszThemeFile);
//      Assert(uret, TEXT("problem getting stored wallpaper file for preview bmp\n"));
      InstantiatePath((LPTSTR)pValue, MAX_VALUELEN);
      // search for file if necessary, see if found
      if (ConfirmFile((LPTSTR)pValue, TRUE) == CF_NOTFOUND) {
         GetRegString(HKEY_CURRENT_USER, szCP_DT, szWP, NULL, pValue, (MAX_VALUELEN * sizeof(TCHAR)));
      }
   }
   // or, from the system
   else {            // cur system settings
      // If ActiveDesktop is enabled we'll get the current settings
      // from the IActiveDesktop interface otherwise we'll do it
      // the "old" way by reading directly from the registry.
      if (IsActiveDesktopOn()) {
         if (!GetADWallpaper(pValue)) {
            // Failed to get Wallpaper so invalidate the Wallpaper
            pValue[0] = TEXT('\0');
         }
      }
      else {
         // No AD so do it the old way.
         GetRegString(HKEY_CURRENT_USER, szCP_DT, szWP, NULL,
                                                  pValue, (MAX_VALUELEN * sizeof(TCHAR)));
      }
   }

   // If ActiveDesktop is on get the Wallpaper options (Tile/Stretch/Center)
   // from the AD interface.  Otherwise read directly from the registry.
   tile = 0;
   style = 0;
   if (IsActiveDesktopOn()) {
      if (GetADWPOptions(&dwStyle)) {
         if (WPSTYLE_TILE == dwStyle) tile = 1;
         if (WPSTYLE_STRETCH == dwStyle) style = 2;  // 2 means stretch
         // Don't care about center apparently.
      }
   }
   else {
   // AD is not on so get this information from the registry.
      tile  = GetRegInt(HKEY_CURRENT_USER, szCP_DT, szTileWP, 0);
      style = GetRegInt(HKEY_CURRENT_USER, szCP_DT, szWPStyle, 0);
   }

   // check tile flag, get information from theme file
   if (bThemed && bCBStates[FC_WALL]) {    // theme file and checkbox
      tile  = GetPrivateProfileInt(szCP_DT, szTileWP, tile, lpszThemeFile);
      style = GetPrivateProfileInt(szCP_DT, szWPStyle, style, lpszThemeFile);
   }

   if (*pValue && (pValue[0] != TEXT('(')))
        // PLUS98 BUG 1093
        // Don't call into the graphics filter if we're currently in the
        // graphics filter.  Doing so will fault.
        if (!bInGrphFilter) {
           EnableWindow(GetDlgItem(hWndApp, DDL_THEME), FALSE);
           bInGrphFilter = TRUE;
           g_hbmWall = LoadWallpaper(pValue, lpszThemeFile, TRUE);
           bInGrphFilter = FALSE;
           EnableWindow(GetDlgItem(hWndApp, DDL_THEME), TRUE);
           SetFocus(hWndApp);
           SendMessage(hWndApp, DM_SETDEFID, IDOK, 0);
        }

   if (g_hbmWall) {
      SelectObject(g_hdcWall, g_hbmWall); // bitmap stays in this DC
      GetObject(g_hbmWall, sizeof(bm), &bm);
   }

   // get palette if appropriate
   if (GetDeviceCaps(g_hdcMem, RASTERCAPS) & RC_PALETTE) {
      DWORD adw[256+20+1];
      int n=0;

      if (g_hbmWall) {
        g_hpalWall = PaletteFromDS(g_hdcWall);

        // use the Halftone palette if the bitmap does not have one.
        if (g_hpalWall == NULL && bm.bmBitsPixel >= 8)
            g_hpalWall = CreateHalftonePalette(g_hdcMem);

        // now merge the 3D palette and the wallpaper palette.
        // we want the 3D (ie button shadow colors) to be first
        // and the wallpaper colors to be next.
        Assert(g_hpalWall, TEXT("null palette for bmp\n"));
        Assert(GetObject(hpal3D, sizeof(n), &n) && n==20, TEXT("hpal3D not valid or does not have 20 colors\n"));

        GetObject(g_hpalWall, sizeof(n), &n);
        GetPaletteEntries(hpal3D,     0, 20,  (LPPALETTEENTRY)&adw[1]);
        GetPaletteEntries(g_hpalWall, 0, n, (LPPALETTEENTRY)&adw[21]);
        adw[0] = MAKELONG(0x0300, n+20);

        DeleteObject(g_hpalWall); // we dont need this anymore
        g_hpalWall = CreatePalette((LPLOGPALETTE)adw);
        Assert(g_hpalWall, TEXT("CreatePalette failed\n"));
      }
      else {
        g_hpalWall = hpal3D;
      }
   }

   if (g_hpalWall)
   {
       //make sure to select into a windowDC first
       //so a WM_PALETTECHANGE happens.
       HDC hdc = GetDC(hWndApp);
       SelectPalette(hdc, g_hpalWall, FALSE);
       RealizePalette(hdc);
       ReleaseDC(hWndApp, hdc);
       SelectPalette(g_hdcMem, g_hpalWall, FALSE);
       RealizePalette(g_hdcMem);
   }

   // do the painting
   if (g_hbmWall)
   {
      GetObject(g_hbmWall, sizeof(bm), &bm);

//    dxWall = MulDiv(bm.bmWidth, dxPreview, GetDeviceCaps(g_hdcMem, HORZRES));
//    dyWall = MulDiv(bm.bmHeight, dyPreview, GetDeviceCaps(g_hdcMem, VERTRES));

      dxWall = bm.bmWidth;
      dyWall = bm.bmHeight;

      if (dxWall < 1) dxWall = 1;
      if (dyWall < 1) dyWall = 1;

      IntersectClipRect(g_hdcMem, 0, 0, dxPreview, dyPreview);
      SetStretchBltMode(g_hdcMem, COLORONCOLOR);

      if (tile)                     // TRUE for tile flag set
      {
         StretchBlt(g_hdcMem, 0, 0, dxWall, dyWall,
                    g_hdcWall, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY);

         for (i = dxWall; i < dxPreview; i+= dxWall)
               BitBlt(g_hdcMem, i, 0, dxWall, dyWall, g_hdcMem, 0, 0, SRCCOPY);

         for (i = 0; i < dyPreview; i += dyWall)
               BitBlt(g_hdcMem, 0, i, dxPreview, dyWall, g_hdcMem, 0, 0, SRCCOPY);
      }
      else if (style & 2)
      {
         StretchBlt(g_hdcMem, 0, 0, dxPreview, dyPreview,
                  g_hdcWall, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY);
      }
      else
      {
         StretchBlt(g_hdcMem, (dxPreview - dxWall)/2, (dyPreview - dyWall)/2,
                  dxWall, dyWall, g_hdcWall, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY);
      }

      #ifdef BMPOUT
      BmpOut(g_hbmPreview,dxPreview,dyPreview);
      PrevOut();
      #endif

      // restore dc
      SelectObject(g_hdcWall, g_hbmDefault);
      SelectPalette(g_hdcMem, GetStockObject(DEFAULT_PALETTE), TRUE);
      SelectClipRgn(g_hdcMem, NULL);
   }

   //
   // Now you can add the windows and icons on top of the background
   //

   // icons first
   IconsPreviewDraw(g_hdcMem, lpszThemeFile);

   // sample windows
// FakewinSetTheme(lpszThemeFile);
   FakewinDraw(g_hdcMem);

   //
   // final cleanup
   SelectObject(g_hdcMem, hbmOld);

   // force repaint of preview area
   InvalidateRect(hWndApp, (LPRECT)&rView, FALSE);

   #ifdef BMPOUT
   DeleteDC(hdcDeb);
   ReleaseDC(NULL, hdcOut);
   #endif
}



//
// GetThemeColor
//
// Utility routine that gets a color from the theme.
//

TCHAR szBkgdKey[] = TEXT("Background");
TCHAR szTextKey[] = TEXT("WindowText");

COLORREF GetThemeColor(LPTSTR lpszTheme, int iColorIndex)
{
   COLORREF crRet;
   UINT uret;

   switch (iColorIndex) {
   case COLOR_BACKGROUND:
      uret = (UINT) GetPrivateProfileString((LPTSTR)szColorApp, (LPTSTR)szBkgdKey,
                                            (LPTSTR)szNULL,
                                            (LPTSTR)pValue, MAX_VALUELEN,
                                            lpszTheme);
      Assert(uret, TEXT("problem getting stored theme bkgd color\n"));
      break;
   case COLOR_WINDOWTEXT:
      uret = (UINT) GetPrivateProfileString((LPTSTR)szColorApp, (LPTSTR)szTextKey,
                                            (LPTSTR)szNULL,
                                            (LPTSTR)pValue, MAX_VALUELEN,
                                            lpszTheme);
      Assert(uret, TEXT("problem getting stored theme wintext color\n"));
      break;
   default:
      Assert(0, TEXT("unexpected color request in GetThemeColor()\n"));
      break;
   }

   if (*pValue)
      crRet = RGBStringToColor((LPTSTR)pValue);
   else
      crRet = RGB(0,0,0);

   return (crRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\dither.c ===
/* DITHER.C

   Frosting: Master Theme Selector for Windows '95
   Copyright (c) 1994-1998 Microsoft Corporation.  All rights reserved.
*/


#include <windows.h>
#include <windowsx.h>

#ifdef DBG
    #define _DEBUG
#endif

#ifdef DEBUG
    #define _DEBUG
#endif

#ifdef _DEBUG
    #include <mmsystem.h>
    #define TIMESTART(sz) { TCHAR szTime[80]; DWORD time = timeGetTime();
    #define TIMESTOP(sz) time = timeGetTime() - time; wsprintf(szTime, TEXT("%s took %d.%03d sec\r\n"), sz, time/1000, time%1000); OutputDebugString(szTime); }
#else
    #define TIMESTART(sz) 
    #define TIMESTOP(sz) 
#endif

//-----------------------------------------------------------------------------
// helpers
//-----------------------------------------------------------------------------
__inline UINT Clamp8(int z)
{
    return (UINT)(((z) < 0) ? 0 : (((z) > 255) ? 255 : (z)));
}

__inline WORD rgb555(r, g, b)
{
    return (((WORD)(r) << 10) | ((WORD)(g) << 5) | (WORD)(b));
}

//-----------------------------------------------------------------------------
// Rounding stuff
//-----------------------------------------------------------------------------
//
// round an 8bit value to a 5bit value with good distribution
//
#pragma data_seg(".text", "CODE")
BYTE aRound8to5[] = {
      0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,
      2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,
      4,  4,  4,  4,  4,  4,  5,  5,  5,  5,  5,  5,  5,  5,  6,  6,
      6,  6,  6,  6,  6,  6,  7,  7,  7,  7,  7,  7,  7,  7,  8,  8,
      8,  8,  8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9,  9, 10,
     10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 12,
     12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13,
     14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
     16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19,
     19, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21,
     21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23,
     23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25,
     25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27,
     27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29,
     29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31,
};
#pragma data_seg()

//
// complement of table above
//
#pragma data_seg(".text", "CODE")
BYTE aRound5to8[] = {
      0,  8, 16, 25, 33, 41, 49, 58, 66, 74, 82, 90, 99,107,115,123,
    132,140,148,156,165,173,181,189,197,206,214,222,230,239,247,255,
};
#pragma data_seg()

//-----------------------------------------------------------------------------
// RoundPixel555
//-----------------------------------------------------------------------------
__inline WORD RoundPixel555(int r, int g, int b)
{
    return rgb555(aRound8to5[r], aRound8to5[g], aRound8to5[b]);
}

//-----------------------------------------------------------------------------
// Round24from555
//-----------------------------------------------------------------------------
__inline void Round24from555(RGBQUAD *out, WORD in)
{
    out->rgbBlue  = aRound5to8[      (in) & 0x1f];
    out->rgbGreen = aRound5to8[ (in >> 5) & 0x1f];
    out->rgbRed   = aRound5to8[(in >> 10) & 0x1f];
}


/******************************Public*Routine******************************\
* 16bpp dither stuff
*
* pimped from dibengine
*
\**************************************************************************/
//
// map a 8bit value (0-255) to a 5bit value (0-31) *evenly*
//
//  if (i < 8)    return 0;
//  if (i == 255) return 31;
//                return (i-8)/8;
//
#pragma data_seg(".text", "CODE")
BYTE aMap8to5[] = {
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2,
      3,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,  4,  4,  4,  4,
      5,  5,  5,  5,  5,  5,  5,  5,  6,  6,  6,  6,  6,  6,  6,  6,
      7,  7,  7,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,  8,  8,  8,
      9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
     11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12,
     13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14,
     15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
     17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18,
     19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20,
     21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
     23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24,
     25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
     27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28,
     29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 31,
};
#pragma data_seg()

//
// map a 5bit value back to a 8bit value
//
// if (i==0)  return 0;
// if (i==31) return 255;
//            return i*8+8;
//
#pragma data_seg(".text", "CODE")
BYTE aMap5to8[] = {
      0, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96,104,112,120,128,
    136,144,152,160,168,176,184,192,200,208,216,224,232,240,248,255,
};
#pragma data_seg()

//
// halftone table for 16bpp dithers
//
#pragma data_seg(".text", "CODE")
BYTE aHalftone16[4][4] = {
    0, 4, 1, 5,
    6, 2, 7, 3,
    1, 5, 0, 4,
    7, 3, 6, 2,
};
#pragma data_seg()

/******************************Public*Routine******************************\
* Dither555
*
\**************************************************************************/
__inline WORD
Dither555(BYTE r, BYTE re, BYTE g, BYTE ge, BYTE b, BYTE be, BYTE e)
{
    return rgb555(r + (re > e), g + (ge > e), b + (be > e));
}

/******************************Public*Routine******************************\
* DitherPixel555
*
* Takes RGB and x/y coords
*   and produces an appropriate 555 pixel.
*
\**************************************************************************/
__inline WORD DitherPixel555(int rs, int gs, int bs, int x, int y)
{
    BYTE r  = aMap8to5[rs];
    BYTE re = rs - aMap5to8[r];

    BYTE g  = aMap8to5[gs];
    BYTE ge = gs - aMap5to8[g];

    BYTE b  = aMap8to5[bs];
    BYTE be = bs - aMap5to8[b];

    return Dither555(r, re, g, ge, b, be, aHalftone16[x % 4][y % 4]);
}

///////////////////////////////////////////////////////////////////////////////

typedef struct {int r, g, b;} ERRBUF;

///////////////////////////////////////////////////////////////////////////////

void DitherScan(LPBYTE dst, LPBYTE src, RGBQUAD *colors, LPBYTE map,
    ERRBUF *cur_err, ERRBUF *nxt_err, int dx, int y, BOOL f8bpp, BOOL fOrder16)
{
    RGBQUAD rgbChosen, *pChosen = &rgbChosen;
    WORD wColor16;
    int er,eg,eb;
    int  r, g, b;
    int        x;

    for (x=0; x<dx; x++)
    {
        r = Clamp8((int)src[2] + cur_err[x].r / 16);
        g = Clamp8((int)src[1] + cur_err[x].g / 16);
        b = Clamp8((int)src[0] + cur_err[x].b / 16);

        wColor16 = (fOrder16? DitherPixel555(r,g,b,x,y) : RoundPixel555(r,g,b));

        if (f8bpp)
            pChosen = colors + (*dst++ = map[wColor16]);
        else
            Round24from555(pChosen, (*((WORD *)dst)++ = wColor16));

        er = r - (int)pChosen->rgbRed;
        eg = g - (int)pChosen->rgbGreen;
        eb = b - (int)pChosen->rgbBlue;

        cur_err[x+1].r += er * 7;
        cur_err[x+1].g += eg * 7;
        cur_err[x+1].b += eb * 7;

        nxt_err[x-1].r += er * 3;
        nxt_err[x-1].g += eg * 3;
        nxt_err[x-1].b += eb * 3;

        nxt_err[x+0].r += er * 5;
        nxt_err[x+0].g += eg * 5;
        nxt_err[x+0].b += eb * 5;

        nxt_err[x+1].r += er * 1;
        nxt_err[x+1].g += eg * 1;
        nxt_err[x+1].b += eb * 1;

        src+=3;
    }
}

///////////////////////////////////////////////////////////////////////////////

void DitherEngine(LPBYTE dst, LPBYTE src, RGBQUAD *colors, LPBYTE map,
    int dx, int dy, int dx_bytes, BOOL f8bpp, BOOL fOrder16)
{
    ERRBUF *buf;
    ERRBUF *err0;
    ERRBUF *err1;
    ERRBUF *cur_err;
    ERRBUF *nxt_err;
    int src_next_scan;
    int y, i;

    src_next_scan = (dx*3+3)&~3;

    buf = (ERRBUF *)LocalAlloc(LPTR, sizeof(ERRBUF) * (dx+2) * 2);
    if (buf)
    {
        err0 = cur_err = buf+1;
        err1 = nxt_err = buf+1 + dx + 2;

        /* read line by line, quantize, and transfer */
        for (y=0; y<dy; y++)
        {
            DitherScan(dst, src, colors, map, cur_err, nxt_err, dx, y,
                f8bpp, fOrder16);

            src += src_next_scan;
            dst += dx_bytes;

            cur_err = nxt_err;
            nxt_err = cur_err == err0 ? err1 : err0;

            for (i=-1; i<=dx; i++)
                nxt_err[i].r = nxt_err[i].g = nxt_err[i].b = 0;
        }
        LocalFree((HLOCAL)buf);
    }
}

///////////////////////////////////////////////////////////////////////////////

// note that this layout has scanlines DWORD aligned
#define INVMAP_IMAGE_PELS   (0x8000)
#define INVMAP_IMAGE_X      (0x0100)
#define INVMAP_IMAGE_Y      (INVMAP_IMAGE_PELS / INVMAP_IMAGE_X)

HBITMAP CreateInverseMapping(BYTE **ppMap, HDC hdcColors)
{
    BOOL fResult = FALSE;
    HBITMAP hbmDst, hbmOldColors;
    HDC hdcSrc;

    *ppMap = NULL;

    if ((hbmDst = CreateCompatibleBitmap(hdcColors,
        INVMAP_IMAGE_X, INVMAP_IMAGE_Y)) == NULL)
    {
        return NULL;
    }

    hbmOldColors = SelectBitmap(hdcColors, hbmDst);

    if ((hdcSrc = CreateCompatibleDC(NULL)) != NULL)
    {
        WORD *pSrc;
        BITMAPINFO bmiSrc = {sizeof(BITMAPINFOHEADER), INVMAP_IMAGE_X,
            INVMAP_IMAGE_Y, 1, 16, BI_RGB, 0, 0, 0, 0, 0};
        HBITMAP hbmSrc = CreateDIBSection(hdcColors, &bmiSrc, DIB_RGB_COLORS,
            &pSrc, NULL, 0);

        if (hbmSrc)
        {
            BITMAP bmDst;
            if (GetObject(hbmDst, sizeof(bmDst), &bmDst))
            {
                HBITMAP hbmOldSrc = SelectBitmap(hdcSrc, hbmSrc);
                UINT u = 0;

                while (u < INVMAP_IMAGE_PELS)
                    *pSrc++ = (WORD)u++;

                BitBlt(hdcColors, 0, 0, INVMAP_IMAGE_X, INVMAP_IMAGE_Y, hdcSrc,
                    0, 0, SRCCOPY);

                *ppMap = (BYTE *)bmDst.bmBits;

                SelectBitmap(hdcSrc, hbmOldSrc);
            }

            DeleteBitmap(hbmSrc);
        }

        DeleteDC(hdcSrc);
    }

    SelectBitmap(hdcColors, hbmOldColors);

    if (*ppMap)
        return hbmDst;

    DeleteBitmap(hbmDst);
    return NULL;
}

///////////////////////////////////////////////////////////////////////////////

BOOL DitherImage(HDC hdcDst, HBITMAP hbmDst, LPBITMAPINFOHEADER lpbiSrc,
    LPBYTE lpbSrc, BOOL fOrder16)
{
    BOOL fResult = FALSE;
    BITMAP bmDst;

    if (lpbiSrc->biBitCount != 24)
        return FALSE;

    if (GetObject(hbmDst, sizeof(bmDst), &bmDst))
    {
        if ((lpbiSrc->biWidth == bmDst.bmWidth) &&
            (lpbiSrc->biHeight == bmDst.bmHeight) &&
            ((bmDst.bmBitsPixel == 16) || (bmDst.bmBitsPixel == 8)))
        {
            RGBQUAD rgbColors[256];
            HBITMAP hbmMap = NULL;
            BYTE *pMap;
            BOOL f8bpp = (bmDst.bmBitsPixel == 8);

            if (f8bpp)
            {
                TIMESTART(TEXT("CreateInverseMap"));
                if ((hbmMap = CreateInverseMapping(&pMap, hdcDst)) == NULL)
                    goto error;

                GetDIBColorTable(hdcDst, 0, 256, rgbColors);
                TIMESTOP(TEXT("CreateInverseMap"));
            }

            DitherEngine((LPBYTE)bmDst.bmBits, lpbSrc, rgbColors, pMap,
                bmDst.bmWidth, bmDst.bmHeight, bmDst.bmWidthBytes,
                f8bpp, fOrder16);

            if (hbmMap)
                DeleteBitmap(hbmMap);

            fResult = TRUE;

        error:
            ;   // make the compiler happy it wants a statement here
        }
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\bkgd.h ===
// bkgd.h
//
// include file for BKGD.C and BKGDUTIL.C
//
// Frosting: Master Theme Selector for Windows '95
// Copyright (c) 1994-1999 Microsoft Corporation.  All rights reserved.

// globals

int dxPreview, dyPreview;

#define CXYDESKPATTERN 8

extern HBITMAP g_hbmPreview;	         // the bitmap used for previewing
extern HDC     g_hdcMem;               // memory dc mostly used for preview bmp

extern HBITMAP  g_hbmWall;             // bitmap image of wallpaper
extern HDC      g_hdcWall;             // memory DC with g_hbmWall selected
extern HPALETTE g_hpalWall;            // palette that goes with hbmWall bitmap
extern HBRUSH   g_hbrBack;             // brush for the desktop background

extern HBITMAP g_hbmDefault;           

// BKGDUTIL.C
HPALETTE FAR PaletteFromDS(HDC hdc);
void FAR PASCAL TranslatePattern(LPTSTR lpStr, WORD FAR *patbits);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\cb.c ===
/* CB.C
   Resident Code Segment      // Tweak: make non-resident

   Utility routines for checkboxes.

   Frosting: Master Theme Selector for Windows '95
   Copyright (c) 1994-1998 Microsoft Corporation
*/

// ---------------------------------------------
// Brief file history:
// Alpha:
// Beta:
// Bug fixes
// ---------
//
// ---------------------------------------------

#include "windows.h"
#include "frost.h"
#include "global.h"

//
// InitCheckboxes
// Actually, you are init'ing the stored state of the checkboxes.
// All from saved registry values initially; or just checked if no stored 
// values. This gets picked up on the first call to EnableThemeButtons().
//
void FAR InitCheckboxes()
{
   extern TCHAR szPlus_CBs[];
   LONG lret;
   HKEY hKey;
   int iter;
   TCHAR szState[5];
   DWORD dwSize;
   DWORD dwType;
   
   // we're going to try to read from the registry
   lret = RegOpenKeyEx( HKEY_CURRENT_USER, szPlus_CBs, 
                        (DWORD)0, KEY_QUERY_VALUE, (PHKEY)&hKey );

   // check that you got a good key here
   if (lret == ERROR_SUCCESS) {

      // go through each checkbox and read stored state from registry
      for (iter = 0; iter < MAX_FCHECKS; iter ++) {

         // first do paranoid check of data size
         lret = RegQueryValueEx(hKey, (LPTSTR)szCBNames[iter], (LPDWORD)NULL,
                                (LPDWORD)&dwType, (LPBYTE)NULL, (LPDWORD)&dwSize);
         if (ERROR_SUCCESS == lret) {
            // here's the size check before getting the data
            if (dwSize > ((DWORD)5 * sizeof(TCHAR))) {
               Assert(FALSE, TEXT("Large entry for checkbox state!\n"));
               lret = ERROR_SUCCESS - 5;  // set error flag for check below
            }

            else
               //
               // now really get the value
               lret = RegQueryValueEx(hKey, (LPTSTR)szCBNames[iter], (LPDWORD)NULL,
                                      (LPDWORD)&dwType, (LPBYTE)szState, (LPDWORD)&dwSize);
         }

         //
         // if you got something, go ahead and use it to set checkbox state!
         //
         if (ERROR_SUCCESS == lret) {
            // invalid value defaults to TRUE/checked, so check for valid FALSE/unchecked
            bCBStates[iter] = (szState[0] == TEXT('0') ? FALSE : TRUE);
         }

         // otherwise, use ultimate error case
         else {
            Assert(FALSE, TEXT("couldn't read one of the checkbox states\n"));
            // always easy worst case default: just init to checked
            // Except for CB_SCHEDULE -- if it can't be read we want
            // to default to off.
            if (FC_SCHEDULE == iter) bCBStates[iter] = FALSE;
            else bCBStates[iter] = TRUE;
         }
      }

      // cleanup
      RegCloseKey(hKey);
   }

   else {   // couldn't open key, so just set to checked
      Assert(FALSE, TEXT("problem opening Checkbox registry to init checkboxes\n"));
      for (iter = 0; iter < MAX_FCHECKS; iter ++) {
         if (FC_SCHEDULE == iter) bCBStates[iter] = FALSE;
         else bCBStates[iter] = TRUE;
      }
   }
}

//
// Save/RestoreCheckboxes
// Save/Restore the state of the checkboxes to/from the states array.
// The checkbox ID array defines order saved in the states array.
//
// Globals: sets values in global bCBStates[] array.
//
void FAR SaveCheckboxes()
{
   int iter;

   for (iter = 0; iter < MAX_FCHECKS; iter ++) {
      bCBStates[iter] = IsDlgButtonChecked(hWndApp, iCBIDs[iter]);
   }
}

//
// Assumes caller has already enabled all the buttons so they can be checked.
void FAR RestoreCheckboxes()
{
   int iter;

   for (iter = 0; iter < MAX_FCHECKS; iter ++) {
      CheckDlgButton(hWndApp, iCBIDs[iter], bCBStates[iter]);
   }
}

// IsAnyBoxChecked()
//
// Returns TRUE if any of the theme setting checkboxes are checked.
// We ignore the SCHEDULE checkbox setting.

BOOL FAR IsAnyBoxChecked()
{
   BOOL bRet = FALSE;
   int iter;

   for (iter = 0;
        (iter < MAX_FCHECKS) && !bRet;
        iter ++) {
      if (FC_SCHEDULE != iter)
      {
        bRet = bRet | IsDlgButtonChecked(hWndApp, iCBIDs[iter]);
      }
   }

   return (bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\adutil.h ===
/*  ADUTIL.H
**
**  Copyright (C) Microsoft Corp. 1998, All Rights Reserved.
**
**  Prototypes for functions provided by ADUTIL.CPP.
**  
**  Created by: David Schott, January 1998
*/

// ActiveDesktop functions provided by ADUTIL.CPP
BOOL IsActiveDesktopOn();
BOOL GetADWallpaper(LPTSTR);
BOOL SetADWallpaper(LPTSTR, BOOL);
BOOL GetADWPOptions(DWORD *);
BOOL GetADWPPattern(LPTSTR);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\bkgdutil.c ===
/* BKGDUTIL.C

   Buncha extra routines from CPL code.

   Frosting: Master Theme Selector for Windows '95
   Copyright (c) 1994-1998 Microsoft Corporation
*/


#include "windows.h"
#include "frost.h"
#include "bkgd.h"
#include "loadimag.h"
#include <shlobj.h>

extern HWND hWndApp;  // Handle to Desktop Themes window
/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/
HPALETTE FAR PaletteFromDS(HDC hdc)
{
    DWORD adw[257];
    int i,n;

    n = GetDIBColorTable(hdc, 0, 256, (LPRGBQUAD)&adw[1]);
    adw[0] = MAKELONG(0x300, n);

    for (i=1; i<=n; i++)
        adw[i] = RGB(GetBValue(adw[i]),GetGValue(adw[i]),GetRValue(adw[i]));

    if (n == 0)
        return NULL;
    else
        return CreatePalette((LPLOGPALETTE)&adw[0]);
}


/*-------------------------------------------------------------
** given a pattern string from an ini file, return the pattern
** in a binary (ie useful) form.
**-------------------------------------------------------------*/
void FAR PASCAL TranslatePattern(LPTSTR lpStr, WORD FAR *patbits)
{
  short i, val;

   /* Get eight groups of numbers seprated by non-numeric characters. */
   for (i = 0; i < CXYDESKPATTERN; i++)
   {
      val = 0;
      if (*lpStr != 0)
      {
         /* Skip over any non-numeric characters. */                       // and watch for EOS
         while (*lpStr && !(*lpStr >= TEXT('0') && *lpStr <= TEXT('9')))   // JDK fixed CPL code bug
                 lpStr++;

         /* Get the next series of digits. */
         while (*lpStr >= TEXT('0') && *lpStr <= TEXT('9'))
                 val = val*10 + *lpStr++ - TEXT('0');
      }
      patbits[i] = val;
   }
  return;
}


BOOL FAR PASCAL PreviewInit(void)
{
   HDC hdc;
   HBITMAP hbm;
   HBRUSH hbr;

   // numbers
   dxPreview = rView.right-rView.left;
   dyPreview = rView.bottom-rView.top;

   // use hDlg DC as reference
   hdc = GetDC(hWndApp);
   // DCs
   g_hdcWall = CreateCompatibleDC(hdc);
   g_hdcMem = CreateCompatibleDC(hdc);
   // bitmap
   g_hbmPreview = CreateCompatibleBitmap(hdc, dxPreview, dyPreview);
   ReleaseDC(NULL, hdc);
   // check up on new toys
   if (!g_hdcWall || !g_hdcMem || !g_hbmPreview)
           return FALSE;

   // default bitmap
   hbm = CreateBitmap(1, 1, 1, 1, NULL);
   g_hbmDefault = SelectObject(g_hdcWall, hbm);     // cpl code never deletes this
   SelectObject(g_hdcWall, g_hbmDefault);
   DeleteObject(hbm);

   // init the bitmap with something
   hbm = SelectObject(g_hdcWall, g_hbmPreview);
   hbr = SelectObject(g_hdcWall, GetSysColorBrush(COLOR_DESKTOP));
   PatBlt(g_hdcWall, 0, 0, dxPreview, dyPreview, PATCOPY);
   SelectObject(g_hdcWall, hbm);
   SelectObject(g_hdcWall, hbr);

   // catch fake sample window and icons init, too
        return (FakewinInit() && IconsPreviewInit());
}

void FAR PASCAL PreviewDestroy(void)
{
   if (g_hbmPreview)
   {
      DeleteObject(g_hbmPreview);
      g_hbmPreview = NULL;
   }

   if (g_hbmWall)
   {
      SelectObject(g_hdcWall, g_hbmDefault);
      CacheDeleteBitmap(g_hbmWall);
      g_hbmWall = NULL;
   }

   if (g_hpalWall)
   {
      extern HPALETTE hpal3D; // fakewin.c
      SelectPalette(g_hdcWall, GetStockObject(DEFAULT_PALETTE), TRUE);
      if (g_hpalWall != hpal3D)
         DeleteObject(g_hpalWall);
      g_hpalWall = NULL;
   }

   if (g_hdcWall)
   {
      DeleteDC(g_hdcWall);
      g_hdcWall = NULL;
   }

   if (g_hbrBack)
   {
      DeleteObject(g_hbrBack);
      g_hbrBack = NULL;
   }

   // catch fake sample window and icons destroy, too
   FakewinDestroy();
   IconsPreviewDestroy();
   CacheLoadImageFromFile(NULL, 0, 0, 0, 0);
}


//
//  ExtractPlusColorIcon
//
//  Extract Icon from a file in proper Hi or Lo color for current system display
//
// from FrancisH on 6/22/95 with mods by TimBragg
HRESULT ExtractPlusColorIcon(LPCTSTR szPath, int nIndex, HICON *phIcon,
    UINT uSizeLarge, UINT uSizeSmall)
{
    IShellLink *psl;
    HRESULT hres;
    HICON hIcons[2];    // MUST! - provide for TWO return icons

    if ( !gfCoInitDone )
        {
        if (SUCCEEDED(CoInitialize(NULL)))
                gfCoInitDone = TRUE;
        }
        
    *phIcon = NULL;
    if (SUCCEEDED(hres = CoCreateInstance(&CLSID_ShellLink, NULL,
        CLSCTX_INPROC_SERVER, &IID_IShellLink, &psl)))
    {
        if (SUCCEEDED(hres = psl->lpVtbl->SetIconLocation(psl, szPath, nIndex)))
        {
            IExtractIcon *pei;
            if (SUCCEEDED(hres = psl->lpVtbl->QueryInterface(psl,
                &IID_IExtractIcon, &pei)))
            {
                if (SUCCEEDED(hres = pei->lpVtbl->Extract(pei, szPath, nIndex,
                    &hIcons[0], &hIcons[1], (UINT)MAKEWPARAM((WORD)uSizeLarge,
                    (WORD)uSizeSmall))))
                                {
                        *phIcon = hIcons[0];    // Return first icon to caller
                                }

                pei->lpVtbl->Release(pei);
            }
        }

        psl->lpVtbl->Release(psl);
    }
        
    return hres;
}       // end ExtractPlusColorIcon()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\adutil.cpp ===
/*  ADUTIL.CPP
**
**  Copyright (C) Microsoft Corp. 1998-1999, All Rights Reserved.
**
**  Utility functions for interfacing with the IActiveDesktop
**  services.  These services are documented in the Internet SDK.
**
**  Created by: David Schott, January 1998
*/

#include <windows.h>
#include <mbctype.h>
#include <objbase.h>
#include <initguid.h>
#include "..\inc\wininet.h"
#include "..\inc\shlguid.h"
#include "..\inc\shlobj.h"

#define MAX_VALUELEN 1024  // Also defined in FROST.H!!

// Extern globals
extern "C" HWND hWndApp;  // Handle to Desktop Themes window

// Globals
IActiveDesktop *g_pIAD = NULL;    // IActiveDesktop interface

BOOL InitIAD()
{
    HRESULT hr = E_FAIL;

    // Bring in the library

    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        //MessageBox(hWndApp, TEXT("CoInit failed"), TEXT("ADUTIL"), MB_OK | MB_APPLMODAL);
        return FALSE;
    }

    g_pIAD = NULL;

    hr = CoCreateInstance(CLSID_ActiveDesktop, NULL,
                CLSCTX_INPROC_SERVER, IID_IActiveDesktop, (void **)&g_pIAD);

    if(!FAILED(hr))
    {
        //MessageBox(hWndApp, TEXT("CoCreateInsance successful"), TEXT("ADUTIL"), MB_OK | MB_APPLMODAL);
        return TRUE;
    }
    else
    {
        //MessageBox(hWndApp, TEXT("CoCreateInstance failed"), TEXT("ADUTIL"), MB_OK | MB_APPLMODAL);
        CoUninitialize();
        return FALSE;
    }
}

void IADCleanUp()
{
    if (g_pIAD) g_pIAD->Release();
    g_pIAD = NULL;
    CoUninitialize();
    return;
}

extern "C" BOOL IsActiveDesktopOn()
{
    HRESULT hr = E_FAIL;
    COMPONENTSOPT ADOptions;
    SHELLFLAGSTATE sfs;
    HINSTANCE hInst = 0;
    typedef VOID (*MYPROC)(LPSHELLFLAGSTATE, DWORD);
    MYPROC SHGetSettings;

    // Rumor has it this will help guarantee that our AD interface
    // is in sync.
    // SHGetSettings(&sfs, 0);
    
    hInst = LoadLibrary(TEXT("SHELL32.DLL"));
    if (hInst)
    {
       SHGetSettings = (MYPROC)GetProcAddress(hInst, "SHGetSettings");
       if (SHGetSettings)
       {
          //MessageBox(NULL, TEXT("Calling SHGetSettings"), TEXT("ADUTIL"), MB_OK | MB_APPLMODAL);
          SHGetSettings(&sfs, 0);
       }
       FreeLibrary(hInst);
    }

    if (!InitIAD()) {
       //MessageBox(hWndApp, TEXT("INITIAD Failed"), TEXT("ADUTIL"), MB_OK | MB_APPLMODAL);
       return FALSE;
    }

    ZeroMemory(&ADOptions, sizeof(ADOptions));
    ADOptions.dwSize = sizeof(ADOptions);

    // Paranoid check
    if (!g_pIAD) {
       IADCleanUp();
       return FALSE;
    }

    hr = g_pIAD->GetDesktopItemOptions(&ADOptions, 0);

    if (FAILED(hr)) {
       IADCleanUp();
       return FALSE;
    }
    else {
       //if (ADOptions.fActiveDesktop)
       //   MessageBox(hWndApp, TEXT("ActiveDesktop enabled."), TEXT("ADUTIL"), MB_OK | MB_APPLMODAL);
       //else MessageBox(hWndApp, TEXT("ActiveDesktop disabled."), TEXT("ADUTIL"), MB_OK | MB_APPLMODAL);

       if (ADOptions.fActiveDesktop) {
          IADCleanUp();
          return TRUE;
       }
       else {
          IADCleanUp();
          return FALSE;
       }
    }

    // SHOULD NEVER FALL THROUGH TO THIS BUT JUST IN CASE

    IADCleanUp();
    return FALSE;
}

extern "C" BOOL SetADWallpaper(LPTSTR lpszWallpaper, BOOL bForceADOn)
{

    HRESULT hr = E_FAIL;
    COMPONENTSOPT ADOptions;
    SHELLFLAGSTATE sfs;
    HINSTANCE hInst = 0;
    typedef VOID (*MYPROC)(LPSHELLFLAGSTATE, DWORD);
    MYPROC SHGetSettings;

#ifndef UNICODE
    WCHAR wszWallpaper[MAX_PATH];
#endif
    UINT uCodePage;

    // Rumor has it this will help guarantee that our AD interface
    // is in sync.
    // SHGetSettings(&sfs, 0);

    hInst = LoadLibrary(TEXT("SHELL32.DLL"));
    if (hInst)
    {
       SHGetSettings = (MYPROC)GetProcAddress(hInst, "SHGetSettings");
       if (SHGetSettings)
       {
          //MessageBox(NULL, TEXT("Calling SHGetSettings"), TEXT("ADUTIL"), MB_OK | MB_APPLMODAL);
          SHGetSettings(&sfs, 0);
       }
       FreeLibrary(hInst);
    }

    if (!InitIAD()) {
       return FALSE;
    }

    // Paranoid check
    if (!g_pIAD) {
       IADCleanUp();
       return FALSE;
    }

    uCodePage = _getmbcp();

#ifndef UNICODE
    //MessageBox(hWndApp, lpszWallpaper, TEXT("SetADWallpaper"), MB_OK | MB_APPLMODAL);

    MultiByteToWideChar(uCodePage, 0, lpszWallpaper, -1,
                                             wszWallpaper, MAX_PATH);
#endif


#ifdef UNICODE
    //MessageBox(hWndApp, lpszWallpaper, TEXT("SetADWallpaper"), MB_OK | MB_APPLMODAL);
    hr = g_pIAD->SetWallpaper(lpszWallpaper, 0);
#else
    hr = g_pIAD->SetWallpaper(wszWallpaper, 0);
#endif

    if (FAILED(hr)) {
       IADCleanUp();
       return FALSE;
    }


    if (bForceADOn) {
       ZeroMemory(&ADOptions, sizeof(ADOptions));
       ADOptions.dwSize = sizeof(ADOptions);
       hr = g_pIAD->GetDesktopItemOptions(&ADOptions, 0);

       if (FAILED(hr)) {
          IADCleanUp();
          return FALSE;
       }

       //if (ADOptions.fActiveDesktop)
       //   MessageBox(hWndApp, TEXT("ActiveDesktop enabled."), TEXT("ADUTIL"), MB_OK | MB_APPLMODAL);
       //else MessageBox(hWndApp, TEXT("ActiveDesktop disabled."), TEXT("ADUTIL"), MB_OK | MB_APPLMODAL);

       if (!ADOptions.fActiveDesktop) {
          // Turn AD on
          ADOptions.dwSize = sizeof(ADOptions);
          ADOptions.fActiveDesktop = TRUE;
          g_pIAD->SetDesktopItemOptions(&ADOptions, 0);
       }
    }

    g_pIAD->ApplyChanges(AD_APPLY_ALL | AD_APPLY_FORCE);
    IADCleanUp();
    return TRUE;
}

extern "C" BOOL GetADWallpaper(LPTSTR lpszWallpaper)
{
    HRESULT hr = E_FAIL;
#ifndef UNICODE
    WCHAR wszWallpaper[MAX_PATH];
#endif
    UINT uCodePage;
    
    if (!InitIAD()) {
       // MessageBox(hWndApp, TEXT("INITIAD Failed"), TEXT("ADUTIL"), MB_OK | MB_APPLMODAL);
       return FALSE;
    }

    // Paranoid check
    if (!g_pIAD) {
       IADCleanUp();
       return FALSE;
    }

    uCodePage = _getmbcp();

#ifdef UNICODE
    hr = g_pIAD->GetWallpaper(lpszWallpaper, MAX_PATH, 0);
#else 
    hr = g_pIAD->GetWallpaper(wszWallpaper, MAX_PATH, 0);
#endif

    if (FAILED(hr)) {
       IADCleanUp();
       return FALSE;
    }
    else {
#ifndef UNICODE
       WideCharToMultiByte(uCodePage, 0, wszWallpaper, -1, lpszWallpaper,
                                                 MAX_PATH, NULL, NULL);
#endif

       //MessageBox(hWndApp, lpszWallpaper, TEXT("GetWallpaper"), MB_OK | MB_APPLMODAL);

       IADCleanUp();
       return TRUE;
    }
}

extern "C" BOOL GetADWPOptions (DWORD *dwStyle)
{
    WALLPAPEROPT WPOptions;
    HRESULT hr = E_FAIL;

    if (!InitIAD()) {
       // MessageBox(hWndApp, TEXT("INITIAD Failed"), TEXT("ADUTIL"), MB_OK | MB_APPLMODAL);
       return FALSE;
    }

    // Paranoid check
    if (!g_pIAD) {
       IADCleanUp();
       return FALSE;
    }

    ZeroMemory(&WPOptions, sizeof(WALLPAPEROPT));
    WPOptions.dwSize = sizeof(WALLPAPEROPT);

    hr = g_pIAD->GetWallpaperOptions(&WPOptions, 0);

    if (FAILED(hr)) {
       IADCleanUp();
       return FALSE;
    }
    else {
       *dwStyle = WPOptions.dwStyle;
       IADCleanUp();
       return TRUE;
    }
}

extern "C" BOOL SetADWPOptions (DWORD dwStyle)
{
    WALLPAPEROPT WPOptions;
    HRESULT hr = E_FAIL;

    if (!InitIAD()) {
       // MessageBox(hWndApp, TEXT("INITIAD Failed"), TEXT("ADUTIL"), MB_OK | MB_APPLMODAL);
       return FALSE;
    }

    // Paranoid check
    if (!g_pIAD) {
       IADCleanUp();
       return FALSE;
    }

    ZeroMemory(&WPOptions, sizeof(WALLPAPEROPT));
    WPOptions.dwSize = sizeof(WALLPAPEROPT);
    WPOptions.dwStyle = dwStyle;

    hr = g_pIAD->SetWallpaperOptions(&WPOptions, 0);

    if (FAILED(hr)) {
       IADCleanUp();
       return FALSE;
    }
    else {
       g_pIAD->ApplyChanges(AD_APPLY_ALL);
       IADCleanUp();
       return TRUE;
    }
}

extern "C" BOOL GetADWPPattern (LPTSTR lpszPattern)
{
    HRESULT hr = E_FAIL;
#ifndef UNICODE
    WCHAR wszPat[MAX_VALUELEN]; // Assume this is big enough?
#endif
    UINT uCodePage;


    if (!InitIAD()) {
       return FALSE;
    }

    // Paranoid check
    if (!g_pIAD) {
       IADCleanUp();
       return FALSE;
    }

    uCodePage = _getmbcp();

#ifdef UNICODE
    hr = g_pIAD->GetPattern(lpszPattern, MAX_VALUELEN, 0);
#else
    hr = g_pIAD->GetPattern(wszPat, MAX_VALUELEN, 0);
#endif

    if (FAILED(hr)) {
       IADCleanUp();
       return FALSE;
    }
    else {
#ifndef UNICODE
       WideCharToMultiByte(uCodePage, 0, wszPat, -1, lpszPattern,
                                                 MAX_VALUELEN, NULL, NULL);
#endif
       IADCleanUp();
       return TRUE;
    }
}

extern "C" BOOL SetADWPPattern (LPTSTR lpszPattern)
{
    HRESULT hr = E_FAIL;
#ifndef UNICODE
    WCHAR wszPat[MAX_VALUELEN];  // Assume this is big enough?
#endif
    UINT uCodePage;

    if (!InitIAD()) {
       return FALSE;
    }

    // Paranoid check
    if (!g_pIAD) {
       IADCleanUp();
       return FALSE;
    }

    uCodePage = _getmbcp();

#ifndef UNICODE
    MultiByteToWideChar(uCodePage, 0, lpszPattern, -1,
                                             wszPat, MAX_VALUELEN);
#endif

#ifdef UNICODE
    hr = g_pIAD->SetPattern(lpszPattern, 0);
#else
    hr = g_pIAD->SetPattern(wszPat, 0);
#endif


    if (FAILED(hr)) {
       IADCleanUp();
       return FALSE;
    }
    else {
       g_pIAD->ApplyChanges(AD_APPLY_ALL);
       IADCleanUp();
       return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\dither.h ===
/* DITHER.H

   Frosting: Master Theme Selector for Windows '95
   Copyright (c) 1994-1999 Microsoft Corporation.  All rights reserved.
*/

BOOL DitherImage(
    HDC hdcDst,
    HBITMAP hbmDst,
    LPBITMAPINFOHEADER lpbiSrc,
    LPBYTE lpSrcBits,
    BOOL fOrder16       // do ordered dither 24->16?
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\fakewin.h ===
// fakewin.h
//
// include file for FAKEWIN.C
//
// Frosting: Master Theme Selector for Windows '95
// Copyright (c) 1994-1998 Microsoft Corporation.  All rights reserved.

//
// external routines
extern int FAR WriteBytesToBuffer(LPTSTR);

//
// typedefs and defines

// fonts
#define FONT_NONE         -1
#define FONT_CAPTION	   0
#define FONT_MENU          1
#define FONT_ICONTITLE     2
#define FONT_STATUS	   3
#define FONT_MSGBOX	   4
//#define FONT_SMCAPTION     1
#define NUM_FONTS          5

typedef struct {
    HFONT hfont;
    LOGFONT lf;
} LOOK_FONT;

typedef struct {
    int iFont;
    RECT rc;
} LOOK_ELEMENT;


// JDK:
// Actually, this only seems to be used to get the count of elements
// directly following this defn.  Otherwise unused in CPL code.
//

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//this order has to match the array order in lookdlg.c // g_elements below
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
enum _ELEMENTS {
    ELEMENT_APPSPACE = 0,

//     ELEMENT_DESKTOP,

    ELEMENT_INACTIVEBORDER,
    ELEMENT_ACTIVEBORDER,
    ELEMENT_INACTIVECAPTION,
    ELEMENT_INACTIVESYSBUT1,
    ELEMENT_INACTIVESYSBUT2,
    ELEMENT_ACTIVECAPTION,
    ELEMENT_ACTIVESYSBUT1,
    ELEMENT_ACTIVESYSBUT2,
    ELEMENT_MENUNORMAL,
    ELEMENT_MENUSELECTED,
    ELEMENT_MENUDISABLED,
    ELEMENT_WINDOW,
    ELEMENT_MSGBOX,
    ELEMENT_MSGBOXCAPTION,
    ELEMENT_MSGBOXSYSBUT,
    ELEMENT_SCROLLBAR,
    ELEMENT_SCROLLUP,
    ELEMENT_SCROLLDOWN,
    ELEMENT_BUTTON,

//    ELEMENT_SMCAPTION,

    ELEMENT_ICON,
    ELEMENT_ICONHORZSPACING,
    ELEMENT_ICONVERTSPACING,
    ELEMENT_INFO
};
// BOGUS:  need to get a size from somewhere
#define NUM_ELEMENTS (ELEMENT_INFO+1)

// KEEP IN SYNC WITH pRegColors in REGUTILS.C!!
// BOGUS twice: need to get a size from somewhere
#define MAX_COLORS   (COLOR_GRADIENTINACTIVECAPTION+1)

//
// globals
// jdk: see note above enum above
// NOTE: the order in g_elements must match the enum order above
HPALETTE hpal3D = NULL;		// only exist if palette device
BOOL bPalette = FALSE;		// is this a palette device?
int cyFixedBorder;
int cxFixedBorder;
int cxFixedEdge;
int cyFixedEdge;
int cxSize;                // ***DEBUG*** this shouldn't really be fixed, should it?

LOOK_FONT g_fonts[NUM_FONTS];

COLORREF g_rgb[MAX_COLORS];
HBRUSH g_brushes[MAX_COLORS];

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//this order has to match the enum order above
// jdk: see also not above
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
LOOK_ELEMENT g_elements[] = {
/* ELEMENT_APPSPACE        */	{FONT_NONE, {-1,-1,-1,-1}},

//  /* ELEMENT_DESKTOP         */	{FONT_NONE, {-1,-1,-1,-1}},

/* ELEMENT_INACTIVEBORDER  */	{FONT_NONE, {-1,-1,-1,-1}},
/* ELEMENT_ACTIVEBORDER    */	{FONT_NONE, {-1,-1,-1,-1}},
/* ELEMENT_INACTIVECAPTION */	{FONT_CAPTION, {-1,-1,-1,-1}},
/* ELEMENT_INACTIVESYSBUT1 */	{FONT_NONE, {-1,-1,-1,-1}},
/* ELEMENT_INACTIVESYSBUT2 */	{FONT_NONE, {-1,-1,-1,-1}},
/* ELEMENT_ACTIVECAPTION   */	{FONT_CAPTION, {-1,-1,-1,-1}},
/* ELEMENT_ACTIVESYSBUT1   */	{FONT_NONE, {-1,-1,-1,-1}},
/* ELEMENT_ACTIVESYSBUT2   */	{FONT_NONE, {-1,-1,-1,-1}},
/* ELEMENT_MENUNORMAL      */	{FONT_MENU, {-1,-1,-1,-1}},
/* ELEMENT_MENUSELECTED    */	{FONT_MENU, {-1,-1,-1,-1}},
/* ELEMENT_MENUDISABLED    */	{FONT_MENU, {-1,-1,-1,-1}},
/* ELEMENT_WINDOW          */	{FONT_NONE, {-1,-1,-1,-1}},
/* ELEMENT_MSGBOX          */	{FONT_MSGBOX, {-1,-1,-1,-1}},
/* ELEMENT_MSGBOXCAPTION   */	{FONT_CAPTION, {-1,-1,-1,-1}},
/* ELEMENT_MSGBOXSYSBUT    */	{FONT_CAPTION, {-1,-1,-1,-1}},
// do not even try to set a scr
/* ELEMENT_SCROLLBAR       */	{FONT_NONE, {-1,-1,-1,-1}},
/* ELEMENT_SCROLLUP        */	{FONT_NONE, {-1,-1,-1,-1}},
/* ELEMENT_SCROLLDOWN      */	{FONT_NONE, {-1,-1,-1,-1}},
/* ELEMENT_BUTTON          */	{FONT_NONE, {-1,-1,-1,-1}},
// /* ELEMENT_SMCAPTION       */	{FONT_SMCAPTION, {-1,-1,-1,-1}},
/* ELEMENT_ICON            */	{FONT_ICONTITLE, {-1,-1,-1,-1}},
/* ELEMENT_ICONHORZSPACING */	{FONT_NONE, {-1,-1,-1,-1}},
/* ELEMENT_ICONVERTSPACING */	{FONT_NONE, {-1,-1,-1,-1}},
/* ELEMENT_INFO            */ {FONT_STATUS, {-1,-1,-1,-1}},
};

#define RCZ(element)         g_elements[element].rc

TCHAR szFakeActive[40];
TCHAR szFakeInactive[40];
TCHAR szFakeMinimized[40];
TCHAR szFakeIconTitle[40];
TCHAR szFakeNormal[40];
TCHAR szFakeDisabled[40];
TCHAR szFakeSelected[40];
TCHAR szFakeMsgBox[40];
TCHAR szFakeButton[40];
//TCHAR szFakeSmallCaption[40];
TCHAR szFakeWindowText[40];
TCHAR szFakeMsgBoxText[40];
TCHAR szFakeABC[] = TEXT("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");

HMENU hmenuFake;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\fakewin.c ===
/* FAKEWIN.C
   Resident Code Segment      // Tweak: make non-resident?

   Most of this code is taken from the display CPLs adjusted to
   work with the Theme Switcher and cleaned up a little.

   Routines for painting the preview box in the main window
      Window samples
      Icons
      (Desktop background is in BKGD.C)

   Frosting: Master Theme Selector for Windows '95
   Copyright (c) 1994-1999 Microsoft Corporation.  All rights reserved.
*/

// ---------------------------------------------
// Brief file history:
// Alpha:
// Beta:
// Bug fixes
// ---------

#include "windows.h"
#include "frost.h"
#include "global.h"

#include "bkgd.h"
#include "fakewin.h"
#include "nc.h"

//
// local routines
void NEAR FakewinRecalc(void);
void NEAR PASCAL Set3DPaletteColor(COLORREF rgb, int iColor);
COLORREF NearestColor(int iColor, COLORREF rgb);
void GetThemeColors(LPTSTR);
void GetThemeFonts(LPTSTR);
BOOL IsPaletteColor(HPALETTE, COLORREF);
COLORREF GetNearestPaletteColor(HPALETTE, COLORREF);

// as per DavidBa 3/95 and MartinHa 4/95
WINUSERAPI HANDLE WINAPI SetSysColorsTemp(COLORREF FAR *, HBRUSH FAR *, UINT_PTR); // internal
WINUSERAPI int WINAPI DrawMenuBarTemp(HWND, HDC, LPRECT, HMENU, HFONT);
#ifdef UNICODE
#define DrawCaptionTemp DrawCaptionTempW
#else
#define DrawCaptionTemp DrawCaptionTempA
#endif // !UNICODE
WINUSERAPI BOOL WINAPI DrawCaptionTemp(HWND, HDC, LPRECT, HFONT, HICON, LPTSTR, UINT);


// globals
ICONMETRICS imTheme;
NONCLIENTMETRICS ncmTheme;
// string size metrics
int cxNormalStr;
int yButtonStr;
int cxDisabledStr, cxSelectedStr;   // includes extra 2 chars width cxAvgCharx2
int cyDisabledStr, cxAvgCharx2;


#define RGB_PALETTE 0x02000000

//
// FakewinInit/Destroy
//
// These are the the constant objects and one-time inits for
// things we need to paint the fake window sample.
//
// Taken from the display CPL code, rearranged, commented and cleaned up.
//

BOOL FAR PASCAL FakewinInit(void)
{
   HDC hdc;
   int iter;

   //
   // Load our display strings.

   LoadString(hInstApp, IDS_ACTIVE, szFakeActive, ARRAYSIZE(szFakeActive));
   LoadString(hInstApp, IDS_INACTIVE, szFakeInactive, ARRAYSIZE(szFakeInactive));
   LoadString(hInstApp, IDS_MINIMIZED, szFakeMinimized, ARRAYSIZE(szFakeMinimized));
   LoadString(hInstApp, IDS_ICONTITLE, szFakeIconTitle, ARRAYSIZE(szFakeIconTitle));
   LoadString(hInstApp, IDS_NORMAL, szFakeNormal, ARRAYSIZE(szFakeNormal));
   LoadString(hInstApp, IDS_DISABLED, szFakeDisabled, ARRAYSIZE(szFakeDisabled));
   LoadString(hInstApp, IDS_SELECTED, szFakeSelected, ARRAYSIZE(szFakeSelected));
   LoadString(hInstApp, IDS_MSGBOX, szFakeMsgBox, ARRAYSIZE(szFakeMsgBox));
   LoadString(hInstApp, IDS_BUTTONTEXT, szFakeButton, ARRAYSIZE(szFakeButton));
// LoadString(hInstApp, IDS_SMCAPTION, szFakeSmallCaption, ARRAYSIZE(szFakeSmallCaption));
   LoadString(hInstApp, IDS_WINDOWTEXT, szFakeWindowText, ARRAYSIZE(szFakeWindowText));
   LoadString(hInstApp, IDS_MSGBOXTEXT, szFakeMsgBoxText, ARRAYSIZE(szFakeMsgBoxText));

   //
   // store interesting gdi info
   hdc = GetDC(NULL);
   bPalette = GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE;
   ReleaseDC(NULL, hdc);

   //
   // other sys info that doesn't change with theme
   cyFixedBorder = GetSystemMetrics(SM_CYBORDER);
   cxFixedBorder = GetSystemMetrics(SM_CXBORDER);
   cxFixedEdge = GetSystemMetrics(SM_CXEDGE);
   cyFixedEdge = GetSystemMetrics(SM_CYEDGE);

   //
   // always make a palette even on non-pal device (???)
   if (bPalette || TRUE)
   {
      DWORD dwPal[21];
      HPALETTE hpal = GetStockObject(DEFAULT_PALETTE);

      dwPal[0]  = MAKELONG(0x300, 20);
      dwPal[1]  = RGB(255, 255, 255);
      dwPal[2]  = RGB(0,   0,   0  );
      dwPal[3]  = RGB(192, 192, 192);
      dwPal[4]  = RGB(128, 128, 128);
      dwPal[5]  = RGB(255, 0,   0  );
      dwPal[6]  = RGB(128, 0,   0  );
      dwPal[7]  = RGB(255, 255, 0  );
      dwPal[8]  = RGB(128, 128, 0  );
      dwPal[9]  = RGB(0  , 255, 0  );
      dwPal[10] = RGB(0  , 128, 0  );
      dwPal[11] = RGB(0  , 255, 255);
      dwPal[12] = RGB(0  , 128, 128);
      dwPal[13] = RGB(0  , 0,   255);
      dwPal[14] = RGB(0  , 0,   128);
      dwPal[15] = RGB(255, 0,   255);
      dwPal[16] = RGB(128, 0,   128);

      // get magic colors
      GetPaletteEntries(hpal, 8,  4, (LPPALETTEENTRY)&dwPal[17]);

      hpal3D = CreatePalette((LPLOGPALETTE)dwPal);
   }

   // init fonts/brushes arrays to null
   for (iter = 0; iter < NUM_FONTS; iter++) {
      g_fonts[iter].hfont = NULL;
   }
   for (iter = 0; iter < MAX_COLORS; iter++) {
      g_brushes[iter] = NULL;
   }

   // cleanup
   return (TRUE);
}

// final deletion of fonts, brushes, palette
void FAR PASCAL FakewinDestroy(void)
{
   int i;

   for (i = 0; i < NUM_FONTS; i++) {
      if (g_fonts[i].hfont)
         DeleteObject(g_fonts[i].hfont);
   }
   for (i = 0; i < MAX_COLORS; i++) {
      if (g_brushes[i])
         DeleteObject(g_brushes[i]);
   }

   if (hpal3D)
      DeleteObject(hpal3D);
}


//
// FakewinSetTheme
//
// Reset all the things you're painting that change with each theme:
// colors, brushes, fonts, etc.
//
// Then given the current fonts and win sizes, call FakewinRecalc to
// recalculate all the rectangles for painting.
//
#define bThemed (*lpszTheme)
void FAR FakewinSetTheme(LPTSTR lpszTheme)
{
   extern TCHAR szMetrics[];
   extern TCHAR szNCM[];
   extern TCHAR szIM[];
   UINT uret;
   int iter;

   //
   // init colors: get theme's system colors and null out old brushes
   GetThemeColors(lpszTheme);
   for (iter = 0; iter < MAX_COLORS; iter++) {
      if (g_brushes[iter]) DeleteObject(g_brushes[iter]);
      g_brushes[iter] = NULL;
   }

   //
   // tweak system color palette for 3D face color in array
   if (bPalette) {
      PALETTEENTRY pePal[4];
      HPALETTE hpal = GetStockObject(DEFAULT_PALETTE);

      // get current magic colors
      GetPaletteEntries(hpal, 8,  4, pePal);
      SetPaletteEntries(hpal3D, 16,  4, pePal);

      // set up magic colors in the 3d palette
      if (!IsPaletteColor(hpal, g_rgb[COLOR_3DFACE])) {
         Set3DPaletteColor(g_rgb[COLOR_3DFACE], COLOR_3DFACE);
         Set3DPaletteColor(g_rgb[COLOR_3DSHADOW], COLOR_3DSHADOW);
         Set3DPaletteColor(g_rgb[COLOR_3DHILIGHT], COLOR_3DHILIGHT);
      }
   }

   //
   // now go get new brushes for the new and tweaked sys colors
   for (iter = 0; iter < MAX_COLORS; iter++) {
      g_rgb[iter] = NearestColor(iter, g_rgb[iter]);
      g_brushes[iter] = CreateSolidBrush(g_rgb[iter]);
   }

   //
   // get window/border/etc size info from theme
   if (bThemed &&                   // theme file and active checkbox
       (bCBStates[FC_BORDERS] || bCBStates[FC_FONTS])) { // one or both checked

      uret = (UINT) GetPrivateProfileString((LPTSTR)szMetrics, (LPTSTR)szNCM,
                                          (LPTSTR)szNULL,
                                          (LPTSTR)pValue, MAX_VALUELEN,
                                          lpszTheme);
      Assert(uret, TEXT("problem getting stored nonclient metrics for fakewin setup\n"));
      // translate stored data string to NONCLIENTMETRICS bytes
      WriteBytesToBuffer((LPTSTR)pValue);  // char str read from and binary bytes
                                           // written to pValue. It's OK.
      // get it into global NONCLIENTMETRICS struct
#ifdef UNICODE
      // NONCLIENTMETRICS are stored in ANSI format in the Theme file
      // so we need to convert them to UNICODE.
      ConvertNCMetricsToWIDE((LPNONCLIENTMETRICSA)pValue, (LPNONCLIENTMETRICSW)&ncmTheme);
#else
      // Not UNICODE so no need to convert from ANSI...
      ncmTheme = *((LPNONCLIENTMETRICS)pValue);
#endif

      // if _both_ checkboxes are checked, stay with theme file settings for all;
      // if neither were checked, you're not in this code branch (see above);
      // but if one or the other is unchecked, need to mix and match

      if (!bCBStates[FC_BORDERS] || !bCBStates[FC_FONTS]) {
         NONCLIENTMETRICS ncmTemp;

         // get cur system settings
         ncmTemp.cbSize = sizeof(ncmTemp);
         SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncmTemp),
                              (void far *)(LPNONCLIENTMETRICS)&ncmTemp, FALSE);

         //
         // mix them in with theme file settings according to checkbox

         // don't use theme's win borders/sizes and font sizes
         if (!bCBStates[FC_BORDERS]) {
            ncmTheme.iBorderWidth      =  ncmTemp.iBorderWidth;
            ncmTheme.iScrollWidth      =  ncmTemp.iScrollWidth;
            ncmTheme.iScrollHeight     =  ncmTemp.iScrollHeight;
            ncmTheme.iCaptionWidth     =  ncmTemp.iCaptionWidth;
            ncmTheme.iCaptionHeight    =  ncmTemp.iCaptionHeight;
            ncmTheme.iSmCaptionWidth   =  ncmTemp.iSmCaptionWidth;
            ncmTheme.iSmCaptionHeight  =  ncmTemp.iSmCaptionHeight;
            ncmTheme.iMenuWidth        =  ncmTemp.iMenuWidth;
            ncmTheme.iMenuHeight       =  ncmTemp.iMenuHeight;

            TransmitFontCharacteristics(&(ncmTheme.lfCaptionFont),
                                        &(ncmTemp.lfCaptionFont),
                                        TFC_SIZE);
            TransmitFontCharacteristics(&(ncmTheme.lfSmCaptionFont),
                                        &(ncmTemp.lfSmCaptionFont),
                                        TFC_SIZE);
            TransmitFontCharacteristics(&(ncmTheme.lfMenuFont),
                                        &(ncmTemp.lfMenuFont),
                                        TFC_SIZE);
            TransmitFontCharacteristics(&(ncmTheme.lfStatusFont),
                                        &(ncmTemp.lfStatusFont),
                                        TFC_SIZE);
            TransmitFontCharacteristics(&(ncmTheme.lfMessageFont),
                                        &(ncmTemp.lfMessageFont),
                                        TFC_SIZE);
         }
         // don't use theme's font styles
         if (!bCBStates[FC_FONTS]) {   // coulda been an else clause logically
            TransmitFontCharacteristics(&(ncmTheme.lfCaptionFont),
                                        &(ncmTemp.lfCaptionFont),
                                        TFC_STYLE);
            TransmitFontCharacteristics(&(ncmTheme.lfSmCaptionFont),
                                        &(ncmTemp.lfSmCaptionFont),
                                        TFC_STYLE);
            TransmitFontCharacteristics(&(ncmTheme.lfMenuFont),
                                        &(ncmTemp.lfMenuFont),
                                        TFC_STYLE);
            TransmitFontCharacteristics(&(ncmTheme.lfStatusFont),
                                        &(ncmTemp.lfStatusFont),
                                        TFC_STYLE);
            TransmitFontCharacteristics(&(ncmTheme.lfMessageFont),
                                        &(ncmTemp.lfMessageFont),
                                        TFC_STYLE);
         }
      }
   }
   else {                           // no theme: cur windows settings
      ncmTheme.cbSize = sizeof(ncmTheme);
      SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncmTheme),
                           (void far *)(LPNONCLIENTMETRICS)&ncmTheme, FALSE);
   }

   //
   // get icon info from theme
   if (bThemed && bCBStates[FC_ICONS]) {  // theme file and active checkbox
      uret = (UINT) GetPrivateProfileString((LPTSTR)szMetrics, (LPTSTR)szIM,
                                          (LPTSTR)szNULL,
                                          (LPTSTR)pValue, MAX_VALUELEN,
                                          lpszTheme);
      Assert(uret, TEXT("problem getting stored icon metrics for fakewin setup\n"));
      // translate stored data string to ICONMETRICS bytes
      WriteBytesToBuffer((LPTSTR)pValue);  // char str read from and binary bytes
                                           // written to pValue. It's OK.
      // get it into global ICONMETRICS struct
#ifdef UNICODE
      // ICONMETRICS are stored in ANSI format in the Theme file so
      // we need to convert to UNICODE.
      ConvertIconMetricsToWIDE((LPICONMETRICSA)pValue, (LPICONMETRICSW)&imTheme);
#else
      // Not UNICODE so no need to convert ICONMETRICS...
      imTheme = *((LPICONMETRICS)pValue);
#endif
   }
   else {
      imTheme.cbSize = sizeof(imTheme);
      SystemParametersInfo(SPI_GETICONMETRICS, sizeof(imTheme),
                           (void far *)(LPICONMETRICS)&imTheme, FALSE);
   }

   //
   // get fonts from theme and create the fonts
   GetThemeFonts(lpszTheme);
   for (iter = 0; iter < NUM_FONTS; iter++) {
      if (g_fonts[iter].hfont) DeleteObject(g_fonts[iter].hfont);
      g_fonts[iter].hfont = CreateFontIndirect(&g_fonts[iter].lf);
   }

   // lastly, call the painting rect recalc
   // now that you have new fonts and sizes
   FakewinRecalc();
}


//
// GetThemeColors
//
// This routine just gets colors from the theme into the global colors
// array. Luckily, we already have our own parallel arrays of color IDs
// and strings.
//
void GetThemeColors(LPTSTR lpszTheme)
{
   int i;
   BOOL bGrad = FALSE;  // Are gradient captions enabled?

   // Init bGrad
   SystemParametersInfo(SPI_GETGRADIENTCAPTIONS, 0, (LPVOID)&bGrad, 0);

   // can't measure this with extern def'd arrays
   #if 0
   Assert ((sizeof(iSysColorIndices)/sizeof(int)) == MAX_COLORS,
           TEXT("wrong length color array in GetThemeColors\n"));
   #endif

   // loop through our array and store theme color in their array
   for (i = 0; i < MAX_COLORS; i++) {

      if (bThemed && bCBStates[FC_COLORS]) { // theme file and active checkbox
         // get string from theme
         GetPrivateProfileString((LPTSTR)szColorApp,
                                 (LPTSTR)pRegColors[i],
                                 (LPTSTR)szNULL,
                                 (LPTSTR)pValue, MAX_VALUELEN, lpszTheme);

         // Check to see if this is one of the Gradient title bar colors.
         // If it is and there is no setting in the Theme file use the color
         // for the NON-GRADIENT CAPTION instead.

         if ((INDEX_GRADIENTACTIVE == i) && !*pValue) {
         GetPrivateProfileString((LPTSTR)szColorApp,
                                 (LPTSTR)pRegColors[INDEX_ACTIVE],
                                 (LPTSTR)szNULL,
                                 (LPTSTR)pValue, MAX_VALUELEN, lpszTheme);
         }
         if ((INDEX_GRADIENTINACTIVE == i) && !*pValue) {
         GetPrivateProfileString((LPTSTR)szColorApp,
                                 (LPTSTR)pRegColors[INDEX_INACTIVE],
                                 (LPTSTR)szNULL,
                                 (LPTSTR)pValue, MAX_VALUELEN, lpszTheme);
         }

         // translate string and store in RGB array with corresponding index
         g_rgb[iSysColorIndices[i]] = RGBStringToColor((LPTSTR)pValue);
      }
      else {                        // cur windows settings
         // If this is one of the gradient colors and the system
         // doesn't support gradient (bpp ! > 256) or gradients are
         // not currently enabled then get the primary gradient color
         // for the gradient colors

         // bGrad -- are gradient captions enabled?
         // g_bGradient -- enough colors for gradient captions?

         if (((COLOR_GRADIENTACTIVECAPTION == iSysColorIndices[i]) ||
              (COLOR_GRADIENTINACTIVECAPTION == iSysColorIndices[i])) &&
             (!(bGrad && g_bGradient))) {

             if (INDEX_GRADIENTACTIVE == i) g_rgb[i] = GetSysColor(COLOR_ACTIVECAPTION);
             else if (INDEX_GRADIENTINACTIVE == i) g_rgb[i] = GetSysColor(COLOR_INACTIVECAPTION);
         }
         else g_rgb[i] = GetSysColor(i);
      }
   }
}

//
// GetThemeFonts
//
// This routine just gets fonts from the theme into the global fonts
// array. Need to do each font individually into the array.
// Would be cleaner if we were starting this from scratch. Just trying
// to munge it into the form the borrowed code uses.
//
// Note that for Cur Windows Settings, the ncmTheme and imTheme are already
// set to cur win settings, so this just works the same.
//
void GetThemeFonts(LPTSTR lpszTheme)
{
   g_fonts[FONT_CAPTION].lf =    ncmTheme.lfCaptionFont;
   g_fonts[FONT_MENU].lf =       ncmTheme.lfMenuFont;
   g_fonts[FONT_STATUS].lf =     ncmTheme.lfStatusFont;
   g_fonts[FONT_MSGBOX].lf =     ncmTheme.lfMessageFont;

   g_fonts[FONT_ICONTITLE].lf =  imTheme.lfFont;
}




// ----------------------------------------------------------------------------
// FakewinRecalc
//
// calculate all of the rectangles based on the given window rect
// ----------------------------------------------------------------------------
void FakewinRecalc(void)
{
//    DWORD xyNormal;
//    DWORD xyButton;
   SIZE sizeExtent;
    RECT rc;
    HFONT hfontT;
    int cxFrame, cyFrame;
    int cyCaption;
    int i;
    HDC hdc;

   // inits
   hdc = GetDC(NULL);
   rc = rFakeWin;

   //
   // Get our drawing data
   //
   cxFrame = ((int)ncmTheme.iBorderWidth + 1) * cxFixedBorder + cxFixedEdge;
   cyFrame = ((int)ncmTheme.iBorderWidth + 1) * cyFixedBorder + cyFixedEdge;
   cyCaption = (int)ncmTheme.iCaptionHeight;
//   cxSize = GetSystemMetrics(SM_CXSIZE); // WHAT GIVES ***DEBUG***
   cxSize = cyCaption - 2*cyFixedBorder;    // Wild-Assed Guess

   //
   // Get text dimensions, with proper fonts
   //

   hfontT = SelectObject(hdc, g_fonts[FONT_CAPTION].hfont);

   SelectObject(hdc, g_fonts[FONT_MENU].hfont);

   //
   // rewrite this to use win32 code
   //
   GetTextExtentPoint32(hdc, szFakeNormal, lstrlen(szFakeNormal), (LPSIZE)&sizeExtent);
   cxNormalStr = (int)(sizeExtent.cx);

   GetTextExtentPoint32(hdc, szFakeDisabled, lstrlen(szFakeDisabled), (LPSIZE)&sizeExtent);
   cxDisabledStr = (int)(sizeExtent.cx);
   cyDisabledStr = (int)(sizeExtent.cy);

   GetTextExtentPoint32(hdc, szFakeSelected, lstrlen(szFakeSelected), (LPSIZE)&sizeExtent);
   cxSelectedStr = (int)(sizeExtent.cx);

   // get the average width (USER style) of menu font
   GetTextExtentPoint32(hdc, szFakeABC, 52, (LPSIZE)&sizeExtent);
   cxAvgCharx2 = 2 * ((int)(sizeExtent.cx) / 52);

   // actual menu-handling widths of strings is bigger
   cxDisabledStr += cxAvgCharx2;
   cxSelectedStr += cxAvgCharx2;
   cxNormalStr += cxAvgCharx2;

   GetTextExtentPoint32(hdc, szFakeButton, lstrlen(szFakeButton), (LPSIZE)&sizeExtent);
   yButtonStr = (int)(sizeExtent.cy);

   #ifdef ORIG_OUTDATED_CPL_CODE
   xyNormal = GetTextExtent(hdc, szFakeNormal, lstrlen(szFakeNormal));
   cxDisabledStr = LOWORD(GetTextExtent(hdc, szFakeDisabled, lstrlen(szFakeDisabled)));
   cxSelectedStr = LOWORD(GetTextExtent(hdc, szFakeSelected, lstrlen(szFakeSelected)));
   // get the average width (USER style) of menu font
   cxAvgCharx2 = 2 * (LOWORD(GetTextExtent(hdc, szFakeABC, 52)) / 52);
   // actual menu-handling widths of strings is bigger
   cxDisabledStr += cxAvgCharx2;
   cxSelectedStr += cxAvgCharx2;
   LOWORD(xyNormal) += cxAvgCharx2;
   xyButton = GetTextExtent(hdc, szFakeButton, lstrlen(szFakeButton));
   #endif

   // done with dc
   SelectObject(hdc, hfontT);
   ReleaseDC(NULL, hdc);


   // donna paint dt! already done
   #if 0
   // Desktop
   RCZ(ELEMENT_DESKTOP) = rc;
   InflateRect(&rc, -8*cxFixedBorder, -8*cyFixedBorder);
   #endif

   //
   // Windows
   //
   rc.bottom -= cyFrame + cyCaption;
   RCZ(ELEMENT_ACTIVEBORDER) = rc;
   OffsetRect(&RCZ(ELEMENT_ACTIVEBORDER), cxFrame,
              cyFrame + cyCaption + cyFixedBorder);
   RCZ(ELEMENT_ACTIVEBORDER).bottom -= cyCaption;

   //
   // Inactive window
   //
   rc.right -= cyCaption;
   RCZ(ELEMENT_INACTIVEBORDER) = rc;

   // Caption
   InflateRect(&rc, -cxFrame, -cyFrame);
   rc.bottom = rc.top + cyCaption + cyFixedBorder;
   RCZ(ELEMENT_INACTIVECAPTION) = rc;

   // close button
   InflateRect(&rc, -cxFixedEdge, -cyFixedEdge);
   rc.bottom -= cyFixedBorder;	// compensate for magic line under caption
   RCZ(ELEMENT_INACTIVESYSBUT1) = rc;
   RCZ(ELEMENT_INACTIVESYSBUT1).left = rc.right - (cyCaption - cxFixedEdge);

   // min/max buttons
   RCZ(ELEMENT_INACTIVESYSBUT2) = rc;
   RCZ(ELEMENT_INACTIVESYSBUT2).right = RCZ(ELEMENT_INACTIVESYSBUT1).left - cxFixedEdge;
   RCZ(ELEMENT_INACTIVESYSBUT2).left = RCZ(ELEMENT_INACTIVESYSBUT2).right -
    				   2 * (cyCaption - cxFixedEdge);

   // cpl code doesn't do this either
   #if 0
   //
   // small caption window
   //
   RCZ(ELEMENT_SMCAPTION) = RCZ(ELEMENT_ACTIVEBORDER);
   RCZ(ELEMENT_SMCAPTION).bottom = RCZ(ELEMENT_SMCAPTION).top;
   RCZ(ELEMENT_SMCAPTION).top -= (int)ncmTheme.iSmCaptionHeight + cyFixedEdge + 2 * cyFixedBorder;
   RCZ(ELEMENT_SMCAPTION).right -= cxFrame;
   RCZ(ELEMENT_SMCAPTION).left = RCZ(ELEMENT_INACTIVECAPTION).right + 2 * cxFrame;

   RCZ(ELEMENT_SMCAPSYSBUT) = RCZ(ELEMENT_SMCAPTION);
   // deflate inside frame/border to caption and then another edge's worth
   RCZ(ELEMENT_SMCAPSYSBUT).right -= 2 * cxFixedEdge + cxFixedBorder;
   RCZ(ELEMENT_SMCAPSYSBUT).top += 2 * cxFixedEdge + cxFixedBorder;
   RCZ(ELEMENT_SMCAPSYSBUT).bottom -= cxFixedEdge + cxFixedBorder;
   RCZ(ELEMENT_SMCAPSYSBUT).left = RCZ(ELEMENT_SMCAPSYSBUT).right -
    			   ((int)ncmTheme.iSmCaptionHeight - cxFixedEdge);
   #endif

   //
   // Active window
   //
   // Caption
   rc = RCZ(ELEMENT_ACTIVEBORDER);
   InflateRect(&rc, -cxFrame, -cyFrame);
   RCZ(ELEMENT_ACTIVECAPTION) = rc;
   RCZ(ELEMENT_ACTIVECAPTION).bottom =
   RCZ(ELEMENT_ACTIVECAPTION).top + cyCaption + cyFixedBorder;

   // close button
   RCZ(ELEMENT_ACTIVESYSBUT1) = RCZ(ELEMENT_ACTIVECAPTION);
   InflateRect(&RCZ(ELEMENT_ACTIVESYSBUT1), -cxFixedEdge, -cyFixedEdge);
   RCZ(ELEMENT_ACTIVESYSBUT1).bottom -= cyFixedBorder;	// compensate for magic line under caption
   RCZ(ELEMENT_ACTIVESYSBUT1).left = RCZ(ELEMENT_ACTIVESYSBUT1).right -
    			   (cyCaption - cxFixedEdge);

   // min/max buttons
   RCZ(ELEMENT_ACTIVESYSBUT2) = RCZ(ELEMENT_ACTIVESYSBUT1);
   RCZ(ELEMENT_ACTIVESYSBUT2).right = RCZ(ELEMENT_ACTIVESYSBUT1).left - cxFixedEdge;
   RCZ(ELEMENT_ACTIVESYSBUT2).left = RCZ(ELEMENT_ACTIVESYSBUT2).right -
    				   2 * (cyCaption - cxFixedEdge);

   // Menu
   rc.top = RCZ(ELEMENT_ACTIVECAPTION).bottom;
   RCZ(ELEMENT_MENUNORMAL) = rc;
   rc.top = RCZ(ELEMENT_MENUNORMAL).bottom = RCZ(ELEMENT_MENUNORMAL).top + (int)ncmTheme.iMenuHeight;
   RCZ(ELEMENT_MENUDISABLED) = RCZ(ELEMENT_MENUSELECTED) = RCZ(ELEMENT_MENUNORMAL);

   RCZ(ELEMENT_MENUDISABLED).left = RCZ(ELEMENT_MENUNORMAL).left + cxNormalStr;
   RCZ(ELEMENT_MENUDISABLED).right = RCZ(ELEMENT_MENUSELECTED).left =
	   RCZ(ELEMENT_MENUDISABLED).left + cxDisabledStr;
   RCZ(ELEMENT_MENUSELECTED).right = RCZ(ELEMENT_MENUSELECTED).left + cxSelectedStr;

   //
   // Client
   //
   RCZ(ELEMENT_WINDOW) = rc;

   //
   // Scrollbar
   //
   InflateRect(&rc, -cxFixedEdge, -cyFixedEdge); // take off client edge
   RCZ(ELEMENT_SCROLLBAR) = rc;
   rc.right = RCZ(ELEMENT_SCROLLBAR).left = rc.right - (int)ncmTheme.iScrollWidth;
   RCZ(ELEMENT_SCROLLUP) = RCZ(ELEMENT_SCROLLBAR);
   RCZ(ELEMENT_SCROLLUP).bottom = RCZ(ELEMENT_SCROLLBAR).top + (int)ncmTheme.iScrollWidth;

   RCZ(ELEMENT_SCROLLDOWN) = RCZ(ELEMENT_SCROLLBAR);
   RCZ(ELEMENT_SCROLLDOWN).top = RCZ(ELEMENT_SCROLLBAR).bottom - (int)ncmTheme.iScrollWidth;

   //
   // Message Box
   //
//   rc.top = RCZ(ELEMENT_WINDOW).top + (RCZ(ELEMENT_WINDOW).bottom - RCZ(ELEMENT_WINDOW).top) / 2;
   rc.top = RCZ(ELEMENT_WINDOW).top + (RCZ(ELEMENT_WINDOW).bottom - RCZ(ELEMENT_WINDOW).top) / 3;
//   rc.bottom = RCZ(ELEMENT_DESKTOP).bottom - 2*cyFixedEdge;
   rc.bottom = rFakeWin.bottom - 2*cyFixedEdge;
   rc.left = RCZ(ELEMENT_WINDOW).left + 2*cyFixedEdge;
   rc.right = RCZ(ELEMENT_WINDOW).left + (RCZ(ELEMENT_WINDOW).right - RCZ(ELEMENT_WINDOW).left) / 2 + 3*cyCaption;
   RCZ(ELEMENT_MSGBOX) = rc;

   // Caption
   RCZ(ELEMENT_MSGBOXCAPTION) = rc;
   RCZ(ELEMENT_MSGBOXCAPTION).top += cyFixedEdge + cyFixedBorder;
   RCZ(ELEMENT_MSGBOXCAPTION).bottom = RCZ(ELEMENT_MSGBOXCAPTION).top + cyCaption + cyFixedBorder;
   RCZ(ELEMENT_MSGBOXCAPTION).left += cxFixedEdge + cxFixedBorder;
   RCZ(ELEMENT_MSGBOXCAPTION).right -= cxFixedEdge + cxFixedBorder;

   RCZ(ELEMENT_MSGBOXSYSBUT) = RCZ(ELEMENT_MSGBOXCAPTION);
   InflateRect(&RCZ(ELEMENT_MSGBOXSYSBUT), -cxFixedEdge, -cyFixedEdge);
   RCZ(ELEMENT_MSGBOXSYSBUT).left = RCZ(ELEMENT_MSGBOXSYSBUT).right -
    			   (cyCaption - cxFixedEdge);
   RCZ(ELEMENT_MSGBOXSYSBUT).bottom -= cyFixedBorder;	// line under caption

   // Button
   RCZ(ELEMENT_BUTTON).bottom = RCZ(ELEMENT_MSGBOX).bottom - (4*cyFixedBorder + cyFixedEdge);
   RCZ(ELEMENT_BUTTON).top = RCZ(ELEMENT_BUTTON).bottom - (yButtonStr + 8*cyFixedBorder);

   i = (RCZ(ELEMENT_BUTTON).bottom - RCZ(ELEMENT_BUTTON).top) * 3;
   RCZ(ELEMENT_BUTTON).left = (rc.left + (rc.right - rc.left)/2) - i/2;
   RCZ(ELEMENT_BUTTON).right = RCZ(ELEMENT_BUTTON).left + i;
}

// ----------------------------------------------------------------------------
//
//  MyDrawFrame() -
//
//  Draws bordered frame, border size cl, and adjusts passed in rect.
//
// ----------------------------------------------------------------------------
void NEAR PASCAL MyDrawFrame(HDC hdc, LPRECT prc, HBRUSH hbrColor, int cl)
{
    HBRUSH hbr;
    int cx, cy;
    RECT rcT;

    rcT = *prc;
    cx = cl * cxFixedBorder;
    cy = cl * cyFixedBorder;

    hbr = SelectObject(hdc, hbrColor);

    PatBlt(hdc, rcT.left, rcT.top, cx, rcT.bottom - rcT.top, PATCOPY);
    rcT.left += cx;

    PatBlt(hdc, rcT.left, rcT.top, rcT.right - rcT.left, cy, PATCOPY);
    rcT.top += cy;

    rcT.right -= cx;
    PatBlt(hdc, rcT.right, rcT.top, cx, rcT.bottom - rcT.top, PATCOPY);

    rcT.bottom -= cy;
    PatBlt(hdc, rcT.left, rcT.bottom, rcT.right - rcT.left, cy, PATCOPY);

    hbr = SelectObject(hdc, hbr);

    *prc = rcT;
}

/*
** draw a cyFixedBorder band of 3DFACE at the bottom of the given rectangle.
** also, adjust the rectangle accordingly.
*/
void NEAR PASCAL MyDrawBorderBelow(HDC hdc, LPRECT prc)
{
    int i;

    i = prc->top;
    prc->top = prc->bottom - cyFixedBorder;
    FillRect(hdc, prc, g_brushes[COLOR_3DFACE]);
    prc->top = i;
    prc->bottom -= cyFixedBorder;
}

/*-------------------------------------------------------------------
** draw a full window caption with system menu, minimize button,
** maximize button, and text.
**-------------------------------------------------------------------*/
void NEAR PASCAL DrawFullCaption(HDC hdc, LPRECT prc, LPTSTR lpszTitle, UINT flags)
{
    int iRight;
    int iFont;

    SaveDC(hdc);

    // special case gross for small caption that already drew on bottom
    if (!(flags & DC_SMALLCAP))
      MyDrawBorderBelow(hdc, prc);

    iRight = prc->right;
    prc->right = prc->left + cxSize;
    DrawFrameControl(hdc, prc, DFC_CAPTION, DFCS_CAPTIONCLOSE);

    prc->left = prc->right;
    prc->right = iRight - 2*cxSize;
//    iFont = flags & DC_SMALLCAP ? FONT_SMCAPTION : FONT_CAPTION;
    iFont = FONT_CAPTION;
    DrawCaptionTemp(NULL, hdc, prc, g_fonts[iFont].hfont, NULL, lpszTitle, flags | DC_ICON | DC_TEXT);

    prc->left = prc->right;
    prc->right = prc->left + cxSize;
    DrawFrameControl(hdc, prc, DFC_CAPTION, DFCS_CAPTIONMIN);
    prc->left = prc->right;
    prc->right = prc->left + cxSize;
    DrawFrameControl(hdc, prc, DFC_CAPTION, DFCS_CAPTIONMAX);

    RestoreDC(hdc, -1);
}


void FAR PASCAL FakewinDraw(HDC hdc)
{
   RECT rcT;
   int nMode;
   DWORD rgbBk;
   HANDLE hOldColors = NULL;  // paranoid
   HPALETTE hpalOld = NULL;
   HICON hiconLogo;
   HFONT hfontOld;

   //
   // inits
   //
   SaveDC(hdc);  // sneaky!
   if (hpal3D) {
      hpalOld = SelectPalette(hdc, hpal3D, TRUE);
      RealizePalette(hdc);
   }

   hOldColors = SetSysColorsTemp(g_rgb, g_brushes, MAX_COLORS);

   // Setup drawing stuff
   nMode = SetBkMode(hdc, TRANSPARENT);
   rgbBk = GetTextColor(hdc);

   hiconLogo = LoadImage(NULL, IDI_APPLICATION, IMAGE_ICON,
//   hiconLogo = LoadImage(NULL, IDI_WINLOGO, IMAGE_ICON,
    	                   (int)ncmTheme.iCaptionHeight - 2*cxFixedBorder,
    	                   (int)ncmTheme.iCaptionHeight - 2*cyFixedBorder, 0);

   // we leave the lovely desktop we've already painted there
   #if 0
   //
   // Desktop
   //
   FillRect(hdc, &RCZ(ELEMENT_DESKTOP), g_brushes[COLOR_BACKGROUND]);
   #endif

   //
   // Inactive window
   //

   // Border
   rcT = RCZ(ELEMENT_INACTIVEBORDER);
   DrawEdge(hdc, &rcT, EDGE_RAISED, BF_RECT | BF_ADJUST);
   MyDrawFrame(hdc, &rcT, g_brushes[COLOR_INACTIVEBORDER], (int)ncmTheme.iBorderWidth);
   MyDrawFrame(hdc, &rcT, g_brushes[COLOR_3DFACE], 1);

   // Caption
   rcT = RCZ(ELEMENT_INACTIVECAPTION);
   MyDrawBorderBelow(hdc, &rcT);

   // NOTE: because USER draws icon stuff using its own DC and subsequently
   // its own palette, we need to make sure to use the inactivecaption
   // brush before USER does so that it will be realized against our palette.
   // this might get fixed in USER by better be safe.

   // "clip" the caption title under the buttons
   rcT.left = RCZ(ELEMENT_INACTIVESYSBUT2).left - cyFixedEdge;
   FillRect(hdc, &rcT, g_brushes[g_bGradient ? COLOR_GRADIENTINACTIVECAPTION : COLOR_INACTIVECAPTION]);
   rcT.right = rcT.left;
   rcT.left = RCZ(ELEMENT_INACTIVECAPTION).left;
   DrawCaptionTemp(NULL, hdc, &rcT, g_fonts[FONT_CAPTION].hfont, hiconLogo, szFakeInactive,
                        DC_ICON | DC_TEXT | (g_bGradient ? DC_GRADIENT : 0));

   DrawFrameControl(hdc, &RCZ(ELEMENT_INACTIVESYSBUT1), DFC_CAPTION, DFCS_CAPTIONCLOSE);
   rcT = RCZ(ELEMENT_INACTIVESYSBUT2);
   rcT.right -= (rcT.right - rcT.left)/2;
   DrawFrameControl(hdc, &rcT, DFC_CAPTION, DFCS_CAPTIONMIN);
   rcT.left = rcT.right;
   rcT.right = RCZ(ELEMENT_INACTIVESYSBUT2).right;
   DrawFrameControl(hdc, &rcT, DFC_CAPTION, DFCS_CAPTIONMAX);


   // cpl code doesn't do small caption sample
   #if 0
   //
   // small caption window
   //
   {
   HICON hicon;
   int temp;
   rcT = RCZ(ELEMENT_SMCAPTION);
   hicon = LoadImage(NULL, IDI_APPLICATION,
         IMAGE_ICON,
   	   (int)ncmTheme.iSmCaptionHeight - 2*cxFixedBorder,
   	   (int)ncmTheme.iSmCaptionHeight - 2*cyFixedBorder,
		   0);
   DrawEdge(hdc, &rcT, EDGE_RAISED, BF_TOP | BF_LEFT | BF_RIGHT | BF_ADJUST);
   MyDrawFrame(hdc, &rcT, g_brushes[COLOR_3DFACE], 1);
   // "clip" the caption title under the buttons
   temp = rcT.left;  // remember start of actual caption
   rcT.left = RCZ(ELEMENT_SMCAPSYSBUT).left - cxFixedEdge;
   FillRect(hdc, &rcT, g_brushes[COLOR_INACTIVECAPTION]);
   rcT.right = rcT.left;
   rcT.left = temp;  // start of actual caption
   DrawCaptionTemp(NULL, hdc, &rcT, g_fonts[FONT_SMCAPTION].hfont, hicon, szFakeSmallCaption, DC_SMALLCAP | DC_ICON | DC_TEXT);
   DestroyIcon(hicon);
   DrawFrameControl(hdc, &RCZ(ELEMENT_SMCAPSYSBUT), DFC_CAPTION, DFCS_CAPTIONCLOSE);
   }
   #endif


   //
   // Active window
   //

   // Border
   rcT = RCZ(ELEMENT_ACTIVEBORDER);
   DrawEdge(hdc, &rcT, EDGE_RAISED, BF_RECT | BF_ADJUST);
   MyDrawFrame(hdc, &rcT, g_brushes[COLOR_ACTIVEBORDER], (int)ncmTheme.iBorderWidth);
   MyDrawFrame(hdc, &rcT, g_brushes[COLOR_3DFACE], 1);

   // Caption
   rcT = RCZ(ELEMENT_ACTIVECAPTION);
   MyDrawBorderBelow(hdc, &rcT);
   // "clip" the caption title under the buttons

   rcT.left = RCZ(ELEMENT_ACTIVESYSBUT2).left - cxFixedEdge;

   FillRect(hdc, &rcT, g_brushes[g_bGradient ? COLOR_GRADIENTACTIVECAPTION : COLOR_ACTIVECAPTION]);
   rcT.right = rcT.left;
   rcT.left = RCZ(ELEMENT_ACTIVECAPTION).left;
   DrawCaptionTemp(NULL, hdc, &rcT, g_fonts[FONT_CAPTION].hfont, hiconLogo, szFakeActive,
           DC_ACTIVE | DC_ICON | DC_TEXT | (g_bGradient ? DC_GRADIENT : 0));

   DrawFrameControl(hdc, &RCZ(ELEMENT_ACTIVESYSBUT1), DFC_CAPTION, DFCS_CAPTIONCLOSE);
   rcT = RCZ(ELEMENT_ACTIVESYSBUT2);
   rcT.right -= (rcT.right - rcT.left)/2;
   DrawFrameControl(hdc, &rcT, DFC_CAPTION, DFCS_CAPTIONMIN);
   rcT.left = rcT.right;
   rcT.right = RCZ(ELEMENT_ACTIVESYSBUT2).right;
   DrawFrameControl(hdc, &rcT, DFC_CAPTION, DFCS_CAPTIONMAX);

   //
   // Menu
   //
   //   DrawMenuBarTemp(NULL, hdc, &rcT, hmenuFake, g_fonts[FONT_MENU].hfont);

   // inits
   SaveDC(hdc);                     // extra paranoid for changes here
   rcT = RCZ(ELEMENT_MENUNORMAL);
   hfontOld = SelectObject(hdc, g_fonts[FONT_MENU].hfont);
   SetBkMode(hdc, TRANSPARENT);

   // menu back color
   FillRect(hdc, &rcT, g_brushes[COLOR_MENU]);

   // ***DEBUG***
   // normal text
   rcT.right = RCZ(ELEMENT_MENUDISABLED).left;
   if (rcT.right > RCZ(ELEMENT_MENUNORMAL).right)
      rcT.right = RCZ(ELEMENT_MENUNORMAL).right;   // det by caption width
   SetTextColor(hdc, GetSysColor(COLOR_MENUTEXT));
   rcT.right--; rcT.bottom--;         // adjustment for DT positioning
   DrawText(hdc, szFakeNormal, -1, (LPRECT)&rcT,
            DT_CENTER | DT_SINGLELINE | DT_VCENTER);

   // disabled text
   rcT = RCZ(ELEMENT_MENUDISABLED);
   if (rcT.right > RCZ(ELEMENT_MENUNORMAL).right)  // two checks for really,
      rcT.right = RCZ(ELEMENT_MENUNORMAL).right;
   if (rcT.left < RCZ(ELEMENT_MENUNORMAL).right) { // really big fonts
      int iwidth, iheight;

      rcT.right--; rcT.bottom--;         // adjustment for DT positioning
      iwidth = rcT.right-rcT.left;
      iheight = rcT.bottom-rcT.top;

      DrawState(hdc, NULL, NULL, (LPARAM)(LPTSTR)szFakeDisabled, 0,
               rcT.left + (iwidth-(cxDisabledStr-cxAvgCharx2))/2,
               rcT.top + (iheight-cyDisabledStr)/2,
               iwidth, iheight, DST_TEXT | DSS_DISABLED);
   }

   // selected rect back color
   rcT = RCZ(ELEMENT_MENUSELECTED);
   if (rcT.right > RCZ(ELEMENT_MENUNORMAL).right)  // two checks for really,
      rcT.right = RCZ(ELEMENT_MENUNORMAL).right;
   if (rcT.left < RCZ(ELEMENT_MENUNORMAL).right) { // really big fonts
      FillRect(hdc, &rcT, g_brushes[COLOR_HIGHLIGHT]);

      // selected text
      rcT.right--; rcT.bottom--;         // adjustment for DT positioning
      SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
      DrawText(hdc, szFakeSelected, -1, (LPRECT)&rcT,
               DT_CENTER | DT_SINGLELINE | DT_VCENTER);

      // refinish bottom of selection box
      rcT.right++; rcT.bottom++;         // readjustment back to FillRect()
      MyDrawBorderBelow(hdc, &rcT);
   }

   // clean up
   if (hfontOld)
      SelectObject(hdc, hfontOld);
   RestoreDC(hdc, -1);              // paranoid so restore


   //
   // Client area
   //

   rcT = RCZ(ELEMENT_WINDOW);
   DrawEdge(hdc, &rcT, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
   FillRect(hdc, &rcT, g_brushes[COLOR_WINDOW]);

   // window text
   SetBkMode(hdc, TRANSPARENT);
   SetTextColor(hdc, g_rgb[COLOR_WINDOWTEXT]);
   TextOut(hdc, RCZ(ELEMENT_WINDOW).left + 2*cxFixedEdge, RCZ(ELEMENT_WINDOW).top + 2*cyFixedEdge, szFakeWindowText, lstrlen(szFakeWindowText));

   //
   // scroll bar
   //
   rcT = RCZ(ELEMENT_SCROLLBAR);
   //MyDrawFrame(hdc, &rcT, g_brushes[COLOR_3DSHADOW], 1);
   //g_brushes[COLOR_SCROLLBAR]);

   // jdk: they did this to get the brush used to paint the ctl background
   // FillRect(hdc, &rcT, (HBRUSH)DefWindowProc(hWnd, WM_CTLCOLOR, (WPARAM)hdc, MAKELONG(hWnd, CTLCOLOR_SCROLLBAR)));

   // ***DEBUG***
   // will this work? or is this the thumb color? and why not MyDrawFrame()?
   // seems to be a good approximation
   FillRect(hdc, &rcT, g_brushes[COLOR_SCROLLBAR]);

   DrawFrameControl(hdc, &RCZ(ELEMENT_SCROLLUP), DFC_SCROLL, DFCS_SCROLLUP);
   DrawFrameControl(hdc, &RCZ(ELEMENT_SCROLLDOWN), DFC_SCROLL, DFCS_SCROLLDOWN);

   //
   // MessageBox
   //
   rcT = RCZ(ELEMENT_MSGBOX);
   DrawEdge(hdc, &rcT, EDGE_RAISED, BF_RECT | BF_ADJUST);
   FillRect(hdc, &rcT, g_brushes[COLOR_3DFACE]);

   rcT = RCZ(ELEMENT_MSGBOXCAPTION);
   MyDrawBorderBelow(hdc, &rcT);
   // "clip" the caption title under the buttons
   rcT.left = RCZ(ELEMENT_MSGBOXSYSBUT).left - cxFixedEdge;
   FillRect(hdc, &rcT, g_brushes[g_bGradient ? COLOR_GRADIENTACTIVECAPTION : COLOR_ACTIVECAPTION]);
   rcT.right = rcT.left;
   rcT.left = RCZ(ELEMENT_MSGBOXCAPTION).left;
   DrawCaptionTemp(NULL, hdc, &rcT, g_fonts[FONT_CAPTION].hfont, hiconLogo, szFakeMsgBox,
               DC_ACTIVE | DC_ICON | DC_TEXT | (g_bGradient ? DC_GRADIENT : 0));
   DrawFrameControl(hdc, &RCZ(ELEMENT_MSGBOXSYSBUT), DFC_CAPTION, DFCS_CAPTIONCLOSE);

   // message box text
   SetBkMode(hdc, TRANSPARENT);
   SetTextColor(hdc, g_rgb[COLOR_WINDOWTEXT]);
   hfontOld = SelectObject(hdc, g_fonts[FONT_MSGBOX].hfont);
   TextOut(hdc, RCZ(ELEMENT_MSGBOX).left + 3*cxFixedEdge, RCZ(ELEMENT_MSGBOXCAPTION).bottom + cyFixedEdge,
           szFakeMsgBoxText, lstrlen(szFakeMsgBoxText));
   if (hfontOld)
      SelectObject(hdc, hfontOld);

   //
   // Button
   //
   rcT = RCZ(ELEMENT_BUTTON);
   DrawFrameControl(hdc, &rcT, DFC_BUTTON, DFCS_BUTTONPUSH);

   // cpl code asks: ?????? what font should this use ??????
   SetBkMode(hdc, TRANSPARENT);
   SetTextColor(hdc, g_rgb[COLOR_BTNTEXT]);
   DrawText(hdc, szFakeButton, -1, &rcT, DT_CENTER | DT_NOPREFIX |
            DT_SINGLELINE | DT_VCENTER);


   //
   // Cleanup
   //
   SetBkColor(hdc, rgbBk);
   SetBkMode(hdc, nMode);
   if (hiconLogo)
      DestroyIcon(hiconLogo);
   SetSysColorsTemp((COLORREF FAR *)NULL, (HBRUSH FAR *)NULL, (UINT_PTR)hOldColors);
   if (hpalOld) {
      SelectPalette(hdc, hpalOld, FALSE);
      RealizePalette(hdc);
   }
   RestoreDC(hdc, -1);              // jdk: is this redundant to above cleanup?
}


//
//  make the color a solid color if it needs to be.
//  on a palette device make is a palette relative color, if we need to.
//
#define COLORFLAG_SOLID	0x0001
UINT g_colorFlags[MAX_COLORS] = {
/* COLOR_SCROLLBAR           */	0,
/* COLOR_DESKTOP             */	0,
/* COLOR_ACTIVECAPTION       */ COLORFLAG_SOLID,
/* COLOR_INACTIVECAPTION     */ COLORFLAG_SOLID,
/* COLOR_MENU                */ COLORFLAG_SOLID,
/* COLOR_WINDOW              */ COLORFLAG_SOLID,
/* COLOR_WINDOWFRAME         */ COLORFLAG_SOLID,
/* COLOR_MENUTEXT            */	COLORFLAG_SOLID,
/* COLOR_WINDOWTEXT          */	COLORFLAG_SOLID,
/* COLOR_CAPTIONTEXT         */ COLORFLAG_SOLID,
/* COLOR_ACTIVEBORDER        */ 0,
/* COLOR_INACTIVEBORDER      */ 0,
/* COLOR_APPWORKSPACE        */ 0,
/* COLOR_HIGHLIGHT           */ COLORFLAG_SOLID,
/* COLOR_HIGHLIGHTTEXT       */ COLORFLAG_SOLID,
/* COLOR_3DFACE              */ COLORFLAG_SOLID,
/* COLOR_3DSHADOW            */ COLORFLAG_SOLID,
/* COLOR_GRAYTEXT            */ COLORFLAG_SOLID,
/* COLOR_BTNTEXT             */	COLORFLAG_SOLID,
/* COLOR_INACTIVECAPTIONTEXT */	COLORFLAG_SOLID,
/* COLOR_3DHILIGHT           */ COLORFLAG_SOLID,
/* COLOR_3DDKSHADOW          */ COLORFLAG_SOLID,
/* COLOR_3DLIGHT             */ COLORFLAG_SOLID,
/* COLOR_INFOTEXT            */ COLORFLAG_SOLID,
/* COLOR_INFOBK              */ 0
};
COLORREF NearestColor(int iColor, COLORREF rgb)
{
    rgb &= 0x00FFFFFF;

    //
    // if we are on a palette device, we need to do special stuff...
    //
    if (bPalette)
    {
        if (g_colorFlags[iColor] & COLORFLAG_SOLID)
        {
            rgb = GetNearestPaletteColor(hpal3D, rgb) | RGB_PALETTE;
        }
        else
        {
            if (IsPaletteColor(hpal3D, rgb))
                rgb |= RGB_PALETTE;

            else if (IsPaletteColor(GetStockObject(DEFAULT_PALETTE), rgb))
                rgb ^= 0x000001;    // force a dither
        }
    }
    else
    {
        // map color to nearest color if we need to for this UI element.
        if (g_colorFlags[iColor] & COLORFLAG_SOLID)
        {
            HDC hdc = GetDC(NULL);
            rgb = GetNearestColor(hdc, rgb);
            ReleaseDC(NULL, hdc);
        }
    }

    return rgb;
}

COLORREF GetNearestPaletteColor(HPALETTE hpal, COLORREF rgb)
{
    PALETTEENTRY pe;
    GetPaletteEntries(hpal, GetNearestPaletteIndex(hpal, rgb & 0x00FFFFFF), 1, &pe);
    return RGB(pe.peRed, pe.peGreen, pe.peBlue);
}

BOOL IsPaletteColor(HPALETTE hpal, COLORREF rgb)
{
    return GetNearestPaletteColor(hpal, rgb) == (rgb & 0xFFFFFF);
}

// ------------------------ magic color utilities --------------------------
/*
** set a color in the 3D palette.
*/
void NEAR PASCAL Set3DPaletteColor(COLORREF rgb, int iColor)
{
    int iPalette;
    PALETTEENTRY pe;

    if (!hpal3D)
	return;

    switch (iColor)
    {
	case COLOR_3DFACE:
            iPalette = 16;
	    break;
	case COLOR_3DSHADOW:
            iPalette = 17;
	    break;
	case COLOR_3DHILIGHT:
            iPalette = 18;
            break;
        default:
            return;
    }

    pe.peRed    = GetRValue(rgb);
    pe.peGreen  = GetGValue(rgb);
    pe.peBlue   = GetBValue(rgb);
    pe.peFlags  = 0;
    SetPaletteEntries(hpal3D, iPalette, 1, (LPPALETTEENTRY)&pe);
}
// ------------end--------- magic color utilities --------------------------



// jdk: may need something like these to translate fonts ???

#if 0

void NEAR LF32toLF(LPLOGFONT_32 lplf32, LPLOGFONT lplf);
void NEAR LFtoLF32(LPLOGFONT lplf, LPLOGFONT_32 lplf32);
// ------------------------ manage system settings --------------------------
/*
** Helper Routine since USER's new METRICS structures are all 32-bit
*/
void NEAR LF32toLF(LPLOGFONT_32 lplf32, LPLOGFONT lplf)
{
    lplf->lfHeight       = (int) lplf32->lfHeight;
    lplf->lfWidth        = (int) lplf32->lfWidth;
    lplf->lfEscapement   = (int) lplf32->lfEscapement;
    lplf->lfOrientation  = (int) lplf32->lfOrientation;
    lplf->lfWeight       = (int) lplf32->lfWeight;
    *((LPCOMMONFONT) &lplf->lfItalic) = lplf32->lfCommon;
}
void NEAR LFtoLF32(LPLOGFONT lplf, LPLOGFONT_32 lplf32)
{
    lplf32->lfHeight = (LONG)lplf->lfHeight;
    lplf32->lfWidth = (LONG)lplf->lfWidth;
    lplf32->lfEscapement = (LONG)lplf->lfEscapement;
    lplf32->lfOrientation = (LONG)lplf->lfOrientation;
    lplf32->lfWeight = (LONG)lplf->lfWeight;
    lplf32->lfCommon = *((LPCOMMONFONT) &lplf->lfItalic);
}

/*
** Fill in a NONCLIENTMETRICS structure with latest preview stuff
*/
void NEAR GetMyNonClientMetrics(LPNONCLIENTMETRICS lpncm)
{
    lpncm->iBorderWidth = (LONG)(int)ncmTheme.iBorderWidth;
    lpncm->iScrollWidth = lpncm->iScrollHeight = (LONG)(int)ncmTheme.iScrollWidth;
    lpncm->iCaptionWidth = lpncm->iCaptionHeight = (LONG)(int)ncmTheme.iCaptionHeight;
    lpncm->iSmCaptionWidth = lpncm->iSmCaptionHeight = (LONG)(int)ncmTheme.iSmCaptionHeight;
    lpncm->iMenuWidth = lpncm->iMenuHeight = (LONG)(int)ncmTheme.iMenuHeight;
    LFtoLF32(&(g_fonts[FONT_CAPTION].lf), &(lpncm->lfCaptionFont));
    LFtoLF32(&(g_fonts[FONT_SMCAPTION].lf), &(lpncm->lfSmCaptionFont));
    LFtoLF32(&(g_fonts[FONT_MENU].lf), &(lpncm->lfMenuFont));
    LFtoLF32(&(g_fonts[FONT_STATUS].lf), &(lpncm->lfStatusFont));
    LFtoLF32(&(g_fonts[FONT_MSGBOX].lf), &(lpncm->lfMessageFont));
}
/*
** given a NONCLIENTMETRICS structure, make it preview's current setting
*/
void NEAR SetMyNonClientMetrics(LPNONCLIENTMETRICS lpncm)
{
    (int)ncmTheme.iBorderWidth = (int)lpncm->iBorderWidth;
    (int)ncmTheme.iScrollWidth = (int)lpncm->iScrollWidth;
    (int)ncmTheme.iCaptionHeight = (int)lpncm->iCaptionHeight;
    (int)ncmTheme.iSmCaptionHeight = (int)lpncm->iSmCaptionHeight;
    (int)ncmTheme.iMenuHeight = (int)lpncm->iMenuHeight;

    LF32toLF(&(lpncm->lfCaptionFont), &(g_fonts[FONT_CAPTION].lf));
    LF32toLF(&(lpncm->lfSmCaptionFont), &(g_fonts[FONT_SMCAPTION].lf));
    LF32toLF(&(lpncm->lfMenuFont), &(g_fonts[FONT_MENU].lf));
    LF32toLF(&(lpncm->lfStatusFont), &(g_fonts[FONT_STATUS].lf));
    LF32toLF(&(lpncm->lfMessageFont), &(g_fonts[FONT_MSGBOX].lf));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\frost.c ===
/* FROST.C

   Resident Code Segment
   WinMain()
   Main Window(Dlg) Proc
   FrostCommand()
   Small Resident UtilityRoutines

   Frosting: Master Theme Selector for Windows '95
   Copyright (c) 1994-1999 Microsoft Corporation.  All rights reserved.
*/

// ---------------------------------------------
// Brief file history:
// Alpha:
// Beta:
// Bug fixes
// ---------
//
// ---------------------------------------------


#define ROOTFILE 1
#include "windows.h"
#include "windowsx.h"
#include <mbctype.h>
#include "frost.h"
#include "global.h"
#include "..\inc\addon.h"
#include "schedule.h"
#include "htmlprev.h"
#include "objbase.h"
#include "cderr.h"
#include "commdlg.h"

/* Local Routines */
BOOL FrostCommand(HWND, WPARAM, LPARAM);
BOOL ResetTheThemeWorld(LPTSTR);
BOOL InitThemeDDL(HWND);
void NewSampleTitle(void);
void EnableScreenSaverButton();
BOOL FileSpecExists(LPTSTR szFilename);
INT_PTR FAR PASCAL BPP_ChoiceDlg(HWND, UINT, WPARAM, LPARAM);


// globals
BOOL bNewSelection = TRUE;
BOOL bAppliedOnce = FALSE;    // have you applied any theme yet?
BOOL gfCoInitDone = FALSE;    // track state of OLE CoInitialize()
BOOL bCB_SchedChange = FALSE; // User has toggled status of Schedule check
BOOL bInGrphFilter = FALSE;   // Currently in a Graphics filter?

// virtual boolean: null theme name means Cur Win Settings, not from theme file
#define bThemed (*szCurThemeFile)
#define FROSTUNIQUEREPLY   1332           // twice 666

POPUP_HELP_ARRAY phaMainWin[] = {
   { (DWORD)DDL_THEME,     (DWORD)IDH_THEME_LIST           },
   { (DWORD)PB_SAVE,       (DWORD)IDH_THEME_SAVEAS         },
   { (DWORD)PB_DELETE,     (DWORD)IDH_THEME_DELETE         },
   { (DWORD)PB_SCRSVR,     (DWORD)IDH_THEME_PREVSCRN       },
   { (DWORD)PB_POINTERS,   (DWORD)IDH_THEME_PREVETC        },
   { (DWORD)CB_SCRSVR,     (DWORD)IDH_THEME_SCRNSAVER      },
   { (DWORD)CB_SOUND,      (DWORD)IDH_THEMES_SOUNDS        },
   { (DWORD)CB_PTRS,       (DWORD)IDH_THEME_POINTERS       },
   { (DWORD)CB_WALL,       (DWORD)IDH_THEME_WALLPAPER      },
   { (DWORD)CB_ICONS,      (DWORD)IDH_THEME_ICONS          },
   { (DWORD)CB_COLORS,     (DWORD)IDH_THEME_COLORS         },
   { (DWORD)CB_FONTS,      (DWORD)IDH_THEME_FONTS          },
   { (DWORD)CB_BORDERS,    (DWORD)IDH_THEME_BORDER         },
//   { (DWORD)CB_ICONSIZE,   (DWORD)IDH_THEME_ICON_SIZESPACE },
   { (DWORD)CB_SCHEDULE,   (DWORD)IDH_THEME_ROTATE         },
   { (DWORD)0,             (DWORD)0                        }, // double-null terminator
};

int WINAPI WinMain(hInstance, hPrevInstance, lpCmdLine, nCmdShow)
HINSTANCE hInstance;                         /* current instance             */
HINSTANCE hPrevInstance;                     /* previous instance            */
LPSTR lpCmdLine;                             /* command line                 */
int nCmdShow;                                /* show-window type (open/icon) */
{
   MSG msg;
   HWND hWndPrev, hPopupWnd;
   TCHAR szMsg[MAX_MSGLEN+1];
   TCHAR szAppName[MAX_STRLEN+1];
#ifdef UNICODE
   CHAR szMsgA[MAX_MSGLEN+1];
   CHAR szAppNameA[MAX_STRLEN+1];
#endif
   OSVERSIONINFO osVerInfo;

   //
   // just checking on the debug facilities
   Assert(FALSE, TEXT("On_entry: WinMain\n"));

#ifdef UNICODE
   // UNICODE Check -- if we're a UNICODE binary trying to run on Win9x
   // show error and bail out.
   if (!IsPlatformNT())
   {
      LoadStringA(hInstance, STR_APPNAME, szAppNameA, MAX_STRLEN);  // title string
      LoadStringA(hInstance, STR_ERRNOUNICODE, szMsgA, MAX_STRLEN);  // error string
      MessageBoxA(NULL, szMsgA, szAppNameA, MB_OK | MB_APPLMODAL | MB_ICONERROR);

      return FALSE;
   }
#endif // UNICODE

   // Verify the OS version
   ZeroMemory(&osVerInfo, sizeof(osVerInfo));
   osVerInfo.dwOSVersionInfoSize = sizeof(osVerInfo);
   if (GetVersionEx(&osVerInfo))
   {
      // If NT, we need to be version 5.0 or later.
      if ((osVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) &&
          (osVerInfo.dwMajorVersion < 5))
      {
          LoadString(hInstance, STR_APPNAME, szAppName, MAX_STRLEN);  // title string
          LoadString(hInstance, STR_ERRNOUNICODE, szMsg, MAX_STRLEN);  // error string
          MessageBox(NULL, szMsg, szAppName, MB_OK | MB_APPLMODAL | MB_ICONERROR);
          return FALSE;
      }

      // If Win9x, we need to be version 4.1 or later (Win98).
      if ((osVerInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
          ((osVerInfo.dwMajorVersion < 4) ||
           (osVerInfo.dwMajorVersion == 4) && (osVerInfo.dwMinorVersion < 10)))
      {
          LoadString(hInstance, STR_APPNAME, szAppName, MAX_STRLEN);  // title string
          LoadString(hInstance, STR_ERRBAD9XVER, szMsg, MAX_STRLEN);  // error string
          MessageBox(NULL, szMsg, szAppName, MB_OK | MB_APPLMODAL | MB_ICONERROR);
          return FALSE;
      }

      // If the Platform ID is not NT or WIN32 we will run and hope for the
      // best.
   }


   //
   // Prev instance check
   //

   // go see if there is already a window of this type
   LoadString(hInstance, STR_APPNAME, (LPTSTR)szMsg, MAX_STRLEN);  // title string
   hWndPrev = FindWindow((LPTSTR)szClassName, NULL);

   // if you are not the first instance
   if (hWndPrev) {
      if (IsIconic(hWndPrev))
         ShowWindow(hWndPrev, SW_RESTORE);
      else {
         BringWindowToTop(hWndPrev);
         if ((hPopupWnd = GetLastActivePopup(hWndPrev)) != hWndPrev) {
            BringWindowToTop(hPopupWnd);
            hWndPrev = hPopupWnd;
         }
         SetForegroundWindow(hWndPrev);
      }
      // leave this barren place
      return FALSE;                     // ONLY ONE INSTANCE CAN RUN!
   }

   //
   // Initializations
   //

   // run this app!
   if (!InitFrost(hPrevInstance,
                  hInstance,
#ifdef UNICODE
                  GetCommandLine(),
#else
                  lpCmdLine,
#endif
                  nCmdShow))
   {
      // Problems...
      NoMemMsg(STR_TO_RUN);     // not enuf mem to run
      CleanUp();                // Release IThumbnail interface
      return (FALSE);
   }

   // InitFrost may return TRUE if we did something with the commandline, but
   // didn't put up any UI.
   if (hWndApp == NULL) {
      CleanUp();  // Release IThumbnail interface
      return (TRUE);
   }

   //
   // Main message loop
   //
   while (GetMessage(&msg, NULL, 0, 0)) {
      if (hWndApp)
         if (IsDialogMessage(hWndApp, &msg))
            continue;                     // spend most of our time skipping out here
      TranslateMessage(&msg);             /* Translates virtual key codes */
      DispatchMessage(&msg);              /* Dispatches message to window */
   }

   //
   // final exit cleanup
   //
   CleanUp();       // Release our IThumbnail interface for HTML wallpaper
   return (int)(msg.wParam);       /* Returns the value from PostQuitMessage */
}


// PreviewDlgProc
//
// The main window (dialog) proc for the Frosting application.
//

INT_PTR FAR PASCAL PreviewDlgProc(hDlg, message, wParam, lParam)
HWND hDlg;
UINT message;
WPARAM wParam;
LPARAM lParam;
{
   PAINTSTRUCT ps;
   HDC hdc;
   LPHELPINFO lphi;

   switch (message) {

   case WM_INITDIALOG:
      hWndApp = hDlg;

      // init case nomem flag
      bNoMem = FALSE;

      //
      // theme drop-down listbox inits

      bNoMem |= !InitThemeDDL(hDlg);   // init contents, selection
      SendDlgItemMessage(hDlg, DDL_THEME, CB_SETEXTENDEDUI, TRUE, 0L);

      // update preview and checkboxes for cur theme selection

      //
      // other inits

      // rect for preview, adjusted to dlg-relative coords
      GetWindowRect(GetDlgItem(hDlg, RECT_PREVIEW), (LPRECT)&rView);
      MapWindowPoints(NULL, hDlg, (LPPOINT)&rView, 2);
      // kill it now that you've had your way with it
      DestroyWindow(GetDlgItem(hDlg, RECT_PREVIEW));

      // and rect within that rect for sample window
      GetWindowRect(GetDlgItem(hDlg, RECT_FAKEWIN), (LPRECT)&rFakeWin);
      MapWindowPoints(NULL, hDlg, (LPPOINT)&rFakeWin, 2);
      // actually, FakeWin painting is going to be relative to Preview area, so
      OffsetRect((LPRECT)&rFakeWin, -rView.left, -rView.top);

      // kill it now that you've had your way with it
      DestroyWindow(GetDlgItem(hDlg, RECT_FAKEWIN));

      // and another rect within Preview rect, for icons
      GetWindowRect(GetDlgItem(hDlg, RECT_ICONS), (LPRECT)&rPreviewIcons);
      MapWindowPoints(NULL, hDlg, (LPPOINT)&rPreviewIcons, 2);
      // actually, icons are going to be relative to Preview area too, so
      OffsetRect((LPRECT)&rPreviewIcons, -rView.left, -rView.top);

      // kill it now that you've had your way with it
      DestroyWindow(GetDlgItem(hDlg, RECT_ICONS));


      //
      // add What's This? to system menu: for some reason, can't have ? in title bar
      {
         HMENU hSysMenu;

         hSysMenu = GetSystemMenu(hDlg, FALSE);
         LoadString(hInstApp, STR_WHATSTHIS, szMsg, ARRAYSIZE(szMsg));
         InsertMenu(hSysMenu, SC_CLOSE, MF_BYCOMMAND | MF_STRING,
                    SC_CONTEXTHELP, (LPTSTR)szMsg);
         InsertMenu(hSysMenu, SC_CLOSE, MF_BYCOMMAND | MF_SEPARATOR, 0, NULL);
      }

      // set init focus to theme drop-down listbox
      SetFocus(GetDlgItem(hDlg,DDL_THEME));

      // cleanup
      return (FALSE);               // handled init ctl focus ourselves
      break;

   case WM_QUERYNEWPALETTE:
   case WM_PALETTECHANGED:
      if ((HWND)wParam != hDlg)
          InvalidateRect(hDlg, NULL, TRUE);
      break;

   case WM_PAINT:
      // different paint cases for icon and window
      if (IsIconic(hDlg))
         return (FALSE);

      hdc = BeginPaint(hDlg, &ps);
      // repaint the preview area with current theme
      PaintPreview(hDlg, hdc, &rView);
      // paint recessed edge around preview area
      DrawEdge(hdc, (LPRECT)&rView, EDGE_SUNKEN, BF_RECT);
      EndPaint(hDlg, &ps);
      break;

   case WM_COMMAND:
      return(FrostCommand(hDlg, wParam, lParam)); // process and ret EXIT
      break;

   case WM_CLOSE:
      // do the same things you do on Cancel
      FrostCommand(hDlg, MAKEWPARAM(IDCANCEL, 0), (LPARAM)0);
      break;

   case WM_DESTROY:
      if ( gfCoInitDone )
         CoUninitialize();
      PostQuitMessage(0);
      break;

   case WM_HELP:
      lphi = (LPHELPINFO)lParam;

      if (lphi->iContextType == HELPINFO_WINDOW) {
         // All of the help topics are in PLUS!.HLP except for the
         // Rotate theme checkbox is in PLUS!98.HLP.

         if (lphi->iCtrlId == CB_SCHEDULE) {
            WinHelp(lphi->hItemHandle, (LPTSTR)szHelpFile98, HELP_WM_HELP,
                    (DWORD_PTR)((POPUP_HELP_ARRAY FAR *)phaMainWin));
         }
         else {
            WinHelp(lphi->hItemHandle, (LPTSTR)szHelpFile, HELP_WM_HELP,
                    (DWORD_PTR)((POPUP_HELP_ARRAY FAR *)phaMainWin));
         }
      }
      break;

   case WM_CONTEXTMENU:
      // first check for main dlg window
      if ((HWND)wParam == hDlg) {
         POINT ptTest;
         RECT rCurTest;      // cur screen coords of Preview area

         // inits
         ptTest.x = GET_X_LPARAM(lParam);
         ptTest.y = GET_Y_LPARAM(lParam);
         rCurTest = rView;
         MapWindowPoints(hDlg, NULL, (LPPOINT)&rCurTest, 2);

         // if it's a click in the preview area
         if (PtInRect((LPRECT)&rCurTest, ptTest)) {
            WinHelp(hDlg, (LPTSTR)szHelpFile, HELP_CONTEXTPOPUP,
                    (DWORD)IDH_THEME_PREVIEW);
            return (TRUE);
         }

      }

      {  // Scope for ptTest & rCurTest variables
         POINT ptTest;
         RECT rCurTest;      // cur screen coords of Preview area

         // inits
         ptTest.x = GET_X_LPARAM(lParam);
         ptTest.y = GET_Y_LPARAM(lParam);
         GetWindowRect(GetDlgItem(hDlg, CB_SCHEDULE), (LPRECT)&rCurTest);

         // If user right clicked in CB_SCHEDULE area we need to load
         // the help topic from PLUS!98.HLP -- otherwise it comes from
         // PLUS!.HLP
         if (PtInRect((LPRECT)&rCurTest, ptTest)) {
             WinHelp((HWND)wParam, (LPTSTR)szHelpFile98, HELP_CONTEXTMENU,
                     (DWORD_PTR)((POPUP_HELP_ARRAY FAR *)phaMainWin));
         }
         else {
             WinHelp((HWND)wParam, (LPTSTR)szHelpFile, HELP_CONTEXTMENU,
                     (DWORD_PTR)((POPUP_HELP_ARRAY FAR *)phaMainWin));
         }
      }  // End scope for ptTest & rCurTest variables

      break;

   default:
      return(FALSE);                    // didn't process message EXIT
      break;
   }

   return (TRUE);                     // did process message
}


// InitThemeDDL
//
// Inits or Re-Inits the theme drop-down listbox: clears and then
// fills the Theme drop-down listbox with the titles of the
// available themes in the CURRENT DIRECTORY as specified by global var.
//
// Uses: szCurDir[] to get directory to list
//       szCurThemeFile[] to tell whether to init selection
//       szCurThemeName[] to init selection if init'ing
//
//       Assumes you've already made sure that curdir\themename == themefile
//       is a legit, existing file.
//
// Returns: success of initialization

BOOL InitThemeDDL(HWND hdlg)
{
   int iret;
   HWND hDDL;
   WIN32_FIND_DATA wfdFind;
   HANDLE hFind;

   //
   // inits
   hDDL = GetDlgItem(hdlg, DDL_THEME);

   // first get the directory for .THM files
   lstrcpy((LPTSTR)szMsg, (LPTSTR)szCurDir);
   lstrcat((LPTSTR)szMsg, (LPTSTR)TEXT("*"));
   lstrcat((LPTSTR)szMsg, (LPTSTR)szExt);

   //
   // Use FindFirstFile, FindNextFile, FindClose to enum THM files
   // and add each (cleaned-up) string to DDL

   // start find process
   hFind = FindFirstFile((LPCTSTR)szMsg, (LPWIN32_FIND_DATA)&wfdFind);

   #ifdef DEBUG
   //
   // hack so we can find files when debuging...
   //
   if (INVALID_HANDLE_VALUE == hFind) {
       lstrcpy(szThemeDir, TEXT("c:\\Program Files\\Plus!\\Themes\\"));
       lstrcpy(szMsg, szThemeDir);
       lstrcat(szMsg, TEXT("*"));
       lstrcat(szMsg, szExt);
       hFind = FindFirstFile((LPCTSTR)szMsg, (LPWIN32_FIND_DATA)&wfdFind);
   }
   #endif

   // if that got you a valid search handle and first file
   if (INVALID_HANDLE_VALUE != hFind) {

      // add each long filename string to ddl without extension
      do {
         // copy filename to buffer
         lstrcpy((LPTSTR)szMsg, (LPTSTR)wfdFind.cFileName);
         // remove extension
         TruncateExt((LPCTSTR)szMsg);
         // add to ddl
         iret = (int) SendMessage(hDDL, CB_ADDSTRING,
                                  (WPARAM)0, (LPARAM)(LPCTSTR)szMsg);
         if (iret == CB_ERRSPACE) {
            FindClose(hFind);
            return (FALSE);         // prob low mem EXIT
         }
      }
      // get next file
      while (FindNextFile(hFind,(LPWIN32_FIND_DATA)&wfdFind));

      // just checking: only reason to fail is out of files?
      Assert(ERROR_NO_MORE_FILES == GetLastError(), TEXT("wrong error on FindNextFile() out of files\n"));

      // cleanup file search
      FindClose(hFind);
   }
   // else no THM files in that dir: just continue
   else {
      Assert(FALSE, TEXT("FindFirstFile() ret INVALID_HANDLE_VALUE: no THM files?\n"));
   }

   //
   // add init string to beginning of DDLbox: Current Windows Settings
   // note that INSERTSTRING doesn't force resort of list
   iret = (int) SendMessage(hDDL, CB_INSERTSTRING,
                            (WPARAM)0, (LPARAM)(LPCTSTR)szCurSettings);
   if (iret == CB_ERRSPACE) return (FALSE);// prob low mem EXIT

   //
   // add second string iff you've already applied something to _have_
   // a previous Windows settings
   if (bAppliedOnce) {
      iret = (int) SendMessage(hDDL, CB_INSERTSTRING,
                              (WPARAM)1, (LPARAM)(LPCTSTR)szPrevSettings);
      if (iret == CB_ERRSPACE) return (FALSE);// prob low mem EXIT
   }

   //
   // add final string: Other...
   iret = (int) SendMessage(hDDL, CB_INSERTSTRING,
                            (WPARAM)-1,   // end of list
                            (LPARAM)(LPCTSTR)szOther);
   if (iret == CB_ERRSPACE) return (FALSE);// prob low mem EXIT


   //
   // cleanup

   // if "last theme applied" or first in new dir, it's already in global
   if (bThemed) {
      // look for cur theme name
      iCurTheme = (int)SendMessage(hDDL, CB_FINDSTRINGEXACT,
                              (WPARAM) -1, /* start of list */
                              (LPARAM)(LPCTSTR)szCurThemeName);
      if (CB_ERR ==  iCurTheme) {
         // shouldn't ever happen!! made sure file existed before setting globals
         Assert(0, TEXT("couldn't find cur theme name in ddl list we just made!\n"));
         iCurTheme = 0;
         lstrcpy((LPTSTR)szCurThemeFile, (LPTSTR)szNULL);
         lstrcpy((LPTSTR)szCurThemeName, (LPTSTR)szCurSettings);
      }
   }
   else {
      // select first item (CurWinSettings)
      iCurTheme = 0;
      lstrcpy((LPTSTR)szCurThemeFile, (LPTSTR)szNULL);      // no cur THM file
      lstrcpy((LPTSTR)szCurThemeName, (LPTSTR)szCurSettings);
   }

   // select cur theme name
   SendMessage(hDDL, CB_SETCURSEL, (WPARAM)iCurTheme, (LPARAM)0);

   // dis/enable checkboxes/buttons for initial conditions
   EnableThemeButtons();
   RestoreCheckboxes();
   // (checkboxes don't work here, so called after ret from Inits)

   // keep track of what you did and leave
   iThemeCount = (int)SendMessage(hDDL, CB_GETCOUNT, (WPARAM)0, (LPARAM)0);
   return (TRUE);
}

//
// ResetTheThemeWorld
//
// With either the Other... selection from a new dir or with the SaveAs...
// to a new dir, you have to reset the globals for files and dirs and
// refresh the main window drop-down listbox. Do it all here.
//
// Input: full pathname of proposed new theme file.
//        Normal assumption is that this has been checked to exist and
//        be a legit theme file.
//
// Returns: BOOL success -- should always be TRUE
//          FALSE is a VERY dire situation, means you're screwed
//                and cannot do the basic reset for the app main window...
//
BOOL ResetTheThemeWorld(LPTSTR lpszNewThemeFile)
{
   TCHAR szPrevFile[MAX_PATHLEN+1];

   // inits
   lstrcpy(szPrevFile, szCurThemeFile);   // save for error case below

   // reset globals for dir and file
   lstrcpy(szCurThemeFile, lpszNewThemeFile);
   lstrcpy(szCurDir, lpszNewThemeFile);
   *(FileFromPath(szCurDir)) = 0;
   lstrcpy(szCurThemeName, FileFromPath(lpszNewThemeFile));
   TruncateExt(szCurThemeName);

   // empty drop-down listbox
   SendDlgItemMessage(hWndApp, DDL_THEME, CB_RESETCONTENT, 0L, 0L);

   // refill drop-down listbox and select new file
   if (!InitThemeDDL(hWndApp)) {
      // low mem or very unusual error case

      // post low-mem message
      NoMemMsg(STR_TO_LIST);

      // try to recover by going back to prev dir and theme
      lstrcpy(szCurThemeFile, szPrevFile);
      lstrcpy(szCurDir, szPrevFile);
      *(FileFromPath(szCurDir)) = 0;
      lstrcpy(szCurThemeName, FileFromPath(szPrevFile));
      TruncateExt(szCurThemeName);

      // go for it again
      if (!InitThemeDDL(hWndApp)) {

         // Very, very, very bad news.
         // No way to do the basic initialization of the main window...

         return (FALSE);            // APOCALYPSE NOW EXIT

      }
   }

   return (TRUE);
}

// FrostCommand
//
// Main application (dialog) window control messages
//

BOOL FrostCommand(HWND hdlg, WPARAM wParam, LPARAM lParam)
{
   INT_PTR iDlgRet;
   int index;
   BOOL bRet;
   int iPrevTheme;
   extern TCHAR szFrostSection[], szMagic[], szVerify[], szThemeBPP[];
   int iThemeBPP, iSysBPP;
   HDC hdc;
   static int sIndex = CB_ERR;
   static BOOL bChosen = TRUE;
   static BOOL bCanceled = FALSE;
   BOOL bChangeTheme = FALSE;
   TCHAR szThemesExe[MAX_PATH];     // Fully qualified path to Themes.exe

   switch ((int)LOWORD(wParam)) {

   case DDL_THEME:

         // The following abomination is here, to trick the combo box into working
         // in semi-intelligent way.  The problem is, there is no consistancy in the
         // ordering of CBN_SELCHANGE messages and CBN_SELENDOK messages.  This supplies
         // the proper functionality in most cases.
      switch (HIWORD(wParam))
      {
         case CBN_SELCHANGE:
               // User may have "chosen" a theme, or he/she might just be
               // cursoring passed this selection.  This decision is based on
               // whether we have seen a CBN_SELENDOK message yet.
            sIndex = (int)SendMessage((HWND)(LOWORD(lParam)), CB_GETCURSEL, (WPARAM)0, (LPARAM)0);
            if (bChosen == TRUE && bCanceled == FALSE)
            {
               bChangeTheme = TRUE;
            }
            break;
         case CBN_DROPDOWN:
                // When the list is first dropped down, init all flags
            bChosen = FALSE;
            bCanceled = FALSE;
            bChangeTheme = FALSE;
            sIndex = CB_ERR;
            break;
         case CBN_SELENDOK:
               // The user has "chosen" a selection, if we have already recieved a
               // CBN_SELCHANGE notification, assume that this is a chosen theme.
            bChosen = TRUE;
            if (sIndex != CB_ERR && sIndex != iCurTheme)
            {
               bChangeTheme = TRUE;
            }
            break;
         case CBN_SELENDCANCEL:
               // The user has "canceled" the selection of a theme.
            bChosen = FALSE;
            bCanceled = TRUE;
            bChangeTheme = FALSE;
               // Pretty soon we are going to recieve a CBN_SELCHANGE notification,
               // that needs to be undone.  This postevent will handle that.
            PostMessage((HWND)(LOWORD(lParam)), CB_SETCURSEL, (WPARAM)iCurTheme, (LPARAM)0);
            break;
      }

      if (bChangeTheme) {
         index = sIndex;
         bChangeTheme = FALSE;
         iPrevTheme = iCurTheme;
         iCurTheme = index;
         bNewSelection = TRUE;

         // meddle w/ cursor
         WaitCursor();

         //
         // action depends on selection
         // Four cases: Cur Win Settings, Prev Win Settings, Other... and normal.

         //
         // Current Windows settings case
         if (index == 0) {
            // clear pointer to cur file
            lstrcpy((LPTSTR)szCurThemeFile, (LPTSTR)szNULL);   // no cur THM file
            lstrcpy((LPTSTR)szCurThemeName, (LPTSTR)szCurSettings);
         }

         //
         // Previous Windows settings case
         else if ((index == 1) && bAppliedOnce) {
            // create full pathname of prev settings file
            lstrcpy(szCurThemeFile, szThemeDir);
            lstrcat(szCurThemeFile, szPrevSettingsFilename);
            // use false name
            lstrcpy((LPTSTR)szCurThemeName, (LPTSTR)szPrevSettings);
         }

         //
         // Other... case
         else if (index == iThemeCount-1) {

            OPENFILENAME ofnOpen;
            TCHAR szOpenFile[MAX_PATHLEN+1];

            // save away those checkboxes
            if (bThemed)
               SaveCheckboxes();

            do {
               // inits
               lstrcpy(szOpenFile, TEXT("*"));  // start w/ *.Theme
               lstrcat(szOpenFile, szExt);

               ofnOpen.lStructSize = sizeof(OPENFILENAME);
               ofnOpen.hwndOwner = hdlg;
               ofnOpen.lpstrFilter = szFileTypeDesc;
               ofnOpen.lpstrCustomFilter = (LPTSTR)NULL;
               ofnOpen.nMaxCustFilter = 0;
               ofnOpen.nFilterIndex = 1;
               ofnOpen.lpstrFile = szOpenFile;
               ofnOpen.nMaxFile = ARRAYSIZE(szOpenFile);
               ofnOpen.lpstrFileTitle = (LPTSTR)NULL; // szFileTitle;
               ofnOpen.nMaxFileTitle = 0;             // sizeof(szFileTitle);
               ofnOpen.lpstrInitialDir = (LPTSTR)szCurDir;
               ofnOpen.lpstrTitle = (LPTSTR)szOpenTitle;
               ofnOpen.Flags = OFN_PATHMUSTEXIST |
                              OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
               #ifdef USECALLBACKS
               ofnOpen.Flags = OFN_PATHMUSTEXIST |
                              OFN_ENABLEHOOK | OFN_FILEMUSTEXIST;
               ofnOpen.lpfnHook = FileOpenHookProc;
               #endif
               ofnOpen.lpstrDefExt = CharNext((LPTSTR)szExt);

               // call common dlg
               if (!GetOpenFileName((LPOPENFILENAME)&ofnOpen)) {

                  // if they didn't open a file, could be hit cancel but
                  // also check for lowmem return

                  iDlgRet = (int)CommDlgExtendedError();
                  if ((iDlgRet == CDERR_INITIALIZATION) ||
                     (iDlgRet == CDERR_MEMALLOCFAILURE) ||
                     (iDlgRet == CDERR_MEMLOCKFAILURE)
                     )
                     NoMemMsg(STR_TO_LIST);

                  // revert to prev entry
                  iCurTheme = iPrevTheme;
                  // select old theme in list
                  SendMessage((HWND)(LOWORD(lParam)), CB_SETCURSEL,
                              (WPARAM)iCurTheme, (LPARAM)(LPCTSTR)NULL);

                  // get out of this whole line of thought now
                  return (TRUE);    // no new file/dir to open EXIT
               }

               // get results and check that it is a valid theme file
               if (!IsValidThemeFile(szOpenFile)) {
                  TCHAR szTemp[MAX_MSGLEN+1];

                  // bad file: post msg before going back to common open
                  LoadString(hInstApp, STR_ERRBADOPEN, (LPTSTR)szTemp, MAX_MSGLEN);
                  wsprintf((LPTSTR)szMsg, (LPTSTR)szTemp, (LPTSTR)szOpenFile);
                  MessageBox((HWND)hWndApp, (LPTSTR)szMsg, (LPTSTR)szAppName,
                        MB_OK | MB_ICONERROR | MB_APPLMODAL);
               }
            }
            while (!IsValidThemeFile(szOpenFile));

            // now reset the DDL with new dir listing and select new file
            if (!ResetTheThemeWorld((LPTSTR)szOpenFile)) {

               // prob low mem on adding strs to combobox
               DestroyWindow(hdlg);

               break;               // APOCALYPSE NOW EXIT
            }

         }  // end Other... case

         //
         // normal theme selection case
         else {                  // NOT cur Windows settings

            // get new cur theme name and file and construct filename
            SendMessage((HWND)(LOWORD(lParam)), CB_GETLBTEXT, (WPARAM)index,
                        (LPARAM)(LPCTSTR)szCurThemeName );
            lstrcpy((LPTSTR)szCurThemeFile, (LPTSTR)szCurDir);
            lstrcat((LPTSTR)szCurThemeFile, (LPTSTR)szCurThemeName);
            lstrcat((LPTSTR)szCurThemeFile, (LPTSTR)szExt);

            //
            // check that new theme file is valid theme file by looking for magic str
            if (!IsValidThemeFile((LPTSTR)szCurThemeFile)) {   // magic str check
               //
               // NOT a valid theme file with the correct magic string!
               //
               TCHAR szTemp[MAX_MSGLEN+1];

               // post an error message
               LoadString(hInstApp, STR_ERRBADTHEME, (LPTSTR)szTemp, MAX_MSGLEN);
               wsprintf((LPTSTR)szMsg, (LPTSTR)szTemp, (LPTSTR)szCurThemeFile);
               MessageBox((HWND)hWndApp, (LPTSTR)szMsg, (LPTSTR)szAppName,
                     MB_OK | MB_ICONERROR | MB_APPLMODAL);

               // remove entry from list
               SendMessage((HWND)(LOWORD(lParam)), CB_DELETESTRING,
                           (WPARAM)index, (LPARAM)(LPCTSTR)NULL);
               // get new theme count; ask rather than decrement -- for failsafe
               iThemeCount = (int) SendMessage((HWND)(LOWORD(lParam)),
                                               CB_GETCOUNT, (WPARAM)0, (LPARAM)0);

               //
               // revert to prev entry
               iCurTheme = iPrevTheme;
               if (index < iPrevTheme) iCurTheme--;

               // get back old cur file and filename
               lstrcpy((LPTSTR)szCurThemeFile, (LPTSTR)szCurDir);
               SendMessage((HWND)(LOWORD(lParam)), CB_GETLBTEXT, (WPARAM)iCurTheme,
                           (LPARAM)(LPCTSTR)(szCurThemeFile +
                                          lstrlen((LPTSTR)szCurThemeFile)) );
               lstrcat((LPTSTR)szCurThemeFile, (LPTSTR)szExt);

               // select old theme in list
               SendMessage((HWND)(LOWORD(lParam)), CB_SETCURSEL,
                           (WPARAM)iCurTheme, (LPARAM)(LPCTSTR)NULL);

               // bad file selection didn't take EXIT
               NormalCursor();
               break;
            }

         }

         //
         // reset preview to new theme (or cur win settings if null)
         BuildPreviewBitmap((LPTSTR)szCurThemeFile);

         // dis/enable buttons and checkboxes from new global THM file
         EnableThemeButtons();

         // update preview title
         NewSampleTitle();

         // cleanup
         NormalCursor();
      }
      else
         return (FALSE);         // didn't process message EXIT
      break;

   case PB_SAVE:

      #ifdef REVERT
      iDlgRet = DialogBox(hInstApp, MAKEINTRESOURCE(DLG_SAVE), hWndApp, SaveAsDlgProc);
      if (iDlgRet == -1)
         NoMemMsg(STR_TO_SAVE);
      #endif


      // do the save inline here with common dlg
      {
         OPENFILENAME ofnSave;
         TCHAR szSavedFile[MAX_PATHLEN+1];
         LPTSTR lpszTempExt;
         extern BOOL bReadOK, bWroteOK;
         BOOL fFilenameOk;

         // inits

         do
         {
            fFilenameOk = TRUE;
            lstrcpy((LPTSTR)szSavedFile, (LPTSTR)szNewFile);  // start w/ suggested name

            ofnSave.lStructSize = sizeof(OPENFILENAME);
            ofnSave.hwndOwner = hdlg;
            ofnSave.lpstrFilter = szFileTypeDesc;
            ofnSave.lpstrCustomFilter = (LPTSTR)NULL;
            ofnSave.nMaxCustFilter = 0;
            ofnSave.nFilterIndex = 1;
            ofnSave.lpstrFile = szSavedFile;
            ofnSave.nMaxFile = ARRAYSIZE(szSavedFile);
            ofnSave.lpstrFileTitle = (LPTSTR)NULL;  // szFileTitle;
            ofnSave.nMaxFileTitle = 0;              // sizeof(szFileTitle);
            ofnSave.lpstrInitialDir = (LPTSTR)szCurDir;
            ofnSave.lpstrTitle = (LPTSTR)szSaveTitle;
            ofnSave.Flags = OFN_OVERWRITEPROMPT |
                            OFN_HIDEREADONLY;
            ofnSave.lpstrDefExt = CharNext((LPTSTR)szExt);

            // call common dlg
            if (!GetSaveFileName((LPOPENFILENAME)&ofnSave)) {
               // if they didn't save a file, check for lowmem return
               iDlgRet = (int)CommDlgExtendedError();
               if ((iDlgRet == CDERR_INITIALIZATION) ||
                   (iDlgRet == CDERR_MEMALLOCFAILURE) ||
                   (iDlgRet == CDERR_MEMLOCKFAILURE)
                  )
                  NoMemMsg(STR_TO_SAVE);

               return (TRUE);                  // no file to save EXIT
            }

            //
            // process new filename by saving theme to file

            // get new cur dir and set global
            // if different than cur cur dir, first refill listbox

            // enforce extension
            lpszTempExt = (LPTSTR)(szSavedFile + lstrlen((LPTSTR)szSavedFile)
                                  - lstrlen((LPTSTR)szExt));
            if (2 != CompareString( LOCALE_USER_DEFAULT,
                                    NORM_IGNOREWIDTH | NORM_IGNORECASE,
                                    lpszTempExt, lstrlen((LPTSTR)szExt),
                                    (LPTSTR)szExt, lstrlen((LPTSTR)szExt) )
               ) {

               // COMMON DLG BUG: since we have a 5-letter extension, we
               // sometimes get foo.theme and sometimes (if they type "foo")
               // get foo.the. Until that is fixed, here's a decent workaround.
               // Strips their ext if they say foo.txt, or foo.bar.

               // just get rid of vestigal other ext if any
               TruncateExt((LPCTSTR)szSavedFile);
               lstrcat((LPTSTR)szSavedFile, (LPTSTR)szExt);

               // Because the commond dlg does not handle 5-letter extensions
               // properly we need to verify that the file does not already exist
               // and if it does make sure the user really wants to overwrite it.
               if (FileSpecExists(szSavedFile))
               {
                  TCHAR szTitle[MAX_MSGLEN+1];
                  TCHAR szText[MAX_PATHLEN+MAX_MSGLEN+1];
                  TCHAR szTemp[MAX_MSGLEN+1];

                     // show the file name
                  LoadString(hInstApp, STR_SAVETITLE, szTitle, MAX_MSGLEN);
                  lstrcpy(szText, szSavedFile);

                     // Do you want to replace existing?
                  LoadString(hInstApp, STR_FILEEXISTS, szTemp, MAX_MSGLEN);
                  lstrcat(szText, szTemp);

                  if (IDYES != MessageBox(hdlg, szText, szTitle, MB_YESNO |
                                         MB_ICONEXCLAMATION | MB_DEFBUTTON2))
                  {
                     fFilenameOk = FALSE;
                  }
               }
            }
         } while (!fFilenameOk);

         // gather the current windows settings and save them to a THM file
         WaitCursor();
         GatherThemeToFile(szSavedFile);
         NormalCursor();

         if (!bWroteOK) {
            TCHAR szTemp[MAX_MSGLEN+1];

            // out of disk space or some weird file or disk problem
            // could be that most saved OK and just one or some a problem?

            LoadString(hInstApp, STR_ERRCANTSAVE, (LPTSTR)szTemp, MAX_MSGLEN);
            wsprintf((LPTSTR)szMsg, (LPTSTR)szTemp, (LPTSTR)FileFromPath(szSavedFile));
            MessageBox((HWND)hWndApp, (LPTSTR)szMsg, (LPTSTR)szAppName,
                        MB_OK | MB_ICONERROR | MB_APPLMODAL);

            break;                  // couldn't write to file somehow EXIT
         }

         //
         // OK, you have a full pathname of the file that you have
         // successfully saved.
         //
         // You need to look
         // at the directory that you saved it in and see if it is different
         // than the current directory. If it is, we need to do a whole
         // world change: clear out the combobox and refill it, then select
         // the new file. If the dir is the same (the common case), we just
         // need to select it carefully in the list and update a global or two.
         //

         // get new dir
         lstrcpy((LPTSTR)szMsg, (LPTSTR)szSavedFile);
         *(FileFromPath(szMsg)) = 0;

         // compare new dir to cur dir
         if (!lstrcmp(szMsg, szCurDir)) {

            //
            // Yes, you are still in the same dir as cur dir

            // clean up and add new filename to list in drop-down listbox
            lstrcpy((LPTSTR)szMsg, (LPTSTR)FileFromPath(szSavedFile));
            TruncateExt((LPCTSTR)szMsg);
            // check first if the same name is already there
            iDlgRet = (int) SendDlgItemMessage(hWndApp, DDL_THEME,
                                                      CB_FINDSTRINGEXACT,
                                                      (WPARAM) -1, /* start of list */
                                                      (LPARAM)(LPCTSTR)szMsg);
            if ((CB_ERR !=  iDlgRet) &&   // found the exact string!
                !((iDlgRet == 1) && bAppliedOnce) // don't delete 1-index PrevWinSettings
                && iDlgRet) {             // don't delete 0-index CurWinSettings
               // delete the previous
               SendDlgItemMessage(hWndApp, DDL_THEME, CB_DELETESTRING,
                                 (WPARAM)iDlgRet, (LPARAM)0);
               // get new theme count; ask rather than decrement -- for failsafe
               iThemeCount = (int) SendDlgItemMessage(hWndApp, DDL_THEME,
                                                      CB_GETCOUNT, (WPARAM)0, (LPARAM)0);
            }
            // do the add
            if (CB_ERRSPACE != (int) SendDlgItemMessage(hWndApp, DDL_THEME,
                                                      CB_INSERTSTRING,
                                                      // add before Other...
                                                      // always at least CurWinSet and Other...
                                                      // so iThemeCount always >= 2
                                                      (WPARAM) iThemeCount - 1,
                                                      (LPARAM)(LPCTSTR)szMsg) ) {

               // get new theme count; ask rather than increment -- for failsafe
               iThemeCount = (int) SendDlgItemMessage(hWndApp, DDL_THEME,
                                                      CB_GETCOUNT, (WPARAM)0, (LPARAM)0);

               // select item just added and save index of selection
               iCurTheme = iThemeCount-2; // one less than last 0-based item
               SendDlgItemMessage(hWndApp, DDL_THEME,
                                  CB_SETCURSEL, (WPARAM)iCurTheme, (LPARAM)0);

               // update cur Theme file name etc to your new one
               lstrcpy((LPTSTR)szCurThemeFile, (LPTSTR)szSavedFile);
               lstrcpy(szCurThemeName, FileFromPath(szCurThemeFile));
               TruncateExt(szCurThemeName);

               // update checkboxes
               EnableThemeButtons();

            }
            // else not enuf mem to add new name to DDL; no biggie - already saved
         }
         else {

            //
            // You are in a new dir that needs to be made the cur dir

            // now reset the DDL with new dir listing and select new file
            if (!ResetTheThemeWorld((LPTSTR)szSavedFile)) {

               // save away those checkboxes
               if (bThemed)
                  SaveCheckboxes();

               // You've cleared the list of themes but can't re-init it.
               // prob low mem on adding strs to combobox
               DestroyWindow(hdlg);

               break;               // APOCALYPSE NOW EXIT
            }
         }

         // (don't need to update preview, etc; was "cur settings" or prev same last)
      }  // end variable scope

      break;
   case PB_DELETE:
      {  // var scope
         TCHAR szTemp[MAX_MSGLEN+1];
         int iret;
         HWND hDDL;

         // confirm delete cur theme
         LoadString(hInstApp, STR_CONFIRM_DEL, (LPTSTR)szTemp, MAX_MSGLEN);
         wsprintf((LPTSTR)szMsg, (LPTSTR)szTemp, (LPTSTR)szCurThemeName);
         iret = MessageBox((HWND)hWndApp, (LPTSTR)szMsg, (LPTSTR)szAppName,
                           MB_YESNO | MB_ICONQUESTION | MB_APPLMODAL);

         // if they confirmed Yes, Do the evil deed
         if (iret == IDYES) {
            // do the file deletion
            iret = DeleteFile((LPTSTR)szCurThemeFile);

            // if successfully disposed of unwanted file
            if (iret) {
               // get dropdown lb
               hDDL = GetDlgItem(hWndApp, DDL_THEME);

               // remove name from dropdown lb
               SendMessage(hDDL, CB_DELETESTRING,
                           (WPARAM)iCurTheme, (LPARAM)(LPCTSTR)NULL);
               // get new theme count; ask rather than decrement -- for failsafe
               iThemeCount = (int) SendMessage(hDDL, CB_GETCOUNT, (WPARAM)0, (LPARAM)0);


               // select first in list: Cur Win Settings
               SendMessage(hDDL, CB_SETCURSEL, (WPARAM)0, (LPARAM)(LPCTSTR)NULL);
               iCurTheme = 0;

               // recurse to catch updated selection
               SendMessage(hWndApp, WM_COMMAND, MAKEWPARAM(DDL_THEME, CBN_SELENDOK),
                           MAKELPARAM(hDDL, 0));
            }
            // otherwise, inform them that the file was too strong to kill
            else {
               LoadString(hInstApp, STR_ERRCANTDEL, (LPTSTR)szTemp, MAX_MSGLEN);
               wsprintf((LPTSTR)szMsg, (LPTSTR)szTemp, (LPTSTR)szCurThemeName);
               MessageBox((HWND)hWndApp, (LPTSTR)szMsg, (LPTSTR)szAppName,
                     MB_OK | MB_ICONERROR | MB_APPLMODAL);
            }
         }

      }  // var scope
      break;

   case PB_SCRSVR:
      {  // var scope
         extern TCHAR szSS_Section[];
         extern TCHAR szSS_Key[];
         extern TCHAR szSS_File[];
         extern TCHAR szCP_DT[];
         extern TCHAR szSS_Active[];
         BOOL bScrSaveActive = FALSE;
         STARTUPINFO StartupInfo;
         PROCESS_INFORMATION ProcessInformation;


         // first check if the scr saver is active
         if (bThemed) {              // get from theme
            TCHAR szSSName[MAX_MSGLEN+1];
            GetPrivateProfileString((LPTSTR)szSS_Section, (LPTSTR)szSS_Key,
                                    (LPTSTR)szNULL,
                                    (LPTSTR)szSSName, MAX_MSGLEN,
                                    (LPTSTR)szCurThemeFile);
            if (*szSSName != TEXT('\0'))
               bScrSaveActive = TRUE;
         }
         else                       // get from cur system settings
            SystemParametersInfo(SPI_GETSCREENSAVEACTIVE, 0,
                                 (LPVOID)&bScrSaveActive, FALSE);

         // then continue if active
         if (bScrSaveActive) {

            // get the theme
            if (bThemed) {             // get from cur theme file
               GetPrivateProfileString((LPTSTR)szSS_Section, (LPTSTR)szSS_Key,
                                       (LPTSTR)szNULL,
                                       (LPTSTR)szMsg, MAX_MSGLEN,
                                       (LPTSTR)szCurThemeFile);
               // expand filename string as necessary
               InstantiatePath((LPTSTR)szMsg, MAX_MSGLEN);
               // search for file if necessary
               ConfirmFile((LPTSTR)szMsg, TRUE);
               // in this case, if not found shouldn't be here; and just
               // won't run below. still need to search, with replacement
            }
            else {                     // get from system
               GetPrivateProfileString((LPTSTR)szSS_Section, (LPTSTR)szSS_Key,
                                       (LPTSTR)szNULL,
                                       (LPTSTR)szMsg, MAX_MSGLEN,
                                       (LPTSTR)szSS_File);
            }

            // run it now!
            wsprintf(pValue,TEXT("%s /s"), (LPTSTR)szMsg);
            // WinExec(pValue, SW_NORMAL);
            ZeroMemory(&StartupInfo, sizeof(StartupInfo));
            StartupInfo.cb = sizeof(StartupInfo);
            StartupInfo.dwFlags = STARTF_USESHOWWINDOW;
            StartupInfo.wShowWindow = (WORD)SW_NORMAL;

            CreateProcess(NULL,
                          pValue,
                          NULL,
                          NULL,
                          FALSE,
                          0,
                          NULL,
                          NULL,
                          &StartupInfo,
                          &ProcessInformation);
         }
         else {
            Assert(0, TEXT("Got scrsaver button push with no active scrsaver!\n"));
         }
      }  // var scope
      break;

   case PB_POINTERS:
      iDlgRet = DoEtcDlgs(hdlg);
      if (!iDlgRet)
         NoMemMsg(STR_TO_PREVIEW);
      break;

   //
   // check boxes are auto, but need to update preview and Apply button dep on cb states

   case CB_SCHEDULE:
   // Flag that SCHEDULE checkbox changed so Apply gets activated.
      // get controlling checkboxes' current states in bCBStates[]
      SaveCheckboxes();
      // Set the SCHEDULE changed flag.
      bCB_SchedChange = TRUE;
      // Enable the Apply button if appropriate.
      if (bCB_SchedChange) EnableWindow(GetDlgItem(hWndApp, PB_APPLY), TRUE);
      break;

   // these checkboxes affect the "live" preview
   case CB_WALL    :
   case CB_ICONS   :
   case CB_COLORS  :
   case CB_FONTS   :
   case CB_BORDERS :
      // get controlling checkboxes' current states in bCBStates[]
      SaveCheckboxes();
      // force new repaint with diff checkboxes
      BuildPreviewBitmap((LPTSTR)szCurThemeFile);

      // fall through for all-checkbox processing

   case CB_SCRSVR  :
   case CB_SOUND   :
   case CB_PTRS    :
//   case CB_ICONSIZE:
      // apply button only enabled if at least one checkbox is checked
      // Note that IsAnyBoxChecked() ignores CB_SCHEDULE.
      EnableWindow(GetDlgItem(hWndApp, PB_APPLY), IsAnyBoxChecked());

      // new checkbox lineup counts as something new
      bNewSelection = TRUE;
      break;

   case IDOK:
      // PLUS98 BUG 1093
      // If we're in a graphics filter we want to ignore this button
      // press -- processing it will fault.
      if (bInGrphFilter) return (FALSE);
      // Has the user toggled the SCHEDULE checkbox?
      // Note this code is duplicated in the PB_APPLY section below.
      if (bCB_SchedChange) {
         if (bCBStates[FC_SCHEDULE]) {
            // We need to add the Themes task to Task Scheduler.  Check
            // to see if TS is running.
            if (!IsTaskSchedulerRunning()) {
               // TS isn't running, so start it.
               if (!StartTaskScheduler(TRUE /*prompt user*/)) {
                  // Task Scheduler failed to start or the user opted
                  // to not start it. STS() already gave an error but
                  // we need to uncheck the SCHEDULE cb.
                  CheckDlgButton(hdlg, CB_SCHEDULE, BST_UNCHECKED);
                  SaveCheckboxes();
               }
               // Task Scheduler started so add Themes task if it doesn't
               // already exist
               else if (!IsThemesScheduled()) {
                  GetModuleFileName(hInstApp, (LPTSTR)szThemesExe, MAX_PATH);
                  if (!AddThemesTask(szThemesExe, TRUE /*Show errors*/)) {
                     //An error occurred adding the task. ATT() already gave
                     //user an error.  Clear and save CB_SCHEDULE;
                     CheckDlgButton(hdlg, CB_SCHEDULE, BST_UNCHECKED);
                     SaveCheckboxes();
                  }
                  // Assume Themes task was added OK
               }
               // Themes.job is already there, so do nothing
            }

            // Assume TS is already running so add our monthly task
            else if (!IsThemesScheduled()) {
               GetModuleFileName(hInstApp, (LPTSTR)szThemesExe, MAX_PATH);
               if (!AddThemesTask(szThemesExe, TRUE /*Show errors*/)) {
                  //An error occurred adding the task. ATT() already gave
                  //user an error.  Clear and save CB_SCHEDULE;
                  CheckDlgButton(hdlg, CB_SCHEDULE, BST_UNCHECKED);
                  SaveCheckboxes();
               }
               // Assume Themes task was added OK
            }
            // else Themes.job is already there, so do nothing
         }

         // Gotta delete Themes.job but if TS ain't runnin' we can't do that
         // through the TS api.
         else {
           if (IsTaskSchedulerRunning()) DeleteThemesTask();
           else HandDeleteThemesTask();
         }
         bCB_SchedChange = FALSE;
      } // Endif bCB_SchedChange

      // check if anything new since last Apply
      if (!bNewSelection)
         goto NoApplyNeeded;
      // else continue with the apply
   case PB_APPLY:
      // PLUS98 BUG 1093
      // If we're in a graphics filter we want to ignore this button
      // press -- processing it will fault.
      if (bInGrphFilter) return FALSE;
      // Has the user toggled the SCHEDULE checkbox?
      // Note this code is duplicated in the IDOK section above.
      if (bCB_SchedChange) {
         if (bCBStates[FC_SCHEDULE]) {
            // We need to add the Themes task to Task Scheduler.  Check
            // to see if TS is running.
            if (!IsTaskSchedulerRunning()) {
               // TS isn't running, so start it.
               if (!StartTaskScheduler(TRUE /*prompt user*/)) {
                  // Task Scheduler failed to start or the user opted
                  // to not start it. STS() already gave an error but
                  // we need to uncheck the SCHEDULE cb.
                  CheckDlgButton(hdlg, CB_SCHEDULE, BST_UNCHECKED);
                  SaveCheckboxes();
               }
               // Task Scheduler started so add Themes task if it doesn't
               // already exist
               else if (!IsThemesScheduled()) {
                  GetModuleFileName(hInstApp, (LPTSTR)szThemesExe, MAX_PATH);
                  if (!AddThemesTask(szThemesExe, TRUE /*Show errors*/)) {
                     //An error occurred adding the task. ATT() already gave
                     //user an error.  Clear and save CB_SCHEDULE;
                     CheckDlgButton(hdlg, CB_SCHEDULE, BST_UNCHECKED);
                     SaveCheckboxes();
                  }
                  // Assume Themes task was added OK
               }
               // Themes.job is already there, so do nothing
            }

            // Assume TS is already running so add our monthly task
            else if (!IsThemesScheduled()) {
               GetModuleFileName(hInstApp, (LPTSTR)szThemesExe, MAX_PATH);
               if (!AddThemesTask(szThemesExe, TRUE /*Show errors*/)) {
                  //An error occurred adding the task. ATT() already gave
                  //user an error.  Clear and save CB_SCHEDULE;
                  CheckDlgButton(hdlg, CB_SCHEDULE, BST_UNCHECKED);
                  SaveCheckboxes();
               }
               // Assume Themes task was added OK
            }
            // else Themes.job is already there, so do nothing
         }

         // Gotta delete Themes.job but if TS ain't runnin' we can't do that
         // through the TS api.
         else {
           if (IsTaskSchedulerRunning()) DeleteThemesTask();
           else HandDeleteThemesTask();
         }
         bCB_SchedChange = FALSE;
      } // Endif bCB_SchedChange

      // if there is a theme selected, apply it now
      if (bThemed) {

            // Make sure there is even enough space to do theme
            // Complain, if there is a problem
         if (! CheckSpace (hdlg, TRUE))   // definition in Regutils.c
            break;

         //
         // first, check whether there is a problem with the theme bit depth

         // check for theme BPP vs. system, saved to global bool
         iThemeBPP = GetPrivateProfileInt((LPTSTR)szFrostSection, (LPTSTR)szThemeBPP,
                                          0, (LPTSTR)szCurThemeFile);
         hdc = GetDC(NULL);
         iSysBPP = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);
         ReleaseDC(NULL, hdc);
         bLowColorProblem = iThemeBPP > iSysBPP;

         // if there is a potential problem, then ask what to do first
         if (bLowColorProblem && !bNeverCheckBPP &&
            ( IsDlgButtonChecked(hdlg, CB_ICONS) ||
               IsDlgButtonChecked(hdlg, CB_COLORS) ) ) {
            iDlgRet = DialogBox(hInstApp, MAKEINTRESOURCE(DLG_BPPCHOICE), hWndApp, BPP_ChoiceDlg);
            if (iDlgRet == -1) {
               NoMemMsg(STR_TO_APPLY);
               break;                     // low mem EXIT
            }

            if (iDlgRet == IDCANCEL) {
               break;                     // user chicken EXIT
            }
         }

         // meddle w/ cursor
         WaitCursor();

         // check if color-depth problem and they asked for nothing applied
         if (bLowColorProblem && (fLowBPPFilter == APPLY_NONE))
            break;                  // chickened out completely no work EXIT

         // get controlling checkboxes' current states in bCBStates[]
         SaveCheckboxes();

         // Now, see if color-depth problem and they asked for just some applied
         if (bLowColorProblem && (fLowBPPFilter == APPLY_SOME)) {
            // apply filter
            bCBStates[FC_PTRS] = FALSE;
            bCBStates[FC_ICONS] = FALSE;
            bCBStates[FC_COLORS] = FALSE;
            RestoreCheckboxes();
         }


         //
         // OK, you're really going to Apply. If this is your first,
         // then save a memory of your virginal state, for user to
         // savor later if desired.
         if (!bAppliedOnce) {
            TCHAR szPrevThemePath[MAX_PATHLEN+1];
            extern BOOL bWroteOK;
            INT_PTR iret;

            // create full pathname of temp file for orig settings
            lstrcpy(szPrevThemePath, szThemeDir);
            lstrcat(szPrevThemePath, szPrevSettingsFilename);

            // save a theme with original windows settings
            GatherThemeToFile(szPrevThemePath);

            // if saved OK
            if (bWroteOK) {
               // add an item to the list for it
               iret = SendDlgItemMessage(hdlg, DDL_THEME, CB_INSERTSTRING,
                                   (WPARAM)1, (LPARAM)(LPCTSTR)szPrevSettings);

               if (iret != CB_ERRSPACE) {
                  // don't care if you actually _apply_ OK; you've added the item
                  bAppliedOnce = TRUE;

                  // get new ddl index for our current theme
                  iCurTheme = (int)SendDlgItemMessage(hWndApp, DDL_THEME,
                              CB_FINDSTRINGEXACT, (WPARAM)-1, /* start of list */
                              (LPARAM)(LPCTSTR)szCurThemeName);

                  // get new theme count; ask rather than increment -- for failsafe
                  iThemeCount = (int) SendDlgItemMessage(hWndApp, DDL_THEME,
                                         CB_GETCOUNT, (WPARAM)0, (LPARAM)0);

               }
               // else you couldn't add, just don't get this feature

            }
            // else you never get a prev win settings item this session...
         }

         //
         // apply settings from cur theme file to registry/system
         bRet = ApplyThemeFile((LPTSTR)szCurThemeFile);

         // restore cursor
         NormalCursor();

         // check whether there was any problem applying the theme
         if (!bRet) {

            #if 0       // DavidBa decided it was too irksome to post err to user 4/17/95
            TCHAR szErrStr[MAX_MSGLEN+1];
            TCHAR szFileDispStr[MAX_MSGLEN+1];

            // tell the user there was a problem; but we did our best; keep on trucking
            LoadString(hInstApp, STR_ERRAPPLY, (LPTSTR)szErrStr, MAX_MSGLEN);
            lstrcpy((LPTSTR)szFileDispStr, (LPTSTR)szCurThemeFile);
            TruncateExt((LPTSTR)szFileDispStr);
            wsprintf((LPTSTR)szMsg, (LPTSTR)szErrStr, FileFromPath((LPTSTR)szFileDispStr));
            MessageBox((HWND)hWndApp, (LPTSTR)szMsg, (LPTSTR)szAppName,
                     MB_OK | MB_ICONWARNING | MB_APPLMODAL);
            #endif
         }

         // save theme file to "last applied" slot in registry

         if (!((iCurTheme == 1) && bAppliedOnce))  {  // don't save PrevWinSettings
            LONG lret;
            HKEY hKey;
            extern TCHAR szPlus_CurTheme[];

            lret = RegOpenKeyEx(HKEY_CURRENT_USER, szPlus_CurTheme,
                              (DWORD)0, KEY_SET_VALUE, (PHKEY)&hKey );
            if (lret != ERROR_SUCCESS) {
               DWORD dwDisposition;
               Assert(FALSE, TEXT("couldn't RegOpenKey save theme file\n"));
               lret = RegCreateKeyEx( HKEY_CURRENT_USER, szPlus_CurTheme,
                                    (DWORD)0, (LPTSTR)szNULL, REG_OPTION_NON_VOLATILE,
                                    KEY_SET_VALUE, (LPSECURITY_ATTRIBUTES)NULL,
                                    (PHKEY)&hKey, (LPDWORD)&dwDisposition );
            }
            // if open or create worked
            if (lret == ERROR_SUCCESS) {
               lret = RegSetValueEx(hKey, (LPTSTR)NULL, // default value
                                    0,
                                    (DWORD)REG_SZ,
                                    (LPBYTE)szCurThemeFile,
                                    (DWORD)( SZSIZEINBYTES((LPTSTR)szCurThemeFile) + 1 ));
               RegCloseKey(hKey);
            }

            Assert(lret == ERROR_SUCCESS, TEXT("couldn't open, set or create Registry save theme file\n"));

         }  // end if not prev settings case

         // reset dirty/etc flags
         bNewSelection = FALSE;

      }  // end if bThemed

      SaveStates();                 // remember things to registry
      // OK falls through, Apply doesn't
      if ((int)LOWORD(wParam) == PB_APPLY) {
         // Gray the Apply button & make it so it's not the Default button
         EnableWindow(GetDlgItem(hWndApp, PB_APPLY), FALSE);
         SendDlgItemMessage(hWndApp, PB_APPLY, BM_SETSTYLE, (WPARAM)BS_PUSHBUTTON, MAKELPARAM(TRUE,0));
         // Set Focus to the OK button
         SetFocus(GetDlgItem(hWndApp, IDOK));
         // Make the OK button the Default button
         SendMessage(hWndApp, DM_SETDEFID, IDOK, 0);
         break;      // just apply and then EXIT without closing
      }
      // else fall through (from IDOK)
   case IDCANCEL:
      // PLUS98 BUG 1093
      // If we're in a graphics filter we want to ignore this button
      // press -- processing it will fault.
      if (bInGrphFilter) return FALSE;
      // my one unstructured jump in the whole code!
      // From IDOK above only
      NoApplyNeeded:
      // From IDOK above only

      WaitCursor();
      DestroyWindow(hWndApp);       // TUBE THE APPLICATION NOW
      if (bAppliedOnce) {
         TCHAR szPrevThemePath[MAX_PATHLEN+1];
         DWORD dwIndex = 0;
         TCHAR szWVFile[MAX_PATH];

         // Delete the previous temp file before we exit
         lstrcpy(szPrevThemePath, szThemeDir);
         lstrcat(szPrevThemePath, szPrevSettingsFilename);
         DeleteFile(szPrevThemePath);

         // Delete any WebView files that were created for the
         // previous theme as well

         for (dwIndex = 0; dwIndex < MAX_WVNAMES; dwIndex++) {
             if (GetWVFilename(szPrevThemePath,
                               szWVNames[dwIndex],
                               szWVFile)) {
                DeleteFile(szWVFile);
             }
         }
      }


      CloseFrost();                 // final cleanups
      NormalCursor();
      break;

   default:
      return (FALSE);            // didn't process message EXIT
      break;
   }

   // normal case
   return (TRUE);
}


#ifdef USECALLBACKS
//
// FileXXXXHookProc
//
// Callbacks from the common file open and save dialogs.
//
// Return: FALSE to allow standard processing; TRUE to inhibit.
//          (except for WM_INITDIALOG which gets processed first)
//
UINT_PTR FAR PASCAL FileOpenHookProc(HWND hdlg, UINT msg, WPARAM wparam, LPARAM lparam)
{
   switch (msg) {
   case WM_INITDIALOG:
      return (TRUE);                // special case
      break;

   case WM_COMMAND:
      // this is where you preprocess the file selection
      if (wparam == IDOK) {
      }
      break;

   default:
      break;
   }

   return (FALSE);                  // allow standard processing in common dialog
}
#endif


//
// EnableThemeButtons
//
// Utility routine to enable/disable
//    OK
//    Apply
//    Checkboxes
//    SaveAs...
//    Delete
//
// Also do the screen saver button
//
// There are two cases: you have selected a THM file, or you have selected
// the "Current Windows settings" item.
//
// Uses: global szCurThemeFile to get current THM file
//

//#define CBON(x);  EnableWindow(GetDlgItem(hWndApp,x),TRUE);CheckDlgButton(hWndApp,x,TRUE);
#define CBON(x);  EnableWindow(GetDlgItem(hWndApp,x),TRUE);
#define CBOFF(x); EnableWindow(GetDlgItem(hWndApp,x),FALSE);

void FAR EnableThemeButtons()
{
   int iCheck;

   //
   // always in any case get scr saver button state updated
   EnableScreenSaverButton();

   // Always in any case enable the SCHEDULE check box
   EnableWindow(GetDlgItem(hWndApp, CB_SCHEDULE), TRUE);

   //
   // null THM file ==> Cur Win Settings
   if (!bThemed) {

      //
      // BUTTONS

      // enable SaveAs button, disable Delete
      EnableWindow(GetDlgItem(hWndApp, PB_SAVE), TRUE);
      EnableWindow(GetDlgItem(hWndApp, PB_DELETE), FALSE);

      // disable OK and Apply buttons
      // EnableWindow(GetDlgItem(hWndApp, IDOK), FALSE);    // removed as per davidba 4/95
      EnableWindow(GetDlgItem(hWndApp, PB_APPLY), FALSE);

      //
      // CHECKBOXES: first remember and then just uncheck and disable all
      SaveCheckboxes();
      for (iCheck = 0; iCheck < sizeof(iCBIDs)/sizeof(int); iCheck ++) {
         CBOFF(iCBIDs[iCheck]);
      }

      // Always in any case enable the SCHEDULE check box
      EnableWindow(GetDlgItem(hWndApp, CB_SCHEDULE), TRUE);
   }

   //
   // else normal THM file case

   else {

      // can't do this anymore because also need xtion from/to
      // iCurTheme == 1, PrevWinSettings
      #ifdef OLDCODE
      // first check whether you are already in the normal case!
      if (IsWindowEnabled(GetDlgItem(hWndApp, iCBIDs[0])))
         return;                    // NO WORK EXIT
      #endif

      //
      // BUTTONS
//      EnableWindow(GetDlgItem(hWndApp, PB_SAVE), TRUE);  // as per DB 1/95
      EnableWindow(GetDlgItem(hWndApp, PB_SAVE), FALSE);  // as per DB 4/95
      EnableWindow(GetDlgItem(hWndApp, PB_DELETE), TRUE);
      // enable OK and Apply buttons
      // EnableWindow(GetDlgItem(hWndApp, IDOK), TRUE); // as per DB 4.95

      //
      // CHECKBOXES: enable and and then restore checkstates
      for (iCheck = 0; iCheck < sizeof(iCBIDs)/sizeof(int); iCheck ++) {
         CBON(iCBIDs[iCheck]);
      }

      // APPLY BUTTON depends on checkboxes!
      // Note that IsAnyBoxChecked ignores CB_SCHEDULE.
      EnableWindow(GetDlgItem(hWndApp, PB_APPLY), IsAnyBoxChecked());
   }

   //
   // special case:
   // iCurTheme == 1 ==> Prev Win Settings
   if ((iCurTheme == 1) && bAppliedOnce) {
      // disable SaveAs button, disable Delete
      EnableWindow(GetDlgItem(hWndApp, PB_SAVE), FALSE);
      EnableWindow(GetDlgItem(hWndApp, PB_DELETE), FALSE);
   }
}


void EnableScreenSaverButton()
{
   BOOL bScrSaveActive = FALSE;
   extern TCHAR szSS_Section[];
   extern TCHAR szSS_Key[];
   // get scr saver state
   if (bThemed) {                    // normal theme case
      TCHAR szSSName[MAX_MSGLEN+1];
      GetPrivateProfileString((LPTSTR)szSS_Section, (LPTSTR)szSS_Key,
                              (LPTSTR)szNULL,
                              (LPTSTR)szSSName, MAX_MSGLEN,
                              (LPTSTR)szCurThemeFile);
      if (*szSSName != TEXT('\0'))
         bScrSaveActive = TRUE;
   }
   else                             // cur win settings case
      SystemParametersInfo(SPI_GETSCREENSAVEACTIVE, 0,
                           (LPVOID)&bScrSaveActive, FALSE);

   // with screensaver status, enable scr saver button correctly
   EnableWindow(GetDlgItem(hWndApp, PB_SCRSVR), bScrSaveActive);
}



//
// Just updates the title at the bottom of the preview area with
// the current theme name.
//
void NewSampleTitle(void)
{
   if (*szCurThemeFile)
      wsprintf((LPTSTR)szMsg, (LPTSTR)szPreviewTitle, (LPTSTR)szCurThemeName);
   else                             // current windows settings case
      szMsg[0] = 0;

   SetWindowText(GetDlgItem(hWndApp,TEXT_VIEW), (LPTSTR)szMsg);
}

BOOL bDontChecked;

INT_PTR FAR PASCAL BPP_ChoiceDlg(hDlg, message, wParam, lParam)
HWND hDlg;
UINT message;
WPARAM wParam;
LPARAM lParam;
{
   switch (message) {

   case WM_INITDIALOG:
      CheckRadioButton(hDlg, RB_ALL, RB_NONE, RB_SOME);
      bDontChecked = FALSE;
      break;

   case WM_COMMAND:
      switch ((int)LOWORD(wParam)) {

      // watch as changes the radio buttons
      case RB_ALL :
      case RB_SOME:
      case RB_NONE:
         if (IsDlgButtonChecked(hDlg, RB_NONE)) {
            // save check state of cbox, before....
            bDontChecked = IsDlgButtonChecked(hDlg, CB_CUT_IT_OUT);
            // ... turning it off and greying it
            CheckDlgButton(hDlg, CB_CUT_IT_OUT, FALSE);
            EnableWindow(GetDlgItem(hDlg, CB_CUT_IT_OUT), FALSE);
         }
         else {
            // if it WAS disabled, enable check box and restore check state
            if (!IsWindowEnabled(GetDlgItem(hDlg, CB_CUT_IT_OUT))) {
               EnableWindow(GetDlgItem(hDlg, CB_CUT_IT_OUT), TRUE);
               if (bDontChecked)
                  CheckDlgButton(hDlg, CB_CUT_IT_OUT, TRUE);
            }
         }
         break;

      case IDCANCEL:
         fLowBPPFilter = APPLY_ALL;
         EndDialog(hDlg,IDCANCEL);
         break;

      case IDOK:
         // first, check the never-again checkbox
         if (!IsWindowEnabled(GetDlgItem(hDlg, CB_CUT_IT_OUT)))
            bNeverCheckBPP = FALSE;
         else
            bNeverCheckBPP = IsDlgButtonChecked(hDlg, CB_CUT_IT_OUT);

         // get the apply filter
         if (IsDlgButtonChecked(hDlg, RB_ALL))
            fLowBPPFilter = APPLY_ALL;
         else if (IsDlgButtonChecked(hDlg, RB_SOME))
            fLowBPPFilter = APPLY_SOME;
         else
            fLowBPPFilter = APPLY_NONE;

         EndDialog(hDlg,(int)LOWORD(wParam));
         break;

      default:
         return (FALSE);
         break;
      }
      break;
   default:
      return(FALSE);
      break;
   }
   return TRUE;
}

#ifndef UNICODE
// THIS CODE IS NOT CURRENTLY USED.

//  Standard entry code yanked from runtime libs to avoid having to link those
//  libs.  Shrinks binary by a few K.
int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();


    if ( *pszCmdLine == (CHAR)'\"') {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != (CHAR)'\"') );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == (CHAR)'\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > (CHAR)' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= (CHAR)' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never comes here.
}
#endif

//
// Determine if a specified file already exists in the specified path
//
BOOL FileSpecExists(LPTSTR szFilename)
{
   WIN32_FIND_DATA findData;
   HANDLE hFind;
   BOOL fExists = FALSE;

   hFind = FindFirstFile(szFilename, &findData);
   if (hFind != INVALID_HANDLE_VALUE)
   {
      fExists = TRUE;      // Something is there
      FindClose(hFind);
   }

   return fExists;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\global.h ===
/* GLOBAL.H

   Include file for Desktop Themes project.

   Frosting: Master Theme Selector for Windows
   Copyright (c) 1994-1998 Microsoft Corporation
*/

/////////////////////////////////////////////////////////////////////
//
// GLOBAL VARIABLES
//
// Global variables defined in this header file are globals accessed
// by the SCHEDULE.CPP code.  They must be defined as extern in this
// header and declared as extern "C" in SCHEDULE.CPP.
//
// Note that other global variables are defined in FROST.H.
//

extern HWND hWndApp;               // main application window handle
extern HINSTANCE hInstApp;         // application instance handle
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\etcdlg.c ===
/* ETCDLG.C
   Resident Code Segment      // Tweak: make non-resident?

   Routines for Pointers/Sounds/Etc preview dialog

   Frosting: Master Theme Selector for Windows '95
   Copyright (c) 1994-1999 Microsoft Corporation.  All rights reserved.
*/

// ---------------------------------------------
// Brief file history:
// Alpha:
// Beta:
// Bug fixes
// ---------
//
// ---------------------------------------------

#define OEMRESOURCE  1  // for OBM_*
#include "windows.h"
#include "frost.h"
#include "global.h"
#include "prsht.h"
#include "commdlg.h"
#include "stdlib.h"

#include "mmsystem.h"
#include "..\inc\addon.h"
#include "loadimag.h"
#include "adutil.h"
#include "schedule.h"  // IsPlatformNT()

// Local Routines
BOOL EtcInit(void );
void EtcDestroy(void );
INT_PTR FAR PASCAL PtrsPageProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR FAR PASCAL SndsPageProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR FAR PASCAL PicsPageProc(HWND, UINT, WPARAM, LPARAM);
void CreateDataStr(LPTSTR, LPTSTR, LPTSTR);
void GetFileStr(LPTSTR, LPTSTR);
void GetDisplayStr(LPTSTR, LPTSTR);
HBITMAP PASCAL GetSoundBitmap(LPTSTR lpszFile);
HANDLE PASCAL GetRiffAll(HMMIO hmmio, LPTSTR szText, int iLen);
void PASCAL SetDlgItemFile(HWND, UINT, LPCTSTR);

// stuff from  DIB.C
HPALETTE WINAPI  bmfCreateDIBPalette(HANDLE);
HBITMAP  WINAPI  bmfBitmapFromDIB(HANDLE, HPALETTE);
HPALETTE CreateBIPalette (LPBITMAPINFOHEADER);
DWORD WINAPI bmfDIBSize(HANDLE);
WORD PaletteSize (VOID FAR *pv);
WORD NumDIBColors (VOID FAR * pv);

// globals
HBITMAP hbmpCheck, hbmpQ;
BITMAP bmCheck, bmQ;
int iItemHeight;                    // height of listbox items
int xTextOffset;                    // leave room for checkmark when drawing text
RECT rPreview;                      // area of preview image
HCURSOR hCurCursor = NULL;
HBITMAP hbmpCurSnd = NULL;
HANDLE hCurImage = NULL;            // icon or bitmap

TCHAR szCurPreviewFile[MAX_PATHLEN+1];

#define bThemed (*szCurThemeFile)

typedef struct {
   int   idStr;                     // resource id of display string
   int   indexF;                    // index into approp FROST_* struct
}  STR_TO_KEY;


// stuff from  DIB.C
#define PALVERSION      0x300
#define MAXPALETTE      256   /* max. # supported palette entries */
#define WIDTHBYTES(i)   (((i)+31)/32*4)

//
// These arrays match the resource string ids of the strings displayed in
// the listboxes to the index into the appropriate FROST_* array -- to find
// the theme-file key needed to retrieve the filename of the associated
// cursor/icon/bitmap.
//


//
// WARNING: keep indices current with any changes in fvCursors[] in keys.h!
//
// THIS ARRAY SHOWS THE ORDER THAT THE ITEMS APPEAR IN THE LISTBOX!
STR_TO_KEY stkCursors[] = {
   {STR_CUR_ARROW,      0  },
   {STR_CUR_HELP,       1  },
   {STR_CUR_APPSTART,   2  },
   {STR_CUR_WAIT,       3  },
   {STR_CUR_CROSSHAIR,  8  },
   {STR_CUR_IBEAM,      9  },
   {STR_CUR_NWPEN,      4  },
   {STR_CUR_NO,         5  },
   {STR_CUR_SIZENS,     6  },
   {STR_CUR_SIZEWE,     7  },
   {STR_CUR_SIZENWSE,   10 },
   {STR_CUR_SIZENESW,   11 },
   {STR_CUR_SIZEALL,    12 },
   {STR_CUR_UPARROW,    13 }
};

//
// WARNING: keep indices current with any changes in fsCurUser[] in keys.h!
//
// This listbox has its items sorted. Currently.
STR_TO_KEY stkSounds[] = {
   {STR_SND_DEF,        2  },
   {STR_SND_GPF,        3  },
   {STR_SND_MAX,        4  },
   {STR_SND_MENUCMD,    5  },
   {STR_SND_MENUPOP,    6  },
   {STR_SND_MIN,        7  },
   {STR_SND_OPEN,       8  },
   {STR_SND_CLOSE,      9  },
   {STR_SND_MAILBEEP,   10 },
   {STR_SND_RESTDOWN,   11 },
   {STR_SND_RESTUP,     12 },
   {STR_SND_RINGIN,     13 },
   {STR_SND_RINGOUT,    14 },
   {STR_SND_SYSASTER,   15 },
   {STR_SND_SYSDEF,     16 },
   {STR_SND_SYSEXCL,    17 },
   {STR_SND_SYSEXIT,    18 },
   {STR_SND_SYSHAND,    19 },
   {STR_SND_SYSQUEST,   20 },
   {STR_SND_SYSSTART,   21 },
   {STR_SND_TOSSTRASH,  22 }
};

// WARNING: keep current with any changes in number of items in visuals dlg
#define SCRSAV_NDX      6           // zero-based

// max number of items is in the sound listbox
#define MAX_ETC_ITEMS   (sizeof(stkSounds)/sizeof(STR_TO_KEY))

// this array is init'd with the listbox init to keep track of
// which files actually exist
BOOL bCursorExists[MAX_ETC_ITEMS+1];
BOOL bSoundExists[MAX_ETC_ITEMS+1];
BOOL bVisualExists[MAX_ETC_ITEMS+1];


//
// HELP CONTEXT ID to CONTROL ID pairings for context help
//

POPUP_HELP_ARRAY phaPtrsDlg[] = {
   { (DWORD)LB_PTRS        ,     (DWORD)IDH_THEME_POINTERS_LIST},
   { (DWORD)RECT_PREVIEW   ,     (DWORD)IDH_THEME_POINTERS_PREV},
   { (DWORD)TXT_FILENAME   ,     (DWORD)IDH_THEME_POINTERS_FILE},
   { (DWORD)0, (DWORD)0 }          // double-null terminator
};
POPUP_HELP_ARRAY phaSndsDlg[] = {
   { (DWORD)LB_SNDS        ,     (DWORD)IDH_THEME_SOUNDS_LIST},
   { (DWORD)RECT_PREVIEW   ,     (DWORD)IDH_THEME_SOUNDS_ICON_PREV},
   { (DWORD)PB_PLAY        ,     (DWORD)IDH_THEME_SOUNDS_PLAYS},
   { (DWORD)TXT_FILENAME   ,     (DWORD)IDH_THEME_SOUNDS_FILE},
   { (DWORD)0, (DWORD)0 }          // double-null terminator
};
POPUP_HELP_ARRAY phaPicsDlg[] = {
   { (DWORD)LB_PICS        ,     (DWORD)IDH_THEME_PICS_LIST},
   { (DWORD)RECT_PREVIEW   ,     (DWORD)IDH_THEME_PICS_PREV},
   { (DWORD)TXT_FILENAME   ,     (DWORD)IDH_THEME_PICS_FILE},
   { (DWORD)0, (DWORD)0 }          // double-null terminator
};


//
// DoEtcDlgs
//
// Sets up the property sheet for Pointers, Sounds, Pictures.
//
// Returns: BOOL success of setup.
//

INT_PTR FAR DoEtcDlgs(HWND hParent)
{
   PROPSHEETPAGE psp[3];
   PROPSHEETHEADER psh;
   INT_PTR iret;

   //
   // Set up each of the three pages

   ZeroMemory(psp, sizeof(psp));
   psp[0].dwSize = sizeof(PROPSHEETPAGE);
   psp[0].dwFlags = PSP_USETITLE;
   psp[0].hInstance = hInstApp;
   psp[0].pszTemplate = MAKEINTRESOURCE(DLGPROP_PTRS);
   psp[0].pszIcon = (LPCTSTR)NULL;
   psp[0].pszTitle = MAKEINTRESOURCE(STR_TITLE_PTRS);
   psp[0].pfnDlgProc = PtrsPageProc;
   psp[0].lParam = (LPARAM)0;
   psp[0].pfnCallback = (LPFNPSPCALLBACK)0;
   psp[0].pcRefParent = (UINT FAR *)0;


   psp[1].dwSize = sizeof(PROPSHEETPAGE);
   psp[1].dwFlags = PSP_USETITLE;
   psp[1].hInstance = hInstApp;
   psp[1].pszTemplate = MAKEINTRESOURCE(DLGPROP_SNDS);
   psp[1].pszIcon = (LPCTSTR)NULL;
   psp[1].pszTitle = MAKEINTRESOURCE(STR_TITLE_SNDS);
   psp[1].pfnDlgProc = SndsPageProc;
   psp[1].lParam = (LPARAM)0;
   psp[1].pfnCallback = (LPFNPSPCALLBACK)0;
   psp[1].pcRefParent = (UINT FAR *)0;

   psp[2].dwSize = sizeof(PROPSHEETPAGE);
   psp[2].dwFlags = PSP_USETITLE;
   psp[2].hInstance = hInstApp;
   psp[2].pszTemplate = MAKEINTRESOURCE(DLGPROP_PICS);
   psp[2].pszIcon = (LPCTSTR)NULL;
   psp[2].pszTitle = MAKEINTRESOURCE(STR_TITLE_PICS);
   psp[2].pfnDlgProc = PicsPageProc;
   psp[2].lParam = (LPARAM)0;
   psp[2].pfnCallback = (LPFNPSPCALLBACK)0;
   psp[2].pcRefParent = (UINT FAR *)0;


   //
   // set up the property sheet info header

   psh.dwSize = sizeof(PROPSHEETHEADER);
   psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
   psh.hwndParent = hParent;
   psh.hInstance = hInstApp;
   psh.pszIcon = NULL;
   psh.pszCaption = MAKEINTRESOURCE(STR_TITLE_ETC);
   psh.nPages = sizeof(psp)/sizeof(PROPSHEETPAGE);
   psh.nStartPage = 0;
   psh.ppsp = (LPCPROPSHEETPAGE) &psp;

   //
   // object, etc init
   if (!EtcInit())
      return (FALSE);      // couldn't initalize things EXIT

   //
   // create the property sheet and cleanup
   iret = PropertySheet( (LPCPROPSHEETHEADER) &psh);

   //
   // object, etc cleanup
   EtcDestroy();

   return (iret >= 0);      // TRUE if successful
}


//
// EtcInit/Destroy
//
// Init/Destroy things used in common by all three dialogs.
//
// Destroy returns: success
//
BOOL EtcInit(void)
{
   BOOL bret = TRUE;

   // owner-draw listboxes' checkmark and question mark
   hbmpCheck = LoadBitmap(NULL, MAKEINTRESOURCE(OBM_CHECK));
   hbmpQ = LoadBitmap(hInstApp, MAKEINTRESOURCE(BMP_QUESTION));

   if (hbmpCheck && hbmpQ) {
      // keep specs on bitmap
      GetObject(hbmpCheck, sizeof(BITMAP), (LPVOID)(LPBITMAP)&bmCheck);
      GetObject(hbmpQ, sizeof(BITMAP), (LPVOID)(LPBITMAP)&bmQ);
   }
   else
      bret = FALSE;

   // cleanup
   return (bret);
}

void EtcDestroy(void)
{
   if (hbmpCheck) DeleteObject(hbmpCheck);
   hbmpCheck = NULL;

   if (hbmpQ) DeleteObject(hbmpQ);
   hbmpQ = NULL;

   if (hCurCursor) DestroyCursor(hCurCursor);
   hCurCursor = NULL;

   if (hbmpCurSnd) DeleteObject(hbmpCurSnd);
   hbmpCurSnd = NULL;

   if (hCurImage) DestroyCursor(hCurImage);
   hCurImage = NULL;
}


//
// *PageProc
//
// Property sheet page procedures for the Etc preview sheet.
//

TCHAR szCursors[] = TEXT("Control Panel\\Cursors");

INT_PTR FAR PASCAL PtrsPageProc(hDlg, message, wParam, lParam)
HWND hDlg;
UINT message;
WPARAM wParam;
LPARAM lParam;
{
   switch (message) {

   // set up listbox, initial selection, etc.
   case WM_INITDIALOG:
      {  // var scope
         int iter;
         extern FROST_VALUE fvCursors[];     // for theme file keys
         HWND hText, hLBox;
         RECT rText;
         TCHAR szDispStr[MAX_STRLEN+1];

         // just in first of these dialogs, need to init page OK to disabled
         EnableWindow(GetDlgItem(GetParent(hDlg), IDCANCEL), FALSE);
         SendMessage(GetParent(hDlg), PSM_CANCELTOCLOSE, (WPARAM)0, (LPARAM)0);

         // just in first of these dialogs, need to init dialog title
         LoadString(hInstApp, STR_PREVIEWDLG, (LPTSTR)szMsg, MAX_MSGLEN);
         lstrcat((LPTSTR)szMsg,
                 bThemed ? FileFromPath((LPTSTR)szCurThemeFile)
                         : szCurSettings
                );

         TruncateExt((LPTSTR)szMsg);
         SetWindowText(GetParent(hDlg), (LPTSTR)szMsg);

         //
         // get metrics for drawitem size
         hText = GetDlgItem(hDlg, TXT_FILENAME);      // 12 dialog box units high
         GetWindowRect(hText, (LPRECT)&rText);
         iItemHeight = ((rText.bottom - rText.top) * 8) / 12;  // dialog font height
         xTextOffset = (iItemHeight * 3) / 2;         // proportional spacing
         Assert(iItemHeight > 0, TEXT("didn't get positive text height for preview listbox!\n"));

         #if 0 // this is when we painted the cursor by ourself
         // other metrics, etc.
         xCursor = GetSystemMetrics(SM_CXCURSOR);
         yCursor = GetSystemMetrics(SM_CYCURSOR);
         //
         // save away preview rect area
         GetWindowRect(GetDlgItem(hDlg, RECT_PREVIEW), (LPRECT)&rPreview);
         GetWindowRect(hDlg, (LPRECT)&rText);
         OffsetRect((LPRECT)&rPreview, -rText.left, -rText.top);
         DestroyWindow(GetDlgItem(hDlg, RECT_PREVIEW));
         #endif

         //
         // init the listbox with combined strings

         // init
         hLBox = GetDlgItem(hDlg, LB_PTRS);
         Assert (sizeof(stkCursors)/sizeof(STR_TO_KEY) == NUM_CURSORS,
                 TEXT("size mismatch stkCursors and NUM_CURSORS\n"));

         // for each cursor
         for (iter = 0; iter < NUM_CURSORS; iter++) {
            // get display string
            LoadString(hInstApp, stkCursors[iter].idStr,
                       (LPTSTR)szDispStr, MAX_STRLEN);
                      // CPLs don't check for success on LoadString in INITDIALOG, so OK!?
            // get filename if any
            if (bThemed) {
               GetPrivateProfileString((LPTSTR)szCursors,
                                       (LPTSTR)( fvCursors[stkCursors[iter].indexF].szValName ),
                                       (LPTSTR)szNULL,
                                       (LPTSTR)szMsg, MAX_MSGLEN,
                                       (LPTSTR)szCurThemeFile);
               // expand filename string as necessary
               InstantiatePath((LPTSTR)szMsg, MAX_MSGLEN);
            }
            else {
               // cur system settings
               HandGet(HKEY_CURRENT_USER,
                       (LPTSTR)szCursors,
                       (LPTSTR)( fvCursors[stkCursors[iter].indexF].szValName ),
                       (LPTSTR)szMsg);
            }

            // store whether the file exists
            bCursorExists[iter] = szMsg[0] &&
                  (CF_NOTFOUND != ConfirmFile(szMsg, FALSE)); // don't alter str

            // combine strings into data string to load up in
            // owner-draw hasstrings listbox!
            CreateDataStr((LPTSTR)pValue, (LPTSTR)szDispStr, (LPTSTR)szMsg);

            // now, finally, go ahead and assign string to listbox
            SendMessage(hLBox, LB_ADDSTRING, 0, (LPARAM)(LPTSTR)pValue);
         }

         // setup initial focus conditions
         SetFocus(hLBox);
         SendMessage(hLBox, LB_SETCURSEL, 0, 0);

         // need to ensure it gets initial update of cur file
         PostMessage(hDlg, WM_COMMAND, MAKEWPARAM(LB_PTRS, LBN_SELCHANGE),
                                       MAKELPARAM(0, 0) );

      }  // var scope
      break;

   case WM_MEASUREITEM:
      {
         LPMEASUREITEMSTRUCT lpmis;

         /* Set the height of the list box items. */
         lpmis = (LPMEASUREITEMSTRUCT) lParam;
//         lpmis->itemHeight = iItemHeight;
         lpmis->itemHeight = 0;     // DavidBa says they want these big default item hts
//            Assert(iItemHeight > 0, TEXT("set non-positive item height for preview listbox!\n"));
//            Assert(iItemHeight <= 0, TEXT("OK, set a positive item height for preview listbox!\n"));
      }
      break;

   case WM_DRAWITEM:
      { // var scope

         TEXTMETRIC tm;
         LPDRAWITEMSTRUCT lpdis;
         int yTextOffset;
         LPTSTR lpszFile;
         HDC hdcMem;
         HBITMAP hbmpOld;

         lpdis = (LPDRAWITEMSTRUCT) lParam;

         /* If there are no list box items, skip this message. */
         if (lpdis->itemID == -1) {
               break;
         }  // jdk: well, what about focus rect in empty lbox?

         //
         // Inits

         // get the filename assoc with this item, if any
         SendMessage(lpdis->hwndItem, LB_GETTEXT, lpdis->itemID,
                     (LPARAM)(LPTSTR)szMsg);
         GetDisplayStr((LPTSTR)szMsg, (LPTSTR)szMsg);   // Ok src and dst same
         // you now have "displaystr\0filename" in szMsg[]
         lpszFile = (LPTSTR)(szMsg + lstrlen((LPTSTR)szMsg) + 1);

         //
         // draw right background color
         if (lpdis->itemState & ODS_SELECTED) {

            // if item is selected, draw highlight background here
            FillRect(lpdis->hDC, (LPRECT)&(lpdis->rcItem),
               GetSysColorBrush(COLOR_HIGHLIGHT));

            // set text color to highlight text
            SetBkColor(lpdis->hDC, GetSysColor(COLOR_HIGHLIGHT));
            SetTextColor(lpdis->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
         }
         else {                  // not selected
            // need to do normal background fill to undo prev selection
            FillRect(lpdis->hDC, (LPRECT)&(lpdis->rcItem),
               GetSysColorBrush(COLOR_WINDOW));

            // set text color to foreground
            SetBkColor(lpdis->hDC, GetSysColor(COLOR_WINDOW));
            SetTextColor(lpdis->hDC, GetSysColor(COLOR_WINDOWTEXT));
         }

         // if there is a file associated with this item
         if (*lpszFile) {
            HBITMAP hbmpLeading;
            BITMAP bmLeading;

            //
            // find the right leading bitmap: checkmark or question mark
            if (bCursorExists[lpdis->itemID]) {
               hbmpLeading = hbmpCheck;
               bmLeading = bmCheck;
            }
            else {
               hbmpLeading = hbmpQ;
               bmLeading = bmQ;
            }

            //
            // paint in the leading bitmap!

            hdcMem = CreateCompatibleDC(lpdis->hDC);
            if (hdcMem)
            {
                hbmpOld = SelectObject(hdcMem, hbmpLeading);

                // if item height is less than bitmap height
                if (lpdis->rcItem.bottom - lpdis->rcItem.top < bmLeading.bmHeight)
                {
                   // stretch down bitmap size to fit
                   StretchBlt(lpdis->hDC,
                              lpdis->rcItem.left, lpdis->rcItem.top,
                              lpdis->rcItem.bottom - lpdis->rcItem.top,   // width = height
                              lpdis->rcItem.bottom - lpdis->rcItem.top,
                              hdcMem, 0, 0, bmLeading.bmWidth, bmLeading.bmHeight, SRCCOPY);
                }
                else // item height taller than checkmark bitmap
                {
                   // just center vertically
                   BitBlt(lpdis->hDC,
                          lpdis->rcItem.left,
                          lpdis->rcItem.top +
                            (lpdis->rcItem.bottom - lpdis->rcItem.top - bmLeading.bmHeight)/2,
                          bmLeading.bmWidth, bmLeading.bmHeight,
                          hdcMem, 0, 0, SRCCOPY);
                }

                SelectObject(hdcMem, hbmpOld);
                DeleteDC(hdcMem);
             }

// who cares
//               Assert(lpdis->rcItem.bottom - lpdis->rcItem.top == iItemHeight,
//                        TEXT("MEASUREITEM and DRAWITEM have different heights!\n"));
         }

         //
         // now draw the display string for this item

         // figure y offset to vert center text in draw item
         GetTextMetrics(lpdis->hDC, &tm);
         yTextOffset = (lpdis->rcItem.bottom - lpdis->rcItem.top - tm.tmHeight) / 2;
         Assert(yTextOffset >= 0, TEXT("negative text vert offset in DRAWITEM\n"));
         if (yTextOffset < 0)  yTextOffset = 0;

         // do the out
         SetBkMode(lpdis->hDC, TRANSPARENT);
         TextOut(lpdis->hDC,
                  lpdis->rcItem.left + xTextOffset,
                  lpdis->rcItem.top + yTextOffset,
                  (LPTSTR)szMsg, lstrlen((LPTSTR)szMsg));

         //
         // if item is selected, draw a focus rect
         if (lpdis->itemState & ODS_FOCUS) {
            DrawFocusRect(lpdis->hDC, (LPRECT)&(lpdis->rcItem));
         }
      }  // var scope
      break;

   case WM_COMMAND:
      switch ((int)LOWORD(wParam)) {
      case LB_PTRS:
         // if new selection in listbox
         if (HIWORD(wParam) == LBN_SELCHANGE) {
            int iSeln, ilen;

            // get new selection if any
            iSeln = (int)SendDlgItemMessage(hDlg, LB_PTRS, LB_GETCURSEL, 0, 0);
            if (LB_ERR == iSeln)
               break;               // no selection EXIT

            // get selection text
            SendDlgItemMessage(hDlg, LB_PTRS, LB_GETTEXT,
                               (WPARAM)iSeln, (LPARAM)(LPTSTR)szMsg);

            // update global current filename string
            GetFileStr(szCurPreviewFile, szMsg);

            // reset dialog static text of filename string
            SetDlgItemFile(hDlg, TXT_FILENAME, szCurPreviewFile);
            // and scroll end into view
            ilen = lstrlen((LPTSTR)szCurPreviewFile);
            SendDlgItemMessage(hDlg, TXT_FILENAME, EM_SETSEL,
                               (WPARAM)0, MAKELPARAM(-1, ilen));

            // update cursor
            if (hCurCursor) DestroyCursor(hCurCursor);
            hCurCursor = NULL;
            if (*szCurPreviewFile)
            {
               hCurCursor = LoadImage(NULL, szCurPreviewFile, IMAGE_CURSOR,
                                      0, 0, LR_LOADFROMFILE | LR_DEFAULTSIZE);
            }

	

            // set cursor to static, even if null: null clears prev
            SendDlgItemMessage(hDlg, RECT_PREVIEW, STM_SETICON,
                               (WPARAM)hCurCursor, (LPARAM)0);

            #if 0 // this is when we painted the cursor by ourself
            // force repaint of preview area
            InvalidateRect(hDlg, (LPRECT)&rPreview, TRUE);
            #endif
         }
         break;

      // case PB_TEST:
      //    break;
      }
      break;

   #if 0 // this is when we painted the cursor by ourself
   case WM_PAINT:
      BeginPaint(hDlg, &ps);

      //
      // preview area
      DrawEdge(ps.hdc, (LPRECT)&rPreview, EDGE_SUNKEN, BF_RECT);  // always edge
      // if there's a file to preview
      if (*szCurPreviewFile) {
         // add the cursor
         if (hCurCursor)
            DrawIcon(ps.hdc,
                     rPreview.left + (rPreview.right-rPreview.left-xCursor)/2,
                     rPreview.top + (rPreview.bottom-rPreview.top-yCursor)/2,
                     hCurCursor);
      }

      EndPaint(hDlg, &ps);
      break;
   #endif

   case WM_NOTIFY:
      switch ( ((NMHDR FAR *)lParam)->code) {

      // OK or Apply button pressed
      case PSN_APPLY:
         // apply any changes made on this page

         SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR); // accept changes
         break;

      // cancel button pressed
      case PSN_RESET:
         // don't accept any of the changes made on this page
         break;

      case PSN_SETACTIVE:
         break;
      case PSN_KILLACTIVE:
         // need to say that it's OK by us to lose the activation
         SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);   // OK to kill focus now
         break;

      }
      break;

   case WM_HELP:
      {
         LPHELPINFO lphi;
         lphi = (LPHELPINFO)lParam;
         if (lphi->iContextType == HELPINFO_WINDOW) {
            WinHelp(lphi->hItemHandle, (LPTSTR)szHelpFile, HELP_WM_HELP,
                  (DWORD_PTR)((POPUP_HELP_ARRAY FAR *)phaPtrsDlg));
         }
      }
      break;

   case WM_CONTEXTMENU:
      WinHelp((HWND)wParam, (LPTSTR)szHelpFile, HELP_CONTEXTMENU,
            (DWORD_PTR)((POPUP_HELP_ARRAY FAR *)phaPtrsDlg));
      break;

   default:
      return(FALSE);                // didn't process message
      break;
   }

   return TRUE;                     // processed message
}


INT_PTR FAR PASCAL SndsPageProc(hDlg, message, wParam, lParam)
HWND hDlg;
UINT message;
WPARAM wParam;
LPARAM lParam;
{
   static BOOL gfWaveExists = FALSE;
   static HBITMAP hbmpPlay = NULL;
   BOOL bDoubleClick = FALSE;

   switch (message) {

   // set up listbox, initial selection, etc.
   case WM_INITDIALOG:
      {  // var scope
         int iter;
         int iRet;
         extern FROST_SUBKEY fsCurUser[];     // for theme file keys
         HWND hText, hLBox;
         RECT rText;
         TCHAR szDispStr[MAX_STRLEN+1];
         extern FROST_SUBKEY fsCurUser[];
         WAVEOUTCAPS woCaps;

         // Taken right from the Sounds cpl.
         gfWaveExists = waveOutGetNumDevs() > 0 &&
                        (waveOutGetDevCaps(0,&woCaps,sizeof(woCaps)) == 0) &&
                                           woCaps.dwFormats != 0L;

         if ((hbmpPlay = LoadBitmap(hInstApp, MAKEINTRESOURCE(PLAY_BITMAP))) !=
            NULL)
            SendDlgItemMessage(hDlg, PB_PLAY, BM_SETIMAGE, IMAGE_BITMAP,
               (LPARAM) hbmpPlay);

         //
         // get metrics for drawitem size
         hText = GetDlgItem(hDlg, TXT_FILENAME);      // 12 dialog box units high
         GetWindowRect(hText, (LPRECT)&rText);
         iItemHeight = ((rText.bottom - rText.top) * 8) / 12;  // dialog font height
         xTextOffset = (iItemHeight * 3) / 2;         // proportional spacing
         Assert(iItemHeight > 0, TEXT("didn't get positive text height for preview listbox!\n"));

         //
         // init the listbox with combined strings

         // init
         hLBox = GetDlgItem(hDlg, LB_SNDS);
         Assert (sizeof(stkSounds)/sizeof(STR_TO_KEY) == NUM_SOUNDS,
                 TEXT("size mismatch stkSounds and NUM_SOUNDS\n"));

         // for each sound
         for (iter = 0; iter < NUM_SOUNDS; iter++) {
            // get display string
            LoadString(hInstApp, stkSounds[iter].idStr,
                       (LPTSTR)szDispStr, MAX_STRLEN);
                      // CPLs don't check for success on LoadString in INITDIALOG, so OK!?
            // get filename if any
            if (bThemed) {
               GetPrivateProfileString((LPTSTR)(fsCurUser[stkSounds[iter].indexF].szSubKey),
                                       (LPTSTR)FROST_DEFSTR,
                                       (LPTSTR)szNULL,
                                       (LPTSTR)szMsg, MAX_MSGLEN,
                                       (LPTSTR)szCurThemeFile);
               // expand filename string as necessary
               InstantiatePath((LPTSTR)szMsg, MAX_MSGLEN);
            }
            else {
               // cur system settings
               HandGet(HKEY_CURRENT_USER,
                       (LPTSTR)(fsCurUser[stkSounds[iter].indexF].szSubKey),
                       (LPTSTR)szNULL,
                       (LPTSTR)szMsg);
            }

            // combine strings into data string to load up in
            // owner-draw hasstrings listbox!
            CreateDataStr((LPTSTR)pValue, (LPTSTR)szDispStr, (LPTSTR)szMsg);

            // now, finally, go ahead and assign string to listbox
            SendMessage(hLBox, LB_ADDSTRING, 0, (LPARAM)(LPTSTR)pValue);
         }

         //
         // check them all for file existence. have to do here, LBOX IS SORTED!
         //
         for (iter = 0; iter < MAX_ETC_ITEMS; iter++) {
            // get this item's listbox string
            iRet = (int) SendMessage(hLBox, LB_GETTEXT, iter, (LPARAM)(LPTSTR)szMsg);
            if (iRet == LB_ERR)
               break;               // past end of listbox items CONTINUE

            // get the filename assoc with this item, if any
            GetFileStr((LPTSTR)pValue, (LPTSTR)szMsg);

            // store whether the file exists
            bSoundExists[iter] = *pValue &&
                  (CF_NOTFOUND != ConfirmFile((LPTSTR)pValue, FALSE));
         }

         // save away preview rect area
         GetWindowRect(GetDlgItem(hDlg, RECT_PREVIEW), (LPRECT)&rPreview);
         GetWindowRect(hDlg, (LPRECT)&rText);
         OffsetRect((LPRECT)&rPreview, -rText.left, -rText.top);

         // setup initial focus conditions
         SetFocus(hLBox);
         SendMessage(hLBox, LB_SETCURSEL, 0, 0);

         // need to ensure it gets initial update of cur file
         PostMessage(hDlg, WM_COMMAND, MAKEWPARAM(LB_SNDS, LBN_SELCHANGE),
                                       MAKELPARAM(0, 0) );

      }  // var scope
      break;

   case WM_DESTROY:
      {
         if (hbmpPlay) {
            DeleteObject(hbmpPlay);
            hbmpPlay = NULL;
         }
      }
      break;

   case WM_MEASUREITEM:
      {
         LPMEASUREITEMSTRUCT lpmis;

         /* Set the height of the list box items. */
         lpmis = (LPMEASUREITEMSTRUCT) lParam;
//         lpmis->itemHeight = iItemHeight;
         lpmis->itemHeight = 0;     // DavidBa says they want these big default item hts
//            Assert(iItemHeight > 0, TEXT("set non-positive item height for preview listbox!\n"));
//            Assert(iItemHeight <= 0, TEXT("OK, set a positive item height for preview listbox!\n"));
      }
      break;

   case WM_DRAWITEM:
      { // var scope

         TEXTMETRIC tm;
         LPDRAWITEMSTRUCT lpdis;
         int yTextOffset;
         LPTSTR lpszFile;
         HDC hdcMem;
         HBITMAP hbmpOld;

         lpdis = (LPDRAWITEMSTRUCT) lParam;

         /* If there are no list box items, skip this message. */
         if (lpdis->itemID == -1) {
               break;
         }  // jdk: well, what about focus rect in empty lbox?

         //
         // Inits

         // get the filename assoc with this item, if any
         SendMessage(lpdis->hwndItem, LB_GETTEXT, lpdis->itemID,
                     (LPARAM)(LPTSTR)szMsg);
         GetDisplayStr((LPTSTR)szMsg, (LPTSTR)szMsg);   // Ok src and dst same
         // you now have "displaystr\0filename" in szMsg[]
         lpszFile = (LPTSTR)(szMsg + lstrlen((LPTSTR)szMsg) + 1);

         //
         // draw right background color
         if (lpdis->itemState & ODS_SELECTED) {

            // if item is selected, draw highlight background here
            FillRect(lpdis->hDC, (LPRECT)&(lpdis->rcItem),
                     GetSysColorBrush(COLOR_HIGHLIGHT));

            // set text color to highlight text
            SetBkColor(lpdis->hDC, GetSysColor(COLOR_HIGHLIGHT));
            SetTextColor(lpdis->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
         }
         else {                  // not selected
            // need to do normal background fill to undo prev selection
            FillRect(lpdis->hDC, (LPRECT)&(lpdis->rcItem),
                     GetSysColorBrush(COLOR_WINDOW));

            // set text color to foreground
            SetBkColor(lpdis->hDC, GetSysColor(COLOR_WINDOW));
            SetTextColor(lpdis->hDC, GetSysColor(COLOR_WINDOWTEXT));
         }

         // if there is a file associated with this item
         if (*lpszFile) {
            HBITMAP hbmpLeading;
            BITMAP bmLeading;

            //
            // find the right leading bitmap: checkmark or question mark
            if (bSoundExists[lpdis->itemID]) {
               hbmpLeading = hbmpCheck;
               bmLeading = bmCheck;
            }
            else {
               hbmpLeading = hbmpQ;
               bmLeading = bmQ;
            }

            //
            // paint in the leading bitmap!

            hdcMem = CreateCompatibleDC(lpdis->hDC);
            if (hdcMem)
            {
                hbmpOld = SelectObject(hdcMem, hbmpLeading);

                // if item height is less than bitmap height
                if (lpdis->rcItem.bottom - lpdis->rcItem.top < bmLeading.bmHeight)
                {
                   // stretch down bitmap size to fit
                   StretchBlt(lpdis->hDC,
                              lpdis->rcItem.left, lpdis->rcItem.top,
                              lpdis->rcItem.bottom - lpdis->rcItem.top,   // width = height
                              lpdis->rcItem.bottom - lpdis->rcItem.top,
                              hdcMem, 0, 0, bmLeading.bmWidth, bmLeading.bmHeight, SRCCOPY);
                }
                else // item height taller than checkmark bitmap
                {
                   // just center vertically
                   BitBlt(lpdis->hDC,
                          lpdis->rcItem.left,
                          lpdis->rcItem.top +
                            (lpdis->rcItem.bottom - lpdis->rcItem.top - bmLeading.bmHeight)/2,
                          bmLeading.bmWidth, bmLeading.bmHeight,
                          hdcMem, 0, 0, SRCCOPY);
                }

                SelectObject(hdcMem, hbmpOld);
                DeleteDC(hdcMem);
             }

// who cares
//               Assert(lpdis->rcItem.bottom - lpdis->rcItem.top == iItemHeight,
//                        TEXT("MEASUREITEM and DRAWITEM have different heights!\n"));
         }

         //
         // now draw the display string for this item

         // figure y offset to vert center text in draw item
         GetTextMetrics(lpdis->hDC, &tm);
         yTextOffset = (lpdis->rcItem.bottom - lpdis->rcItem.top - tm.tmHeight) / 2;
         Assert(yTextOffset >= 0, TEXT("negative text vert offset in DRAWITEM\n"));
         if (yTextOffset < 0)  yTextOffset = 0;

         // do the out
         SetBkMode(lpdis->hDC, TRANSPARENT);
         TextOut(lpdis->hDC,
                  lpdis->rcItem.left + xTextOffset,
                  lpdis->rcItem.top + yTextOffset,
                  (LPTSTR)szMsg, lstrlen((LPTSTR)szMsg));

         //
         // if item is selected, draw a focus rect
         if (lpdis->itemState & ODS_FOCUS) {
            DrawFocusRect(lpdis->hDC, (LPRECT)&(lpdis->rcItem));
         }
      }  // var scope
      break;

   case WM_COMMAND:
      switch ((int)LOWORD(wParam)) {
      case LB_SNDS:
         // if new selection in listbox
         if (HIWORD(wParam) == LBN_SELCHANGE) {
            int iSeln, ilen;

            // get new selection if any
            iSeln = (int)SendDlgItemMessage(hDlg, LB_SNDS, LB_GETCURSEL, 0, 0);
            if (LB_ERR == iSeln)
               break;               // no selection EXIT

            // get selection text
            SendDlgItemMessage(hDlg, LB_SNDS, LB_GETTEXT,
                               (WPARAM)iSeln, (LPARAM)(LPTSTR)szMsg);

            // update global current filename string
            GetFileStr(szCurPreviewFile, szMsg);

            // reset dialog static text of filename string
            SetDlgItemFile(hDlg, TXT_FILENAME, szCurPreviewFile);
            // and scroll end into view
            ilen = lstrlen((LPTSTR)szCurPreviewFile);
            SendDlgItemMessage(hDlg, TXT_FILENAME, EM_SETSEL,
                               (WPARAM)0, MAKELPARAM(-1, ilen));

            // update snd file icon
            if (hbmpCurSnd) DeleteObject(hbmpCurSnd);
            hbmpCurSnd = NULL;
            if (*szCurPreviewFile)
               hbmpCurSnd = GetSoundBitmap((LPTSTR)szCurPreviewFile);

            // set snd file bmp to static
            if (hbmpCurSnd) {
               SendDlgItemMessage(hDlg, RECT_PREVIEW, STM_SETIMAGE,
                                  (WPARAM)IMAGE_BITMAP, (LPARAM)hbmpCurSnd);
            }
            else {
               // else need to clear it to empty
               SendDlgItemMessage(hDlg, RECT_PREVIEW, STM_SETIMAGE,
                                  (WPARAM)NULL, (LPARAM)NULL);
               InvalidateRect(hDlg, (LPRECT)&rPreview, TRUE);
               #ifdef SHOULDAWORKED
               InvalidateRect(GetDlgItem(hDlg, RECT_PREVIEW), (LPRECT)NULL, TRUE);
               UpdateWindow(GetDlgItem(hDlg, RECT_PREVIEW));
               #endif
            }

            // update play button
            EnableWindow(GetDlgItem(hDlg, PB_PLAY), *szCurPreviewFile &&
                         bSoundExists[iSeln] && gfWaveExists);
         }

         // if just a selection, we're done here
         if (HIWORD(wParam) != LBN_DBLCLK)
            break;

         // else double-click means fall through and play
         bDoubleClick = TRUE;

      case PB_PLAY:
         if (((HIWORD(wParam) == BN_CLICKED) || bDoubleClick) && gfWaveExists) {
            int iSeln;

            // check that sound file exists
            iSeln = (int)SendDlgItemMessage(hDlg, LB_SNDS, LB_GETCURSEL, 0, 0);
            if (!bSoundExists[iSeln])
               break;

            if (*szCurPreviewFile) {
               // disable and wait
               EnableWindow((HWND)lParam, FALSE);
               WaitCursor();

               PlaySound((LPTSTR)szCurPreviewFile, NULL, SND_SYNC | SND_FILENAME);

               // reenable and normal
               EnableWindow((HWND)lParam, TRUE);
               NormalCursor();
               SetFocus((HWND)lParam);
            }
         }
         break;
      }
      break;

   case WM_NOTIFY:
      switch ( ((NMHDR FAR *)lParam)->code) {

      // OK or Apply button pressed
      case PSN_APPLY:
         // apply any changes made on this page

         SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR); // accept changes
         break;

      // cancel button pressed
      case PSN_RESET:
         // don't accept any of the changes made on this page
         break;

      case PSN_SETACTIVE:
         break;
      case PSN_KILLACTIVE:
         // need to say that it's OK by us to lose the activation
         SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);   // OK to kill focus now
         break;

      }
      break;

   case WM_HELP:
      {
         LPHELPINFO lphi;
         lphi = (LPHELPINFO)lParam;
         if (lphi->iContextType == HELPINFO_WINDOW) {
            WinHelp(lphi->hItemHandle, (LPTSTR)szHelpFile, HELP_WM_HELP,
                  (DWORD_PTR)((POPUP_HELP_ARRAY FAR *)phaSndsDlg));
         }
      }
      break;

   case WM_CONTEXTMENU:
      WinHelp((HWND)wParam, (LPTSTR)szHelpFile, HELP_CONTEXTMENU,
             (DWORD_PTR)((POPUP_HELP_ARRAY FAR *)phaSndsDlg));
      break;

   default:
      return(FALSE);                // didn't process message
      break;
   }

   return TRUE;                     // processed message
}

HBITMAP PASCAL GetSoundBitmap(LPTSTR lpszFile)
{
   HANDLE  hDib = NULL;
   HMMIO   hmmio = NULL;
   TCHAR   szValue[MAX_MSGLEN+1];
//   HPALETTE hPal;
   HBITMAP hbmpRet = NULL;
		
   if (!lpszFile || !*lpszFile)
      return ((HBITMAP)NULL);


   /* Open the file */
   hmmio = mmioOpen(lpszFile, NULL, MMIO_ALLOCBUF | MMIO_READ);

   // get the DIB
   if (hmmio) {
      szValue[0] = TEXT('\0');
      hDib = GetRiffAll(hmmio, szValue, sizeof(szValue));
      mmioClose(hmmio, 0);		
   }

   if (hDib) {
      HPALETTE hPal;

      hPal = bmfCreateDIBPalette(hDib);
      if (hPal)
      {
          hbmpRet = bmfBitmapFromDIB(hDib, hPal);   // hPal can be null
          DeleteObject(hPal);
      }

      GlobalFree(hDib);
   }

   return(hbmpRet);
}

// guessing that this is the right addition
#define FOURCC_DISP     mmioFOURCC('D', 'I', 'S', 'P')
#define FOURCC_INFO     mmioFOURCC('I', 'N', 'F', 'O')
#define FOURCC_INAM     mmioFOURCC('I', 'N', 'A', 'M')

HANDLE PASCAL GetRiffAll(HMMIO hmmio, LPTSTR szText, int iLen)
{
    MMCKINFO    ck;
    MMCKINFO    ckINFO;
    MMCKINFO    ckRIFF;
    HANDLE	h = NULL;
    LONG        lSize;
    DWORD       dw;

    mmioSeek(hmmio, 0, SEEK_SET);

    /* descend the input file into the RIFF chunk */
    if (mmioDescend(hmmio, &ckRIFF, NULL, 0) != 0)
        goto error;

    if (ckRIFF.ckid != FOURCC_RIFF)
        goto error;

    while (!mmioDescend(hmmio, &ck, &ckRIFF, 0))
    {
        if (ck.ckid == FOURCC_DISP)
        {
            /* Read dword into dw, break if read unsuccessful */
            if (mmioRead(hmmio, (LPVOID)&dw, sizeof(dw)) != sizeof(dw))
                goto error;

            /* Find out how much memory to allocate */
            lSize = ck.cksize - sizeof(dw);

            if ((int)dw == CF_DIB && h == NULL)
            {
                /* get a handle to memory to hold the description and
					lock it down */
				
                if ((h = GlobalAlloc(GHND, lSize+4)) == NULL)
                    goto error;

                if (mmioRead(hmmio, GlobalLock(h), lSize) != lSize)
                    goto error;
            }
            else if ((int)dw == CF_TEXT && szText[0] == 0)
            {
                if (lSize > iLen-1)
                    lSize = iLen-1;

                szText[lSize] = 0;
                if (mmioRead(hmmio, (LPVOID)szText, lSize) != lSize)
                    goto error;
            }
        }
        else if (ck.ckid    == FOURCC_LIST &&
                 ck.fccType == FOURCC_INFO &&
                 szText[0]  == 0)
        {
            while (!mmioDescend(hmmio, &ckINFO, &ck, 0))
            {
                switch (ckINFO.ckid)
                {
                    case FOURCC_INAM:
//                  case FOURCC_ISBJ:

                        lSize = ck.cksize;

                        if (lSize > iLen-1)
                            lSize = iLen-1;

                        szText[lSize] = 0;
                        if (mmioRead(hmmio, (LPVOID)szText, lSize) != lSize)
                            goto error;

                        break;
                }

                if (mmioAscend(hmmio, &ckINFO, 0))
                    break;
            }
        }

        //
        // if we have both a picture and a title, then exit.
        //
        if (h != NULL && szText[0] != 0)
            break;

        /* Ascend so that we can descend into next chunk
         */
        if (mmioAscend(hmmio, &ck, 0))
            break;
    }

    goto exit;

error:
    if (h)
        GlobalFree(h);
    h = NULL;

exit:
    return h;
}


/***************************************************************************
 *
 *  FUNCTION   :bmfCreateDIBPalette(HANDLE hDib)
 *
 *  PURPOSE    :Creates a palette suitable for displaying hDib.
 *
 *  RETURNS    :A handle to the palette if successful, NULL otherwise.
 *
 ****************************************************************************/

HPALETTE WINAPI bmfCreateDIBPalette (HANDLE hDib)
{
    HPALETTE            hPal;
    LPBITMAPINFOHEADER  lpbi;

    if (!hDib)
	return NULL;    //bail out if handle is invalid

    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDib);
    if (!lpbi)
	return NULL;

    hPal = CreateBIPalette(lpbi);
    GlobalUnlock(hDib);
    return hPal;
}

/***************************************************************************
 *
 *  FUNCTION   :CreateBIPalette(LPBITMAPINFOHEADER lpbi)
 *
 *  PURPOSE    :Given a Pointer to a BITMAPINFO struct will create a
 *              a GDI palette object from the color table.
 *
 *  RETURNS    :A handle to the palette if successful, NULL otherwise.
 *
 ****************************************************************************/

HPALETTE CreateBIPalette (LPBITMAPINFOHEADER lpbi)
{
    LPLOGPALETTE        pPal;
    HPALETTE            hPal = NULL;
    WORD                nNumColors;
    BYTE                red;
    BYTE                green;
    BYTE                blue;
    int                 i;
    RGBQUAD             FAR *pRgb;
    HANDLE hMem;

    if (!lpbi)
	return NULL;

    if (lpbi->biSize != sizeof(BITMAPINFOHEADER))
	return NULL;

    /* Get a pointer to the color table and the number of colors in it */
    pRgb = (RGBQUAD FAR *)((LPTSTR)lpbi + (WORD)lpbi->biSize);
    nNumColors = NumDIBColors(lpbi);

    if (nNumColors)
    {
	/* Allocate for the logical palette structure */
	hMem = GlobalAlloc(GMEM_MOVEABLE,
	sizeof(LOGPALETTE) + nNumColors * sizeof(PALETTEENTRY));
	if (!hMem)
	    return NULL;
	pPal = (LPLOGPALETTE)GlobalLock(hMem);
	if (!pPal)
	{
	    GlobalFree(hMem);
	    return NULL;
	}

	pPal->palNumEntries = nNumColors;
	pPal->palVersion    = PALVERSION;

	/* Fill in the palette entries from the DIB color table and
	 * create a logical color palette.
	 */
	for (i = 0; (unsigned)i < nNumColors; i++)
	{
	    pPal->palPalEntry[i].peRed   = pRgb[i].rgbRed;
	    pPal->palPalEntry[i].peGreen = pRgb[i].rgbGreen;
	    pPal->palPalEntry[i].peBlue  = pRgb[i].rgbBlue;
	    pPal->palPalEntry[i].peFlags = (BYTE)0;
	}
	hPal = CreatePalette(pPal);
	/* note that a NULL return value for the above CreatePalette call
	 * is acceptable, since this value will be returned, and is not
	 * used again here
	 */
	GlobalUnlock(hMem);
	GlobalFree(hMem);
    }
    else if (lpbi->biBitCount == 24)
    {
	/* A 24 bitcount DIB has no color table entries so, set the number of
	 * to the maximum value (256).
	 */
	nNumColors = MAXPALETTE;
	hMem =GlobalAlloc(GMEM_MOVEABLE,
	sizeof(LOGPALETTE) + nNumColors * sizeof(PALETTEENTRY));
	if (!hMem)
	    return NULL;
	pPal = (LPLOGPALETTE)GlobalLock(hMem);
	if (!pPal)
	{
	    GlobalFree(hMem);
	    return NULL;
	}

	pPal->palNumEntries = nNumColors;
	pPal->palVersion    = PALVERSION;

	red = green = blue = 0;

	/* Generate 256 (= 8*8*4) RGB combinations to fill the palette
	 * entries.
	 */
	for (i = 0; (unsigned)i < pPal->palNumEntries; i++)
	{
	    pPal->palPalEntry[i].peRed   = red;
	    pPal->palPalEntry[i].peGreen = green;
	    pPal->palPalEntry[i].peBlue  = blue;
	    pPal->palPalEntry[i].peFlags = (BYTE)0;

	    if (!(red += 32))
	    if (!(green += 32))
		blue += 64;
	}
	hPal = CreatePalette(pPal);
	/* note that a NULL return value for the above CreatePalette call
	 * is acceptable, since this value will be returned, and is not
	 * used again here
	 */
	GlobalUnlock(hMem);
	GlobalFree(hMem);
    }
    return hPal;
}

/***************************************************************************
 *
 *  FUNCTION   :NumDIBColors(VOID FAR * pv)
 *
 *  PURPOSE    :Determines the number of colors in the DIB by looking at
 *              the BitCount field in the info block.
 *              For use only internal to DLL.
 *
 *  RETURNS    :The number of colors in the DIB.
 *
 ****************************************************************************/

WORD NumDIBColors (VOID FAR * pv)
{
    int                 bits;
    LPBITMAPINFOHEADER  lpbi;
    LPBITMAPCOREHEADER  lpbc;

    lpbi = ((LPBITMAPINFOHEADER)pv);
    lpbc = ((LPBITMAPCOREHEADER)pv);

    /*  With the BITMAPINFO format headers, the size of the palette
     *  is in biClrUsed, whereas in the BITMAPCORE - style headers, it
     *  is dependent on the bits per pixel ( = 2 raised to the power of
     *  bits/pixel).
     */
    if (lpbi->biSize != sizeof(BITMAPCOREHEADER))
    {
	if (lpbi->biClrUsed != 0)
	    return (WORD)lpbi->biClrUsed;
	bits = lpbi->biBitCount;
    }
    else
	bits = lpbc->bcBitCount;

    switch (bits)
    {
    case 1:
	return 2;
    case 4:
	return 16;
    case 8:
	return 256;
    default:
	/* A 24 bitcount DIB has no color table */
	return 0;
    }
}

/***************************************************************************
 *
 *  FUNCTION   :bmfBitmapFromDIB(HANDLE hDib, HPALETTE hPal)
 *
 *  PURPOSE    :Converts DIB information into a device-dependent BITMAP
 *              suitable for display on the current display device.  hDib is
 *              a global handle to a memory block containing the DIB
 *              information in CF_DIB format.  hPal is a handle to a palette
 *              to be used for displaying the bitmap.  If hPal is NULL, the
 *              default system palette is used during the conversion.
 *
 *  RETURNS    :Returns a handle to a bitmap is successful, NULL otherwise.
 *
 *  HISTORY:
 *  92/08/29 -  BUG 2123: (w-markd)
 *              Check if DIB is has a valid size, and bail out if not.
 *              If no palette is passed in, try to create one.  If we
 *              create one, we must destroy it before we exit.
 *
 ****************************************************************************/

HBITMAP WINAPI bmfBitmapFromDIB(HANDLE hDib, HPALETTE hPal)
{
    LPBITMAPINFOHEADER  lpbi;
    HPALETTE            hPalT;
    HDC                 hdc;
    HBITMAP             hBmp;
    DWORD               dwSize;
    BOOL                bMadePalette = FALSE;

    if (!hDib)
	return NULL;    //bail out if handle is invalid

    /* BUG 2123: (w-markd)
    ** Check to see if we can get the size of the DIB.  If this call
    ** fails, bail out.
    */
    dwSize = bmfDIBSize(hDib);
    if (!dwSize)
	return NULL;

    lpbi = (VOID FAR *)GlobalLock(hDib);
    if (!lpbi)
	return NULL;

    /* prepare palette */
    /* BUG 2123: (w-markd)
    ** If the palette is NULL, we create one suitable for displaying
    ** the dib.
    */
    if (!hPal)
    {
	hPal = bmfCreateDIBPalette(hDib);
	if (!hPal)
	{
	    GlobalUnlock(hDib);
	    #ifdef V101
	    #else
	    bMadePalette = TRUE;
	    #endif
	    return NULL;
	}
	#ifdef V101
	/* BUGFIX: mikeroz 2123 - this flag was in the wrong place */
	bMadePalette = TRUE;
	#endif
    }
    hdc = GetDC(NULL);
    hPalT = SelectPalette(hdc,hPal,FALSE);
    RealizePalette(hdc);     // GDI Bug...????

    /* Create the bitmap.  Note that a return value of NULL is ok here */
    hBmp = CreateDIBitmap(hdc, (LPBITMAPINFOHEADER)lpbi, (LONG)CBM_INIT,
                          (LPSTR)lpbi + lpbi->biSize + PaletteSize(lpbi),
			  (LPBITMAPINFO)lpbi, DIB_RGB_COLORS );

    /* clean up and exit */
    /* BUG 2123: (w-markd)
    ** If we made the palette, we need to delete it.
    */
    if (bMadePalette)
	DeleteObject(SelectPalette(hdc,hPalT,FALSE));
    else
	SelectPalette(hdc,hPalT,FALSE);
    ReleaseDC(NULL,hdc);
    GlobalUnlock(hDib);
    return hBmp;
}

/***************************************************************************
 *
 *  FUNCTION   :bmfDIBSize(HANDLE hDIB)
 *
 *  PURPOSE    :Return the size of a DIB.
 *
 *  RETURNS    :DWORD with size of DIB, include BITMAPINFOHEADER and
 *              palette.  Returns 0 if failed.
 *
 *  HISTORY:
 *  92/08/13 -  BUG 1642: (w-markd)
 *              Added this function so Quick Recorder could find out the
 *              size of a DIB.
 *  92/08/29 -  BUG 2123: (w-markd)
 *              If the biSizeImage field of the structure we get is zero,
 *              then we have to calculate the size of the image ourselves.
 *              Also, after size is calculated, we bail out if the
 *              size we calculated is larger than the size of the global
 *              object, since this indicates that the structure data
 *              we used to calculate the size was invalid.
 *
 ****************************************************************************/

DWORD WINAPI bmfDIBSize(HANDLE hDIB)
{
    LPBITMAPINFOHEADER  lpbi;
    DWORD               dwSize;

    /* Lock down the handle, and cast to a LPBITMAPINFOHEADER
    ** so we can read the fields we need
    */
    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB);
    if (!lpbi)
	return 0;

    /* BUG 2123: (w-markd)
    ** Since the biSizeImage could be zero, we may have to calculate
    ** the size ourselves.
    */
    dwSize = lpbi->biSizeImage;
    if (dwSize == 0)
	dwSize = WIDTHBYTES((WORD)(lpbi->biWidth) * lpbi->biBitCount) *
	    lpbi->biHeight;


    /* The size of the DIB is the size of the BITMAPINFOHEADER
    ** structure (lpbi->biSize) plus the size of our palette plus
    ** the size of the actual data (calculated above).
    */
    dwSize += lpbi->biSize + (DWORD)PaletteSize(lpbi);

    /* BUG 2123: (w-markd)
    ** Check to see if the size is greater than the size
    ** of the global object.  If it is, the hDIB is corrupt.
    */
    GlobalUnlock(hDIB);
    if (dwSize > GlobalSize(hDIB))
	return 0;
    else
	return(dwSize);
}

/***************************************************************************
 *
 *  FUNCTION   :PaletteSize(VOID FAR * pv)
 *
 *  PURPOSE    :Calculates the palette size in bytes. If the info. block
 *              is of the BITMAPCOREHEADER type, the number of colors is
 *              multiplied by 3 to give the palette size, otherwise the
 *              number of colors is multiplied by 4.
 *
 *  RETURNS    :Palette size in number of bytes.
 *
 ****************************************************************************/

WORD PaletteSize (VOID FAR *pv)
{
    LPBITMAPINFOHEADER  lpbi;
    WORD                NumColors;

    lpbi      = (LPBITMAPINFOHEADER)pv;
    NumColors = NumDIBColors(lpbi);

    if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
	return (NumColors * sizeof(RGBTRIPLE));
    else
	return (NumColors * sizeof(RGBQUAD));
}



//
// globals for PicsPageProc

//int xCursor, yCursor;

TCHAR szRMineIcon[] = TEXT("CLSID\\{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\DefaultIcon");
TCHAR szRNhbdIcon[] = TEXT("CLSID\\{208D2C60-3AEA-1069-A2D7-08002B30309D}\\DefaultIcon");
TCHAR szRTrashIcon[] = TEXT("CLSID\\{645FF040-5081-101B-9F08-00AA002F954E}\\DefaultIcon");
TCHAR szRMyDocsIcon[] = TEXT("CLSID\\{450D8FBA-AD25-11D0-98A8-0800361B1103}\\DefaultIcon");
TCHAR szCUMineIcon[] = TEXT("Software\\Classes\\CLSID\\{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\DefaultIcon");
TCHAR szCUNhbdIcon[] = TEXT("Software\\Classes\\CLSID\\{208D2C60-3AEA-1069-A2D7-08002B30309D}\\DefaultIcon");
TCHAR szCUTrashIcon[] = TEXT("Software\\Classes\\CLSID\\{645FF040-5081-101B-9F08-00AA002F954E}\\DefaultIcon");
TCHAR szCUMyDocsIcon[] = TEXT("Software\\Classes\\CLSID\\{450D8FBA-AD25-11D0-98A8-0800361B1103}\\DefaultIcon");
TCHAR szTrashFull[] = TEXT("full");
TCHAR szTrashEmpty[] = TEXT("empty");

INT_PTR FAR PASCAL PicsPageProc(hDlg, message, wParam, lParam)
HWND hDlg;
UINT message;
WPARAM wParam;
LPARAM lParam;
{
   switch (message) {

   // set up listbox, initial selection, etc.
   case WM_INITDIALOG:
      {  // var scope
         extern FROST_SUBKEY fsRoot[]; // for theme file/registry keys
         extern FROST_SUBKEY fsCUIcons[]; // for theme file/registry keys
         extern TCHAR c_szSoftwareClassesFmt[]; // for NT reg path/keys.h
         int iter;
         int iRet;
         HWND hText, hLBox;
         RECT rText;
         TCHAR szDispStr[MAX_STRLEN+1];
         extern TCHAR szCP_DT[];
         extern TCHAR szWP[];
         extern TCHAR szDT[];
         extern TCHAR szSS_Section[];
         extern TCHAR szSS_Key[];
         extern TCHAR szSS_File[];
         TCHAR szNTReg[MAX_PATH];

         //
         // get metrics for drawitem size
         hText = GetDlgItem(hDlg, TXT_FILENAME);      // 12 dialog box units high
         GetWindowRect(hText, (LPRECT)&rText);
         iItemHeight = ((rText.bottom - rText.top) * 8) / 12;  // dialog font height
         xTextOffset = (iItemHeight * 3) / 2;         // proportional spacing
         Assert(iItemHeight > 0, TEXT("didn't get positive text height for preview listbox!\n"));

         #if 0    // to do own drawing for wallpaper and scr saver?
         // other metrics, etc.
         xCursor = GetSystemMetrics(SM_CXCURSOR);
         yCursor = GetSystemMetrics(SM_CYCURSOR);
         //
         // save away preview rect area
         GetWindowRect(GetDlgItem(hDlg, RECT_PREVIEW), (LPRECT)&rPreview);
         GetWindowRect(hDlg, (LPRECT)&rText);
         OffsetRect((LPRECT)&rPreview, -rText.left, -rText.top);
         DestroyWindow(GetDlgItem(hDlg, RECT_PREVIEW));
         #endif

         //
         // init the listbox with combined strings

         // init
         hLBox = GetDlgItem(hDlg, LB_PICS);

         // unlike the ptrs and snds, have to do each item by hand here
         // since they are three different types (actually four ways of
         // retrieving associated file

         //
         // WALLPAPER BITMAP

         // get display string
         LoadString(hInstApp, STR_PIC_WALL,
                    (LPTSTR)szDispStr, MAX_STRLEN);
                    // CPLs don't check for success on LoadString in INITDIALOG, so OK!?

         // get filename if any
         if (bThemed) {             // get from theme
            GetPrivateProfileString((LPTSTR)szCP_DT, (LPTSTR)szWP,
                                    (LPTSTR)szNULL,
                                    (LPTSTR)szMsg, MAX_MSGLEN,
                                    (LPTSTR)szCurThemeFile);
            // expand filename string as necessary
            InstantiatePath((LPTSTR)szMsg, MAX_MSGLEN);
         }
         else {                     // get from system
            // If ActiveDesktop is on we should query AD for this
            // setting instead of reading from the registry.
            if (IsActiveDesktopOn()) {
               if (!GetADWallpaper(szMsg)) {
                  // Failed to read AD setting so get it from the registry
                  GetRegString(HKEY_CURRENT_USER, szCP_DT, szWP,
                                        szNULL, szMsg, MAX_MSGLEN);
               }
            }

            // ActiveDesktop is off so get the setting from the registry
            else {
               GetRegString(HKEY_CURRENT_USER, szCP_DT, szWP,
                                           szNULL, szMsg, MAX_MSGLEN);
            }

            // If this isn't an HTM or HTML wallpaper file then we
            // should extract the image title.
            if ((lstrcmpi(FindExtension(szMsg), TEXT(".htm")) != 0) &&
                (lstrcmpi(FindExtension(szMsg), TEXT(".html")) != 0)) {

                // Not an HTM/L file so extract the image title
                GetImageTitle(szMsg, szMsg, MAX_MSGLEN);
            }
         }

         // combine strings into data string to load up in
         // owner-draw hasstrings listbox!
         CreateDataStr((LPTSTR)pValue, (LPTSTR)szDispStr, (LPTSTR)szMsg);

         // now, finally, go ahead and assign string to listbox
         SendMessage(hLBox, LB_ADDSTRING, 0, (LPARAM)(LPTSTR)pValue);

         //
         // MY COMPUTER ICON

         LoadString(hInstApp, STR_PIC_MYCOMP,
                    (LPTSTR)szDispStr, MAX_STRLEN);
                    // CPLs don't check for success on LoadString in INITDIALOG, so OK!?

         // get filename if any
         if (bThemed) {             // get from theme
            // Get the CURRENT_USER My Computer icon setting
            GetPrivateProfileString((LPTSTR)szCUMineIcon, (LPTSTR)FROST_DEFSTR,
                                    (LPTSTR)szNULL,
                                    (LPTSTR)szMsg, MAX_MSGLEN,
                                    (LPTSTR)szCurThemeFile);

            // If the string is NULL, try the "old" style Win95
            // CLASSES_ROOT setting instead
            if (!*szMsg) {
               GetPrivateProfileString((LPTSTR)szRMineIcon,
                                       (LPTSTR)FROST_DEFSTR,
                                       (LPTSTR)szNULL,
                                       (LPTSTR)szMsg, MAX_MSGLEN,
                                       (LPTSTR)szCurThemeFile);
            }

            // expand filename string as necessary
            InstantiatePath((LPTSTR)szMsg, MAX_MSGLEN);
         }
         else {                     // get from system
            // First try reading from the appropriate CURRENT_USER
            // section for this platform.

            szMsg[0] = TEXT('\0');

            if (IsPlatformNT())
            {
               lstrcpy(szNTReg, c_szSoftwareClassesFmt);
               lstrcat(szNTReg, szRMineIcon);
               HandGet(HKEY_CURRENT_USER,
                       (LPTSTR)szNTReg,
                       (LPTSTR)szNULL,  // null string for default value
                       (LPTSTR)szMsg);
            }
            else // Not NT
            {
               HandGet(HKEY_CURRENT_USER,
                       (LPTSTR)szCUMineIcon,
                       (LPTSTR)szNULL,  // null string for default value
                       (LPTSTR)szMsg);
            }

            // If we didn't get a good string from CURRENT_USER branch
            // try the CLASSES_ROOT branch instead.

            if (!*szMsg) {
               HandGet(HKEY_CLASSES_ROOT,
                       (LPTSTR)szRMineIcon,
                       (LPTSTR)szNULL,  // null string for default value
                       (LPTSTR)szMsg);
            }
         }

         InstantiatePath((LPTSTR)szMsg, MAX_MSGLEN);

         // combine strings into data string to load up in
         // owner-draw hasstrings listbox!
         CreateDataStr((LPTSTR)pValue, (LPTSTR)szDispStr, (LPTSTR)szMsg);

         // now, finally, go ahead and assign string to listbox
         SendMessage(hLBox, LB_ADDSTRING, 0, (LPARAM)(LPTSTR)pValue);

         //
         // NETWORK NHBD ICON

         LoadString(hInstApp, STR_PIC_NETHOOD,
                    (LPTSTR)szDispStr, MAX_STRLEN);
                    // CPLs don't check for success on LoadString in INITDIALOG, so OK!?

         // get filename if any
         if (bThemed) {             // get from theme
            // Get the CURRENT_USER Net Neighborhood icon setting
            GetPrivateProfileString((LPTSTR)szCUNhbdIcon, (LPTSTR)FROST_DEFSTR,
                                    (LPTSTR)szNULL,
                                    (LPTSTR)szMsg, MAX_MSGLEN,
                                    (LPTSTR)szCurThemeFile);

            // If the string is NULL, try the "old" style Win95
            // CLASSES_ROOT setting instead
            if (!*szMsg) {
               GetPrivateProfileString((LPTSTR)szRNhbdIcon,
                                       (LPTSTR)FROST_DEFSTR,
                                       (LPTSTR)szNULL,
                                       (LPTSTR)szMsg, MAX_MSGLEN,
                                       (LPTSTR)szCurThemeFile);
            }

            // expand filename string as necessary
            InstantiatePath((LPTSTR)szMsg, MAX_MSGLEN);
         }
         else {                     // get from system
            // First try reading from the appropriate CURRENT_USER
            // section for this platform.
            szMsg[0] = TEXT('\0');

            if (IsPlatformNT())
            {
               lstrcpy(szNTReg, c_szSoftwareClassesFmt);
               lstrcat(szNTReg, szRNhbdIcon);
               HandGet(HKEY_CURRENT_USER,
                       (LPTSTR)szNTReg,
                       (LPTSTR)szNULL,  // null string for default value
                       (LPTSTR)szMsg);
            }
            else  // Not NT
            {
               HandGet(HKEY_CURRENT_USER,
                       (LPTSTR)szCUNhbdIcon,
                       (LPTSTR)szNULL,  // null string for default value
                       (LPTSTR)szMsg);
            }

            // If we didn't get a good string from CURRENT_USER branch
            // try the CLASSES_ROOT branch instead.

            if (!*szMsg) {
               HandGet(HKEY_CLASSES_ROOT,
                       (LPTSTR)szRNhbdIcon,
                       (LPTSTR)szNULL,  // null string for default value
                       (LPTSTR)szMsg);
            }
         }

         InstantiatePath((LPTSTR)szMsg, MAX_MSGLEN);

         // combine strings into data string to load up in
         // owner-draw hasstrings listbox!
         CreateDataStr((LPTSTR)pValue, (LPTSTR)szDispStr, (LPTSTR)szMsg);

         // now, finally, go ahead and assign string to listbox
         SendMessage(hLBox, LB_ADDSTRING, 0, (LPARAM)(LPTSTR)pValue);

         //
         // RECYCLE BIN FULL

         LoadString(hInstApp, STR_PIC_RECBINFULL,
                    (LPTSTR)szDispStr, MAX_STRLEN);
                    // CPLs don't check for success on LoadString in INITDIALOG, so OK!?

         // get filename if any
         if (bThemed) {             // get from theme
            // Get the CURRENT_USER Recycle Bin Full icon setting
            GetPrivateProfileString((LPTSTR)szCUTrashIcon, (LPTSTR)szTrashFull,
                                    (LPTSTR)szNULL,
                                    (LPTSTR)szMsg, MAX_MSGLEN,
                                    (LPTSTR)szCurThemeFile);

            // If the string is NULL, try the "old" style Win95
            // CLASSES_ROOT setting instead
            if (!*szMsg) {
               GetPrivateProfileString((LPTSTR)szRTrashIcon,
                                       (LPTSTR)szTrashFull,
                                       (LPTSTR)szNULL,
                                       (LPTSTR)szMsg, MAX_MSGLEN,
                                       (LPTSTR)szCurThemeFile);
            }

            // expand filename string as necessary
            InstantiatePath((LPTSTR)szMsg, MAX_MSGLEN);
         }
         else {                     // get from system
            // First try reading from the appropriate CURRENT_USER
            // section for this platform.
            szMsg[0] = TEXT('\0');

            if (IsPlatformNT())
            {
               lstrcpy(szNTReg, c_szSoftwareClassesFmt);
               lstrcat(szNTReg, szRTrashIcon);
               HandGet(HKEY_CURRENT_USER,
                       (LPTSTR)szNTReg,
                       (LPTSTR)szTrashFull,
                       (LPTSTR)szMsg);
            }
            else // Not NT
            {
               HandGet(HKEY_CURRENT_USER,
                       (LPTSTR)szCUTrashIcon,
                       (LPTSTR)szTrashFull,
                       (LPTSTR)szMsg);
            }

            // If we didn't get a good string from CURRENT_USER branch
            // try the CLASSES_ROOT branch instead.

            if (!*szMsg) {
               HandGet(HKEY_CLASSES_ROOT,
                       (LPTSTR)szRTrashIcon,
                       (LPTSTR)szTrashFull,
                       (LPTSTR)szMsg);
            }
         }

         InstantiatePath((LPTSTR)szMsg, MAX_MSGLEN);

         // combine strings into data string to load up in
         // owner-draw hasstrings listbox!
         CreateDataStr((LPTSTR)pValue, (LPTSTR)szDispStr, (LPTSTR)szMsg);

         // now, finally, go ahead and assign string to listbox
         SendMessage(hLBox, LB_ADDSTRING, 0, (LPARAM)(LPTSTR)pValue);

         //
         // RECYCLE BIN EMPTY

         LoadString(hInstApp, STR_PIC_RECBINEMPTY,
                    (LPTSTR)szDispStr, MAX_STRLEN);
                    // CPLs don't check for success on LoadString in INITDIALOG, so OK!?

         // get filename if any
         if (bThemed) {             // get from theme
            // Get the CURRENT_USER Recycle Bin Empty icon setting
            GetPrivateProfileString((LPTSTR)szCUTrashIcon,
                                    (LPTSTR)szTrashEmpty,
                                    (LPTSTR)szNULL,
                                    (LPTSTR)szMsg, MAX_MSGLEN,
                                    (LPTSTR)szCurThemeFile);

            // If the string is NULL, try the "old" style Win95
            // CLASSES_ROOT setting instead
            if (!*szMsg) {
               GetPrivateProfileString((LPTSTR)szRTrashIcon,
                                       (LPTSTR)szTrashEmpty,
                                       (LPTSTR)szNULL,
                                       (LPTSTR)szMsg, MAX_MSGLEN,
                                       (LPTSTR)szCurThemeFile);
            }

            // expand filename string as necessary
            InstantiatePath((LPTSTR)szMsg, MAX_MSGLEN);
         }
         else {                     // get from system
            // First try reading from the appropriate CURRENT_USER
            // section for this platform.
            szMsg[0] = TEXT('\0');

            if (IsPlatformNT())
            {
               lstrcpy(szNTReg, c_szSoftwareClassesFmt);
               lstrcat(szNTReg, szRTrashIcon);
               HandGet(HKEY_CURRENT_USER,
                       (LPTSTR)szNTReg,
                       (LPTSTR)szTrashEmpty,
                       (LPTSTR)szMsg);
            }
            else // Not NT
            {
               HandGet(HKEY_CURRENT_USER,
                       (LPTSTR)szCUTrashIcon,
                       (LPTSTR)szTrashEmpty,
                       (LPTSTR)szMsg);
            }

            // If we didn't get a good string from CURRENT_USER branch
            // try the CLASSES_ROOT branch instead.

            if (!*szMsg) {
               HandGet(HKEY_CLASSES_ROOT,
                       (LPTSTR)szRTrashIcon,
                       (LPTSTR)szTrashEmpty,
                       (LPTSTR)szMsg);
            }
         }

         InstantiatePath((LPTSTR)szMsg, MAX_MSGLEN);

         // combine strings into data string to load up in
         // owner-draw hasstrings listbox!
         CreateDataStr((LPTSTR)pValue, (LPTSTR)szDispStr, (LPTSTR)szMsg);

         // now, finally, go ahead and assign string to listbox
         SendMessage(hLBox, LB_ADDSTRING, 0, (LPARAM)(LPTSTR)pValue);

         //
         // MY DOCUMENTS ICON

         LoadString(hInstApp, STR_PIC_MYDOCS,
                    (LPTSTR)szDispStr, MAX_STRLEN);
                    // CPLs don't check for success on LoadString in INITDIALOG, so OK!?

         // get filename if any
         if (bThemed) {             // get from theme
            // Get the CURRENT_USER My Documetns icon setting
            GetPrivateProfileString((LPTSTR)szCUMyDocsIcon, (LPTSTR)FROST_DEFSTR,
                                    (LPTSTR)szNULL,
                                    (LPTSTR)szMsg, MAX_MSGLEN,
                                    (LPTSTR)szCurThemeFile);

            // If the string is NULL, try the "old" style Win95
            // CLASSES_ROOT setting instead
            if (!*szMsg) {
               GetPrivateProfileString((LPTSTR)szRMyDocsIcon,
                                       (LPTSTR)FROST_DEFSTR,
                                       (LPTSTR)szNULL,
                                       (LPTSTR)szMsg, MAX_MSGLEN,
                                       (LPTSTR)szCurThemeFile);
            }

            // expand filename string as necessary
            InstantiatePath((LPTSTR)szMsg, MAX_MSGLEN);
         }
         else {                     // get from system
            // First try reading from the appropriate CURRENT_USER
            // section for this platform.
            szMsg[0] = TEXT('\0');

            if (IsPlatformNT())
            {
               lstrcpy(szNTReg, c_szSoftwareClassesFmt);
               lstrcat(szNTReg, szRMyDocsIcon);
               HandGet(HKEY_CURRENT_USER,
                       (LPTSTR)szNTReg,
                       (LPTSTR)szNULL,  // null string for default value
                       (LPTSTR)szMsg);
            }
            else // Not NT
            {
               HandGet(HKEY_CURRENT_USER,
                       (LPTSTR)szCUMyDocsIcon,
                       (LPTSTR)szNULL,  // null string for default value
                       (LPTSTR)szMsg);
            }

            // If we didn't get a good string from CURRENT_USER branch
            // try the CLASSES_ROOT branch instead.

            if (!*szMsg) {
               HandGet(HKEY_CLASSES_ROOT,
                       (LPTSTR)szRMyDocsIcon,
                       (LPTSTR)szNULL,  // null string for default value
                       (LPTSTR)szMsg);
            }
         }

         InstantiatePath((LPTSTR)szMsg, MAX_MSGLEN);

         // combine strings into data string to load up in
         // owner-draw hasstrings listbox!
         CreateDataStr((LPTSTR)pValue, (LPTSTR)szDispStr, (LPTSTR)szMsg);

         // now, finally, go ahead and assign string to listbox
         SendMessage(hLBox, LB_ADDSTRING, 0, (LPARAM)(LPTSTR)pValue);

         //
         // SCREEN SAVER

         LoadString(hInstApp, STR_PIC_SCRSAV,
                    (LPTSTR)szDispStr, MAX_STRLEN);
                    // CPLs don't check for success on LoadString in INITDIALOG, so OK!?

         // get filename if any
         if (bThemed) {             // get from theme
            GetPrivateProfileString((LPTSTR)szSS_Section, (LPTSTR)szSS_Key,
                                    (LPTSTR)szNULL,
                                    (LPTSTR)szMsg, MAX_MSGLEN,
                                    (LPTSTR)szCurThemeFile);
            // expand filename string as necessary
            InstantiatePath((LPTSTR)szMsg, MAX_MSGLEN);

            // For NT with old (Plus95/98) theme files that refer to
            // windows\system we should update string to say system32
            if (IsPlatformNT()) ConfirmFile(szMsg, TRUE);
         }
         else {                     // get from system
            GetPrivateProfileString((LPTSTR)szSS_Section, (LPTSTR)szSS_Key,
                                    (LPTSTR)szNULL,
                                    (LPTSTR)szMsg, MAX_MSGLEN,
                                    (LPTSTR)szSS_File);
            // make into nice long filename for display
            if (FilenameToLong(szMsg, (LPTSTR)pValue))
               lstrcpy(FileFromPath(szMsg), (LPTSTR)pValue);
         }

         // combine strings into data string to load up in
         // owner-draw hasstrings listbox!
         CreateDataStr((LPTSTR)pValue, (LPTSTR)szDispStr, (LPTSTR)szMsg);

         // now, finally, go ahead and assign string to listbox
         SendMessage(hLBox, LB_ADDSTRING, 0, (LPARAM)(LPTSTR)pValue);

         //
         // check them all for file existence. have to do here, no prev loop
         //
         for (iter = 0; iter < MAX_ETC_ITEMS; iter++) {
            // get this item's listbox string
            iRet = (int) SendMessage(hLBox, LB_GETTEXT, iter, (LPARAM)(LPTSTR)szMsg);
            if (iRet == LB_ERR)
               break;               // past end of listbox items CONTINUE

            // get the filename assoc with this item, if any
            GetFileStr((LPTSTR)pValue, (LPTSTR)szMsg);

            // store whether the file exists
            bVisualExists[iter] = *pValue &&
                  (CF_NOTFOUND != ConfirmFile((LPTSTR)pValue, FALSE));
         }


         //
         // setup initial focus conditions
         SetFocus(hLBox);
         SendMessage(hLBox, LB_SETCURSEL, 0, 0);

         // need to ensure it gets initial update of cur file
         PostMessage(hDlg, WM_COMMAND, MAKEWPARAM(LB_PICS, LBN_SELCHANGE),
                                       MAKELPARAM(0, 0) );

      }  // var scope
      break;

   case WM_MEASUREITEM:
      {
         LPMEASUREITEMSTRUCT lpmis;

         /* Set the height of the list box items. */
         lpmis = (LPMEASUREITEMSTRUCT) lParam;
//         lpmis->itemHeight = iItemHeight;
         lpmis->itemHeight = 0;     // DavidBa says they want these big default item hts
//            Assert(iItemHeight > 0, TEXT("set non-positive item height for preview listbox!\n"));
//            Assert(iItemHeight <= 0, TEXT("OK, set a positive item height for preview listbox!\n"));
      }
      break;

   case WM_DRAWITEM:
      { // var scope

         TEXTMETRIC tm;
         LPDRAWITEMSTRUCT lpdis;
         int yTextOffset;
         LPTSTR lpszFile;
         HDC hdcMem;
         HBITMAP hbmpOld;

         lpdis = (LPDRAWITEMSTRUCT) lParam;

         /* If there are no list box items, skip this message. */
         if (lpdis->itemID == -1) {
               break;
         }  // jdk: well, what about focus rect in empty lbox?

         //
         // Inits

         // get the filename assoc with this item, if any
         SendMessage(lpdis->hwndItem, LB_GETTEXT, lpdis->itemID,
                     (LPARAM)(LPTSTR)szMsg);
         GetDisplayStr((LPTSTR)szMsg, (LPTSTR)szMsg);   // Ok src and dst same
         // you now have "displaystr\0filename" in szMsg[]
         lpszFile = (LPTSTR)(szMsg + lstrlen((LPTSTR)szMsg) + 1);

         //
         // draw right background color
         if (lpdis->itemState & ODS_SELECTED) {

            // if item is selected, draw highlight background here
            FillRect(lpdis->hDC, (LPRECT)&(lpdis->rcItem),
               GetSysColorBrush(COLOR_HIGHLIGHT));

            // set text color to highlight text
            SetBkColor(lpdis->hDC, GetSysColor(COLOR_HIGHLIGHT));
            SetTextColor(lpdis->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
         }
         else {                  // not selected
            // need to do normal background fill to undo prev selection
            FillRect(lpdis->hDC, (LPRECT)&(lpdis->rcItem),
               GetSysColorBrush(COLOR_WINDOW));

            // set text color to foreground
            SetBkColor(lpdis->hDC, GetSysColor(COLOR_WINDOW));
            SetTextColor(lpdis->hDC, GetSysColor(COLOR_WINDOWTEXT));
         }

         // if there is a file associated with this item
         if (*lpszFile) {
            HBITMAP hbmpLeading;
            BITMAP bmLeading;

            //
            // find the right leading bitmap: checkmark or question mark
            if (bVisualExists[lpdis->itemID]) {
               hbmpLeading = hbmpCheck;
               bmLeading = bmCheck;
            }
            else {
               hbmpLeading = hbmpQ;
               bmLeading = bmQ;
            }

            //
            // paint in the leading bitmap!

            hdcMem = CreateCompatibleDC(lpdis->hDC);
            if (hdcMem)
            {
                hbmpOld = SelectObject(hdcMem, hbmpLeading);

                // if item height is less than bitmap height
                if (lpdis->rcItem.bottom - lpdis->rcItem.top < bmLeading.bmHeight)
                {
                   // stretch down bitmap size to fit
                   StretchBlt(lpdis->hDC,
                              lpdis->rcItem.left, lpdis->rcItem.top,
                              lpdis->rcItem.bottom - lpdis->rcItem.top,   // width = height
                              lpdis->rcItem.bottom - lpdis->rcItem.top,
                              hdcMem, 0, 0, bmLeading.bmWidth, bmLeading.bmHeight, SRCCOPY);
                }
                else // item height taller than checkmark bitmap
                {
                   // just center vertically
                   BitBlt(lpdis->hDC,
                          lpdis->rcItem.left,
                          lpdis->rcItem.top +
                            (lpdis->rcItem.bottom - lpdis->rcItem.top - bmLeading.bmHeight)/2,
                          bmLeading.bmWidth, bmLeading.bmHeight,
                          hdcMem, 0, 0, SRCCOPY);
                }

                SelectObject(hdcMem, hbmpOld);
                DeleteDC(hdcMem);
            }

// who cares
//               Assert(lpdis->rcItem.bottom - lpdis->rcItem.top == iItemHeight,
//                        TEXT("MEASUREITEM and DRAWITEM have different heights!\n"));
         }

         //
         // now draw the display string for this item

         // figure y offset to vert center text in draw item
         GetTextMetrics(lpdis->hDC, &tm);
         yTextOffset = (lpdis->rcItem.bottom - lpdis->rcItem.top - tm.tmHeight) / 2;
         Assert(yTextOffset >= 0, TEXT("negative text vert offset in DRAWITEM\n"));
         if (yTextOffset < 0)  yTextOffset = 0;

         // do the out
         SetBkMode(lpdis->hDC, TRANSPARENT);
         TextOut(lpdis->hDC,
                  lpdis->rcItem.left + xTextOffset,
                  lpdis->rcItem.top + yTextOffset,
                  (LPTSTR)szMsg, lstrlen((LPTSTR)szMsg));

         //
         // if item is selected, draw a focus rect
         if (lpdis->itemState & ODS_FOCUS) {
            DrawFocusRect(lpdis->hDC, (LPRECT)&(lpdis->rcItem));
         }
      }  // var scope
      break;

   case WM_COMMAND:
      switch ((int)LOWORD(wParam)) {
      case LB_PICS:
         // if new selection in listbox
         if (HIWORD(wParam) == LBN_SELCHANGE) {
            int iSeln, ilen;

            // get new selection if any
            iSeln = (int)SendDlgItemMessage(hDlg, LB_PICS, LB_GETCURSEL, 0, 0);
            if (LB_ERR == iSeln)
               break;               // no selection EXIT

            // get selection text
            SendDlgItemMessage(hDlg, LB_PICS, LB_GETTEXT,
                               (WPARAM)iSeln, (LPARAM)(LPTSTR)szMsg);

            // update global current filename string
            GetFileStr(szCurPreviewFile, szMsg);

            // reset dialog static text of filename string
            if (iSeln == SCRSAV_NDX) {
               // if you can get a long filename, then use it
               if (FilenameToLong((LPTSTR)szCurPreviewFile, (LPTSTR)szMsg))
                  lstrcpy(FileFromPath((LPTSTR)szCurPreviewFile), (LPTSTR)szMsg);
               SetDlgItemFile(hDlg, TXT_FILENAME, szCurPreviewFile);
            }
            else
               SetDlgItemFile(hDlg, TXT_FILENAME, szCurPreviewFile);
            // and scroll end into view
            ilen = lstrlen((LPTSTR)szCurPreviewFile);
            SendDlgItemMessage(hDlg, TXT_FILENAME, EM_SETSEL,
                               (WPARAM)0, MAKELPARAM(-1, ilen));

            //
            // Update Image
            //

            // init by destroying old
            if (hCurImage) DestroyCursor(hCurImage);
            hCurImage = NULL;

            // get new image...
            if (*szCurPreviewFile) {

               // ... unless the screen saver was selected
               if (iSeln != SCRSAV_NDX) {

                  int index;
                  LPTSTR lpszIndex;
#ifdef UNICODE
                  char szTempA[10];
#endif

                  // load as icon; works for bmps too

                  // init: copy global filename to destructive-OK location
                  lstrcpy((LPTSTR)szMsg, (LPTSTR)szCurPreviewFile);

                  // may have index into file. format: "file,index"
                  lpszIndex = FindChar((LPTSTR)szMsg, TEXT(','));
                  if (*lpszIndex) {             // if found a comma, then indexed icon
#ifdef UNICODE
                     wcstombs(szTempA, CharNext(lpszIndex), sizeof(szTempA));
                     index = latoi(szTempA);
#else
                     index = latoi(CharNext(lpszIndex));
#endif
                     *lpszIndex = 0;             // got index then null term filename in szMsg
                  }
                  else {                        // just straight icon file or no index
                     index = 0;
                  }

                  // OK, now you can do the load!
                  ExtractPlusColorIcon(szMsg, index, &((HICON)hCurImage), 0, 0);
               }

               // else SCREEN SAVER: just leave hCurImage NULL for blank
            }

            // set image to static ctl, even if null: null clears prev
            SendDlgItemMessage(hDlg, RECT_PREVIEW, STM_SETICON,
                               (WPARAM)hCurImage, (LPARAM)0);

            // if it's the screen saver, then start up the preview
            if (iSeln == SCRSAV_NDX) {
               // TBA
            }

            #if 0 // this is when we painted the cursor by ourself
            // force repaint of preview area
            InvalidateRect(hDlg, (LPRECT)&rPreview, TRUE);
            #endif
         }
         break;

      // case PB_TEST:
      //    break;
      }
      break;

   #if 0 // this is when we painted the cursor by ourself
   case WM_PAINT:
      BeginPaint(hDlg, &ps);

      //
      // preview area
      DrawEdge(ps.hdc, (LPRECT)&rPreview, EDGE_SUNKEN, BF_RECT);  // always edge
      // if there's a file to preview
      if (*szCurPreviewFile) {
         // add the cursor
         if (hCurCursor)
            DrawIcon(ps.hdc,
                     rPreview.left + (rPreview.right-rPreview.left-xCursor)/2,
                     rPreview.top + (rPreview.bottom-rPreview.top-yCursor)/2,
                     hCurCursor);
      }

      EndPaint(hDlg, &ps);
      break;
   #endif

   case WM_NOTIFY:
      switch ( ((NMHDR FAR *)lParam)->code) {

      // OK or Apply button pressed
      case PSN_APPLY:
         // apply any changes made on this page

         SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR); // accept changes
         break;

      // cancel button pressed
      case PSN_RESET:
         // don't accept any of the changes made on this page
         break;

      case PSN_SETACTIVE:
         break;
      case PSN_KILLACTIVE:
         // need to say that it's OK by us to lose the activation
         SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);   // OK to kill focus now
         break;
      }
      break;

   case WM_HELP:
      {
         LPHELPINFO lphi;
         lphi = (LPHELPINFO)lParam;
         if (lphi->iContextType == HELPINFO_WINDOW) {
            WinHelp(lphi->hItemHandle, (LPTSTR)szHelpFile, HELP_WM_HELP,
                  (DWORD_PTR)((POPUP_HELP_ARRAY FAR *)phaPicsDlg));
         }
      }
      break;

   case WM_CONTEXTMENU:
      WinHelp((HWND)wParam, (LPTSTR)szHelpFile, HELP_CONTEXTMENU,
             (DWORD_PTR)((POPUP_HELP_ARRAY FAR *)phaPicsDlg));
      break;

   default:
      return(FALSE);                // didn't process message
      break;
   }

   return TRUE;                     // processed message
}


//
// CreateDataStr
// GetFileStr
// GetDisplayStr
//
// When initializing the owner-draw listbox in each of these dialogs,
// they are filled with strings of the form:
//    displaystring;filename
// where "filename" is the associated full-path filename string AND CAN BE NULL
// and where "displaystring" is the string that appears in the listbox.
//
// CreateDataStr() puts the two pieces together into one string to store.
// The other two functions retrieve one of the pieces from the concatenated
// stored string.
//

TCHAR szSepStr[] = TEXT(";");    // separator character, as null-term str

// Input: file and display strings     NON-DESTRUCTIVE TO INPUT
// Output: combined data string
void CreateDataStr(LPTSTR lpData, LPTSTR lpDisp, LPTSTR lpFile)
{
   lstrcpy(lpData, lpDisp);         // filename can be null
   lstrcat(lpData, (LPTSTR)szSepStr);
   lstrcat(lpData, lpFile);
}

// Input: combined data string         NON-DESTRUCTIVE TO INPUT
// Output: display string
void GetDisplayStr(LPTSTR lpDisp, LPTSTR lpData)
{
   LPTSTR lpScan, lpCopy;

   // just do it all in a loop
   for (lpScan = lpData, lpCopy = lpDisp;
        *lpScan &&                  // paranoid
        (*lpScan != szSepStr[0]);   // stop when you hit the sep char
        lpScan++, lpCopy++) {
      *lpCopy = *lpScan;            // copy over chars one by one
   }

   // null term filename result to finish
   *lpCopy = 0;                     // null filename yields lpDisp[0] = 0
}

// Input: combined data string         NON-DESTRUCTIVE TO INPUT
// Output: file string
void GetFileStr(LPTSTR lpFile, LPTSTR lpData)
{
   LPTSTR lpScan;

   // just loop until you hit sep char
   for (lpScan = lpData;
        *lpScan &&                  // paranoid
        (*lpScan != szSepStr[0]);   // stop when you hit the sep char
        lpScan++) { }               // do nothing

   // now just take the rest of the string and return it
   if (*lpScan)                     // paranoid
      lstrcpy(lpFile, ++lpScan);    // should never be nullstr, but that works too
   else
      *lpFile = 0;                  // 'impossible' error case
}


#ifdef FOOBAR
//  Sets the dialog item to the path name as "prettied" by the shell.
// jdk 6/95: prev funtion just showed filename no path!
#endif

//
// SetDlgItemFile
//
// The whole point of these dialogs is to let the user see where the
// constituent resource files of a theme are, so we need to include the
// full pathnames. No reason not to pretty up the filename part, though.
//
// FUTURE: we can check here for indexed icon files, and make some
// more user-readable form of it.
// e.g. iconfile.dll,17 --> iconfile.dll [icon #17]
//
void PASCAL SetDlgItemFile(HWND hwnd, UINT DlgItem, LPCTSTR lpszPath)
{
   TCHAR szFullPath[MAX_PATH+1];
   TCHAR szPrettyFilename[MAX_PATH+1];
   LPTSTR lpszFilename;

   // inits
   lstrcpy(szFullPath, lpszPath);
   lpszFilename = FileFromPath(szFullPath);

   // prettify via API if you can
   if (*lpszPath != TEXT('\0')) {
      // what does this do? it gives you the filename with the user's options
      // e.g. Explorer View/Options Show/Don'tShow extensions
      GetFileTitle(lpszPath, szPrettyFilename, ARRAYSIZE(szPrettyFilename));
      lstrcpy(lpszFilename, szPrettyFilename);
   }

   // do it
   SetDlgItemText(hwnd, DlgItem, szFullPath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\halftone.c ===
/* HALFTONE.C

   Frosting: Master Theme Selector for Windows '95
   Copyright (c) 1994-1999 Microsoft Corporation.  All rights reserved.
*/


#include<windows.h>
#include<windowsx.h>

/*----------------------------------------------------------------------------

Division lookup tables.  These tables compute 0-255 divided by 51 and
modulo 51.  These tables could approximate gamma correction.

*/

char unsigned const aDividedBy51Rounded[256] =
{
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
};

char unsigned const aDividedBy51[256] =
{
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5,
};

char unsigned const aModulo51[256] =
{
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
    20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37,
    38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 0, 1, 2, 3, 4, 5, 6,
    7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
    26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
    44, 45, 46, 47, 48, 49, 50, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
    13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
    31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48,
    49, 50, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
    18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
    36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 0, 1, 2, 3,
    4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
    23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
    41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 0,
};


/*----------------------------------------------------------------------------

Multiplication LUTs.  These compute 0-5 times 6 and 36.

*/

char unsigned const aTimes6[6] =
{
    0, 6, 12, 18, 24, 30
};

char unsigned const aTimes36[6] =
{
    0, 36, 72, 108, 144, 180
};


/*----------------------------------------------------------------------------

Dither matrices for 8 bit to 2.6 bit halftones.

*/

char unsigned const aHalftone8x8[64] =
{
     0, 38,  9, 47,  2, 40, 11, 50,
    25, 12, 35, 22, 27, 15, 37, 24,
     6, 44,  3, 41,  8, 47,  5, 43,
    31, 19, 28, 15, 34, 21, 31, 18,
     1, 39, 11, 49,  0, 39, 10, 48,
    27, 14, 36, 23, 26, 13, 35, 23,
     7, 46,  4, 43,  7, 45,  3, 42,
    33, 20, 30, 17, 32, 19, 29, 16,
};

/*----------------------------------------------------------------------------

Buffer for brush bits.

*/

static BYTE aTranslate[216];     // map a 666 to a palette index

/*----------------------------------------------------------------------------

Dithering functions.

*/

__inline char unsigned DitherColor( char unsigned RedDiv51,
    char unsigned RedMod51, char unsigned GreenDiv51, char unsigned GreenMod51,
    char unsigned BlueDiv51, char unsigned BlueMod51, char unsigned Index )
{
// cbh! try out scoy's trick of adding without jumping

#pragma warning (disable:4135) // conversion between different integral types
    char unsigned RedTemp = RedDiv51 + (RedMod51 > Index);
    char unsigned GreenTemp = GreenDiv51 + (GreenMod51 > Index);
    char unsigned BlueTemp = BlueDiv51 + (BlueMod51 > Index);
    return aTranslate[RedTemp + aTimes6[GreenTemp] + aTimes36[BlueTemp]];
#pragma warning (default:4135) // conversion between different integral types
}

__inline BYTE DitherColorXY(COLORREF Color, int x, int y)
{
    char unsigned RedDiv51   = aDividedBy51[GetRValue(Color)];
    char unsigned RedMod51   = aModulo51[GetRValue(Color)];
    char unsigned GreenDiv51 = aDividedBy51[GetGValue(Color)];
    char unsigned GreenMod51 = aModulo51[GetGValue(Color)];
    char unsigned BlueDiv51  = aDividedBy51[GetBValue(Color)];
    char unsigned BlueMod51  = aModulo51[GetBValue(Color)];

    return DitherColor(RedDiv51,RedMod51,GreenDiv51,
                       GreenMod51,BlueDiv51,BlueMod51,
                       aHalftone8x8[(x&7) + (y&7)*8]);
}

void InitHalftone(RGBQUAD FAR *pct)
{
    int r,g,b,n,i;
    DWORD FAR *pdw;
    HPALETTE hpal;

    if (hpal = CreateHalftonePalette(NULL))
    {
        pdw = (DWORD FAR *)pct;

        n = GetPaletteEntries(hpal, 0, 256, (LPPALETTEENTRY)pdw);

        //
        // get the halftone palette colors
        //
        for (i=0; i<256; i++)
            pdw[i] = RGB(GetBValue(pdw[i]),GetGValue(pdw[i]),GetRValue(pdw[i]));

        pdw[8] = 0;
        pdw[9] = 0;
        pdw[246] = 0;
        pdw[247] = 0;

        //
        //  now build the 666->index translate,
        //
        for (i=b=0; b<6; b++)
            for (g=0; g<6; g++)
                for (r=0; r<6; r++)
                    aTranslate[i++] = (BYTE)(GetNearestPaletteIndex(hpal, RGB(r*51,g*51,b*51)));

        DeleteObject(hpal);
    }
}

BOOL HalftoneImage(HDC hdc, HBITMAP hbm, LPBITMAPINFOHEADER lpbi, LPBYTE lpBits)
{
    int x, y;
    BYTE r,g,b;
    int dx, dy;
    BITMAP bm;
    LPBYTE pbSrc;
    LPBYTE pbDst;
    RGBQUAD ct[256];

    if (lpbi->biBitCount != 24)
        return FALSE;

    InitHalftone(ct);
    SetDIBColorTable(hdc, 0, 256, ct);

    GetObject(hbm, sizeof(bm), &bm);
    dx = lpbi->biWidth;
    dy = lpbi->biHeight;

    /* read line by line, quantize, and transfer */
    for (y=0; y<dy; y++)
    {
        pbSrc = lpBits;
        pbDst = bm.bmBits;

        for (x=0; x<dx; x++)
        {
            b = *pbSrc++;
            g = *pbSrc++;
            r = *pbSrc++;
            *pbDst++ = DitherColorXY(RGB(r,g,b),x,y);
        }

        (LPBYTE)lpBits += (lpbi->biWidth*3+3)&~3;
        (LPBYTE)bm.bmBits += bm.bmWidthBytes;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\frost.h ===
/* FROST.H

   Include file for Frosting project.

   Frosting: Master Theme Selector for Windows '95
   Copyright (c) 1994-1999 Microsoft Corporation.  All rights reserved.
*/

#ifdef DBG
 #define _DEBUG
 #define DEBUG
#endif

//-----------------------
//  D I A L O G   I D S
//-----------------------

// dialog box IDs
#define DLG_MAIN                 10
#define DLG_SAVE                 12
//#define DLG_ETC                  14
#define DLG_BPPCHOICE            20
#define DLGPROP_PTRS             30
#define DLGPROP_SNDS             32
#define DLGPROP_PICS             34


// Common control IDs
#define IDC_STATIC               -1

//
// PREVIEW DIALOG CONTROL IDS

// Theme groupbox        
#define DDL_THEME                100
#define PB_SAVE                  110
#define PB_DELETE                120
#define RECT_PREVIEW             130
#define RECT_FAKEWIN             140
#define RECT_ICONS               150
#define TEXT_VIEW                160

// Previews groupbox
#define PB_SCRSVR                200
#define PB_POINTERS              210

// Settings groupbox
#define CB_SCRSVR                300
#define CB_SOUND                 310
#define CB_PTRS                  320
#define CB_WALL                  330
#define CB_ICONS                 340
//#define CB_ICONSIZE              345
#define CB_COLORS                350
#define CB_FONTS                 360
#define CB_BORDERS               370
#define CB_SCHEDULE              380

// Control buttons    
#define PB_APPLY                 400

// FOR PREVIEW SAMPLE

// appearance preview menu
#define IDR_MENU	1
#define IDM_NORMAL	10
#define IDM_DISABLED	11
#define IDM_SELECTED	12


//
// SAVEAS DIALOG CONTROL IDS

#define EC_THEME                 500

//
// POINTERS/ETC DIALOG CONTROL IDS
#define PB_TEST                  600
#define PB_PLAY                  602
#define LB_PTRS                  610
#define LB_SNDS                  612
#define LB_PICS                  614
#define TXT_FILENAME             620

//
// Theme BPP choice dlg
#define RB_ALL                   700
#define RB_SOME                  701
#define RB_NONE                  702
#define CB_CUT_IT_OUT            730

//
// NT Task Scheduler Username/Password dialog
#define STR_PW_NOMATCH                  27
#define STR_PWTITLE                     28
#define DLG_PASSWORD                    101
#define EDIT_USER                       1000
#define EDIT_PW                         1001
#define EDIT_PWCONFIRM                  1002
#define STATIC_PW                       1003
#define STATIC_PWCONFIRM                1004
#define STATIC_USER                     1005
#define STATIC_PWDESC                   1006


//-----------------------
// S T R I N G   I D S
//-----------------------

// important constants for strings
#define MAX_STRLEN   80          // TRANSLATORS: English strs max 40
#define MAX_PATHLEN  MAX_PATH    // fullpathname/filename max
                                 // note windef.h has 260; 255 for file
                                 // note2 -- dschott changed from 255 to
                                 // MAX_PATH
#define MAX_MSGLEN   512         // TRANSLATORS: English strs max 256
                                 // MAX_MSGLEN must be at least 2xMAX_STRLEN
                                 // MAX_MSGLEN must be at least 2xMAX_PATHLEN

//
// Try to keep the general strings and low mem strings
// ids within the range of 0-15, one resource block at boot.

// WARNING -- STR_APPNAME is also defined in HTMLPREV.CPP
// general strings
#define STR_APPNAME              0
#define STR_CURSET               1
#define STR_PREVSET              2
#define STR_THMEXT               3
#define STR_FILETYPE             4
#define STR_THEMESUBDIR          5
#define STR_PREVIEWTITLE         6
#define STR_HELPFILE             7
#define STR_PREVIEWDLG           8
#define STR_OTHERTHM             9
#define STR_HELPFILE98           700
#define STR_JOB_NAME             701
#define STR_JOB_COMMENT          702

// low mem strings
#define STR_NOT_ENUF             10    // THIS LOWMEM STRING MUST COME FIRST
                                       // OTHER LOWMEM STRS MUST BE SQUENTIAL
#define STR_TO_RUN               11
#define STR_TO_SAVE              12
#define STR_TO_LIST              13
#define STR_TO_PREVIEW           14   
#define STR_TO_APPLY             15
#define NUM_NOMEM_STRS           6     // KEEP THIS UPDATED IF ADDING LOWMEM STRS
                                       // counts not enuf str + all the to strs

// error strings
#define STR_ERRBADTHEME          16    // theme file in list didn't pass verification
#define STR_ERRBADOPEN           17    // theme file in open didn't pass verification
#define STR_ERRCANTDEL           18    // problem deleting
#define STR_ERRAPPLY             19    // couldn't apply everything
#define STR_ERRCANTSAVE          20    // couldn't write theme to file
#define STR_ERRNEEDSPACE         21    // Not enough space on drive to apply theme
#define STR_ERRTSNOTRUN          22    // Task Scheduler is not running -- want to start?
#define STR_ERRTSNOTFOUND        23    // MSTASK.EXE could not be found
#define STR_ERRTSNOSTART         24    // Error starting Task Scheduler
#define STR_ERRTS                25    // Error accessing Task Scheduler
// WARNING STR_ERRHTML is also defined in HTMLPREV.CPP
#define STR_ERRHTML              26    // Error getting HTML wallpaper preview
#define STR_ERRNOUNICODE         29    // Error trying to run UNICODE binary on Win9x or NT ver not Win2000
#define STR_ERRTSNOTADMIN        30    // Error, can't turn on TS because not admin
#define STR_ERRBAD9XVER          31    // Error, trying to run on Win9x platform that is not Win98 or later

// misc strings
#define STR_CONFIRM_DEL          32
#define STR_SUGGEST              33
#define STR_SAVETITLE            34
#define STR_OPENTITLE            35
#define STR_PREVSETFILE          36
#define STR_FILEEXISTS           37    // file already exists text

#define STR_WHATSTHIS            43
                                       // icon preview label texts
#define STR_MYCOMPUTER           44    // ORDER AND CONTIGUITY MATTERS
#define STR_NETNHBD              45    // change with order of fsRoot in keys.h
#define STR_TRASH                46
#define STR_MYDOCS               47


// property sheet titles
#define STR_TITLE_ETC            48    // prop sheet title
#define STR_TITLE_PTRS           49    // tab titles
#define STR_TITLE_SNDS           50
#define STR_TITLE_PICS           51

// appearance strings for preview sample window
#define IDS_ACTIVE               52
#define IDS_INACTIVE             53
#define IDS_MINIMIZED	         54
#define IDS_ICONTITLE	         55
#define IDS_NORMAL               56
#define IDS_DISABLED             57
#define IDS_SELECTED             58
#define IDS_MSGBOX               59
#define IDS_BUTTONTEXT	         60
#define IDS_SMCAPTION	         61
#define IDS_WINDOWTEXT	         62
#define IDS_MSGBOXTEXT	         63

// strings for cursor dialog listbox
#define STR_CUR_ARROW            64
#define STR_CUR_HELP             65
#define STR_CUR_APPSTART         66
#define STR_CUR_WAIT             67
#define STR_CUR_NWPEN            68
#define STR_CUR_NO               69
#define STR_CUR_SIZENS           70
#define STR_CUR_SIZEWE           71
#define STR_CUR_CROSSHAIR        72
#define STR_CUR_IBEAM            73
#define STR_CUR_SIZENWSE         74
#define STR_CUR_SIZENESW         75
#define STR_CUR_SIZEALL          76
#define STR_CUR_UPARROW          77

// strings for sounds dialog listbox
#define STR_SND_DEF              80
#define STR_SND_GPF              81
#define STR_SND_MAX              82
#define STR_SND_MENUCMD          83
#define STR_SND_MENUPOP          84
#define STR_SND_MIN              85
#define STR_SND_OPEN             86
#define STR_SND_CLOSE            87
#define STR_SND_RESTDOWN         88
#define STR_SND_RESTUP           89
#define STR_SND_RINGIN           90
#define STR_SND_RINGOUT          91
#define STR_SND_SYSASTER         92
#define STR_SND_SYSDEF           93
#define STR_SND_SYSEXCL          94
#define STR_SND_SYSEXIT          95
#define STR_SND_SYSHAND          96
#define STR_SND_SYSQUEST         97
#define STR_SND_SYSSTART         98
#define STR_SND_TOSSTRASH        99
#define STR_SND_MAILBEEP        100

// strings for visuals dialog listbox
#define STR_PIC_WALL             106
#define STR_PIC_MYCOMP           107
#define STR_PIC_NETHOOD          108
#define STR_PIC_RECBINFULL       109
#define STR_PIC_RECBINEMPTY      110
#define STR_PIC_MYDOCS           111
#define STR_PIC_SCRSAV           112

//---------------------
// O T H E R   I D S 
//---------------------

#define FROST_ICON   40

#define PLAY_BITMAP  1
#define BMP_QUESTION 2

//------------------------------------------------
// Flags for IActiveDesktop::GetWallpaperOptions()
//           IActiveDesktop::SetWallpaperOptions()
//
// stolen from SHLOBJ.H
//------------------------------------------------
#define WPSTYLE_CENTER      0
#define WPSTYLE_TILE        1
#define WPSTYLE_STRETCH     2
#define WPSTYLE_MAX         3


//---------------------
// C O N S T A N T S
//---------------------
#define ICON_WIDTH   32    // change if you change icon to dif size!
#define ICON_HEIGHT  32

#define APPLY_ALL    1     // for low color apply filter flag
#define APPLY_SOME   2
#define APPLY_NONE   3

//SYNCHRONIZATION ALERT -- dependent on values in ADDON.H
#define HELP_PLUS98  2028  // Help topics with this ID or greater are
                           // found in PLUS!98.HLP.


//------------------------------------
// O T H E R  U S E F U L  S T U F F
//------------------------------------
#define ARRAYSIZE(x)       (sizeof(x)/sizeof(x[0]))
#define SZSIZEINBYTES(x)   (lstrlen(x)*sizeof(TCHAR)+1)

// *** NUMBER AND ORDER ALERT
//
// WARNING: keep these up to date when change ETCDLG.C and/or KEYS.H
//
// *** NUMBER AND ORDER ALERT

#define NUM_CURSORS  14
#define FIRST_SOUND  2              // 0-based
#define NUM_SOUNDS   21

// SYNCHRONIZATION WARNING!! -- Keep in SYNC with pRegColors[] array
// in REGUTILS.C.
#define INDEX_ACTIVE            0
#define INDEX_INACTIVE          8
#define INDEX_GRADIENTACTIVE    27
#define INDEX_GRADIENTINACTIVE  28


// for ConfirmFile()
#define CF_EXISTS    1
#define CF_FOUND     2
#define CF_NOTFOUND  3

//---------------------
// T Y P E S
//---------------------

typedef struct {
   TCHAR *szValName;                // register key value name
   int iValType;                    // REG_* flag for value type to read/write   
   BOOL bValRelPath;                // relative pathname file string in this val?
   int fValCheckbox;                // chkbox that controls setting this value
} FROST_VALUE;

typedef struct {
   TCHAR *szSubKey;                 // register subkey name string, 
                                    //   below ROOT or CUR_USER
   int fValues;                     // flag for number/type of values; see below
   BOOL bDefRelPath;                // relative pathname file str? for deflt str
   FROST_VALUE *fvVals;             // pointer to array of valuenames
   int iNumVals;                    // number of values
   int fDefCheckbox;                // chkbox that controls setting Default str
} FROST_SUBKEY;

typedef struct {
   DWORD dwControlID;
   DWORD dwHelpContextID;
} POPUP_HELP_ARRAY;

// defs for fValues field
#define  FV_DEFAULT     1           // single value associated with this key
                                    // name; like old INI file routines
                                    // save time, space, energy for common case.
                                    // fvVals is not used in this case.

#define  FV_LIST        2           // normal case of array of FROST_VALUEs

#define  FV_LISTPLUSDEFAULT  3      // normal list like FV_LIST, AND one member
                                    // of which is the default string

//
// defs for fValCheckbox and fDefCheckbox fields
#define  FC_SCRSVR               0
#define  FC_SOUND                1
#define  FC_PTRS                 2
#define  FC_WALL                 3
#define  FC_ICONS                4
//#define  FC_ICONSIZE             5
#define  FC_COLORS               5
#define  FC_FONTS                6
#define  FC_BORDERS              7
#define  FC_SCHEDULE             8

#define  FC_NULL                 9  // for fDefCheckbox with no def str

//
// string constant
#define  FROST_DEFSTR   TEXT("DefaultValue")
// default icon to apply if Theme file doesn't have MyDocs icon setting
#define  MYDOC_DEFSTR   TEXT("mydocs.dll,0")

//
// macros

#define WaitCursor();         SetCursor(LoadCursor(NULL, IDC_WAIT));
#define NormalCursor();       SetCursor(LoadCursor(NULL, IDC_ARROW));


/////////////////////////////
// 
// Debugging utility macro
//
/////////////////////////////

// Very simple assertion tool

#ifdef _DEBUG
__inline void ods(LPTSTR sz)
{
    OutputDebugString(sz);
    if (*sz && sz[lstrlen(sz)-1] == TEXT('\n'))
        OutputDebugString(TEXT("\r"));
}
#define Assert(p,s); if(!(p)) { ods(s); };
#else
#define Assert(p,s); 
#endif


//----------------------------------
// G L O B A L   V A R I A B L E S
//----------------------------------

//HWND hWndApp;                    // main application window handle
//HINSTANCE hInstApp;              // application instance handle
HICON hIconFrost;                // application icon, has to be painted by hand

BOOL bNoMem;                     // dialog init flag for out of mem
BOOL g_bGradient;                // Enuf colors for gradient captions?

BOOL bLowColorProblem;           // potential prob w/ theme colors > system
BOOL bNeverCheckBPP;             // from BPP Choice dlg; remember per session
int fLowBPPFilter;               // flag saying how to filter apply when bLowColorProblem is true

RECT rView;                      // preview area of dlg
RECT rFakeWin;                   // fake sample window within preview area
RECT rPreviewIcons;              // bounding rect for icon samples in preview area
int iThemeCount;                 // num of items in theme DDL, incl Cur and Other...
int iCurTheme;                   // 0-based index of cur theme in list

extern TCHAR *pRegColors[];      // have to be def'd in REGUTILS.C for sizing
extern int iSysColorIndices[];
extern BOOL gfCoInitDone;	     // track state of OLE CoInitialize()


// strings
TCHAR szAppName[MAX_STRLEN+1];    // application name
TCHAR szMsg[MAX_MSGLEN+1];        // scratch buffer
TCHAR szCurSettings[MAX_STRLEN+1];// "Current Windows settings" for DDLbox
TCHAR szPrevSettings[MAX_STRLEN+1];// "Previous Windows settings" for DDLbox
TCHAR szPrevSettingsFilename[MAX_STRLEN+1];  // theme file w/prev settings, no path
TCHAR szOther[MAX_STRLEN+1];      // "Other..." for DDLbox
TCHAR szNewFile[MAX_STRLEN+1];    // suggested new filename on save theme
TCHAR szExt[MAX_STRLEN+1];        // THM file extension for theme files
TCHAR szFileTypeDesc[MAX_STRLEN+1];  // for save/open file type description
TCHAR szPreviewTitle[MAX_STRLEN+1]; // Preview of "Foo" title at bottom of dlg

TCHAR szSaveTitle[MAX_STRLEN+1];  // title for saveas dlg
TCHAR szOpenTitle[MAX_STRLEN+1];  // title for open dlg

TCHAR szHelpFile[MAX_PATH];       // Help file name; no path nec.; Plus!95
TCHAR szHelpFile98[MAX_PATH];     // Help file name for Plus! 98 new topics

TCHAR szThemeDir[MAX_PATHLEN+1];  // dir of most theme files
TCHAR szWinDir[MAX_PATHLEN+1];    // Windows directory
TCHAR szCurDir[MAX_PATHLEN+1];    // last dir opened a theme file from
TCHAR szCurThemeFile[MAX_PATHLEN+1]; // path + filename of cur theme file
TCHAR szCurThemeName[MAX_PATHLEN+1];  // just name, no path and no extension

#define MAX_VALUELEN 1024        // extra meaty length for safety
extern TCHAR pValue[];           // multi-use buffer: char, hex string, etc.

// 
// Checkbox states, ids and values
// important that this is coordinated with FC_* in keys.h !!!!

#define  MAX_FCHECKS 9           // don't need one for NULL case

BOOL bCBStates[MAX_FCHECKS];     // main window checkbox states

// WebView names number must be consistent with szWVNames[] below
#define  MAX_WVNAMES 3           // number of WebView artwork files

// if in root file
#ifdef ROOTFILE
//

// Consistency Alert! the number of elements here should match MAX_FCHECKS above
int iCBIDs[] = {CB_SCRSVR,
                CB_SOUND,
                CB_PTRS,
                CB_WALL,     // checkbox IDs
                CB_ICONS,
                CB_COLORS,
                CB_FONTS,
                CB_BORDERS,
                CB_SCHEDULE };
//              CB_ICONS, CB_ICONSIZE, CB_COLORS, CB_FONTS, CB_BORDERS };
TCHAR * szCBNames[] = {  TEXT("Screen saver"),
                         TEXT("Sound events"),
                         TEXT("Mouse pointers"),
                         TEXT("Desktop wallpaper"),
                         TEXT("Icons"),
//                       TEXT("Icon size and spacing"),
                         TEXT("Colors"),
                         TEXT("Font names and styles"),
                         TEXT("Font and window sizes"),
                         TEXT("Rotate theme monthly")
                      };  

TCHAR szNULL[] = TEXT("");

TCHAR szColorApp[] = TEXT("Control Panel\\Colors");

TCHAR szClassName[] = TEXT("DesktopThemes");

// Names of the WebView artwork files -- found in \windir\web
//
// Consistency alert -- number of items must match MAX_WVNAMES
// defined above!

TCHAR * szWVNames[] = { TEXT("WVLEFT.BMP"),
                        TEXT("WVLINE.GIF"),
                        TEXT("WVLOGO.GIF")
                      };


#else  // else not root file

extern int iCBIDs[];
extern TCHAR * szCBNames[];
extern TCHAR szNULL[];
extern TCHAR szColorApp[];
extern TCHAR szClassName[];
extern TCHAR * szWVNames[];

// end if root file
#endif


//---------------------------
// F A R   R O U T I N E S
//---------------------------

// frost.c
INT_PTR FAR PASCAL PreviewDlgProc(HWND, UINT, WPARAM, LPARAM);
void FAR EnableThemeButtons();
#ifdef USECALLBACKS
UINT_PTR FAR PASCAL FileOpenHookProc(HWND, UINT, WPARAM, LPARAM);
#endif

// init.c
BOOL FAR InitFrost(HINSTANCE, HINSTANCE, LPTSTR, int);
void FAR SaveStates();
void FAR CloseFrost();

#ifdef FOO
// savedlg.c
INT_PTR FAR PASCAL SaveAsDlgProc(HWND, UINT, WPARAM, LPARAM);
#endif

// etcdlg.c
INT_PTR FAR DoEtcDlgs(HWND);

// regutils.c
void GetRegString(HKEY hkey, LPCTSTR szKey, LPCTSTR szValue, LPCTSTR szDefault, LPTSTR szBuffer, UINT cbBuffer);
int  GetRegInt(HKEY hkey, LPCTSTR szKey, LPCTSTR szValue, int def);

BOOL FAR GatherThemeToFile(LPTSTR);
BOOL FAR ApplyThemeFile(LPTSTR);
VOID FAR InstantiatePath(LPTSTR, int);
int FAR ConfirmFile(LPTSTR, BOOL);
COLORREF FAR RGBStringToColor(LPTSTR);
void FAR ColorToRGBString(LPTSTR, COLORREF);
BOOL FAR HandGet(HKEY hKeyRoot, LPTSTR lpszSubKey, LPTSTR lpszValName, LPTSTR lpszRet);
// void FAR SetCheckboxesFromThemeFile(LPTSTR);
// void FAR SetCheckboxesFromRegistry();
BOOL GetWVFilename(LPCTSTR, LPCTSTR, LPTSTR);

// bkgd.c
void FAR PASCAL BuildPreviewBitmap(LPTSTR lpszThemeFile);
void FAR PaintPreview(HWND, HDC, PRECT);
// bkgdutil.c
BOOL FAR PASCAL PreviewInit(void);
void FAR PASCAL PreviewDestroy(void);
HRESULT ExtractPlusColorIcon(LPCTSTR szPath, int nIndex, HICON *phIcon, UINT uSizeLarge, UINT uSizeSmall);


// fakewin.c
BOOL FAR PASCAL FakewinInit(void);
void FAR PASCAL FakewinDestroy(void);
void FAR FakewinSetTheme(LPTSTR);
void FAR PASCAL FakewinDraw(HDC);

// icons.c
BOOL FAR PASCAL IconsPreviewInit(void);
void FAR PASCAL IconsPreviewDestroy(void);
void FAR PASCAL IconsPreviewDraw(HDC, LPTSTR);

// utils.c
void FAR InitNoMem(HANDLE);
void FAR NoMemMsg(int);
void FAR TruncateExt(LPCTSTR);
LPTSTR FAR FileFromPath(LPCTSTR);
LPTSTR FAR FindChar(LPTSTR, TCHAR);
VOID FAR litoa(int, LPSTR);
int FAR latoi( LPSTR );
BOOL FAR FilenameToShort(LPTSTR lpszInput, LPTSTR lpszShort);
BOOL FAR FilenameToLong(LPTSTR lpszInput, LPTSTR lpszLong);
BOOL FAR IsValidThemeFile(LPTSTR);

BOOL FAR CheckSpace (HWND hWnd, BOOL fComplain);  // Defined in Regutils.c

// nc.c
VOID FAR TransmitFontCharacteristics(PLOGFONT, PLOGFONT, int);
#define TFC_STYLE    1
#define TFC_SIZE     2

// cb.c
void FAR InitCheckboxes();
void FAR SaveCheckboxes();
void FAR RestoreCheckboxes();
BOOL FAR IsAnyBoxChecked();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\halftone.h ===
/* HALFTONE.H

   Frosting: Master Theme Selector for Windows '95
   Copyright (c) 1994-1999 Microsoft Corporation.  All rights reserved.
*/

void HalftoneImage(HDC hdc, HBITMAP hbm, LPBITMAPINFOHEADER lpbi, LPBYTE lpBits);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\htmlprev.h ===
/*  HTMLPREV.H
**
**  Copyright (c) 1997-1999 Microsoft Corporation.  All Rights Reserved.
**
**  IThumbnail wrapper functions provided by HTMLPREV.CPP
**
*/

BOOL InitHTMLBM();
HBITMAP HtmlToBmp(LPCTSTR, LONG, LONG);
void CleanUp();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\icons.c ===
/* ICONS.C
   Resident Code Segment      // Tweak: make non-resident?

   Initing and painting icons in preview sample

   Frosting: Master Theme Selector for Windows '95
   Copyright (c) 1994-1998 Microsoft Corporation.  All rights reserved.
*/

// ---------------------------------------------
// Brief file history:
// Alpha:
// Beta:
// Bug fixes
// ---------

#include "windows.h"
#include "stdlib.h"
#include "frost.h"
#include "global.h"
#include "schedule.h"  // IsPlatformNT()
#include "nc.h"

extern int FAR WriteBytesToBuffer(LPTSTR);

#define ICONSIZE  32
#define NUM_ICONS 4
#define MYDOC_INDEX 3 // Index to MyDocs icon subkey in fsRoot & fsCUIcons
                      // Keep in sync with KEYS.H!!

POINT ptIconOrigin[NUM_ICONS];
RECT rLabels[NUM_ICONS];
TCHAR szLabelText[NUM_ICONS][MAX_STRLEN+1];

#define bThemed (*lpszThemeFile)


BOOL FAR PASCAL IconsPreviewInit(void)
{
   int xOrg, iter;

   // icons are centered, evenly spaced, in the icon rectangle in the RC file

   // you can get x origins of icons from the icon area rect
   xOrg = rPreviewIcons.left + (rPreviewIcons.right - rPreviewIcons.left -
                                ICONSIZE) / 2;
   for (iter = 0; iter < NUM_ICONS; iter++) {
      ptIconOrigin[iter].x = xOrg;
   }
   // y origins depend on font height in theme

   // load icon label texts
   for (iter = 0; iter < NUM_ICONS; iter++) {
      LoadString(hInstApp, STR_MYCOMPUTER+iter, (LPTSTR)(szLabelText[iter]), MAX_STRLEN);
   }

   return (TRUE);
}
void FAR PASCAL IconsPreviewDestroy(void)
{
}

void FAR PASCAL IconsPreviewDraw(HDC hdcDraw, LPTSTR lpszThemeFile)
{
   UINT uret;
   ICONMETRICS imTheme;
   extern TCHAR szMetrics[];
   extern TCHAR szIM[];
   HFONT hIconFont, hOldFont;
   HICON hTempIcon;
   TEXTMETRIC tmLabel;
   int yLabel, yCushion, yIconSpacing;
   int iter, iTemp;
   int index;
   extern FROST_SUBKEY fsRoot[];          // Win95/Plus95 icon keys
   extern FROST_SUBKEY fsCUIcons[];       // Win98/Plus98 icon keys
   extern TCHAR c_szSoftwareClassesFmt[]; // WinNT reg path from keys.h 
   LPTSTR lpszIndex;
   SIZE sizeText;
   COLORREF rgbLabel, rgbLabelText, rgbOldText;
   HBRUSH hbrLabel;
   TCHAR szNTReg[MAX_PATH];
#ifdef UNICODE
   CHAR szTempA[10];
#endif

   //
   // Inits
   // 
   // Get the icon font; use it to figure y positions of icons and labels;
   // setup DC with font; get lable brush/text color.
   //

   //
   // get the icon font

   // first get the iconmetrics struct
//   if (bThemed && bCBStates[FC_ICONS]) {  // icon fonts go with icons cb, not fonts
   if (bThemed && bCBStates[FC_FONTS]) {  // icon fonts go with _fonts_ now !!!!
      uret = (UINT) GetPrivateProfileString((LPTSTR)szMetrics, (LPTSTR)szIM,
                                          (LPTSTR)szNULL,
                                          (LPTSTR)pValue, MAX_VALUELEN,
                                          lpszThemeFile);
      Assert(uret, TEXT("problem getting stored icon metrics for icon preview draw\n"));
      // translate stored data string to ICONMETRICS bytes
      WriteBytesToBuffer((LPTSTR)pValue);  // char str read from and binary bytes
                                           // written to pValue. It's OK.
      // get it into global ICONMETRICS struct
#ifdef UNICODE
      // ICONMETRICS are stored in ANSI format in the Theme file so we
      // need to convert to UNICODE
      ConvertIconMetricsToWIDE((LPICONMETRICSA)pValue, (LPICONMETRICSW)&imTheme);
#else
      // Not UNICODE so no need to convert...
      imTheme = *((LPICONMETRICS)pValue);
#endif
   }
   else {
      imTheme.cbSize = sizeof(imTheme);
      SystemParametersInfo(SPI_GETICONMETRICS, sizeof(imTheme),
                           (void far *)(LPICONMETRICS)&imTheme, FALSE);
   }

   // then create the font
   hIconFont = CreateFontIndirect(&imTheme.lfFont);

   // and use it in this DC
   if (hIconFont)
      hOldFont = SelectObject(hdcDraw, hIconFont);

   //
   // now that we have the font, we can get the y origins for the icons
   // and the y extremities of the text labels

   // figure label height
   GetTextMetrics(hdcDraw, &tmLabel);
//   yLabel = (tmLabel.tmHeight*13)/9;   // very good estimate; else try 11/9
   yLabel = tmLabel.tmHeight;       // no, just text height will do
   // and cushion between bottom of icons and their labels
   yCushion = (yLabel*4)/13; // pretty good guess

   // icons are centered, evenly spaced, in the icon rectangle in the RC file
   yIconSpacing = ( rPreviewIcons.bottom - rPreviewIcons.top
                    - NUM_ICONS * (yLabel + yCushion + ICONSIZE) ) / NUM_ICONS;
   Assert(yIconSpacing > 0, TEXT("neg yIconSpacing implies icon preview rect too short\n"));
   ptIconOrigin[0].y = rPreviewIcons.top + yIconSpacing/2;
   for (iter = 1; iter < NUM_ICONS; iter ++) {
      ptIconOrigin[iter].y = ptIconOrigin[iter-1].y +
                             ICONSIZE + yCushion + yLabel + yIconSpacing;
   }

   // labels are where you now expect them
   for (iter = 0; iter < NUM_ICONS; iter ++) {
      rLabels[iter].top = ptIconOrigin[iter].y + ICONSIZE + yCushion;
      rLabels[iter].bottom = rLabels[iter].top + yLabel;
   }

   //
   // final init involves colors (and brush) for labels and label text

   // get desktop background color
   if (bThemed && bCBStates[FC_COLORS]) {    // getting from selected theme
      GetPrivateProfileString((LPTSTR)TEXT("Control Panel\\Colors"),
                              (LPTSTR)TEXT("Background"),
                              (LPTSTR)szNULL,
                              (LPTSTR)szMsg, MAX_MSGLEN,
                              lpszThemeFile);
      // translate to color
      rgbLabel = RGBStringToColor((LPTSTR)szMsg);
   }
   else                          // using cur windows settings
      rgbLabel = GetSysColor(COLOR_BACKGROUND);

   // then make that the nearest solid color for label background
   rgbLabel = GetNearestColor(hdcDraw, rgbLabel);

   // now use a HACK HACK HACK HACK brilliant method for getting text color
   if ((GetRValue(rgbLabel) > 128) ||
       (GetGValue(rgbLabel) > 128) ||
       (GetBValue(rgbLabel) > 128) )
      rgbLabelText = RGB(0,0,0);    // black text on lighter label
   else 
      rgbLabelText = RGB(255,255,255);    // white text on darker label

   // and then create the background brush and set the text color
   hbrLabel = CreateSolidBrush(rgbLabel);
   rgbOldText = SetTextColor(hdcDraw, rgbLabelText);
   SetBkMode(hdcDraw, TRANSPARENT);


   //
   // now we can get each of the icons and draw them at the right spot
   // and while you're at it draw the labels
   for (iter = 0; iter < NUM_ICONS; iter ++) {

      // first get filename into temp global buffer szMsg

      if (bThemed && bCBStates[FC_ICONS]) { // getting from selected theme
         GetPrivateProfileString((LPTSTR)fsCUIcons[iter].szSubKey,
                                 // SPECIAL UGLY CASE FOR TRASH CAN
                                 (LPTSTR)(iter == 2 ? TEXT("full") : FROST_DEFSTR),
                                 (LPTSTR)szNULL,
                                 (LPTSTR)szMsg, MAX_MSGLEN,
                                 lpszThemeFile);

         // If the key is null we might have an "old" Plus95 *.Theme file
         // so let's use the Win95 keyname instead
         if (!*szMsg) {
            GetPrivateProfileString((LPTSTR)fsRoot[iter].szSubKey,
                                    // SPECIAL UGLY CASE FOR TRASH CAN
                                    (LPTSTR)(iter == 2 ? TEXT("full") : FROST_DEFSTR),
                                    (LPTSTR)szNULL,
                                    (LPTSTR)szMsg, MAX_MSGLEN,
                                    lpszThemeFile);
         }

         // PLUS98 bug 1042
         // If this is the MyDocs icon and there is no setting for
         // it in the Theme file then we need to default to the
         // szMyDocsDefault icon.

         if ((MYDOC_INDEX == iter) && (!*szMsg)) {
            lstrcpy(szMsg, MYDOC_DEFSTR);
         }
         
         // expand filename string as necessary
         InstantiatePath((LPTSTR)szMsg, MAX_MSGLEN);

         // search for file if necessary, see if found
         // ConfirmFile on NULL string returns "CF_EXISTS" so have
         // added "|| !*szMsg" case to this conditional to check for it

         if ((ConfirmFile((LPTSTR)szMsg, TRUE) == CF_NOTFOUND) || !*szMsg) {
            // if file not found, nothing applied --> keeps cur sys setting
            szMsg[0] = TEXT('\0');
            HandGet(HKEY_CURRENT_USER,
                  (LPTSTR)fsCUIcons[iter].szSubKey,
                  // SPECIAL UGLY CASE FOR TRASH CAN
                  (LPTSTR)(iter == 2 ? TEXT("full") : szNULL),
                                          // null gives default string
                  (LPTSTR)szMsg);

            // If we failed to get a string from the CURRENT_USER branch
            // go try the CLASSES_ROOT branch instead.
            if (!*szMsg) {
               HandGet(HKEY_CLASSES_ROOT,
                       (LPTSTR)fsRoot[iter].szSubKey,
                       // SPECIAL UGLY CASE FOR TRASH CAN
                       (LPTSTR)(iter == 2 ? TEXT("full") : szNULL),
                                               // null gives default string
                       (LPTSTR)szMsg);
            }
         }
      }
      else {                        // using cur windows settings

         // First try getting the icon from the appropriate
         // CURRENT_USER branch for this platform

         szMsg[0] = TEXT('\0');

         if (IsPlatformNT())
         {

            lstrcpy(szNTReg, c_szSoftwareClassesFmt);
            lstrcat(szNTReg, fsRoot[iter].szSubKey);
            HandGet(HKEY_CURRENT_USER,
                    (LPTSTR)szNTReg,
                    // SPECIAL UGLY CASE FOR TRASH CAN
                    (LPTSTR)(iter == 2 ? TEXT("full") : szNULL),
                                                // null gives default string
                    (LPTSTR)szMsg);
         }
         else // not NT
         {
            HandGet(HKEY_CURRENT_USER,
                    (LPTSTR)fsCUIcons[iter].szSubKey,
                    // SPECIAL UGLY CASE FOR TRASH CAN
                    (LPTSTR)(iter == 2 ? TEXT("full") : szNULL),
                                                // null gives default string
                    (LPTSTR)szMsg);

         }
         // If we got a NULL string from the CURRENT_USER branch then
         // try the CLASSES_ROOT branch instead

         if (!*szMsg) {
            HandGet(HKEY_CLASSES_ROOT,
                    (LPTSTR)fsRoot[iter].szSubKey,
                    // SPECIAL UGLY CASE FOR TRASH CAN
                    (LPTSTR)(iter == 2 ? TEXT("full") : szNULL),
                                                // null gives default string
                    (LPTSTR)szMsg);
         }
      }

      // now load the icon; may have index into file. format: "file,index"
      lpszIndex = FindChar((LPTSTR)szMsg, TEXT(','));
      if (*lpszIndex) {             // if found a comma, then indexed icon
#ifdef UNICODE
         // latoi doesn't like wide strings -- convert to ANSI before calling
         wcstombs(szTempA, CharNext(lpszIndex), sizeof(szTempA));
         index = latoi(szTempA);
#else
         index = latoi(CharNext(lpszIndex));
#endif
         *lpszIndex = 0;            // got index then null term filename in szMsg
      }
      else {                        // just straight icon file or no index
         index = 0;
      }
      // Get proper res ICON from file
      ExtractPlusColorIcon(szMsg, index, &hTempIcon, 0, 0);
	  

      // draw the icon at the right spot
      if (hTempIcon)
         DrawIconEx(hdcDraw, ptIconOrigin[iter].x, ptIconOrigin[iter].y,
                    hTempIcon, ICONSIZE, ICONSIZE, 0, NULL, DI_NORMAL);

      // figure the label width for the font and text string
      GetTextExtentPoint32(hdcDraw, (LPTSTR)(szLabelText[iter]),
                           lstrlen((LPTSTR)(szLabelText[iter])),
                           (LPSIZE)&sizeText);
      iTemp = (rPreviewIcons.right - rPreviewIcons.left - (int)(sizeText.cx)) / 2;
      rLabels[iter].left = rPreviewIcons.left + iTemp
                           - (yLabel*3)/13;  // very good estimate
      rLabels[iter].right = rPreviewIcons.right - iTemp 
                            + (yLabel*3)/13;  // very good estimate

      // draw label background in solid color version of dt bkgd color
      FillRect(hdcDraw, (LPRECT)&(rLabels[iter]), hbrLabel);

      // draw actual text string there, too
      DrawText(hdcDraw, (LPTSTR)(szLabelText[iter]),
                        lstrlen((LPTSTR)(szLabelText[iter])),
               (LPRECT)&(rLabels[iter]),
               DT_CENTER | DT_VCENTER | DT_NOCLIP | DT_SINGLELINE
              );

      // individual icon draw Cleanup
      if (hTempIcon)
         DestroyIcon(hTempIcon);
   }

   //
   // cleanup
   if (hbrLabel) DeleteObject(hbrLabel);
   if (rgbOldText != CLR_INVALID) SetTextColor(hdcDraw, rgbOldText);
   if (hIconFont) {
      SelectObject(hdcDraw, hOldFont);
      DeleteObject(hIconFont);
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\keys.h ===
/* KEYS.H

   Include file for list of settings from registry that theme selector sets.

   Frosting: Master Theme Selector for Windows '95
   Copyright (c) 1994-1999 Microsoft Corporation.  All rights reserved.
*/


///////////////////////////////////////////////////
//
// Typedefs and constants for these registry key/valuename/etc records
//

// moved to FROST.H



///////////////////////////////////////////////////
//
// HKEY_CLASSES_ROOT subkeys' value names and types
//

FROST_VALUE fvTrashIcon[] = {       // trash can icons
   {TEXT("full"), REG_SZ, TRUE, FC_ICONS},
   {TEXT("empty"), REG_SZ, TRUE, FC_ICONS}
};


//
// HKEY_CLASSES_ROOT subkeys
//

#define MAX_ICON 4    // Number of subkeys in fsRoot and fsCUIcons enums
#define TRASH_INDEX 2 // Index to trash icon subkey in fsRoot & fsCUIcons
                      // Keep in sync!!
#define MYDOC_INDEX 3 // Index to MyDocs icon subkey in fsRoot & fsCUIcons
                      // Keep in sync!!  Also in ICONS.C.

// changed order here requires changed indices in icons.c and string ids in frost.h.
// also have to change hand-coded work in etcdlg.c PicsPageProc()
// also have to change hand-coded work in etcdlg.c Trash*() functions
FROST_SUBKEY fsRoot[] = {
   // My Computer icon
   {TEXT("CLSID\\{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\DefaultIcon"), 
    FV_DEFAULT, TRUE, (FROST_VALUE *)NULL, 0, FC_ICONS},

   // Net neighborhood icon
   {TEXT("CLSID\\{208D2C60-3AEA-1069-A2D7-08002B30309D}\\DefaultIcon"), 
    FV_DEFAULT, TRUE, (FROST_VALUE *)NULL, 0, FC_ICONS},

   // trash icons
   {TEXT("CLSID\\{645FF040-5081-101B-9F08-00AA002F954E}\\DefaultIcon"), 
    FV_LIST, TRUE, fvTrashIcon, sizeof(fvTrashIcon)/sizeof(FROST_VALUE), FC_ICONS},

   // My Documents icon
   {TEXT("CLSID\\{450D8FBA-AD25-11D0-98A8-0800361B1103}\\DefaultIcon"),
   FV_DEFAULT, TRUE, (FROST_VALUE *)NULL, 0, FC_ICONS}
};


// For Win98 icon settings.  Keep in sync with fsRoot and MAX_ICON, and
// TRASH_INDEX above!!!

FROST_SUBKEY fsCUIcons[] = {
   // My Computer icon
   {TEXT("Software\\Classes\\CLSID\\{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\DefaultIcon"), 
    FV_DEFAULT, TRUE, (FROST_VALUE *)NULL, 0, FC_ICONS},

   // Net neighborhood icon
   {TEXT("Software\\Classes\\CLSID\\{208D2C60-3AEA-1069-A2D7-08002B30309D}\\DefaultIcon"), 
    FV_DEFAULT, TRUE, (FROST_VALUE *)NULL, 0, FC_ICONS},

   // trash icons
   {TEXT("Software\\Classes\\CLSID\\{645FF040-5081-101B-9F08-00AA002F954E}\\DefaultIcon"), 
    FV_LIST, TRUE, fvTrashIcon, sizeof(fvTrashIcon)/sizeof(FROST_VALUE), FC_ICONS},

   // My Documents icon
   {TEXT("Software\\Classes\\CLSID\\{450D8FBA-AD25-11D0-98A8-0800361B1103}\\DefaultIcon"),
   FV_DEFAULT, TRUE, (FROST_VALUE *)NULL, 0, FC_ICONS}
};

// This is for NT -- it must be prepended to the CLASSES_ROOT strings above
// to create the appropriate reg path for NT icons.

const TCHAR c_szSoftwareClassesFmt[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\");

///////////////////////////////////////////////////
//
// HKEY_CURRENT_USER subkeys' value names and types
//

#if 0
FROST_VALUE fvColors[] = {          // different colors in color scheme
   {TEXT("ActiveTitle"), REG_SZ, FALSE, FC_COLORS},
   {TEXT("Background"), REG_SZ, FALSE, FC_COLORS},
   {TEXT("Hilight"), REG_SZ, FALSE, FC_COLORS},
   {TEXT("HilightText"), REG_SZ, FALSE, FC_COLORS},
   {TEXT("TitleText"), REG_SZ, FALSE, FC_COLORS},
   {TEXT("Window"), REG_SZ, FALSE, FC_COLORS},
   {TEXT("WindowText"), REG_SZ, FALSE, FC_COLORS},
   {TEXT("Scrollbar"), REG_SZ, FALSE, FC_COLORS},
   {TEXT("InactiveTitle"), REG_SZ, FALSE, FC_COLORS},
   {TEXT("Menu"), REG_SZ, FALSE, FC_COLORS},
   {TEXT("WindowFrame"), REG_SZ, FALSE, FC_COLORS},
   {TEXT("MenuText"), REG_SZ, FALSE, FC_COLORS},
   {TEXT("ActiveBorder"), REG_SZ, FALSE, FC_COLORS},
   {TEXT("InactiveBorder"), REG_SZ, FALSE, FC_COLORS},
   {TEXT("AppWorkspace"), REG_SZ, FALSE, FC_COLORS},
   {TEXT("ButtonFace"), REG_SZ, FALSE, FC_COLORS},
   {TEXT("ButtonShadow"), REG_SZ, FALSE, FC_COLORS},
   {TEXT("GrayText"), REG_SZ, FALSE, FC_COLORS},
   {TEXT("ButtonText"), REG_SZ, FALSE, FC_COLORS},
   {TEXT("InactiveTitleText"), REG_SZ, FALSE, FC_COLORS},
   {TEXT("ButtonHilight"), REG_SZ, FALSE, FC_COLORS},
   {TEXT("ButtonDkShadow"), REG_SZ, FALSE, FC_COLORS},
   {TEXT("ButtonLight"), REG_SZ, FALSE, FC_COLORS},
   {TEXT("MessageBox"), REG_SZ, FALSE, FC_COLORS},
   {TEXT("MessageBoxText"), REG_SZ, FALSE, FC_COLORS},
   {TEXT("InfoText"), REG_SZ, FALSE, FC_COLORS},
   {TEXT("InfoWindow"), REG_SZ, FALSE, FC_COLORS},
   {TEXT("GradientActiveTitle"), REG_SZ, FC_COLORS},
   {TEXT("GradientInActiveTitle"), REG_SZ, FC_COLORS}
};
#endif

//
// WARNING: keep order consistent with indices in stkCursors[] in etcdlg.c
//          also keep total number consistent with NUM_CURSORS in frost.h
//
FROST_VALUE fvCursors[] = {         // different cursors
   {TEXT("Arrow"), REG_SZ, TRUE, FC_PTRS},
   {TEXT("Help"), REG_SZ, TRUE, FC_PTRS},
   {TEXT("AppStarting"), TRUE, REG_SZ, FC_PTRS},
   {TEXT("Wait"), REG_SZ, TRUE, FC_PTRS},
   {TEXT("NWPen"), REG_SZ, TRUE, FC_PTRS},
   {TEXT("No"), REG_SZ, TRUE, FC_PTRS},
   {TEXT("SizeNS"), REG_SZ, TRUE, FC_PTRS},
   {TEXT("SizeWE"), REG_SZ, TRUE, FC_PTRS},
   {TEXT("Crosshair"), REG_SZ, TRUE, FC_PTRS},
   {TEXT("IBeam"), REG_SZ, TRUE, FC_PTRS},
   {TEXT("SizeNWSE"), REG_SZ, TRUE, FC_PTRS},
   {TEXT("SizeNESW"), REG_SZ, TRUE, FC_PTRS},
   {TEXT("SizeAll"), REG_SZ, TRUE, FC_PTRS},
   {TEXT("UpArrow"), REG_SZ, TRUE, FC_PTRS}
};


FROST_VALUE fvDesktop[] = {
   {TEXT("Wallpaper"), REG_SZ, TRUE, FC_WALL},
//   {TEXT("TileWallpaper"), REG_SZ, FALSE, FC_WALL}, // done by hand now
//   {TEXT("WallpaperStyle"), REG_SZ, FALSE, FC_WALL},// done by hand now
// {TEXT("WallPaperOriginX"), REG_SZ, FALSE, FC_WALL},// no longer done
// {TEXT("WallPaperOriginY"), REG_SZ, FALSE, FC_WALL},// no longer done
   {TEXT("Pattern"), REG_SZ, FALSE, FC_WALL},
//   {TEXT("ScreenSaveActive"), REG_SZ, FALSE, FC_SCRSVR} // done by hand now
//   {TEXT("ScreenSaveUsePassword"), REG_DWORD}, // no longer done
//   {TEXT("ScreenSave_Data"), REG_BINARY}       // no longer done
};


#ifdef REVERT
// this is down to these few icon settings now
// rest of icons/borders/fonts done by hand; see below 
FROST_VALUE fvWinMetrics[] = {
   {TEXT("Shell Icon Size"), REG_SZ, FALSE, FC_ICONSIZE},
   {TEXT("Shell Small Icon Size"), REG_SZ, FALSE, FC_ICONSIZE},
//   {TEXT("Shell Icon BPP"), REG_SZ, FALSE, FC_ICONS}
};
#endif


//
// HKEY_CURRENT_USER subkeys
//

// *** NUMBER AND ORDER ALERT
// If you add or delete CP\Foo items or add or delete sound keys,
// you have to change the First/Last Sound defines in frost.h
// and the stkSounds[] in etcdlg.c
// *** NUMBER AND ORDER ALERT

FROST_SUBKEY fsCurUser[] = {
//
// metric lists in the control panel registry

//   {TEXT("Control Panel\\Colors"), FV_LIST, FALSE, fvColors, sizeof(fvColors)/sizeof(FROST_VALUE), FC_NULL},

   {TEXT("Control Panel\\Cursors"), FV_LISTPLUSDEFAULT, TRUE, fvCursors, sizeof(fvCursors)/sizeof(FROST_VALUE), FC_PTRS},

   {TEXT("Control Panel\\Desktop"), FV_LIST, FALSE, fvDesktop, sizeof(fvDesktop)/sizeof(FROST_VALUE), FC_NULL},

//   {TEXT("Control Panel\\Desktop\\WindowMetrics"), FV_LIST, FALSE, fvWinMetrics, sizeof(fvWinMetrics)/sizeof(FROST_VALUE), FC_NULL},

// *** NUMBER AND ORDER ALERT
// If you add or delete CP\Foo items or add or delete sound keys,
// you have to change the First/Last Sound defines in frost.h
//  *and*  the stkSounds[] in etcdlg.c
// *** NUMBER AND ORDER ALERT

//
// single value sound keys

   {TEXT("AppEvents\\Schemes\\Apps\\.Default\\.Default\\.Current"), 
    FV_DEFAULT, TRUE, (FROST_VALUE *)NULL, 0, FC_SOUND},

   {TEXT("AppEvents\\Schemes\\Apps\\.Default\\AppGPFault\\.Current"), 
    FV_DEFAULT, TRUE, (FROST_VALUE *)NULL, 0, FC_SOUND},

   {TEXT("AppEvents\\Schemes\\Apps\\.Default\\Maximize\\.Current"), 
    FV_DEFAULT, TRUE, (FROST_VALUE *)NULL, 0, FC_SOUND},

   {TEXT("AppEvents\\Schemes\\Apps\\.Default\\MenuCommand\\.Current"), 
    FV_DEFAULT, TRUE, (FROST_VALUE *)NULL, 0, FC_SOUND},

   {TEXT("AppEvents\\Schemes\\Apps\\.Default\\MenuPopup\\.Current"), 
    FV_DEFAULT, TRUE, (FROST_VALUE *)NULL, 0, FC_SOUND},

   {TEXT("AppEvents\\Schemes\\Apps\\.Default\\Minimize\\.Current"), 
    FV_DEFAULT, TRUE, (FROST_VALUE *)NULL, 0, FC_SOUND},

   {TEXT("AppEvents\\Schemes\\Apps\\.Default\\Open\\.Current"),
    FV_DEFAULT, TRUE, (FROST_VALUE *)NULL, 0, FC_SOUND},

   {TEXT("AppEvents\\Schemes\\Apps\\.Default\\Close\\.Current"), 
    FV_DEFAULT, TRUE, (FROST_VALUE *)NULL, 0, FC_SOUND},

   {TEXT("AppEvents\\Schemes\\Apps\\.Default\\MailBeep\\.Current"),
    FV_DEFAULT, TRUE, (FROST_VALUE *)NULL, 0, FC_SOUND},

   {TEXT("AppEvents\\Schemes\\Apps\\.Default\\RestoreDown\\.Current"), 
    FV_DEFAULT, TRUE, (FROST_VALUE *)NULL, 0, FC_SOUND},

   {TEXT("AppEvents\\Schemes\\Apps\\.Default\\RestoreUp\\.Current"), 
    FV_DEFAULT, TRUE, (FROST_VALUE *)NULL, 0, FC_SOUND},

   {TEXT("AppEvents\\Schemes\\Apps\\.Default\\RingIn\\.Current"), 
    FV_DEFAULT, TRUE, (FROST_VALUE *)NULL, 0, FC_SOUND},

   {TEXT("AppEvents\\Schemes\\Apps\\.Default\\Ringout\\.Current"), 
    FV_DEFAULT, TRUE, (FROST_VALUE *)NULL, 0, FC_SOUND},

   {TEXT("AppEvents\\Schemes\\Apps\\.Default\\SystemAsterisk\\.Current"), 
    FV_DEFAULT, TRUE, (FROST_VALUE *)NULL, 0, FC_SOUND},

   {TEXT("AppEvents\\Schemes\\Apps\\.Default\\SystemDefault\\.Current"), 
    FV_DEFAULT, TRUE, (FROST_VALUE *)NULL, 0, FC_SOUND},

   {TEXT("AppEvents\\Schemes\\Apps\\.Default\\SystemExclamation\\.Current"), 
    FV_DEFAULT, TRUE, (FROST_VALUE *)NULL, 0, FC_SOUND},

   {TEXT("AppEvents\\Schemes\\Apps\\.Default\\SystemExit\\.Current"), 
    FV_DEFAULT, TRUE, (FROST_VALUE *)NULL, 0, FC_SOUND},

   {TEXT("AppEvents\\Schemes\\Apps\\.Default\\SystemHand\\.Current"), 
    FV_DEFAULT, TRUE, (FROST_VALUE *)NULL, 0, FC_SOUND},

   {TEXT("AppEvents\\Schemes\\Apps\\.Default\\SystemQuestion\\.Current"), 
    FV_DEFAULT, TRUE, (FROST_VALUE *)NULL, 0, FC_SOUND},

   {TEXT("AppEvents\\Schemes\\Apps\\.Default\\SystemStart\\.Current"), 
    FV_DEFAULT, TRUE, (FROST_VALUE *)NULL, 0, FC_SOUND},

   {TEXT("AppEvents\\Schemes\\Apps\\Explorer\\EmptyRecycleBin\\.Current"), 
    FV_DEFAULT, TRUE, (FROST_VALUE *)NULL, 0, FC_SOUND}

// *** NUMBER AND ORDER ALERT
// If you add or delete CP\Foo items or add or delete sound keys,
// you have to change the First/Last Sound defines in frost.h
// and the stkSounds[] in etcdlg.c
// *** NUMBER AND ORDER ALERT

};



////////////////////////////////////////////////
//
// Special section for Theme Selector info
//

TCHAR szFrostSection[] = TEXT("MasterThemeSelector");
TCHAR szMagic[] = TEXT("MTSM");
TCHAR szVerify[] = TEXT("DABJDKT");
TCHAR szThemeBPP[] = TEXT("ThemeColorBPP");  // >=16 means the UI colors need HiColor
TCHAR szImageBPP[] = TEXT("ThemeImageBPP");  // >=16 means the wallpaper is HiColor
                                             // <=8  means the wallpaper is 8bpp only 
TCHAR szIconBPP[]  = TEXT("ThemeIconBPP");   // >=16 means the icons are HiColor


#ifdef REFERENCE_ONLY
// here is the concordance used between SetSysColors() and the registry values

   "ActiveTitle",           COLOR_ACTIVECAPTION,
   "Background",            COLOR_DESKTOP,
   "Hilight",               COLOR_HIGHLIGHT,
   "HilightText",           COLOR_HIGHLIGHTTEXT,
   "TitleText",             COLOR_CAPTIONTEXT,
   "Window",                COLOR_WINDOW,
   "WindowText",            COLOR_WINDOWTEXT,
   "Scrollbar",             COLOR_SCROLLBAR,
   "InactiveTitle",         COLOR_INACTIVECAPTION,
   "Menu",                  COLOR_MENU,
   "WindowFrame",           COLOR_WINDOWFRAME,
   "MenuText",              COLOR_MENUTEXT,
   "ActiveBorder",          COLOR_ACTIVEBORDER,
   "InactiveBorder",        COLOR_INACTIVEBORDER,
   "AppWorkspace",          COLOR_APPWORKSPACE,
   "ButtonFace",            COLOR_3DFACE,
   "ButtonShadow",          COLOR_3DSHADOW,
   "GrayText",              COLOR_GRAYTEXT,
   "ButtonText",            COLOR_BTNTEXT,
   "InactiveTitleText",     COLOR_INACTIVECAPTIONTEXT,
   "ButtonHilight",         COLOR_3DHILIGHT,
   "ButtonDkShadow",        COLOR_3DDKSHADOW,
   "ButtonLight",           COLOR_3DLIGHT,
   "InfoText",              COLOR_INFOTEXT,
   "InfoWindow",            COLOR_INFOBK,
   "GradientActiveTitle"    COLOR_GRADIENTACTIVECAPTION,
   "GradientInactiveTitle"  COLOR_GRADIENTINACTIVECAPTION,
//   "MessageBox",      ,
//   "MessageBoxText",  ,
#endif




////////////////////////////////////////////////
//
// Keep the below around for reference. From orig file from DavidBa
//

#ifdef ORIG_INFO

;icons
;My Computer icon
[HKEY_CLASSES_ROOT\CLSID\{20D04FE0-3AEA-1069-A2D8-08002B30309D}\DefaultIcon]
@="bfly3.ico"

;Net hood Icon
[HKEY_CLASSES_ROOT\CLSID\{208D2C60-3AEA-1069-A2D7-08002B30309D}\DefaultIcon]
@="nest2.ico"

;Wastebasket icon
[HKEY_CLASSES_ROOT\CLSID\{645FF040-5081-101B-9F08-00AA002F954E}\DefaultIcon]
@="fire4.ico"
"full"="fire4.ico"
"empty"="fire4.ico"

;colors
[HKEY_CURRENT_USER\Control Panel\Colors]
"ActiveTitle"="0 0 255"
"Background"="128 128 128"
"Hilight"="0 0 0"
"HilightText"="255 255 255"
"TitleText"="255 255 255"
"Window"="255 255 255"
"WindowText"="0 0 0"
"Scrollbar"="164 198 221"
"InactiveTitle"="0 0 128"
"Menu"="164 198 221"
"WindowFrame"="0 0 0"
"MenuText"="0 0 0"
"ActiveBorder"="164 198 221"
"InactiveBorder"="164 198 221"
"AppWorkspace"="0 0 128"
"ButtonFace"="164 198 221"
"ButtonShadow"="128 128 128"
"GrayText"="128 128 128"
"ButtonText"="0 0 0"
"InactiveTitleText"="192 192 192"
"ButtonHilight"="255 255 255"
"ButtonDkShadow"="0 0 0"
"ButtonLight"="164 198 221"
"MessageBox"="255 0 0"
"MessageBoxText"="0 0 0"
"InfoText"="164 198 221"
"InfoWindow"="0 0 0"
"GradientActiveTitle"="0,0,128"
"GradientInactiveTitle"="128,128,128"

;Cursors
[HKEY_CURRENT_USER\Control Panel\Cursors]
"Arrow"="c:\\booger.cur"
"Help"=""
"AppStarting"=""
"Wait"=""
"NWPen"=""
"No"=""
"SizeNS"=""
"SizeWE"=""
@=""
"Crosshair"=""
"IBeam"=""
"SizeNWSE"=""
"SizeNESW"=""
"SizeAll"=""
"UpArrow"=""


;Sounds
[HKEY_CURRENT_USER\AppEvents\Schemes\Apps\.Default\.Default\.Current]
@="C:\\WINDOWS\\media\\Frosting\\Default.wav"

[HKEY_CURRENT_USER\AppEvents\Schemes\Apps\.Default\AppGPFault\.Current]
@="C:\\WINDOWS\\media\\Frosting\\AppGPFault.wav"

[HKEY_CURRENT_USER\AppEvents\Schemes\Apps\.Default\Maximize\.Current]
@="C:\\WINDOWS\\media\\Frosting\\Maximize.wav"

[HKEY_CURRENT_USER\AppEvents\Schemes\Apps\.Default\MenuCommand\.Current]
@="C:\\WINDOWS\\media\\Frosting\\MenuCommand.wav"

[HKEY_CURRENT_USER\AppEvents\Schemes\Apps\.Default\MenuPopup\.Current]
@="C:\\WINDOWS\\media\\Frosting\\MenuPopup.wav"

[HKEY_CURRENT_USER\AppEvents\Schemes\Apps\.Default\Minimize\.Current]
@="C:\\WINDOWS\\media\\Frosting\\Minimize.wav"

[HKEY_CURRENT_USER\AppEvents\Schemes\Apps\.Default\Open\.Current]
@="C:\\WINDOWS\\media\\Frosting\\Open.wav"

[HKEY_CURRENT_USER\AppEvents\Schemes\Apps\.Default\RestoreDown\.Current]
@="C:\\WINDOWS\\media\\Frosting\\RestoreDown.wav"

[HKEY_CURRENT_USER\AppEvents\Schemes\Apps\.Default\RestoreUp\.Current]
@="C:\\WINDOWS\\media\\Frosting\\RestoreUp.wav"

[HKEY_CURRENT_USER\AppEvents\Schemes\Apps\.Default\RingIn\.Current]
@="C:\\WINDOWS\\media\\Frosting\\RingIn.wav"

[HKEY_CURRENT_USER\AppEvents\Schemes\Apps\.Default\Ringout\.Current]
@="C:\\WINDOWS\\media\\Frosting\\Ringout.wav"

[HKEY_CURRENT_USER\AppEvents\Schemes\Apps\.Default\SystemAsterisk\.Current]
@="C:\\WINDOWS\\media\\Frosting\\SystemAsterisk.wav"

[HKEY_CURRENT_USER\AppEvents\Schemes\Apps\.Default\SystemDefault\.Current]
@="C:\\WINDOWS\\media\\Frosting\\SystemDefault.wav"

[HKEY_CURRENT_USER\AppEvents\Schemes\Apps\.Default\SystemExclamation\.Current]
@="C:\\WINDOWS\\media\\Frosting\\SystemExclamation.wav"

[HKEY_CURRENT_USER\AppEvents\Schemes\Apps\.Default\SystemExit\.Current]
@="C:\\WINDOWS\\media\\Frosting\\SystemExit.wav"

[HKEY_CURRENT_USER\AppEvents\Schemes\Apps\.Default\SystemHand\.Current]
@="C:\\WINDOWS\\media\\Frosting\\SystemHand.wav"

[HKEY_CURRENT_USER\AppEvents\Schemes\Apps\.Default\SystemQuestion\.Current]
@="C:\\WINDOWS\\media\\Frosting\\SystemQuestion.wav"

[HKEY_CURRENT_USER\AppEvents\Schemes\Apps\.Default\SystemStart\.Current]
@="C:\\WINDOWS\\media\\Frosting\\SystemStart.wav"

[HKEY_CURRENT_USER\AppEvents\Schemes\Apps\Explorer\EmptyRecycleBin\.Current]
@="C:\\WINDOWS\\media\\Frosting\\EmptyRecycleBin.wav"

;Desktop stuff

[HKEY_CURRENT_USER\Control Panel\Desktop]
"Wallpaper"="C:\\WINDOWS\\FROSTING\\BACKDROP.BMP"
"TileWallpaper"="0"
"BorderWidth"="4"
"ScreenSaveActive"="1"
"WallPaperOriginX"="0"
"WallPaperOriginY"="0"
"Pattern"="(None)"
"ScreenSaveUsePassword"=dword:00000000
"WallpaperStyle"="0"
"ScreenSave_Data"=hex:30,43,00

[HKEY_CURRENT_USER\Control Panel\Desktop\WindowMetrics]
"BorderWidth"="-15"
"ScrollWidth"="-195"
"ScrollHeight"="-195"
"CaptionWidth"="-270"
"CaptionHeight"="-270"
"SmCaptionWidth"="-225"
"SmCaptionHeight"="-225"
"MenuWidth"="-270"
"MenuHeight"="-270"

"CaptionFont"=hex:0a,00,00,00,00,00,00,00,bc,02,00,00,00,00,00,00,00,00,4d,53,\
20,53,61,6e,73,20,53,65,72,69,66,00,00,3b,00,00,50,7f,00,00,38,7f,63,00,00,\
  00,00,00,01,00

"SmCaptionFont"=hex:06,00,00,00,00,00,00,00,bc,02,00,00,00,00,00,00,00,00,4d,\
53,20,53,61,6e,73,20,53,65,72,69,66,00,00,3b,00,00,50,7f,00,00,38,7f,63,00,\
  00,00,00,00,01,00

"MenuFont"=hex:0a,00,00,00,00,00,00,00,90,01,00,00,00,00,00,00,00,00,4d,53,20,\
53,61,6e,73,20,53,65,72,69,66,00,00,3b,00,00,50,7f,00,00,38,7f,63,00,00,00,\
  00,00,01,00

"StatusFont"=hex:08,00,00,00,00,00,00,00,90,01,00,00,00,00,00,00,00,00,4d,53,\
20,53,61,6e,73,20,53,65,72,69,66,00,00,3b,00,00,50,7f,00,00,38,7f,63,00,00,\
  00,00,00,01,00

"MessageFont"=hex:0a,00,00,00,00,00,00,00,90,01,00,00,00,00,00,00,00,00,54,69,\
6d,65,73,20,4e,65,77,20,52,6f,6d,61,6e,00,00,00,50,7f,00,00,38,7f,63,00,00,\
00,00,00,01,00

"IconFont"=hex:06,00,00,00,00,00,00,00,90,01,00,00,00,00,00,00,00,00,4d,53,20,\
53,61,6e,73,20,53,65,72,69,66,00,1c,81,93,69,cc,82,bf,42,89,00,03,00,54,01,\
  b4,81,bf,42
"IconSpacing"="-1395"
"IconVerticalSpacing"="-1125"
"Shell Icon Size"="32"
"Shell Icon Depth"=""
"IconTitleWrap"="0"
"IconSpacingFactor"="100"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\init.c ===
/* INIT.C
   Resident Code Segment      // Tweak: make non-resident

   Initialization and destroy routines

   InitFrost()
   CloseFrost()

   Frosting: Master Theme Selector for Windows '95
   Copyright (c) 1994-1999 Microsoft Corporation. All rights reserved.
*/

// ---------------------------------------------
// Brief file history:
// Alpha:
// Beta:
// Bug fixes
// ---------
//
// ---------------------------------------------

#include "windows.h"
#include "frost.h"
#include "global.h"
#include "schedule.h"
#include "htmlprev.h"

// Local Routines
BOOL InitInstance(HINSTANCE, HINSTANCE, int);
BOOL GetRotateTheme(LPTSTR);

// Globals
TCHAR szPlus_CurTheme[] = TEXT("Software\\Microsoft\\Plus!\\Themes\\Current");
TCHAR szPlus_CBs[] = TEXT("Software\\Microsoft\\Plus!\\Themes\\Apply");

#define bThemed (*szCurThemeFile)

// Reg paths for finding potential Theme directories
#define PLUS95_KEY        TEXT("Software\\Microsoft\\Plus!\\Setup")
#define PLUS95_PATH       TEXT("DestPath")
#define PLUS98_KEY        TEXT("Software\\Microsoft\\Plus!98")
#define PLUS98_PATH       TEXT("Path")
#define KIDS_KEY          TEXT("Software\\Microsoft\\Microsoft Kids\\Kids Plus!")
#define KIDS_PATH         TEXT("InstallDir")
#define PROGRAMFILES_KEY  TEXT("Software\\Microsoft\\Windows\\CurrentVersion")
#define PROGRAMFILES_PATH TEXT("ProgramFilesDir")

//  ProcessCmdLine
//
//  Very basic commandline: "/s themefile" to apply theme
//                          "themefile" to open app with theme selected
//                                      and curdir to be that file's dir
//
//  Return: TRUE if we should exit the app
//          FALSE to continue execution
//
BOOL ProcessCmdLine(LPTSTR lpCmdLine)
{
    extern TCHAR szFrostSection[], szMagic[], szVerify[];
    BOOL fSetTheme = FALSE;
    BOOL fRotateTheme = FALSE;
    LPTSTR lpszThemeFile;
    BOOL fStopOnQuote = FALSE;
    WIN32_FIND_DATA wfdFind;
    HANDLE hFind;
    TCHAR szRotateTheme[MAX_PATH];
    // TCHAR szThemesExe[MAX_PATH];
    DWORD dwRet;
    HKEY hKey;
    extern TCHAR szPlus_CurTheme[];

    Assert(0, TEXT("Cmd line: '"));
    Assert(0, lpCmdLine);
    Assert(0, TEXT("'\n"));

    //  Skip leading whitespace.
    while (*lpCmdLine && (*lpCmdLine != TEXT('/')))
        lpCmdLine = CharNext(lpCmdLine);

    //  Check for special switches.
    if (*lpCmdLine == TEXT('/')) {
        lpCmdLine = CharNext(lpCmdLine);
        switch (*lpCmdLine) {
            //  "Set" theme as active.
            case TEXT('s'):
            case TEXT('S'):
                fSetTheme = TRUE;
                lpCmdLine = CharNext(lpCmdLine);
                break;
            case TEXT('r'):
            case TEXT('R'):
                fRotateTheme = TRUE;
                lpCmdLine = CharNext(lpCmdLine);
                break;
            default:
                return FALSE;       // invalid flag so continue execution EXIT
        }
        while (*lpCmdLine == TEXT(' '))
            lpCmdLine = CharNext(lpCmdLine);
    }

    //  Handle quoted long file names.  Even if the name isn't quoted, we'll
    //  still parse to the end of the commandline.
    if (*lpCmdLine == TEXT('\"')) {
        fStopOnQuote = TRUE;
        lpCmdLine = CharNext(lpCmdLine);
    }

    lpszThemeFile = lpCmdLine;

    //  Parse until end of line or we find the closing quote.
    while (*lpCmdLine && !(fStopOnQuote && *lpCmdLine == TEXT('\"')))
        lpCmdLine = CharNext(lpCmdLine);

    //  Back up to the last non-whitespace character.
    while (lpCmdLine > lpszThemeFile && *(lpCmdLine-1) == TEXT(' '))
        lpCmdLine = CharPrev(lpszThemeFile, lpCmdLine);

    //  If there's anything after the closing quote, so what?
    *lpCmdLine = TEXT('\0');

    //  This is our chance to fake a theme rotation "/r" into the
    //  "/s" paradigm.  Let's get a string to the next theme in the
    //  rotation.

    if (fRotateTheme) {
        if (GetRotateTheme(szRotateTheme)) {
           fSetTheme = TRUE;
           lpszThemeFile = szRotateTheme;           
        }
        // GetRotateTheme failed.  If we fall through we're likely
        // to display the main dialog and we don't want to do that
        // in the "/r" case.  Just exit the app.
        else return TRUE;
    }

    //  After all that work, nothing was specified on the commandline.
    if (lpszThemeFile == lpCmdLine)
        return FALSE;               // no filename so continue execution EXIT

    //
    // OK: you've got a theme file. if it is for real, save it for use.
    // first check existence
    hFind = FindFirstFile(lpszThemeFile, (LPWIN32_FIND_DATA)&wfdFind);
    if (INVALID_HANDLE_VALUE == hFind)
       return (TRUE);              // file doesn't exist so continue execution EXIT
                                   // PLUS98 BUG 1293 -- this used to return FALSE
                                   // and open the Theme applet if /s had an invalid
                                   // file.  Now we return TRUE which closes Themes

    // then check for magic string
    GetPrivateProfileString((LPTSTR)szFrostSection,
                            (LPTSTR)szMagic,
                            (LPTSTR)szNULL,
                            (LPTSTR)szMsg, MAX_MSGLEN,
                            lpszThemeFile);

    // magic str check
    if (lstrcmp((LPTSTR)szMsg, (LPTSTR)szVerify)) {
       // No magic string so this must not be a real theme file.
       // If this was from a "/r" rotate we want to return TRUE and
       // bail out.  Otherwise return FALSE so we open the Theme
       // app. (this was the existing Plus 95 behavior):
       if (fRotateTheme) return (TRUE);
       else  return (FALSE);
    }

   //
   // get the confirmed theme into the necessary globals

   // save theme file using the long filename
   lstrcpy(szCurThemeFile, lpszThemeFile);      // actual pathname verified
   // save cur dir (not theme dir)
   lstrcpy(szCurDir, szCurThemeFile);
   *(FileFromPath(szCurDir)) = 0;
   // save theme name
   lstrcpy(szCurThemeName, wfdFind.cFileName);  // make sure long filename
   TruncateExt(szCurThemeName);

   // now maybe we just want to apply the theme and exit
   if (fSetTheme) {
         // Make sure there is even enough space to do theme
         // But don't complain, if there isn't
      if (! CheckSpace (NULL, FALSE))   // definition in Regutils.c
         return FALSE;

      //  Make the apply code write out everything.
      InitCheckboxes();

      // Simulate a left shift keypress to wake up the screensaver.
      // Otherwise if the SS is running and we apply a new SS you
      // can wind up with dueling savers...
      keybd_event(VK_LSHIFT, 0, 0, 0);
      keybd_event(VK_LSHIFT, 0, KEYEVENTF_KEYUP, 0);

      ApplyThemeFile(lpszThemeFile);
      // APPCOMPAT -- Plus95 Themes was not updating the Current Theme
      // setting in the registry on this codepath.  Need to fix that
      // here.

      dwRet = RegOpenKeyEx(HKEY_CURRENT_USER, szPlus_CurTheme,
                          (DWORD)0, KEY_SET_VALUE, (PHKEY)&hKey );
      if (dwRet != ERROR_SUCCESS) {
         DWORD dwDisposition;
         Assert(FALSE, TEXT("couldn't RegOpenKey save theme file\n"));
         dwRet = RegCreateKeyEx( HKEY_CURRENT_USER, szPlus_CurTheme,
                            (DWORD)0, (LPTSTR)szNULL, REG_OPTION_NON_VOLATILE,
                            KEY_SET_VALUE, (LPSECURITY_ATTRIBUTES)NULL,
                            (PHKEY)&hKey, (LPDWORD)&dwDisposition );
      }
      // if open or create worked
      if (dwRet == ERROR_SUCCESS) {
         dwRet = RegSetValueEx(hKey, (LPTSTR)NULL, // default value
                             0,
                             (DWORD)REG_SZ,
                             (LPBYTE)lpszThemeFile,
                             (DWORD)( SZSIZEINBYTES((LPTSTR)szCurThemeFile) + 1 ));
          RegCloseKey(hKey);
       }

       Assert(dwRet == ERROR_SUCCESS, TEXT("couldn't open, set or create Registry save theme file\n"));
       return TRUE;                // set the theme so now just exit app EXIT
   } // end if fSetTheme

   return FALSE;                   // continue execution
}

// InitFrost
// Since there are no window classes to register, this routine just loads
// the strings and, since there's only one instance, calls InitInstance().
//
// Returns: success of initialization

BOOL FAR InitFrost(hPrevInstance, hInstance, lpCmdLine, nCmdShow)
HINSTANCE hPrevInstance;
HINSTANCE hInstance;                   /* Current instance identifier.       */
LPTSTR lpCmdLine;
int nCmdShow;                          /* Param for first ShowWindow() call. */
{
   LPTSTR lpScan, lpTemp;
   WNDCLASS WndClass;
   BOOL bret;
   BOOL bGotThemeDir;
   HDC hdc;

   //
   // Get initial strings
   // (Gauranteed enough mem at app init for these loads)
   InitNoMem(hInstance);
   LoadString(hInstance, STR_APPNAME, szAppName, MAX_STRLEN);
   LoadString(hInstance, STR_CURSET, szCurSettings, MAX_STRLEN);
   LoadString(hInstance, STR_PREVSET, szPrevSettings, MAX_STRLEN);
   LoadString(hInstance, STR_PREVSETFILE, szPrevSettingsFilename, MAX_STRLEN);
   LoadString(hInstance, STR_OTHERTHM, szOther, MAX_STRLEN);
   LoadString(hInstance, STR_THMEXT, szExt, MAX_STRLEN);
   LoadString(hInstance, STR_PREVIEWTITLE, szPreviewTitle, MAX_STRLEN);
   LoadString(hInstance, STR_HELPFILE, szHelpFile, MAX_STRLEN);
   LoadString(hInstance, STR_HELPFILE98, szHelpFile98, MAX_STRLEN);
   LoadString(hInstApp, STR_SUGGEST, szNewFile, MAX_STRLEN);
   LoadString(hInstApp, STR_SAVETITLE, szSaveTitle, MAX_STRLEN);
   LoadString(hInstApp, STR_OPENTITLE, szOpenTitle, MAX_STRLEN);
   LoadString(hInstApp, STR_FILETYPE, szFileTypeDesc, MAX_STRLEN);

   WndClass.style = CS_DBLCLKS | CS_BYTEALIGNWINDOW | CS_GLOBALCLASS;
   WndClass.lpfnWndProc = DefDlgProc;
   WndClass.cbClsExtra = 0;
   WndClass.cbWndExtra = DLGWINDOWEXTRA;
   WndClass.hInstance = hInstApp;
   WndClass.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(FROST_ICON));
   WndClass.hCursor = LoadCursor(NULL, IDC_ARROW);
   WndClass.hbrBackground = (HBRUSH) (COLOR_3DFACE + 1);
   WndClass.lpszMenuName = NULL;
   WndClass.lpszClassName = szClassName;

   if (!RegisterClass(&WndClass))
      return FALSE;

   // Initialize our g_bGradient flag
   hdc = GetDC(NULL);
   g_bGradient = (BOOL)(GetDeviceCaps(hdc, BITSPIXEL) > 8);
   ReleaseDC(NULL, hdc);

   //
   // build file search string
   lpScan = (LPTSTR)szFileTypeDesc;
   while (*lpScan) {
      if (2 == CompareString(LOCALE_USER_DEFAULT, NORM_IGNOREWIDTH,
                             (LPTSTR)TEXT("|"), 1, lpScan, 1)) {
         lpTemp = lpScan;
         lpScan = CharNext(lpScan);
         *lpTemp = 0;
      }
      else
         lpScan = CharNext(lpScan);
   }

   //
   // init directory strings

   // theme directory - for now it is subdir of EXE dir
   GetModuleFileName(hInstApp, (LPTSTR)szThemeDir, MAX_PATHLEN);
   *(FileFromPath((LPTSTR)szThemeDir)) = 0;   // leaves trailing '\'

   // Save this path momentarily -- if we can't find any good Themes
   // directory we're going to fall back to this directory.
   lstrcpy(szCurDir, szThemeDir);

   // Tack a "Themes" onto the path
   LoadString(hInstance, STR_THEMESUBDIR,     // includes trailing '\'
              (LPTSTR)(szThemeDir + lstrlen((LPTSTR)szThemeDir)), MAX_STRLEN);

   // Find out if this ThemeDir even exists.  If it doesn't we need
   // to get creative in finding our ThemeDir by searching the
   // following locales:
   //
   //   Plus!98 Install Path\Themes
   //   Plus!95 Install Path\Themes
   //   Kids for Plus! Install Path\Themes
   //   Program Files\Plus!\Themes

   bGotThemeDir = FALSE;

   Assert(0, TEXT("Themes.exe\\Themes path: "));
   Assert(0, szThemeDir);
   Assert(0, TEXT("\n"));
   if (0xFFFFFFFF != GetFileAttributes(szThemeDir)) bGotThemeDir = TRUE;

   if (!bGotThemeDir)
   {
      // Haven't found ThemeDir yet.  Try the Plus!98 location

      bret = HandGet(HKEY_LOCAL_MACHINE, PLUS98_KEY,
                     PLUS98_PATH, (LPTSTR)szThemeDir);

      if (bret)
      {
         // Tack a "Themes" onto the path
         lstrcat(szThemeDir, TEXT("\\"));
         LoadString(hInstance, STR_THEMESUBDIR,
                    (szThemeDir + lstrlen((LPTSTR)szThemeDir)), MAX_STRLEN);

         Assert(0, TEXT("Plus! 98 path: "));
         Assert(0, szThemeDir);
         Assert(0, TEXT("\n"));
         if (0xFFFFFFFF != GetFileAttributes(szThemeDir)) bGotThemeDir = TRUE;
      }
   }

   if (!bGotThemeDir)
   {
      // Still haven't found ThemeDir.  Try the Plus! 95 location

      bret = HandGet(HKEY_LOCAL_MACHINE, PLUS95_KEY,
                      PLUS95_PATH, (LPTSTR)szThemeDir);

      if (bret)
      {
         // Tack on a "Themes" onto the path
         // Plus!95 DestPath has "Plus!.dll" on the end so get rid
         // of that.
         *(FileFromPath(szThemeDir)) = 0;
         LoadString(hInstance, STR_THEMESUBDIR,
         (szThemeDir + lstrlen((LPTSTR)szThemeDir)), MAX_STRLEN);

         Assert(0, TEXT("Plus! 95 path: "));
         Assert(0, szThemeDir);
         Assert(0, TEXT("\n"));

         if (0xFFFFFFFF != GetFileAttributes(szThemeDir)) bGotThemeDir = TRUE;
      }
   }

   if (!bGotThemeDir)
   {
      // Still haven't found ThemeDir.  Try the Kids for Plus! location

      bret = HandGet(HKEY_LOCAL_MACHINE, KIDS_KEY,
                     KIDS_PATH, (LPTSTR)szThemeDir);

      if (bret)
      {
         // Tack a "\Plus! for Kids\Themes" onto the path
         lstrcat(szThemeDir, TEXT("\\Plus! for Kids\\"));
         LoadString(hInstance, STR_THEMESUBDIR,
                    (szThemeDir + lstrlen((LPTSTR)szThemeDir)), MAX_STRLEN);

         Assert(0, TEXT("Kids Plus! path: "));
         Assert(0, szThemeDir);
         Assert(0, TEXT("\n"));

         if (0xFFFFFFFF != GetFileAttributes(szThemeDir)) bGotThemeDir = TRUE;
      }
   }

   if (!bGotThemeDir)
   {
      // Still haven't found ThemeDir.  Try the Program Files\Plus! location

      bret = HandGet(HKEY_LOCAL_MACHINE, PROGRAMFILES_KEY,
                     PROGRAMFILES_PATH, (LPTSTR)szThemeDir);

      if (bret)
      {
         // Tack a "Plus!\Themes" onto the path
         lstrcat(szThemeDir, TEXT("\\Plus!\\"));
         LoadString(hInstance, STR_THEMESUBDIR,
                   (szThemeDir + lstrlen((LPTSTR)szThemeDir)), MAX_STRLEN);

         Assert(0, TEXT("Program Files path: "));
         Assert(0, szThemeDir);
         Assert(0, TEXT("\n"));

         if (0xFFFFFFFF != GetFileAttributes(szThemeDir)) bGotThemeDir = TRUE;
      }
   }

   if (!bGotThemeDir)
   {
      // After all that searching we still haven't found a good Theme
      // dir.  So we'll just use the directory where Themes.exe is
      // located -- we saved this in szCurDir before we started this
      // search process.

      lstrcpy(szThemeDir, szCurDir);

      Assert(0, TEXT("Themes.exe path: "));
      Assert(0, szThemeDir);
      Assert(0, TEXT("\n"));

   }

   // default current dir
   lstrcpy((LPTSTR)szCurDir, (LPTSTR)szThemeDir);

   // Windows directory
   GetWindowsDirectory((LPTSTR)szWinDir, MAX_PATHLEN);
   if (TEXT('\\') != szWinDir[lstrlen((LPTSTR)szWinDir)-1])
      lstrcat((LPTSTR)szWinDir, (LPTSTR)TEXT("\\"));

   //
   // see if there is a previous theme file to return to
   bret = HandGet(HKEY_CURRENT_USER, szPlus_CurTheme,
                  (LPTSTR)NULL, (LPTSTR)szMsg);
   Assert(bret, TEXT("no previous theme file in Registry!\n"));
   if (bret) {

      // get init cur dir from prev theme file
      lstrcpy(szCurDir, szMsg);
      *(FileFromPath(szCurDir)) = 0;

      // Used to actually set the cur theme file/name to prev theme.
      // Now we just use the directory if there is a prev theme.
      // No longer care if it is a real file or a theme file or not.
      #ifdef REVERT
      WIN32_FIND_DATA wfdFind;
      HANDLE hFind;
      extern TCHAR szFrostSection[], szMagic[], szVerify[];
      TCHAR szMagicTest[MAX_STRLEN+1];

      // first check if it is for real: existence
      hFind = FindFirstFile(szMsg, (LPWIN32_FIND_DATA)&wfdFind);
      if (INVALID_HANDLE_VALUE != hFind) {

         // then check if it is for real: theme file magic string
         GetPrivateProfileString((LPTSTR)szFrostSection,
                                 (LPTSTR)szMagic,
                                 (LPTSTR)szNULL,
                                 (LPTSTR)szMagicTest, MAX_STRLEN,
                                 szMsg);
         if (!lstrcmp((LPTSTR)szMagicTest, (LPTSTR)szVerify)) {

            //
            // now you're convinced that the prev theme file is legit
            //

            // then use it to set some globals
            lstrcpy(szCurThemeFile, szMsg);
            // save cur dir (not theme dir)
            lstrcpy(szCurDir, szCurThemeFile);
            *(FileFromPath(szCurDir)) = 0;
            // save theme name
            lstrcpy(szCurThemeName, FileFromPath(szCurThemeFile));
            TruncateExt(szCurThemeName);
         }
      }
      #endif   // REVERT
   }

   // then look if there is a command line that may override things
   if (ProcessCmdLine(lpCmdLine))
      return TRUE;                  // don't run app EXIT, hWndApp==NULL as flag

   // Single-instance application can call InitInstance() here
   // Return success of inst initialization
   return(InitInstance(hPrevInstance, hInstance, nCmdShow));
}


// InitInstance
// Create main window; assign globals for instance and window handles.
//
// Returns: success of initialization

BOOL InitInstance(hPrevInstance, hInstance, nCmdShow)
HINSTANCE hPrevInstance;
HINSTANCE hInstance;                   /* Current instance identifier.       */
int nCmdShow;                          /* Param for first ShowWindow() call. */

{
   RECT rWndApp, rWorkArea;
   TCHAR szThemesExe[MAX_PATH];

   // assign global instance handle
   hInstApp = hInstance;

   // create main window and assign global window handle
   bNoMem = FALSE;                     // clear out of mem flag
   hWndApp = CreateDialog( hInstApp,
                           MAKEINTRESOURCE(DLG_MAIN),
                           (HWND)NULL,
                           PreviewDlgProc
                         );
   if (!hWndApp || bNoMem)          // if problems, then bail
      return (FALSE);

   InitHTMLBM(); // Init the IThumbnail interface for HTML wallpaper support

   // have to init preview painting stuff after create dlg
   if (!PreviewInit()) {
      DestroyWindow(hWndApp);
      return (FALSE);               // low mem on dc/bmp create EXIT
   }


   // this doesn't work from WM_INITDIALOG, so added here, too
   InitCheckboxes();                // init stored values
   RestoreCheckboxes();             // init actual cbs from stored values
   if (bThemed)                     // kinda kludgy to put here but it works
      EnableWindow(GetDlgItem(hWndApp, PB_SAVE), FALSE);

   // also, can now make init Preview bmp for init paint
   BuildPreviewBitmap((LPTSTR)szCurThemeFile);

   // center main window on screen
   GetWindowRect(hWndApp, (LPRECT)&rWndApp);
   SystemParametersInfo(SPI_GETWORKAREA, 0, (PVOID)(LPRECT)&rWorkArea, 0);
   MoveWindow(hWndApp,
              ((rWorkArea.right-rWorkArea.left) - (rWndApp.right-rWndApp.left))/2,
              ((rWorkArea.bottom-rWorkArea.top) - (rWndApp.bottom-rWndApp.top))/2,
//              (GetSystemMetrics(SM_CXSCREEN) - (rWndApp.right-rWndApp.left))/2,
//              (GetSystemMetrics(SM_CYSCREEN) - (rWndApp.bottom-rWndApp.top))/2,
              rWndApp.right-rWndApp.left, rWndApp.bottom-rWndApp.top,
              FALSE);               // don't repaint

   // Make the main window visible; update its client area
   ShowWindow(hWndApp, nCmdShow);   /* Show the window */
   UpdateWindow(hWndApp);           /* Sends WM_PAINT message */

// Check to see if CB_SCHEDULE is checked and verify that Task
// Scheduler is running and the Themes task exists as appropriate

   if (bCBStates[FC_SCHEDULE]) {
      if (IsTaskSchedulerRunning()) {
         if (!IsThemesScheduled()) {
            GetModuleFileName(hInstApp, (LPTSTR)szThemesExe, MAX_PATH);
            if (!AddThemesTask(szThemesExe, TRUE /*Show errors*/)) {
               // Couldn't add task -- ATT gave error but need to clear
               // SCHEDULE CB
               bCBStates[FC_SCHEDULE] = FALSE;
               RestoreCheckboxes();
               SaveStates();  // Write checkbox states to registry
            }
         } // Themes.job exists so do nothing
      }
      else {
         // Zonk -- Task Scheduler isn't running.  Start it.
         if (StartTaskScheduler(TRUE /*prompt user*/)) {
            // Task scheduler started -- check if themes task already
            // exists
            if (!IsThemesScheduled()) {
               GetModuleFileName(hInstApp, (LPTSTR)szThemesExe, MAX_PATH);
               if (!AddThemesTask(szThemesExe, TRUE /*Show errors*/)) {
                  // Couldn't add task -- ATT gave error but need to clear
                  // SCHEDULE CB
                  bCBStates[FC_SCHEDULE] = FALSE;
                  RestoreCheckboxes();
                  SaveStates();  // Write checkbox states to registry
               }
            } //TS is running now and Themes.job exists
         }
         else {
            // Couldn't start TS -- STS() gave error.  Need to clear
            // SCHEDULE CB and HandDelete any existing Themes.job.
            // CheckDlgButton(hdlg, CB_SCHEDULE, BST_UNCHECKED);
            bCBStates[FC_SCHEDULE] = FALSE;
            RestoreCheckboxes();
            SaveStates();  // Write checkbox states to the registry
            HandDeleteThemesTask();
         }
      } // END ELSE Task Scheduler isn't running
   }
   else { // bCBStates[FC_CHECKBOX] != TRUE
      // SCHEDULE Checkbox is clear -- should delete Themes task.
      if (IsTaskSchedulerRunning()) DeleteThemesTask();
      else HandDeleteThemesTask();
   }

   // cleanup
   return (TRUE);                   // success
}


// CloseFrost
//
// Cleanup your objects, thunks, etc.
//

void FAR CloseFrost()
{
   // just extra tidy housekeeping
   hWndApp = NULL;
   hInstApp = NULL;

   PreviewDestroy();
}


// SaveStates
//
// Remember persistent states: currently checkboxes.
// Last applied theme is remembered at Apply time.
//
void FAR SaveStates()
{
   LONG lret;
   HKEY hKey;
   int iter;

   //
   // checkboxes
   //
   lret = RegOpenKeyEx(HKEY_CURRENT_USER, szPlus_CBs,
                       (DWORD)0, KEY_SET_VALUE, (PHKEY)&hKey );
   if (lret != ERROR_SUCCESS) {
      DWORD dwDisposition;
      Assert(FALSE, TEXT("couldn't RegOpenKey save checkboxes\n"));
      lret = RegCreateKeyEx( HKEY_CURRENT_USER, szPlus_CBs,
                             (DWORD)0, (LPTSTR)szNULL, REG_OPTION_NON_VOLATILE,
                             KEY_SET_VALUE, (LPSECURITY_ATTRIBUTES)NULL,
                             (PHKEY)&hKey, (LPDWORD)&dwDisposition );
   }
   // if open or create worked
   if (lret == ERROR_SUCCESS) {

      for (iter = 0; iter < MAX_FCHECKS; iter ++) {
         if (bThemed)
            RegSetValueEx(hKey, (LPTSTR)szCBNames[iter],
                        0,
                        (DWORD)REG_SZ,
                        (LPBYTE)(IsDlgButtonChecked(hWndApp, iCBIDs[iter]) ?
                                 TEXT("1") : TEXT("0")),
                        (DWORD)2*sizeof(TCHAR));
         else  // cur win settings --> real states saved in bCBStates[]
            RegSetValueEx(hKey, (LPTSTR)szCBNames[iter],
                        0,
                        (DWORD)REG_SZ,
                        (LPBYTE)(bCBStates[iter] ? TEXT("1") : TEXT("0")),
                        (DWORD)2*sizeof(TCHAR));
      }

      // close when finished
      RegCloseKey(hKey);
   }
   else {
      Assert(FALSE, TEXT("couldn't open or create Registry save checkboxes\n"));
   }
}

BOOL GetRotateTheme(LPTSTR lpszRotateTheme)
{
   BOOL bRet = FALSE;
   TCHAR szThemesdir[MAX_PATH];
   HANDLE hFF;
   WIN32_FIND_DATA FindData;

   // WARNING -- If "next" .Theme file is not valid theme file we'll never rotate!

   // See if there is a current theme.
   szThemesdir[0] = TEXT('\0');
   bRet = HandGet(HKEY_CURRENT_USER, szPlus_CurTheme,
                  (LPTSTR)NULL, (LPTSTR)szThemesdir);

   // Do we have a current Theme?
   hFF = INVALID_HANDLE_VALUE;
   if (szThemesdir[0]) {

      // Yes we do, so do a FindFirst on it and make sure we've
      // got the long filename.
      ZeroMemory(&FindData, sizeof(WIN32_FIND_DATA));
      hFF = FindFirstFile(szThemesdir, &FindData);
   }

   // Did we find the file on FindFirst?  If so, proceed with finding
   // the next Theme in that directory else assume that the registry's
   // Current Theme setting is bogus and look in the default dir.

   if (INVALID_HANDLE_VALUE != hFF) {
      // Copy long filename.
      lstrcpy(lpszRotateTheme, FindData.cFileName);
      FindClose(hFF);

      // We've got the longfilename to the current Theme
      // Now do a FF/FN on *.Theme in the Theme dir until
      // we find the current theme.

      // Strip the theme file off the path.
      *(FileFromPath(szThemesdir)) = 0;
      lstrcat(szThemesdir, TEXT("*\0"));
      LoadString(NULL, STR_THMEXT, (szThemesdir + lstrlen(szThemesdir)),
                                        MAX_PATH);

      ZeroMemory(&FindData, sizeof(WIN32_FIND_DATA));
      hFF = FindFirstFile(szThemesdir, &FindData);

      if (INVALID_HANDLE_VALUE == hFF) {
         // We shouldn't hit this since we just found our current
         // theme in this directory.  If we do, just bail out.
         lpszRotateTheme[0] = TEXT('\0');
         return FALSE;
      }

      // Step through the .Theme files in this dir until we find our
      // current theme file.
      bRet = TRUE;
      while (lstrcmp(FindData.cFileName, lpszRotateTheme) && bRet) {
            bRet = FindNextFile(hFF, &FindData);
      }

      if (lstrcmp(FindData.cFileName, lpszRotateTheme)) {
         // We ran out of files before finding the current theme!?!?
         // Not likely...  Bail out.
         FindClose(hFF);
         lpszRotateTheme[0] = TEXT('\0');
         return FALSE;
      }

      // Assume the FindNext file is our current theme.  Let's
      // get the Next .Theme file -- that's what we're rotating to...

      if (FindNextFile(hFF, &FindData)) {
         *(FileFromPath(szThemesdir)) = 0;
         lstrcat(szThemesdir, FindData.cFileName);
         lstrcpy(lpszRotateTheme, szThemesdir);
         FindClose(hFF);
         return TRUE;
      }

      // OK, we failed to find another Theme file in the current dir
      // so assume our current Theme is the last in the list.  Go
      // back to the beginning and use the first Theme file we find
      // as our "rotate to" theme.

      else {
         FindClose(hFF);
         ZeroMemory(&FindData, sizeof(WIN32_FIND_DATA));
         hFF = FindFirstFile(szThemesdir, &FindData);

         if (INVALID_HANDLE_VALUE == hFF) {
            // This shouldn't fail since we just found our current
            // theme in this dir.  If it does, bail out.
            lpszRotateTheme[0] = TEXT('\0');
            return FALSE;
         }

         // This is our new/rotate file
         *(FileFromPath(szThemesdir)) = 0;
         lstrcat(szThemesdir, FindData.cFileName);
         lstrcpy (lpszRotateTheme, szThemesdir);
         FindClose(hFF);
         return TRUE;
      }
   }

   // No current theme applied or the Current Theme setting in the
   // registry is bogus so use the global szThemeDir setting and
   // look for a theme in that directory.
   else {
      lstrcpy(szThemesdir, szThemeDir);
      lstrcat(szThemesdir, TEXT("*\0"));
      LoadString(NULL, STR_THMEXT, (szThemesdir + lstrlen(szThemesdir)),
                                        MAX_PATH);

      ZeroMemory(&FindData, sizeof(WIN32_FIND_DATA));
      hFF = FindFirstFile(szThemesdir, &FindData);

      if (INVALID_HANDLE_VALUE == hFF) {
         // Apparently there are no themes available in the default
         // Themes directory.  We're hosed -- no rotation today.
         lpszRotateTheme[0] = TEXT('\0');
         return FALSE;
       }

       // This is our new/rotate file
       *(FileFromPath(szThemesdir)) = 0;
       lstrcat(szThemesdir, FindData.cFileName);
       lstrcpy (lpszRotateTheme, szThemesdir);
       FindClose(hFF);
       return TRUE;
   }

   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\htmlprev.cpp ===
/*  HTMLPREV.CPP
**
**  Copyright (c) 1997-1999 Microsoft Corporation.  All Rights Reserved.
**
**  Display a preview of the HTML wallpaper background,
**  complete with rudimentary palette handling and stretching
**  of bitmaps to fit the preview screen.
**
*/

#include <windows.h>
#include <mbctype.h>
#include <objbase.h>
#include <initguid.h>
#include "..\inc\thmbguid.h"
#include "..\inc\thmbobj.h"

#define WM_HTML_BITMAP  (WM_USER + 275)   // IThumbnail::GetBitmap msg
#define HTML_TIMER      777               // Unique timer ID

// WARNING THESE ARE ALSO DEFINED IN FROST.H -- JUST DON'T WANT TO
// INCLUDE ALL OF FROST.H HERE:
#define MAX_MSGLEN      512
// strings ids
#define STR_APPNAME     0     // Application name (for title bar)
#define STR_ERRHTML     26    // Error getting HTML wallpaper preview


// GLOBALS
extern "C" HWND hWndApp;
IThumbnail *g_pthumb = NULL;    // Html to Bitmap converter

extern "C" BOOL InitHTMLBM()
{

    HRESULT hr = E_FAIL;

    // Bring in the library

    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        return FALSE;
    }

    hr = CoCreateInstance(CLSID_Thumbnail, NULL, CLSCTX_INPROC_SERVER,
                                        IID_IThumbnail, (void **)&g_pthumb);

    if(SUCCEEDED(hr))
    {
        g_pthumb->Init(hWndApp, WM_HTML_BITMAP);
        return TRUE;
    }
    else
    {
        // CoUninitialize();
        g_pthumb = NULL;
        return FALSE;
    }

}

extern "C" HBITMAP HtmlToBmp(LPCTSTR szHTML, LONG lWidth, LONG lHeight)
{
    HBITMAP hbmWall;
#ifndef UNICODE
    WCHAR wszFile[MAX_PATH];
#endif
    DWORD dwItem = 13;  // Random choice of numbers for dwItem
    UINT uCodePage;
    MSG msg;
    TCHAR szMessage[MAX_MSGLEN];
    TCHAR szTitle[MAX_MSGLEN];
    UINT_PTR uTimer = 0;

    uCodePage = _getmbcp();

    // Paranoid check just in case
    if (!g_pthumb) {
       return NULL;
    }

    // MessageBox(hWndApp, szHTML, TEXT("Calling GetBitMap"), MB_OK | MB_APPLMODAL);
#ifndef UNICODE
    // IThumbnail interfaces expect wide strings.  Need to
    // convert ANSI szHTML into UNICODE.
    MultiByteToWideChar(uCodePage, 0, szHTML, -1,
                                             wszFile, MAX_PATH);

    g_pthumb->GetBitmap(wszFile, dwItem, lWidth, lHeight);
#else
    g_pthumb->GetBitmap(szHTML, dwItem, lWidth, lHeight);
#endif
    // Set a timer so we don't spin forever waiting on a dead GetBitMap call
    uTimer = SetTimer(hWndApp, HTML_TIMER, 60000 /*60 sec*/, NULL);

    LoadString(NULL, STR_APPNAME, szTitle, MAX_MSGLEN);
    LoadString(NULL, STR_ERRHTML, szMessage, MAX_MSGLEN);

    ZeroMemory(&msg, sizeof(MSG));

    while (TRUE) {
      // First check for Bitmap done message
      ZeroMemory(&msg, sizeof(MSG));
      if (PeekMessage(&msg, hWndApp, WM_HTML_BITMAP,
                      WM_HTML_BITMAP, PM_REMOVE)) {
        if (msg.wParam == dwItem && msg.lParam) {
           hbmWall = (HBITMAP)msg.lParam;
           if (uTimer) KillTimer(hWndApp, uTimer);
           return hbmWall;
        }
        else {
           if (uTimer) KillTimer(hWndApp, uTimer);
           MessageBox(hWndApp, szMessage, szTitle,
                                   MB_OK | MB_APPLMODAL | MB_ICONERROR);
           return NULL;
        }
      }

      // Now check to see if we've timed-out waiting on Getbitmap
      ZeroMemory(&msg, sizeof(MSG));
      if (PeekMessage(&msg, hWndApp, WM_TIMER, WM_TIMER, PM_REMOVE)) {
         if (msg.wParam == HTML_TIMER) {
            // We timed-out
            MessageBox(hWndApp, szMessage, szTitle,
                                     MB_OK | MB_APPLMODAL | MB_ICONERROR);
            return NULL;
         }
      }
    } // End While true

    // SHOULDN'T EVER FALL THROUGH TO THIS BUT JUST IN CASE
    return NULL;
}

extern "C" void CleanUp()
{
    if (g_pthumb) g_pthumb->Release();
    g_pthumb = NULL;
    CoUninitialize();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\nc.c ===
/* NC.C
   Resident Code Segment      // Tweak: make non-resident?

   Routines for reading and writing Non-client metrics, and icons.

   Roughly: Borders and Fonts and Icons stuff.

   GatherIconMetricsByHand();
   GatherNonClientMetricsByHand();
   SetIconMetricsByHand();
   SetNonClientMetricsByHand();

   Unlike all of the other items, we do not read and write these to the
   registry directly. Instead, we use the SystemParametersInfo(GET/SET)
   API.

   ***
   This is a low-header-comment file. The four functions just read and write
   two sets of params. Comments within the functions show the simple goings-
   on.

   Uses: global pValue buffer from REGUTILS.C
   ***

   Frosting: Master Theme Selector for Windows '95
   Copyright (c) 1994-1999 Microsoft Corporation.  All rights reserved.
*/

// ---------------------------------------------
// Brief file history:
// Alpha:
// Beta:
// Bug fixes
// ---------
//
// ---------------------------------------------

#include "windows.h"
#include <mbctype.h>
#include "frost.h"
#include "nc.h"


////////////////////////////////////////////////
//
// E X T E R N A L   F U N C T I O N S
//
// Uses external functions in REGUTILS.C,
// which was going to be the only function to
// read and write -- until we found we couldn't
// do these parameters live directly to the registry.
//
////////////////////////////////////////////////
extern BOOL FAR WriteBytesToFile(LPTSTR, LPTSTR, BYTE *, int, LPTSTR);
extern int FAR WriteBytesToBuffer(LPTSTR);

//
// LOCAL ROUTINES
//

//
// LOCAL GLOBALS
extern BOOL bReadOK, bWroteOK;


////////////////////////////////////////////////
//
// FONTS and BORDERS and ICONS
//
// These are done by hand only!
// These are all read and set with SystemParametersInfo() instead of reading
// and writing directly to the registry like the naughty app we are with most
// of the above.
//

// General
TCHAR szMetrics[] = TEXT("Metrics");
TCHAR szNCM[] = TEXT("NonclientMetrics");
TCHAR szIM[] = TEXT("IconMetrics");

TCHAR szCP_DT_WM[] = TEXT("Control Panel\\Desktop\\WindowMetrics");
TCHAR szIconSize[] = TEXT("Shell Icon Size");
TCHAR szSmallIconSize[] = TEXT("Shell Small Icon Size");

#ifdef FOO
// BORDERS
TCHAR szBorderWidth[] = TEXT("BorderWidth");
TCHAR szScrollWidth[] = TEXT("ScrollWidth");
TCHAR szScrollHeight[] = TEXT("ScrollHeight");
TCHAR szCapWidth[] = TEXT("CaptionWidth");
TCHAR szCapHeight[] = TEXT("CaptionHeight");
TCHAR szSmCapWidth[] = TEXT("SmCaptionWidth");
TCHAR szSmCapHeight[] = TEXT("SmCaptionHeight");
TCHAR szMenuWidth[] = TEXT("MenuWidth");
TCHAR szMenuHeight[] = TEXT("MenuHeight");

// FONTS styles and names and sizes mixed together
TCHAR szCapFont[] = TEXT("CaptionFont");
TCHAR szSmCapFont[] = TEXT("SmCaptionFont");
TCHAR szMenuFont[] = TEXT("MenuFont");
TCHAR szStatFont[] = TEXT("StatusFont");
TCHAR szMsgFont[] = TEXT("MessageFont");

// ICONS
TCHAR szIconFont[] = TEXT("IconFont");
TCHAR szIconVertSpacing[] = TEXT("IconVertSpacing");
TCHAR szIconHorzSpacing[] = TEXT("IconHorzSpacing");
#endif


// These two are in the registry, but do not correspond to
// anything in the Display CPL or SystemParametersInfo() code.
// I assume that these are set internally by the system
// based on the icon size (set directly in the registry earlier)
// and horz/vert spacing (set right above). DB will test
// and if it works for his themes, then we're there.
//   "IconSpacing";
//   "IconSpacingFactor";

// Later added these two by hand, in and out of reg, so can
// check for null values.
//
// {TEXT("Shell Icon Size"), REG_SZ, FC_ICONS},
// {TEXT("Shell Small Icon Size"), REG_SZ, FC_ICONS},


BOOL FAR GatherIconMetricsByHand(LPTSTR lpszTheme)
{
   ICONMETRICS im;
//   BOOL bOK, bret;
   BOOL bOK;
   extern BOOL bReadOK, bWroteOK;
#ifdef UNICODE
#ifdef FUDDY_DUDDY
   CHAR szTempA[10];
#endif
   ICONMETRICSA imA;
#endif

   // inits
   im.cbSize = sizeof(im);
   bOK = SystemParametersInfo(SPI_GETICONMETRICS, sizeof(im),
                              (void far *)(LPICONMETRICS)&im, FALSE);
   if (!bOK) bReadOK = FALSE;

   // write the whole kit and kaboodle

#ifdef UNICODE
   // Need to convert the ICONMETRICS structure to ANSI before writing
   // to the Theme file.
   ConvertIconMetricsToANSI((LPICONMETRICSW)&im, (LPICONMETRICSA)&imA);

   if (bOK) {
      bOK = WriteBytesToFile((LPTSTR)szMetrics, (LPTSTR)szIM,
                             (BYTE *)&(imA), sizeof(ICONMETRICSA), lpszTheme);
   }
#else
   // Currently ANSI so no need to convert ICONMETRICS before writing
   // to Theme file

   if (bOK) {
      bOK = WriteBytesToFile((LPTSTR)szMetrics, (LPTSTR)szIM,
                             (BYTE *)&(im), sizeof(ICONMETRICS), lpszTheme);
   }
#endif // UNICODE

   if (!bOK) bWroteOK = FALSE;

   #ifdef DOING_ICON_SIZES
   //
   // now get and store icon sizes

   // first Icon Size
   bret = HandGet(HKEY_CURRENT_USER, szCP_DT_WM,
                  szIconSize, (LPTSTR)pValue);
   Assert(bret, TEXT("couldn't get IconSize from Registry!\n"));
   bOK = bOK && bret;
   bret = WritePrivateProfileString((LPTSTR)szCP_DT_WM, (LPTSTR)szIconSize,
                                    // only store if got something, else null
                                    (LPTSTR)(bret ? pValue : szNULL),
                                    lpszTheme);
   bOK = bOK && bret;
   if (!bret) bWroteOK = FALSE;

   // then Small Icon Size
   bret = HandGet(HKEY_CURRENT_USER, szCP_DT_WM,
                  szSmallIconSize, (LPTSTR)pValue);
   Assert(bret, TEXT("couldn't get SmallIconSize from Registry!\n"));
   bOK = bOK && bret;
   bret = WritePrivateProfileString((LPTSTR)szCP_DT_WM, (LPTSTR)szSmallIconSize,
                                    // only store if got something, else null
                                    (LPTSTR)(bret ? pValue : szNULL),
                                    lpszTheme);
   bOK = bOK && bret;
   if (!bret) bWroteOK = FALSE;
   #endif // DOING_ICON_SIZES


   #ifdef FUDDY_DUDDY
   // 3 writes: translate to string and write to THM file
   if (bOK) {

      // write font to theme file
      // REARCHITECT: if we were really doing this you would want to convert
      // this LOGFONT to ANSI before writing to the Theme file.
      bRet = WriteBytesToFile((LPTSTR)szMetrics, (LPTSTR)szIconFont,
                              (BYTE *)&(im.lfFont), sizeof(LOGFONT), lpszTheme);
      bOK = bOK && bRet;

      // write vert spacing to theme file
#ifdef UNICODE
      litoa(im.iVertSpacing, szTempA);
      mbstowcs(pValue, szTempA, sizeof(szTempA));
#else
      litoa(im.iVertSpacing, (LPTSTR)pValue);
#endif
      bRet = WritePrivateProfileString((LPTSTR)szMetrics, (LPTSTR)szIconVertSpacing,
                                       (LPTSTR)pValue, lpszTheme);

      bOK = bOK && bRet;

      // write horz spacing to theme file
#ifdef UNICODE
      litoa(im.iHorzSpacing, szTempA);
      mbstowcs(pValue, szTempA, sizeof(szTempA));
#else
      litoa(im.iHorzSpacing, (LPTSTR)pValue);
#endif
      bRet = WritePrivateProfileString((LPTSTR)szMetrics, (LPTSTR)szIconHorzSpacing,
                                       (LPTSTR)pValue, lpszTheme);
      bOK = bOK && bRet;
   }
   #endif // FUDDY_DUDDY

   // cleanup
   Assert(bOK, TEXT("problem gathering icon metrics by hand\n"));
   return (bOK);
}

BOOL FAR GatherNonClientMetricsByHand(LPTSTR lpszTheme)
{
   NONCLIENTMETRICS ncm;
   BOOL bOK;
#ifdef UNICODE
   NONCLIENTMETRICSA ncmA;
#endif

   // inits
   ncm.cbSize = sizeof(ncm);
   bOK = SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm),
                              (void far *)(LPNONCLIENTMETRICS)&ncm, FALSE);
   if (!bOK) bReadOK = FALSE;

   // write the whole kit and kaboodle
#ifdef UNICODE
   // Need to convert the NONCLIENTMETRICS structure to ANSI before
   // writing it to the Theme file
   ConvertNCMetricsToANSI((LPNONCLIENTMETRICSW)&ncm, (LPNONCLIENTMETRICSA)&ncmA);

   if (bOK) {
      bOK = WriteBytesToFile((LPTSTR)szMetrics, (LPTSTR)szNCM,
                             (BYTE *)&(ncmA), sizeof(NONCLIENTMETRICSA), lpszTheme);
   }
#else
   // No UNICODE so no need to convert NONCLIENTMETRICS to ANSI
   // before writing to Theme file.

   if (bOK) {
      bOK = WriteBytesToFile((LPTSTR)szMetrics, (LPTSTR)szNCM,
                             (BYTE *)&(ncm), sizeof(NONCLIENTMETRICS), lpszTheme);
   }
#endif // UNICODE

   if (!bOK) bWroteOK = FALSE;

   // cleanup
   Assert(bOK, TEXT("problem gathering nonclient metrics by hand\n"));
   return (bOK);
}

//
// SetIconMetricsByHand
//
// When they decided that icon fonts went with fonts not with
// icons, this got a little tangled. Follow the bools.
//
VOID FAR SetIconMetricsByHand(BOOL bIconSpacing, BOOL bIconFont)
{
   UINT uret;
   ICONMETRICS imCur, imStored;
   LONG lret;
   HKEY hKey;

   //
   // INITS

   //
   // Get cur iconmetrics
   imCur.cbSize = sizeof(imCur);
   uret = (UINT) SystemParametersInfo(SPI_GETICONMETRICS, sizeof(imCur),
                                      (void far *)(LPICONMETRICS)&imCur, FALSE);
   Assert(uret, TEXT("problem getting cur icon metrics before setting\n"));

   //
   // Get stored iconmetrics

   // get stored data string
   uret = (UINT) GetPrivateProfileString((LPTSTR)szMetrics, (LPTSTR)szIM,
                                        (LPTSTR)szNULL,
                                        (LPTSTR)pValue, MAX_VALUELEN,
                                        (LPTSTR)szCurThemeFile);
   Assert(uret, TEXT("problem getting stored icon metrics before setting\n"));

   // if we somehow come up with no icon metrics in the theme, just
   // PUNT and leave cur settings
   if (*pValue) {                   // if something there to set
      // translate stored data string to ICONMETRICS bytes
      WriteBytesToBuffer((LPTSTR)pValue);  // char str read from and binary bytes
                                           // written to pValue. It's OK.
      // get it into ICONMETRICS structure for ease of use and safety
#ifdef UNICODE
      // ICONMETRICS are stored in ANSI format in the Theme file so if
      // we're living in a UNICODE world we need to convert from ANSI
      // to UNICODE
      ConvertIconMetricsToWIDE((LPICONMETRICSA)pValue, (LPICONMETRICSW)&imStored);
#else
      // No UNICODE, no need to convert from ANSI...
      imStored = *((LPICONMETRICS)pValue);
#endif
      //
      // Combine the cur and the saved here and now in the imStored struct
      imCur.cbSize = sizeof(ICONMETRICS);    // paranoid
      if (bIconSpacing) {
         imCur.iHorzSpacing = imStored.iHorzSpacing;
         imCur.iVertSpacing = imStored.iVertSpacing;
      }
      // iTitleWrap already as was in system
      if (bIconFont)
         imCur.lfFont = imStored.lfFont;

      //
      // Set it in the system live
      uret = (UINT) SystemParametersInfo(SPI_SETICONMETRICS, sizeof(imCur),
                                       (void far *)(LPICONMETRICS)&imCur,
                                       // send change at end of theme application
                                       SPIF_UPDATEINIFILE);
      Assert(uret, TEXT("problem setting icon metrics in cur system!!\n"));
   }

   // the rest is just for icon size and spacing
   if (bIconSpacing) {
      //
      // now do icon sizes directly to the registry

      // open
      lret = RegOpenKeyEx(HKEY_CURRENT_USER, szCP_DT_WM,
                        (DWORD)0, KEY_SET_VALUE, (PHKEY)&hKey );
      if (lret == ERROR_SUCCESS) {

         GetPrivateProfileString((LPTSTR)szCP_DT_WM, (LPTSTR)szIconSize,
                                 (LPTSTR)szNULL,
                                 (LPTSTR)pValue, MAX_VALUELEN, (LPTSTR)szCurThemeFile);
         if (*pValue) {                   // non-null size settings only!
            RegSetValueEx(hKey, (LPTSTR)szIconSize,
                        0,
                        (DWORD)REG_SZ,
                        (LPBYTE)pValue,
                        (DWORD)(SZSIZEINBYTES((LPTSTR)pValue) + 1));
         }

         GetPrivateProfileString((LPTSTR)szCP_DT_WM, (LPTSTR)szSmallIconSize,
                                 (LPTSTR)szNULL,
                                 (LPTSTR)pValue, MAX_VALUELEN, (LPTSTR)szCurThemeFile);
         if (*pValue) {                   // non-null size settings only!
            RegSetValueEx(hKey, (LPTSTR)szSmallIconSize,
                        0,
                        (DWORD)REG_SZ,
                        (LPBYTE)pValue,
                        (DWORD)(SZSIZEINBYTES((LPTSTR)pValue) + 1 ));
         }

         // cleanup!
         RegCloseKey(hKey);

      }  // end if opened key
   }  // end if bIconSpacing
}


//
// SetNonClientMetricsByHand
//
// Borders and fonts are both in the same NONCLIENTMETRICS setting,
// so we have to set them together. Here's what we do:
// Start with cur system settings as default. If we are changing
// font styles, alter the fonts from the default. If we are changing
// window border and font sizes, make those changes to our default copy of
// the metrics and fonts, too.
//
// Then go reset the system.
//
VOID FAR SetNonClientMetricsByHand(BOOL bFonts, BOOL bBorders)
{
   UINT uret;
   NONCLIENTMETRICS ncmCur, ncmStored;

   //
   // INITS

   //
   // Get cur nonclientmetrics: this is the default until we hear otherwise
   ncmCur.cbSize = sizeof(ncmCur);
   uret = (UINT) SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncmCur),
                                      (void far *)(LPNONCLIENTMETRICS)&ncmCur, FALSE);
   Assert(uret, TEXT("problem getting cur nonclient metrics before setting\n"));

   //
   // Get stored nonclientmetrics

   // get stored data string
   uret = (UINT) GetPrivateProfileString((LPTSTR)szMetrics, (LPTSTR)szNCM,
                                        (LPTSTR)szNULL,
                                        (LPTSTR)pValue, MAX_VALUELEN,
                                        (LPTSTR)szCurThemeFile);
   Assert(uret, TEXT("problem getting stored nonclient metrics before setting\n"));


   // if we somehow come up with no non-client metrics in the theme, just
   // PUNT and leave cur settings
   if (!(*pValue))
      return;                       // easy no work to do EXIT


   // translate stored data string to NONCLIENTMETRICS bytes
   WriteBytesToBuffer((LPTSTR)pValue);  // char str read from and binary bytes
                                        // written to pValue. It's OK.
   // get it into NONCLIENTMETRICS structure for ease of use and safety
#ifdef UNICODE
   // NONCLIENTMETRICS are stored in ANSI format in the Theme file so
   // we need to convert them to UNICODE
   ConvertNCMetricsToWIDE((LPNONCLIENTMETRICSA)pValue, (LPNONCLIENTMETRICSW)&ncmStored);
#else
   // No UNICODE so no need to convert NONCLIENTMETRICS...
   ncmStored = *((LPNONCLIENTMETRICS)pValue);
#endif
   //
   // Combine the cur with the requested saved info here and now
   // Cur metrics are the default, overridden for fields requested
   // by user by new info from metrics stored with the theme.
   //
   // init
   ncmCur.cbSize = sizeof(NONCLIENTMETRICS); // paranoid

   // what we reset if the user checks Font names and styles
   if (bFonts) {
      // only (some) font information
      TransmitFontCharacteristics(&(ncmCur.lfCaptionFont), &(ncmStored.lfCaptionFont),
                                 TFC_STYLE);
      TransmitFontCharacteristics(&(ncmCur.lfSmCaptionFont), &(ncmStored.lfSmCaptionFont),
                                 TFC_STYLE);
      TransmitFontCharacteristics(&(ncmCur.lfMenuFont), &(ncmStored.lfMenuFont),
                                 TFC_STYLE);
      TransmitFontCharacteristics(&(ncmCur.lfStatusFont), &(ncmStored.lfStatusFont),
                                 TFC_STYLE);
      TransmitFontCharacteristics(&(ncmCur.lfMessageFont), &(ncmStored.lfMessageFont),
                                 TFC_STYLE);
   }

   // what we reset if the user checks Font and window si&zes
   if (bBorders) {
      // fonts
      TransmitFontCharacteristics(&(ncmCur.lfCaptionFont), &(ncmStored.lfCaptionFont),
                                 TFC_SIZE);
      TransmitFontCharacteristics(&(ncmCur.lfSmCaptionFont), &(ncmStored.lfSmCaptionFont),
                                 TFC_SIZE);
      TransmitFontCharacteristics(&(ncmCur.lfMenuFont), &(ncmStored.lfMenuFont),
                                 TFC_SIZE);
      TransmitFontCharacteristics(&(ncmCur.lfStatusFont), &(ncmStored.lfStatusFont),
                                 TFC_SIZE);
      TransmitFontCharacteristics(&(ncmCur.lfMessageFont), &(ncmStored.lfMessageFont),
                                 TFC_SIZE);
      // window elements sizes
      ncmCur.iBorderWidth = ncmStored.iBorderWidth;
      ncmCur.iScrollWidth = ncmStored.iScrollWidth;
      ncmCur.iScrollHeight = ncmStored.iScrollHeight;
      ncmCur.iCaptionWidth = ncmStored.iCaptionWidth;
      ncmCur.iCaptionHeight = ncmStored.iCaptionHeight;
      ncmCur.iSmCaptionWidth = ncmStored.iSmCaptionWidth;
      ncmCur.iSmCaptionHeight = ncmStored.iSmCaptionHeight;
      ncmCur.iMenuWidth = ncmStored.iMenuWidth;
      ncmCur.iMenuHeight = ncmStored.iMenuHeight;
   }

   //
   // Phew! Now set it in the system live...
   uret = (UINT) SystemParametersInfo(SPI_SETNONCLIENTMETRICS, sizeof(ncmCur),
                                      (void far *)(LPNONCLIENTMETRICS)&ncmCur,
                                      // send change at end of theme application
                                      SPIF_UPDATEINIFILE);
   Assert(uret, TEXT("problem setting nonclient metrics in cur system!!\n"));
}


//
// TransmitFontCharacteristics
//
// This is actually a pretty key function. See, font characteristics are
// all set together: a LOGFONT has name and style and size info all in one.
// But when you are setting all the nonclient metrics like window caption
// and menu size, you need to stretch the font sizes with it. But we give the
// user a choice of changing window sizes without "changing" the font; i.e.
// without applying a new font name and style from the theme.
//
// So we need to be able to pick apart the name and style from the size
// characteristics. And here it is.
//
// Really just a helper routine for the above function, so we don't have all
// this gunk inline five times.
//
VOID TransmitFontCharacteristics(PLOGFONT plfDst, PLOGFONT plfSrc, int iXmit)
{
   switch (iXmit) {
   case TFC_SIZE:
      plfDst->lfHeight = plfSrc->lfHeight;
      plfDst->lfWidth = plfSrc->lfWidth;
      break;
   case TFC_STYLE:
      plfDst->lfEscapement = plfSrc->lfEscapement;
      plfDst->lfOrientation = plfSrc->lfOrientation;
      plfDst->lfWeight = plfSrc->lfWeight;
      plfDst->lfItalic = plfSrc->lfItalic;
      plfDst->lfUnderline = plfSrc->lfUnderline;
      plfDst->lfStrikeOut = plfSrc->lfStrikeOut;
      plfDst->lfCharSet = plfSrc->lfCharSet;
      plfDst->lfOutPrecision = plfSrc->lfOutPrecision;
      plfDst->lfClipPrecision = plfSrc->lfClipPrecision;
      plfDst->lfQuality = plfSrc->lfQuality;
      plfDst->lfPitchAndFamily = plfSrc->lfPitchAndFamily;
      lstrcpy((LPTSTR)plfDst->lfFaceName,
              (LPTSTR)plfSrc->lfFaceName);
      break;
   }
}

#ifdef UNICODE

VOID ConvertIconMetricsToANSI(LPICONMETRICS wIM, LPICONMETRICSA aIM)
{
   ZeroMemory(aIM, sizeof(aIM));

   aIM->cbSize = sizeof(aIM);
   aIM->iHorzSpacing = wIM->iHorzSpacing;
   aIM->iVertSpacing = wIM->iVertSpacing;
   aIM->iTitleWrap = wIM->iTitleWrap;
   ConvertLogFontToANSI(&wIM->lfFont, &aIM->lfFont);

   return;
}

VOID ConvertIconMetricsToWIDE(LPICONMETRICSA aIM, LPICONMETRICSW wIM)
{
   ZeroMemory(wIM, sizeof(wIM));

   wIM->cbSize = sizeof(wIM);
   wIM->iHorzSpacing = aIM->iHorzSpacing;
   wIM->iVertSpacing = aIM->iVertSpacing;
   wIM->iTitleWrap = aIM->iTitleWrap;
   ConvertLogFontToWIDE(&aIM->lfFont, &wIM->lfFont);

   return;
}

VOID ConvertNCMetricsToANSI(LPNONCLIENTMETRICSW wNCM, LPNONCLIENTMETRICSA aNCM)
{
   ZeroMemory(aNCM, sizeof(aNCM));

   aNCM->cbSize = sizeof(aNCM);
   aNCM->iBorderWidth = wNCM->iBorderWidth;
   aNCM->iScrollWidth = wNCM->iScrollWidth;
   aNCM->iScrollHeight = wNCM->iScrollHeight;
   aNCM->iCaptionWidth = wNCM->iCaptionWidth;
   aNCM->iCaptionHeight = wNCM->iCaptionHeight;
   ConvertLogFontToANSI(&wNCM->lfCaptionFont, &aNCM->lfCaptionFont);
   aNCM->iSmCaptionWidth = wNCM->iSmCaptionWidth;
   aNCM->iSmCaptionHeight = wNCM->iSmCaptionHeight;
   ConvertLogFontToANSI(&wNCM->lfSmCaptionFont, &aNCM->lfSmCaptionFont);
   aNCM->iMenuWidth = wNCM->iMenuWidth;
   aNCM->iMenuHeight = wNCM->iMenuHeight;
   ConvertLogFontToANSI(&wNCM->lfMenuFont, &aNCM->lfMenuFont);
   ConvertLogFontToANSI(&wNCM->lfStatusFont, &aNCM->lfStatusFont);
   ConvertLogFontToANSI(&wNCM->lfMessageFont, &aNCM->lfMessageFont);

   return;
}

VOID ConvertNCMetricsToWIDE(LPNONCLIENTMETRICSA aNCM, LPNONCLIENTMETRICSW wNCM)
{
   ZeroMemory(wNCM, sizeof(wNCM));

   wNCM->cbSize = sizeof(wNCM);
   wNCM->iBorderWidth = aNCM->iBorderWidth;
   wNCM->iScrollWidth = aNCM->iScrollWidth;
   wNCM->iScrollHeight = aNCM->iScrollHeight;
   wNCM->iCaptionWidth = aNCM->iCaptionWidth;
   wNCM->iCaptionHeight = aNCM->iCaptionHeight;
   ConvertLogFontToWIDE(&aNCM->lfCaptionFont, &wNCM->lfCaptionFont);
   wNCM->iSmCaptionWidth = aNCM->iSmCaptionWidth;
   wNCM->iSmCaptionHeight = aNCM->iSmCaptionHeight;
   ConvertLogFontToWIDE(&aNCM->lfSmCaptionFont, &wNCM->lfSmCaptionFont);
   wNCM->iMenuWidth = aNCM->iMenuWidth;
   wNCM->iMenuHeight = aNCM->iMenuHeight;
   ConvertLogFontToWIDE(&aNCM->lfMenuFont, &wNCM->lfMenuFont);
   ConvertLogFontToWIDE(&aNCM->lfStatusFont, &wNCM->lfStatusFont);
   ConvertLogFontToWIDE(&aNCM->lfMessageFont, &wNCM->lfMessageFont);

   return;
}

VOID ConvertLogFontToANSI(LPLOGFONTW wLF, LPLOGFONTA aLF)
{
   UINT uCodePage;

   uCodePage = _getmbcp();

   ZeroMemory(aLF, sizeof(aLF));
   aLF->lfHeight = wLF->lfHeight;
   aLF->lfWidth = wLF->lfWidth;
   aLF->lfEscapement = wLF->lfEscapement;
   aLF->lfOrientation = wLF->lfOrientation;
   aLF->lfWeight = wLF->lfWeight;
   aLF->lfItalic = wLF->lfItalic;
   aLF->lfUnderline = wLF->lfUnderline;
   aLF->lfStrikeOut = wLF->lfStrikeOut;
   aLF->lfCharSet = wLF->lfCharSet;
   aLF->lfOutPrecision = wLF->lfOutPrecision;
   aLF->lfClipPrecision = wLF->lfClipPrecision;
   aLF->lfQuality = wLF->lfQuality;
   aLF->lfPitchAndFamily = wLF->lfPitchAndFamily;

   WideCharToMultiByte(uCodePage, 0, wLF->lfFaceName, -1,
                                 aLF->lfFaceName, LF_FACESIZE, NULL, NULL);

   return;
}

VOID ConvertLogFontToWIDE(LPLOGFONTA aLF, LPLOGFONTW wLF)
{
   UINT uCodePage;

   uCodePage = _getmbcp();

   ZeroMemory(wLF, sizeof(wLF));
   wLF->lfHeight = aLF->lfHeight;
   wLF->lfWidth = aLF->lfWidth;
   wLF->lfEscapement = aLF->lfEscapement;
   wLF->lfOrientation = aLF->lfOrientation;
   wLF->lfWeight = aLF->lfWeight;
   wLF->lfItalic = aLF->lfItalic;
   wLF->lfUnderline = aLF->lfUnderline;
   wLF->lfStrikeOut = aLF->lfStrikeOut;
   wLF->lfCharSet = aLF->lfCharSet;
   wLF->lfOutPrecision = aLF->lfOutPrecision;
   wLF->lfClipPrecision = aLF->lfClipPrecision;
   wLF->lfQuality = aLF->lfQuality;
   wLF->lfPitchAndFamily = aLF->lfPitchAndFamily;

   MultiByteToWideChar(uCodePage, 0, aLF->lfFaceName, -1,
                                             wLF->lfFaceName, LF_FACESIZE);

   return;
}

#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\loadimag.h ===
//
//  LoadImage.c
//
//  routines to load and decomress a graphics file using a MS Office
//  graphic import filter.
//
//  writen for Plus! 05/24/95
//  ToddLa
//
//  Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */




typedef struct
{
    LPBITMAPINFOHEADER pBitmapInfoHeader;
    HMETAFILE hMetaFile;
} BITMAP_AND_METAFILE_COMBO;

//  LoadImageFromFile(LPCTSTR szFileName, int width, int height, int bpp, int dither);
//
//  load a graphic file decompess it (iff needed) and return a DIBSection
//
//      szFileName      - the file name, can be a windows bitmap
//                        or any format supported by a installed
//                        graphic import filter.
//
//      width, height   - requested width,height in pixels
//                        pass zero for no stretching
//
//      bpp             - requested bit depth
//
//                          0   use the bit depth of the image
//                         -1   use best bit depth for current display
//                          8   use 8bpp
//                          16  use 16bpp 555
//                          24  use 24bpp
//                          32  use 32bpp
//                          555 use 16bpp 555
//                          565 use 16bpp 565
//
//                       if the requested bit depth is 8bpp a palette
//                       will be used in this order.
//
//                          if the image file is <= 8bpp its
//                          color table will be used.
//
//                          if a file of the same name, with
//                          a .pal extension exists this will be
//                          used as the palette.
//
//                          otherwise the halftone palette will be used.
//
//      dither              0 = none.
//                          1 = dither to custon palette.
//                          2 = dither to standard palette.
//                          3 = halftone to standard palette.
//
//  returns
//
//      DIBSection bitmap handle
//
#define DITHER_NONE            0
#define DITHER_CUSTOM          1
#define DITHER_STANDARD        2
#define DITHER_HALFTONE        3
#define DITHER_CUSTOM_HYBRID   4
#define DITHER_STANDARD_HYBRID 5
HBITMAP LoadImageFromFile(LPCTSTR szFileName, BITMAP_AND_METAFILE_COMBO * pbam, int width, int height, int bpp, int dither);

//  LoadDIBFromFile
//
//  load a image file using a image import filter.
HRESULT LoadDIBFromFile(IN LPCTSTR szFileName, IN BITMAP_AND_METAFILE_COMBO * pBitmapAndMetaFile);
void FreeDIB(BITMAP_AND_METAFILE_COMBO bam);

//
//  LoadPaletteFromFile
//
//  load a MS .PAL file. as a array of RGBQUADs
//
//  if the palette file is invalid or does not
//  exists the halftone colors are returned.
//  if hdcNearest is not NULL the colors are adjusted w/GetNearestColor
//
DWORD LoadPaletteFromFile(LPCTSTR szFile, LPDWORD rgb, HDC hdcNearest);

//
// GetFilterInfo
//
BOOL GetFilterInfo(int i, LPTSTR szName, UINT cbName, LPTSTR szExt, UINT cbExt, LPTSTR szHandler, UINT cbHandler);

//
// SaveImageToFile
//
// save a DIBSection to a .BMP file.
//
// if szTitle is !=NULL it will be written to the end of the
// bitmap so GetImageTitle() can read it.
//
BOOL SaveImageToFile(HBITMAP hbm, LPCTSTR szFile, LPCTSTR szTitle);

//
// GetImageTitle
//
// retrives the title writen to a bitmap file by SaveImageToFile
//
DWORD GetImageTitle(LPCTSTR szFile, LPTSTR szTitle, UINT cb);

//
//  CacheLoadImageFromFile
//  CacheDeleteBitmap
//
HBITMAP CacheLoadImageFromFile(LPCTSTR szFileName, int width, int height, int bpp, int dither);
void    CacheDeleteBitmap(HBITMAP hbm);

// FindExtension
//
// returns a pointer to the extension of a file.
//
LPCTSTR FindExtension(LPCTSTR pszPath);

#ifdef __cplusplus
}
#endif	/* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\loadimag.c ===
/* LOADIMAG.C

   Frosting: Master Theme Selector for Windows '95
   Copyright (c) 1994-1999 Microsoft Corporation.  All rights reserved.
*/


#include <windows.h>
#include <windowsx.h>
#include <mbctype.h>
#include "stdlib.h"
#include "loadimag.h"
#include "halftone.h"
#include "dither.h"
#include "htmlprev.h"
#include "schedule.h"  // IsPlatformNT() function

//DEBUG
//#include "stdio.h"
//TCHAR szDebug[512];

#ifdef DBG
    #define _DEBUG
#endif

#ifdef DEBUG
    #define _DEBUG
#endif

#define ARRAYSIZE(x)       (sizeof(x)/sizeof(x[0]))
#define SZSIZEINBYTES(x)   (lstrlen(x)*sizeof(TCHAR)+1)

#ifdef _DEBUG
    #include <mmsystem.h>
    #define TIMESTART(sz) { TCHAR szTime[80]; DWORD time = timeGetTime();
    #define TIMESTOP(sz) time = timeGetTime() - time; wsprintf(szTime, TEXT("%s took %d.%03d sec\r\n"), sz, time/1000, time%1000); OutputDebugString(szTime); }
#else
    #define TIMESTART(sz)
    #define TIMESTOP(sz)
#endif

// regutils.c
extern VOID ExpandSZ(LPTSTR);

static  BOOL          bVersion2;        //peihwal : add for JPEG32.FLT interface
//
//  structures for dealing with import filters.
//
#pragma pack(2)                         /* Switch on 2-byte packing. */
typedef struct {
        unsigned short  slippery: 1;    /* True if file may disappear. */
        unsigned short  write : 1;      /* True if open for write. */
        unsigned short  unnamed: 1;     /* True if unnamed. */
        unsigned short  linked : 1;     /* Linked to an FS FCB. */
        unsigned short  mark : 1;       /* Generic mark bit. */
        union {
            char        ext[4];     /* File extension. */
            HFILE       hfEmbed;    /* handle to file containing */
                                    /* graphic (for import) */
        };
        unsigned short  handle;         /* not used */
        char     fullName[260];         /* Full path name and file name. */
        DWORD    filePos;               /* Position in file of...  */
} FILESPEC;
#pragma pack()

typedef struct {
        HANDLE  h;
        RECT    bbox;
        int     inch;
} GRPI;

// returns a pointer to the extension of a file.
//
// in:
//      qualified or unqualfied file name
//
// returns:
//      pointer to the extension of this file.  if there is no extension
//      as in "foo" we return a pointer to the NULL at the end
//      of the file
//
//      foo.txt     ==> ".txt"
//      foo         ==> ""
//      foo.        ==> "."
//

LPCTSTR FindExtension(LPCTSTR pszPath)
{
    LPCTSTR pszDot;

    for (pszDot = NULL; *pszPath; pszPath = CharNext(pszPath))
    {
        switch (*pszPath) {
        case TEXT('.'):
            pszDot = pszPath;   // remember the last dot
            break;
        case TEXT('\\'):
        case TEXT(' '):                   // extensions can't have spaces
            pszDot = NULL;      // forget last dot, it was in a directory
            break;
        }
    }

    // if we found the extension, return ptr to the dot, else
    // ptr to end of the string (NULL extension)
    return pszDot ? pszDot : pszPath;
}

//
// GetFilterInfo
//
//  32-bit import filters are listed in the registry...
//
//  HKLM\SOFTWARE\Microsoft\Shared Tools\Graphics Filters\Import\XXX
//      Path        = filename
//      Name        = friendly name
//      Extenstions = file extenstion list
//
#pragma data_seg(".text")
static const TCHAR c_szHandlerKey[] = TEXT("SOFTWARE\\Microsoft\\Shared Tools\\Graphics Filters\\Import");
static const TCHAR c_szName[] = TEXT("Name");
static const TCHAR c_szPath[] = TEXT("Path");
static const TCHAR c_szExts[] = TEXT("Extensions");
#pragma data_seg()

BOOL GetFilterInfo(int i, LPTSTR szName, UINT cbName, LPTSTR szExt, UINT cbExt, LPTSTR szHandler, UINT cbHandler)
{
    HKEY hkey;
    HKEY hkeyT;
    DWORD dwType = 0;
    TCHAR ach[80];
    BOOL f=FALSE;

    if (RegOpenKey(HKEY_LOCAL_MACHINE, c_szHandlerKey, &hkey) == 0)
    {
        if (RegEnumKey(hkey, i, ach, ARRAYSIZE(ach))==0)
        {
            if (RegOpenKey(hkey, ach, &hkeyT) == 0)
            {
                if (szName)
                {
                    szName[0]=0;
                    RegQueryValueEx(hkeyT, c_szName, NULL, NULL, (LPBYTE)szName, &cbName);
                }
                if (szExt)
                {
                    szExt[0]=0;
                    RegQueryValueEx(hkeyT, c_szExts, NULL, NULL, (LPBYTE)szExt, &cbExt);
                }
                if (szHandler)
                {
                    szHandler[0]=0;
                    RegQueryValueEx(hkeyT, c_szPath, NULL, &dwType, (LPBYTE)szHandler, &cbHandler);
                    if (REG_EXPAND_SZ == dwType) ExpandSZ(szHandler);
                }

                RegCloseKey(hkeyT);
                f = TRUE;
            }
        }
        RegCloseKey(hkey);
    }
    return f;
}

//
//  GetHandlerForFile
//
//  find a import filter for the given file.
//
//  if the file does not need a handler return ""
//
BOOL GetHandlerForFile(LPCTSTR szFile, LPTSTR szHandler, UINT cb)
{
    LPCTSTR ext;
    TCHAR ach[40];
    int i;
    BOOL f = FALSE;

    *szHandler = 0;

    if (szFile == NULL)
        return FALSE;

    // find the extension
    ext = FindExtension(szFile);


    for (i=0; GetFilterInfo(i, NULL, 0, ach, sizeof(ach), szHandler, cb); i++)
    {
        if (lstrcmpi(ext+1, ach) == 0)
            break;
        else
            *szHandler = 0;
    }

    // if the handler file does not exist fail.
    if (*szHandler && GetFileAttributes(szHandler) != -1)
        f = TRUE;

    //if we cant find a handler hard code JPEG
    if (!f && lstrcmpi(ext,TEXT(".jpg")) == 0)
    {
        lstrcpy(szHandler, TEXT("JPEGIM32.FLT"));
//        lstrcpy(szHandler, TEXT("JPEG32.FLT"));
        f = TRUE;
    }

    //if we cant find a handler hard code PCX
    if (!f && lstrcmpi(ext, TEXT(".pcx")) == 0)
    {
        lstrcpy(szHandler, TEXT("PCXIMP32.FLT"));
        f = TRUE;
    }

    return f;
}

//
// FindBitmapInfo
//
// find the DIB bitmap in a memory meta file...
//
LPBITMAPINFOHEADER FindBitmapInfo(LPMETAHEADER pmh)
{
    LPMETARECORD pmr;

    for (pmr = (LPMETARECORD)((LPBYTE)pmh + pmh->mtHeaderSize*2);
         pmr < (LPMETARECORD)((LPBYTE)pmh + pmh->mtSize*2);
         pmr = (LPMETARECORD)((LPBYTE)pmr + pmr->rdSize*2))
    {
        switch (pmr->rdFunction)
        {
            case META_DIBBITBLT:
                return (LPBITMAPINFOHEADER)&(pmr->rdParm[8]);

            case META_DIBSTRETCHBLT:
                return (LPBITMAPINFOHEADER)&(pmr->rdParm[10]);

            case META_STRETCHDIB:
                return (LPBITMAPINFOHEADER)&(pmr->rdParm[11]);

            case META_SETDIBTODEV:
                return (LPBITMAPINFOHEADER)&(pmr->rdParm[9]);
        }
    }

    return NULL;
}
// add for new filter JPEG32.FLT
static LPVOID lpWMFBits = NULL;
//
//  FindBitmapInfoFromWMF
//
//  retrieve metafile header
//
LPBITMAPINFOHEADER FindBitmapInfoFromWMF(GRPI* pict)
{
    UINT         uiSizeBuf = 0;
    LPBITMAPINFOHEADER lpbi = NULL;

    //get the size of the metafile associated with hMF...
    if ((uiSizeBuf = GetMetaFileBitsEx(pict->h, 0, NULL)))
    {
        //allocate buffer
        lpWMFBits = GlobalAllocPtr(GHND, uiSizeBuf);

        //get the bits of the Windows metafile associated with hMF...
        if (!lpWMFBits)
        {
            return NULL;
        }

        //make a local copy of it in our segment
        if ( GetMetaFileBitsEx(pict->h, uiSizeBuf, lpWMFBits))
        {
            lpbi = FindBitmapInfo((LPMETAHEADER)lpWMFBits);
        }
    }
    return (lpbi);
}
// end for new filter JPEG32.FLT
//
//  LoadDIBFromFile
//
//  load a image file using a image import filter.
//
HRESULT LoadDIBFromFile(IN LPCTSTR szFileName, IN BITMAP_AND_METAFILE_COMBO * pBitmapAndMetaFile)
{
    HRESULT hr = S_OK;
    HMODULE             hModule;
    FILESPEC            fileSpec;               // file to load
    GRPI                pict;
    UINT                rc;                     // return code
    HANDLE              hPrefMem = NULL;        // filter-supplied preferences
    UINT                wFilterType;            // 2 = graphics filter
    TCHAR               szHandler[MAX_PATH];    // changed from 128 to MAX_PATH
    LPVOID              lpMeta = NULL;
#ifdef UNICODE
    TCHAR               szFileNameW[MAX_PATH];
#endif

    UINT (FAR PASCAL *GetFilterInfo)(short v, LPSTR szFilterExten,
            HANDLE FAR * fph1, HANDLE FAR * fph2);
    UINT (FAR PASCAL *ImportGR)(HDC hdc, FILESPEC FAR *lpfs,
            GRPI FAR *p, HANDLE hPref);

    pBitmapAndMetaFile->pBitmapInfoHeader = NULL;
    pBitmapAndMetaFile->hMetaFile = NULL;

    if (!GetHandlerForFile(szFileName, szHandler, sizeof(szHandler)))
        return hr;

    if (szHandler[0] == 0)
        return hr;

    TIMESTART(TEXT("LoadDIBFromFile"));

    hModule = LoadLibrary(szHandler);

    if (hModule == NULL)
        goto exit;

    /* get a pointer to the ImportGR function */
    (FARPROC)GetFilterInfo = GetProcAddress(hModule, "GetFilterInfo");
    (FARPROC)ImportGR = GetProcAddress(hModule, "ImportGr");

    if (GetFilterInfo == NULL)
        (FARPROC)GetFilterInfo = GetProcAddress(hModule, "GetFilterInfo@16");

    if (ImportGR == NULL)
        (FARPROC)ImportGR = GetProcAddress(hModule, "ImportGr@16");

    if (ImportGR == NULL)
        goto exit;

    if (GetFilterInfo != NULL)
    {
        wFilterType = (*GetFilterInfo)
            ((short) 2,                 // interface version no.
            (LPSTR)"",                  // end of .INI entry
            (HANDLE FAR *) &hPrefMem,   // fill in: preferences
            (HANDLE FAR *) NULL);       // unused in Windows

        /* the return value is the type of filter: 0=error,
         * 1=text-filter, 2=graphics-filter
         */
        if (wFilterType != 2)
            goto exit;
    }

    fileSpec.slippery = FALSE;      // TRUE if file may disappear
    fileSpec.write = FALSE;         // TRUE if open for write
    fileSpec.unnamed = FALSE;       // TRUE if unnamed
    fileSpec.linked = FALSE;        // Linked to an FS FCB
    fileSpec.mark = FALSE;          // Generic mark bit
////fileSpec.fType = 0L;            // The file type
    fileSpec.handle = 0;            // MS-DOS open file handle
    fileSpec.filePos = 0L;

    //the converters need a pathname without spaces!

#ifdef UNICODE
    GetShortPathName(szFileName, szFileNameW, ARRAYSIZE(szFileNameW));
    wcstombs(fileSpec.fullName, szFileNameW, ARRAYSIZE(fileSpec.fullName));
#else
    GetShortPathName(szFileName, fileSpec.fullName, ARRAYSIZE(fileSpec.fullName));
#endif

    pict.h = NULL;

    rc = (*ImportGR)
        (NULL,                          // "the target DC" (printer?)
        (FILESPEC FAR *) &fileSpec,     // file to read
        (GRPI FAR *) &pict,             // fill in: result metafile
        (HANDLE) hPrefMem);             // preferences memory

    if (rc != 0 || pict.h == NULL)
        goto exit;

    //
    // find the BITMAPINFO in the returned metafile
    // this saves us from creating a metafile and duplicating
    // all the memory.
    //
// add for new filter JPEG32.FLT

    lpMeta = GlobalLock(pict.h);
    rc = GetLastError();

    bVersion2 = (lpMeta) ? TRUE : FALSE;

    //
    // The whole "bversion2" logic above seems fundamentally flawed.
    // It is broken under NT, that's for certain.  Since I have had
    // limited luck getting info on the graphics filter interface
    // and the "bversion2" logic, I am going to assume that for the
    // NT world we don't have a version2 filter.
    //

    if (IsPlatformNT()) bVersion2 = FALSE;

    if ( bVersion2 )
    {
        pBitmapAndMetaFile->pBitmapInfoHeader = FindBitmapInfo((LPMETAHEADER)lpMeta);
    }
    else
    {
        pBitmapAndMetaFile->pBitmapInfoHeader = FindBitmapInfoFromWMF(&pict);
        pBitmapAndMetaFile->pBitmapInfoHeader->biYPelsPerMeter = 0x12345678;
    }
//    pBitmapAndMetaFile->pBitmapInfoHeader = FindBitmapInfo((LPMETAHEADER)GlobalLock(pict.h));
// add for new filter JPEG32.FLT

    if (pBitmapAndMetaFile->pBitmapInfoHeader == NULL)       // cant find it bail
    {
        GlobalFree(pict.h);
    }
    else
    {
        // BUGBUG This will not work in Win64 - throwing away high 32 bits
        pBitmapAndMetaFile->hMetaFile = pict.h;
    }

exit:
    if (hPrefMem != NULL)
        GlobalFree(hPrefMem);

    if (hModule)
        FreeLibrary(hModule);

    TIMESTOP(TEXT("LoadDIBFromFile"));

    return hr;
}

//
//  FreeDIB
//
void FreeDIB(BITMAP_AND_METAFILE_COMBO bam)
{
    if (bam.pBitmapInfoHeader)
    {
        if (bam.hMetaFile && (bam.pBitmapInfoHeader->biYPelsPerMeter == 0x12345678))
        {
// add for new filter JPEG32.FLT
//           GlobalFree((HANDLE)lpbi->biXPelsPerMeter);
            //done with the actual memory used to store bits so nuke it...
            if ( !bVersion2 )
            {
                if ( lpWMFBits )
                {
                    // DSCHOTT 98JUL20
                    // Moved this DeleteMetaFile() from after this
                    // IF clause up to here since lpbi->biXPelsPerMeter
                    // is not valid after this GlobalFreePtr() call.
                    DeleteMetaFile(bam.hMetaFile);

                    GlobalFreePtr(lpWMFBits);
                    lpWMFBits = NULL;
                }

                // DSCHOTT moved up inside IF clause before GlobalFreePtr().
                // DeleteMetaFile((HMETAFILE)lpbi->biXPelsPerMeter);
            }
            else  // bVersion2
            {
                GlobalFree(bam.hMetaFile);
            }
// add for new filter JPEG32.FLT
        }
        else
        {
            GlobalFree(GlobalHandle(bam.pBitmapInfoHeader));
        }

    }  // end if lpbi

}  // FreeDIB()


#define DIVIDE_SAFE(nNumber)            ((0 == (nNumber)) ? 1 : (nNumber))


//
//  LoadImageFromFile
//
//  load a image file using a image import filter.
//
HBITMAP LoadImageFromFile(LPCTSTR szFileName, BITMAP_AND_METAFILE_COMBO * pBitmapMetaFile, int width, int height, int bpp, int dither)
{
    HBITMAP hbm=NULL;
    HBITMAP hbmT;
    HBITMAP hbmFree=NULL;
    HDC     hdc=NULL;
    BITMAP_AND_METAFILE_COMBO bamFree = {0};
    HCURSOR hcur;
    LPBYTE  pbSrc;
    LPBYTE  pbDst;
    LPCTSTR ext;
    TCHAR   ach[MAX_PATH];  //dschott changed from 128 to MAX_PATH
    int     displaybpp;
    UINT    rastercaps;
    DIBSECTION ds;
    struct {
        BITMAPINFOHEADER bi;
        DWORD            ct[256];
    }   dib;

    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
//  TIMESTART(TEXT("LoadImageFromFile"));

    if (pBitmapMetaFile && (pBitmapMetaFile->pBitmapInfoHeader == NULL))
    {
        // find the extension
        ext = FindExtension(szFileName);

        // if it is a bitmap file no handler is needed, we can just call LoadImage
        if (lstrcmpi(ext,TEXT(".bmp")) == 0 ||
            lstrcmpi(ext,TEXT(".dib")) == 0 ||
            lstrcmpi(ext,TEXT(".rle")) == 0 ||
            ext[0] != TEXT('.'))
        {
            if (width < 0 && height < 0)
            {
                DWORD dw = GetImageTitle(szFileName, ach, sizeof(ach));
                width  = (int)LOWORD(dw) * -width  / DIVIDE_SAFE(GetSystemMetrics(SM_CXSCREEN));
                height = (int)HIWORD(dw) * -height / DIVIDE_SAFE(GetSystemMetrics(SM_CYSCREEN));
            }
            hbm = LoadImage(NULL, szFileName, IMAGE_BITMAP, width, height, LR_LOADFROMFILE|LR_CREATEDIBSECTION);
            goto exit;
        }

        TIMESTART(TEXT("LoadDIBFromFile"));
        LoadDIBFromFile(szFileName, pBitmapMetaFile);
        bamFree.pBitmapInfoHeader = pBitmapMetaFile->pBitmapInfoHeader;
        bamFree.hMetaFile = pBitmapMetaFile->hMetaFile;
        TIMESTOP(TEXT("LoadDIBFromFile"));
    }

    if (pBitmapMetaFile == NULL)       // cant find it bail
        goto exit;

    //
    // figure out the lpBits pointer we need to pass to StretchDIBits
    //
    pbSrc = (LPBYTE)pBitmapMetaFile->pBitmapInfoHeader + pBitmapMetaFile->pBitmapInfoHeader->biSize + pBitmapMetaFile->pBitmapInfoHeader->biClrUsed * sizeof(RGBQUAD);

    if (pBitmapMetaFile->pBitmapInfoHeader->biClrUsed == 0 && pBitmapMetaFile->pBitmapInfoHeader->biBitCount <= 8)
        pbSrc = (LPBYTE)((LPDWORD)pbSrc + (1 << pBitmapMetaFile->pBitmapInfoHeader->biBitCount));

    hdc = CreateCompatibleDC(NULL);

    if (hdc == NULL)
        goto exit;

    displaybpp = GetDeviceCaps(hdc, PLANES) * GetDeviceCaps(hdc, BITSPIXEL);
    rastercaps = GetDeviceCaps(hdc, RASTERCAPS);

    //
    //  create a DIBSection and draw the DIB into it.
    //  we need to figure out what type of DIBSection to
    //  make.  the caller can ask for a specific bit depth (bpp>0)
    //  or the same bit depth as the image (bpp==0) or the bit depth
    //  of the display (bpp==-1) the same goes for width/height
    //
    hmemcpy(&dib, pBitmapMetaFile->pBitmapInfoHeader, sizeof(dib));
    dib.bi.biClrUsed = 0;
    dib.bi.biXPelsPerMeter = 0;
    dib.bi.biYPelsPerMeter = 0;

    if (width < 0)
        width  = dib.bi.biWidth * -width  / DIVIDE_SAFE(GetSystemMetrics(SM_CXSCREEN));

    if (height < 0)
        height = dib.bi.biHeight * -height / DIVIDE_SAFE(GetSystemMetrics(SM_CYSCREEN));

    if (width > 0)
        dib.bi.biWidth = width;

    if (height > 0)
        dib.bi.biHeight = height;

    // get the best bit depth to use on this display.
    if (bpp == -1 && dib.bi.biBitCount > 8)
    {
        if (displaybpp > 8)
            bpp = 16;
        else
            bpp = 8;
    }

    // we may need to figure out a palette for this image
    //
    // if we can find a file with the same name and a extension of .PAL
    // use that as the palette, else use a default set of colors.
    //
    if (bpp == 8)
    {
        dib.bi.biBitCount = 8;
        dib.bi.biCompression = 0;
        if (pBitmapMetaFile->pBitmapInfoHeader->biBitCount > 8)
        {
            HDC screen;
            lstrcpy(ach, szFileName);
            lstrcpy((LPTSTR)FindExtension(ach),TEXT(".pal"));

            // LoadPaletteFromFile("") will give us back the HT colors...
            if (dither == DITHER_STANDARD ||
                dither == DITHER_STANDARD_HYBRID)
            {
                ach[0] = 0;
            }

            screen = GetDC(NULL);
            dib.bi.biClrUsed = LoadPaletteFromFile(ach, dib.ct,
                (rastercaps & RC_PALETTE) ? NULL : screen);
            ReleaseDC(NULL, screen);
        }
    }
#if 0
    else if (bpp == 565)
    {
        dib.bi.biBitCount = 16;
        dib.bi.biCompression = BI_BITFIELDS;
        dib.ct[0] = 0x0000F800;
        dib.ct[1] = 0x000007E0;
        dib.ct[2] = 0x0000001F;
    }
    else if (bpp == 555)
    {
        dib.bi.biBitCount = 16;
        dib.bi.biCompression = 0;
    }
#endif
    else if (bpp > 0)
    {
        dib.bi.biBitCount = (WORD)bpp;
        dib.bi.biCompression = 0;
    }

    //
    // check to see if we are dithering, and if we are also stretching
    // we need to do the stretching NOW so we dont end up stretching
    // dither patterns, we also do this before calling CreateDIBSection
    // to make the memory usage of this already piggy code smaller
    //
    if (dither && pBitmapMetaFile->pBitmapInfoHeader->biBitCount == 24 && (bpp == 16 || bpp == 8))
    {
        if (dib.bi.biWidth!=pBitmapMetaFile->pBitmapInfoHeader->biWidth || dib.bi.biHeight!=pBitmapMetaFile->pBitmapInfoHeader->biHeight)
        {
//          TIMESTART(TEXT("Stretch"));
            if (hbmFree = LoadImageFromFile(NULL, pBitmapMetaFile, dib.bi.biWidth, dib.bi.biHeight, 0, 0))
            {
                GetObject(hbmFree, sizeof(ds), &ds);
                pbSrc = ds.dsBm.bmBits;
                pBitmapMetaFile->pBitmapInfoHeader = &ds.dsBmih;
                if (bamFree.pBitmapInfoHeader != NULL)
                {
                    FreeDIB(bamFree);
                    bamFree.pBitmapInfoHeader = NULL;
                    bamFree.hMetaFile = NULL;
                }
            }
//          TIMESTOP(TEXT("Stretch"));
        }
    }
    else
    {
        dither = 0;
    }

    // make the DIBSection what the caller wants.
    hbm = CreateDIBSection(hdc, (LPBITMAPINFO)&dib.bi, DIB_RGB_COLORS, &pbDst, NULL, 0);

    if (hbm == NULL)
        goto exit;

    hbmT = SelectObject(hdc, hbm);
    SetStretchBltMode(hdc, COLORONCOLOR);

    if (dither)
    {
        TIMESTART(TEXT("Dithering"));

        if ((dither == DITHER_HALFTONE) && (dib.bi.biBitCount == 8))
        {
            HalftoneImage(hdc, hbm, pBitmapMetaFile->pBitmapInfoHeader, pbSrc);
        }
        else
        {
            DitherImage(hdc, hbm, pBitmapMetaFile->pBitmapInfoHeader, pbSrc, ((dib.bi.biBitCount == 16) ||
                ((dither != DITHER_STANDARD) && (dither != DITHER_CUSTOM))));
        }

        TIMESTOP(TEXT("Dithering"));
    }
    else
    {
        //
        // now draw the DIB into the DIBSection, GDI will handle all
        // the format conversion here.
        //
        TIMESTART(TEXT("StretchDIBits"));
        StretchDIBits(hdc,
            0, 0, dib.bi.biWidth, dib.bi.biHeight,
            0, 0, pBitmapMetaFile->pBitmapInfoHeader->biWidth, pBitmapMetaFile->pBitmapInfoHeader->biHeight,
            pbSrc, (LPBITMAPINFO)pBitmapMetaFile->pBitmapInfoHeader, DIB_RGB_COLORS, SRCCOPY);
        TIMESTOP(TEXT("StretchDIBits"));
    }
    SelectObject(hdc, hbmT);

exit:
    if (hdc)
        DeleteDC(hdc);

    if (bamFree.pBitmapInfoHeader != NULL)
        FreeDIB(bamFree);

    if (hbmFree)
        DeleteObject(hbmFree);

    if (hcur)
        SetCursor(hcur);

//  TIMESTOP(TEXT("LoadImageFromFile"));
    return hbm;
}

//
//  LoadPaletteFromFile
//
DWORD LoadPaletteFromFile(LPCTSTR szFile, LPDWORD rgb, HDC hdcNearest)
{
    HANDLE      fh;
    DWORD       dwBytesRead;
    UINT         i;
    struct  {
        DWORD   dwRiff;
        DWORD   dwFileSize;
        DWORD   dwPal;
        DWORD   dwData;
        DWORD   dwDataSize;
        WORD    palVersion;
        WORD    palNumEntries;
        DWORD   rgb[256];
    }   pal;

    pal.dwRiff = 0;

    // read in the palette file.
    fh = CreateFile(szFile,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);

    if (fh != INVALID_HANDLE_VALUE)
    {
        if (!ReadFile(fh, (LPVOID)&pal, sizeof(pal), &dwBytesRead, NULL))
        {
            NULL;   // We failed.  We check later but this line appeases PREFIX.
        }

        CloseHandle(fh);
    }

    // if the file is not a palette file, or does not exist
    // default to the halftone colors.
    if (pal.dwRiff != 0x46464952 || // 'RIFF'
        pal.dwPal  != 0x204C4150 || // 'PAL '
        pal.dwData != 0x61746164 || // 'data'
        pal.palVersion != 0x0300 ||
        pal.palNumEntries > 256  ||
        pal.palNumEntries < 1)
    {
        HPALETTE hpal = CreateHalftonePalette(NULL);

        if (hpal)
        {
            GetPaletteEntries(hpal, 0, 256, (LPPALETTEENTRY)pal.rgb);
            DeleteObject(hpal);
        }

        pal.palNumEntries = 256;
    }

    for (i = 0; i < pal.palNumEntries; i++)
    {
        COLORREF c = pal.rgb[i];

        if (hdcNearest)
            c = GetNearestColor(hdcNearest, c);

        rgb[i] = RGB(GetBValue(c),GetGValue(c), GetRValue(c));
    }

    return pal.palNumEntries;
}

//
// magic number we write to the file so we can make sure the
// title string is realy there.
//
#define TITLE_MAGIC 0x47414D53

//
//  SaveImageToFile
//
BOOL SaveImageToFile(HBITMAP hbm, LPCTSTR szFile, LPCTSTR szTitle)
{
    BITMAPFILEHEADER    hdr;
    HANDLE              fh;
    DWORD               dwBytesWritten;
    DWORD               dw;
    HDC                 hdc;
    DIBSECTION          dib;
    DWORD               ct[256];
#ifdef UNICODE
    CHAR                szTitleA[MAX_PATH];
    UINT                uCodePage;
#endif

    if (GetObject(hbm, sizeof(dib), &dib) == 0)
        return FALSE;

    if (dib.dsBm.bmBits == NULL)
        return FALSE;

    hdc = CreateCompatibleDC(NULL);
    SelectObject(hdc, hbm);
    if (dib.dsBmih.biBitCount <= 8)
    {
        dib.dsBmih.biClrUsed = GetDIBColorTable(hdc, 0, 256, (LPRGBQUAD)ct);
    }
    else if (dib.dsBmih.biCompression == BI_BITFIELDS)
    {
        dib.dsBmih.biClrUsed = 3;
        ct[0] = dib.dsBitfields[0];
        ct[1] = dib.dsBitfields[1];
        ct[2] = dib.dsBitfields[2];
    }
    DeleteDC(hdc);


    fh = CreateFile(szFile,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);


    if (fh == INVALID_HANDLE_VALUE)
        return FALSE;

    dw = sizeof(BITMAPFILEHEADER) +
         dib.dsBmih.biSize +
         dib.dsBmih.biClrUsed * sizeof(RGBQUAD) +
         dib.dsBmih.biSizeImage;

    hdr.bfType      = 0x4d42; // BFT_BITMAP
    hdr.bfSize      = dw;
    hdr.bfReserved1 = 0;
    hdr.bfReserved2 = 0;
    hdr.bfOffBits   = dw - dib.dsBmih.biSizeImage;

#define WRITE(fh, p, cb) if (!WriteFile(fh, (LPVOID)(p), cb, &dwBytesWritten, NULL)) goto error;

    WRITE(fh,&hdr,sizeof(BITMAPFILEHEADER));
    WRITE(fh,&dib.dsBmih,dib.dsBmih.biSize);
    WRITE(fh,&ct,dib.dsBmih.biClrUsed * sizeof(RGBQUAD));
    WRITE(fh,dib.dsBm.bmBits, dib.dsBmih.biSizeImage);

    if (szTitle && *szTitle)
    {
        dw = TITLE_MAGIC;
        WRITE(fh,&dw, sizeof(dw));

#ifdef UNICODE
        // Need to convert the title string to ANSI before writing it
        // to the file
        uCodePage = _getmbcp();
        WideCharToMultiByte(uCodePage, 0, szTitle, -1,
                            szTitleA, MAX_PATH, NULL, NULL);

        dw = lstrlenA(szTitleA)+1;
        WRITE(fh,&dw, sizeof(dw));
        WRITE(fh,szTitleA,dw);
#else
        // No Unicode so no need to convert to ANSI
        dw = SZSIZEINBYTES(szTitle)+1;
        WRITE(fh,&dw, sizeof(dw));
        WRITE(fh,szTitle,dw);
#endif
    }

    CloseHandle(fh);
    return TRUE;

error:
    CloseHandle(fh);
    DeleteFile(szFile);
    return FALSE;
}

DWORD GetImageTitle(LPCTSTR szFile, LPTSTR szTitle, UINT cb)
{
    BITMAPFILEHEADER    hdr;
    BITMAPINFOHEADER    bi;
    HANDLE              fh;
    DWORD               dwBytesRead;
    DWORD               dw=0;
    CHAR                szTitleA[MAX_PATH];
#ifdef UNICODE
    UINT                uCodePage;
#endif

    fh = CreateFile(szFile,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);

    if (fh == INVALID_HANDLE_VALUE)
        return FALSE;

    dwBytesRead = 0;
    ReadFile(fh, (LPVOID)&hdr, sizeof(hdr), &dwBytesRead, NULL);
    if (dwBytesRead != sizeof(hdr))
    {
        goto error;
    }

    if (hdr.bfType != 0x4d42) // BFT_BITMAP
        goto error;

    if (hdr.bfSize == 0)
        goto error;

    dwBytesRead = 0;
    if (!ReadFile(fh, (LPVOID)&bi, sizeof(bi), &dwBytesRead, NULL) ||
        (dwBytesRead != sizeof(bi)))
    {
        goto error;
    }

    if (bi.biSize != sizeof(bi))
        goto error;

    SetFilePointer(fh, hdr.bfSize, NULL, FILE_BEGIN);
    dwBytesRead=0;
    ReadFile(fh, (LPVOID)&dw, sizeof(dw), &dwBytesRead, NULL);

    if (dw != TITLE_MAGIC)
        goto error;

    dwBytesRead=0;
    ReadFile(fh, (LPVOID)&dw, sizeof(dw), &dwBytesRead, NULL);

    if ((dw > cb) || (dwBytesRead != sizeof(dw)))
        goto error;

    dwBytesRead=0;
    ReadFile(fh, (LPVOID)szTitleA, dw, &dwBytesRead, NULL);

    if (dwBytesRead != dw)
        goto error;

#ifdef UNICODE
    // Need to convert the ANSI string to UNICODE.
    uCodePage = _getmbcp();
    MultiByteToWideChar(uCodePage, 0, szTitleA, -1, szTitle, MAX_PATH);
#else
    // String should be ANSI, no conversion needed, just copy it to
    // the destination buffer.
    lstrcpy(szTitle, szTitleA);
#endif

    CloseHandle(fh);
    return MAKELONG(bi.biWidth, bi.biHeight);

error:
    CloseHandle(fh);
    return MAKELONG(bi.biWidth, bi.biHeight);
}

//
// CacheLoadImageFromFile
//
static HBITMAP _hbm;
static int _width;
static int _height;
static int _bpp;
static int _dither;
static BITMAP_AND_METAFILE_COMBO _dib;
static TCHAR _name[MAX_PATH];

HBITMAP CacheLoadImageFromFile(LPCTSTR szFileName, int width, int height, int bpp, int dither)
{

    TIMESTART(TEXT("CacheLoadImageFromFile"));

    if (szFileName && lstrcmpi(FindExtension(szFileName),TEXT(".bmp")) == 0)
        return LoadImageFromFile(szFileName, NULL, width, height, bpp, dither);

    // If it's an HTML file use IThumbnail to create a bmp
    if ((szFileName && lstrcmpi(FindExtension(szFileName),TEXT(".htm")) == 0) ||
        (szFileName && lstrcmpi(FindExtension(szFileName),TEXT(".html")) == 0))

       {
         SetCursor(LoadCursor(NULL, IDC_WAIT));
         return HtmlToBmp(szFileName, width, height);
       }


    //
    // check our cache.
    //
    if (szFileName &&
        _hbm != NULL &&
        _width == width &&
        _height == height &&
        _bpp == bpp &&
        _dither == dither &&
        lstrcmpi(szFileName, _name) == 0)
    {
        return _hbm;
    }

    if (_hbm)
    {
        DeleteObject(_hbm);
        _hbm = NULL;
    }

    if (_dib.pBitmapInfoHeader == NULL || szFileName == NULL || lstrcmpi(szFileName, _name) != 0)
    {
        if (_dib.pBitmapInfoHeader)
        {
            FreeDIB(_dib);
            _dib.pBitmapInfoHeader = NULL;
            _dib.hMetaFile = NULL;
        }

        if (szFileName == NULL)
            return NULL;

        LoadDIBFromFile(szFileName, &_dib);
        lstrcpy(_name, szFileName);
    }

    if (_dib.pBitmapInfoHeader == NULL)
        return NULL;

    _hbm = LoadImageFromFile(szFileName, &_dib, width, height, bpp, dither);

    if (_hbm)
    {
        _width = width;
        _height = height;
        _bpp = bpp;
        _dither = dither;
    }

    TIMESTOP(TEXT("CacheLoadImageFromFile"));
    return _hbm;
}

void CacheDeleteBitmap(HBITMAP hbm)
{
#if 0
    //
    // we are already caching the DIB data in memory, so we dont need to cache
    // the bitmap
    //
    DeleteObject(hbm);
    if (hbm == _hbm)
    _hbm = NULL;
#else
    if (hbm != _hbm)
        DeleteObject(hbm);
#endif
}

#ifdef _CONSOLE
#ifndef UNICODE  // This console stuff is not UNICODE smart.

#include <stdio.h>

void main (int argc, char **argv)
{
    HBITMAP hbm;
    int bpp=-1;     // default to screen.
    char ach[128];

    argv++;
    argc--;

    if (argc < 1)
    {
        printf("usage: %s [-8 -555 -565 -24 -32] input.jpg output.bmp\n", argv[-1]);
        exit(-1);
    }

    while (argc > 0 && **argv == '-')
    {
        if (lstrcmp(*argv, "-8")   == 0) bpp = 8;
        if (lstrcmp(*argv, "-16")  == 0) bpp = 16;
        if (lstrcmp(*argv, "-555") == 0) bpp = 555;
        if (lstrcmp(*argv, "-565") == 0) bpp = 565;
        if (lstrcmp(*argv, "-24")  == 0) bpp = 24;
        if (lstrcmp(*argv, "-32")  == 0) bpp = 32;
        argc--;
        argv++;
    }

    printf("Loading %s....\n", argv[0]);
    hbm = LoadImageFromFile(argv[0], 0, 0, bpp);

    if (hbm == NULL)
    {
        printf("can't load %s\n", argv[0]);
        exit(-1);
    }

    if (argc > 1)
    {
        BITMAP bm;
        GetObject(hbm, sizeof(bm), &bm);

        printf("Writing %d bpp image %s....\n", bm.bmBitsPixel, argv[1]);
        if (!SaveImageToFile(hbm, argv[1], argv[0]))
        {
            printf("can't save %s\n", argv[1]);
            exit(-1);
        }

        GetImageTitle(argv[1], ach, sizeof(ach));
        printf("image title: %s\n", ach);
    }

    exit(0);
}

#endif // !UNICODE
#endif // _CONSOLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\savedlg.c ===
/* SAVEDLG.C
   Resident Code Segment      // Tweak: make non-resident?

   Routines for Save Theme As dialog

   Frosting: Master Theme Selector for Windows '95
   Copyright (c) 1994-1999 Microsoft Corporation.  All rights reserved.
*/

// ---------------------------------------------
// Brief file history:
// Alpha:
// Beta:
// Bug fixes
// ---------
//
// ---------------------------------------------

#include "windows.h"
#include "frost.h"
#include "global.h"

// Local Routines
BOOL ValidateFilename(LPTSTR);

INT_PTR FAR PASCAL SaveAsDlgProc(hDlg, message, wParam, lParam)
HWND hDlg;
UINT message;
WPARAM wParam;
LPARAM lParam;
{
   switch (message) {

   case WM_INITDIALOG:
      // set max length for new theme name
      SendDlgItemMessage(hDlg, EC_THEME, EM_LIMITTEXT,
                         (WPARAM)(MAX_PATHLEN-5), (LPARAM)0);


      // suggest a name for the new saved theme
      if (LoadString(hInstApp, STR_SUGGEST, szMsg, MAX_STRLEN))
         SetDlgItemText(hDlg, EC_THEME, (LPTSTR)szMsg);
      break;

   case WM_COMMAND:
      switch ((int)LOWORD(wParam)) {

      // watch as changes the edit control
      case EC_THEME:
         if (HIWORD(wParam) == EN_CHANGE) {
            // if changed, enable OK iff nonzero length filename
            EnableWindow(GetDlgItem(hDlg, IDOK),
                         (BOOL) SendMessage((HWND)LOWORD(lParam),
                                            WM_GETTEXTLENGTH,
                                            (WPARAM)0, (LPARAM)0) );
         }
         else return (FALSE);       // didn't really process msg EXIT
         break;

      // OK to go ahead and save the current settings as a new theme
      case IDOK:
      {  // local variable scope
         TCHAR szNewFile[MAX_PATHLEN+1];

         // get new filename
         GetDlgItemText(hDlg, EC_THEME, (LPTSTR)szNewFile, MAX_PATHLEN-4);
         lstrcat((LPTSTR)szNewFile, (LPTSTR)szExt);

         // check whether they gave valid filename: chars + length
         if (!ValidateFilename((LPTSTR)szNewFile)) {
            // bad file: post message and put them back in save dlg
            /// *** DEBUG *** add messagebox here......................
            break;                  // couldn't use name EXIT
         }

         // gather the current windows settings and save them to a THM file
         WaitCursor();
         if (!GatherThemeToFile((LPTSTR)szNewFile)) {
            // out of disk space or some weird file or disk problem
            // *** DEBUG *** add messagebox here......................
            // could be that most saved OK and just one or some a problem?
            NormalCursor();
            break;                  // couldn't write to file somehow EXIT
         }
         NormalCursor();

         // clean up and add new filename to list in drop-down listbox
         lstrcpy((LPTSTR)szMsg, (LPTSTR)szNewFile);
         TruncateExt((LPCTSTR)szMsg);
         if (CB_ERRSPACE != (int) SendDlgItemMessage(hWndApp, DDL_THEME,
                                                     CB_INSERTSTRING,
                                                     (WPARAM) -1, /* end of list */
                                                     (LPARAM)(LPCTSTR)szMsg) ) {

            // get new theme count; ask rather than increment -- for failsafe
            iThemeCount = (int) SendDlgItemMessage(hWndApp, DDL_THEME,
                                                   CB_GETCOUNT, (WPARAM)0, (LPARAM)0);

            // select item just added and save index of selection
            iCurTheme = iThemeCount-1;
            SendDlgItemMessage(hWndApp, DDL_THEME,
                               CB_SETCURSEL, (WPARAM)iCurTheme, (LPARAM)0);

            // update cur Theme file name to your new one
            lstrcpy((LPTSTR)szCurThemeFile, (LPTSTR)szThemeDir);
            lstrcat((LPTSTR)szCurThemeFile, (LPTSTR)szNewFile);

            // update checkboxes
            EnableThemeButtons();

         }
         // else not enuf mem to add new name to DDL; no biggie - already saved

         // (don't need to update preview, etc; was "cur settings" or prev same last)

      }  // variable scope
         /* fall through */
      case IDCANCEL:
         EndDialog(hDlg,(int)LOWORD(wParam));
         break;
      default:
         return (FALSE);
         break;
      }
      break;
   default:
      return(FALSE);
      break;
   }
   return TRUE;
}


//
// ValidateFilename
// Check that this file and the current directory path together make
// a valid filename.
// Check for total length, legals chars, etc.
//
BOOL ValidateFilename(LPTSTR lpszFilename)
{
   // first check for length
   if (lstrlen((LPTSTR)lpszFilename) + lstrlen((LPTSTR)szThemeDir) > MAX_PATHLEN)
      return (FALSE);            // too long for Win95! EXIT

   // do ultimate test of name validity with openfile check

   // cleanup
   return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\nc.h ===
/* NC.H

   Structures needed so UNICODE Themes can read and write ANSI-based
   NonClientMetric and IconMetric structures to the Theme file.

   Frosting: Master Theme Selector for Windows
   Copyright (c) 1998 Microsoft Corporation.  All rights reserved.
*/

//
// ROUTINES from NC.C -- used for converting ANSI structures to UNICODE
// and vice versa.
//
#ifdef UNICODE
VOID ConvertIconMetricsToANSI(LPICONMETRICS, LPICONMETRICSA);
VOID ConvertIconMetricsToWIDE(LPICONMETRICSA, LPICONMETRICSW);
VOID ConvertNCMetricsToANSI(LPNONCLIENTMETRICSW, LPNONCLIENTMETRICSA);
VOID ConvertNCMetricsToWIDE(LPNONCLIENTMETRICSA, LPNONCLIENTMETRICSW);
VOID ConvertLogFontToANSI(LPLOGFONTW, LPLOGFONTA);
VOID ConvertLogFontToWIDE(LPLOGFONTA, LPLOGFONTW);
#endif // UNICODE


/*
#ifdef UNICODE
typedef struct tagLOGFONTA {
   LONG lfHeight;
   LONG lfWidth;
   LONG lfEscapement;
   LONG lfOrientation;
   LONG lfWeight;
   BYTE lfItalic;
   BYTE lfUnderline;
   BYTE lfStrikeOut;
   BYTE lfCharSet;
   BYTE lfOutPrecision;
   BYTE lfClipPrecision;
   BYTE lfQuality;
   BYTE lfPitchAndFamily;
   CHAR lfFaceName[LF_FACESIZE];
} LOGFONTA;

typedef struct tagICONMETRICSA {
    UINT     cbSize;
    int      iHorzSpacing;
    int      iVertSpacing;
    int      iTitleWrap;
    LOGFONTA lfFont;
} ICONMETRICSA, FAR *LPICONMETRICSA;

typedef struct tagNONCLIENTMETRICSA {
    UINT     cbSize;
    int      iBorderWidth;
    int      iScrollWidth;
    int      iScrollHeight;
    int      iCaptionWidth;
    int      iCaptionHeight;
    LOGFONTA lfCaptionFont;
    int      iSmCaptionWidth;
    int      iSmCaptionHeight;
    LOGFONTA lfSmCaptionFont;
    int      iMenuWidth;
    int      iMenuHeight;
    LOGFONTA lfMenuFont;
    LOGFONTA lfStatusFont;
    LOGFONTA lfMessageFont;
} NONCLIENTMETRICSA, FAR* LPNONCLIENTMETRICSA;

#endif //UNICODE
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\regutils.c ===
/* REGUTILS.C
   Resident Code Segment      // Tweak: make non-resident?

   Routines for reading and writing to the system registry and our .THM files.

   GatherThemeToFile()
   ApplyThemeFile()

   Frosting: Master Theme Selector for Windows '95
   Copyright (c) 1994-1999 Microsoft Corporation.  All rights reserved.
*/

// ---------------------------------------------
// Brief file history:
// Alpha:
// Beta:
// Bug fixes
// ---------
//
// ---------------------------------------------
//
// Critique 2/1/95 jdk at dvw
//
// The design intends to have everything work transparently from
// the KEYS.H file. The tables there specify all of the fields
// in the registry that we want to save to a theme file and to set
// from a theme file, along with flags for how to treat each field, 
// etc. It works in nice abstract loops that just save/set what 
// you tell it. You can add and change elements that you care to
// have in the theme by adjusting the KEYS.H file, without touching
// your code. Clean.
// 
// Unfortunately, once you've set everything in the registry, you
// still need to hand-code how you make many of the elements take
// effect in the system in the current user session. This involves
// wildly divergent APIs/parameters. This blows the abstraction noted
// above. Everytime you change something in the KEYS.H file, you have
// to hand-code changes here, too.
//
// I've isolated the non-abstract, item-specific code in HandPumpSystem()
// below. Looking back on it now, there is some redundancy here. If
// we started by doing everything by hand, then we could do the registry
// and system settings together. Now you may end up reading, writing, 
// and later rereading the same string -- with attendant Reg open/closes
// as well.

#include "windows.h"
#include "frost.h"
#include "global.h"
#include "keys.h"                   // only this files refers to list of keys
#include "shlobj.h"                 // for SHChangeNotify() and flag
#include "loadimag.h"              
#include "Bkgd.h"
#include "adutil.h"
#include "schedule.h"
#include "mmsystem.h"

// Stuff in bkgd.c
extern void GetPlusBitmapName(LPTSTR szPlus);
extern HBITMAP LoadWallpaper(LPTSTR szWallpaper, LPTSTR szTheme, BOOL fPreview);

// Externs in NC.C
extern BOOL FAR GatherIconMetricsByHand();
extern BOOL FAR GatherNonClientMetricsByHand();
extern VOID FAR SetIconMetricsByHand(BOOL, BOOL);
extern VOID FAR SetNonClientMetricsByHand(BOOL, BOOL);

// Local Routines 
BOOL GatherSubkeys(HKEY, FROST_SUBKEY *, int, LPTSTR);
BOOL DatumRegisterToFile(HKEY, FROST_VALUE, LPTSTR, LPTSTR);
BOOL FAR WriteBytesToFile(LPTSTR, LPTSTR, BYTE *, int, LPTSTR);
BOOL ApplySubkeys(HKEY, FROST_SUBKEY *, int, LPTSTR, BOOL);
BOOL DatumFileToRegister(HKEY, FROST_VALUE, LPTSTR, LPTSTR, BOOL);
BOOL WriteBytesToRegister(HKEY, LPTSTR, int, LPTSTR);
int FAR WriteBytesToBuffer(LPTSTR);
BOOL IsTrashFull();
BOOL ApplyCurrentTrash(BOOL, LPTSTR);
BOOL HandPumpSystem();
BOOL GatherSysColorsByHand(LPTSTR);
BOOL SetSysColorsByHand();
BOOL GatherWallpaperBitsByHand(LPTSTR);
VOID AbstractPath(LPTSTR, int);
BOOL GatherICONS(LPCTSTR);
BOOL ApplyWebView(LPCTSTR);
BOOL GatherWebView(LPCTSTR);
BOOL ExtractWVResource(LPCTSTR, LPCTSTR);
VOID ExpandSZ(LPTSTR);

extern TCHAR szCursors[];

#define DEF_SCREENSAVETIMEOUT 15 * 60   // default time to screen saver in seconds

//
// Local Globals
//
TCHAR pValue[MAX_VALUELEN+1];        // multi-use buffer: char, hex string, etc.

BOOL bReadOK, bWroteOK;             // Save: read from reg/sys, write to file
                                    // Apply: not implemented since ignoring results anyway

// strings for grody screen saver case
TCHAR szSS_Section[] = TEXT("boot");
TCHAR szSS_Key[] = TEXT("SCRNSAVE.EXE");
TCHAR szSS_File[] = TEXT("SYSTEM.INI");    // this worked in disp cpl code with no path....
TCHAR szCP_Clr[] = TEXT("Control Panel\\Colors");
TCHAR szCP_Appearance[] = TEXT("Control Panel\\Appearance");
TCHAR szCP_SoundSchemes[] = TEXT("AppEvents\\Schemes");
extern TCHAR szCP_DT[];
TCHAR szSS_Active[] = TEXT("ScreenSaveActive");
TCHAR szCurrent[] = TEXT("Current");
extern TCHAR szTileWP[];
TCHAR szWPStyle[]  = TEXT("WallpaperStyle");

//
// For DoSysColors() and GetThemeColors() and others
//
// Important that these two arrays are the same length, and that they
// are kept in the same order together during any change.
//
// SYNCHRONIZATION ALERT! -- Keep INDEX_* defines in FROST.H in
// sync with this array.  Keep NUM_COLORS define in FAKEWIN.H
// in sync with this array.

TCHAR *pRegColors[] = {
   TEXT("ActiveTitle"),
   TEXT("Background"),
   TEXT("Hilight"),
   TEXT("HilightText"),
   TEXT("TitleText"),
   TEXT("Window"),
   TEXT("WindowText"),
   TEXT("Scrollbar"),
   TEXT("InactiveTitle"),
   TEXT("Menu"),
   TEXT("WindowFrame"),
   TEXT("MenuText"),
   TEXT("ActiveBorder"),
   TEXT("InactiveBorder"),
   TEXT("AppWorkspace"),
   TEXT("ButtonFace"),
   TEXT("ButtonShadow"),
   TEXT("GrayText"),
   TEXT("ButtonText"),
   TEXT("InactiveTitleText"),
   TEXT("ButtonHilight"),
   TEXT("ButtonDkShadow"),
   TEXT("ButtonLight"),
   TEXT("InfoText"),
   TEXT("InfoWindow"),
// These next two are bogus -- just here to pad the array.  They
// should be something like the "ButtonAlternateFace" (not sure
// about that one) and "HotTrackingColor".
   TEXT("GradientActiveTitle"),
   TEXT("GradientInactiveTitle"),
// These next two are the real deal for the gradient title bars
   TEXT("GradientActiveTitle"),
   TEXT("GradientInactiveTitle")
};

int iSysColorIndices[] =  {
   COLOR_ACTIVECAPTION,
   COLOR_DESKTOP,
   COLOR_HIGHLIGHT,
   COLOR_HIGHLIGHTTEXT,
   COLOR_CAPTIONTEXT,
   COLOR_WINDOW,
   COLOR_WINDOWTEXT,
   COLOR_SCROLLBAR,
   COLOR_INACTIVECAPTION,
   COLOR_MENU,
   COLOR_WINDOWFRAME,
   COLOR_MENUTEXT,
   COLOR_ACTIVEBORDER,
   COLOR_INACTIVEBORDER,
   COLOR_APPWORKSPACE,
   COLOR_3DFACE,
   COLOR_3DSHADOW,
   COLOR_GRAYTEXT,
   COLOR_BTNTEXT,
   COLOR_INACTIVECAPTIONTEXT,
   COLOR_3DHILIGHT,
   COLOR_3DDKSHADOW,
   COLOR_3DLIGHT,
   COLOR_INFOTEXT,
   COLOR_INFOBK,
// These next two are bogus -- just here to pad the array.  They
// should be something like the "COLOR_3DFACE" (not sure about
// that one) and "COLOR_HOTLIGHT".
   COLOR_GRADIENTACTIVECAPTION,
   COLOR_GRADIENTINACTIVECAPTION,
// These next two are the real deal for the gradient title bars
   COLOR_GRADIENTACTIVECAPTION,
   COLOR_GRADIENTINACTIVECAPTION
};

__inline int _atoi(char *sz)
{
    int i=0;
    while (*sz && *sz >= '0' && *sz <= '9')
        i = i*10 + *sz++ -'0';
    return i;
}

//
//  GetRegString
//
void GetRegString(HKEY hkey, LPCTSTR szKey, LPCTSTR szValue, LPCTSTR szDefault, LPTSTR szBuffer, UINT cbBuffer)
{
    if (szDefault)
        lstrcpy(szBuffer, szDefault);
    else
        szBuffer[0] = 0;

    if (RegOpenKey(hkey, szKey, &hkey) == 0)
    {
        RegQueryValueEx(hkey, szValue, NULL, NULL, (LPBYTE)szBuffer, &cbBuffer);
        RegCloseKey(hkey);
    }
}

//
//  GetRegInt
//
int GetRegInt(HKEY hkey, LPCTSTR szKey, LPCTSTR szValue, int def)
{
    TCHAR ach[40];
#ifdef UNICODE
    CHAR szTempA[40];
#endif

    GetRegString(hkey, szKey, szValue, NULL, ach, sizeof(ach));

    if (ach[0])
#ifdef UNICODE
    // Need to do conversion to ANSI for _atoi to work.
    {
        wcstombs(szTempA, (wchar_t *)ach, sizeof(szTempA));
        return _atoi(szTempA);
    }
#else  // !UNICODE
        return _atoi(ach);
#endif
    else
        return def;
}

//
// GatherThemeToFile
// 
// This is one of the workhorse routines of the package.
// For the whole list of theme items that we care about, go check the
// cur Windows system settings in the registry. Copy those settings to
// a new file with the given full pathname.
//
// Oh, and umh then: for the two sets of things we do by hand --
// rather than by reading (and later writing) directly from (to)
// the registry -- go off and do the special case code for them.
// That is, Icon metrics and Nonclient metrics.
//
// Uses: global szCurDir to get theme directory
//       resets szCurThemeFile if successful writing to file
//
// Returns: BOOL success writing to file
//
BOOL FAR GatherThemeToFile(LPTSTR lpszFullPath)
{
   int imaxkey;
   BOOL bRet, bOK = TRUE;

   // 
   // init global error flags
   bReadOK = bWroteOK = TRUE;

   //
   // first do the ICON subkeys

   // OLD Plus95 code for gathering icon information has been replaced
   // by GatherICONS() function below.
   //imaxkey = sizeof(fsRoot)/sizeof(FROST_SUBKEY);
   //bOK = GatherSubkeys(HKEY_CLASSES_ROOT, fsRoot, imaxkey, lpszFullPath);

   bOK = GatherICONS(lpszFullPath);

   //
   // then do the CURRENT_USER subkeys

   imaxkey = sizeof(fsCurUser)/sizeof(FROST_SUBKEY);
   bRet = GatherSubkeys(HKEY_CURRENT_USER, fsCurUser, imaxkey, lpszFullPath);
   bOK = bOK && bRet;

   //
   // Now do the special cases
   bRet = GatherIconMetricsByHand(lpszFullPath);
   bOK = bOK && bRet;
   bRet = GatherNonClientMetricsByHand(lpszFullPath);
   bOK = bOK && bRet;
   bRet = GatherSysColorsByHand(lpszFullPath);
   bOK = bOK && bRet;
   bRet = GatherWallpaperBitsByHand(lpszFullPath);
   bOK = bOK && bRet;


   //
   // then do the Screen Saver setting, off in its own world
   // get cur
   GetPrivateProfileString((LPTSTR)szSS_Section, (LPTSTR)szSS_Key,  
                           (LPTSTR)szNULL,
                           (LPTSTR)pValue, MAX_VALUELEN,
                           (LPTSTR)szSS_File);
   // abstract out variable path if appropriate
   AbstractPath((LPTSTR)pValue, MAX_VALUELEN);
   // and save it to the theme
   bRet = WritePrivateProfileString((LPTSTR)szSS_Section, (LPTSTR)szSS_Key,
                                    (LPTSTR)pValue, lpszFullPath);
   bOK = bOK && bRet;
   if (!bRet) bWroteOK = FALSE;

   // Collect the WebView settings -- don't think we really care
   // if this fails...
   GatherWebView(lpszFullPath);
   //
   // then write magic number for file verification
   bRet = WritePrivateProfileString((LPTSTR)szFrostSection,
                                    (LPTSTR)szMagic,
                                    (LPTSTR)szVerify,
                                    lpszFullPath);
   bOK = bOK && bRet;
   if (!bRet) bWroteOK = FALSE;

   //
   // cleanup
   Assert(bOK, TEXT("didn't gather theme to file successfully\n"));
   return (bOK);
}


//
// GatherSubkeys
// 
// OK, read this carefully.
//
// This routine takes a handle to a currently open Registry key.
// Then it takes a pointer to an array of FROST_SUBKEYs that identifies
// subkey name strings of the open key. Then for those subkey names
// each FROST_SUBKEY also points to another array of value names. This
// is the final leaf of the Registry scheme. With a key, a subkey and a
// specific value name, you can get an actual value. The actual query and
// writing to a file happens in the DatumRegisterToFile() routine below.
//
// So here's the scheme:
//    for each subkey
//       open the subkey to get a key handle
//       for each value of this subkey that we care about
//          pass all the info to DatumRegisterToFile() to write one value
//
// Returns: BOOL success writing to file
// 
BOOL GatherSubkeys(HKEY hKeyRoot, FROST_SUBKEY *fsEnum, int iMaxKey, LPTSTR lpszFile)
{
   HKEY hKey;                       // cur open key
   int ikey, ival;
   LONG lret;
   BOOL bRet, bOK = TRUE;

   // loop through each subkey 
   for (ikey = 0; ikey < iMaxKey; ikey++) {

      // open this subkey
      lret = RegOpenKeyEx( hKeyRoot, (LPTSTR)fsEnum[ikey].szSubKey,
                               (DWORD)0, KEY_QUERY_VALUE, (PHKEY)&hKey );

      // check that you got a good key here
      if (lret != ERROR_SUCCESS) {
         Assert(FALSE, TEXT("problem on RegOpenKey (read) of subkey "));
         Assert(FALSE, fsEnum[ikey].szSubKey);
         Assert(FALSE, TEXT("\n"));

         // OK, you couldn't open the key to even look at the values.

         // *****************************************************************
         // based on the sketchy documentation we have for this Reg* and Error
         // stuff, we're guessing that you've ended up here because this
         // totally standard, Windows-defined subkey name just doesn't happen 
         // to be defined for the current user.
         // *****************************************************************

         // SO: just write empty strings to the THM file for each valuename
         // you have for this subkey. You have then faithfully recorded that
         // there was nothing there.

         // still successful so long as all the empty strings are written out
         // with the value names to the THM file. also do default string if 
         // appropriate.

         // (null loop if default string only)
         for (ival = 0; ival < fsEnum[ikey].iNumVals; ival++) {
            bRet = WritePrivateProfileString(
                                    fsEnum[ikey].szSubKey,
                                    (LPTSTR)fsEnum[ikey].fvVals[ival].szValName,
                                    (LPTSTR)szNULL, lpszFile
                                            );
            Assert(bRet, TEXT("couldn't write empty value string to THM file\n"));
            bOK = bOK && bRet;
            if (!bRet) bWroteOK = FALSE;
         }
         if (fsEnum[ikey].fValues != FV_LIST) { // either def or list+def
            bRet = WritePrivateProfileString(
                                    fsEnum[ikey].szSubKey,
                                    (LPTSTR)FROST_DEFSTR,
                                    (LPTSTR)szNULL, lpszFile
                                            );
            Assert(bRet, TEXT("couldn't write empty default string to THM file\n"));
            bOK = bOK && bRet;
            if (!bRet) bWroteOK = FALSE;
         }

         continue;                  // Open (read) subkey problem EXIT
      }

      // treat depending on type of values for this subkey
      switch (fsEnum[ikey].fValues) {

      case FV_LIST:
      case FV_LISTPLUSDEFAULT:

         // loop through each value in the list for this subkey
         for (ival = 0; ival < fsEnum[ikey].iNumVals; ival++) {
            bRet = DatumRegisterToFile(hKey, fsEnum[ikey].fvVals[ival],
                                       lpszFile,
                                       (LPTSTR)(fsEnum[ikey].szSubKey) );
            bOK = bOK && bRet;
         }

         // check if just list or list plus default
         if (FV_LIST == fsEnum[ikey].fValues)
            break;                  // normal EXIT
         // else fall through and do default, too

      case FV_DEFAULT:
         //
         // Default string: There are no "valuenames" to search for under
         // this key. Like the old INI file routines, it's just 
         //

         // get default string:
         // this is a little messy to include here and get it right

         {  // variable scope
         DWORD dwSize;
         DWORD dwType;
         LONG lret;
         BOOL bDefault = TRUE;

            // first do paranoid check of data size
            lret = RegQueryValueEx(hKey, (LPTSTR)szNULL,   // null str to get default
                                   (LPDWORD)NULL,
                                   (LPDWORD)&dwType,
                                   (LPBYTE)NULL,
                                   (LPDWORD)&dwSize );
 
            if (ERROR_SUCCESS == lret) {              // saw something there

               // here's the size check before getting the data
               if (dwSize > (DWORD)(MAX_VALUELEN * sizeof(TCHAR))) {
                  Assert(FALSE, TEXT("Humongous default entry string in registry...\n"));
                  bDefault = FALSE; // can't read, so very bad news
                  bReadOK = FALSE;
               }
               else {               // size is acceptable
                  // now really get the value
                  lret = RegQueryValueEx(hKey, (LPTSTR)szNULL,// null str to get default
                                       (LPDWORD)NULL,
                                       (LPDWORD)&dwType,
                                       (LPBYTE)pValue, // getting actual def value
                                       (LPDWORD)&dwSize);

                  // If the value is an EXPAND_SZ we need to expand it...
                  if (REG_EXPAND_SZ == dwType) ExpandSZ(pValue);

                  Assert(lret == ERROR_SUCCESS, TEXT("bad return on default entry string\n"));
                  Assert(((dwType == (DWORD)REG_SZ) || (dwType == (DWORD)REG_EXPAND_SZ)), TEXT("unexpected default entry type\n"));

                  if (ERROR_SUCCESS != lret)
                     // couldn't read somehow, so use null string
                     *pValue = 0;
               }
            }
            else
               // couldn't even find the default string, so use null string
               *pValue = 0;

            // be sure to remember if couldn't get a value as above
            bOK = bOK && bDefault;
            
         }  // end variable scope

         //
         // OK, if this is a path/filename, see about xlating to relative path
         if (fsEnum[ikey].bDefRelPath)
            AbstractPath((LPTSTR)pValue, MAX_VALUELEN);

         //
         // Phew, finally:write single default value
         //
         bRet = WritePrivateProfileString((LPTSTR)(fsEnum[ikey].szSubKey),
                                          (LPTSTR)FROST_DEFSTR,
                                          (LPTSTR)pValue, lpszFile);
         Assert(bRet, TEXT("couldn't write default string to THM file.\n"));
         bOK = bOK && bRet;
         if (!bRet) bWroteOK = FALSE;
         break;

      default:
         Assert(FALSE, TEXT("Unlisted .fValues value in Gather!\n"));
         break;
      }

      // close this key
      RegCloseKey(hKey);

   }

   // CLEANUP
   Assert(bOK, TEXT("didn't GatherSubkeys well\n"));
   return (bOK);
}


//
// DatumRegisterToFile
//
// This is the atomic operation: a single datum from the registry to the file.
// The technique varies a little by type of datum.
//
// Returns: BOOL success writing to file
//          Note that sucess doesn't depend on reading value from registry; 
//          could be a value that's not set. Only reason to fail is: value
//          was too big to read, or the write itself failed.
//
BOOL DatumRegisterToFile(
HKEY hQueryKey,
FROST_VALUE fvQuery,
LPTSTR lpszFile,                   // full pathname for output file
LPTSTR lpszKeyname )
{
   DWORD dwSize;
   DWORD dwType;
   LONG lret;
   BOOL bOK = TRUE;
   BOOL bSkipReadingWP = FALSE;

   // First off, if this is the Wallpaper and ActiveDesktop is on we
   // need to read the current wallpaper setting from the IActiveDesktop
   // interface instead of from the registry.

   bSkipReadingWP = FALSE;
   if ((lstrcmpi(fvQuery.szValName,TEXT("Wallpaper")) == 0) && IsActiveDesktopOn()) {
      if (GetADWallpaper(pValue)) {
         bSkipReadingWP = TRUE;
         dwType = REG_SZ;   // Set dwType as if we read a SZ from the reg
         lret = ERROR_SUCCESS;
      }
      // Couldn't read the wallpaper from IActiveDesktop so go ahead and
      // try reading it from the registry.
   }

   // Else, if this is the Wallpaper Pattern and ActiveDesktop is on we
   // need to read the current Pattern setting from the IActiveDesktop
   // interface instead of from the registry.

   else if ((lstrcmpi(fvQuery.szValName,TEXT("Pattern")) == 0) &&
                                                IsActiveDesktopOn()) {
      if (GetADWPPattern(pValue)) {
         bSkipReadingWP = TRUE;
         dwType = REG_SZ;   // Set dwType as if we read a SZ from the reg
         lret = ERROR_SUCCESS;
      }
      // Couldn't read the Pattern from IActiveDesktop so go ahead and
      // try reading it from the registry.
   }

   if (!bSkipReadingWP) {

      // first do paranoid check of data size
      lret = RegQueryValueEx(hQueryKey, fvQuery.szValName, (LPDWORD)NULL,
                             (LPDWORD)&dwType, (LPBYTE)NULL, (LPDWORD)&dwSize);

      if (ERROR_SUCCESS == lret) {

         // here's the size check before getting the data
         if (dwSize > (DWORD)(MAX_VALUELEN*sizeof(TCHAR))) {
            Assert(FALSE, TEXT("Humongous entry in registry...\n"));
            bReadOK = FALSE;
            return (FALSE);        // incredibly unlikely mammoth entry EXIT
         }
      
         //
         // now really get the value
         //

         lret = RegQueryValueEx(hQueryKey, fvQuery.szValName, (LPDWORD)NULL,
                              (LPDWORD)&dwType, (LPBYTE)pValue, (LPDWORD)&dwSize);

         // If EXPAND_SZ type we need to expand it
         if (REG_EXPAND_SZ == dwType)
         {
            ExpandSZ(pValue);
            dwType = REG_SZ;  // Fudge this to make that assert happy
         }
         Assert(lret == ERROR_SUCCESS, TEXT("bad return on datum retrieval\n"));
         Assert(dwType == (DWORD)fvQuery.iValType, TEXT("unexpected datum type\n"));
      }
   }
   //
   // if you got something, go ahead and write it 
   if (ERROR_SUCCESS == lret) {

      // switch on value type to get how to write it 
      switch ((int)dwType) {

      case REG_SZ:
      case REG_EXPAND_SZ:
         // before writing, if this is a path/filename,
         // see about xlating to relative path
         //
         // even before that, see if it is a bitmap
         // and find out what compressed file it came from --
         // that is if it's not an HTM/HTML wallpaper.

         if ((lstrcmpi(fvQuery.szValName, TEXT("Wallpaper")) == 0) &&
             (lstrcmpi(FindExtension(pValue), TEXT(".htm")) != 0) &&
             (lstrcmpi(FindExtension(pValue), TEXT(".html")) !=0)) {
            GetImageTitle(pValue, pValue, sizeof(pValue));
         }


         if (fvQuery.bValRelPath)
            AbstractPath((LPTSTR)pValue, MAX_VALUELEN);

         bOK = WritePrivateProfileString(lpszKeyname,
                                         (LPTSTR)fvQuery.szValName,
                                         (LPTSTR)pValue, lpszFile);
         Assert(bOK, TEXT("couldn't write value string to THM file.\n"));
         if (!bOK) bWroteOK = FALSE;
         break;

      //
      // these two cases are both just treated as binary output
      case REG_DWORD:
      case REG_BINARY:

         bOK = WriteBytesToFile(lpszKeyname, (LPTSTR)fvQuery.szValName,
                                (BYTE *)pValue, (int)dwSize, lpszFile);
         Assert(bOK, TEXT("couldn't write value bytes to THM file.\n"));
         if (!bOK) bWroteOK = FALSE;   // pretty unitary write function
         break;

      default:
         Assert(FALSE, TEXT("unexpected REG_* data type read from registry\n"));
         break;
      }
   }

   // EITHER: couldn't query size OR couldn't retrieve value
   else {

      // *****************************************************************
      // based on the sketchy documentation we have for this Reg* and Error
      // stuff, we're guessing that you've ended up here because this
      // totally legitimate, successfully opened key and this totally
      // standard, Windows-defined value name just doesn't happen to have
      // a value assigned to it for the current user.
      // *****************************************************************

      // So: just write an empty string to the THM file. Still successful
      // so long as the key actually is written to the THM file.

      bOK = WritePrivateProfileString(lpszKeyname,
                                      (LPTSTR)fvQuery.szValName,
                                      (LPTSTR)szNULL, lpszFile);
      Assert(bOK, TEXT("couldn't write empty string to THM file.\n"));
      if (!bOK) bWroteOK = FALSE;
   }

   // cleanup
   Assert(bOK, TEXT("missed a datum from register to file\n"));
   return (bOK);
}



//
// WriteBytesToFile
//
// Writes binary data out to the THM file.
// Converts the data byte by byte to ASCII numbers, appends
// them to one long string, writes string to profile.
//
// Returns: success of write to theme file
//
BOOL FAR WriteBytesToFile(LPTSTR lpszProfileSection, LPTSTR lpszProfileKey,
                      BYTE *pData, int iBytes, LPTSTR lpszProfile)
{
   HLOCAL hXlat;
   TCHAR *psz;
   BOOL bWrote = TRUE;
   int iter;
#ifdef UNICODE
   char szNumberA[10];   // byte value converted to ANSI
#endif

   //
   // inits

   // alloc and lock memory for translation
   hXlat = LocalAlloc(LPTR, 5*sizeof(TCHAR)*iBytes+2);
   if (!hXlat) {                    // couldn't create buffer!!
      NoMemMsg(STR_TO_SAVE);        // post low mem message!
      return (FALSE);               // bad news couldn't write EXIT
   }

   //
   // do the translation to a string

   psz = (TCHAR *)hXlat;             // start at beginning of string buffer

   // loop through the bytes
   for (iter = 0; iter < iBytes; iter++) {

      // translate one byte into our string buffer

#ifdef UNICODE
      // With UNICODE we need to use a temporary ANSI buffer
      // for the litoa conversion, then convert that string to
      // UNICODE when putting it into our main string buffer.

      litoa( (int)(pData[iter]), (LPSTR)szNumberA);
      mbstowcs((wchar_t *)psz, szNumberA, sizeof(szNumberA));

#else // !UNICODE
      litoa( (int)(pData[iter]), (LPSTR)psz);
#endif
      // add a space
      lstrcat((LPTSTR)psz, TEXT(" "));

      // bump pointer up to end of string for next byte
      psz = psz + lstrlen((LPTSTR)psz);
   }

   //
   // do the write to the THM file

   bWrote = WritePrivateProfileString(lpszProfileSection, 
                                      lpszProfileKey,
                                      (LPTSTR)hXlat,
                                      lpszProfile);

   //
   // cleanup

   // free up memory allocated
   LocalFree(hXlat);
   return (bWrote);
}


//
// ApplyThemeFile
//
// The inverse of GatherThemeToFile(), this routine takes a theme
// file and sets system registry values from the file. It also then
// calls individual APIs to make some of the settings take immediate
// effect.
// 
// Goes through the list of theme values and if the controlling checkbox
// is checked, sets the value from the file to the registry. This is 
// a nice clean loop using the tables in KEYS.H to match checkboxes to
// registry keys/valuenames.
//
// Then for each checkbox, do the current system settings by hand as
// necessary.
//
// lpszFilename == full pathname
BOOL FAR ApplyThemeFile(LPTSTR lpszFilename)
{
   BOOL bRet, bOK = TRUE;
   int imaxkey;
   BOOL bFullTrash;
   extern TCHAR szPlus_CurTheme[];

   //
   // first apply the ROOT subkeys to the registry: these are the icons

   // but first first go check cur registry to see if trash can full or empty
   bFullTrash = IsTrashFull();

   // OK now apply the root subkeys -- this is where Win95 checks for
   // the icons
   //imaxkey = sizeof(fsRoot)/sizeof(FROST_SUBKEY);
   //bOK = ApplySubkeys(HKEY_CLASSES_ROOT, fsRoot, imaxkey, lpszFilename,
   //                   FALSE); // don't apply null theme entries for icons!

   // Now apply the Win98/current user icon keys

   imaxkey = sizeof(fsCUIcons)/sizeof(FROST_SUBKEY);
   bOK = ApplySubkeys(HKEY_CURRENT_USER, fsCUIcons, imaxkey, lpszFilename,
                      FALSE); // don't apply null theme entries for icons!

   // have to keep setting cursor to wait because someone resets it
   WaitCursor();

   // now apply the right current trash icon from theme
   bRet = ApplyCurrentTrash(bFullTrash, lpszFilename);
   bOK = bOK && bRet;

   //
   // then apply the CURRENT_USER subkeys to the registry

   imaxkey = sizeof(fsCurUser)/sizeof(FROST_SUBKEY);
   bRet = ApplySubkeys(HKEY_CURRENT_USER, fsCurUser, imaxkey, lpszFilename, TRUE);
   bOK = bOK && bRet;

   // have to keep setting cursor to wait because someone resets it
   WaitCursor();

   ApplyWebView(lpszFilename);

   WaitCursor();

   // just a random place to check this:
   Assert(NUM_CURSORS == (sizeof(fvCursors)/sizeof(FROST_VALUE)),
          TEXT("DANGER: mismatched number of cursors in fvCursors and NUM_CURSORS constant!\n"));

   //
   // now try to make everything apply to the system currently
   bRet = HandPumpSystem();
   // *** DEBUG *** need specific error message here
   bOK = bOK && bRet;

   //
   // cleanup

   // save this theme file in the registry as the last one applied


   // if you messed with stored CB values for color problem filter
   if (bLowColorProblem && (fLowBPPFilter == APPLY_NONE)) 
      SaveCheckboxes();             // then reset from the actual buttons
   Assert(bOK, TEXT("didn't apply theme successfully\n"));
   return (bOK);
}


//
// ApplySubkeys
// 
// This is parallel to the GatherSubkeys() function above, copying
// values instead _from_ the theme file _to_ the Registry. It uses
// the same loop structure, see the comments to GatherSubkeys().
//
// The one change is that on applying values, we check first the
// FC_* flag in the fValCheckbox or fDefCheckbox fields to identify
// the controlling checkbox for that valuename. If the checkbox is
// unchecked, the value is not set. (We already got the checkbox states
// into bCBStates[] in ApplyThemeFile() above.
//
// Returns: success writing to Registry, should be always TRUE.
//
BOOL ApplySubkeys(HKEY hKeyRoot, FROST_SUBKEY *fsEnum, int iMaxKey, LPTSTR lpszFile, BOOL bApplyNull)
{
   HKEY hKey;                       // cur open key
   int ikey, ival, iret;
   LONG lret;
   BOOL bRet, bOK = TRUE;
   TCHAR szNTReg[MAX_PATH];

   // loop through each subkey 
   for (ikey = 0; ikey < iMaxKey; ikey++) {

      // have to keep setting cursor to wait because someone resets it
      WaitCursor();

      // If this is NT and the key is for the icons we need to touch
      // up the reg pathing

      if (IsPlatformNT() && (ikey < MAX_ICON) &&
          ((lstrcmpi(fsEnum[ikey].szSubKey,  fsCUIcons[ikey].szSubKey) == 0) ||
          (lstrcmpi(fsEnum[ikey].szSubKey,  fsRoot[ikey].szSubKey) == 0)))

      {
          lstrcpy(szNTReg, c_szSoftwareClassesFmt);
          lstrcat(szNTReg, fsRoot[ikey].szSubKey);

          // open this subkey
          lret = RegOpenKeyEx( hKeyRoot, (LPTSTR)szNTReg,
                               (DWORD)0, KEY_SET_VALUE, (PHKEY)&hKey );
      }
      else
      {

          // open this subkey
          lret = RegOpenKeyEx( hKeyRoot, (LPTSTR)fsEnum[ikey].szSubKey,
                               (DWORD)0, KEY_SET_VALUE, (PHKEY)&hKey );
      }

      // check that you got a good key here
      if (lret != ERROR_SUCCESS) {
         DWORD dwDisposition;

         Assert(FALSE, TEXT("problem on RegOpenKey (write) of subkey "));
         Assert(FALSE, fsEnum[ikey].szSubKey);
         Assert(FALSE, TEXT("\n"));

         // OK, you couldn't even open the key !!!

         // *****************************************************************
         // based on the sketchy documentation we have for this Reg* and Error
         // stuff, we're guessing that you've ended up here because this
         // totally standard, Windows-defined subkey name just doesn't happen 
         // to be defined for the current user.
         // *****************************************************************

         // SO: Just create this subkey for this user, and maybe it will get
         // used after you create and set it.
         // still successful so long as can create new subkey to write to

         if (IsPlatformNT() && (ikey < MAX_ICON) &&
             ((lstrcmpi(fsEnum[ikey].szSubKey,  fsCUIcons[ikey].szSubKey) == 0) ||
             (lstrcmpi(fsEnum[ikey].szSubKey,  fsRoot[ikey].szSubKey) == 0)))

         {
             lret = RegCreateKeyEx( hKeyRoot, (LPTSTR)szNTReg,
                                   (DWORD)0, (LPTSTR)szNULL, REG_OPTION_NON_VOLATILE,
                                   KEY_SET_VALUE, (LPSECURITY_ATTRIBUTES)NULL,
                                   (PHKEY)&hKey, (LPDWORD)&dwDisposition );
         }
         else
         {
             lret = RegCreateKeyEx( hKeyRoot, (LPTSTR)fsEnum[ikey].szSubKey,
                                   (DWORD)0, (LPTSTR)szNULL, REG_OPTION_NON_VOLATILE,
                                   KEY_SET_VALUE, (LPSECURITY_ATTRIBUTES)NULL,
                                   (PHKEY)&hKey, (LPDWORD)&dwDisposition );

         }

         if (lret != ERROR_SUCCESS) {
            Assert(FALSE, TEXT("problem even with RegCreateKeyEx (write) of subkey "));
            Assert(FALSE, fsEnum[ikey].szSubKey);
            Assert(FALSE, TEXT("\n"));

            // we are not happy campers
            bOK = FALSE;
            // but we'll keep on truckin'
            continue;               // bad subkey EXIT
         }

      }

      // treat depending on type of values for this subkey
      switch (fsEnum[ikey].fValues) {

      case FV_LIST:
      case FV_LISTPLUSDEFAULT:

         // loop through each value in the list for this subkey
         for (ival = 0; ival < fsEnum[ikey].iNumVals; ival++) {

            // if the checkbox that controls this value is checked
            if ( bCBStates[ fsEnum[ikey].fvVals[ival].fValCheckbox ] ) {

               // then read from theme file and write to registry
               bRet = DatumFileToRegister(hKey, fsEnum[ikey].fvVals[ival],
                                          lpszFile,
                                          (LPTSTR)(fsEnum[ikey].szSubKey),
                                          bApplyNull);
               bOK = bOK && bRet;
            }
         }

         // check if just list or list plus default
         if (FV_LIST == fsEnum[ikey].fValues)
            break;                  // normal EXIT
         // else fall through and do default, too

      case FV_DEFAULT:
         //
         // if this subkey's default value's checkbox is checked
         if (bCBStates[fsEnum[ikey].fDefCheckbox]) {

            //
            // Default string: There are no "valuenames" to set under
            // this key. Like the old INI file routines, it's just one value.
            //
                       
            //
            // Get default value string
            iret = GetPrivateProfileString((LPTSTR)(fsEnum[ikey].szSubKey),
                                          (LPTSTR)FROST_DEFSTR,
                                          (LPTSTR)szNULL,
                                          (LPTSTR)pValue, MAX_VALUELEN, lpszFile);

            // no error case; legit null string value is indistinguishable from
            // error case...

            // If we're reading the ICON strings and we got a NULL return
            // then we should try using the "old" Win95 reg keys in case
            // this is an old .Theme file

            if ((!*pValue) && (ikey < MAX_ICON) &&
               (lstrcmpi(fsEnum[ikey].szSubKey,  fsCUIcons[ikey].szSubKey) == 0))
            {
               iret = GetPrivateProfileString((LPTSTR)(fsRoot[ikey].szSubKey),
                                              (LPTSTR)FROST_DEFSTR,
                                              (LPTSTR)szNULL,
                                              (LPTSTR)pValue,
                                              MAX_VALUELEN, 
                                              lpszFile);

               // PLUS98 bug 1042
               // If this is the MyDocs icon and there is no setting for
               // it in the Theme file then we need to default to the
               // szMyDocsDefault icon.

               if ((MYDOC_INDEX == ikey) && (!*pValue)) {
                  lstrcpy(pValue, MYDOC_DEFSTR);
               }
                  
            }
            
            // if this value is a relative path filename string,
            // first see about making abstract path into current instance
            if (fsEnum[ikey].bDefRelPath) {
               InstantiatePath((LPTSTR)pValue, MAX_VALUELEN);
               // look for and confirm finding the file, with replacement
               if (ConfirmFile((LPTSTR)pValue, TRUE) == CF_NOTFOUND) {
                  *pValue = 0;      // if not found, just null out filename
                  bOK = FALSE;      // couldn't apply this file
               }
            }

            //
            // sometimes don't want to set a null string to the Registry
            if (*pValue || bApplyNull) {  // either non-null or OK to set null

               // now set the value in the registry
               lret = RegSetValueEx(hKey, (LPTSTR)szNULL,// null str to set default value
                                    0,
                                    (DWORD)REG_SZ,
                                    (LPBYTE)pValue, // getting actual def value
                                    (DWORD)(SZSIZEINBYTES(pValue)));
               Assert(lret == ERROR_SUCCESS, TEXT("couldn't write a default entry string!\n"));
               bOK = bOK && (lret == ERROR_SUCCESS);
            }

         }  // end if controlling checkbox checked
         break;

      default:
         Assert(FALSE, TEXT("Unlisted .fValues value in Apply!\n"));
         break;
      }

      // close this key
      RegCloseKey(hKey);

   }

   // CLEANUP
   Assert(bOK, TEXT("didn't ApplySubkeys well\n"));
   return (bOK);
}

//
// DatumFileToRegister
//
// Like DatumRegisterToFile(), this is an atomic operation; in this
// case, move a single datum from theme file to the registry.
// Here, too, technique differs slightly between strings and numbers.
//
// Returns: BOOL success writing to registry
//
BOOL DatumFileToRegister(
HKEY hSetKey,
FROST_VALUE fvSet,
LPTSTR lpszFile,                     // full pathname for theme file
LPTSTR lpszKeyname,
BOOL bOKtoApplyNull)
{
   LONG lret;
   int iret;
   BOOL bOK = TRUE;

   //
   // get the saved string from the theme file
   iret = GetPrivateProfileString(lpszKeyname,
                                  (LPTSTR)fvSet.szValName,
                                  (LPTSTR)szNULL,
                                  (LPTSTR)pValue, MAX_VALUELEN, lpszFile);
   // no error case: can't tell difference between legit null string and default

   // If we're reading the TRASH ICON strings and we got a NULL return
   // then we should try using the "old" Win95 reg keys in case
   // this is an old .Theme file

   if ((!*pValue) &&
       (lstrcmpi(lpszKeyname, fsCUIcons[TRASH_INDEX].szSubKey) == 0)) {

      iret = GetPrivateProfileString((LPTSTR)(fsRoot[TRASH_INDEX].szSubKey),
                                     (LPTSTR)fvSet.szValName,
                                     (LPTSTR)szNULL,
                                     (LPTSTR)pValue,
                                     MAX_VALUELEN,
                                     lpszFile);
   }

   // not always OK to set null value to registry
   if (!bOKtoApplyNull && !(*pValue))
      return(TRUE);                 // no work to do EXIT

   // switch on value type to get how to write it 
   switch (fvSet.iValType) {

   case REG_SZ:

      // if this value is a relative path filename string,
      // first see about making abstract path into current instance
      if (fvSet.bValRelPath) {
         InstantiatePath((LPTSTR)pValue, MAX_VALUELEN);
         // look for and confirm finding the file, with replacement
         if (ConfirmFile((LPTSTR)pValue, TRUE) == CF_NOTFOUND) {
            *pValue = 0;      // if not found, just null out filename
            bOK = FALSE;      // couldn't apply this file!
         }
      }

      // If this is the Wallpaper setting and it's an .htm or .html
      // wallpaper we need to apply this via IActiveDesktop
      //

      if (lstrcmpi(fvSet.szValName, TEXT("Wallpaper")) == 0 && pValue && *pValue && 
          (lstrcmpi(FindExtension(pValue),TEXT(".htm")) == 0 ||
           lstrcmpi(FindExtension(pValue),TEXT(".html")) == 0)) {

        // First, clear the existing registry wallpaper setting.
        // Don't really care if this fails.
        lret = RegSetValueEx(hSetKey, fvSet.szValName,
                             0,
                             (DWORD)REG_SZ,
                             (LPBYTE)TEXT("\0"),
                             (DWORD)sizeof(TCHAR));

        // Now try applying the new wallpaper via ActiveDesktop SetWP.
        if (SetADWallpaper(pValue, TRUE /* Force AD on */)) {
           bOK = TRUE;
           *pValue = 0;
           bOKtoApplyNull = FALSE; // Don't want to set Wallpaper string to
                                   // NULL later on because it causes AD to
                                   // forget about the HTML wallpaper!!
        }
        else {
           // Setting the HTML wallpaper failed!
           bOK = FALSE;
           *pValue = 0;
        }
      }

      //
      // if we are applying a compressed image, lets decompress it first
      //
      // NOTE we can handle the out 'o disk case a little better
      //
      if (lstrcmpi(fvSet.szValName, TEXT("Wallpaper")) == 0 && pValue && *pValue &&
          lstrcmpi(FindExtension(pValue),TEXT(".bmp")) != 0 &&
          lstrcmpi(FindExtension(pValue),TEXT(".dib")) != 0 &&
          lstrcmpi(FindExtension(pValue),TEXT(".rle")) != 0 ) {

        TCHAR plus_bmp[MAX_PATH];

        if (g_hbmWall)
        {
            CacheDeleteBitmap(g_hbmWall);
            g_hbmWall = NULL;
        }

        g_hbmWall = LoadWallpaper(pValue, lpszFile, FALSE);
        Assert(g_hbmWall, TEXT("LoadWallpaper failed!\n"));

        if (g_hbmWall) {
            GetPlusBitmapName(plus_bmp);
            bOK = bOK && SaveImageToFile(g_hbmWall, plus_bmp, pValue);
            Assert(bOK, TEXT("unable to save wallpaper to plus!.bmp\n"));
        }
        else {
            bOK = FALSE;
        }

        if (bOK)
           lstrcpy(pValue, plus_bmp);
        else
           *pValue = 0;      // if not found, just null out filename
      }

      // not always OK to set null value to registry
      if (!bOKtoApplyNull && !(*pValue))        
         return(TRUE);                 // no work to do EXIT

      // just write the string to the registry
      lret = RegSetValueEx(hSetKey, fvSet.szValName,
                           0,
                           (DWORD)REG_SZ,
                           (LPBYTE)pValue,
                           (DWORD)SZSIZEINBYTES(pValue));

      bOK = bOK && (lret == ERROR_SUCCESS);

      // One last thing -- if this is the Wallpaper and
      // ActiveDesktop is on we need to use the ActiveDesktop
      // interface to set the wallpaper.  We do this because
      // we want this wallpaper setting in BOTH the registry
      // and the ActiveDesktop.  If you set a BMP wallpaper
      // via the registry w/out also doing it via the AD
      // interface it's possible for the AD/Non-AD desktops
      // to be out of sync on their wallpaper.
      //
      // Note this is the case where the wallpaper is not html.
      // Html wallpapers are set via the ActiveDesktop interface
      // above.

      if ((lstrcmpi(fvSet.szValName, TEXT("Wallpaper")) == 0) &&
          IsActiveDesktopOn()) {
         bOK = SetADWallpaper(pValue, FALSE);
      }

      Assert(bOK, TEXT("couldn't write a string value to registry!\n"));
      break;

   //
   // these two cases are both just treated as binary output
   case REG_DWORD:
   case REG_BINARY:

      bOK = WriteBytesToRegister(hSetKey, (LPTSTR)fvSet.szValName,
                                 fvSet.iValType,
                                 (LPTSTR)pValue);
      Assert(bOK, TEXT("couldn't write value bytes to registry.\n"));
      break;

   default:
      Assert(FALSE, TEXT("unexpected REG_* data type from our own tables!\n"));
      break;
   }

   // cleanup
   Assert(bOK, TEXT("missed a datum from register to file\n"));
   return (bOK);
}

//
// WriteBytesToRegister
//
// Parallel to WriteBytesToFile() function. This function takes an ASCII
// string of space-separated 0-255 numbers, translates them into byte
// number values packed into an output buffer, and then assigns that 
// binary data to the given key/valuename in the registry -- as the data
// type given.
//
// Note that lpByteStr points to the same pValue that we are using as
// an output buffer. This depends on the numbers compressing as they
// are translated from ASCII to binary. Uses an itermediary variable so 
// the first translation isn't messed up.
//
// ********************************************************************
// ASSUMPTIONS: You assume that noone has mucked with this theme file
// manually! In particular, this function depends on no leading blank
// and exactly one blank between each number in the string, and one
// trailing blank at the end followed by a null terminator.
// WHOOPS! BAD ASSUMPTION: trailing blank is stripped by Write/Get
// PrivateProfileString() functions! So need to watch for end manually.
// ********************************************************************
//
// Uses: writes binary data to global pValue[]
//
// Returns: success of write to register
BOOL WriteBytesToRegister(HKEY hKeySet, LPTSTR lpszValName,
                          int iType, LPTSTR lpszByteStr)
{
   BOOL bOK = TRUE;
   int iBytes;
   LONG lret;

   iBytes = WriteBytesToBuffer(lpszByteStr);

   // set binary data in register file with the right data type
   lret = RegSetValueEx(hKeySet, lpszValName,
                        0,
                        (DWORD)iType,
                        (LPBYTE)pValue,
                        (DWORD)iBytes);
   bOK = (lret == ERROR_SUCCESS);
   Assert(bOK, TEXT("couldn't write a string value to registry!\n"));

   //
   // cleanup
   return (bOK);
}

//
// Utility routine for above; takes ASCII string to binary in 
// global pValue[] buffer.
//
// Since the values this guy is manipulating is purely ASCII
// numerics we should be able to get away with this char pointer
// arithmetic.  If they were not simple ASCII numerics I think
// we could get into trouble with some DBCS chars
//
// Uses: writes binary data to global pValue[]
//
int FAR WriteBytesToBuffer(LPTSTR lpszInput)
{
   LPTSTR lpszCur, lpszNext, lpszEnd;
   BYTE *pbCur;
   int iTemp, iBytes;
#ifdef UNICODE
   CHAR szTempA[10];
#endif

   //
   // inits
   lpszNext = lpszInput;
   pbCur = (BYTE *)&pValue;
   iBytes = 0;
   lpszEnd = lpszInput + lstrlen(lpszInput);   // points to null term

   //
   // translating loop
   while (*lpszNext && (lpszNext < lpszEnd)) {

      //
      // update str pointers
      // hold onto your starting place
      lpszCur = lpszNext;
      // advance pointer to next and null terminate cur
      while ((TEXT(' ') != *lpszNext) && *lpszNext) { lpszNext++; }
      *lpszNext = 0;    lpszNext++;
      // on last number, this leaves lpszNext pointing past lpszEnd

      // translate this string-number into binary number and place in
      // output buffer.
#ifdef UNICODE
      wcstombs(szTempA, lpszCur, sizeof(szTempA));
      iTemp = latoi(szTempA);
#else // !UNICODE
      iTemp = latoi(lpszCur);
#endif
      *pbCur = (BYTE)iTemp;
      pbCur++;                      // incr byte loc in output buffer

      // keep track of your bytes
      iBytes++;
   }

   //
   // cleanup
   return (iBytes);
}


//
// Trash functions
//
// The registry holds three icons for the trash: full, empty, and default. 
// In theory default is always one of the full or empty, and it is the current
// state of the actual trash.
//
// These functions are to query the trash state:
//
// IsTrashFull    returns BOOL on full state
//
// and to apply the correct-state trash icon from 
// the theme file to the default/cur:
//
// ApplyCurrentTrash
//

#define szCUTrashKey      (fsCUIcons[TRASH_INDEX].szSubKey)
#define szRTrashKey       (fsRoot[TRASH_INDEX].szSubKey)
#define szEmptyTrashVal   TEXT("empty")
#define szFullTrashVal    TEXT("full")

BOOL IsTrashFull()
{
   TCHAR szEmpty[MAX_PATHLEN+1];
   TCHAR szDefault[MAX_PATHLEN+1];
   TCHAR szNTReg[MAX_PATH];

   // Get the two strings
   // First try the CURRENT_USER branch
   // Then try the CLASSES_ROOT branch

   if (IsPlatformNT())
   {
      lstrcpy(szNTReg, c_szSoftwareClassesFmt);
      lstrcat(szNTReg, szRTrashKey);
      szEmpty[0] = TEXT('\0');
      HandGet(HKEY_CURRENT_USER, szNTReg, szEmptyTrashVal, (LPTSTR)szEmpty);
      if (!*szEmpty) {
         // Didn't get a valid string from CURRENT_USER so try CLASSES_ROOT
         HandGet(HKEY_CLASSES_ROOT, szRTrashKey, szEmptyTrashVal, (LPTSTR)szEmpty);
      }

      szDefault[0] = TEXT('\0');
      HandGet(HKEY_CURRENT_USER, szNTReg, szNULL, (LPTSTR)szDefault);
      if (!*szDefault) {
         // Didn't get a valid string from CURRENT_USER so try CLASSES_ROOT
         HandGet(HKEY_CLASSES_ROOT, szRTrashKey, szNULL, (LPTSTR)szDefault);
      }
   }
   else  // Not NT
   {
      szEmpty[0] = TEXT('\0');
      HandGet(HKEY_CURRENT_USER, szCUTrashKey, szEmptyTrashVal, (LPTSTR)szEmpty);
      if (!*szEmpty) {
         // Didn't get a valid string from CURRENT_USER so try CLASSES_ROOT
         HandGet(HKEY_CLASSES_ROOT, szRTrashKey, szEmptyTrashVal, (LPTSTR)szEmpty);
      }

      szDefault[0] = TEXT('\0');
      HandGet(HKEY_CURRENT_USER, szCUTrashKey, szNULL, (LPTSTR)szDefault);
      if (!*szDefault) {
         // Didn't get a valid string from CURRENT_USER so try CLASSES_ROOT
         HandGet(HKEY_CLASSES_ROOT, szRTrashKey, szNULL, (LPTSTR)szDefault);
      }
   }

   // have to keep setting cursor to wait because someone resets it
   WaitCursor();

   // compare strings and return 
   return(lstrcmpi((LPTSTR)szEmpty, (LPTSTR)szDefault));
   // lstrcmpi rets 0 for equal strings; equal to empty means FALSE to full
}

BOOL ApplyCurrentTrash(BOOL bTrashFull, LPTSTR lpszFile)
{
   LONG lret;
   HKEY hKey;                       // cur open key
   TCHAR szNTReg[MAX_PATH];

   //
   // check first that we are even touching the icons
   if (!bCBStates[FC_ICONS])
      return (TRUE);                // no trash to apply EXIT

   // have to keep setting cursor to wait because someone resets it
   WaitCursor();

   // 
   // inits
   //lret = RegOpenKeyEx( HKEY_CLASSES_ROOT, (LPTSTR)szRTrashKey,
   //                     (DWORD)0, KEY_SET_VALUE, (PHKEY)&hKey );

   if (IsPlatformNT())
   {
      lstrcpy(szNTReg, c_szSoftwareClassesFmt);
      lstrcat(szNTReg, szRTrashKey);

      lret = RegOpenKeyEx( HKEY_CURRENT_USER, (LPTSTR)szNTReg,
                           (DWORD)0, KEY_SET_VALUE, (PHKEY)&hKey );
   }
   else // NOT NT
   {

      lret = RegOpenKeyEx( HKEY_CURRENT_USER, (LPTSTR)szCUTrashKey,
                           (DWORD)0, KEY_SET_VALUE, (PHKEY)&hKey );
   }

   if (lret != ERROR_SUCCESS) {
      Assert(FALSE, TEXT("problem on RegOpenKey CURRENT_USER in ApplyCurrentTrash\n"));
      return (FALSE);               // nothing else to do EXIT
   }

   // have to keep setting cursor to wait because someone resets it
   WaitCursor();

   // get the right trash icon file
   GetPrivateProfileString((LPTSTR)szCUTrashKey,
                           (LPTSTR)(bTrashFull ? szFullTrashVal : szEmptyTrashVal),
                           (LPTSTR)szNULL,
                           (LPTSTR)pValue, MAX_VALUELEN,
                           lpszFile);

   // If we didn't get the value it could be that we've got an old
   // Win95/Plus95 .Theme file.  Let's try reading the Theme file
   // using the Win95 reg key:

   if (!*pValue) {
      GetPrivateProfileString((LPTSTR)szRTrashKey,
                              (LPTSTR)(bTrashFull ? szFullTrashVal : szEmptyTrashVal),
                              (LPTSTR)szNULL,
                              (LPTSTR)pValue, MAX_VALUELEN,
                              lpszFile);
   }

   InstantiatePath((LPTSTR)pValue, MAX_VALUELEN);
   // look for and confirm finding the file, with replacement
   if (ConfirmFile((LPTSTR)pValue, TRUE) == CF_NOTFOUND) {
      *pValue = 0;      // if not found, just null out filename --> ret FALSE
   }

   if (!(*pValue)) {
      Assert(FALSE, TEXT("ApplyCurrentTrash came up with no file\n"));
      RegCloseKey(hKey);            // mini-cleanup
      return (FALSE);               // no usable icon file, so just EXIT and leave cur
   }

   // have to keep setting cursor to wait because someone resets it
   WaitCursor();

   // Do the deed
   lret = RegSetValueEx(hKey, (LPTSTR)szNULL, // sets default value
                        0,
                        (DWORD)REG_SZ,
                        (LPBYTE)pValue,
                        (DWORD)SZSIZEINBYTES(pValue));
   // have to keep setting cursor to wait because someone resets it
   WaitCursor();

   // cleanup and return
   RegCloseKey(hKey);
   Assert(lret == ERROR_SUCCESS, TEXT("bad return setting current trash\n"));
   return (ERROR_SUCCESS == lret);
}


//
// HandPumpSystem
//
// OK. You've applied all of the theme file settings to the registry.
// Congratulations. Now reboot! HA HA HA! No seriously, most of the
// settings don't take effect in the current system just by writing 
// them to the registry. You have to make each system change happen
// by hand. Hand pump it.
// 
// So here we try to get things actually changing in front of the 
// astonished user's eyes.
// Of course, assuming the checkbox to request it is checked.
//
// First, to be robustly certain that we are setting what is in the
// registry, actually read the value from the registry. Then use the
// random API for this element to set it.
//
// This is long and messy, the way it has to be. See design critique
// note at head of file.
//
// NOTE that SetSysColors() in SetSysColorsByHand() sends a
// WM_SYSCOLORCHANGE message. We also need to send a WM_SYSCOLORCHANGE 
// message if we change any of the metrics - since Excel and other apps 
// saw color/metric changes as unitary in 3.1 and would look for color.
// The extra BOOLs watching color and sys changes are to avoid sending
// two WM_SYSCOLORCHANGE messages.
//
// Uses: global bCBStates[] for checkbox states
//       global szCurThemeFile[], non-encapsulated uncool 
//              but this is the grody routine anyway
//
BOOL HandPumpSystem()
{
   BOOL bret, bOK = TRUE, bChangedSettings = FALSE;
   TCHAR szWinMetrics[] = TEXT("WindowMetrics");
   BOOL fClearAppearance = FALSE;
   BOOL bSaverIsNull = FALSE;
   HKEY hKey;
   LONG lret;
   DWORD dwDisposition;
   int screenSaverTimeout = 0;  // Screen saver timeout
   BOOL bSkipWP = FALSE;        // ActiveDesktop/HTML WP so skip HP WP
   TCHAR szADWP[MAX_PATH];      // Current/ActiveDesktop wallpaper setting

   // FC_SCRSVR 
   if (bCBStates[FC_SCRSVR]) {

      // have to keep setting cursor to wait because someone resets it
      WaitCursor();

      // Take a peek at the current SS setting.  If it's null we want to
      // force the timeout to 15 minutes iff current timeout is 1 minute
      // per Plus98 bug 1075.  The reason for doing this is because Win98
      // sets the timeout to 1 min by default -- so the first time a
      // SS is applied the timeout is very short.  Too short in some
      // people's opinion.  So we try to detect this one scenario and
      // make the timeout a little bit longer.

      GetPrivateProfileString((LPTSTR)szSS_Section, (LPTSTR)szSS_Key,
                              (LPTSTR)szNULL,
                              (LPTSTR)pValue, MAX_VALUELEN,
                              (LPTSTR)szSS_File);

      if (!*pValue) bSaverIsNull = TRUE;

      //
      // This one is different: Screen Saver is saved in SYSTEM.INI.

      #ifdef GENTLER
      // get the current value from SYSTEM.INI
      GetPrivateProfileString((LPTSTR)szSS_Section, (LPTSTR)szSS_Key,
                              (LPTSTR)szNULL,
                              (LPTSTR)szTemp, MAX_VALUELEN,
                              (LPTSTR)szSS_File);
      // now, with cur value as default, get value from theme file
      GetPrivateProfileString((LPTSTR)szSS_Section, (LPTSTR)szSS_Key,
                              (LPTSTR)szTemp,    // cur value is default
                              (LPTSTR)pValue, MAX_VALUELEN,
                              (LPTSTR)szCurThemeFile);
      #endif

      // get scr saver from theme
      GetPrivateProfileString((LPTSTR)szSS_Section, (LPTSTR)szSS_Key,
                              (LPTSTR)szNULL,    // NULL is default
                              (LPTSTR)pValue, MAX_VALUELEN,
                              (LPTSTR)szCurThemeFile);
      
      // next, translate path variable if necessary
      InstantiatePath((LPTSTR)pValue, MAX_VALUELEN);
      // look for and confirm finding the file, with replacement
      if (ConfirmFile((LPTSTR)pValue, TRUE) == CF_NOTFOUND) {
         *pValue = 0;               // if not found, just null out filename
         bOK = FALSE;               // couldn't apply this file!
      }
      else {                        // file's OK, so continue
         // now, MAKE SURE that you only write short filenames to old-fashioned system
         if (FilenameToShort((LPTSTR)pValue, (LPTSTR)szMsg))
            lstrcpy(FileFromPath((LPTSTR)pValue), (LPTSTR)szMsg);
      }

      // and finally, apply value from theme file (or NULL if not in theme)
      WritePrivateProfileString((LPTSTR)szSS_Section, (LPTSTR)szSS_Key,
                                (LPTSTR)pValue, (LPTSTR)szSS_File);

      // and make it live in the system
      SystemParametersInfo(SPI_SETSCREENSAVEACTIVE,
                           // set depending on whether scr saver in theme
                           // pValue still has scr saver name
                           (*pValue ? 1 : 0),
                           NULL, SPIF_SENDCHANGE | SPIF_UPDATEINIFILE);

      // Set screen saver timeout value
      if (!SystemParametersInfo(SPI_GETSCREENSAVETIMEOUT, 0, &screenSaverTimeout, 0))
      {
         screenSaverTimeout = 0;
      }

      // Plus 98 bug 1075 -- if current screensaver setting is NULL and
      // the timeout is 1 minute, then force timeout to default (15 mins).
      if (bSaverIsNull && (60 == screenSaverTimeout)) screenSaverTimeout = 0;

      if (*pValue && !screenSaverTimeout)
      {
            // There must be a screen saver timeout value, otherwise the system
            // assumes that there is no screen saver selected.
         SystemParametersInfo(SPI_SETSCREENSAVETIMEOUT, DEF_SCREENSAVETIMEOUT, NULL,
                              SPIF_SENDCHANGE | SPIF_UPDATEINIFILE);
      }
   }

   // have to keep setting cursor to wait because someone resets it
   WaitCursor();

   // FC_SOUND  
   // already in effect just by setting registry settings

   if (bCBStates[FC_SOUND]) {
      // but need to flush buffer and ensure new sounds used for next events
      sndPlaySound((LPTSTR)NULL, SND_ASYNC | SND_NODEFAULT);

      //
      // Clear the current pointer scheme string from the registry so that Mouse
      // cpl doesn't display a bogus name.  Don't care if this fails.
      RegSetValue(HKEY_CURRENT_USER, (LPTSTR) szCP_SoundSchemes, REG_SZ,
         TEXT(".current"), 0);
   }

   // have to keep setting cursor to wait because someone resets it
   WaitCursor();

   // FC_PTRS   
   if (bCBStates[FC_PTRS]) {
      SystemParametersInfo( SPI_SETCURSORS, 0, 0, SPIF_SENDCHANGE);

      //
      // Clear the current pointer scheme string from the registry so that Mouse
      // cpl doesn't display a bogus name.  Don't care if this fails.
      RegSetValue(HKEY_CURRENT_USER, (LPTSTR) szCP_Appearance, REG_SZ, szNULL, sizeof(TCHAR));
   }

   // have to keep setting cursor to wait because someone resets it
   WaitCursor();

   // FC_WALL   

   // If ActiveDesktop is on and we're using an html wallpaper
   // we don't want to do this hand pump stuff for the various
   // wallpaper settings

   bSkipWP = FALSE;      
   if (IsActiveDesktopOn()) {
      if (GetADWallpaper(szADWP)) {
         if (lstrcmpi(FindExtension(szADWP), TEXT(".htm")) == 0 ||
             lstrcmpi(FindExtension(szADWP), TEXT(".html")) == 0 ) {
             bSkipWP = TRUE;
         }
      } 
   }

   if ((bCBStates[FC_WALL]) && !bSkipWP) {
      //
      // TileWallpaper and WallpaperStyle done by hand here
      //

      lret = RegCreateKeyEx( HKEY_CURRENT_USER, (LPTSTR)szCP_DT,
                             (DWORD)0, (LPTSTR)szNULL, REG_OPTION_NON_VOLATILE,
                             KEY_SET_VALUE, (LPSECURITY_ATTRIBUTES)NULL,
                             (PHKEY)&hKey, (LPDWORD)&dwDisposition );
      if (lret != ERROR_SUCCESS) {
         Assert(FALSE, TEXT("problem on RegCreateKeyEx for CP Desktop in HandPump!\n"));
         bOK = FALSE;            // we are not happy campers
      }
      if (ERROR_SUCCESS == lret) {  // got an open key; set the two values

         // do TileWallpaper
         GetPrivateProfileString((LPTSTR)szCP_DT, (LPTSTR)szTileWP,
                                 (LPTSTR)szNULL,
                                 (LPTSTR)pValue, MAX_VALUELEN,
                                 (LPTSTR)szCurThemeFile);
         if (*pValue) {             // if in theme, set; else leave reg alone!
            lret = RegSetValueEx(hKey,
                                 (LPTSTR)szTileWP,
                                 0,
                                 (DWORD)REG_SZ,
                                 (LPBYTE)pValue,
                                 (DWORD)SZSIZEINBYTES(pValue));

            Assert(lret == ERROR_SUCCESS, TEXT("bad return setting szTileWP in HandPump!\n"));
            if (ERROR_SUCCESS != lret)
               bOK = FALSE;
         }

         // do WallpaperStyle
         GetPrivateProfileString((LPTSTR)szCP_DT, (LPTSTR)szWPStyle,
                                 (LPTSTR)szNULL,
                                 (LPTSTR)pValue, MAX_VALUELEN,
                                 (LPTSTR)szCurThemeFile);
         if (*pValue) {             // if in theme, set; else leave reg alone!
            lret = RegSetValueEx(hKey,
                                 (LPTSTR)szWPStyle,
                                 0,
                                 (DWORD)REG_SZ,
                                 (LPBYTE)pValue,
                                 (DWORD)SZSIZEINBYTES(pValue));

            Assert(lret == ERROR_SUCCESS, TEXT("bad return setting WPStyle in HandPump!\n"));
            if (ERROR_SUCCESS != lret)
               bOK = FALSE;
         }

         RegCloseKey(hKey);            // mini-cleanup
      }

      //
      // Wallpaper and Pattern are set in reg in ApplySubkeys.
      // Just make them live here
      //

      // get the Wallpaper reset in system

      bret = HandGet(HKEY_CURRENT_USER,
                     TEXT("Control Panel\\Desktop"),
                     TEXT("Wallpaper"),
                     (LPTSTR)pValue);

      SystemParametersInfo(SPI_SETDESKWALLPAPER, 0, pValue,
                           SPIF_SENDCHANGE);

      // get the Pattern reset in system

      bret = HandGet(HKEY_CURRENT_USER,
                     TEXT("Control Panel\\Desktop"),
                     TEXT("Pattern"),
                     (LPTSTR)pValue);

      SystemParametersInfo(SPI_SETDESKPATTERN, 0, pValue,
                           SPIF_SENDCHANGE);

      // PLUS! 98 Bug 896 -- when switching from an HTML wallpaper
      // to a BMP wallpaper the shell didn't update the WP if the
      // ICONS setting was not checked -- user had to press F5 to
      // refresh the desktop.  This fixes that problem.

      SHChangeNotify(SHCNE_ASSOCCHANGED, 0, NULL, NULL);

      // the rest of the wallpaper items seem to be read from registry as needed
      // "TileWallpaper"   
      // NIX: "WallpaperStyle"  
      // "WallPaperOriginX"
      // "WallPaperOriginY"
   }

   // have to keep setting cursor to wait because someone resets it
   WaitCursor();

   // FC_ICONS  
   // already done


   // FC_ICONSIZE and FC_FONTS are NO LONGER intertwined
//   if (bCBStates[FC_FONTS] || bCBStates[FC_ICONSIZE]) {
      // for icons, this is just for the spacing; size already done

   // FC_FONTS
   if (bCBStates[FC_FONTS]) {
      // for fonts, this is the icon fonts
      SetIconMetricsByHand(FALSE, bCBStates[FC_FONTS]);
      fClearAppearance = TRUE;
   }

   // have to keep setting cursor to wait because someone resets it
   WaitCursor();

   // FC_FONTS  and  FC_BORDERS  are intertwined
   if (bCBStates[FC_FONTS] || bCBStates[FC_BORDERS]) {
      SetNonClientMetricsByHand(bCBStates[FC_FONTS], bCBStates[FC_BORDERS]);
      bChangedSettings = TRUE;
      fClearAppearance = TRUE;
   }

   // have to keep setting cursor to wait because someone resets it
   WaitCursor();

   // FC_COLORS 
   if (bCBStates[FC_COLORS]) {
      bret = SetSysColorsByHand();
      //
      // THIS SENT A WM_SYSCOLORCHANGE MESSAGE
      //

      bOK = bOK && bret;
      fClearAppearance = TRUE;
   }
   else if (bChangedSettings)       // may need to send color msg anyway
      // for Win3.1 app compatibility, need to say COLOR changed if any metrics changed
      PostMessage(HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0);
      // Changed SendMessage to PostMessage to get around Plus! Setup bug


   //
   // cleanup

   // have to keep setting cursor to wait because someone resets it
   WaitCursor();

   // let the world know you've mucked with it all
   if (bChangedSettings)
      SendMessage(HWND_BROADCAST, WM_SETTINGCHANGE,
                  SPI_SETNONCLIENTMETRICS, (LPARAM)(LPTSTR)szWinMetrics);

   // have to keep setting cursor to wait because someone resets it
   WaitCursor();

//   if (bCBStates[FC_ICONS] || bCBStates[FC_ICONSIZE]) {
   if (bCBStates[FC_ICONS]) {
      SHChangeNotify(SHCNE_ASSOCCHANGED, 0, NULL, NULL); // should do the trick!
      SendMessage(HWND_BROADCAST, WM_SETTINGCHANGE,
                  SPI_SETICONMETRICS, (LPARAM)(LPTSTR)szWinMetrics);
   }

   if (fClearAppearance) {
      //
      // Clear the current appearance string from the registry so that Display cpl
      // doesn't display a bogus name.  Don't care if this fails.
      if (RegOpenKeyEx(HKEY_CURRENT_USER, (LPTSTR)szCP_Appearance, (DWORD)0,
                       KEY_SET_VALUE, (PHKEY)&hKey ) == ERROR_SUCCESS) {
          RegDeleteValue(hKey, szCurrent);
          RegCloseKey(hKey);
      }
   }

   return (bOK);
}

//
// HandGet
//
// Just a little helper routine, gets an individual string value from the 
// registry and returns it to the caller. Takes care of registry headaches,
// including a paranoid length check before getting the string.
//
// NOTE that this function thinks it's getting a string value. If it's
// another kind, this function will do OK: but the caller may be surprised
// if expecting a string.
//
// Returns: success of string retrieval
//
BOOL FAR HandGet(HKEY hKeyRoot, LPTSTR lpszSubKey, LPTSTR lpszValName, LPTSTR lpszRet)
{
   LONG lret;
   HKEY hKey;                       // cur open key
   BOOL bOK = TRUE;
   DWORD dwSize;
   DWORD dwType;

   //
   // inits
   // get subkey
   lret = RegOpenKeyEx( hKeyRoot, lpszSubKey,
                        (DWORD)0, KEY_QUERY_VALUE, (PHKEY)&hKey );
   if (lret != ERROR_SUCCESS) {
      Assert(FALSE, TEXT("problem on RegOpenKey in HandGet\n"));
      return (FALSE);
   }

   // now do our paranoid check of data size
   lret = RegQueryValueEx(hKey, lpszValName,
                           (LPDWORD)NULL,
                           (LPDWORD)&dwType,
                           (LPBYTE)NULL,  // null for size info only
                           (LPDWORD)&dwSize );

   if (ERROR_SUCCESS == lret) {     // saw something there

      // here's the size check before getting the data
      if (dwSize > (DWORD)(MAX_VALUELEN * sizeof(TCHAR))) { // if string too big
         Assert(FALSE, TEXT("Humongous registry string; can't HandGet...\n"));
         bOK = FALSE;               // can't read, so very bad news
         bReadOK = FALSE;
      }
      else {                        // size is OK to continue
         // now really get the value
         lret = RegQueryValueEx(hKey, lpszValName,
                                 (LPDWORD)NULL,
                                 (LPDWORD)&dwType,
                                 (LPBYTE)lpszRet, // getting actual value
                                 (LPDWORD)&dwSize);

         // If this is an EXPAND_SZ we need to expand it...
         if (REG_EXPAND_SZ == dwType) ExpandSZ(lpszRet);

         Assert(lret == ERROR_SUCCESS, TEXT("bad return HandGet query\n"));
         Assert(((dwType == (DWORD)REG_SZ) || (dwType == (DWORD)REG_EXPAND_SZ)), TEXT("non-string type in HandGet!\n"));

         if (ERROR_SUCCESS != lret) bOK = FALSE;
      }
   }
   else bOK = FALSE;

   //
   // cleanup
   // close subkey
   RegCloseKey(hKey);

   return (bOK);
}


//
// Gather/SetSysColorsByHand
//
// Colors would seem to be the prototypical setting, that we could just
// read and write directly in the registry. But noooooooo.....
// A. On initial install, somehow the color settings all remain blank.
// B. Need to use SetSysColor() anyway to broadcast message.
//
// So on both read and write, need to use Get/SetSysColor. On write, still
// also need to write directly to registry.
//

//
// Uses GetSysColor() rather than reading directly from the Registry.
// Writes to theme file.
//
BOOL GatherSysColorsByHand(LPTSTR lpszTheme)
{
   int iColor;
   COLORREF crRGB;
   BOOL bRet, bOK = TRUE;
   BOOL bGrad = FALSE;    // Are gradient titles enabled?

   // init bGrad
   SystemParametersInfo(SPI_GETGRADIENTCAPTIONS, 0, (LPVOID)&bGrad, 0);

   // 
   // inits
   Assert ((sizeof(iSysColorIndices)/sizeof(int)) == (sizeof(pRegColors)/sizeof(TCHAR *)),
           TEXT("mismatched color arrays in GatherSysColorsByHand\n"));

   //
   // main process

   // go through each color in your array
   for (iColor = 0; iColor < (sizeof(pRegColors)/sizeof(TCHAR *)); iColor ++) {

      // If this is the Gradient Caption setting and the system does
      // not currently show gradient captions then don't write them out
      // to the theme file.
      //
      // bGrad == Are gradient captions currently enabled?
      // g_bGradient == Enough colors to show gradients?

      if (((COLOR_GRADIENTACTIVECAPTION == iSysColorIndices[iColor]) ||
           (COLOR_GRADIENTINACTIVECAPTION == iSysColorIndices[iColor])) &&
          (!(bGrad && g_bGradient))) continue;

      // get the system color
      crRGB = GetSysColor(iSysColorIndices[iColor]);
      // ASSUME THAT YOU NEVER GET A BOGUS VALUE FROM THIS FUNCTION!!

      // translate to a string
      ColorToRGBString((LPTSTR)szMsg, crRGB);

      // write to theme file
      bRet = WritePrivateProfileString((LPTSTR)szCP_Clr, (LPTSTR)(pRegColors[iColor]),
                                       (LPTSTR)szMsg, lpszTheme);
      if (!bRet) bOK = FALSE;
   }

   // cleanup
   if (!bOK) bWroteOK = FALSE;
   return (bOK);
}

//
// Reads from the theme and writes to the Registry.
// At the same time, does the grody SetSysColor thing:
// creates an array to set up the call. Makes the call.
//
BOOL SetSysColorsByHand()
{
   LONG lret;
   HKEY hKey;                       // cur open key
   BOOL bOK = TRUE;
   COLORREF crSet[(sizeof(iSysColorIndices)/sizeof(int))];
   int iColor;
   DWORD dwDisposition;

   //
   // inits
   Assert ((sizeof(iSysColorIndices)/sizeof(int)) == (sizeof(pRegColors)/sizeof(TCHAR *)),
           TEXT("mismatched color arrays in SetSysColorsByHand\n"));

   // have to keep setting cursor to wait because someone resets it
   WaitCursor();
      
      // Open the color key if it exists, otherwise create it.
   lret = RegCreateKeyEx( HKEY_CURRENT_USER, (LPTSTR)szCP_Clr,
                        (DWORD)0, (LPTSTR)szNULL, REG_OPTION_NON_VOLATILE, 
                        KEY_SET_VALUE, NULL, (PHKEY)&hKey, (LPDWORD)&dwDisposition );

   if (lret != ERROR_SUCCESS) {
      Assert(FALSE, TEXT("problem on RegOpenKey in SetSysColorsByHand\n"));
      return (FALSE);
   }

   //
   // main process

   // go through each color valuename in your array
   for (iColor = 0; iColor < (sizeof(pRegColors)/sizeof(TCHAR *)); iColor ++) {

      // get color string from theme file 
      GetPrivateProfileString((LPTSTR)szCP_Clr, (LPTSTR)(pRegColors[iColor]),
                              (LPTSTR)szNULL,
                              (LPTSTR)pValue, MAX_VALUELEN,
                              (LPTSTR)szCurThemeFile);

      // If this is one of the Gradient Title bar settings and the setting
      // doesn't exist in the Theme file, read the non-gradient title setting
      // instead.

      if ((iColor == INDEX_GRADIENTACTIVE) && !*pValue) {
         GetPrivateProfileString((LPTSTR)szCP_Clr,
                                 (LPTSTR)(pRegColors[INDEX_ACTIVE]),
                                 (LPTSTR)szNULL,
                                 (LPTSTR)pValue, MAX_VALUELEN,
                                 (LPTSTR)szCurThemeFile);
      }

      if ((iColor == INDEX_GRADIENTINACTIVE) && !*pValue) {
         GetPrivateProfileString((LPTSTR)szCP_Clr,
                                 (LPTSTR)(pRegColors[INDEX_INACTIVE]),
                                 (LPTSTR)szNULL,
                                 (LPTSTR)pValue, MAX_VALUELEN,
                                 (LPTSTR)szCurThemeFile);
      }

      if (!(*pValue)) {
         // if nothing in theme, use cur sys colors
         crSet[iColor] = GetSysColor(iSysColorIndices[iColor]);
         continue;                  // null color value CONTINUE
      }

      // set color to Registry
      lret = RegSetValueEx(hKey, (LPTSTR)(pRegColors[iColor]),
                           0,
                           (DWORD)REG_SZ,
                           (LPBYTE)pValue,
                           (DWORD)SZSIZEINBYTES(pValue));
      Assert(lret == ERROR_SUCCESS, TEXT("bad return SetSysColorsByHand query\n"));
      if (ERROR_SUCCESS != lret)
         bOK = FALSE;

      // OK, you've got a str version of a COLOR.
      // Translate string and add to COLORREF array.
      crSet[iColor] = RGBStringToColor((LPTSTR)pValue);
   }

   //
   // There. You've finally got an array of color RGB values. Apply liberally.

   SystemParametersInfo(SPI_SETGRADIENTCAPTIONS, 0, IntToPtr(g_bGradient), SPIF_UPDATEINIFILE);
   SetSysColors((sizeof(iSysColorIndices)/sizeof(int)), iSysColorIndices, crSet);

   //
   // Cleanup
   RegCloseKey(hKey);
   return (bOK);
}


//
// RGB to String to RGB utilities.
//
COLORREF FAR RGBStringToColor(LPTSTR lpszRGB)
{
   LPTSTR lpszCur, lpszNext;
   BYTE bRed, bGreen, bBlue;
#ifdef UNICODE
   CHAR szTempA[10];
#endif

   // inits
   lpszNext = lpszRGB;

   // set up R for translation
   lpszCur = lpszNext;
   while ((TEXT(' ') != *lpszNext) && *lpszNext) { lpszNext++; }
   *lpszNext = 0;    lpszNext++;
   // get Red
#ifdef UNICODE
   wcstombs(szTempA, (wchar_t *)lpszCur, sizeof(szTempA));
   bRed = (BYTE)latoi(szTempA);
#else // !UNICODE
   bRed = (BYTE)latoi(lpszCur);
#endif
   // set up G for translation
   lpszCur = lpszNext;
   while ((TEXT(' ') != *lpszNext) && *lpszNext) { lpszNext++; }
   *lpszNext = 0;    lpszNext++;
   // get Green
#ifdef UNICODE
   wcstombs(szTempA, (wchar_t *)lpszCur, sizeof(szTempA));
   bGreen = (BYTE)latoi(szTempA);
#else // !UNICODE
   bGreen = (BYTE)latoi(lpszCur);
#endif
   // set up B for translation
   lpszCur = lpszNext;
   while ((TEXT(' ') != *lpszNext) && *lpszNext) { lpszNext++; }
   *lpszNext = 0;    lpszNext++;
   // get Blue
#ifdef UNICODE
   wcstombs(szTempA, (wchar_t *)lpszCur, sizeof(szTempA));
   bBlue = (BYTE)latoi(szTempA);
#else // !UNICODE
   bBlue = (BYTE)latoi(lpszCur);
#endif

   // OK, now combine them all for the big finish.....!
   return(RGB(bRed, bGreen, bBlue));
}

void FAR ColorToRGBString(LPTSTR lpszRet, COLORREF crColor)
{
   int iTemp;
   TCHAR szTemp[12];
#ifdef UNICODE
   CHAR szTempA[10];
#endif

   // first do R value
   iTemp = (int) GetRValue(crColor);
#ifdef UNICODE
   litoa(iTemp, szTempA);
   mbstowcs(lpszRet, szTempA, sizeof(szTempA));
#else // !UNICODE
   litoa(iTemp, lpszRet);
#endif

   // add on G value
   lstrcat(lpszRet, TEXT(" "));
   iTemp = (int) GetGValue(crColor);
#ifdef UNICODE
   litoa(iTemp, szTempA);
   mbstowcs(szTemp, szTempA, sizeof(szTempA));
#else // !UNICODE
   litoa(iTemp, szTemp);
#endif
   lstrcat(lpszRet, (LPTSTR)szTemp);

   // add on B value
   lstrcat(lpszRet, TEXT(" "));
   iTemp = (int) GetBValue(crColor);
#ifdef UNICODE
   litoa(iTemp, szTempA);
   mbstowcs(szTemp, szTempA, sizeof(szTempA));
#else // !UNICODE
   litoa(iTemp, szTemp);
#endif
   lstrcat(lpszRet, (LPTSTR)szTemp);

   // OK, you're done now
}

BOOL GatherWallpaperBitsByHand(LPTSTR lpszTheme)
{
   BOOL bret, bOK = TRUE;

   // save TileWallpaper 
   bret = HandGet(HKEY_CURRENT_USER, (LPTSTR)szCP_DT, (LPTSTR)szTileWP,(LPTSTR)pValue);
   Assert(bret, TEXT("couldn't get WallpaperStyle from Registry!\n"));
   bOK = bOK && bret;
   bret = WritePrivateProfileString((LPTSTR)szCP_DT, (LPTSTR)szTileWP,
                                    // only store if got something, else null
                                    (LPTSTR)(bret ? pValue : szNULL),
                                    lpszTheme);
   bOK = bOK && bret;
   if (!bret) bWroteOK = FALSE;

   // save Wallpaper Style
   bret = HandGet(HKEY_CURRENT_USER, (LPTSTR)szCP_DT, (LPTSTR)szWPStyle, (LPTSTR)pValue);
   Assert(bret, TEXT("couldn't get WallpaperStyle from Registry!\n"));
   bOK = bOK && bret;
   bret = WritePrivateProfileString((LPTSTR)szCP_DT, (LPTSTR)szWPStyle,
                                    // only store if got something, else null
                                    (LPTSTR)(bret ? pValue : szNULL),
                                    lpszTheme);
   bOK = bOK && bret;
   if (!bret) bWroteOK = FALSE;

   return (bOK);
}


//
// *Path
//
// These routines help to make themes transportable between computers.
// The problem is that the registry keeps filenames for the various
// theme elements and, of course, these are hard-coded paths that vary
// from machine to machine.
//
// The way we work around this problem is by storing filenames in the
// theme file as _relative_ paths: relative to the theme file directory
// or the Windows directory. (Actually, these routines are set up to
// be relative to any number of directories.) When saving a filename to
// a theme, we check to see if any relative paths can be abstracted out.
// When retrieving a filename from a theme, we take the abstract placeholder
// and replace it with the current sessions instances.

// these must parallel each other. abstract strs must start with %
TCHAR *szAbstractDirs[] = {szThemeDir,     szWinDir,   szWinDir};
TCHAR *szAbstractStrs[] = {TEXT("%ThemeDir%"),   TEXT("%WinDir%"),  TEXT("%SystemRoot%")};

// AbstractPath (see header above)
//
// Takes actual full path/filename and takes out a leading substring
// that matches any of the paths to abstract, if any.
//
// lpszPath    both input and output; assumes it's huge
//
VOID AbstractPath(LPTSTR lpszPath, int imax)
{
   int iter, iAbstrDirLen;
   TCHAR szTemp[MAX_PATHLEN+1];

   // check easy out first
   if (!lpszPath[0])
      return;                       // easy out, nothing to change EXIT

   // paranoid init
   szTemp[MAX_PATHLEN] = 0;

   // look for each of the path prefixes we care about in the given string
   for (iter = 0; iter < (sizeof(szAbstractDirs)/sizeof(TCHAR *)); iter++ ) {

      // inits
      iAbstrDirLen = lstrlen((LPTSTR)(szAbstractDirs[iter]));

      // get beginning of passed path string 
      lstrcpyn((LPTSTR)szTemp, lpszPath, 
      // ********************************
      // LSTRCPYN issue: doc says that N specifies number of chars, not
      // including the terminating null char. Behavior seems to include
      // the null char, so I add one here. If the Win libs are modified
      // to match their doc, then this will become a bug.
      // ********************************
               iAbstrDirLen + 1);

      // compare to path prefix to abstract
      if (!lstrcmpi((LPTSTR)szTemp, (LPTSTR)(szAbstractDirs[iter]))) {
         // 
         // GOT A MATCH: now do the substitution
         lstrcpy((LPTSTR)szTemp,
                 (LPTSTR)(szAbstractStrs[iter]));      // start w/ abstract key
         lstrcat((LPTSTR)szTemp,
                 (LPTSTR)(lpszPath + iAbstrDirLen));   // rest of path
         lstrcpy(lpszPath, (LPTSTR)szTemp);   // copy the result to ret str

         // now get out
         return;                    // got yer result now EXIT
      }
   }

   // if you didn't get a match, then you're just returning the same path str
}


// InstantiatePath (see header above)
//
// Takes theme file's version of path/filename and looks for leading abstraction
// string that matches any of the known abstractions, replacing it with
// current system's equivalent if found.
//
// lpszPath    both input and output; assumes it's huge
//
VOID FAR InstantiatePath(LPTSTR lpszPath, int imax)
{
   int iter, iAbstrStrLen;
   TCHAR szTemp[MAX_PATHLEN+1];

   // easy outs
   if ((TEXT('%') != lpszPath[0]) || !lpszPath[0])
      return;                       // easy out, nothing to change EXIT

   // paranoid init
   szTemp[MAX_PATHLEN] = 0;

   // look for each of the possible abstraction prefixes in the given string
   for (iter = 0; iter < (sizeof(szAbstractStrs)/sizeof(TCHAR *)); iter++ ) {

      // inits
      iAbstrStrLen = lstrlen((LPTSTR)(szAbstractStrs[iter]));

      // get beginning of passed path string 
      lstrcpyn((LPTSTR)szTemp, lpszPath,
      // ********************************
      // LSTRCPYN issue: doc says that N specifies number of chars, not
      // including the terminating null char. Behavior seems to include
      // the null char, so I add one here. If the Win libs are modified
      // to match their doc, then this will become a bug.
      // ********************************
               iAbstrStrLen + 1);

      // compare to this abstraction key string
      if (!lstrcmpi((LPTSTR)szTemp, (LPTSTR)(szAbstractStrs[iter]))) {
         // 
         // GOT A MATCH: now do the substitution
         lstrcpy((LPTSTR)szTemp,
                 (LPTSTR)(szAbstractDirs[iter]));      // actual path prefix

         // Avoid the double backslash problem

         if (lpszPath[iAbstrStrLen] == TEXT('\\')) iAbstrStrLen++;

         lstrcat((LPTSTR)szTemp,
                 (LPTSTR)(lpszPath + iAbstrStrLen));   // rest of path
         lstrcpy(lpszPath, (LPTSTR)szTemp);   // copy the result to ret str

         // now get out
         return;                    // got yer result now EXIT
      }
   }

   // On NT there is one more abstraction we need to worry about but
   // we can't add it to the array of abstraction strings -- doing
   // so would cause us to write it out to Theme files which would
   // make the theme files not backward compatible.
   //
   //    %SystemDrive%
   //

   if (IsPlatformNT())
   {

      // inits
      iAbstrStrLen = lstrlen((LPTSTR)(TEXT("%SystemDrive%")));

      // get beginning of passed path string 
      lstrcpyn((LPTSTR)szTemp, lpszPath,
      // ********************************
      // LSTRCPYN issue: doc says that N specifies number of chars, not
      // including the terminating null char. Behavior seems to include
      // the null char, so I add one here. If the Win libs are modified
      // to match their doc, then this will become a bug.
      // ********************************
               iAbstrStrLen + 1);

      // compare to this abstraction key string
      if (!lstrcmpi((LPTSTR)szTemp, (LPTSTR)(TEXT("%SystemDrive%")))) {
         // 
         // GOT A MATCH: now do the substitution
         szTemp[0] = szWinDir[0]; // drive letter 'C'
         szTemp[1] = szWinDir[1]; // colon        ':'
         szTemp[2] = TEXT('\0');  // null

         lstrcat((LPTSTR)szTemp,
                 (LPTSTR)(lpszPath + iAbstrStrLen));   // rest of path
         lstrcpy(lpszPath, (LPTSTR)szTemp);   // copy the result to ret str

         // now get out
         return;                    // got yer result now EXIT
      }
   }

   // if you didn't get a match, then you're just returning the same path str
}

//
// ConfirmFile
//
// This function does the "smart" file searching that's supposed to be
// built into each resource file reference in applying themes.
//
// First see if the full pathname + file given actually exists.
// If it does not, then try looking for the same filename (stripped from path)
// in other standard directories, in this order:
//    Current Theme file directory
//    Theme switcher THEMES subdirectory
//    Windows directory
//    Windows/MEDIA directory
//    Windows/CURSORS directory
//    Windows/SYSTEM directory
//
// Input: LPTSTR lpszPath     full pathname 
//        BOOL  bUpdate       whether to alter the filename string with found file
// Returns: int flag telling if and how file has been confirmed
//              CF_EXISTS   pathname passed in was actual file
//              CF_FOUND    file did not exist, but found same filename elsewhere
//              CF_NOTFOUND file did not exist, could not find elsewhere
//          
int FAR ConfirmFile(LPTSTR lpszPath, BOOL bUpdate)
{
   TCHAR szWork[MAX_PATHLEN+1];
   TCHAR szTest[MAX_PATHLEN+1];
   int iret = CF_NOTFOUND;          // default value
   LPTSTR lpFile;
   LPTSTR lpNumber;
   HANDLE hTest;

   // special case easy return: if it's null, then trivially satisfied.
   if (!*lpszPath) return (CF_EXISTS);  // NO WORK EXIT

   //
   // Inits

   // copy pathname to a work string for the function
   lstrcpy((LPTSTR)szWork, lpszPath);

   // input can be of the form foo.dll,13. need to strip off that comma,#
   // but hold onto it to put back at the end if we change the pathname
   lpNumber = FindChar(szWork, TEXT(','));
   if (*lpNumber) {                 // if there is a comma
      lpFile = lpNumber;            // temp
      lpNumber = CharNext(lpNumber);// hold onto number
      *lpFile = 0;
   }

   //
   // Do the checks

   // *** first check if the given file just exists as is
   hTest = CreateFile(szWork, GENERIC_READ, FILE_SHARE_READ,
                      (LPSECURITY_ATTRIBUTES)NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
   if (hTest != INVALID_HANDLE_VALUE) {   // success
      iret = CF_EXISTS;             // assign ret value
      // don't need to worry about bUpdate: found with input string
   }

   // otherwise, let's go searching for the same filename in other dirs
   else {
      Assert(FALSE, TEXT("had to go looking for "));
      Assert(FALSE, szWork);
      Assert(FALSE, TEXT("....\n"));

      // get ptr to the filename separated from the path
      lpFile = FileFromPath(szWork);

      // *** try the cur theme file dir
      lstrcpy((LPTSTR)szTest, (LPTSTR)szCurDir);
      lstrcat((LPTSTR)szTest, lpFile);
      hTest = CreateFile((LPTSTR)szTest, GENERIC_READ, FILE_SHARE_READ,
                         (LPSECURITY_ATTRIBUTES)NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
      if (hTest != INVALID_HANDLE_VALUE) {   // success
         iret = CF_FOUND;           // assign ret value
         Assert(FALSE, TEXT("   OK, found it in cur theme file dir\n"));
      }

      // *** otherwise try the Theme switcher THEMES subdirectory
      else  {
         lstrcpy((LPTSTR)szTest, (LPTSTR)szThemeDir);
         lstrcat((LPTSTR)szTest, lpFile);
         hTest = CreateFile((LPTSTR)szTest, GENERIC_READ, FILE_SHARE_READ,
                            (LPSECURITY_ATTRIBUTES)NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
         if (hTest != INVALID_HANDLE_VALUE) {   // success
            iret = CF_FOUND;           // assign ret value
            Assert(FALSE, TEXT("   OK, found it in themes directory\n"));
         }

         // *** otherwise try the win dir
         else {
            lstrcpy((LPTSTR)szTest, (LPTSTR)szWinDir);
            lstrcat((LPTSTR)szTest, lpFile);
            hTest = CreateFile((LPTSTR)szTest, GENERIC_READ, FILE_SHARE_READ,
                               (LPSECURITY_ATTRIBUTES)NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
            if (hTest != INVALID_HANDLE_VALUE) {   // success
               iret = CF_FOUND;           // assign ret value
               Assert(FALSE, TEXT("   OK, found it in windows directory\n"));
            }

            // *** otherwise try the win/media dir
            else {
               // can get this one directly from Registry
               HandGet(HKEY_LOCAL_MACHINE,
                       TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion"),
                       TEXT("MediaPath"), (LPTSTR)szTest);
               
               #ifdef THEYREMOVEREGSETTING
               lstrcpy((LPTSTR)szTest, (LPTSTR)szWinDir);
               lstrcat((LPTSTR)szTest, TEXT("Media\\"));
               #endif
               
               lstrcat((LPTSTR)szTest, TEXT("\\"));
               lstrcat((LPTSTR)szTest, lpFile);

               hTest = CreateFile((LPTSTR)szTest, GENERIC_READ, FILE_SHARE_READ,
                                 (LPSECURITY_ATTRIBUTES)NULL,
                                 OPEN_EXISTING,
                                 FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
               if (hTest != INVALID_HANDLE_VALUE) {   // success
                  iret = CF_FOUND;           // assign ret value
                  Assert(FALSE, TEXT("   OK, found it in windows media directory\n"));
               }

               // *** otherwise try the win/cursors dir
               else {
                  lstrcpy((LPTSTR)szTest, (LPTSTR)szWinDir);
                  lstrcat((LPTSTR)szTest, TEXT("CURSORS\\"));
                  lstrcat((LPTSTR)szTest, lpFile);
                  hTest = CreateFile((LPTSTR)szTest, GENERIC_READ, FILE_SHARE_READ,
                                    (LPSECURITY_ATTRIBUTES)NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
                  if (hTest != INVALID_HANDLE_VALUE) {   // success
                     iret = CF_FOUND;           // assign ret value
                     Assert(FALSE, TEXT("   OK, found it in windows cursors directory\n"));
                  }
                  // *** otherwise try the win/system dir
                  else {
                     lstrcpy((LPTSTR)szTest, (LPTSTR)szWinDir);
                     lstrcat((LPTSTR)szTest, TEXT("SYSTEM\\"));
                     lstrcat((LPTSTR)szTest, lpFile);
                     hTest = CreateFile((LPTSTR)szTest, GENERIC_READ, FILE_SHARE_READ,
                                       (LPSECURITY_ATTRIBUTES)NULL,
                                       OPEN_EXISTING,
                                       FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
                     if (hTest != INVALID_HANDLE_VALUE) {   // success
                        iret = CF_FOUND;           // assign ret value
                        Assert(FALSE, TEXT("   OK, found it in windows system directory\n"));
                     }
                     // *** otherwise try the win/system32 dir
                     else {
                        lstrcpy((LPTSTR)szTest, (LPTSTR)szWinDir);
                        lstrcat((LPTSTR)szTest, TEXT("SYSTEM32\\"));
                        lstrcat((LPTSTR)szTest, lpFile);

                        hTest = CreateFile((LPTSTR)szTest, GENERIC_READ, FILE_SHARE_READ,
                                          (LPSECURITY_ATTRIBUTES)NULL,
                                          OPEN_EXISTING,
                                          FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
                        if (hTest != INVALID_HANDLE_VALUE) {   // success
                           iret = CF_FOUND;           // assign ret value
                           Assert(FALSE, TEXT("   OK, found it in windows system32 directory\n"));
                        }
                     }
                  }
               }
            }
         }
      }

      // if found anywhere other than orig, copy found path/str as requested
      if ((iret == CF_FOUND) && bUpdate) {
         lstrcpy(lpszPath, (LPTSTR)szTest);
         // if we stripped off a number, let's add it back on
         if (*lpNumber) {
            lstrcat(lpszPath, TEXT(","));
            lstrcat(lpszPath, lpNumber);
         }
      }  // endif found file by searching
   }

   // cleanup
   Assert(iret != CF_NOTFOUND, TEXT("   But never found it!\n"));
   if (iret != CF_NOTFOUND)
      CloseHandle(hTest);           // close file if opened
   return (iret);
}



#ifdef ACTUALLY_DOING_THIS
//
// SetCheckboxesFromThemeFile
//
// After a new theme is selected from the listbox, you have to update
// the checkboxes in the main dlg window: 
//    uncheck and disable those that are not used in the theme
//    check and enable those that are used in the theme
// 
// Some of the checkboxes will always be enabled.
// Some of the checkboxes require a check of a sequence of settings
// (e.g. the sound events) and enabling iff any of them are used.
//
void FAR SetCheckboxesFromThemeFile(LPTSTR lpszFilename)
{

}


//
// SetCheckboxesFromRegistry
//
// Similar to SetCheckboxesFromThemeFile(), but for the case of
// "Current Windows settings" there is no file -- you just query
// the cur registry to get all the same values.
//
void FAR SetCheckboxesFromRegistry()
{

}
#endif


//
// CheckSpace
//
// Checks if there is enough space on drive to apply theme file.
//

BOOL FAR CheckSpace (HWND hWnd, BOOL fComplain)
{
      // 
      // Step 1.  Calculate Worst case Space needed
      //

      //  4 48 x 48 hicolor icons (10K each worst case) + (10K theme file) + padding
      //  Multiple by 2 for Prev and Curr Themes
   #define FUDGE_SIZE   (2L << 16)

   HDC               hdc;
   ULONG             cHorz;
   ULONG             cVert;
   ULONG             cPlanes;
   ULONG             cBPP;
   ULONG             fFlags;
   ULONG             cbNeeded;
   ULONG             cPalSize;
   ULONG             cColorDepth;
   TCHAR             szTemp[MAX_MSGLEN+1];
   TCHAR             szMsg[MAX_MSGLEN+1];
   HANDLE            hFile;
   WIN32_FIND_DATA   fd;
   TCHAR             chDrive;
   TCHAR             szDrive[4];
   ULONG             ckNeeded;
   ULONG             cbAvail;
   DWORD             csCluster;
   DWORD             cbSector;
   DWORD             ccFree;
   DWORD             ccTotal;

   hdc = GetDC (HWND_DESKTOP);
   
   cHorz       = GetDeviceCaps (hdc, HORZRES);
   cVert       = GetDeviceCaps (hdc, VERTRES);
   cPlanes     = GetDeviceCaps (hdc, PLANES);
   cBPP        = GetDeviceCaps (hdc, BITSPIXEL);
   fFlags      = GetDeviceCaps (hdc, RASTERCAPS);
   cPalSize    = 3L;
   cColorDepth = cPlanes * cBPP;

   if ((fFlags & RC_PALETTE) == RC_PALETTE)
      {
      cPalSize = GetDeviceCaps (hdc, SIZEPALETTE);
      }

   ReleaseDC (HWND_DESKTOP, hdc);

      // Get Worst case size of Plus! bitmap
   cbNeeded = (cHorz * cVert * cColorDepth)/8L;

      // Add in Bitmap File Header
   cbNeeded += sizeof (BITMAPFILEHEADER);

      // Add in Bitmap Info Header 
   cbNeeded += sizeof (BITMAPINFOHEADER);

      // Add in worst case palette size
   cbNeeded += sizeof (RGBQUAD) * cPalSize;

      // Add in Fudge factor
   cbNeeded += FUDGE_SIZE;

      //
      // Step 2.  Is there a current Plus! bitmap ?!?
      //          Subtract it's size from our requirements
      //

   GetPlusBitmapName (szTemp);

   hFile = FindFirstFile(szTemp, &fd);
   if (hFile != INVALID_HANDLE_VALUE)
      {
         // Make sure it isn't larger than we know what to do with
      if (!fd.nFileSizeHigh)
         {
         if (cbNeeded > fd.nFileSizeLow)
            cbNeeded -= fd.nFileSizeLow;
         else
            {
               // Just to be safe we need some space
            cbNeeded = FUDGE_SIZE;
            }
         }

      FindClose (hFile);
      }
   
      // 
      // Step 3.  Get Space available on drive
      //

   chDrive = szTemp[0];
   szDrive[0] = chDrive;
   szDrive[1] = TEXT(':');
   szDrive[2] = TEXT('\\');
   szDrive[3] = 0;

   if (! GetDiskFreeSpace (szDrive, &csCluster, &cbSector, &ccFree, &ccTotal))
      return FALSE;

   cbAvail = ccFree * csCluster * cbSector;
   

      // 
      // Step 3.  Is there a problem ?!?
      //

   if (cbAvail < cbNeeded)
      {
         // Inform User ?!?
      if (fComplain)
         {
            // Let user know about space problem
         ckNeeded = cbNeeded/1024L;

         LoadString (hInstApp, STR_ERRNEEDSPACE, (LPTSTR)szTemp, MAX_MSGLEN);
         wsprintf ((LPTSTR)szMsg, (LPTSTR)szTemp, chDrive, ckNeeded, chDrive);
         MessageBox((HWND)hWnd, (LPTSTR)szMsg, (LPTSTR)szAppName,
                    MB_OK | MB_ICONERROR | MB_APPLMODAL);
         }

         // Don't bother to do any work
      return FALSE;
      }

   return TRUE;
}

// GatherICONS
//
BOOL GatherICONS(LPCTSTR lpszThemefile)
{
   DWORD ikey;                 // index for FROST_SUBKEY arrary
   DWORD dwMaxKey;             // number of FROST_SUBKEY's in array
   int ival;                   // index for FROST_VALUE array
   DWORD dwType;               // type of reg key
   DWORD dwSize;               // size of reg key
   HKEY hKeyCU;                // handle to CURRENT_USER key
   HKEY hKeyR;                 // handle to CLASSES_ROOT key
   BOOL bGotCU;                // Do we have a good CU handle?
   BOOL bGotR;                 // Do we have a good ROOT handle?
   BOOL bGotValCU;             // We got the value from the CU key
   BOOL bGotValR;              // We got the value from the R key
   BOOL bRet;                  // Return from bool function
   BOOL bOK = TRUE;            // cumulative return code for this function
   LONG lret;                  // function result
   TCHAR szNTReg[MAX_PATH];    // Reg path to use for NT

   dwMaxKey = sizeof(fsCUIcons)/sizeof(FROST_SUBKEY);

   // loop through each subkey in the fsCUIcons() enumeration
   for (ikey = 0; ikey < dwMaxKey; ikey++) {

     // The icon information is typically kept in the CURRENT_USER
     // branch, but if we don't find it there we need to check the
     // CLASSES_ROOT branch as well.
     //
     // On the NT Platform we check the c_szSoftwareClassesFmt reg
     // path first (instead of CURRENT_USER/fsCUIcons) then try the
     // CLASSES_ROOT branch.
 
     // Try to open the appropriate CURRENT_USER subkey for this platform
     if (IsPlatformNT())
     {
        lstrcpy(szNTReg, c_szSoftwareClassesFmt);
        lstrcat(szNTReg, fsRoot[ikey].szSubKey);
        lret = RegOpenKeyEx(HKEY_CURRENT_USER, szNTReg,
                            (DWORD)0, KEY_QUERY_VALUE, (PHKEY)&hKeyCU);

     }
     else  // Not NT so don't use the touched-up current_user path
     {
        lret = RegOpenKeyEx(HKEY_CURRENT_USER, (LPTSTR)fsCUIcons[ikey].szSubKey,
                            (DWORD)0, KEY_QUERY_VALUE, (PHKEY)&hKeyCU);
     }

     if (lret != ERROR_SUCCESS) bGotCU = FALSE;
     else bGotCU = TRUE;

     // Try to open the CLASSES_ROOT subkey
     lret = RegOpenKeyEx(HKEY_CLASSES_ROOT, (LPTSTR)fsRoot[ikey].szSubKey,
                         (DWORD)0, KEY_QUERY_VALUE, (PHKEY)&hKeyR);

     if (lret != ERROR_SUCCESS) bGotR = FALSE;
     else bGotR = TRUE;

     // If we couldn't open a key in either the CU or R branch then
     // we should write a null value to the Theme file.
     if (!bGotCU && !bGotR) {

        // (null loop if default string only)
        for (ival = 0; ival < fsCUIcons[ikey].iNumVals; ival++) {
            bRet = WritePrivateProfileString(
                             fsCUIcons[ikey].szSubKey,
                             (LPTSTR)fsCUIcons[ikey].fvVals[ival].szValName,
                             (LPTSTR)szNULL, lpszThemefile);
 
            bOK = bOK && bRet;
        }

        if (fsCUIcons[ikey].fValues != FV_LIST) { // either def or list+def
            bRet = WritePrivateProfileString(
                                    fsCUIcons[ikey].szSubKey,
                                    (LPTSTR)FROST_DEFSTR,
                                    (LPTSTR)szNULL, lpszThemefile);

            bOK = bOK && bRet;
         }

         continue;  // Failed to OPEN reg key so continue on to next ikey
     }

     // Assume that we successfully opened either the CU or R subkey
     // treat depending on type of values for this subkey

     switch (fsCUIcons[ikey].fValues) {

      case FV_LIST:
      case FV_LISTPLUSDEFAULT:

         // loop through each value in the list for this subkey
         for (ival = 0; ival < fsCUIcons[ikey].iNumVals; ival++) {
            bGotValCU = FALSE;
            if (bGotCU) {
               dwSize = (DWORD)(MAX_VALUELEN * sizeof(TCHAR));
               lret = RegQueryValueEx(
                            hKeyCU,
                            fsCUIcons[ikey].fvVals[ival].szValName,
                            (LPDWORD)NULL,
                            (LPDWORD)&dwType,
                            (LPBYTE)pValue,
                            (LPDWORD)&dwSize);

               if (lret == ERROR_SUCCESS)
               {
                  bGotValCU = TRUE;
                  if (REG_EXPAND_SZ == dwType) ExpandSZ(pValue);
               }
            }

            // If we have a CLASSES_ROOT handle AND:
            //
            //  * We failed to read from CU OR
            //  * We got a NULL string from CU
            //
            // Try reading from the CR branch instead:

            bGotValR = FALSE;
            if ((bGotR) && (!bGotValCU || !*pValue)) {
               dwSize = (DWORD)(MAX_VALUELEN * sizeof(TCHAR));
               lret = RegQueryValueEx(
                            hKeyR,
                            fsRoot[ikey].fvVals[ival].szValName,
                            (LPDWORD)NULL,
                            (LPDWORD)&dwType,
                            (LPBYTE)pValue,
                            (LPDWORD)&dwSize);

               if (lret == ERROR_SUCCESS)
               {
                  bGotValR = TRUE;
                  if (REG_EXPAND_SZ == dwType) ExpandSZ(pValue);
               }
            }

            if (!bGotValCU && !bGotValR) {
               // Failed to get value from either CU or R so write
               // a null string to the Theme file

               bRet = WritePrivateProfileString(
                            fsCUIcons[ikey].szSubKey,
                            (LPTSTR)fsCUIcons[ikey].fvVals[ival].szValName,
                            (LPTSTR)szNULL, lpszThemefile);
               bOK = bOK && bRet;
               continue;  // Next ival
            }

            // Assume we got the value from either the CU or R key
            // Regardless of which one we *got* it from we'll write it
            // out to the Theme file as if it came from the CURRENT USER
            // branch

            if (fsCUIcons[ikey].fvVals[ival].bValRelPath)
                             AbstractPath((LPTSTR)pValue, MAX_VALUELEN);

            bRet = WritePrivateProfileString(
                             fsCUIcons[ikey].szSubKey,
                             (LPTSTR)fsCUIcons[ikey].fvVals[ival].szValName,
                             (LPTSTR)pValue, lpszThemefile);
            bOK = bOK && bRet;

         }  // End for ival loop

         // check if just list or list plus default
         if (FV_LIST == fsCUIcons[ikey].fValues)
            break;                  // normal EXIT

         // else fall through and do default, too

      case FV_DEFAULT:
         //
         // Default string: There are no "valuenames" to search for under
         // this key. 
         //

         // First try getting the default string from the CU key

         bGotValCU = FALSE;
         if (bGotCU) {
            dwSize = (DWORD)(MAX_VALUELEN * sizeof(TCHAR));
            lret = RegQueryValueEx(hKeyCU,
                                   (LPTSTR)szNULL,// null str to get default
                                   (LPDWORD)NULL,
                                   (LPDWORD)&dwType,
                                   (LPBYTE)pValue, // getting actual def value
                                   (LPDWORD)&dwSize);

            if (ERROR_SUCCESS == lret)
            {
               bGotValCU = TRUE;
               if (REG_EXPAND_SZ == dwType) ExpandSZ(pValue);
            }
         }

         // If we have a CLASSES_ROOT handle AND:
         //
         //  * We failed to read from CU OR
         //  * We got a NULL string from CU
         //
         // Try reading from the CR branch instead:

         bGotValR = FALSE;
         if ((bGotR) && (!bGotValCU || !*pValue)) {
            dwSize = (DWORD)(MAX_VALUELEN * sizeof(TCHAR));
            lret = RegQueryValueEx(hKeyR,
                                   (LPTSTR)szNULL,// null str to get default
                                   (LPDWORD)NULL,
                                   (LPDWORD)&dwType,
                                   (LPBYTE)pValue, // getting actual def value
                                   (LPDWORD)&dwSize);

            if (ERROR_SUCCESS == lret)
            {
               bGotValR = TRUE;
               if (REG_EXPAND_SZ == dwType) ExpandSZ(pValue);
            }
         }

         if (!bGotValCU && !bGotValR) {
            // Failed to get the default value from either the CU or R key
            *pValue = TEXT('\0');  // Set pValue to null string
         }

         // OK, if this is a path/filename, see about xlating to relative path
         if (fsCUIcons[ikey].bDefRelPath)
            AbstractPath((LPTSTR)pValue, MAX_VALUELEN);

         //
         // Phew, finally.  Write single default value
         //
         bRet = WritePrivateProfileString((LPTSTR)(fsCUIcons[ikey].szSubKey),
                                          (LPTSTR)FROST_DEFSTR,
                                          (LPTSTR)pValue, lpszThemefile);

         bOK = bOK && bRet;
         break;

      default:
         Assert(FALSE, TEXT("Unlisted .fValues value in GatherICONS!\n"));
         break;
     }  // End switch

     // close the keys if appropriate
     if (bGotR)  RegCloseKey(hKeyR);
     if (bGotCU) RegCloseKey(hKeyCU);

   }  // End for ikey

   return bOK;
}

// ApplyWebView
//
// For each setting in the [WebView] portion of the *.Theme
// file copy the specified file into the \windir\web directory.
//
// If there is no setting, extract the resource from the WEBVW.DLL.
//
// [WebView]
//
// WVLEFT.BMP = filename.bmp  // Webview top left "watermark"
// WVLINE.GIF = filename.gif  // Webview line in top left corner
// WVLOGO.GIF = filename.gif  // Webview gears & win98 logo
//
// Params:  Full path to *.Theme file.
//
// Returns: FALSE if major catastrophe
//          TRUE if things (sort of) went OK
//

BOOL ApplyWebView(LPCTSTR szThemefile)
{
   DWORD dwI = 0;                    // Index into szWVNames array
   DWORD dwResult = 0;               // Result of function call
   TCHAR szWinDirWeb[MAX_PATH];      // Path to \windir\web
   TCHAR szWinDirWebFile[MAX_PATH];  // Full path to WebView art file
   TCHAR szBuffer[MAX_PATH];         // Read from *.Theme file
   TCHAR szTempPath[MAX_PATH];       // Path to temp directory
   TCHAR szTempFile[MAX_PATH];       // Full path to temporary file
   
   // Initialize the path to the \windir\web directory where we'll
   // put the WebView artwork files

   if (!GetWindowsDirectory(szWinDirWeb, MAX_PATH)) {
      // This is bad -- we can't find the windows directory?! Abandon ship.
      return FALSE;
   }

   lstrcat(szWinDirWeb, TEXT("\\Web\0"));


   // Get a temp filename where we can store the resource we extract
   // out of WEBVW.DLL (if we need to).

   // First the path to temp dir
   if (!GetTempPath(MAX_PATH, szTempPath)) {
      // This is bad -- we can't find the temp directory?! Abandon ship.
      return FALSE;
   }

   // Now a temp filename
   if (!GetTempFileName(szTempPath, TEXT("THM"), 0, szTempFile)) {
      // Couldn't get a temp file?  Not likely but if so bail out...
      return FALSE;
   }

   // For each potential [WebView] setting in the Theme file do
   // this stuff...
   for (dwI = 0; dwI < MAX_WVNAMES; dwI++)
   {

      // Get the current setting from the *.Theme file if the setting
      // exists
      GetPrivateProfileString(TEXT("WebView"),
                              szWVNames[dwI],
                              TEXT("\0"),
                              szBuffer,
                              MAX_PATH,
                              szThemefile);

      // Instantiate the path
      InstantiatePath(szBuffer, MAX_PATH);

      // Now check to see if this file even exists
      dwResult = GetFileAttributes(szBuffer);

      // If GFA failed we need to extract this file from webvw.dll
      if (0xFFFFFFFF == dwResult) {
         if (ExtractWVResource(szWVNames[dwI], szTempFile)) {
            // We successfully extracted the resource into TempFile.
            // Now copy it to the ultimate destination.

            // Create a path to the \windir\web\file
            lstrcpy(szWinDirWebFile, szWinDirWeb);
            lstrcat(szWinDirWebFile, TEXT("\\"));
            lstrcat(szWinDirWebFile, szWVNames[dwI]);

            // Copy the file
            DeleteFile(szWinDirWebFile);
            CopyFile(szTempFile, szWinDirWebFile, FALSE);

            // Delete the temporary file
            DeleteFile(szTempFile);
         }
      }  // End if GFA failed
      else {
         // The .Theme file exists so we need to copy it to the Web dir

         // Create a path to the \windir\web\file
         lstrcpy(szWinDirWebFile, szWinDirWeb);
         lstrcat(szWinDirWebFile, TEXT("\\"));
         lstrcat(szWinDirWebFile, szWVNames[dwI]);

         DeleteFile(szWinDirWebFile);
         CopyFile(szBuffer, szWinDirWebFile, FALSE);
      }
   } // End for dwI loop

   // Cleanup the temp file
   DeleteFile(szTempFile);
   return TRUE; //  this isn't very meaningful...
}


// GatherWebView
//
// Collect the current WebView artwork files, store them in the
// theme dir under the appropriate name, and save the settings
// in the *.Theme file under the appropriate setting.
//
// [WebView]
//
// WVLEFT.BMP = Theme name WVLEFT.BMP  // Webview top left "watermark"
// WVLINE.GIF = Theme name WVLINE.GIF  // Webview line in top left corner
// WVLOGO.GIF = Theme name WVLOGO.GIF  // Webview gears & win98 logo
//
// Params:  Full path to *.Theme file.
//
// Returns: FALSE if major catastrophe
//          TRUE if things sort of went OK
//

BOOL GatherWebView(LPCTSTR szThemefile)
{
   DWORD dwI = 0;                    // Index into szWVNames array
   TCHAR szWinDirWeb[MAX_PATH];      // Path to \windir\web
   TCHAR szWinDirWebFile[MAX_PATH];  // Full path to WebView art file
   TCHAR szSaveFile[MAX_PATH];       // Full path to destination file
   
   // Initialize the path to the \windir\web directory where we'll
   // get the WebView artwork files

   if (!GetWindowsDirectory(szWinDirWeb, MAX_PATH)) {
      // This is bad -- we can't find the windows directory?! Abandon ship.
      return FALSE;
   }

   lstrcat(szWinDirWeb, TEXT("\\Web\0"));

   // For each potential [WebView] setting in the Theme file do
   // this stuff...
   for (dwI = 0; dwI < MAX_WVNAMES; dwI++)
   {

      // Verify that we have a file for the current setting
      lstrcpy(szWinDirWebFile, szWinDirWeb);
      lstrcat(szWinDirWebFile, TEXT("\\"));
      lstrcat(szWinDirWebFile, szWVNames[dwI]);
      if (GetFileAttributes(szWinDirWebFile)) {

         // We've got a file so let's save it to the theme dir
         // under a unique name

         if (GetWVFilename(szThemefile, szWVNames[dwI], szSaveFile)) {
            if (CopyFile(szWinDirWebFile, szSaveFile, FALSE)) {
               SetFileAttributes(szSaveFile, FILE_ATTRIBUTE_ARCHIVE);
               AbstractPath(szSaveFile, MAX_PATH);
               WritePrivateProfileString(TEXT("WebView"),
                                         szWVNames[dwI],
                                         szSaveFile,
                                         szThemefile);
            }
         }
      }
   }
   return TRUE;
}

// ExtractWVResource
//
// Extracts the specified custom resource from the windir\system\webvw.dll
// file and stores it in the specified destination file.
//
// If the destination file exists it is overwritten.
//
// Params:  lpszResource -- Resource name to extract (i.e. WVLEFT.BMP)
//          lpszDestination -- File to save resource to
//
// Returns: True if successful, False if not.
//

BOOL ExtractWVResource(LPCTSTR lpszResource, LPCTSTR lpszDestination)
{

   HINSTANCE hInstWVDLL = NULL;    // Instance handle for WEBVW.DLL
   HRSRC hRsrc = NULL;             // Handle to resource in WEBVW.DLL
   HGLOBAL hGlobal = NULL;         // Global handle to loaded resource
   LPVOID lpResource = NULL;       // Memory pointer to locked resource
   DWORD dwRSize = 0;              // Size of resource
   DWORD dwBytesW = 0;             // Number of bytes written to dest file
   HANDLE hFile = NULL;            // Handle to destination file
   TCHAR szWebVWDLL[MAX_PATH];     // Full path to \windir\system\webvw.dll
   DWORD dwResult;                 // Result of function call

   // Build full path to \windir\system\webvw.dll
   if (!GetWindowsDirectory(szWebVWDLL, MAX_PATH)) {
      // This is bad -- we can't find the windows directory?! Abandon ship.
      return FALSE;
   }
   if (IsPlatformNT()) {
      lstrcat(szWebVWDLL, TEXT("\\SYSTEM32\\WEBVW.DLL\0"));
   }
   else {
      lstrcat(szWebVWDLL, TEXT("\\SYSTEM\\WEBVW.DLL\0"));
   }

   // Load WEBVW.DLL
   hInstWVDLL = NULL;
   hInstWVDLL = LoadLibrary(szWebVWDLL);

   if (!hInstWVDLL) {
      return FALSE;
   }

   // Find the desired resource in WEBVW.DLL
   hRsrc = NULL;
   hRsrc = FindResource(hInstWVDLL, lpszResource, TEXT("#23") /*Resource Type*/);

   if (!hRsrc) {
      FreeLibrary(hInstWVDLL);
      return FALSE;
   }

   // Load the resource into memory
   hGlobal = NULL;
   hGlobal = LoadResource(hInstWVDLL, hRsrc);
   if (!hGlobal) {
      FreeLibrary(hInstWVDLL);
      return FALSE;
   }

   // Figure out how big the resource is.
   dwRSize = 0;
   dwRSize = SizeofResource(hInstWVDLL, hRsrc);
   if (!dwRSize) {
      FreeLibrary(hInstWVDLL);
      return FALSE;
   }
         
   // Get a memory pointer to and lock the resource
   lpResource = NULL;
   lpResource = LockResource(hGlobal);
   if (!lpResource) {
      FreeLibrary(hInstWVDLL);
      return FALSE;
   }

   // Get a handle to the destination file
   hFile = CreateFile(lpszDestination,
                      GENERIC_WRITE,
                      FILE_SHARE_READ,
                      NULL,
                      CREATE_ALWAYS,
                      FILE_ATTRIBUTE_ARCHIVE,
                      NULL);

   if (INVALID_HANDLE_VALUE == hFile) {
      FreeLibrary(hInstWVDLL);
      return FALSE;
   }

   // Write the full resource into the destination file
   dwBytesW = 0;
   dwResult = 0;
   dwResult = WriteFile(hFile, lpResource, dwRSize, &dwBytesW, NULL);

   // Problems writing the resource?
   if ((!dwResult) || (dwRSize != dwBytesW)) {
      CloseHandle(hFile);
      DeleteFile(lpszDestination);
      FreeLibrary(hInstWVDLL);
      return FALSE;
   }

   // Cleanup and hit the road
   CloseHandle(hFile);
   FreeLibrary(hInstWVDLL);
   return TRUE;
}

// GetWVFilename
//
// Given a Themefile (with path info), a WebView file name (i.e. WVLEFT.BMP),
// and a pointer to a string buffer, build a name for the Theme WebView file.
//
// For example:
//
// lpszThemefile = C:\Program Files\Plus!\Themes\Sports.Theme
// lpszWVName = WVLOGO.GIF
//
// Result:
//
// lpszWVFile = "C:\Program Files\Plus!\Themes\Sports WVLOGO.GIF"
//
// NOTE: lpszWVFile does not have the double quotes in it -- I put
// them in this comment for clarity.
//
// Params:
//
// lpszThemefile -- path/name of theme file
// lpszWVName -- name of WebView artwork file
// lpszWVFile -- destination buffer to hold final file name
//
// Returns: TRUE if lpszWVFile is valid name, else FALSE

BOOL GetWVFilename(LPCTSTR lpszThemefile, LPCTSTR lpszWVName, LPTSTR lpszWVFile)
{
   LPTSTR lpszThemeName = NULL;   // Pointer to Theme filename in path
   LPTSTR Begin;
   LPTSTR Current;
   LPTSTR End;

   // Take the easy out if we got bogus params
   if (!lpszThemefile || !*lpszThemefile || !lpszWVName || !*lpszWVName ||
       !lpszWVFile) {
      return FALSE;
   }

   if (GetFullPathName(lpszThemefile, MAX_PATH, lpszWVFile, &lpszThemeName)) {

      // Remove the extension from the Theme name -- go to the
      // end of the string then back up to the first ".".

      Current = lpszWVFile;
      while (*Current) Current = CharNext(Current);
      End = Current;

      // Current now points to the end of lpszWVFile -- back up to the
      // first '.' (the extension marker).
      Begin = lpszWVFile;
      Current = CharPrev(Begin, Current);
      while ((Current > Begin) && (*Current != TEXT('.'))) Current = CharPrev(Begin, Current);

      if (Current >= Begin) *Current = TEXT('\0');

      // Append a space followed by the WebView file name
      lstrcat(lpszWVFile, TEXT(" "));
      lstrcat(lpszWVFile, lpszWVName);

    }
    return TRUE;
}

VOID ExpandSZ(LPTSTR pszSrc)
{

    LPTSTR pszTmp;

    Assert(FALSE, TEXT("GOT EXPAND_SZ -- Before: "));
    Assert(FALSE, pszSrc);
    Assert(FALSE, TEXT("\n"));

    pszTmp = (LPTSTR)GlobalAlloc(GPTR, (MAX_PATH * sizeof(TCHAR)));
    Assert(pszTmp, TEXT("THEMES: Error allocating memory in ExpandSZ()\n"));
    if (pszTmp)
    {
       if (ExpandEnvironmentStrings(pszSrc, pszTmp, MAX_PATH))
       {
          lstrcpy(pszSrc, pszTmp);
       }
       GlobalFree(pszTmp);
    }

    Assert(FALSE, TEXT("GOT EXPAND_SZ -- After: "));
    Assert(FALSE, pszSrc);
    Assert(FALSE, TEXT("\n"));

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\schedule.cpp ===
// File:        schedule.cpp
//
// Contents:    Functions needed to start, query, add, remove tasks
//              in Task Scheduler
//
// Microsoft Desktop Themes for Windows
// Copyright (c) 1998-1999 Microsoft Corporation.  All rights reserved.

#include <wchar.h>
#include <windows.h>
#include <mbctype.h>
#include <objbase.h>
#include <initguid.h>
#include <mstask.h>
#include <msterr.h>
#include "frost.h"

#define MSG_BOX_TSERR(hw,msg) MessageBox(hw, msg, szThemeName,\
                            MB_OK | MB_ICONERROR | MB_APPLMODAL)


#define SCHED_CLASS             TEXT("SAGEWINDOWCLASS")
#define SCHED_TITLE             TEXT("SYSTEM AGENT COM WINDOW")
#define SCHED_SERVICE_APP_NAME  TEXT("mstask.exe")
#define SCHED_SERVICE_NAME      TEXT("Schedule")
#define EVERY_MONTH (TASK_JANUARY | TASK_FEBRUARY | TASK_MARCH | TASK_APRIL |\
                     TASK_MAY | TASK_JUNE | TASK_JULY | TASK_AUGUST |\
                     TASK_SEPTEMBER | TASK_OCTOBER | TASK_NOVEMBER |\
                     TASK_DECEMBER)

//+--------------------------------------------------------------------------
// Global variables defined in GLOBAL.H for compat. with C sources
//---------------------------------------------------------------------------

extern "C" HWND hWndApp = NULL;
extern "C" HINSTANCE hInstApp = NULL;

//+--------------------------------------------------------------------------
// Global variables for use in SCHEDULE.CPP only
//---------------------------------------------------------------------------

ITaskScheduler *g_pITaskScheduler = NULL;
TCHAR szRunServices[] = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunServices");
TCHAR szScheduler[] = TEXT("SchedulingAgent");
TCHAR szMSTask[] = TEXT("mstask.exe");
TCHAR szUserName[MAX_PATH];
TCHAR szPassword[MAX_PATH];

//+--------------------------------------------------------------------------
// Function Prototypes
//---------------------------------------------------------------------------

HRESULT Init(void);
void Cleanup(void);
extern "C" BOOL IsTaskSchedulerRunning();
extern "C" BOOL StartTaskScheduler(BOOL);
extern "C" BOOL IsThemesScheduled();
extern "C" BOOL AddThemesTask(LPTSTR, BOOL);
extern "C" BOOL DeleteThemesTask();
extern "C" BOOL HandDeleteThemesTask();
extern "C" BOOL IsPlatformNT();
extern "C" BOOL GetCurrentUser(LPTSTR, DWORD, LPTSTR, DWORD, LPTSTR, DWORD);
extern "C" BOOL GetTextualSid(PSID, LPTSTR, LPDWORD);
extern "C" VOID BuildNTJobName(LPTSTR);
extern "C" BOOL IsUserAdmin();

//+--------------------------------------------------------------------------
//
// Function:        PasswordDlgProc()
//
// Synopsis:        WINNT only -- prompts user for name and password.
//
// Arguments:       none (void)
//
//---------------------------------------------------------------------------

INT_PTR CALLBACK PasswordDlgProc(HWND hDlg,
                                 UINT uMsg,
                                 WPARAM wParam,
                                 LPARAM lParam)
{
    TCHAR szPWConfirm[MAX_PATH];
    TCHAR szErrMsg[MAX_PATH];
    TCHAR szThemeName[MAX_STRLEN];  // Used for msgbox title
    DWORD dwSize = 0;
    TCHAR szProfile[MAX_PATH];

    switch(uMsg)

    {

          case WM_INITDIALOG:

                 if (GetCurrentUser(szPassword, /* Actually user name   */
                                    ARRAYSIZE(szPassword),
                                    szUserName, /* Actually domain name */
                                    ARRAYSIZE(szUserName),
                                    szProfile,
                                    ARRAYSIZE(szProfile)))
                 {
                    // GetCurrentUser succeeded so build the domain\user
                    //
                    // Remember these variable names are bogus --
                    // szUserName is actually the domain name
                    // szPassword is actually the user name
                    //

                    if (szPassword[0]) lstrcat(szUserName, TEXT("\\"));
                    lstrcat(szUserName, szPassword);
                 }
                 else
                 {
                    // GetCurrentUser failed so do this as last resort
                    dwSize = ARRAYSIZE(szUserName);
                    GetUserName(szUserName, &dwSize);
                 }
                 *szPassword = 0;

                 SetDlgItemText(hDlg, EDIT_USER, szUserName);
                 SetFocus(GetDlgItem(hDlg, EDIT_PW));

                 return FALSE;  // Return false to keep focus on PW control
                 break;


           case WM_COMMAND:

                 switch (wParam)

                 {

                      case IDOK:
                           GetDlgItemText(hDlg, EDIT_USER, szUserName, MAX_PATH);
                           GetDlgItemText(hDlg, EDIT_PW, szPassword, MAX_PATH);
                           GetDlgItemText(hDlg, EDIT_PWCONFIRM, szPWConfirm, MAX_PATH);

                           if (lstrcmp(szPassword, szPWConfirm))
                           {
                              // PW and PWCONFIRM don't match

                              LoadString(hInstApp, STR_APPNAME, szThemeName, MAX_STRLEN);
                              LoadString(hInstApp, STR_PW_NOMATCH, szErrMsg, MAX_PATH);
                              MessageBox(hWndApp, szErrMsg, szThemeName,
                                         MB_OK | MB_ICONERROR | MB_APPLMODAL);
                              SetDlgItemText(hDlg, EDIT_PW, TEXT("\0"));
                              SetDlgItemText(hDlg, EDIT_PWCONFIRM, TEXT("\0"));
                              SetActiveWindow(GetDlgItem(hDlg, EDIT_PW));
                              SetFocus(GetDlgItem(hDlg, EDIT_PW));
                              break;
                           }

                           else

                           {
                              EndDialog(hDlg,1);
                              break;
                           }

                      case IDCANCEL:
                           szUserName[0] = TEXT('\0');
                           szPassword[0] = TEXT('\0');
                           EndDialog(hDlg, 0);
                           break;
                 }

                 break;

           default:
                 return FALSE;

    } // switch uMsg

    return TRUE;

} // PasswordDlgProc


//+--------------------------------------------------------------------------
//
// Function:        IsPlatformNT()
//
// Synopsis:        Checks to see if the os is NT or not.
//
// Arguments:       none (void)
//
// Returns:         TRUE if NT, FALSE if not.
//
//---------------------------------------------------------------------------

extern "C" BOOL IsPlatformNT()
{
    OSVERSIONINFO        osver;

    osver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    // Determine what version of OS we are running on.
    GetVersionEx(&osver);

    if (osver.dwPlatformId == VER_PLATFORM_WIN32_NT)
       return TRUE;
    else
       return FALSE;
}

//+--------------------------------------------------------------------------
//
// Function:        IsTaskSchedulerRunning()
//
// Synopsis:        Looks for TS window to determince TS is running.
//
// Arguments:       none (void)
//
// Returns:         TRUE if running, FALSE if not.
//
//---------------------------------------------------------------------------

extern "C" BOOL IsTaskSchedulerRunning()
{
   HWND hwnd = FindWindow(SCHED_CLASS, SCHED_TITLE);

   if (hwnd == NULL)
   {
      //MessageBox(hWndApp, TEXT("TS is not running"), TEXT("Desktop Themes"), MB_OK | MB_APPLMODAL);
      return FALSE;
   }
   else
   {
      //MessageBox(hWndApp, TEXT("TS is running"), TEXT("Desktop Themes"), MB_OK | MB_APPLMODAL);
      return TRUE;
   }
}

//---------------------------------------------------------------------------
//  Function:   StartTaskScheduler
//  Synopsis:   Start the task scheduler service if it isn't already running.
//  Arguments:  bPrompt -- TRUE == prompt user before starting.
//                         FALSE == just start it, don't prompt user.
//  Returns:    TRUE if successful, FALSE if not.
//  Notes:      This function works in Win9x only.
//              If the service is running but paused, does nothing.
//---------------------------------------------------------------------------

extern "C" BOOL StartTaskScheduler(BOOL bPrompt)
{
    STARTUPINFO          sui;
    PROCESS_INFORMATION  pi;
    TCHAR                szApp[MAX_PATH];
    LPTSTR               pszPath;
    DWORD                dwRet;
    BOOL                 fRet;
    TCHAR                szErrMsg[MAX_PATH];
    TCHAR                szThemeName[MAX_STRLEN]; // Used for msgbox title
    int                  MBChoice;  // User's reply to Yes/No dialog
    DWORD                dwDisposition;
    HKEY                 hKey;
    LONG                 lret;

    LoadString(hInstApp, STR_APPNAME, szThemeName, MAX_STRLEN);

    HWND hwnd = FindWindow(SCHED_CLASS, SCHED_TITLE);
    if (hwnd != NULL) {
       // It is already running.
       return TRUE;
    }

    // If specified, prompt user before attempting to start
    // Task Scheduler.

    if (bPrompt) {
       LoadString(hInstApp, STR_ERRTSNOTRUN, szErrMsg, MAX_PATH);
       MBChoice = MessageBox(hWndApp, szErrMsg, szThemeName,
                           MB_YESNO | MB_ICONQUESTION | MB_APPLMODAL);

       // Did user opt to NOT start task scheduler?
       if (IDYES != MBChoice) return FALSE;
    }

    if (!IsPlatformNT()) {

       // Start the Win9x version of TaskScheduler.
       //  Execute the task scheduler process.

       ZeroMemory(&sui, sizeof(sui));
       sui.cb = sizeof(STARTUPINFO);

       dwRet = SearchPath(NULL,
                          SCHED_SERVICE_APP_NAME,
                          NULL,
                          MAX_PATH,
                          szApp,
                          &pszPath);

       if (dwRet == 0) {
           LoadString(hInstApp, STR_ERRTSNOTFOUND, szErrMsg, MAX_PATH);
           MessageBox(hWndApp, szErrMsg, szThemeName,
                         MB_OK | MB_ICONERROR | MB_APPLMODAL);
           return FALSE;
       }

       fRet = CreateProcess(szApp,
                            NULL,
                            NULL,
                            NULL,
                            FALSE,
                            CREATE_NEW_CONSOLE | CREATE_NEW_PROCESS_GROUP,
                            NULL,
                            NULL,
                            &sui,
                            &pi);

       if (fRet == 0) {
           LoadString(hInstApp, STR_ERRTSNOSTART, szErrMsg, MAX_PATH);
           MessageBox(hWndApp, szErrMsg, szThemeName,
                             MB_OK | MB_ICONERROR | MB_APPLMODAL);
           return FALSE;
       }

       CloseHandle(pi.hProcess);
       CloseHandle(pi.hThread);

       // Assume that MSTASK.EXE was successfully started.  We need to
       // add mstask.exe to the RunServices branch of the registry.

       hKey = NULL;
       lret = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                             szRunServices,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_WRITE,
                             NULL,
                             &hKey,
                             &dwDisposition);

       if (lret == ERROR_SUCCESS) {
          // RegDeleteValue(hKey, szScheduler);
          lret = RegSetValueEx(hKey,
                               szScheduler,
                               0,
                               REG_SZ,
                               (CONST BYTE *)szMSTask,
                               SZSIZEINBYTES(szMSTask));
       }

       if (hKey) RegCloseKey(hKey);

       return TRUE;
    }
    else
    {

       // If not Win9x then start the NT version as a TaskScheduler service.

       SC_HANDLE   hSC = NULL;
       SC_HANDLE   hSchSvc = NULL;

       // Does the user have administrative privileges?  If not, the
       // user can't start TS.

       if (!IsUserAdmin())
       {
          LoadString(hInstApp, STR_ERRTSNOTADMIN, szErrMsg, MAX_PATH);
          MessageBox(hWndApp, szErrMsg, szThemeName,
                             MB_OK | MB_ICONERROR | MB_APPLMODAL);
          return FALSE;
       }


       hSC = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);

       if (hSC == NULL)
       {

          return FALSE;
// NEED TO ADD ERROR DIALOG HERE
//        return GetLastError();
       }

       hSchSvc = OpenService(hSC,
                             SCHED_SERVICE_NAME,
                             SERVICE_START | SERVICE_QUERY_STATUS);

       CloseServiceHandle(hSC);

       if (hSchSvc == NULL)
       {
          LoadString(hInstApp, STR_ERRTSNOSTART, szErrMsg, MAX_PATH);
          MessageBox(hWndApp, szErrMsg, szThemeName,
                             MB_OK | MB_ICONERROR | MB_APPLMODAL);
          return FALSE;
       }

       SERVICE_STATUS SvcStatus;

       if (QueryServiceStatus(hSchSvc, &SvcStatus) == FALSE)
       {
          CloseServiceHandle(hSchSvc);
          LoadString(hInstApp, STR_ERRTSNOSTART, szErrMsg, MAX_PATH);
          MessageBox(hWndApp, szErrMsg, szThemeName,
                             MB_OK | MB_ICONERROR | MB_APPLMODAL);
          return FALSE;
       }

       if (SvcStatus.dwCurrentState == SERVICE_RUNNING)
       {
          // The service is already running.
          CloseServiceHandle(hSchSvc);
          return TRUE;
       }

       if (StartService(hSchSvc, 0, NULL) == FALSE)
       {
          CloseServiceHandle(hSchSvc);
          LoadString(hInstApp, STR_ERRTSNOSTART, szErrMsg, MAX_PATH);
          MessageBox(hWndApp, szErrMsg, szThemeName,
                             MB_OK | MB_ICONERROR | MB_APPLMODAL);
          return FALSE;
       }

       CloseServiceHandle(hSchSvc);

       return TRUE;
    }

}  // END StartTaskScheduler()

//+--------------------------------------------------------------------------
//
// Function:        Init()
//
// Synopsis:        Called to initialize and instantiate a task
//                  scheduler object.
//
// Arguments:       none (void)
//
// Returns:         HRESULT indicating success or failure.  S_OK on success.
//
// Side effect:     Sets global pointer g_pITaskScheduler, for use in other
//                  functions.
//
//---------------------------------------------------------------------------

HRESULT Init()
{
    HRESULT hr = S_OK;

    // Bring in the library

    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        return hr;
    }

    // Create the pointer to Task Scheduler object
    // CLSID from the header file mstask.h

    hr = CoCreateInstance(
        CLSID_CTaskScheduler,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ITaskScheduler,
        (void **) &g_pITaskScheduler);

    // Should we fail, unload the library

    if (FAILED(hr))
    {
        CoUninitialize();
    }

    return hr;
}


//+--------------------------------------------------------------------------
//
// Function:    Cleanup()
//
// Synopsis:    Called to clean up OLE, memory, etc. before termination
//
// Arguments:   none (void)
//
// Returns:     nothing (void)
//
// Side effect: Cancels the global pointer g_pITaskScheduler.
//
//---------------------------------------------------------------------------

void Cleanup()
{
    if (g_pITaskScheduler)
    {
        g_pITaskScheduler->Release();
        g_pITaskScheduler = NULL;
    }

    // Unload the library, now that our pointer is freed.

    CoUninitialize();
    return;
}


//+--------------------------------------------------------------------------
//
// Function:    IsThemesScheduled()
//
// Synopsis:    Enumerates tasks and returns TRUE if Themes.job exists.
//              Returns FALSE if it does not.
//
// Arguments:   none (void).  Requires g_pITaskScheduler.
//
// Returns:     TRUE if Themes.job exists, else FALSE
//
//---------------------------------------------------------------------------

extern "C" BOOL IsThemesScheduled()
{
    HRESULT hr = S_OK, hrLoop = S_OK;
    IEnumWorkItems *pIEnumWorkItems;
    IUnknown *pIU;
    ITask *pITask;
    ULONG ulTasksToGet = 1, ulActualTasksRetrieved = 0;
    LPWSTR *rgpwszNames;
    TCHAR szDefaultJobName[MAX_PATH];
    BOOL bResult;
    UINT uCodePage;
#ifndef UNICODE
    CHAR szJobNameA[MAX_PATH];
#endif

    // For protection

    g_pITaskScheduler = NULL;

    // String conversion initialization

    uCodePage = _getmbcp();

    // Attempt to initialize OLE and fill in the global g_pITaskScheduler

    hr = Init();
    if (FAILED(hr))
    {
         return FALSE;
    }

    // Get the default name for a Themes task

    LoadString(hInstApp, STR_JOB_NAME, szDefaultJobName, MAX_PATH);

    // If this is NT we need to append the user profile name onto the
    // end of this task.

    if (IsPlatformNT()) BuildNTJobName(szDefaultJobName);

    //
    // Get an enumeration pointer, using ITaskScheduler::Enum
    //

    hr = g_pITaskScheduler->Enum(&pIEnumWorkItems);
    if (FAILED(hr))
    {
        // LoadString(hInstApp, STR_ERRTS, szErrMsg, MAX_PATH);
        // MSG_BOX_TSERR(hWndApp, szErrMsg);
        Cleanup();
        return FALSE;
    }

    bResult = FALSE;
    do
    {
        // Get a single work item, using IEnumWorkItems::Next

        hrLoop = pIEnumWorkItems->Next(ulTasksToGet, &rgpwszNames,
                                       &ulActualTasksRetrieved);
        if (hrLoop == S_FALSE)
        {
            // There are no more waiting tasks to look at
            break;
        }

        // Attach to the work item, using ITaskScheduler::Activate

        hr = g_pITaskScheduler->Activate(rgpwszNames[0], IID_ITask, &pIU);
        if (FAILED(hr))
        {
            // LoadString(hInstApp, STR_ERRTS, szErrMsg, MAX_PATH);
            // MSG_BOX_TSERR(hWndApp, szErrMsg);
            bResult = FALSE;
            break;
        }

        // QI pIU for pITask

        hr = pIU->QueryInterface(IID_ITask, (void **) &pITask);
        pIU->Release();
        pIU = NULL;
        if (FAILED(hr))
        {
            // LoadString(hInstApp, STR_ERRTS, szErrMsg, MAX_PATH);
            // MSG_BOX_TSERR(hWndApp, szErrMsg);
            bResult = FALSE;
            break;
        }

        // Compare task name

#ifndef UNICODE
        // No UNICODE so we need to convert the wide string returned
        // by ITask into an ANSI string.

        WideCharToMultiByte(uCodePage, 0, rgpwszNames[0], -1,
                            szJobNameA, MAX_PATH, NULL, NULL);
        // MessageBox(hWndApp, szJobNameA, szThemeName,
        //                               MB_OK | MB_APPLMODAL);
        if (!lstrcmp(szJobNameA, szDefaultJobName)) bResult = TRUE;
#else
        // We're living in a UNICODE world so no need to convert
        // the string from ITask.

        // MessageBox(hWndApp, rgpwszNames[0], szThemeName,
        //                               MB_OK | MB_APPLMODAL);
        if (!lstrcmp(rgpwszNames[0], szDefaultJobName)) bResult = TRUE;
#endif

        // Clean up each element in the array of job names, then
        // clean up the final array.

        CoTaskMemFree(rgpwszNames[0]);
        CoTaskMemFree(rgpwszNames);

        // Free the ITask pointer

        pITask->Release();

    } while(!bResult);

    // Release the enumeration pointer

    pITask = NULL;

    pIEnumWorkItems->Release();
    pIEnumWorkItems = NULL;

    Cleanup();
    return bResult; //
}

//+--------------------------------------------------------------------------
//
// Function:        DeleteThemesTask()
//
// Synopsis:        Deletes Themes task from Task Scheduler.
//
// Returns:         TRUE if OK, FALSE if FAIL.
//
//---------------------------------------------------------------------------

extern "C" BOOL DeleteThemesTask()
{
    HRESULT hr = S_OK;
    UINT uCodePage;
    TCHAR szDefaultJobName[MAX_PATH];
#ifndef UNICODE
    WCHAR szJobNameW[MAX_PATH];
#endif

    // String conversion initialization

    uCodePage = _getmbcp();

    // For protection

    g_pITaskScheduler = NULL;

    // Attempt to initialize OLE and fill in the global g_pITaskScheduler

    hr = Init();
    if (FAILED(hr))
    {
         // LoadString(hInstApp, STR_ERRTS, szErrMsg, MAX_PATH);
         // MSG_BOX_TSERR(hWndApp, szErrMsg);
         return FALSE;
    }

    // Get the default name for a Themes task

    LoadString(hInstApp, STR_JOB_NAME, szDefaultJobName, MAX_PATH);

    // If this is NT we need to append the user profile name onto the
    // end of this task.

    if (IsPlatformNT()) BuildNTJobName(szDefaultJobName);

#ifndef UNICODE
    // No UNICODE so convert the string to WCHAR format to
    // please the TS interface

    MultiByteToWideChar(uCodePage, 0, szDefaultJobName, -1,
                                             szJobNameW, MAX_PATH);

    // Delete it
    hr = g_pITaskScheduler->Delete(szJobNameW);
#else // UNICODE
    // We're UNICODE so we don't need to convert the string before
    // calling TS
    hr = g_pITaskScheduler->Delete(szDefaultJobName);
#endif

    Cleanup();

    return TRUE; // Returns TRUE regardless of hr value.
}

//+--------------------------------------------------------------------------
//
// Function:        AddThemesTask()
//
// Synopsis:        Adds a new work item to the Scheduled Tasks folder.
//
// Arguments:       lpwszThemesExe - fully qualified path to Themes.exe.
//                  bShowErrors - if TRUE, ATT shows error dialogs else
//                                it fails silently.
//
// Returns:         TRUE if successful, FALSE if not.
//
//---------------------------------------------------------------------------

extern "C" BOOL AddThemesTask(LPTSTR lpszThemesExe, BOOL bShowErrors)

{
    HRESULT hr = S_OK;
    IUnknown *pIU;
    IPersistFile *pIPF;
    ITask *pITask;
    ITaskTrigger *pITaskTrig;
    DWORD dwTaskFlags, dwTrigFlags;
    WORD wTrigNumber;
    TASK_TRIGGER TaskTrig;
    UINT uCodePage;

    //TCHAR szUserName[MAX_PATH];
    //TCHAR szPassword[MAX_PATH];
    WCHAR szRotateCommandW[] = L"/r";
    TCHAR szDefaultJobName[MAX_PATH];
    TCHAR szJobComment[MAX_PATH];
#ifndef UNICODE
    WCHAR szUserNameW[MAX_PATH];
    WCHAR szPasswordW[MAX_PATH];
    WCHAR szThemesExeW[MAX_PATH];
    WCHAR szJobNameW[MAX_PATH];
    WCHAR szJobCommentW[MAX_PATH];
#endif
    SYSTEMTIME LocalTime;
    TCHAR szErrMsg[MAX_PATH];
    TCHAR szThemeName[MAX_STRLEN];  // msg box title
    HKEY hKey;
    DWORD dwDisposition;
    LONG lret;
    INT_PTR iResult;

    LoadString(hInstApp, STR_APPNAME, szThemeName, MAX_STRLEN);
    LoadString(hInstApp, STR_JOB_NAME, szDefaultJobName, MAX_PATH);
    LoadString(hInstApp, STR_JOB_COMMENT, szJobComment, MAX_PATH);

    // If this is NT we need to append the user profile name onto the
    // end of this task.

    if (IsPlatformNT()) BuildNTJobName(szDefaultJobName);

    // String conversion initialization

    uCodePage = _getmbcp();


    // For protection

    g_pITaskScheduler = NULL;

    // Attempt to initialize OLE and fill in the global g_pITaskScheduler

    hr = Init();
    if (FAILED(hr))
    {
         if (bShowErrors) {
            LoadString(hInstApp, STR_ERRTS, szErrMsg, MAX_PATH);
            MSG_BOX_TSERR(hWndApp, szErrMsg);
         }
         return FALSE;
    }

    // Add the task.  Most likely failure is that work item already exists.
    // Uses ITaskScheduler::NewWorkItem


#ifndef UNICODE
    // No UNICODE so convert string to wide before adding task

    MultiByteToWideChar(uCodePage, 0, szDefaultJobName, -1,
                                             szJobNameW, MAX_PATH);

    hr = g_pITaskScheduler->NewWorkItem(szJobNameW,
                                        CLSID_CTask,
                                        IID_ITask,
                                        &pIU);
#else
    // UNICODE, so no need to convert string to WIDE before adding task

    hr = g_pITaskScheduler->NewWorkItem(szDefaultJobName,
                                        CLSID_CTask,
                                        IID_ITask,
                                        &pIU);
#endif

    if (FAILED(hr))
    {
        if (bShowErrors) {
           LoadString(hInstApp, STR_ERRTS, szErrMsg, MAX_PATH);
           MSG_BOX_TSERR(hWndApp, szErrMsg);
        }
        Cleanup();
        return FALSE;
    }

    // We now have an IUnknown pointer.  This is queried for an ITask
    // pointer on the work item we just added.

    hr = pIU->QueryInterface(IID_ITask, (void **) &pITask);
    if (FAILED(hr))
    {
        if (bShowErrors) {
           LoadString(hInstApp, STR_ERRTS, szErrMsg, MAX_PATH);
           MSG_BOX_TSERR(hWndApp, szErrMsg);
        }
        pIU->Release();
        Cleanup();
        return FALSE;
    }

    // Cleanup pIUnknown, as we are done with it.

    pIU->Release();
    pIU = NULL;

    //
    // If this is for NT we need to get and set the user account
    // information.   ITask::SetAccountInformation
    //

    if (IsPlatformNT())
    {

        szUserName[0] = TEXT('\0');    // global user name string
        szPassword[0] = TEXT('\0');    // global password string

        // Prompt for the user name and password
        //
        // Password dialog returns:
        //      -1 if DialogBox() fails
        //       0 if user cancels
        //       1 if PW entered OK

        iResult = 0;
        iResult = DialogBox(hInstApp,
                            MAKEINTRESOURCE(DLG_PASSWORD),
                            hWndApp,
                            PasswordDlgProc);

        if (iResult < 1)
        {
           // Either the password dialog failed or the user Canceled
           // it so bail out.
           pITask->Release();
           Cleanup();
           return FALSE;
        }

#ifndef UNICODE

        // No UNICODE so we need to convert from ANSI to WCHAR before
        // calling SetAccountInformation

        MultiByteToWideChar(uCodePage, 0, szUserName, -1,
                                             szUserNameW, MAX_PATH);

        MultiByteToWideChar(uCodePage, 0, szPassword, -1,
                                             szPasswordW, MAX_PATH);

        hr = pITask->SetAccountInformation(szUserNameW, szPasswordW);

#else
        // UNICODE so no need to convert strings

        hr = pITask->SetAccountInformation(szUserName, szPassword);

#endif  // UNICODE

        if (FAILED(hr))
        {
           if (bShowErrors) {
              LoadString(hInstApp, STR_ERRTS, szErrMsg, MAX_PATH);
              MSG_BOX_TSERR(hWndApp, szErrMsg);
           }
           pITask->Release();
           Cleanup();
           return FALSE;
        }

    }  // IsPlatformNT


    // Set command name with ITask::SetApplicationName

#ifndef UNICODE
    // No UNICODE so need to convert string to WIDE

    MultiByteToWideChar(uCodePage, 0, lpszThemesExe, -1,
                                             szThemesExeW, MAX_PATH);

    hr = pITask->SetApplicationName(szThemesExeW);
#else
    // UNICODE so no need to convert string

    hr = pITask->SetApplicationName(lpszThemesExe);
#endif

    if (FAILED(hr))
    {
        if (bShowErrors) {
           LoadString(hInstApp, STR_ERRTS, szErrMsg, MAX_PATH);
           MSG_BOX_TSERR(hWndApp, szErrMsg);
        }
        pITask->Release();
        Cleanup();
        return FALSE;
    }

    // Set task parameters with ITask::SetParameters

    hr = pITask->SetParameters(szRotateCommandW);
    if (FAILED(hr))
    {
        if (bShowErrors) {
           LoadString(hInstApp, STR_ERRTS, szErrMsg, MAX_PATH);
           MSG_BOX_TSERR(hWndApp, szErrMsg);
        }
        pITask->Release();
        Cleanup();
        return FALSE;
    }

    // Set the comment, so we know how this job got there
    // Uses ITask::SetComment

#ifndef UNICODE
    // No UNICODE so convert to WIDE

    MultiByteToWideChar(uCodePage, 0, szJobComment, -1,
                                             szJobCommentW, MAX_PATH);


    hr = pITask->SetComment(szJobCommentW);
#else
    // UNICODE so no need to convert string

    hr = pITask->SetComment(szJobComment);
#endif

    if (FAILED(hr))
    {
        if (bShowErrors) {
           LoadString(hInstApp, STR_ERRTS, szErrMsg, MAX_PATH);
           MSG_BOX_TSERR(hWndApp, szErrMsg);
        }
        pITask->Release();
        Cleanup();
        return FALSE;
    }

    // Set the flags on the task object
    // Use ITask::SetFlags

    dwTaskFlags = NULL;
    hr = pITask->SetFlags(dwTaskFlags);
    if (FAILED(hr))
    {
        if (bShowErrors) {
           LoadString(hInstApp, STR_ERRTS, szErrMsg, MAX_PATH);
           MSG_BOX_TSERR(hWndApp, szErrMsg);
        }
        pITask->Release();
        Cleanup();
        return FALSE;
    }

    // Now, create a trigger to run the task at our specified time.
    // Uses ITask::CreateTrigger()

    hr = pITask->CreateTrigger(&wTrigNumber, &pITaskTrig);
    if (FAILED(hr))
    {
        if (bShowErrors) {
           LoadString(hInstApp, STR_ERRTS, szErrMsg, MAX_PATH);
           MSG_BOX_TSERR(hWndApp, szErrMsg);
        }
        pITask->Release();
        Cleanup();
        return FALSE;
    }

    // Now, fill in the trigger as necessary.

    GetLocalTime(&LocalTime);

    if (12 == LocalTime.wMonth) {
        LocalTime.wMonth = 1;
        LocalTime.wYear++;
    }
    else LocalTime.wMonth++;

    dwTrigFlags = 0;

    TaskTrig.cbTriggerSize = sizeof(TASK_TRIGGER);
    TaskTrig.Reserved1 = 0;
    TaskTrig.wBeginYear = LocalTime.wYear;
    TaskTrig.wBeginMonth = LocalTime.wMonth;
    TaskTrig.wBeginDay = 1;
    TaskTrig.wEndYear = 0;
    TaskTrig.wEndMonth = 0;
    TaskTrig.wEndDay = 0;
    TaskTrig.wStartHour = 14;
    TaskTrig.wStartMinute = 0;
    TaskTrig.MinutesDuration = 0;
    TaskTrig.MinutesInterval = 0;
    TaskTrig.rgFlags = dwTrigFlags;
    TaskTrig.TriggerType = TASK_TIME_TRIGGER_MONTHLYDATE;
    TaskTrig.Type.MonthlyDate.rgfDays = 1;
    TaskTrig.Type.MonthlyDate.rgfMonths = EVERY_MONTH;
    TaskTrig.wRandomMinutesInterval = 0;
    TaskTrig.Reserved2 = 0;

    // Add this trigger to the task using ITaskTrigger::SetTrigger

    hr = pITaskTrig->SetTrigger(&TaskTrig);
    if (FAILED(hr))
    {
        if (bShowErrors) {
           LoadString(hInstApp, STR_ERRTS, szErrMsg, MAX_PATH);
           MSG_BOX_TSERR(hWndApp, szErrMsg);
        }
        pITaskTrig->Release();
        pITask->Release();
        Cleanup();
        return FALSE;
    }

    // Make the changes permanent
    // Requires using IPersistFile::Save()

    hr = pITask->QueryInterface(IID_IPersistFile, (void **) &pIPF);
    if (FAILED(hr))
    {
        if (bShowErrors) {
           LoadString(hInstApp, STR_ERRTS, szErrMsg, MAX_PATH);
           MSG_BOX_TSERR(hWndApp, szErrMsg);
        }
        pITaskTrig->Release();
        pITask->Release();
        Cleanup();
        return FALSE;
    }

    hr = pIPF->Save(NULL, FALSE);
    if (FAILED(hr))
    {
        if (bShowErrors) {
           LoadString(hInstApp, STR_ERRTS, szErrMsg, MAX_PATH);
           MSG_BOX_TSERR(hWndApp, szErrMsg);
        }
        pITaskTrig->Release();
        pITask->Release();
        pIPF->Release();
        Cleanup();
        return FALSE;
    }

    // We no longer need ITask

    pITask->Release();
    pITask = NULL;

    // Done with ITaskTrigger pointer

    pITaskTrig->Release();
    pITaskTrig = NULL;

    // Done with IPersistFile

    pIPF->Release();
    pIPF = NULL;
    Cleanup();

    // Finally -- we have successfully added the task but we need to
    // make sure that Task Scheduler is in the RunServices branch of
    // the registry so it will start every time.
    hKey = NULL;
    lret = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                          szRunServices,
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          KEY_WRITE,
                          NULL,
                          &hKey,
                          &dwDisposition);

    if (lret == ERROR_SUCCESS) {
       // RegDeleteValue(hKey, szScheduler);
       lret = RegSetValueEx(hKey,
                            szScheduler,
                            0,
                            REG_SZ,
                            (CONST BYTE *)szMSTask,
                            (SZSIZEINBYTES(szMSTask) + 1));
    }

    if (hKey) RegCloseKey(hKey);

    return TRUE;
}

extern "C" BOOL HandDeleteThemesTask()
{
    TCHAR szJobFile[MAX_PATH];  // Full path to %windir%\Tasks\Themes.job
    TCHAR szDefaultJobName[MAX_PATH];

    if (!GetWindowsDirectory(szJobFile, MAX_PATH)) return FALSE;
    lstrcat(szJobFile, TEXT("\\Tasks\\\0"));
    LoadString(hInstApp, STR_JOB_NAME, szDefaultJobName, MAX_PATH);
    // If this is NT we need to append the user profile name onto the
    // end of this task.

    if (IsPlatformNT()) BuildNTJobName(szDefaultJobName);
    lstrcat(szJobFile, szDefaultJobName);
    DeleteFile(szJobFile);
    return TRUE;
}

//---------------------------------------------------------------------------
//  GetUserToken - Gets the current process's user token and returns
//                        it. It can later be free'd with LocalFree.
//---------------------------------------------------------------------------
PTOKEN_USER GetUserToken(HANDLE hUser)
{
    PTOKEN_USER pUser;
    DWORD dwSize = 64;
    HANDLE hToClose = NULL;

    if (hUser == NULL)
    {
        OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hUser);
        hToClose = hUser;
    }

    pUser = (PTOKEN_USER)LocalAlloc(LPTR, dwSize);
    if (pUser)
    {
        DWORD dwNewSize;
        BOOL fOk = GetTokenInformation(hUser, TokenUser, pUser, dwSize, &dwNewSize);
        if (!fOk && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
        {
            LocalFree((HLOCAL)pUser);

            pUser = (PTOKEN_USER)LocalAlloc(LPTR, dwNewSize);
            if (pUser)
            {
                fOk = GetTokenInformation( hUser, TokenUser, pUser, dwNewSize, &dwNewSize);
            }
        }
        if (!fOk)
        {
            LocalFree((HLOCAL)pUser);
            pUser = NULL;
        }
    }

    if (hToClose)
        CloseHandle(hToClose);

    return pUser;
}

//----------------------------------------------------------------------------
//  GetCurrentUser - Fills in a buffer with the unique name that we are using
//                   for the currently logged on user.  On NT, this name is
//                   used for the name of the profile directory and for the
//                   name of the per-user recycle bin directory on a security
//                   aware drive.
//
//  Parameters:
//                   lpAccountName -- buffer to receive user account name
//                   lpDomainName -- buffer to receive domain name
//                   lpProfilePath -- receives fully qualified path to user's
//                                    profile directory.  If the caller does
//                                    not want the profile path NULL may be
//                                    passed in for this parameter.
//----------------------------------------------------------------------------
extern "C" BOOL GetCurrentUser(LPTSTR lpAccountName, DWORD cchAcctSize,
                               LPTSTR lpDomainName, DWORD cchDomSize,
                               LPTSTR lpProfilePath, DWORD cchProfSize)
{
    PTOKEN_USER     pUser;
    LPTSTR          pTextSid = 0;
    DWORD           cbBytes;
    SID_NAME_USE    SNU;
    HANDLE          hUser;

    // Take the easy outs -- no NULL parms for first four.
    if (!lpAccountName || !lpDomainName || !&cchAcctSize || !&cchDomSize) return FALSE;

    // Initialize these strings to NULL.
    *lpAccountName = 0;
    *lpDomainName = 0;

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hUser))
    {
       return FALSE;
    }

    pUser = GetUserToken(hUser);

    CloseHandle(hUser);

    if (!pUser)
       return FALSE;

    if (!IsValidSid(pUser->User.Sid))
    {
       LocalFree(pUser);
       return FALSE;
    }

    if (!LookupAccountSid(NULL,
                         pUser->User.Sid,
                         lpAccountName,
                         &cchAcctSize,
                         lpDomainName,
                         &cchDomSize,
                         &SNU))
    {
       // LookupAccountSid failed
       LocalFree(pUser);
       return FALSE;
    }

    // Does the caller want the profile path?

    if (!lpProfilePath)
    {
       // No, so cleanup and hit the road.
       LocalFree(pUser);
       return TRUE;
    }

    // Have the Account and Domain Name.  Next we need to get
    // a text based SID so we can lookup the profile path in
    // the registry.

    // First let's find out how big a buffer we need for the
    // text Sid.

    *lpProfilePath = 0;
    cbBytes = 0;
    if ((!GetTextualSid(pUser->User.Sid, pTextSid, &cbBytes)) &&
        (ERROR_INSUFFICIENT_BUFFER == GetLastError()))
    {
       pTextSid = (LPTSTR)LocalAlloc(LPTR, cbBytes);
       if (!pTextSid)
       {
          LocalFree(pUser);
          return FALSE;
       }

       if (!GetTextualSid(pUser->User.Sid, pTextSid, &cbBytes))
       {
          LocalFree(pUser);
          return FALSE;
       }
    }
    else
    {
       // Failed to get a text SID so we're outta here.
       LocalFree((HLOCAL)pUser);
       return FALSE;
    }

    // OK, now we should have a text-based SID.  Used this to find
    // the profilepath in the registry.

    if (pTextSid)
    {
       HKEY hkeyProfileList;

       // Open the registry and find the appropriate name

       LONG lStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"), 0,
                                   KEY_READ, &hkeyProfileList);

       if (lStatus == ERROR_SUCCESS)
       {
          HKEY hkeyUser;
          lStatus = RegOpenKeyEx(hkeyProfileList, pTextSid, 0, KEY_READ, &hkeyUser);
          if (lStatus == ERROR_SUCCESS)
          {
             DWORD dwType;
             cbBytes = (cchProfSize * sizeof(TCHAR));

             // First check for a "ProfileName" key

             lStatus = RegQueryValueEx(hkeyUser, TEXT("ProfileName"), NULL, &dwType,
                                       (LPBYTE)lpProfilePath, &cbBytes);

             if (lStatus == ERROR_SUCCESS && (dwType == REG_SZ || dwType == REG_EXPAND_SZ))
             {
                // We're good to go.
                LocalFree(pUser);
                LocalFree(pTextSid);
                RegCloseKey(hkeyProfileList);
                RegCloseKey(hkeyUser);
                return TRUE;
             }
             else
             {
                // Otherwise, grab the "ProfilePath" and get the last part of the name
                cbBytes = (cchProfSize * sizeof(TCHAR));

                lStatus = RegQueryValueEx(hkeyUser,TEXT("ProfileImagePath"), NULL, &dwType,
                                          (LPBYTE)lpProfilePath, &cbBytes);

                if (lStatus == ERROR_SUCCESS && (dwType == REG_SZ || dwType == REG_EXPAND_SZ))
                {
                   // Return just the directory name portion of the profile path
                   //lstrcpyn(lpBuff, PathFindFileName(lpProfilePath), iSize);

                   LocalFree(pUser);
                   LocalFree(pTextSid);
                   RegCloseKey(hkeyProfileList);
                   RegCloseKey(hkeyUser);
                   return TRUE;
                }
                else
                {
                   // Have exhausted our resources -- can't get the
                   // profile path.
                   LocalFree(pUser);
                   LocalFree(pTextSid);
                   RegCloseKey(hkeyProfileList);
                   RegCloseKey(hkeyUser);
                   return FALSE;
                }
             }
          }
          else
          {
             // Couldn't open reg key so we're hosed
             LocalFree(pUser);
             LocalFree(pTextSid);
             RegCloseKey(hkeyProfileList);
             return FALSE;
          }
       }

       LocalFree(pUser);
       LocalFree(pTextSid);

    }
    else
    {
       // For some completely unknown reason we have a NULL Sid string
       // so we're doomed.
       LocalFree(pTextSid);
       return FALSE;
    }

    // We should never fall through to this point but if we do...
    return FALSE;
}

//+--------------------------------------------------------------------------
//
// Function:        GetTextualSid()
//
// Synopsis:        WINNT only -- converts a SID to text.
//
// Returns:         TRUE if successful, FALSE if not.
//                  Sets LastError on failure.
//
// Taken from the January 1998 MSDN reference.
//
//---------------------------------------------------------------------------


BOOL GetTextualSid( PSID pSid,             // binary Sid
                    LPTSTR TextualSid,     // buffer for Textual representation of Sid
                    LPDWORD lpdwBufferLen) // required/provided TextualSid buffersize
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwSidRev=SID_REVISION;
    DWORD dwCounter;
    DWORD dwSidSize;

    // Validate the binary SID.
    if(!IsValidSid(pSid))
    {
       SetLastError(ERROR_INVALID_PARAMETER);
       return FALSE;
    }

    // Get the identifier authority value from the SID.
    psia = GetSidIdentifierAuthority(pSid);

    // Get the number of subauthorities in the SID.
    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    // Compute the buffer length.
    // S-SID_REVISION- + IdentifierAuthority- + subauthorities- + NULL
    dwSidSize=(15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

    // Check input buffer length.
    // If too small, indicate the proper size and set last error.
    if (*lpdwBufferLen < dwSidSize)
    {
       *lpdwBufferLen = dwSidSize;
       SetLastError(ERROR_INSUFFICIENT_BUFFER);
       return FALSE;
    }

    // Add 'S' prefix and revision number to the string.
    dwSidSize=wsprintf(TextualSid, TEXT("S-%lu-"), dwSidRev );

    // Add SID identifier authority to the string.
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )
    {
       dwSidSize+=wsprintf(TextualSid + lstrlen(TextualSid),
                   TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                   (USHORT)psia->Value[0],
                   (USHORT)psia->Value[1],
                   (USHORT)psia->Value[2],
                   (USHORT)psia->Value[3],
                   (USHORT)psia->Value[4],
                   (USHORT)psia->Value[5]);
    }
    else
    {
       dwSidSize+=wsprintf(TextualSid + lstrlen(TextualSid),
                   TEXT("%lu"),
                   (ULONG)(psia->Value[5]      )   +
                   (ULONG)(psia->Value[4] <<  8)   +
                   (ULONG)(psia->Value[3] << 16)   +
                   (ULONG)(psia->Value[2] << 24)   );
    }

    // Add SID subauthorities to the string.
    //

    for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)
    {
       dwSidSize+=wsprintf(TextualSid + dwSidSize, TEXT("-%lu"),
       *GetSidSubAuthority(pSid, dwCounter) );
    }

    SetLastError(ERROR_INSUFFICIENT_BUFFER);
    return TRUE;
}

extern "C" VOID BuildNTJobName(LPTSTR lpJobName)
{
  TCHAR szUser[MAX_PATH];
  TCHAR szDomain[MAX_PATH];
  TCHAR szProfile[MAX_PATH];
  LPTSTR Current;
  LPTSTR Dot;

  if (!lpJobName) return;  // Null pointers not allowed.

  if (!GetCurrentUser(szUser, ARRAYSIZE(szUser),
                      szDomain, ARRAYSIZE(szDomain),
                      szProfile, ARRAYSIZE(szProfile)))
  {
     // GetCurrentUser failed so bail out.
     return;
  }
  // Walk to the end of the lpJobName string
  Dot = lpJobName;
  while (*Dot) Dot = CharNext(Dot);

  // Dot now points to the end of the lpJobName string.  Backup until
  // we get to the "dot" in the extension.

  Dot = CharPrev(lpJobName, Dot);
  while ((Dot > lpJobName) && (*Dot != TEXT('.'))) Dot = CharPrev(lpJobName, Dot);

  // Ok truncate the extension by putting a NULL on the "dot".
  *Dot = TEXT('\0');

  // Walk to the end of the szProfile string
  Current = szProfile;
  while (*Current) Current = CharNext(Current);

  // Current now points to the end of szProfile.  Backup until we get
  // to the first "\".

  Current = CharPrev(szProfile, Current);
  while ((Current > szProfile) && (*Current != TEXT('\\'))) Current = CharPrev(szProfile, Current);

  *Current = TEXT('(');

  lstrcat(lpJobName, TEXT(" "));
  lstrcat(lpJobName, Current);
  lstrcat(lpJobName, TEXT(").JOB"));
}


extern "C" BOOL IsUserAdmin(VOID)

/*++

Routine Description:

    This routine returns TRUE if the caller's process is a
    member of the Administrators local group.

    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.

Arguments:

    None.

Return Value:

    TRUE - Caller has Administrators local group.

    FALSE - Caller does not have Administrators local group.

--*/

{
    HANDLE Token;
    DWORD BytesRequired;
    PTOKEN_GROUPS Groups;
    BOOL b;
    DWORD i;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup;

    //
    // On non-NT platforms the user is administrator.
    //
    if(!IsPlatformNT()) {
        return(TRUE);
    }

    //
    // Open the process token.
    //
    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&Token)) {
        return(FALSE);
    }

    b = FALSE;
    Groups = NULL;

    //
    // Get group information.
    //
    if (!GetTokenInformation(Token,TokenGroups,NULL,0,&BytesRequired)
        && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        && (Groups = (PTOKEN_GROUPS)LocalAlloc(LPTR,BytesRequired))
        && GetTokenInformation(Token,TokenGroups,Groups,BytesRequired,&BytesRequired))
    {

        b = AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0,
                &AdministratorsGroup
                );

        if (b) {

            //
            // See if the user has the administrator group.
            //
            b = FALSE;
            for(i=0; i<Groups->GroupCount; i++) {
                if(EqualSid(Groups->Groups[i].Sid,AdministratorsGroup)) {
                    b = TRUE;
                    break;
                }
            }

            FreeSid(AdministratorsGroup);
        }
    }

    //
    // Clean up and return.
    //

    if(Groups) {
        LocalFree((HLOCAL)Groups);
    }

    CloseHandle(Token);

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=themes
TARGETPATH=obj
TARGETTYPE=PROGRAM

SOURCES=          \
    ..\adutil.cpp \
    ..\schedule.cpp \
    ..\htmlprev.cpp \
    ..\frost.rc   \
    ..\cb.c       \
    ..\init.c     \
    ..\regutils.c \
    ..\savedlg.c  \
    ..\etcdlg.c   \
    ..\utils.c    \
    ..\bkgdutil.c \
    ..\fakewin.c  \
    ..\nc.c       \
    ..\frost.c    \
    ..\bkgd.c     \
    ..\icons.c    \
    ..\loadimag.c \
    ..\halftone.c \
    ..\dither.c

MSC_WARNING_LEVEL=/W3 /WX

UMTYPE=windows
UMENTRY=winmain

USE_MSVCRT=1

TARGETLIBS= \
    $(WINDOWS_LIB_PATH)\user32p.lib  \
    $(SDK_LIB_PATH)\comdlg32.lib  \
    $(SDK_LIB_PATH)\shell32.lib   \
    $(SDK_LIB_PATH)\ole32.lib     \
    $(SDK_LIB_PATH)\uuid.lib      \
    $(SDK_LIB_PATH)\comctl32.lib  \
    $(SDK_LIB_PATH)\winmm.lib     \
    $(SDK_LIB_PATH)\mpr.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\tools\clipdump\clipdump.c ===
#include <windows.h>
#include <stdio.h>


char achLine[17];

void Dump( PBYTE pb, DWORD cb ) {
    DWORD i, j;


    for( i = 0; i < cb; i += 16 ) {
        printf( "%04X  ", (int)i );
        FillMemory( achLine, sizeof(achLine), 0);

        for( j = 0; j < 16; j++ ) {
            BYTE b;

            if (i+j >= cb) {
                break;
            }
            printf( "%02X ", (b = pb[i+j]) );
            achLine[j] = b >= ' ' ? b : '.';
        }

        achLine[j] = '\0';
        printf(  "  #%s#\n", achLine );

    }

}

TCHAR gszName[MAX_PATH];

LPTSTR MakeCFFmtName( UINT i ) {

    switch( i ) {
    case CF_TEXT:           lstrcpy( gszName, "CF_TEXT");              break;
    case CF_BITMAP:         lstrcpy( gszName, "CF_BITMAP");            break;
    case CF_METAFILEPICT:   lstrcpy( gszName, "CF_METAFILEPICT");      break;
    case CF_SYLK:           lstrcpy( gszName, "CF_SYLK");              break;
    case CF_DIF:            lstrcpy( gszName, "CF_DIF");               break;
    case CF_TIFF:           lstrcpy( gszName, "CF_TIFF");              break;
    case CF_OEMTEXT:        lstrcpy( gszName, "CF_OEMTEXT");           break;
    case CF_DIB:            lstrcpy( gszName, "CF_DIB");               break;
    case CF_PALETTE:        lstrcpy( gszName, "CF_PALETTE");           break;
    case CF_PENDATA:        lstrcpy( gszName, "CF_PENDATA");           break;
    case CF_RIFF:           lstrcpy( gszName, "CF_RIFF");              break;
    case CF_WAVE:           lstrcpy( gszName, "CF_WAVE");              break;
    case CF_UNICODETEXT:    lstrcpy( gszName, "CF_UNICODETEXT");       break;
    case CF_ENHMETAFILE:    lstrcpy( gszName, "CF_ENHMETAFILE");       break;
    case CF_HDROP:          lstrcpy( gszName, "CF_HDROP");             break;
    case CF_LOCALE:         lstrcpy( gszName, "CF_LOCALE");            break;
    case CF_MAX:            lstrcpy( gszName, "CF_MAX");               break;
    case CF_OWNERDISPLAY:   lstrcpy( gszName, "CF_OWNERDISPLAY");      break;
    case CF_DSPTEXT:        lstrcpy( gszName, "CF_DSPTEXT");           break;
    case CF_DSPBITMAP:      lstrcpy( gszName, "CF_DSPBITMAP");         break;
    case CF_DSPMETAFILEPICT:lstrcpy( gszName, "CF_DSPMETAFILEPICT");   break;
    case CF_DSPENHMETAFILE: lstrcpy( gszName, "CF_DSPENHMETAFILE");    break;

    default:
        gszName[0] = TEXT('\0');
        GetClipboardFormatName(i, gszName, sizeof(gszName) / sizeof(TCHAR));
        break;
    }

    return gszName;
}

void
__cdecl
main(
    int cArgs,
    char **szArg
    )
{
    UINT iCF = 0;
    UINT iRet = 0;
    LPTSTR szName;

    if( cArgs > 1 && (
            (*szArg[1] == '-' || *szArg[1] == '/') &&
            (szArg[1][1] == '?' || lstrcmpi(&(szArg[1][1]), "help") == 0) ) ) {
        fprintf( stderr, "usage: dumpclip [\"clipboard format\"]\n" );
        ExitProcess((DWORD)-1);
    }


    OpenClipboard(NULL);

    for( iCF = EnumClipboardFormats( 0 ); iCF != 0; iCF = EnumClipboardFormats( iCF ) ) {
        HANDLE hClipData;
        PVOID pData;

        szName = MakeCFFmtName(iCF);

        if (cArgs == 1 || lstrcmpi(szArg[1], szName) == 0 ) {

            hClipData = GetClipboardData(iCF);

            pData = GlobalLock(hClipData);

            printf( "\n%s format:\n", szName );
            Dump( pData, (DWORD)GlobalSize(hClipData) );

            GlobalUnlock(hClipData);
            printf( "\n" );
        }
    }

    CloseClipboard();

    ExitProcess(iRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\utils.c ===
/* UTILS.C
   Resident Code Segment      // Tweak: make non-resident?

   NoMem string utility routines
   String utility routines

   Frosting: Master Theme Selector for Windows '95
   Copyright (c) 1994-1999 Microsoft Corporation.  All rights reserved.
*/

// ---------------------------------------------
// Brief file history:
// Alpha:
// Beta:
// Bug fixes
// ---------
//
// ---------------------------------------------

#include "windows.h"
#include "frost.h"
#include "global.h"

// Local Routines 

// Local global vars
TCHAR szNoMem[NUM_NOMEM_STRS][MAX_STRLEN+1];


// InitNoMem
//
// Stores all the no/low memory error messages in the data segment,
// so you're guaranteed to have them when you need them.
//
// Called at init, when we are assured these loads succeed.
//
// Note that this loop shows why the string IDs for the low mem
// messages need to be consecutive and starting with STR_NOT_ENUF,
// as noted in the .H file.
//

void FAR InitNoMem(hinst)
HANDLE hinst;
{
   int iter;

   for (iter = 0; iter < NUM_NOMEM_STRS; iter++)
      LoadString(hinst, STR_NOT_ENUF+iter,
                 &(szNoMem[iter][0]), MAX_STRLEN);
}


// NoMemMsg
//
// Takes the low memory error string suffix, creates the full string, posts
// a messagebox. We are assured of being able to get a messagebox in low
// memory situations with at least a hand icon.
//
// Note that the second line shows why the string IDs for the low mem
// messages need to be consecutive and starting with STR_NOT_ENUF,
// as noted in the .H file.
//
 
void FAR NoMemMsg(istr)
int istr;
{
   lstrcpy( (LPTSTR)szMsg, (LPCTSTR)&(szNoMem[0][0]) );
   lstrcat( (LPTSTR)szMsg, (LPCTSTR)&(szNoMem[istr-STR_NOT_ENUF][0]) );

   MessageBox((HWND)hWndApp, (LPCTSTR)szMsg, (LPCTSTR)szAppName,
              MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL);
}


/*=============================================================================
 FILEFROMPATH returns the filename of given filename which may include path.
 Q: International: always same chars for \ and :, or should we do a string
 compare with a resource string for each?
 Q: International: does lstrlen return chars or bytes to make the first line
 work or not?
=============================================================================*/
LPTSTR FAR FileFromPath(lpsz)
LPCTSTR lpsz;
{
   LPTSTR lpch;

   /* Strip path/drive specification from name if there is one */
   lpch = CharPrev((LPCTSTR)lpsz, (LPCTSTR)(lpsz + lstrlen(lpsz)));
   while (lpch > lpsz) {
      lpch = CharPrev((LPCTSTR)lpsz, (LPCTSTR)lpch);
      if (*lpch == TEXT('\\') || *lpch == TEXT(':')) {
         lpch = CharNext((LPCTSTR)lpch);
         break;
      }
   }
   return(lpch);

} /* end FileFromPath */      // JUST FOR INIT DEBUG

// TruncateExt
//
// Utility routine that removes extension from filename
// See International questions above routine.
//
void FAR TruncateExt(LPCTSTR lpstr)
{
   LPTSTR lpch;

   // find the dot before the extension, truncate from there if found
   lpch = CharPrev((LPCTSTR)lpstr, (LPCTSTR)(lpstr + lstrlen(lpstr)));
   while (lpch > lpstr) {
      lpch = CharPrev((LPCTSTR)lpstr, (LPCTSTR)lpch);
      if (*lpch == TEXT('.')) {
         *lpch = 0;           // null terminate
         break;               // you're done now EXIT loop
      }
   }
}



//
// FindChar
//
// Subset of a substring search. Just looks for first instance of a single
// character in a string.
//
// Returns: pointer into string you passed, or to its null term if not found
//
LPTSTR FAR FindChar(LPTSTR lpszStr, TCHAR chSearch)
{
   LPTSTR lpszScan;

   for (lpszScan = lpszStr;
        *lpszScan && (*lpszScan != chSearch);   // ***DEBUG*** char compare in intl?
        lpszScan = CharNext(lpszScan))
      { }

   // cleanup
   return (lpszScan);               // either points to null term or search char
}


//
// ascii to integer conversion routine
//

// ***DEBUG*** int'l: is this true? 
// These don't need to be UNICODE/international ready, since they
// *only* deal with strings from the Registry and our own private
// INI files.

/* CAREFUL!! This atoi just IGNORES non-numerics like decimal points!!! */
/* checks for (>=1) leading negative sign */
int FAR latoi( s )
LPSTR s;
{
   int n;
   LPSTR pS;
   BOOL bSeenNum;
   BOOL bNeg;

   n=0;
   bSeenNum = bNeg = FALSE;

   for (pS=s; *pS; pS++) {
      if ((*pS >= '0') && (*pS <= '9')) {
         bSeenNum = TRUE;
         n = n*10 + (*pS - '0');
      }
      if (!bSeenNum && (*pS == '-')) {
         bNeg = TRUE;
      }
   }

   if (bNeg) {
      n = -n;
   }
   
   return(n);
}


void lreverse( s )
LPSTR s;
{
    LPSTR p1, p2;
    char c;

    p1 = s;
    p2 = (LPSTR)(p1+ lstrlenA((LPSTR) p1 ) - 1 );

    while( p1 < p2 ) {
        c = *p1;
        *p1++ = *p2;
        *p2-- = c;
    }
}

VOID FAR litoa( n, s )
int n;
LPSTR s;
{
    LPSTR pS;
    BOOL bNeg = FALSE;

    if (n < 0) {
        n = -n;
        bNeg = TRUE;
    }
    pS = s;
    do {
        *pS = n % 10 + '0';
        pS++;
    } while ( (n /= 10) != 0 );

    if (bNeg) {
        *pS = '-';
        pS++;
    }
    *pS = '\0';
    lreverse( s );
}

//
// LongToShortToLong
//
// Can take either as input (?).
// Output string has to be long enough (14 or MAX_PATH)
//
// OK for input and output to be the same string.
// 
// Returns: success in finding file

BOOL FAR FilenameToShort(LPTSTR lpszInput, LPTSTR lpszShort)
{
   WIN32_FIND_DATA wfdFind;
   HANDLE hFind;

   // init
   hFind = FindFirstFile(lpszInput, (LPWIN32_FIND_DATA)&wfdFind);
   if (INVALID_HANDLE_VALUE == hFind) {
      *lpszShort = 0;               // error null return
      return (FALSE);               // couldn't find file EXIT
   }

   // meat
   if (wfdFind.cAlternateFileName[0])
      lstrcpy(lpszShort, (LPTSTR)wfdFind.cAlternateFileName);
   else
      // sometimes no alternate given; e.g. if short == long
      lstrcpy(lpszShort, (LPTSTR)wfdFind.cFileName);

   // cleanup
   FindClose(hFind);
   Assert(*lpszShort, TEXT("no short filename constructed!\n"))
   return (*lpszShort);
}

BOOL FAR FilenameToLong(LPTSTR lpszInput, LPTSTR lpszLong)
{
   WIN32_FIND_DATA wfdFind;
   HANDLE hFind;

   // init
   hFind = FindFirstFile(lpszInput, (LPWIN32_FIND_DATA)&wfdFind);
   if (INVALID_HANDLE_VALUE == hFind) {
      *lpszLong = 0;                // error null return
      return (FALSE);               // couldn't find file EXIT
   }

   // meat 
   if (wfdFind.cFileName[0])
      lstrcpy(lpszLong, (LPTSTR)wfdFind.cFileName);
   else 
      // sometimes no long name given; e.g. if funny old file
      lstrcpy(lpszLong, (LPTSTR)wfdFind.cAlternateFileName);

   // cleanup
   FindClose(hFind);
   Assert(*lpszLong, TEXT("no long filename constructed!\n"))
   return (*lpszLong);
}


//
// IsValidThemeFile
//
// Answers the question.
//
BOOL FAR IsValidThemeFile(LPTSTR lpTest)
{
   extern TCHAR szFrostSection[], szMagic[], szVerify[];

   GetPrivateProfileString((LPTSTR)szFrostSection,
                           (LPTSTR)szMagic,
                           (LPTSTR)szNULL,
                           (LPTSTR)szMsg, MAX_MSGLEN,
                           (LPTSTR)lpTest);

   return (!lstrcmp((LPTSTR)szMsg, (LPTSTR)szVerify));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\tools\fixlinks\fixlinks.c ===
#define UNICODE
#define _INC_OLE
#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>

#include <stdio.h>
#include <string.h>

void
FatalError(
    LPSTR Message,
    ULONG_PTR MessageParameter1,
    ULONG_PTR MessageParameter2
    )
{
    if (Message != NULL) {
        fprintf( stderr, "FIXLINK: " );
        fprintf( stderr, Message, MessageParameter1, MessageParameter2 );
        fprintf( stderr, "\n" );
        }

    exit( 1 );
}

void
Usage(
    LPSTR Message,
    ULONG MessageParameter
    )
{
    fprintf( stderr, "usage: FIXLINKS [-v] [-q] [-s SystemRoot | -S searchString replaceString]\n" );
    fprintf( stderr, "                [-r Directory | fileNames]\n" );
    fprintf( stderr, "where: -v specifies verbose output\n" );
    fprintf( stderr, "       -q specifies query only, no actual updating of link files\n" );
    fprintf( stderr, "       -s specifies the value to look for and replace with %%SystemRoot%%\n" );
    fprintf( stderr, "       -S specifies the value to look for and replace with replaceString\n" );
    fprintf( stderr, "       -r Directory specifies the root of a directory tree to\n" );
    fprintf( stderr, "          search for .LNK files to update.\n" );
    fprintf( stderr, "       fileNames specify one or more .LNK files to be updated\n" );

    //
    // No return from FatalError
    //

    if (Message != NULL) {
        fprintf( stderr, "\n" );
        }
    FatalError( Message, MessageParameter, 0 );
}

PWSTR
GetErrorMessage(
    DWORD MessageId
    )
{
    PWSTR Message, s;

    Message = NULL;
    FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM |
                     FORMAT_MESSAGE_ALLOCATE_BUFFER,
                   NULL,
                   MessageId,
                   0,
                   (PWSTR)&Message,
                   128,
                   (va_list *)NULL
                 );
    if (Message == NULL) {
        if (Message = (PWSTR)LocalAlloc( 0, 128 )) {
            swprintf( Message, L"Unable to get message for %08x", MessageId );
            }
        }
    else {
        s = wcsrchr( Message, L'\r' );
        if (s == NULL) {
            s = wcsrchr( Message, L'\n' );
            }

        if (s != NULL) {
            *s = UNICODE_NULL;
            }
        }

    return Message;
}


PWSTR
GetArgAsUnicode(
    LPSTR s
    )
{
    ULONG n;
    PWSTR ps;

    n = strlen( s );
    ps = HeapAlloc( GetProcessHeap(),
                    0,
                    (n + 1) * sizeof( WCHAR )
                  );
    if (ps == NULL) {
        FatalError( "Out of memory", 0, 0 );
        }

    if (MultiByteToWideChar( CP_ACP,
                             MB_PRECOMPOSED,
                             s,
                             n,
                             ps,
                             n
                           ) != (LONG)n
       ) {
        FatalError( "Unable to convert parameter '%s' to Unicode (%u)",
                    (ULONG_PTR)s,
                    GetLastError() );
        }

    ps[ n ] = UNICODE_NULL;
    return ps;
}


WCHAR SearchString[ MAX_PATH ];
ULONG cchSearchString;
WCHAR ReplaceString[ MAX_PATH ];
ULONG cchReplaceString;
WCHAR RootOfSearch[ MAX_PATH ];
BOOL VerboseFlag;
BOOL QueryFlag;

HRESULT
ProcessLinkFile(
    PWSTR FileName
    );

void
ProcessLinkFilesInDirectoryTree(
    PWSTR Directory
    );

__cdecl
main(
    int argc,
    char *argv[]
    )
{
    char *s;
    BOOL FileArgumentSeen = FALSE;
    PWSTR FileName;
    HRESULT Error;

    GetEnvironmentVariable( L"SystemRoot", SearchString, MAX_PATH );
    cchSearchString = wcslen( SearchString );
    if (cchSearchString == 0) {
        FatalError( "Unable to get value of SYSTEMROOT environment variable", 0, 0 );
        }
    wcscpy( ReplaceString, L"%SystemRoot%" );
    cchReplaceString = wcslen( ReplaceString );
    while (--argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch( tolower( *s ) ) {
                    case 'r':
                        if (--argc) {
                            GetFullPathName( GetArgAsUnicode( *++argv ),
                                             MAX_PATH,
                                             RootOfSearch,
                                             &FileName
                                           );
                            }
                        else {
                            Usage( "Missing parameter to -r switch", 0 );
                            }
                        break;

                    case 's':
                        if (--argc) {
                            wcscpy( SearchString, GetArgAsUnicode( *++argv ) );
                            }
                        else {
                            Usage( "Missing parameter to -%c switch", (ULONG)*s);
                            }

                        cchSearchString = wcslen( SearchString );
                        if (cchSearchString == 0) {
                            FatalError( "May not specify an empty search string", 0, 0 );
                            }

                        if (*s == 'S') {
                            if (--argc) {
                                wcscpy( ReplaceString, GetArgAsUnicode( *++argv ) );
                                }
                            else {
                                Usage( "Missing parameter to -S switch", 0 );
                                }

                            cchReplaceString = wcslen( ReplaceString );
                            if (cchSearchString == 0) {
                                FatalError( "May not specify an empty replacement string", 0, 0 );
                                }
                            }
                        break;

                    case 'q':
                        QueryFlag = TRUE;
                        break;

                    case 'v':
                        VerboseFlag = TRUE;
                        break;

                    default:
                        Usage( "Invalid switch -%c'", (ULONG)*s );
                    }
                }
            }
        else {

            if (wcslen( RootOfSearch )) {
                FatalError( "May not specify file names with -r option", 0, 0 );
                }

            FileArgumentSeen = TRUE;
            FileName = GetArgAsUnicode( s );
            if (FileName == NULL) {
                Error = (HRESULT)GetLastError();
                }
            else {
                Error = ProcessLinkFile( FileName );
                }

            if (Error != NO_ERROR) {
                FatalError( "Failed to load from file '%s' (%ws)",
                            (ULONG_PTR)s,
                            (ULONG_PTR)GetErrorMessage( Error )
                            );
                }
            }
        }

    if (!FileArgumentSeen) {
        if (wcslen( RootOfSearch )) {
            ProcessLinkFilesInDirectoryTree( RootOfSearch );
            }
        else {
            Usage( "No textFile specified", 0 );
            }
        }

    return 0;
}

HRESULT
ProcessLinkFile(
    PWSTR FileName
    )
{
    HRESULT rc;
    IShellLink *psl;
    IPersistFile *ppf;
    WCHAR szPath[ MAX_PATH ];
    WCHAR szNewPath[ MAX_PATH ];
    PWSTR s;
    BOOL FileNameShown;
    BOOL FileUpdated;

    if (FAILED(rc = CoInitialize( NULL )))
        return rc;

    rc = CoCreateInstance( &CLSID_ShellLink,
                           NULL,
                           CLSCTX_INPROC,
                           &IID_IShellLink,
                           &psl
                         );
    if (!SUCCEEDED( rc )) {
        FatalError( "Unable to create ShellLink instance (%ws)",
                    (ULONG_PTR)GetErrorMessage( rc ),
                    0
                    );
        }

    rc = (psl->lpVtbl->QueryInterface)( psl, &IID_IPersistFile, &ppf );
    if (!SUCCEEDED( rc )) {
        FatalError( "Unable to get ShellLink PersistFile interface (%ws)",
                    (ULONG_PTR)GetErrorMessage( rc ),
                    0
                    );
        ppf->lpVtbl->Release( ppf );
        }

    rc = (ppf->lpVtbl->Load)( ppf, FileName, STGM_READWRITE );
    if (!SUCCEEDED( rc )) {
        printf( "%ws: unable to get load link file (%ws)\n", FileName, GetErrorMessage( rc ) );
        ppf->lpVtbl->Release( ppf );
        psl->lpVtbl->Release( psl );
        return S_OK;
        }

    FileUpdated = FALSE;
    FileNameShown = FALSE;
    if (VerboseFlag) {
        printf( "%ws:\n", FileName );
        FileNameShown = TRUE;
        }

    rc = (psl->lpVtbl->GetPath)( psl, szPath, MAX_PATH, NULL, 0 );
    if (SUCCEEDED( rc )) {
        if (!_wcsnicmp( szPath, SearchString, cchSearchString )) {
            if (!FileNameShown) {
                printf( "%ws:\n", FileName );
                FileNameShown = TRUE;
                }
            printf( "    Path: %ws", szPath );
            wcscpy( szNewPath, ReplaceString );
            wcscat( szNewPath, &szPath[ cchSearchString ] );
            if (QueryFlag) {
                printf( " - would be changed to %ws\n", szNewPath );
                }
            else {
                rc = (psl->lpVtbl->SetPath)( psl, szNewPath );
                if (SUCCEEDED( rc )) {
                    printf( " - changed to %ws\n", szNewPath );
                    FileUpdated = TRUE;
                    }
                else {
                    printf( " - unable to modify (%ws)\n", GetErrorMessage( rc ) );
                    }
                }
            }
        else {
            if (VerboseFlag) {
                printf( "    Path: %ws\n", szPath );
                }
            }
        }
    else {
        ppf->lpVtbl->Release( ppf );
        psl->lpVtbl->Release( psl );
        printf( "    Unable to get ShellLink Path (%ws)\n", GetErrorMessage( rc ) );
        }

    rc = (psl->lpVtbl->GetWorkingDirectory)( psl, szPath, MAX_PATH );
    if (SUCCEEDED( rc )) {
        if (!_wcsnicmp( szPath, SearchString, cchSearchString )) {
            if (!FileNameShown) {
                printf( "%ws:\n", FileName );
                FileNameShown = TRUE;
                }
            printf( "    Working Directory: %ws", szPath );
            wcscpy( szNewPath, ReplaceString );
            wcscat( szNewPath, &szPath[ cchSearchString ] );
            if (QueryFlag) {
                printf( " - would be changed to %ws\n", szNewPath );
                }
            else {
                rc = (psl->lpVtbl->SetWorkingDirectory)( psl, szNewPath );
                if (SUCCEEDED( rc )) {
                    printf( " - changed to %ws\n", szNewPath );
                    FileUpdated = TRUE;
                    }
                else {
                    printf( " - unable to modify (%ws)\n", GetErrorMessage( rc ) );
                    }
                }
            }
        else {
            if (VerboseFlag) {
                printf( "    Working Directory: %ws\n", szPath );
                }
            }
        }
    else {
        ppf->lpVtbl->Release( ppf );
        psl->lpVtbl->Release( psl );
        printf( "    Unable to get ShellLink Working Directory (%ws)\n", GetErrorMessage( rc ) );
        }

    if (FileUpdated) {
        rc = (ppf->lpVtbl->Save)( ppf, FileName, TRUE );
        if (SUCCEEDED( rc )) {
            rc = (ppf->lpVtbl->SaveCompleted)( ppf, FileName );
            if (SUCCEEDED( rc )) {
                printf( "    Link file updated.\n" );
                }
            else {
                printf( "    **** unable to save changes to link file (%ws)\n", GetErrorMessage( rc ) );
                }
            }
        }

    ppf->lpVtbl->Release( ppf );
    psl->lpVtbl->Release( psl );
    return S_OK;
}

void
ProcessLinkFilesInDirectoryTree(
    PWSTR Directory
    )
{
    HANDLE FindHandle;
    WIN32_FIND_DATA FindData;
    WCHAR Path[ MAX_PATH ];
    PWSTR FileName;
    ULONG n;

    wcscpy( Path, Directory );
    FileName = &Path[ wcslen( Path ) ];
    *FileName++ = L'\\';
    wcscpy( FileName, L"*" );

    FindHandle = FindFirstFile( Path, &FindData );
    if (FindHandle == INVALID_HANDLE_VALUE) {
        return;
        }

    if (VerboseFlag) {
        printf( "%ws\n", Directory );
        }

    SetCurrentDirectory( Directory );
    do {
        if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            if (wcscmp( FindData.cFileName, L"." ) && wcscmp( FindData.cFileName, L".." )) {
                wcscpy( FileName, FindData.cFileName );
                ProcessLinkFilesInDirectoryTree( Path );
                }
            }
        else {
            n = wcslen( FindData.cFileName );
            while (n-- && FindData.cFileName[ n ] != L'.') {
                }

            if (!_wcsicmp( &FindData.cFileName[ n ], L".lnk" )) {
                wcscpy( FileName, FindData.cFileName );
                ProcessLinkFile( Path );
                }
            }
        }
    while (FindNextFile( FindHandle, &FindData ));

    FindClose( FindHandle );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\themes\themesw\schedule.h ===
// File:        schedule.h
//
// Contents:    Task Scheduler wrapper functions provided by SCHEDULE.CPP
//
// Microsoft Desktop Themes for Windows
// Copyright (c) 1998-1999 Microsoft Corporation.  All rights reserved.

// Task Scheduler functions provided by SCHEDULE.CPP

BOOL IsTaskSchedulerRunning();
BOOL StartTaskScheduler(BOOL);
BOOL IsThemesScheduled();
BOOL DeleteThemesTask();
BOOL AddThemesTask(LPTSTR, BOOL);
BOOL HandDeleteThemesTask();
BOOL IsPlatformNT();
BOOL GetCurrentUser(LPTSTR, DWORD, LPTSTR, DWORD, LPTSTR, DWORD);
BOOL IsUserAdmin();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\tools\lnkdump\lnkdump.c ===
#include <lnkdump.h>
#pragma hdrstop



void ReadString( HANDLE hFile, LPVOID * lpVoid, BOOL bUnicode )
{

    USHORT cch;
    DWORD  dwBytesRead;
    *lpVoid = NULL;

    if (bUnicode)
    {
        LPWSTR lpWStr = NULL;

        if (ReadFile( hFile, (LPVOID)&cch, sizeof(cch), &dwBytesRead, NULL ))
        {
            lpWStr = (LPWSTR)HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, (cch+1)*sizeof(WCHAR) );
            if (lpWStr) {
                if (ReadFile( hFile, (LPVOID)lpWStr, cch*sizeof(WCHAR), &dwBytesRead, NULL ))
                {
                    lpWStr[cch] = L'\0';
                    *lpVoid = lpWStr;
                }
            }
        }
    }
    else
    {
        LPSTR lpStr = NULL;

        if (ReadFile( hFile, (LPVOID)&cch, sizeof(cch), &dwBytesRead, NULL ))
        {
            lpStr = (LPSTR)HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, (cch+1) );
            if (lpStr) {
                if (ReadFile( hFile, (LPVOID)lpStr, cch, &dwBytesRead, NULL ))
                {
                    lpStr[cch] = '\0';
                    *lpVoid = lpStr;
                }
            }
        }
    }

}


int __cdecl main( int argc, char *argv[])
{
    HANDLE hFile;
    CShellLink csl;
    CShellLink * this = &csl;
    DWORD cbSize, cbTotal, cbToRead, dwBytesRead;
    SYSTEMTIME st;
    LPSTR pTemp = NULL;

    this->pidl = 0;
    this->pli = NULL;
    memset( this, 0, sizeof(CShellLink) );
    if (argc!=2)
    {
        printf("usage: lnkdump filename.lnk\n" );
        return(1);
    }


    // Try to open the file
    hFile = CreateFile( argv[1],
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                       );

    if (hFile == INVALID_HANDLE_VALUE)
    {
        printf( "lnkdump: unable to open file %s, err %d\n",
                argv[1],
                GetLastError()
               );
        return(1);
    }

    // Now, read out data...

    if (!ReadFile( hFile, (LPVOID)&this->sld, sizeof(this->sld), &dwBytesRead, NULL ))
        return (1);
    // read all of the members

    if (this->sld.dwFlags & SLDF_HAS_ID_LIST)
    {
        // Read the size of the IDLIST
        cbSize = 0; // need to zero out to get HIWORD 0 'cause USHORT is only 2 bytes
        if (!ReadFile( hFile, (LPVOID)&cbSize, sizeof(USHORT), &dwBytesRead, NULL ))
            return (1);
        if (cbSize)
        {
            SetFilePointer(hFile,cbSize,NULL,FILE_CURRENT);
        }
        else
        {
            printf( "Error readling PIDL out of link!\n" );
            return( 1 );
        }
    }

    // REARCHITECT: this part is not unicode ready, talk to daviddi

    if (this->sld.dwFlags & (SLDF_HAS_LINK_INFO))
    {
        LPVOID pli;

        if (!ReadFile( hFile, (LPVOID)&cbSize, sizeof(cbSize), &dwBytesRead, NULL ))
            return (1);

        if (cbSize >= sizeof(cbSize))
        {
            cbSize -= sizeof(cbSize);
            SetFilePointer(hFile,cbSize,NULL,FILE_CURRENT);
        }

    }

    if (this->sld.dwFlags & SLDF_HAS_NAME)
        ReadString( hFile, &this->pszName, this->sld.dwFlags & SLDF_UNICODE);
    if (this->sld.dwFlags & SLDF_HAS_RELPATH)
        ReadString( hFile, &this->pszRelPath, this->sld.dwFlags & SLDF_UNICODE);
    if (this->sld.dwFlags & SLDF_HAS_WORKINGDIR)
        ReadString( hFile, &this->pszWorkingDir, this->sld.dwFlags & SLDF_UNICODE);
    if (this->sld.dwFlags & SLDF_HAS_ARGS)
        ReadString( hFile, &this->pszArgs, this->sld.dwFlags & SLDF_UNICODE);
    if (this->sld.dwFlags & SLDF_HAS_ICONLOCATION)
        ReadString( hFile, &this->pszIconLocation, this->sld.dwFlags & SLDF_UNICODE);

    // Read in extra data sections
    this->pExtraData = NULL;
    cbTotal = 0;
    while (TRUE)
    {

        LPSTR pReadData = NULL;

        cbSize = 0;
        if (!ReadFile( hFile, (LPVOID)&cbSize, sizeof(cbSize), &dwBytesRead, NULL ))
            return (1);

        if (cbSize < sizeof(cbSize))
            break;

        if (pTemp)
        {
            pTemp = (void *)HeapReAlloc( GetProcessHeap(),
                                         HEAP_ZERO_MEMORY,
                                         this->pExtraData,
                                         cbTotal + cbSize + sizeof(DWORD)
                                        );
            if (pTemp)
            {
                this->pExtraData = (LPDBLIST)pTemp;
            }
        }
        else
        {
            (LPVOID)this->pExtraData = pTemp = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, cbTotal + cbSize + sizeof(DWORD) );

        }

        if (!pTemp)
            break;

        cbToRead = cbSize - sizeof(cbSize);
        pReadData = pTemp + cbTotal;

        if (!ReadFile( hFile, (LPVOID)(pReadData + sizeof(cbSize)), cbToRead, &dwBytesRead, NULL ))
            return (1);

        if (dwBytesRead==cbToRead)
        {
            // got all of the extra data, comit it
            *((UNALIGNED DWORD *)pReadData) = cbSize;
            cbTotal += cbSize;
        }
        else
            break;

    }

    printf( "\n===== Dump of link file (%s) =====\n\n", argv[1] );

    printf( "[Shell Link Data (sld)]\n" );
    printf( "    cbSize           = 0x%08X\n", this->sld.cbSize );
    printf( "    GUID             = {%08lX-%04X-%04X-%02X%02X-%02X%02X%02x%02x%02x%02x}\n",
            this->sld.clsid.Data1, this->sld.clsid.Data2, this->sld.clsid.Data3,
            this->sld.clsid.Data4[0], this->sld.clsid.Data4[1],
            this->sld.clsid.Data4[2], this->sld.clsid.Data4[3],
            this->sld.clsid.Data4[4], this->sld.clsid.Data4[5],
            this->sld.clsid.Data4[6], this->sld.clsid.Data4[7]
           );
    printf( "    dwFlags          = 0x%08X\n", this->sld.dwFlags );
    if (this->sld.dwFlags & SLDF_HAS_ID_LIST)
        printf( "                           SLDF_HAS_ID_LIST          is set.\n" );
    if (this->sld.dwFlags & SLDF_HAS_LINK_INFO)
        printf( "                           SLDF_HAS_LINK_INFO        is set.\n" );
    if (this->sld.dwFlags & SLDF_HAS_NAME)
        printf( "                           SLDF_HAS_NAME             is set.\n" );
    if (this->sld.dwFlags & SLDF_HAS_RELPATH)
        printf( "                           SLDF_HAS_RELPATH          is set.\n" );
    if (this->sld.dwFlags & SLDF_HAS_WORKINGDIR)
        printf( "                           SLDF_HAS_WORKINGDIR       is set.\n" );
    if (this->sld.dwFlags & SLDF_HAS_ARGS)
        printf( "                           SLDF_HAS_ARGS             is set.\n" );
    if (this->sld.dwFlags & SLDF_HAS_ICONLOCATION)
        printf( "                           SLDF_HAS_ICONLOCATION     is set.\n" );
    if (this->sld.dwFlags & SLDF_HAS_EXP_SZ)
        printf( "                           SLDF_HAS_EXP_SZ           is set.\n" );
    if (this->sld.dwFlags & SLDF_RUN_IN_SEPARATE)
        printf( "                           SLDF_RUN_IN_SEPARATE      is set.\n" );
    if (this->sld.dwFlags & SLDF_UNICODE)
        printf( "                           SLDF_HAS_UNICODE          is set.\n" );
    if (this->sld.dwFlags & SLDF_FORCE_NO_LINKINFO)
        printf( "                           SLDF_FORCE_NO_LINKINFO    is set.\n" );
    printf( "    dwFileAttributes = 0x%08X\n", this->sld.dwFileAttributes );
    if (this->sld.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
        printf( "                           FILE_ATTRIBUTE_READONLY   is set.\n" );
    if (this->sld.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)
        printf( "                           FILE_ATTRIBUTE_HIDDEN     is set.\n" );
    if (this->sld.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)
        printf( "                           FILE_ATTRIBUTE_SYSTEM     is set.\n" );
    if (this->sld.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        printf( "                           FILE_ATTRIBUTE_DIRECTORY  is set.\n" );
    if (this->sld.dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE)
        printf( "                           FILE_ATTRIBUTE_ARCHIVE    is set.\n" );
    if (this->sld.dwFileAttributes & FILE_ATTRIBUTE_NORMAL)
        printf( "                           FILE_ATTRIBUTE_NORMAL     is set.\n" );
    if (this->sld.dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY)
        printf( "                           FILE_ATTRIBUTE_TEMPORARY  is set.\n" );
    if (this->sld.dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED)
        printf( "                           FILE_ATTRIBUTE_COMPRESSED is set.\n" );
    FileTimeToSystemTime( &this->sld.ftCreationTime, &st );
    printf("    ftCreationTime   = %02d:%02d:%02d, %02d/%02d/%04d\n", st.wHour, st.wMinute, st.wSecond, st.wMonth, st.wDay, st.wYear );
    FileTimeToSystemTime( &this->sld.ftLastAccessTime, &st );
    printf("    ftLastAccessTime = %02d:%02d:%02d, %02d/%02d/%04d\n", st.wHour, st.wMinute, st.wSecond, st.wMonth, st.wDay, st.wYear );
    FileTimeToSystemTime( &this->sld.ftLastWriteTime, &st );
    printf("    ftLastWriteTime  = %02d:%02d:%02d, %02d/%02d/%04d\n", st.wHour, st.wMinute, st.wSecond, st.wMonth, st.wDay, st.wYear );
    printf("    nFileSizeLow     = %d bytes\n", this->sld.nFileSizeLow );
    printf("    iIcon            = %d\n", this->sld.iIcon );
    printf("    wHotkey          = 0x08%X\n", this->sld.wHotkey );
    printf("    dwRes1           = 0x08%X\n", this->sld.dwRes1 );
    printf("    dwRes2           = 0x08%X\n", this->sld.dwRes2 );

    printf("\n[Strings]\n");
    if (this->pszName)
    {
        printf( "    pszName          = " );
        if (this->sld.dwFlags & SLDF_UNICODE)
        {
            CHAR szTemp[ 256 ];

            WideCharToMultiByte( CP_ACP, 0,
                                 (LPWSTR)this->pszName,
                                 -1,
                                 szTemp,
                                 256,
                                 NULL,
                                 NULL
                                );
            printf( "(UNICODE) %s\n", szTemp );

        }
        else
            printf( "%s\n", (LPSTR)this->pszName );
    }

    if (this->pszRelPath)
    {
        printf( "    pszRelPath       = " );
        if (this->sld.dwFlags & SLDF_UNICODE)
        {
            CHAR szTemp[ 256 ];

            WideCharToMultiByte( CP_ACP, 0,
                                 (LPWSTR)this->pszRelPath,
                                 -1,
                                 szTemp,
                                 256,
                                 NULL,
                                 NULL
                                );
            printf( "(UNICODE) %s\n", szTemp );

        }
        else
            printf( "%s\n", (LPSTR)this->pszRelPath );
    }

    if (this->pszWorkingDir)
    {
        printf( "    pszWorkingDir    = " );
        if (this->sld.dwFlags & SLDF_UNICODE)
        {
            CHAR szTemp[ 256 ];

            WideCharToMultiByte( CP_ACP, 0,
                                 (LPWSTR)this->pszWorkingDir,
                                 -1,
                                 szTemp,
                                 256,
                                 NULL,
                                 NULL
                                );
            printf( "(UNICODE) %s\n", szTemp );

        }
        else
            printf( "%s\n", (LPSTR)this->pszWorkingDir );
    }

    if (this->pszArgs)
    {
        printf( "    pszArgs          = " );
        if (this->sld.dwFlags & SLDF_UNICODE)
        {
            CHAR szTemp[ 256 ];

            WideCharToMultiByte( CP_ACP, 0,
                                 (LPWSTR)this->pszArgs,
                                 -1,
                                 szTemp,
                                 256,
                                 NULL,
                                 NULL
                                );
            printf( "(UNICODE) %s\n", szTemp );

        }
        else
            printf( "%s\n", (LPSTR)this->pszArgs );
    }

    if (this->pszIconLocation)
    {
        printf( "    pszIconLocation  = " );
        if (this->sld.dwFlags & SLDF_UNICODE)
        {
            CHAR szTemp[ 256 ];

            WideCharToMultiByte( CP_ACP, 0,
                                 (LPWSTR)this->pszIconLocation,
                                 -1,
                                 szTemp,
                                 256,
                                 NULL,
                                 NULL
                                );
            printf( "(UNICODE) %s\n", szTemp );

        }
        else
            printf( "%s\n", (LPSTR)this->pszIconLocation );
    }


    if (this->pExtraData)
    {
        LPEXP_SZ_LINK lpData = (LPEXP_SZ_LINK)this->pExtraData;

        while( lpData && lpData->cbSize!=0 )
        {
            switch( lpData->dwSignature )
            {

            case EXP_SZ_LINK_SIG:
                {
                    CHAR szTemp[ 256 ];


                    printf("\n[Extra Data -- EXP_SZ_LINK_SIG info]\n");
                    printf("    cbSize      = 0x%X bytes\n", lpData->cbSize );
                    printf("    dwSignature = 0x%X\n", lpData->dwSignature );
                    printf("    szTarget    = %s\n", lpData->szTarget );
                    WideCharToMultiByte( CP_ACP, 0, lpData->swzTarget, -1, szTemp, 256, NULL, NULL );
                    printf("    swzTarget   = (UNICODE) %s\n\n", szTemp );
                }
                break;

            case NT_CONSOLE_PROPS_SIG:
                {
                    CHAR szTemp[ 256 ];
                    INT i;
                    LPNT_CONSOLE_PROPS lpConData = (LPNT_CONSOLE_PROPS)lpData;

                    printf("\n[Extra Data -- NT_CONSOLE_PROPS_SIG info]\n");
                    printf("    cbSize              = 0x%X bytes\n", lpConData->cbSize );
                    printf("    dwSignature         = 0x%X\n", lpConData->dwSignature );
                    printf("    wFillAttribute      = 0x%04X\n", lpConData->wFillAttribute );
                    printf("    wPopupFillAttribute = 0x%04X\n", lpConData->wPopupFillAttribute );
                    printf("    dwScreenBufferSize  = (%d , %d)\n", lpConData->dwScreenBufferSize.X, lpConData->dwScreenBufferSize.Y );
                    printf("    dwWindowSize        = (%d , %d)\n", lpConData->dwWindowSize.X, lpConData->dwWindowSize.Y );
                    printf("    dwWindowOrigin      = (%d , %d)\n", lpConData->dwWindowOrigin.X, lpConData->dwWindowOrigin.Y );
                    printf("    nFont               = %d\n", lpConData->nFont );
                    printf("    nInputBufferSize    = %d\n", lpConData->nInputBufferSize );
                    printf("    dwFontSize          = (%d , %d)\n", lpConData->dwFontSize.X, lpConData->dwFontSize.Y );
                    printf("    uFontFamily         = 0x%08X\n", lpConData->uFontFamily );
                    printf("    uFontWeight         = 0x%08X\n", lpConData->uFontWeight );
                    WideCharToMultiByte( CP_ACP, 0, lpConData->FaceName, LF_FACESIZE, szTemp, LF_FACESIZE, NULL, NULL );
                    szTemp[ LF_FACESIZE ] = (CHAR)0;
                    printf("    FaceName            = %s\n", szTemp );
                    printf("    uCursorSize         = %d\n", lpConData->uCursorSize );
                    printf("    bFullScreen         = %s\n", lpConData->bFullScreen ? "TRUE" : "FALSE" );
                    printf("    bQuickEdit          = %s\n", lpConData->bQuickEdit  ? "TRUE" : "FALSE" );
                    printf("    bInsertMode         = %s\n", lpConData->bInsertMode ? "TRUE" : "FALSE" );
                    printf("    bAutoPosition       = %s\n", lpConData->bAutoPosition ? "TRUE" : "FALSE" );
                    printf("    uHistoryBufferSize  = %d\n", lpConData->uHistoryBufferSize );
                    printf("    uNumHistoryBuffers  = %d\n", lpConData->uNumberOfHistoryBuffers );
                    printf("    bHistoryNoDup       = %s\n", lpConData->bHistoryNoDup ? "TRUE" : "FALSE" );
                    printf("    ColorTable = [" );
                    i=0;
                    while( i < 16 )
                    {
                        printf("\n         ");
                        printf("0x%08X ", lpConData->ColorTable[i++]);
                        printf("0x%08X ", lpConData->ColorTable[i++]);
                        printf("0x%08X ", lpConData->ColorTable[i++]);
                        printf("0x%08X ", lpConData->ColorTable[i++]);
                    }
                    printf( "]\n\n" );
                }
                break;

            case NT_FE_CONSOLE_PROPS_SIG:
                {
                    LPNT_FE_CONSOLE_PROPS lpFEConData = (LPNT_FE_CONSOLE_PROPS)lpData;

                    printf("\n[Extra Data -- NT_FE_CONSOLE_PROPS_SIG info]\n");
                    printf("    cbSize              = 0x%X bytes\n", lpFEConData->cbSize );
                    printf("    dwSignature         = 0x%X\n", lpFEConData->dwSignature );
                    printf("    CodePage            = %d\n\n", lpFEConData->uCodePage );
                }
                break;

            case EXP_DARWIN_ID_SIG:
                {
                    CHAR szTemp[ 256 ];
                    LPEXP_DARWIN_LINK lpDarwin = (LPEXP_DARWIN_LINK)lpData;

                    printf("\n[Extra Data -- EXP_DARWIN_ID_SIG info]\n");
                    printf("    szDarwinID           = %s\n", lpDarwin->szDarwinID );
                    WideCharToMultiByte( CP_ACP, 0, lpDarwin->szwDarwinID, -1, szTemp, 256, NULL, NULL );
                    printf("    szwDarwinID          = (UNICODE) %s\n\n", szTemp );
                }
                break;

            case EXP_SPECIAL_FOLDER_SIG:
                {
                    LPEXP_SPECIAL_FOLDER lpFolder = (LPEXP_SPECIAL_FOLDER)lpData;

                    printf("\n[Extra Data -- EXP_SPECIAL_FOLDER_SIG info]\n");
                    printf("    idSpecialFolder      = 0x%X\n", lpFolder->idSpecialFolder );
                    printf("    cbOffset             = 0x%X\n\n", lpFolder->cbOffset );
                }
                break;

#ifdef WINNT
            case EXP_TRACKER_SIG:
                {
                    LPEXP_TRACKER lpTracker = (LPEXP_TRACKER)lpData;
                    WCHAR wszGUID[ MAX_PATH ];

                    printf("\n[Extra Data -- EXP_TRACKER_SIG info]\n");
#if 0
                    // (reinerf) - traker info looks like a byte-array, how do we dump it?
                    printf("    abTracker           = 0x%X\n", lpTracker->abTracker);
#endif
                }
#endif
                break;

            case EXP_SZ_ICON_SIG:
                {
                    CHAR szTemp[256];
                    LPEXP_SZ_LINK lpExpIcon = (LPEXP_SZ_LINK)lpData;

                    printf("\n[Extra Data -- EXP_SZ_ICON_SIG info]\n");
                    printf("    szTarget             = %s\n", lpExpIcon->szTarget );
                    WideCharToMultiByte( CP_ACP, 0, lpExpIcon->swzTarget, -1, szTemp, 256, NULL, NULL );
                    printf("    wszTarget            = (UNICODE) %s\n\n", szTemp );
                }
                break;


            } // end swtich

            (LPBYTE)lpData += lpData->cbSize;
        }

        LocalFree( this->pExtraData );
    }

    if (this->pidl)
        LocalFree( (HLOCAL)this->pidl );

    if (this->pli)
        LocalFree( this->pli );

    if (this->pszName)
        HeapFree( GetProcessHeap(), 0, this->pszName );
    if (this->pszRelPath)
        HeapFree( GetProcessHeap(), 0, this->pszRelPath );
    if (this->pszWorkingDir)
        HeapFree( GetProcessHeap(), 0, this->pszWorkingDir );
    if (this->pszArgs)
        HeapFree( GetProcessHeap(), 0, this->pszArgs );
    if (this->pszIconLocation)
        HeapFree( GetProcessHeap(), 0, this->pszIconLocation );

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\tools\lnkdump\lnkdump.h ===
#include <windows.h>
#include <stdio.h>
#include <shellapi.h>
#include <shlobj.h>
#include <shlwapi.h>
#define NO_SHLWAPI_STRFCNS
#define NO_SHLWAPI_PATH
#define NO_SHLWAPI_REG
#define NO_SHLWAPI_UALSTR
#define NO_SHLWAPI_HTTP
#define NO_SHLWAPI_INTERNAL
#include <shlwapip.h>

#define FE_SB 1

#include <shlobjp.h>

#ifndef PLINKINFO
#define PLINKINFO LPVOID
#endif

#define EXP_SZ_LINK_SIG         0xA0000001
//#define NT_CONSOLE_PROPS_SIG    0xA0000002 // moved to shlobj.w
#define EXP_TRACKER_SIG         0xA0000003
//#define NT_FE_CONSOLE_PROPS_SIG 0xA0000004 // moved to shlobj.w
#define EXP_DARWIN_ID_SIG       0xA0000006

#define EXP_HEADER DATABLOCK_HEADER
#define LPEXP_HEADER LPDATABLOCK_HEADER

// most expansion data structures go here
// those shared with other components (NT40 Console stuff)
// are in shlobj.w (private)
//

typedef struct {
    IShellLink          sl;
    IPersistStream      ps;
    IPersistFile        pf;
    IShellExtInit       si;
    IContextMenu2       cm;
    IDropTarget         dt;
#ifdef USE_DATA_OBJ
    IDataObj            dobj;
#endif
////IExtractIcon  