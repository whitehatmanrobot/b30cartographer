t           (void)               const { return (m_surfLinear.getFormat()); }

    inline void            setFourCC           (DWORD dw4cc)              { m_surfLinear.setFourCC(dw4cc); }
    inline BOOL            getFourCC           (void)               const { return (m_surfLinear.getFourCC()); }
    inline BOOL            isFourCC            (void)               const { return (m_surfLinear.isFourCC()); }
    inline BOOL            isDXT               (void)               const { return (m_surfLinear.isDXT()); }
    inline BOOL            isBumpMap           (void)               const { return ((m_surfLinear.getFormat() == NV_SURFACE_FORMAT_DV8DU8)   ||
                                                                                    (m_surfLinear.getFormat() == NV_SURFACE_FORMAT_L6DV5DU5) ||
                                                                                    (m_surfLinear.getFormat() == NV_SURFACE_FORMAT_X8L8DV8DU8)); }

    inline void            tagHasAlpha         (void)                     { m_surfLinear.tagHasAlpha(); }
    inline void            tagHasNoAlpha       (void)                     { m_surfLinear.tagHasNoAlpha(); }
    inline BOOL            hasAlpha            (void)               const { return (m_surfLinear.hasAlpha()); }

#ifdef TEX_MANAGE
    inline void            setNext             (CTexture *pNext)          { m_pNext = pNext; }
    inline CTexture*       getNext             (void)               const { return (m_pNext); }
    inline void            setPrev             (CTexture *pPrev)          { m_pPrev = pPrev; }
    inline CTexture*       getPrev             (void)               const { return (m_pPrev); }
    inline void            setContext          (PNVD3DCONTEXT pCtx)       { m_pContext = pCtx; }
    inline PNVD3DCONTEXT   getContext          (void)               const { return (m_pContext); }

    inline BOOL            isResident          (void)                     { return ((getSwizzled()->getHeapLocation() != CSimpleSurface::HEAP_SYS) ? TRUE : FALSE); }
    inline BOOL            isEvicted           (void)                     { return ((getSwizzled()->getHeapLocation() == CSimpleSurface::HEAP_SYS) ? TRUE : FALSE); }
#endif

    inline void            tagColorKey         (void)                     { m_dwFlags |= FLAG_COLORKEY; }
    inline BOOL            hasColorKey         (void)               const { return ((m_dwFlags & FLAG_COLORKEY) == FLAG_COLORKEY); }
    inline void            setColorKey         (DWORD dwCK)               { m_dwColorKey = dwCK; }
    inline DWORD           getColorKey         (void)               const { return (m_dwColorKey); }

    inline DWORD           getNV056Control0    (void)               const { return (m_dwNV056Control0); }
    inline DWORD           getNV056Format      (void)               const { return (m_dwNV056Format); }

           void            hwLock              (PNVD3DCONTEXT pContext, DWORD dwAccess);
    inline void            hwUnlock            (void)                     { m_surfSwizzled.hwUnlock(); }
    inline void            cpuLockSwz          (DWORD dwAccess)           { m_surfSwizzled.cpuLock (dwAccess); }
    inline void            cpuUnlockSwz        (void)                     { m_surfSwizzled.cpuUnlock(); }
    inline void            cpuLockLin          (DWORD dwAccess)           { m_surfLinear.cpuLock (dwAccess); }
    inline void            cpuUnlockLin        (void)                     { m_surfLinear.cpuUnlock(); }

           BOOL            internalCanRename   (void);
           void            internalRename      (DWORD dwOldIndex, DWORD dwNewIndex);
           void            enableRenaming      (void);

    // methods
public:
    DWORD        calcMipMapSize              (DWORD dwLogU, DWORD dwLogV, DWORD dwLogP, DWORD dwMipMapLevels);
    BOOL         prepareLinearAsRenderTarget (void);
    BOOL         updateLinearSurface         (void);
    BOOL         updateSwizzleSurface        (PNVD3DCONTEXT pContext);
    void         calculateNV056ControlWords  (void);
    static DWORD getCubeMapFaceNum           (DWORD dwFace);
#ifdef TEX_MANAGE
    BOOL         evict                       (void);
    BOOL         fetch                       (void);
#endif

    // construction
public:
    // new creation
    BOOL create  (CNvObject *pWrapperObject,      // NvObject wrapping this texture
                  DWORD      dwWidth,             // width
                  DWORD      dwHeight,            // height
                  DWORD      dwDepth,             // depth
                  DWORD      dwBPPRequested,      // bytes per pixel requested
                  DWORD      dwBPPGranted,        // bytes per pixel granted
                  DWORD      dwMipMapCount,       // # of mipmaps (including self)
                  DWORD      dwFormat,            // texture format NV_TEXTURE_FORMAT_xxx
                  DWORD      dwAllowedHeaps,      // allowed heaps to allocate in
                  DWORD      dwPreferredHeap);    // preferred heap
    BOOL create  (CNvObject *pWrapperObject,      // NvObject wrapping this texture
                  DWORD      dwThisFace,          // cubemap face
                  CTexture  *pBaseTexture,        // create a mipmap from this base
                  DWORD      dwMipMapLevel);      // this is the nth mipmap (base = 0)
    // new destruction
    BOOL destroy (void);

     CTexture ();
    ~CTexture ();
};

//---------------------------------------------------------------------------

#ifdef __cplusplus
extern "C"
{
#endif

// public functions
DWORD nvTextureCreateSurface    (LPDDRAWI_DDRAWSURFACE_LCL pLcl, LPDDRAWI_DIRECTDRAW_GBL pDDGbl, LPDDSURFACEDESC pDDSurfDesc);
BOOL  nvTextureDestroySurface   (LPDDHAL_DESTROYSURFACEDATA pDestorySurfaceData, LPDDRAWI_DDRAWSURFACE_LCL pLcl);
DWORD nvTextureBlt              (PNVD3DCONTEXT pContext, LPDDHAL_BLTDATA pBltData);
DWORD nvTextureBltDX7           (PNVD3DCONTEXT pContext, CNvObject *pSrcObj, CNvObject *pDstObj, D3DBOX *boxSrc, DWORD dwDstX, DWORD dwDstY, DWORD dwDstZ, DWORD dwFlags);
DWORD nvTextureColorFill        (CNvObject *pDstObj, DWORD dwX0, DWORD dwY0, DWORD dwFillWidth, DWORD dwFillHeight, DWORD dwColor);
DWORD nvTextureStretchBlit      (LPSURFINFO pSrcInfo, LPSURFINFO pDstInfo);
DWORD nvTextureLock             (CTexture *pTexture, LPDDHAL_LOCKDATA pLockData);
DWORD nvTextureUnlock           (CTexture *pTexture, LPDDHAL_UNLOCKDATA pUnlockData);

DWORD D3DCreateTextureContexts  (DWORD dwHeapBase, DWORD dwNewLimit);
void  D3DDestroyTextureContexts (GLOBALDATA *pDriverData);

BOOL  nvTextureDefaultAlloc     (void);
void  nvTextureDefaultFree      (void);

#ifdef __cplusplus
}
#endif

#endif // _nvTex_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvVideoPort.h ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvVideoPort.h                                                     *
*    Definition file for:                                                   *
*       vp.c                                                                *
*    Suggested new name:                                                    *
*       nvVideoPort.c                                                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Paul van der Kouwe 06/16/99 - created.                              *
*                                                                           *
\***************************************************************************/

#ifndef __NVVIDEOPORT_H_
#define __NVVIDEOPORT_H_

#ifdef __cplusplus
extern "C" {
#endif

// public
DWORD __stdcall CanCreateVideoPort32       (LPDDHAL_CANCREATEVPORTDATA);
DWORD __stdcall CreateVideoPort32          (LPDDHAL_CREATEVPORTDATA);
DWORD __stdcall FlipVideoPort32            (LPDDHAL_FLIPVPORTDATA);
DWORD __stdcall GetVideoPortBandwidth32    (LPDDHAL_GETVPORTBANDWIDTHDATA);
DWORD __stdcall GetVideoPortInputFormat32  (LPDDHAL_GETVPORTINPUTFORMATDATA);
DWORD __stdcall GetVideoPortOutputFormat32 (LPDDHAL_GETVPORTOUTPUTFORMATDATA);
DWORD __stdcall GetVideoPortField32        (LPDDHAL_GETVPORTFIELDDATA);
DWORD __stdcall GetVideoPortLine32         (LPDDHAL_GETVPORTLINEDATA);
DWORD __stdcall GetVideoPortConnectInfo    (LPDDHAL_GETVPORTCONNECTDATA);
DWORD __stdcall DestroyVideoPort32         (LPDDHAL_DESTROYVPORTDATA);
DWORD __stdcall GetVideoPortFlipStatus32   (LPDDHAL_GETVPORTFLIPSTATUSDATA);
DWORD __stdcall UpdateVideoPort32          (LPDDHAL_UPDATEVPORTDATA);
DWORD __stdcall WaitForVideoPortSync32     (LPDDHAL_WAITFORVPORTSYNCDATA);
DWORD __stdcall GetVideoSignalStatus32     (LPDDHAL_GETVPORTSIGNALDATA);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __NVVIDEOPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvVB.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _nvVB_h
#define _nvVB_h

#ifdef __cplusplus
extern "C"
{
#endif

/*****************************************************************************
 * constants
 */
#define VB_CACHE_SIZE               32              // # of software cache entries (no more than 256)
#define TOTAL_VB_RENAME             16

/*****************************************************************************
 * CVertexBuffer
 *
 * d3d vertex buffer internal structure
 */
class CVertexBuffer
{
    /*
     * constants
     */
public:
    enum
    {
        FLAG_D3D_LOCKED         = 1,    // d3d has lock (affects renaming policy)
        FLAG_D3D_IMPLICIT       = 2,    // d3d implicit VB
        FLAG_DX6                = 4,    // dx6 vertex buffer
        FLAG_MODIFIED           = 8,    // set when we believe the contents of the buffer has changed
        FLAG_RENAME2SYSTEM      = 16,   // when set, we will attempt to move the VB to system memory (used to CM hack performance)
        FLAG_DYNAMIC            = 32,   // dynamic buffer
        FLAG_SUPERTRIOWNSMEM    = 64,   // supertri owns the look aside buffer
        FLAG_ALIASLOCKED        = 128   // NV_AGP alias lock
    };

public:
    struct STVERTEX
    {
        float x,y,z,reserved;
    };

    /*
     * members
     */
protected:
// bank
#ifdef MCFD

#else 
    DWORD            m_Cache_CSS_dwFlags;             // Copy of CSimpleSurface flags
    CSimpleSurface  *m_Cache_CSS_pActiveSurface;      // Pointer to the currently active surface
#endif //MCFD
    CNvObject       *m_pWrapperObject;
    DWORD            m_dwFlags;
    DWORD            m_dwVertexStride;
    void            *m_pSuperTriLookAsideBuffer;
    DWORD            m_dwSuperTriLookAsideBufferSize;
    DWORD            m_dwLockCount;
// bank
    DWORD          __pad[8];
// bank

#ifdef MCFD
	void * m_data;  //pointer to the whole bitmap
public:
	CBlockList m_blockList;   // list header of the blocks belonging to the renaming chain

    inline DWORD           getContextDMA     (void)   { return m_blockList.m_pActive->getContextDMA(); }
    inline DWORD           getHeapLocation   (void)   { return m_blockList.m_pActive->getHeapLocation(); }
    inline DWORD           getOffset         (void)   { return m_blockList.m_pActive->getOffset();  }
    DWORD                  getAddress        (void);
    inline DWORD           getfpVidMem       (void)   { return m_blockList.m_pActive->getAddress(); }
    inline DWORD           getSize           (void)   { return m_blockList.m_pActive->getSize();    }

    inline BOOL            hwCanRead(void)            { return m_blockList.m_pActive->hwCanRead(); }

    void  LockForGPU             (DWORD dwAcess);
    void  UnlockForGPU           (void);

    void  LockForCPU            (DWORD dwAcess, DWORD RenamingPolicy=RENAME_POLICY_NO_COPY);
    void  UnlockForCPU          (void);


#else
    CComplexSurface<TOTAL_VB_RENAME> m_Surface;

    /*
     * helpers
     */
public:
    inline CSimpleSurface* getSurface        (void)   { return m_Surface.getActiveSurface(); }
    inline DWORD           getContextDMA     (void)   { return m_Surface.getActiveSurface()->getContextDMA(); }
    inline DWORD           getHeapLocation   (void)   { return m_Surface.getActiveSurface()->getHeapLocation(); }
    inline DWORD           getOffset         (void)   { return m_Surface.getActiveSurface()->getOffset();  }
    inline DWORD           getAddress        (void)   { return m_Surface.getActiveSurface()->getAddress(); }
    inline DWORD           getfpVidMem       (void)   { return m_Surface.getActiveSurface()->getfpVidMem(); }
    inline DWORD           getSize           (void)   { return m_Surface.getActiveSurface()->getSize();    }
#endif
    inline CNvObject*      getWrapper        (void)   { return (m_pWrapperObject); }

    /*
     * methods
     */
public:
           BOOL  prepareSuperTriLookAsideBuffer (void);
           void  destroySuperTriLookAsideBuffer (void);
    inline void* getSuperTriLookAsideBuffer     (void)    const {   return m_pSuperTriLookAsideBuffer;   }
    inline void  setSuperTriLookAsideBuffer     (void *p)       {   m_pSuperTriLookAsideBuffer = p;
                                                                    // this should never assert, but if it does, this simply means we should free the look aside buffer we already own
                                                                    nvAssert (!(m_dwFlags & FLAG_SUPERTRIOWNSMEM));
                                                                }

#ifdef MCFD
    BOOL  create             (DWORD dwSize, DWORD dwAllowedHeaps, DWORD dwPreferredHeap);
    BOOL  destroy            (void);
    void  own                (DWORD dwAddress, DWORD dwSize, DWORD dwHeapLocation);
    void  disown             (void) ;
    void  tagRenameEnable    (DWORD dwRenameType, DWORD dwPreAllocCount=1);
#else
    inline BOOL  create             (DWORD dwSize, DWORD dwAllowedHeaps, DWORD dwPreferredHeap)
                                                                {   BOOL bCreated =  m_Surface.create (m_pWrapperObject,
                                                                                                       dwSize,
                                                                                                       dwAllowedHeaps,
                                                                                                       dwPreferredHeap
#ifdef CAPTURE
                                                                                                      ,CAPTURE_SURFACE_KIND_VERTEX
#endif
                                                                                                       );
                                                                    updateCachedValues();
                                                                    return bCreated;
                                                                }


    inline BOOL  destroy            (void)                      {   destroySuperTriLookAsideBuffer();
                                                                    return (m_Surface.destroy());
                                                                }

    inline void  own                (DWORD dwAddress, DWORD dwSize, DWORD dwHeapLocation)
                                                                {   m_Surface.own(dwAddress,dwSize,1,dwHeapLocation,FALSE);
                                                                    updateCachedValues();
                                                                }

    inline void  disown             (void)                      {   m_Surface.disown();   }

    inline void  tagRenameEnable    (DWORD dwRenameType, DWORD dwPreAllocCount=1)
                                                                {   m_Surface.tagRenameEnable (dwRenameType, dwPreAllocCount);   }
#endif

#ifndef MCFD
    inline void  hwLock             (DWORD dwAccess)            {   m_Surface.hwLock (dwAccess);   }
    inline void  hwUnlock           (void)                      {   m_Surface.hwUnlock();   }

    inline void  cpuLock            (DWORD dwAccess)            {   m_Surface.cpuLock (dwAccess);
                                                                    updateCachedValues();
                                                                    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                                                                        nvglSetNv20KelvinInvalidateVertexCache (NV_DD_KELVIN);
                                                                    }
                                                                    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                                                                        nvglSetNv10CelsiusInvalidateVertexCache (NV_DD_CELSIUS);
                                                                    }
                                                                }

    inline void  cpuUnlock          (void)                      {   m_Surface.cpuUnlock();   }
#endif

    inline void  tagD3DLocked       (void)                      {   m_dwFlags |= FLAG_D3D_LOCKED;         }
    inline void  tagD3DUnlocked     (void)                      {   m_dwFlags &= ~FLAG_D3D_LOCKED;        }
    inline BOOL  isD3DLocked        (void) const                {   return (m_dwFlags & FLAG_D3D_LOCKED); }

    inline void  tagD3DImplicit     (void)                      {   m_dwFlags |= FLAG_D3D_IMPLICIT;         }
    inline BOOL  isD3DImplicit      (void) const                {   return (m_dwFlags & FLAG_D3D_IMPLICIT); }

    inline void  tagDX6             (void)                      {   m_dwFlags |= FLAG_DX6;         }
    inline BOOL  isDX6              (void) const                {   return (m_dwFlags & FLAG_DX6); }

    inline void  tagModified        (void)                      {   m_dwFlags |=  FLAG_MODIFIED;        }
    inline void  tagNotModified     (void)                      {   m_dwFlags &= ~FLAG_MODIFIED;        }
    inline BOOL  isModified         (void) const                {   return (m_dwFlags & FLAG_MODIFIED); }

    inline void  tagAliasLocked     (void)                      {   m_dwFlags |=  FLAG_ALIASLOCKED;        }
    inline void  tagNotAliasLocked  (void)                      {   m_dwFlags &= ~FLAG_ALIASLOCKED;        }
    inline BOOL  isAliasLocked      (void) const                {   return (m_dwFlags & FLAG_ALIASLOCKED); }

    inline void  tagRenameToSystem  (void)                      {   m_dwFlags |= FLAG_RENAME2SYSTEM;         }
    inline void  tagRenamedToSystem (void)                      {   m_dwFlags &= ~FLAG_RENAME2SYSTEM;        }
    inline BOOL  mustRenameToSystem (void) const                {   return (m_dwFlags & FLAG_RENAME2SYSTEM); }

    inline void  tagDynamic         (void)                      {   m_dwFlags |= FLAG_DYNAMIC;         }
    inline BOOL  isDynamic          (void) const                {   return (m_dwFlags & FLAG_DYNAMIC); }

    inline void  setVertexStride    (DWORD dw)                  {   m_dwVertexStride = dw;     }
    inline DWORD getVertexStride    (void) const                {   return (m_dwVertexStride); }

    inline void  bumpLockCount      (void)                      {   m_dwLockCount++;        }
    inline DWORD getLockCount       (void) const                {   return (m_dwLockCount); }

#ifdef MCFD

    inline void  updateCachedValues (void)                      {   
                                                                }

    inline bool  cachedhwCanRead    (void)                      {   return (m_blockList.m_pActive->getFlags() & CSimpleSurface::HEAP_LOCATION_MASK) != CSimpleSurface::HEAP_SYS;   }
    inline void  prefetchSurface() {};

#else

    // SK - The following are used to prefetch the current, active vertex buffer
    inline void  updateCachedValues (void)                      {   CSimpleSurface *p = m_Surface.getActiveSurface();
                                                                    m_Cache_CSS_dwFlags = p->getFlags();
                                                                    m_Cache_CSS_pActiveSurface = p;
                                                                }

    inline bool  cachedhwCanRead    (void)                      {   return (m_Cache_CSS_dwFlags & CSimpleSurface::HEAP_LOCATION_MASK) != CSimpleSurface::HEAP_SYS;   }

    #define rEAX                    0
    #define rEDX                    2
    #define mREG(x)                 ((x) << 3)
    #define rmIND8(x)               (0x40 | (x))
    #define prefetch_rm8(h,rm,ofs)  __asm _emit 0x0f __asm _emit 0x18 __asm _emit (mREG(h) | (rm)) __asm _emit (ofs)

    inline void  prefetchSurface    (void) const                {   if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI) {
                                                                        __asm
                                                                        {
                                                                            mov eax, this
                                                                            lea edx, [eax].m_Surface
                                                                            prefetch_rm8(1, rmIND8(rEAX), 0)
                                                                            prefetch_rm8(0, rmIND8(rEAX), 32)
                                                                            mov edx, [eax]CVertexBuffer.m_Cache_CSS_pActiveSurface
                                                                            prefetch_rm8(1, rmIND8(rEDX), 0)
                                                                            prefetch_rm8(1, rmIND8(rEDX), 32)
                                                                        }
                                                                    }

                                                                }
    #undef rEAX
    #undef rEDX
    #undef mREG
    #undef rmIND8
    #undef prefetch_rm8
#endif
    /*
     * construction
     */
public:
    CVertexBuffer  (CNvObject *pWrapperObject = NULL);
    ~CVertexBuffer (void);

};

/*****************************************************************************
 * CCommandBuffer
 *
 * d3d system memory wrapper (command and execute buffers)
 */
class CCommandBuffer
{
    /*
     * members
     */
protected:
// bank
    CSimpleSurface             m_Surface;
// bank
    CNvObject                 *m_pWrapperObject;
    LPDDRAWI_DDRAWSURFACE_LCL  m_pDDSurfaceLcl;
    DWORD                      _pad0[6];

    /*
     * helpers
     */
public:
    inline LPDDRAWI_DDRAWSURFACE_LCL getDDSurfaceLcl (void) const { return m_pDDSurfaceLcl; }

    inline CSimpleSurface* getSurface (void)                 { return &m_Surface; }
    inline DWORD           getAddress (void)           const { return m_Surface.getAddress(); }
    inline DWORD           getSize    (void)           const { return m_Surface.getSize();    }

    inline void            cpuLock    (DWORD dwAccess)       { m_Surface.cpuLock (dwAccess); }
    inline void            cpuUnlock  (void)                 { m_Surface.cpuUnlock(); }

    /*
     * methods
     */
public:
    inline BOOL create  (DWORD dwSize)  { return m_Surface.create (dwSize, 1, 1, 0,
                                                                   CSimpleSurface::HEAP_SYS,
                                                                   CSimpleSurface::HEAP_SYS,
                                                                   CSimpleSurface::ALLOCATE_SIMPLE
#ifdef CAPTURE
                                                                  ,CAPTURE_SURFACE_KIND_COMMAND
#endif
                                                                   ); }
    inline BOOL destroy (void)          { return m_Surface.destroy(); }

    inline void own     (DWORD dwAddress, DWORD dwSize, DWORD dwHeapLocation)
                                                               { m_Surface.own(dwAddress, dwSize, 1, dwHeapLocation, FALSE); }

    inline BOOL isOwner (void)    const { return m_Surface.isOwner(); }


    inline BOOL growBy  (DWORD dwSize, BOOL bPreserveContents) { return m_Surface.growBy(dwSize, bPreserveContents); }

    /*
     * construction
     */
public:
    CCommandBuffer (CNvObject                 *pWrapperObject,
                    LPDDRAWI_DDRAWSURFACE_LCL  pDDSurfaceLcl);
    ~CCommandBuffer (void);
};

/*****************************************************************************
 * D3D callbacks
 */
DWORD __stdcall D3DCanCreateExecuteBuffer32 (LPDDHAL_CANCREATESURFACEDATA pCanCreateSurfaceData);
DWORD __stdcall D3DCreateExecuteBuffer32    (LPDDHAL_CREATESURFACEDATA    pCreateSurfaceData);
DWORD __stdcall D3DDestroyExecuteBuffer32   (LPDDHAL_DESTROYSURFACEDATA   pDestroySurfaceData);
DWORD __stdcall D3DLockExecuteBuffer32      (LPDDHAL_LOCKDATA             pLockData);
DWORD __stdcall D3DUnlockExecuteBuffer32    (LPDDHAL_UNLOCKDATA           pUnlockData);

#ifdef __cplusplus
}
#endif

#endif // _nvVB_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvtranslate.h ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVTRANSLATE.H                                                     *
*   declatations of constants and prototypes for tables needed to           *
*   translate from generic definitions (either NV or D3D) to HW-specific    *
*   definitions                                                             *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler    bertrem     03May99     created                 *
*                                                                           *
\***************************************************************************/

#ifndef _NVTRANSLATE_H_
#define _NVTRANSLATE_H_

#ifdef __cplusplus
extern "C" {
#endif

//--------------------------------------------------------------------------
// surface formats
//--------------------------------------------------------------------------

// generic names
// note these are all named by enumerating components from MSB to LSB.
// please keep it this way (despite what people in redmond do)!
#define NV_SURFACE_FORMAT_Y8                            0
#define NV_SURFACE_FORMAT_AY8                           1
#define NV_SURFACE_FORMAT_A1R5G5B5                      2
#define NV_SURFACE_FORMAT_X1R5G5B5                      3
#define NV_SURFACE_FORMAT_A4R4G4B4                      4
#define NV_SURFACE_FORMAT_R5G6B5                        5
#define NV_SURFACE_FORMAT_A8R8G8B8                      6
#define NV_SURFACE_FORMAT_X1A7R8G8B8                    7
#define NV_SURFACE_FORMAT_X8R8G8B8                      8
#define NV_SURFACE_FORMAT_I8_A1R5G5B5                   9
#define NV_SURFACE_FORMAT_I8_R5G6B5                     10
#define NV_SURFACE_FORMAT_I8_A4R4G4B4                   11
#define NV_SURFACE_FORMAT_I8_A8R8G8B8                   12
#define NV_SURFACE_FORMAT_DXT1_A1R5G5B5                 13
#define NV_SURFACE_FORMAT_DXT23_A8R8G8B8                14
#define NV_SURFACE_FORMAT_DXT45_A8R8G8B8                15
#define NV_SURFACE_FORMAT_IMAGE_A1R5G5B5                16
#define NV_SURFACE_FORMAT_IMAGE_R5G6B5                  17
#define NV_SURFACE_FORMAT_IMAGE_A8R8G8B8                18
#define NV_SURFACE_FORMAT_IMAGE_Y8                      19
#define NV_SURFACE_FORMAT_IMAGE_SY8                     20
#define NV_SURFACE_FORMAT_IMAGE_X7SY9                   21
#define NV_SURFACE_FORMAT_IMAGE_R8B8                    22
#define NV_SURFACE_FORMAT_IMAGE_G8B8                    23
#define NV_SURFACE_FORMAT_IMAGE_SG8SB8                  24
#define NV_SURFACE_FORMAT_Z16                           25
#define NV_SURFACE_FORMAT_Z24S8                         26
#define NV_SURFACE_FORMAT_Z24X8                         27
#define NV_SURFACE_FORMAT_DV8DU8                        28
#define NV_SURFACE_FORMAT_L6DV5DU5                      29
#define NV_SURFACE_FORMAT_X8L8DV8DU8                    30
#define NV_SURFACE_FORMAT_HILO_1_V16U16                 31
#define NV_SURFACE_FORMAT_HILO_HEMI_V16U16              32
#define NV_SURFACE_FORMAT_A8B8G8R8                      33
#define NV_SURFACE_FORMAT_UNKNOWN                       34 //used for sys surfaces we don't control

#define NV_SURFACE_FORMAT_COUNT                         35

// format to BPP conversion
extern const DWORD nvSurfaceFormatToBPP[NV_SURFACE_FORMAT_COUNT];

// generic -> HW surface format conversion tables
extern const DWORD nv052SurfaceFormat[NV_SURFACE_FORMAT_COUNT];
extern const DWORD nv053SurfaceFormat[NV_SURFACE_FORMAT_COUNT];
extern const DWORD nv056SurfaceFormat[NV_SURFACE_FORMAT_COUNT];
extern const DWORD nv062SurfaceFormat[NV_SURFACE_FORMAT_COUNT];
extern const DWORD nv077SurfaceFormat[NV_SURFACE_FORMAT_COUNT];
extern const DWORD nv089SurfaceFormat[NV_SURFACE_FORMAT_COUNT];
extern const DWORD nv097SurfaceFormat[NV_SURFACE_FORMAT_COUNT];

// generic -> HW texture format conversion tables
extern const DWORD nv054TextureFormat[NV_SURFACE_FORMAT_COUNT];
extern const DWORD nv055TextureFormat[NV_SURFACE_FORMAT_COUNT];
extern const DWORD nv056TextureFormat[NV_SURFACE_FORMAT_COUNT];
extern const DWORD nv097TextureFormat[NV_SURFACE_FORMAT_COUNT];

//--------------------------------------------------------------------------
// context DMAs
//--------------------------------------------------------------------------

// generic names
#define NV_CONTEXT_DMA_NONE                             0   // system memory
#define NV_CONTEXT_DMA_AGP_OR_PCI                       1   // pci / agp
#define NV_CONTEXT_DMA_VID                              2   // video

#define NV_CONTEXT_DMA_COUNT                            3

// generic -> HW texture format context DMA conversion tables
extern const DWORD nv054TextureContextDma[NV_CONTEXT_DMA_COUNT];
extern const DWORD nv055TextureContextDma[NV_CONTEXT_DMA_COUNT];
extern const DWORD nv056TextureContextDma[NV_CONTEXT_DMA_COUNT];
extern const DWORD nv097TextureContextDma[NV_CONTEXT_DMA_COUNT];
extern const DWORD nv056PaletteContextDma[NV_CONTEXT_DMA_COUNT];
extern const DWORD nv097PaletteContextDma[NV_CONTEXT_DMA_COUNT];

//--------------------------------------------------------------------------
// D3D conversion stuff
//--------------------------------------------------------------------------

#define D3D_STENCIL_OP_COUNT                            9
#define D3D_CMP_FUNC_COUNT                              9
#define D3D_BLEND_COUNT                                14
#define D3D_BLEND_OP_COUNT                              6
#define D3D_TADDRESS_COUNT                              5
#define D3D_MAGFILTER_COUNT                             6
#define D3D_MINFILTER_COUNT                             4
#define D3D_MIPFILTER_COUNT                             4

#define D3D_INPUTREGMAP_COUNT                           D3DVSDE_NORMAL2+1
#define D3D_OUTPUTREGMAP_COUNT                          16

// D3D -> HW conversion tables
extern const DWORD nv056StencilOp[D3D_STENCIL_OP_COUNT];
extern const DWORD nv097StencilOp[D3D_STENCIL_OP_COUNT];
extern const DWORD nv056StencilFunc[D3D_CMP_FUNC_COUNT];
extern const DWORD nv097StencilFunc[D3D_CMP_FUNC_COUNT];
extern const DWORD nv056AlphaFunc[D3D_CMP_FUNC_COUNT];
extern const DWORD nv097AlphaFunc[D3D_CMP_FUNC_COUNT];
extern const DWORD nv056DepthFunc[D3D_CMP_FUNC_COUNT];
extern const DWORD nv097DepthFunc[D3D_CMP_FUNC_COUNT];
extern const DWORD nv056BlendFunc[D3D_BLEND_COUNT];
extern const DWORD nv097BlendFunc[D3D_BLEND_COUNT];
extern const DWORD nv056BlendOp[D3D_BLEND_OP_COUNT];
extern const DWORD nv097BlendOp[D3D_BLEND_OP_COUNT];
extern const DWORD nv056TextureAddress[D3D_TADDRESS_COUNT];
extern const DWORD nv097TextureAddress[D3D_TADDRESS_COUNT];
extern const DWORD nv056TextureMagFilter[D3D_MAGFILTER_COUNT];
extern const DWORD nv097TextureMagFilter[D3D_MAGFILTER_COUNT];
extern const DWORD nv056TextureMinFilter[D3D_MINFILTER_COUNT][D3D_MIPFILTER_COUNT];
extern const DWORD nv097TextureMinFilter[D3D_MINFILTER_COUNT][D3D_MIPFILTER_COUNT];

extern const DWORD dx8MinFilterMapping[];
extern const DWORD dx8MagFilterMapping[];
extern const DWORD dx8MipFilterMapping[];

extern const DWORD defaultInputRegMap[D3D_INPUTREGMAP_COUNT];
extern const DWORD defaultOutputRegMap[D3D_OUTPUTREGMAP_COUNT];

//--------------------------------------------------------------------------

#ifdef __cplusplus
}
#endif

#endif // _NVTRANSLATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvTimer.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvTimer.h
//        definition of a timing mechanism
//
//  History:
//      Ben DeWaal            (ben)          ??           created
//      Craig Duttweiler      (bertrem)      10Apr00      moved to this file
//
// **************************************************************************

class CNVTimer
{
protected:
    __int64 m_qwTime[64];

public:
    inline void reset (int iTimeSlot)
    {
        m_qwTime[iTimeSlot] = 0;
    }

    inline void start (int iTimeSlot)
    {
        __int64 i64;
        __asm
        {
            push eax
            push edx
            rdtsc
            mov dword ptr [i64],eax
            mov dword ptr [i64+4],edx
            pop edx
            pop eax
        }
        m_qwTime[iTimeSlot] = -i64;
    }

    inline void restart (int iTimeSlot)
    {
        __int64 i64;
        __asm
        {
            push eax
            push edx
            rdtsc
            mov dword ptr [i64],eax
            mov dword ptr [i64+4],edx
            pop edx
            pop eax
        }
        m_qwTime[iTimeSlot] -= i64;
    }

    inline void stop (int iTimeSlot)
    {
        __int64 i64;
        __asm
        {
            push eax
            push edx
            rdtsc
            mov dword ptr [i64],eax
            mov dword ptr [i64+4],edx
            pop edx
            pop eax
        }
        m_qwTime[iTimeSlot] += i64;
    }

    inline double getTime (int iTimeSlot)
    {
        return double(m_qwTime[iTimeSlot]) / (1e6 * double(pDriverData->nvD3DPerfData.dwProcessorSpeed));
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvvxmac.h ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

#ifndef _nvvxmac_h_
#define _nvvxmac_h_

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Inner Loop Prototypes and Vertex Macros
 */

/*
 * General Constants
 */
#define NV_FORCE_TRI_SETUP(_ctx) (_ctx)->dwFunctionLookup = NV_SETUP_FUNCTION_INDEX;

#define NV_DX6_FUNCTION_ADJUST      2
#define NV_FIXED_FUNCTION_INDEX     2048
#define NV_AA_FUNCTION_INDEX        2048
#define NV_SETUP_FUNCTION_INDEX     2049

#define sizeDX5TriangleVertex       9
#define sizeDx5TriangleTLVertex     sizeDX5TriangleVertex

#define sizeDX6TriangleVertex       11
#define sizeDx6TriangleTLVertex     sizeDX6TriangleVertex

/*
 * Vertex Macros
 */

#define nvglDX5TriangleVertex(fifo,freecount,ch,alias,vertex)\
{\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    memcpy ((void*)(fifo + 4),(void*)(vertex),32);\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5TriangleVertexExpFog(fifo,freecount,ch,alias,vertex)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = (*(DWORD*)(vertex + 12));\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\
    dwTemp = (*(DWORD*)(vertex + 20));\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog  = fz * pContext->fFogTableDensity;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\
    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5TriangleVertexExp2Fog(fifo,freecount,ch,alias,vertex)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = (*(DWORD*)(vertex + 12));\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\
    dwTemp = (*(DWORD*)(vertex + 20));\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog  = fz * pContext->fFogTableDensity;\
    ffog *= ffog;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\
    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5TriangleVertexLinearFog(fifo,freecount,ch,alias,vertex)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = (*(DWORD*)(vertex + 12));\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\
    dwTemp = (*(DWORD*)(vertex + 20));\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog = (fz >= pContext->fFogTableEnd) ? 0.0f :\
           (fz <= pContext->fFogTableStart) ? 1.0f :\
           (pContext->fFogTableEnd - fz) * pContext->fFogTableLinearScale;\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\
    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5TriangleVertexWBuf(fifo,freecount,ch,alias,vertex)\
{\
    DWORD dwTemp;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = (*(DWORD*)(vertex +  8));\
    dwTemp = (*(DWORD*)(vertex + 12));\
    frhw = (FLOAT_FROM_DWORD(dwTemp)) * pContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\
    dwTemp = (*(DWORD*)(vertex + 20));\
    *(DWORD*)(fifo + 24) = dwTemp;\
    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\
    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5TriangleVertexExpFogWBuf(fifo,freecount,ch,alias,vertex)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = (*(DWORD*)(vertex + 12));\
    frhw = (FLOAT_FROM_DWORD(dwTemp)) * pContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\
    dwTemp = (*(DWORD*)(vertex + 20));\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog  = fz * pContext->fFogTableDensity;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\
    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5TriangleVertexExp2FogWBuf(fifo,freecount,ch,alias,vertex)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = (*(DWORD*)(vertex + 12));\
    frhw = (FLOAT_FROM_DWORD(dwTemp)) * pContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\
    dwTemp = (*(DWORD*)(vertex + 20));\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog  = fz * pContext->fFogTableDensity;\
    ffog *= ffog;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\
    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5TriangleVertexLinearFogWBuf(fifo,freecount,ch,alias,vertex)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = (*(DWORD*)(vertex + 12));\
    frhw = (FLOAT_FROM_DWORD(dwTemp)) * pContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\
    dwTemp = (*(DWORD*)(vertex + 20));\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog = (fz >= pContext->fFogTableEnd) ? 0.0f :\
           (fz <= pContext->fFogTableStart) ? 1.0f :\
           (pContext->fFogTableEnd - fz) * pContext->fFogTableLinearScale;\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\
    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertex(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertexExpFog(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog  = fz * pContext->fFogTableDensity;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertexExp2Fog(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog  = fz * pContext->fFogTableDensity;\
    ffog *= ffog;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertexLinearFog(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog = (fz >= pContext->fFogTableEnd) ? 0.0f :\
           (fz <= pContext->fFogTableStart) ? 1.0f :\
           (pContext->fFogTableEnd - fz) * pContext->fFogTableLinearScale;\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertexWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (FLOAT_FROM_DWORD(dwTemp)) * pContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertexExpFogWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (FLOAT_FROM_DWORD(dwTemp)) * pContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog  = fz * pContext->fFogTableDensity;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertexExp2FogWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (FLOAT_FROM_DWORD(dwTemp)) * pContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog  = fz * pContext->fFogTableDensity;\
    ffog *= ffog;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertexLinearFogWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (FLOAT_FROM_DWORD(dwTemp)) * pContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog = (fz >= pContext->fFogTableEnd) ? 0.0f :\
           (fz <= pContext->fFogTableStart) ? 1.0f :\
           (pContext->fFogTableEnd - fz) * pContext->fFogTableLinearScale;\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(FALSE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX6FlexTriangleVertex(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(TRUE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#define nvglDX6FlexTriangleVertexExpFog(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog  = fz * pContext->fFogTableDensity;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(TRUE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#define nvglDX6FlexTriangleVertexExp2Fog(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog  = fz * pContext->fFogTableDensity;\
    ffog *= ffog;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(TRUE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#define nvglDX6FlexTriangleVertexLinearFog(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog = (fz >= pContext->fFogTableEnd) ? 0.0f :\
           (fz <= pContext->fFogTableStart) ? 1.0f :\
           (pContext->fFogTableEnd - fz) * pContext->fFogTableLinearScale;\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(TRUE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#define nvglDX6FlexTriangleVertexWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (FLOAT_FROM_DWORD(dwTemp)) * pContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(TRUE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#define nvglDX6FlexTriangleVertexExpFogWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (FLOAT_FROM_DWORD(dwTemp)) * pContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog  = fz * pContext->fFogTableDensity;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(TRUE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#define nvglDX6FlexTriangleVertexExp2FogWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (FLOAT_FROM_DWORD(dwTemp)) * pContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog  = fz * pContext->fFogTableDensity;\
    ffog *= ffog;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(TRUE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#define nvglDX6FlexTriangleVertexLinearFogWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (FLOAT_FROM_DWORD(dwTemp)) * pContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwDiffuseMask) + fvf.dwDiffuseOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = FLOAT_FROM_DWORD(dwrhw);\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = FLOAT_FROM_DWORD(dwz);\
    ffog = (fz >= pContext->fFogTableEnd) ? 0.0f :\
           (fz <= pContext->fFogTableStart) ? 1.0f :\
           (pContext->fFogTableEnd - fz) * pContext->fFogTableLinearScale;\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset[0];\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(TRUE, &(((DWORD*)nvFifo)[1]));\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#ifdef __cplusplus
}
#endif

#endif // _nvvxmac_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\nvVShad.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _nvVShad_h
#define _nvVShad_h

#include "../../../common/inc/vtxpgmcomp.h"
#include "nvDbg.h"

#ifdef __cplusplus
extern "C"
{
#endif

typedef struct v_shader_register{  //replace with DX define when I find it HMH
    float x;
    float y;
    float z;
    float w;
} VSHADERREGISTER, *PVSHADERREGISTER;

// vertex attribute source info
typedef struct _VASOURCEINFO {
    DWORD dwStream;    // the stream from which this attribute gets its values
    DWORD dwOffset;    // the offset (in bytes) within a component from which the values come
    DWORD dwType;      // the type of data loaded into this attribute
    DWORD dwSrc;       // for tessellator types -- src register for a normal/uv autocalc
    DWORD flag;        // type of autocalc   0=none, 1=normal, 2=autotex
} VASOURCEINFO;

//---------------------------------------------------------------------------

class CVertexShader
{
public:

    enum {
        AUTONONE      = 0,
        AUTONORMAL    = 1,
        AUTOTEXCOORD  = 2,
    };

    enum {
        VA_STREAM_NONE = 0xFFFFFFFF
    };

    VASOURCEINFO        m_vaSourceData[NV_CAPS_MAX_STREAMS];  // sources of the data loaded into the 16 vertex attribute registers

    ParsedProgram       m_ParsedProgram;
    VertexProgramOutput m_ProgramOutput;
    VSHADERREGISTER     m_Attrib[16];
    VSHADERREGISTER     m_Result[15];

    char                m_numConsts            [D3DVS_CONSTREG_MAX_V1_1]; // number of constants set from each index
    VSHADERREGISTER     m_vertexShaderConstants[D3DVS_CONSTREG_MAX_V1_1]; // actual constants

#if (NVARCH >= 0x020)
    PKELVIN_PROGRAM       m_pKelvinProgram;      // compiled kelvin meta-code
#endif

protected:

    DWORD             m_dwHandle;
    DWORD             m_dwFVF;
    DWORD             m_dwCodeSize;          // size of code   declaration
    DWORD            *m_pCodeData;           // ptr to code    declaration data
    DWORD             m_dwStride;            // the total size (in bytes) of all vertex attributes pulled from streams by this shader
    float             m_one, m_zero;
    BOOL              m_bHasConsts;

    VtxProgCompileX86    m_Caller;
    VtxProgCompileKelvin m_CallerKelvin;

public:

    BOOL create (PNVD3DCONTEXT pContext, DWORD dwHandle, DWORD dwStreamSize, DWORD dwCodeSize, DWORD *lpStream, DWORD *lpCode);
    BOOL create (PNVD3DCONTEXT pContext, DWORD dwFVF, DWORD dwHandle);
    BOOL reset ( void );

    CVertexShader(void);
    ~CVertexShader(void);

    inline BOOL  bVAExists            (DWORD dwReg)   {   return ((getVAStream(dwReg) != VA_STREAM_NONE) ? TRUE : FALSE);   }

    inline DWORD getVAStream          (DWORD dwReg)   {   return (m_vaSourceData[dwReg].dwStream);   }
    inline DWORD getVAOffset          (DWORD dwReg)   {   return (m_vaSourceData[dwReg].dwOffset);   }
    inline DWORD getVAType            (DWORD dwReg)   {   return (m_vaSourceData[dwReg].dwType);     }
    inline DWORD getVASrc             (DWORD dwReg)   {   return (m_vaSourceData[dwReg].dwSrc);      }
    inline char  getVAFlag            (DWORD dwReg)   {   return (m_vaSourceData[dwReg].flag);       }

    inline DWORD getAutoNormalStream  (void)          {   for (int i=0; i<NV_CAPS_MAX_STREAMS; i++) {
                                                              if (m_vaSourceData[i].flag == CVertexShader::AUTONORMAL) {
                                                                  return i;
                                                              }
                                                          }
                                                          return VA_STREAM_NONE;
                                                      }

    inline DWORD getAutoTextureStream (DWORD dwCount) {   for (int i=0; i<NV_CAPS_MAX_STREAMS; i++) {
                                                              if (m_vaSourceData[i].flag == CVertexShader::AUTOTEXCOORD) {
                                                                  if (dwCount == 0) return i;
                                                                  else dwCount--;
                                                              }
                                                          }
                                                          return VA_STREAM_NONE;
                                                      }

    inline DWORD getVASize            (DWORD dwReg)   {   if (bVAExists(dwReg)) {
                                                              switch (getVAType(dwReg)) {
                                                              case D3DVSDT_FLOAT1:   // 0
                                                                  return 1 * sizeof(DWORD);
                                                              case D3DVSDT_FLOAT2:   // 1
                                                                  return 2 * sizeof(DWORD);
                                                              case D3DVSDT_FLOAT3:   // 2
                                                                  return 3 * sizeof(DWORD);
                                                              case D3DVSDT_FLOAT4:   // 3
                                                                  return 4 * sizeof(DWORD);
                                                              case D3DVSDT_D3DCOLOR: // 4
                                                                  return 4 * sizeof(BYTE);
                                                              case D3DVSDT_UBYTE4:   // 5
                                                                  return 4 * sizeof(BYTE);
                                                              case D3DVSDT_SHORT2:   // 6
                                                                  return 2 * sizeof(SHORT);
                                                              case D3DVSDT_SHORT4:   // 7
                                                                  return 4 * sizeof(SHORT);
                                                              default:
                                                                  DPF("Unknown vertex array type: %d", getVAType(dwReg));
                                                                  nvAssert(0);
                                                                  return 0;
                                                              }
                                                          } else {
                                                              return 0;
                                                          }
                                                      }

    inline BOOL  hasProgram           (void)   const  {   return m_dwCodeSize ? TRUE : FALSE; }
    inline BOOL  hasConstants         (void)   const  {   return m_bHasConsts;                }
    inline DWORD getStride            (void)   const  {   return m_dwStride;                  }
    inline DWORD getHandle            (void)   const  {   return m_dwHandle;                  }
    inline DWORD getFVF               (void)   const  {   return m_dwFVF;                     }
    inline BOOL  isFvfShader          (void)   const  {   return !(m_dwHandle & 0x1);         }

    // This is temporary.  For the short-term we will have all FVFs share the
    // same vertex shader 0 ala DX7.
    // This may be replaced with a hash table lookup in Rel20.
    static inline DWORD getHandleFromFvf     (DWORD dwFvf)   { return 0ul; }

};

#ifdef __cplusplus
}
#endif

#endif // _nvVShad_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\inc\statdef.h ===
// File created by FindTrace
// Last modified: Wed Jan 03 13:49:51 2001
 

#ifndef STATDEF_H
#define STATDEF_H

typedef struct LENHASH
{
	union
	{
		DWORD offset;
		char *strPtr;
	};
	union
	{
		struct
		{
			WORD numEntries;
			WORD startID;
		};
		DWORD strLen;
	};
} LENHASH;

#define STAT_NUM_FUNCTIONS		382
#define STAT_HASH_TABLE_SIZE	122

#ifdef STAT_INSTANIATE_TABLE
LENHASH statDefHash[STAT_HASH_TABLE_SIZE] = {
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0, {2, 0} },
	{14, {3, 2} },
	{38, {1, 5} },
	{47, {2, 6} },
	{67, {4, 8} },
	{111, {9, 12} },
	{219, {7, 21} },
	{310, {17, 28} },
	{548, {20, 45} },
	{848, {24, 65} },
	{1232, {25, 89} },
	{1657, {22, 114} },
	{2053, {25, 136} },
	{2528, {22, 161} },
	{2968, {23, 183} },
	{3451, {22, 206} },
	{3935, {22, 228} },
	{4441, {19, 250} },
	{4897, {19, 269} },
	{5372, {18, 288} },
	{5840, {9, 306} },
	{6083, {14, 315} },
	{6475, {4, 329} },
	{6591, {7, 333} },
	{6801, {8, 340} },
	{7049, {5, 348} },
	{7209, {5, 353} },
	{7374, {2, 358} },
	{7442, {2, 360} },
	{7512, {1, 362} },
	{7548, {2, 363} },
	{7622, {3, 365} },
	{7736, {1, 368} },
	{7775, {1, 369} },
	{7815, {1, 370} },
	{7856, {1, 371} },
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{7898, {1, 372} },
	{0xffffffff, {0, 0}},
	{7944, {1, 373} },
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{7992, {1, 374} },
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{8044, {1, 375} },
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{8114, {1, 376} },
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{8187, {1, 377} },
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{8267, {1, 378} },
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{8355, {1, 379} },
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{8447, {1, 380} },
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{0xffffffff, {0, 0}},
	{8549, {1, 381} }
};

char statDefList[] = 
		"Blit32\0"
		"Flip32\0"
		"DllMain\0"
		"__Reset\0"
		"nvClear\0"
		"nvClear2\0"
		"SetMode32\0"
		"bltStrBlt\0"
		"DriverInit\0"
		"bltTexture\0"
		"nvDP2Clear\0"
		"nvEnable32\0"
		"FreeAgpHeap\0"
		"MyExtEscape\0"
		"SetDCHandle\0"
		"WaitForIdle\0"
		"blt4CCto4CC\0"
		"nvDP2Points\0"
		"nvDP2TexBlt\0"
		"nvDisable32\0"
		"nvEnableD3D\0"
		"AllocAGPHeap\0"
		"GetModePitch\0"
		"SetEntries32\0"
		"SetPalette32\0"
		"getRootIndex\0"
		"nvDisableD3D\0"
		"nvPaletteBlt\0"
		"ColourControl\0"
		"FirstTimeInit\0"
		"GetScanLine32\0"
		"blt8bppStrBlt\0"
		"bltColourFill\0"
		"bltSimpleCopy\0"
		"bltUpdateClip\0"
		"nvD3DReenable\0"
		"nvDP2LineList\0"
		"nvDP2SetLight\0"
		"nvDP2StateSet\0"
		"nvEnableHeaps\0"
		"nvFreeContext\0"
		"nvRenderState\0"
		"nvSetDX6State\0"
		"nvTextureLock\0"
		"nvUnpalettize\0"
		"AddModeToTable\0"
		"GetBltStatus32\0"
		"GetFlatCodeSel\0"
		"GetFlatDataSel\0"
		"bltAllocAGPMem\0"
		"bltAllocSysMem\0"
		"bltAllocVidMem\0"
		"bltSetBltState\0"
		"bltSlowStoVBlt\0"
		"bltSlowVtoSBlt\0"
		"cacheFogValues\0"
		"nvDP2LineStrip\0"
		"nvDP2SetTexLOD\0"
		"nvDP2SetWRange\0"
		"nvDP2SetZRange\0"
		"nvDP2StreamEnd\0"
		"nvHWSwizzleBlt\0"
		"nvResetContext\0"
		"nvSceneCapture\0"
		"nvSetupContext\0"
		"AboutToBeLoaded\0"
		"CTexture::evict\0"
		"CTexture::fetch\0"
		"CreatePalette32\0"
		"CreateSurface32\0"
		"D3DReadRegistry\0"
		"DestroyDriver32\0"
		"FreeTextureHeap\0"
		"GetDriverInfo32\0"
		"ScaleZFillDepth\0"
		"getAdapterIndex\0"
		"nvContextCreate\0"
		"nvCreateZBuffer\0"
		"nvDP2BufferBlit\0"
		"nvDP2SetIndices\0"
		"nvDP2SetPalette\0"
		"nvDP2VolumeBlit\0"
		"nvDrawPointList\0"
		"nvEnableOverlay\0"
		"nvInitRefCounts\0"
		"nvTexManageInit\0"
		"nvTextureBltDX7\0"
		"nvTextureCreate\0"
		"nvTextureUnlock\0"
		"AcquireUserMutex\0"
		"AllocTextureHeap\0"
		"CTexture::hwLock\0"
		"DestroyPalette32\0"
		"DestroySurface32\0"
		"DrawPrimitives32\0"
		"ReleaseUserMutex\0"
		"_CTexture_rename\0"
		"bltSetSurfaces2D\0"
		"bltSimpleVtoVBlt\0"
		"buildDDHALInfo32\0"
		"nvContextDestroy\0"
		"nvDP2CreateLight\0"
		"nvDP2LineListImm\0"
		"nvDP2SetMaterial\0"
		"nvDP2SetPriority\0"
		"nvDP2SetViewport\0"
		"nvDP2TriangleFan\0"
		"nvDestroyDDLocal\0"
		"nvDrawPrimitives\0"
		"nvFindObjectList\0"
		"nvInitD3DObjects\0"
		"nvTexManageEvict\0"
		"nvTexManageFetch\0"
		"nvTexManageTouch\0"
		"AboutToBeUnloaded\0"
		"CreateDmaContexts\0"
		"CreateTextureHeap\0"
		"GetK32ProcAddress\0"
		"SortDDHalModeList\0"
		"bltAllocWorkSpace\0"
		"bltControlTraffic\0"
		"getDXShareForHead\0"
		"nvAddObjectToList\0"
		"nvCelsiusAACreate\0"
		"nvCelsiusAAMinify\0"
		"nvCreateSurfaceEx\0"
		"nvDP2SetClipPlane\0"
		"nvDP2SetTransform\0"
		"nvDP2TriangleList\0"
		"nvEnableNotifiers\0"
		"nvFindGenericList\0"
		"nvSetContextState\0"
		"nvSetHardwareCaps\0"
		"nvSetRenderTarget\0"
		"nvSwizBlt_lin2swz\0"
		"updateMipMapChain\0"
		"CDefaultVB::create\0"
		"CanCreateSurface32\0"
		"DestroyDmaContexts\0"
		"DestroyTextureHeap\0"
		"DrawOnePrimitive32\0"
		"GetHeapAlignment32\0"
		"bltEarlyErrorCheck\0"
		"getDisplayDuration\0"
		"nvCelsiusAADestroy\0"
		"nvCelsiusAAMagnify\0"
		"nvCelsiusAAMinifyZ\0"
		"nvCreateObjectList\0"
		"nvDP2DrawPrimitive\0"
		"nvDP2TriangleStrip\0"
		"nvDP2UpdatePalette\0"
		"nvDeleteObjectList\0"
		"nvDrawOnePrimitive\0"
		"nvEnableSemaphores\0"
		"nvExpandObjectList\0"
		"nvFVFDrawPointList\0"
		"nvFindSurfaceChain\0"
		"nvInitDDrawObjects\0"
		"nvSetHardwareState\0"
		"nvTextureColorFill\0"
		"nvTranslateLODBias\0"
		"BuildDDHalModeTable\0"
		"CDefaultVB::destroy\0"
		"GetOffsetTranslated\0"
		"GetTranslatedOffset\0"
		"SafeSyncSurfaceData\0"
		"_CTexture_canRename\0"
		"bltCreateContextDMA\0"
		"nvCalculateColorKey\0"
		"nvCelsiusAAMagnifyZ\0"
		"nvContextDestroyAll\0"
		"nvCreateGenericList\0"
		"nvDP2DrawPrimitive2\0"
		"nvDP2DrawTriSurface\0"
		"nvDP2RecordSetLight\0"
		"nvDP2SetPixelShader\0"
		"nvDP2SetRenderState\0"
		"nvDP2TriangleFanImm\0"
		"nvDeleteGenericList\0"
		"nvDrawPointTriangle\0"
		"nvExpandGenericList\0"
		"nvTexManageResetPtr\0"
		"nvTexManageSceneEnd\0"
		"UpdateNonLocalHeap32\0"
		"__DDHAL32_VidMemFree\0"
		"nvCelsiusAAScaledBlt\0"
		"nvDP2CaptureSetLight\0"
		"nvDP2DrawRectSurface\0"
		"nvDP2IndexedLineList\0"
		"nvDP2RecordExtension\0"
		"nvDP2RecordSetWRange\0"
		"nvDP2RecordSetZRange\0"
		"nvDP2SetRenderTarget\0"
		"nvDP2SetStreamSource\0"
		"nvDP2SetVertexShader\0"
		"nvRefreshSurfaceInfo\0"
		"nvSetD3DSurfaceState\0"
		"nvSetDX6TextureState\0"
		"nvSetSurfaceViewport\0"
		"nvStencilBufferInUse\0"
		"nvSwizzleBlt_Lin_Lin\0"
		"nvSwizzleBlt_Lin_Swz\0"
		"nvSwizzleBlt_Swz_Lin\0"
		"nvSwizzleBlt_Swz_Swz\0"
		"nvTextureDefaultFree\0"
		"nvTextureStretchBlit\0"
		"GetPointerTextureHeap\0"
		"SafeSyncVideoPortData\0"
		"__DDHAL32_VidMemAlloc\0"
		"nvAllocateContextDMAs\0"
		"nvDP2CaptureExtension\0"
		"nvDP2CaptureSetWRange\0"
		"nvDP2CaptureSetZRange\0"
		"nvDP2IndexedLineList2\0"
		"nvDP2IndexedLineStrip\0"
		"nvDP2RecordSetIndices\0"
		"nvFindNextCubemapFace\0"
		"nvGetObjectFromHandle\0"
		"nvSetDx5TriangleState\0"
		"nvStencilBufferExists\0"
		"nvSwizBlt_cpu_lin2lin\0"
		"nvSwizBlt_cpu_lin2swz\0"
		"nvSwizBlt_cpu_swz2lin\0"
		"nvSwizBlt_cpu_swz2swz\0"
		"nvSwizBlt_gpu_lin2swz\0"
		"nvTexManageAddTexture\0"
		"nvTexManageAdvancePtr\0"
		"nvTextureDefaultAlloc\0"
		"CDefaultVB::CDefaultVB\0"
		"CDriverContext::create\0"
		"CSimpleSurface::create\0"
		"CSimpleSurface::isBusy\0"
		"D3DLockExecuteBuffer32\0"
		"GetAvailDriverMemory32\0"
		"WaitForVerticalBlank32\0"
		"invalidateTextureCache\0"
		"nvAllocateDDrawObjects\0"
		"nvCelsiusAAScaledBltHW\0"
		"nvClearObjectListEntry\0"
		"nvDP2CaptureSetIndices\0"
		"nvDP2CreatePixelShader\0"
		"nvDP2DeletePixelShader\0"
		"nvDP2MultiplyTransform\0"
		"nvDP2RecordSetMaterial\0"
		"nvDP2RecordSetViewport\0"
		"nvDP2SetStreamSourceUM\0"
		"nvFVFDrawPointTriangle\0"
		"nvIndexedPointTriangle\0"
		"nvTexManageAdvanceList\0"
		"nvTextureCreateSurface\0"
		"CDefaultVB::~CDefaultVB\0"
		"CDriverContext::destroy\0"
		"CSimpleSurface::cpuLock\0"
		"Lock32: fpvidmem = %08x\0"
		"nvAddSurfaceChainToList\0"
		"nvAllocDriverStructures\0"
		"nvCalculateBumpMapState\0"
		"nvClearGenericListEntry\0"
		"nvCreateContextListHeap\0"
		"nvDP2CaptureSetMaterial\0"
		"nvDP2CaptureSetViewport\0"
		"nvDP2ClippedTriangleFan\0"
		"nvDP2CreateVertexShader\0"
		"nvDP2DeleteVertexShader\0"
		"nvDP2IndexedTriangleFan\0"
		"nvDP2RecordSetClipPlane\0"
		"nvDP2RecordSetTransform\0"
		"nvSetD3DSurfaceViewport\0"
		"nvTextureDestroySurface\0"
		"CComplexSurface::cpuLock\0"
		"CSimpleSurface::hwUnlock\0"
		"CTexture::calcMipMapSize\0"
		"CTexture::enableRenaming\0"
		"CTexture::internalRename\0"
		"D3DCreateExecuteBuffer32\0"
		"D3DCreateTextureContexts\0"
		"D3DUnlockExecuteBuffer32\0"
		"bltDestroyAllContextDMAs\0"
		"bltPotentialFaultHandler\0"
		"nvCalculateSurfaceParams\0"
		"nvCalculateZBufferParams\0"
		"nvDP2CaptureSetClipPlane\0"
		"nvDP2CaptureSetTransform\0"
		"nvDP2IndexedTriangleList\0"
		"nvDP2SetPixelShaderConst\0"
		"nvDestroyContextListHeap\0"
		"nvDrawPrimitives2 (%08x)\0"
		"nvTexManageRemoveTexture\0"
		"CComplexSurface::disown()\0"
		"CTexture[%08x]::destroy()\0"
		"D3DDestroyExecuteBuffer32\0"
		"D3DDestroyTextureContexts\0"
		"DrawOneIndexedPrimitive32\0"
		"Unlock32: fpvidmem = %08x\0"
		"nvCelsiusAAMinifyInternal\0"
		"nvCreateSurfaceWithFormat\0"
		"nvDP2DrawIndexedPrimitive\0"
		"nvDP2IndexedTriangleList2\0"
		"nvDP2IndexedTriangleStrip\0"
		"nvDP2RecordSetPixelShader\0"
		"nvDP2RecordSetRenderState\0"
		"nvDP2SetTextureStageState\0"
		"nvDP2SetVertexShaderConst\0"
		"nvDrawOneIndexedPrimitive\0"
		"nvFVFIndexedPointTriangle\0"
		"nvSetDx6MultiTextureState\0"
		"BuildDefaultDDHalModeTable\0"
		"CTexture[%08x]::CTexture()\0"
		"nvCelsiusAAMagnifyInternal\0"
		"nvCheckSystemMemorySurface\0"
		"nvDP2CaptureSetPixelShader\0"
		"nvDP2CaptureSetRenderState\0"
		"nvDP2DrawIndexedPrimitive2\0"
		"nvDP2RecordSetStreamSource\0"
		"nvDP2RecordSetVertexShader\0"
		"CNvObject::dbgTestIntegrity\0"
		"CTexture::getCubeMapFaceNum\0"
		"CTexture::internalCanRename\0"
		"CTexture[%08x]::~CTexture()\0"
		"D3DCanCreateExecuteBuffer32\0"
		"nvAutoPaletteCheckAndRevert\0"
		"nvCalculateHardwareStateDX5\0"
		"nvCelsiusSet2Stage1Combiner\0"
		"nvCreateSystemMemorySurface\0"
		"nvDP2CaptureSetStreamSource\0"
		"nvDP2CaptureSetVertexShader\0"
		"nvDeleteSystemMemorySurface\0"
		"nvValidateTextureStageState\0"
		"nvVolumeSwizBlt_cpu_lin2swz\0"
		"nv4ValidateTextureStageState\0"
		"nvCreateSurfaceWithoutFormat\0"
		"nvDP2RecordSetStreamSourceUM\0"
		"nvGetWin16MutexProcAddresses\0"
		"CComplexSurface[%08x]::swap()\0"
		"CSimpleSurface[%08x]::reset()\0"
		"GetSelectorsFromDisplayDriver\0"
		"nvCelsiusAASelectSuperBuffers\0"
		"nvDP2CaptureSetStreamSourceUM\0"
		"nvSetCelsuisBumpMap1Combiners\0"
		"nvSetCelsuisBumpMap2Combiners\0"
		"CSimpleSurface[%08x]::disown()\0"
		"FreeSelectorsFromDisplayDriver\0"
		"nvCalculateDirectHardwareState\0"
		"nvCelsiusAASelectNormalBuffers\0"
		"nvDP2RecordSetPixelShaderConst\0"
		"nvSetMultiTextureHardwareState\0"
		"nvTextureDestroy - handle=%08x\0"
		"nvTextureGetSurf - handle=%08x\0"
		"CSimpleSurface[%08x]::destroy()\0"
		"nvConvertTextureStageToDX5Class\0"
		"nvDP2CaptureSetPixelShaderConst\0"
		"nvDP2RecordSetTextureStageState\0"
		"nvDP2RecordSetVertexShaderConst\0"
		"CComplexSurface::tagRenameEnable\0"
		"CComplexSurface[%08x]::destroy()\0"
		"nvDP2CaptureSetTextureStageState\0"
		"nvDP2CaptureSetVertexShaderConst\0"
		"nvSwizzleBlt_Lin_Swz_FullTexture\0"
		"nvKelvinValidateTextureStageState\0"
		"nvPointIndexedTriangle (%d,%x,%p)\0"
		"nvCelsiusValidateTextureStageState\0"
		"nvTexManageEvictAll: pContext=%08x\0"
		"nvCelsiusSetTextures3StageCombiners\0"
		"nvCreateVidHeapVarsAndPseudoNotifier\0"
		"nvPointNonIndexedTriangle (%d,%x,%p)\0"
		"CTexture[%08x]::updateLinearSurface()\0"
		"nvSetDefaultMultiTextureHardwareState\0"
		"nvWireframeIndexedTriangle (%d,%x,%x)\0"
		"CTexture[%08x]::updateSwizzleSurface()\0"
		"nvSetRenderTargetDX7 (rt = %d, zb = %d)\0"
		"nvWireframeNonIndexedTriangle (%d,%x,%x)\0"
		"CSimpleSurface[%08x]::swap(pSurface=%08x)\0"
		"CTexture[%08x]::prepareLinearAsRenderTarget()\0"
		"nvTextureSwap - hContext=%08x, h1=%08x, h2=%08x\0"
		"CSimpleSurface[%08x]::create(pTemplateSurface=%08x)\0"
		"SetSurfaceColorKey32: lpSetCK->lpDD=%08x, lpSetCK->lpDDSurface = %08x\0"
		"CTexture[%08x]::create(dwThisFace=%d,pBaseTexture=%08x,dwMipMapLevel=%d)\0"
		"CComplexSurface[%08x]::create(dwSize=%08x,dwAllowedHeaps=%x,dwPreferredHeap=%x)\0"
		"CSimpleSurface[%08x]::own(dwAddress=%08x,dwPitch=%08x,dwH=%08x,dwHeapLoc=%x,bOwnMem=%d)\0"
		"CComplexSurface[%08x]::own(dwAddress=%08x,dwPitch=%08x,dwLogH=%08x,dwHeapLoc=%x,bOwnMem=%d)\0"
		"CSimpleSurface[%08x]::create(dwPitch=%08x,dwHt=%08x,dwDp=%08x,dwAllHeaps=%x,dwPrefHeap=%x,dwFlags=%x)\0"
		"CTexture[%08x]::create(dwWidth=%d,dwHeight=%d,dwBPP=%d,dwMipMapCount=%d,dwFormat=%x,dwAllowedHeaps=%x,dwPreferredHeap=%x)\0";
#endif	 //STAT_INSTANIATE_TABLE
#endif	// ifndef <filename>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\d3dContext.cpp ===
/*
 * Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 * (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: d3dContext.cpp                                                    *
*   The Direct3D context management routines.                               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/02/97 - re-wrote and cleaned up.     *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

#ifdef PROFILE_INDEX
void nvCreateIndexProfile();
void nvDestroyIndexProfile();
#endif //PROFILE_INDEX

#ifdef NV_DISASM
HANDLE nvPusherFile               = 0;
BOOL   nvPusherDisassemblerEnable = 0;
#endif

#ifdef DEBUG_SURFACE_PLACEMENT
extern CSurfaceDebug csd;
#endif

//-------------------------------------------------------------------------

/*
 * Miscellaneous D3D context related routines.
 */
BOOL nvCreateContextListHeap
(
    GLOBALDATA *pDriverData
)
{
    dbgTracePush ("nvCreateContextListHeap");
    dbgTracePop();
    return (TRUE);
}

//-------------------------------------------------------------------------

BOOL nvDestroyContextListHeap
(
    void
)
{
    PNVD3DCONTEXT   pContext;
    PNVD3DCONTEXT   pContextNext;

    dbgTracePush ("nvDestroyContextListHeap");

    /*
     * Free any contexts that are still allocated.
     */
    pContext = (PNVD3DCONTEXT)getDC()->dwContextListHead;
    while (pContext)
    {
        pContextNext = pContext->pContextNext;
        FreeIPM(pContext);
        getDC()->dwD3DContextCount--;
        pContext = pContextNext;
    }

    dbgTracePop();
    return (TRUE);
}

/*
 * --------------------------------------------------------------------------
 * nvDestroyPreapprovedContexts
 *
 *    This function destroys all preapproved contexts that had been created
 *    and never migrated to the natural ones.
 * --------------------------------------------------------------------------
 */
void nvDestroyPreapprovedContexts(void)
{
    PNVD3DCONTEXT pPreapprovedContext, pPreapprovedContextNext;
    pPreapprovedContext = (PNVD3DCONTEXT)getDC()->dwPreapprovedContextListHead;
    getDC()->dwPreapprovedContextListHead = 0;
    while (pPreapprovedContext)
    {
        pPreapprovedContextNext = (PNVD3DCONTEXT)pPreapprovedContext->pContextNext;
        FreeIPM(pPreapprovedContext);
        pPreapprovedContext = pPreapprovedContextNext;
    }
}

/*
 * --------------------------------------------------------------------------
 * nvFindPreapprovedContext
 *
 *    This function searches the getDC()->dwPreapprovedContextListHead
 *    list of preapproved PNVD3DCONTEXT structures by the process ID.
 * --------------------------------------------------------------------------
 */
PNVD3DCONTEXT nvFindPreapprovedContext(DWORD dwPID, BOOL bRemove)
{
    PNVD3DCONTEXT pPreapprovedContext, pPreapprovedContextPrev;
    pPreapprovedContextPrev = NULL;
    pPreapprovedContext = (PNVD3DCONTEXT)getDC()->dwPreapprovedContextListHead;
    while (pPreapprovedContext)
    {
        if(pPreapprovedContext->pid == dwPID)
        {
            if (bRemove)
            {
                if (pPreapprovedContextPrev)
                    pPreapprovedContextPrev->pContextNext = pPreapprovedContext->pContextNext;
                else
                    getDC()->dwPreapprovedContextListHead = pPreapprovedContext->pContextNext;
            }
            return pPreapprovedContext;
        }
        pPreapprovedContextPrev = pPreapprovedContext;
        pPreapprovedContext = (PNVD3DCONTEXT)pPreapprovedContext->pContextNext;
    }
    return NULL;
}

/*
 * --------------------------------------------------------------------------
 * nvGetPreapprovedContext
 *
 *    This function returns a pointer to a PNVD3DCONTEXT structure
 *    which is used for saving application belongings before the natural
 *    call to the nvContextCreate has been made. The nvContextCreate must
 *    inherit all significant information being kept here. First the function
 *    looks for the PreapprovedContext in the existing list and that failed it
 *    allocates a new structure.
 * --------------------------------------------------------------------------
 */
PNVD3DCONTEXT nvGetPreapprovedContext(void)
{
    PNVD3DCONTEXT pPreapprovedContext;
    DWORD         dwPID = GetCurrentProcessId();
    if (pPreapprovedContext = nvFindPreapprovedContext(dwPID, FALSE))
        return pPreapprovedContext;
    pPreapprovedContext = (PNVD3DCONTEXT)AllocIPM(sizeof(NVD3DCONTEXT));
    if (!pPreapprovedContext)
        return NULL;
    memset(pPreapprovedContext, 0, sizeof(NVD3DCONTEXT));

    // Set the process ID for the context.
    pPreapprovedContext->pid = dwPID;
#ifdef TEX_MANAGE
    // initialize texture manager
    nvTexManageInit (pPreapprovedContext);
#endif

    /*
     * Update the context list.
     */
    pPreapprovedContext->pContextPrev = (PNVD3DCONTEXT)NULL;
    pPreapprovedContext->pContextNext = (PNVD3DCONTEXT)getDC()->dwPreapprovedContextListHead;
    if (pPreapprovedContext->pContextNext)
        pPreapprovedContext->pContextNext->pContextPrev = pPreapprovedContext;
    getDC()->dwPreapprovedContextListHead = pPreapprovedContext;
    return pPreapprovedContext;
}

/*
 * D3D HAL context callback routines
 */

/*
 * --------------------------------------------------------------------------
 * NvContextCreate
 *
 * LPD3DHAL_CONTEXTCREATEDATA pccd
 *    Pointer to a structure containing things including the current
 *    rendering surface, the current Z surface, and the DirectX object
 *    handle, etc.
 * --------------------------------------------------------------------------
 */

DWORD __stdcall nvContextCreate
(
    LPD3DHAL_CONTEXTCREATEDATA  pccd
)
{
    unsigned char              *pData = 0;
    HDDRVITEM                   hContext;
    LPDDRAWI_DDRAWSURFACE_INT   pDDS   = 0;
    LPDDRAWI_DDRAWSURFACE_INT   pDDSZ  = 0;
    LPDDRAWI_DDRAWSURFACE_LCL   pDDSLcl  = 0;
    LPDDRAWI_DDRAWSURFACE_GBL   pDDSGbl  = 0;
    LPDDRAWI_DDRAWSURFACE_LCL   pDDSLclZ = 0;
    LPDDRAWI_DIRECTDRAW_GBL     pDDGbl   = 0;

    dbgTracePush ("nvContextCreate");

    // analyzer markers
#ifdef NV_MARKER
    {
        extern DWORD dwMarkerCount;
        dwMarkerCount = 0;
    }
#endif

    // push buffer disassembler
#ifdef NV_DISASM
    {
        nvPusherFile = NvCreateFile("\\PushData.bin",GENERIC_WRITE,0,0,CREATE_ALWAYS,0,0);
        if (nvPusherFile == INVALID_HANDLE_VALUE)
        {
            nvPusherFile = 0;
        }
    }
#endif

    // Validate the direct draw surface pointers.
#ifndef WINNT // Chas said.
    if (global.dwDXRuntimeVersion >= 0x0700)
    {
        // directX 7 or higher.
        if ((pDDSLcl = pccd->lpDDSLcl) == NULL) {
            pccd->ddrval = DDERR_CURRENTLYNOTAVAIL;
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
    }
    else
#endif // WINNT
    {
        // directX 6 or earlier and NT cause Chas said so.
        if ((pccd->lpDDSLcl == NULL))
        {
            pccd->ddrval = DDERR_CURRENTLYNOTAVAIL;
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
        if ((pDDSLcl = DDS_LCL(pccd->lpDDSLcl)) == NULL)
        {
            pccd->ddrval = DDERR_CURRENTLYNOTAVAIL;
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
    }

    if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
    {
        pccd->ddrval = DDERR_CURRENTLYNOTAVAIL;
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }
    if ((pDDSGbl = pDDSLcl->lpGbl ) == NULL)
    {
        pccd->ddrval = DDERR_CURRENTLYNOTAVAIL;
        dbgTracePop();
        return DDHAL_DRIVER_HANDLED;
    }
#ifndef WINNT
    if (global.dwDXRuntimeVersion >= 0x0700)
    {
        // directX 7 or higher.
        pDDSLclZ = pccd->lpDDSZLcl;
    }
    else
#endif // !WINNT
    {
        // directX 6 or earlier
        if ((pccd->lpDDSZLcl != NULL)
            && ((pDDSLclZ = DDS_LCL(pccd->lpDDSZLcl)) == NULL)) {
            pccd->ddrval = DDERR_CURRENTLYNOTAVAIL;
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
    }

    if (pDDSLclZ && (pDDSLclZ->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
    {
        pccd->ddrval = DDERR_CURRENTLYNOTAVAIL;
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    // Get pointer to global driver data structure.
    if (global.dwDXRuntimeVersion >= 0x0700) {
        pDDGbl = pccd->lpDDLcl->lpGbl;
    }
    else {
        pDDGbl = pccd->lpDDGbl;
    }
    nvSetDriverDataPtrFromDDGbl (pDDGbl);

#ifdef WINNT
    // on Win2K the registry is only read on a mode switch - read it here too so that
    // the settings can take immediate effect on windowed app too
    D3DReadRegistry (pDriverData);
#endif

    // load the logo if necessary
    nvLoadLogo();

    // connect to pm
#ifndef WINNT
    // ben BUGBUG philosophical ugliness
    DWORD dwID = (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0097_KELVIN) ?
                     0x020 :
                     (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) ?
                         0x010 :
                         0x004;
    pmConnect (pDXShare->dwHeadNumber,(U032)NvDeviceBaseGet(NV_DEV_BASE,pDriverData->dwDeviceIDNum), dwID);
#endif // !WINNT

    PNVD3DCONTEXT pContext;

    // Try to find the context among existing preapproved contexts already allocated
    pContext = nvFindPreapprovedContext (pccd->dwPID, TRUE);

    if (!pContext)
    {
        // Allocate a new context from the context array.
        hContext = (HDDRVITEM)AllocIPM(sizeof(NVD3DCONTEXT));

        // Get the pointer to the newly allocated context.
        pContext = (PNVD3DCONTEXT)hContext;
        if (!pContext)
        {
            NvReleaseSemaphore(pDriverData);
            DPF_LEVEL (NVDBG_LEVEL_ERROR, "nvContextCreate - Bad Context");
            pccd->ddrval = D3DHAL_OUTOFCONTEXTS;
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
        memset(pContext, 0, sizeof(NVD3DCONTEXT));

        // Set the process ID for the context.
        pContext->pid = pccd->dwPID;

#ifdef TEX_MANAGE
        // initialize texture manager
        nvTexManageInit (pContext);
#endif
    }
    else {
        nvAssert(0);
    }

    // Save off the applications DirectX version level.
    //      1 -> DX5 (?)
    //      2 -> DX6
    //      3 -> DX7
    //      4 -> DX8
    switch (pccd->dwhContext)
    {
        default: // pessimism
        case 0: pContext->dwDXAppVersion = 0x300;
                break;
        case 1: pContext->dwDXAppVersion = 0x500;
                break;
        case 2: pContext->dwDXAppVersion = 0x600;
                break;
        case 3: pContext->dwDXAppVersion = 0x700;
                break;
        case 4: pContext->dwDXAppVersion = 0x800;
                break;
    }

    // Return the handle of the new context.
    pccd->dwhContext = hContext;

    // cache off a pointer to pDXShare & pDriverData
#ifdef WINNT
    pContext->ppdev    = ppdev;
#else // !WINNT
    pContext->pDXShare = pDXShare;
#endif // !WINNT
    pContext->pDriverData = pDriverData;

    // initialize the surface specific context data
    nvAssert (pDDSLcl);   // we must have a render target
    CNvObject *pNvObj = GET_PNVOBJ (pDDSLcl);
    nvAssert (IS_VALID_PNVOBJ(pNvObj));     // we better have gotten a CreateSurface32 call for this already
    if( !IS_VALID_PNVOBJ(pNvObj) ) {
            DPF_LEVEL (NVDBG_LEVEL_ERROR, "nvContextCreate - Bad Render Target");
            FreeIPM(pContext);
            pccd->dwhContext = 0;
            pccd->ddrval = DDERR_SURFACELOST;
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
    }
    if (global.dwDXRuntimeVersion < 0x0700) {
        // nvobject pointers may have been swapped around amongst ddslcls since this
        // surface was created. make sure this nvobject's handle still points to this ddslcl.
        pNvObj->setHandle ((DWORD)pDDSLcl);
    }
    pContext->pRenderTarget = pNvObj->getSimpleSurface();
    pContext->dwRTHandle = pNvObj->getHandle();

    // Set up the default viewport
    nvSetSurfaceViewport (pContext);

    dbgSetFrontRenderTarget (pContext, pContext->pRenderTarget);

    // check for a z-buffer
    if (pDDSLclZ) {
        pNvObj = GET_PNVOBJ (pDDSLclZ);
        nvAssert (IS_VALID_PNVOBJ(pNvObj));     // we better have gotten a CreateSurface32 call for this already
        if (global.dwDXRuntimeVersion < 0x0700) {
            pNvObj->setHandle ((DWORD)pDDSLclZ);
        }
        pContext->pZetaBuffer = pNvObj->getSimpleSurface();
        pContext->dwZBHandle = pNvObj->getHandle();
    }
    else {
        pContext->pZetaBuffer = NULL;
        pContext->dwZBHandle  = 0;
    }

    // now that both surfaces are set, check that we can actually render with this combination.
    if (!nvCheckBufferCompatibility (pContext->pRenderTarget, pContext->pZetaBuffer,
                                     pDDSLclZ, pContext->dwDXAppVersion) ||
        !CKelvinAAState::CheckBufferMemoryConfig(pContext)) {
        FreeIPM(pContext);
        pccd->dwhContext = 0;
        pccd->ddrval = DDERR_CURRENTLYNOTAVAIL;
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

#ifdef WINNT
    /*
     * Winnt only: save a ptr to the DX driver state associated with
     * this context.
     */
    pContext->lpDD = pccd->lpDDLcl->lpGbl;
#endif // #ifdef WINNT

    // save the DIRECTDRAW_LCL and GBL associated with this context
    if (global.dwDXRuntimeVersion >= 0x0700) {
        pContext->dwDDLclID = (DWORD)(pccd->lpDDLcl);
        nvAssert (pDDGbl == pccd->lpDDLcl->lpGbl);  // there are two ways to access this. make sure they're ==
    }
    else {
        pContext->dwDDLclID = 0;     // this isn't available before DX7
        nvAssert (pDDGbl == pccd->lpDDGbl);  // there are two ways to access this. make sure they're ==
    }
    pContext->dwDDGblID = (DWORD)pDDGbl;

    /*
     * Do the hardware specific context setup.
     */
    if (!nvSetupContext(pContext))
    {
        /*
         * When this call fails, it means there was some sort of problem with the
         * surface format.  Either an unsupported pixel format was specified or
         * an unsupported pixel/zeta format was specified.
         * Free the context memory and return an error.
         */
        FreeIPM(pContext);
        NvReleaseSemaphore(pDriverData);
        pccd->dwhContext = 0;
        pContext  = 0;
        pccd->ddrval = DDERR_INVALIDPIXELFORMAT;
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    // zero out state set code
    pContext->pStateSets           = NULL;
    pContext->dwMaxStateSetHandles = 0;
    pContext->dwCurrentStateSet    = 0;

    // Update the open context count.
    getDC()->dwD3DContextCount++;

    // Update the context list.
    pContext->pContextPrev = (PNVD3DCONTEXT)NULL;
    pContext->pContextNext = (PNVD3DCONTEXT)getDC()->dwContextListHead;
    if (pContext->pContextNext) {
        pContext->pContextNext->pContextPrev = pContext;
    }
    getDC()->dwContextListHead = pContext;

    pContext->dwTickLastUsed = GetTickCount();

    pContext->bClearLogo = FALSE;

    // Initialize vxd frame count for statistics driver
    DDFLIPINIT();

    nvInitTLData (pContext);
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvInitKelvinData (pContext);
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvInitCelsiusData (pContext);
    }
#endif

    // Create a default vertex shader
    pContext->pCurrentVShader = new CVertexShader;
    nvAssert(pContext->pCurrentVShader != NULL);
    CNvObject *pObj = new CNvObject(pContext->pid);
    nvAssert(pObj != NULL);
    pObj->setObject (CNvObject::NVOBJ_VERTEXSHADER, pContext->pCurrentVShader);

    // add this handle 0 object to the global list of objects
    // this is our default
    PNV_OBJECT_LIST pNvList = nvFindObjectList(pContext->dwDDLclID, &global.pNvVShaderLists);
    nvAddObjectToList(pNvList, pObj, 0);

    if (pContext->dwDXAppVersion >= 0x0800) {
        pContext->pVShaderConsts = new VertexShaderConsts;
        memset(pContext->pVShaderConsts, 0, sizeof(VertexShaderConsts));
    } else {
        pContext->pVShaderConsts = NULL;
    }

    // stateset schtuff
    // initially put things in 'set' (rather than 'record') mode
    pContext->pDP2FunctionTable = &nvDP2SetFuncs;

    // We clearly haven't seen any triangles yet =)
    pContext->bSeenTriangles = FALSE;

    // Initialize view and world matrix to unit matrix to avoid a mess in supertri if we try to set hwstate
    // before we get a chance to initialize the matrices (usually happens when kelvin AA is enabled)
    pContext->xfmView._11 = 1.0;
    pContext->xfmView._22 = 1.0;
    pContext->xfmView._33 = 1.0;
    pContext->xfmView._44 = 1.0;

    pContext->xfmWorld[0]._11 = 1.0;
    pContext->xfmWorld[0]._22 = 1.0;
    pContext->xfmWorld[0]._33 = 1.0;
    pContext->xfmWorld[0]._44 = 1.0;


#ifdef NV_PROFILE
    // Start up profiler
    nvpCreate();
#endif //NV_PROFILE

#ifdef PROFILE_INDEX
    nvCreateIndexProfile();
#endif // PROFILE_INDEX
#ifdef DEBUG
#ifdef HAVE_NV_FILE_FACILITY
    createDPFLog();
#endif
#endif
#ifdef NV_MARKER
    *(DWORD*)(VIDMEM_ADDR(pDriverData->BaseAddress)) = 0xcccccccc;
#endif

    // make sure we have a valid texture heap
    nvAssert (getDC()->nvD3DTexHeapData.dwHandle);  // delete after sept00

#ifdef TEX_MANAGE_TEST
    // chew up some memory
    {
        DWORD dwAddr, dwStatus, dwSize;
        //dwSize = 24 * (1<<20);  // 24 MB
        dwSize = 0x01a34000;  // 2 of 3 allocations in multitexture SDK app will succeed (1280x1024x32)
        //dwSize = 0x01a36000;  // 1 of 3 allocations in multitexture SDK app will succeed (1280x1024x32)
        //dwSize = 0x01a38000;  // 0 of 3 allocations in multitexture SDK app will succeed (1280x1024x32)
        NVHEAP_ALLOC (dwStatus, dwAddr, dwSize, TYPE_TEXTURE);
        nvAssert (dwStatus == 0);  // allocation successful
    }
#endif

#ifdef  STEREO_SUPPORT
    StereoContextCreate();
#endif  //STEREO_SUPPORT

#if (NVARCH >= 0x010)
    // Set up a few defaults
    pContext->aa.fWidthAmplifier  = 1.0f;
    pContext->aa.fHeightAmplifier = 1.0f;
    pContext->aa.dwDepthAmplifier = 1;
    pContext->aa.fLODBias         = 0.0f;
    pContext->aa.dwLinePointSize  = 0x8; // 1.0 in 6.3 fmt
#endif

    if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_CT_11M)
    {
        NV_CFGEX_GET_FLATPANEL_INFO_MULTI_PARAMS panel;
        NV_CFGEX_GET_MONITOR_INFO_MULTI_PARAMS monitor0, monitor1;
        NV_CFGEX_VBLANK_ENABLED_PARAMS mon0vb;
        NV_CFGEX_VBLANK_ENABLED_PARAMS pan0vb;
        DWORD dwSWidth, dwSHeight;
        NvRmConfigGet (pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFG_SCREEN_WIDTH,  &dwSWidth);
        NvRmConfigGet (pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFG_SCREEN_HEIGHT, &dwSHeight);
        panel.Head =0;
        NvRmConfigGetEx (pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_GET_FLAT_PANEL_INFO_MULTI, &panel,sizeof(panel) );
        if ((panel.Head == 0) && (!panel.FlatPanelConnected) )
        {

            panel.Head =1;
            NvRmConfigGetEx (pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_GET_FLAT_PANEL_INFO_MULTI, &panel,sizeof(panel) );
        }

        if (panel.FlatPanelConnected)
        {
            pan0vb.Head = panel.Head;
            NvRmConfigGetEx (pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_VBLANK_ENABLED, &pan0vb,sizeof(pan0vb));

        }

        monitor0.Head = 0;
        NvRmConfigGetEx (pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_GET_MONITOR_INFO_MULTI, &monitor0,sizeof(monitor0));

        if (monitor0.MonitorConnected)
        {
            mon0vb.Head = 0;
            NvRmConfigGetEx (pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_VBLANK_ENABLED, &mon0vb,sizeof(mon0vb));
        }
        else
        {
            monitor1.Head = 1;
            NvRmConfigGetEx (pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_GET_MONITOR_INFO_MULTI, &monitor1,sizeof(monitor1));
            if (monitor0.MonitorConnected)
            {
                mon0vb.Head = 0;
                NvRmConfigGetEx (pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_VBLANK_ENABLED, &mon0vb,sizeof(mon0vb));
            }
        }



        pContext->bScaledFlatPanel = false;
        if (panel.FlatPanelConnected && (dwSWidth > 640) && (dwSHeight > 480) && (panel.FlatPanelMode == 0) && (dwSWidth < panel.FlatPanelSizeX) && (dwSHeight < panel.FlatPanelSizeY))
            if (!mon0vb.Enabled && pan0vb.Enabled)
            {
                pContext->bScaledFlatPanel = true;
            }

    }

    /*
     * Context creation complete, return successfully.
     */
    NvReleaseSemaphore(pDriverData);
    pccd->ddrval = DD_OK;
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

//-------------------------------------------------------------------------

void nvFreeContext (PNVD3DCONTEXT pContext)
{
    DWORD i;

    dbgTracePush ("nvFreeContext");

    // free the lights
    delete [](pContext->pLightArray);

    // free palettes - MS provides no formal mechanism for freeing palettes
    // a potential problem exists if the D3D context is destroyed but not the DDRAW context.
    // the video memory associated with the palette may be released and the pointer in our palette
    // object will point to memory we no longer own. Release the palette memory here to prevent this.
    // nvDP2UpdatePalette will reallocate the video memory if required.
    PNV_OBJECT_LIST pNvPaletteList = nvFindObjectList(pContext->dwDDLclID, &global.pNvPaletteLists);
    for(i = 0; i < pNvPaletteList->dwListSize; i ++) {
        CNvObject *pNvObj = nvGetObjectFromHandle(pContext->dwDDLclID, i, &global.pNvPaletteLists);
        if (pNvObj) {
            // free the video memory associated with this palette
            pNvObj->getPaletteSurface()->destroy();
        }
    }

    // free state sets
    if (pContext->pStateSets)
    {
        for (i = 0; i < pContext->dwMaxStateSetHandles; i++) {
            stateSetDelete (pContext, i);
        }

        FreeIPM (pContext->pStateSets);
    }
    pContext->pStateSets           = NULL;
    pContext->dwMaxStateSetHandles = 0;

    // only free the global data when the last context is gone
    getDC()->dwD3DContextCount --;
    if (getDC()->dwD3DContextCount == 0)
    {
#if (NVARCH >= 0x010)
        // free the celsius combiner programs
        PCELSIUSCOMBINERPROGRAM pProgram, pNext;
        for (i = 0; i < CELSIUSCPTABLE_SIZE; i++) {
            pProgram = global.celsiusCombinerProgramTable[i];
            while (pProgram) {
                pNext = pProgram->pNext;
                FreeIPM (pProgram);
                pProgram = pNext;
            }
            global.celsiusCombinerProgramTable[i] = NULL;
        }
#endif  // NVARCH >= 0x010
    }

    // remove context from context list
    if (pContext->pContextPrev) {
        pContext->pContextPrev->pContextNext = pContext->pContextNext;
    }
    if (pContext->pContextNext) {
        pContext->pContextNext->pContextPrev = pContext->pContextPrev;
    }
    if (getDC()->dwContextListHead == pContext) {
        getDC()->dwContextListHead = pContext->pContextNext;
    }

    if (pContext->pVShaderConsts) {
        delete pContext->pVShaderConsts;
        pContext->pVShaderConsts = NULL;
    }

    FreeIPM(pContext);

    dbgTracePop();
}

//-------------------------------------------------------------------------

/*
 * nvContextDestroy
 *
 * d3d callback to destroy the given context and all association with it
 */

DWORD __stdcall nvContextDestroy
(
    LPD3DHAL_CONTEXTDESTROYDATA pcdd
)
{
    dbgTracePush ("nvContextDestroy");

    // Get pointer to context being destroyed.
    PNVD3DCONTEXT pContext = (PNVD3DCONTEXT)pcdd->dwhContext;
    if (!pContext)
    {
        DPF_LEVEL (NVDBG_LEVEL_ERROR, "nvContextDestroy - Bad Context");
        pcdd->ddrval = D3DHAL_CONTEXT_BAD;
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    // Get pointer to global driver data structure
    nvSetDriverDataPtrFromContext(pContext);

#ifdef DEBUG_SURFACE_PLACEMENT
    csd.Destroy();
#endif

    if (getDC()->dwD3DContextCount == 0)
    {
        pcdd->ddrval = DD_OK;
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

#ifdef  STEREO_SUPPORT
    StereoContextDestroy(pContext);
#endif  //STEREO_SUPPORT

#ifdef NV_MARKER
    *(DWORD*)(VIDMEM_ADDR(pDriverData->BaseAddress)) = 0xdddddddd;
#endif

    // push buffer disassembler
#ifdef NV_DISASM
    {
        if (nvPusherFile)
        {
            NvCloseHandle(nvPusherFile);
            nvPusherFile = 0;
        }
    }
#endif

     // disconnect from pm
     pmDisconnect();

#ifdef NV_PROFILE
    // Shut down profiler
    nvpDestroy();
#endif //NV_PROFILE

#ifdef PROFILE_INDEX
    // Shut down profiler
    nvDestroyIndexProfile();
#endif //PROFILE_INDEX

    // Perform any cleanup required.

    // kill AA
#if (NVARCH >= 0x010)
    nvCelsiusAADestroy (pContext);
#endif  // NVARCH >= 0x010

#if (NVARCH >= 0x020)
    pContext->kelvinAA.Destroy();
#endif  // NVARCH >= 0x020

#ifdef TEX_MANAGE
    nvTexManageEvictAll (pContext);
#endif

    nvFreeContext (pContext);

    // Reset the global context and texture handles.
    pDriverData->dwCurrentContextHandle = 0;

    // Return successfully.
    pcdd->ddrval = DD_OK;
    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
#ifdef DEBUG
#ifdef HAVE_NV_FILE_FACILITY
    closeDPFLog();
#endif
#endif
    return (DDHAL_DRIVER_HANDLED);
}

//-------------------------------------------------------------------------

// This callback is invoked when a process dies.

DWORD __stdcall nvContextDestroyAll
(
    LPD3DHAL_CONTEXTDESTROYALLDATA  pcdd
)
{
    dbgTracePush ("nvContextDestroyAll");

    // This routine is legacy and will only ever be called in non-mulitmonitor
    // situations, so it's ok to trust what has been previously loaded into
    // pDriverData.

    if (getDC()->dwD3DContextCount == 0)
    {
        pcdd->ddrval = DD_OK;
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    // iterate through all contexts and destroy the ones with this PID
    PNVD3DCONTEXT pContext = (PNVD3DCONTEXT)getDC()->dwContextListHead;
    while (pContext)
    {
        PNVD3DCONTEXT pNext = pContext->pContextNext;

        if ((pcdd->dwPID == ~0) || (pContext->pid == pcdd->dwPID))
        {
            D3DHAL_CONTEXTDESTROYDATA pcdd;
            pcdd.dwhContext = (ULONG_PTR) pContext;
            nvContextDestroy (&pcdd);
        }

        pContext = pNext;
    }

    // Destroy all objects associated with this PID.
    // For our own purposes we use a PID value of ~0 to indicate that we want to destroy all PIDs
    for (CNvObject *pNvObj = global.pNvObjectHead; pNvObj;)
    {
        // get next
        CNvObject *pNext = pNvObj->getNext();

        // should we free it?
        if (((pcdd->dwPID == ~0) || (pNvObj->getPID() == pcdd->dwPID))
#ifndef WINNT
            && (pNvObj != (CNvObject*)pDXShare->pNvPrimarySurf)
#endif
           )
        {
            CCommandBuffer *pCommandBuffer = pNvObj->getCommandBuffer();
            if (pCommandBuffer)
            {
                SET_PNVOBJ (pCommandBuffer->getDDSurfaceLcl(), NULL);
            }
            // cleanup is handled in nvObject release
            pNvObj->release();
        }
        pNvObj = pNext;
    }

    // Reset the global context and texture handles.
    pDriverData->dwCurrentContextHandle = 0;

    pcdd->ddrval = DD_OK;
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

//-------------------------------------------------------------------------

DWORD __stdcall nvDestroyDDLocal
(
    LPDDHAL_DESTROYDDLOCALDATA pdddld
)
{
    nvSetDriverDataPtrFromDDGbl (pdddld->pDDLcl->lpGbl);

    dbgTracePush ("nvDestroyDDLocal");
    nvAssert (pdddld->pDDLcl != NULL);

    for (CNvObject *pNvObj = global.pNvObjectHead; pNvObj;)
    {
        CNvObject *pNext = pNvObj->getNext();

        // does it belong to this context?
        if (pNvObj->getDDLclID() == (DWORD)pdddld->pDDLcl)
        {
            switch(pNvObj->getClass()) {
            // release these object types
            case CNvObject::NVOBJ_VERTEXSHADER:
            case CNvObject::NVOBJ_CACHEDPATCH:
            case CNvObject::NVOBJ_PALETTE:
            case CNvObject::NVOBJ_PIXELSHADER:
                pNvObj->release();
                break;
            // ignore these
            case CNvObject::NVOBJ_TEXTURE:
            case CNvObject::NVOBJ_VERTEXBUFFER:
            case CNvObject::NVOBJ_COMMANDBUFFER:
            case CNvObject::NVOBJ_SIMPLESURFACE:
                // nvAssert(0);  -- DCT can get here legitimately
                break;
            // unknown object type
            default:
                break;
            }
        }
        pNvObj = pNext;
    }

    nvDeleteObjectList ((DWORD)pdddld->pDDLcl, &global.pNvSurfaceLists);
    nvDeleteObjectList ((DWORD)pdddld->pDDLcl, &global.pNvPaletteLists);
    nvDeleteObjectList ((DWORD)pdddld->pDDLcl, &global.pNvVShaderLists);
    nvDeleteObjectList ((DWORD)pdddld->pDDLcl, &global.pNvPShaderLists);
    nvDeleteObjectList ((DWORD)pdddld->pDDLcl, &global.pNvPatchLists);
    
#ifdef WINNT
    // display heap usage
    g_nvIPHeap.checkHeapUsage();
#endif

    NvReleaseSemaphore(pDriverData);
    pdddld->ddRVal = DD_OK;
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\d3dDebug.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: d3dDebug.cpp
//      D3D-specific debugging routines
//
// **************************************************************************
//
//  History:
//      Chas Inman              18Nov97         original version
//      Craig Duttweiler        21Nov00         major rehash
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

#ifdef WINNT
    void atexit (void) {};
#endif

//-------------------------------------------------------------------------
// GLOBAL VARIABLES
//---------------------------------------------------------------------------

#ifdef DEBUG

    // general debugging
    DWORD          dbgShowState             = 0x00000000;
    DWORD          dbgDumpState             = 0x00000000;
    DWORD          dbgFlush                 = 0x00000000; // Flush Nothing
    DWORD          dbgForceHWRefresh        = 0x00000000;

    // primary info (shared by front buffer rendering and texture previewing)
    DWORD          dbgPrimaryPitch          = 0;
    DWORD          dbgPrimaryHeight         = 0;
    DWORD          dbgPrimaryBPP            = 0;

    // front buffer rendering
    CSimpleSurface dbgFrontRenderSurface;
    BOOL           dbgFrontRender           = 0;

    // texture previewing
    DWORD          dbgTexturePreview        = 0;

#endif  // DEBUG

//-------------------------------------------------------------------------
// STRING TABLES
//---------------------------------------------------------------------------

#ifdef DEBUG

char szD3DBoolean[][32] =
{
    "FALSE",
    "TRUE",
};

char szD3DShadeMode[][32] =
{
    "NULL",
    "D3DSHADE_FLAT",
    "D3DSHADE_GOURAUD",
    "D3DSHADE_PHONG"
};

char szD3DFillMode[][32] =
{
    "NULL",
    "D3DFILL_POINT",
    "D3DFILL_WIREFRAME",
    "D3DFILL_SOLID"
};

char szD3DTextureFilter[][32] =
{
    "NULL",
    "D3DFILTER_NEAREST",
    "D3DFILTER_LINEAR",
    "D3DFILTER_MIPNEAREST",
    "D3DFILTER_MIPLINEAR",
    "D3DFILTER_LINEARMIPNEAREST",
    "D3DFILTER_LINEARMIPLINEAR"
};

char szD3DBlend[][32] =
{
    "NULL",
    "D3DBLEND_ZERO",
    "D3DBLEND_ONE",
    "D3DBLEND_SRCCOLOR",
    "D3DBLEND_INVSRCCOLOR",
    "D3DBLEND_SRCALPHA",
    "D3DBLEND_INVSRCALPHA",
    "D3DBLEND_DESTALPHA",
    "D3DBLEND_INVDESTALPHA",
    "D3DBLEND_DESTCOLOR",
    "D3DBLEND_INVDESTCOLOR",
    "D3DBLEND_SRCALPHASAT",
    "D3DBLEND_BOTHSRCALPHA",
    "D3DBLEND_BOTHINVSRCALPHA"
};

char szD3DTextureBlend[][32] =
{
    "NULL",
    "D3DTBLEND_DECAL",
    "D3DTBLEND_MODULATE",
    "D3DTBLEND_DECALALPHA",
    "D3DTBLEND_MODULATEALPHA",
    "D3DTBLEND_DECALMASK",
    "D3DTBLEND_MODULATEMASK",
    "D3DTBLEND_COPY",
    "D3DTBLEND_ADD"
};

char szD3DTextureAddress[][32] =
{
    "NULL",
    "D3DTADDRESS_WRAP",
    "D3DTADDRESS_MIRROR",
    "D3DTADDRESS_CLAMP",
    "D3DTADDRESS_BORDER"
};

char szD3DCull[][32] =
{
    "NULL",
    "D3DCULL_NONE",
    "D3DCULL_CW",
    "D3DCULL_CCW"
};

char szD3DCmpFunc[][32] =
{
    "NULL",
    "D3DCMP_NEVER",
    "D3DCMP_LESS",
    "D3DCMP_EQUAL",
    "D3DCMP_LESSEQUAL",
    "D3DCMP_GREATER",
    "D3DCMP_NOTEQUAL",
    "D3DCMP_GREATEREQUAL",
    "D3DCMP_ALWAYS"
};

char szD3DStencilOp[][32] =
{
    "NULL",
    "D3DSTENCILOP_KEEP",
    "D3DSTENCILOP_ZERO",
    "D3DSTENCILOP_REPLACE",
    "D3DSTENCILOP_INCRSAT",
    "D3DSTENCILOP_DECRSAT",
    "D3DSTENCILOP_INVERT",
    "D3DSTENCILOP_INCR",
    "D3DSTENCILOP_DECR"
};

char szD3DFogMode[][32] =
{
    "D3DFOG_NONE",
    "D3DFOG_EXP",
    "D3DFOG_EXP2",
    "D3DFOG_LINEAR"
};

char szD3DZBufferType[][32] =
{
    "D3DZB_FALSE",
    "D3DZB_TRUE",
    "D3DZB_USEW"
};

char szD3DAntiAliasMode[][32] =
{
    "NULL",
    "D3DANTIALIAS_NONE",
    "D3DANTIALIAS_SORTDEPENDENT",
    "D3DANTIALIAS_SORTINDEPENDENT"
};

char szD3DTextureOp[][36] =
{
    "NULL",
    "D3DTOP_DISABLE",
    "D3DTOP_SELECTARG1",
    "D3DTOP_SELECTARG2",
    "D3DTOP_MODULATE",
    "D3DTOP_MODULATE2X",
    "D3DTOP_MODULATE4X",
    "D3DTOP_ADD",
    "D3DTOP_ADDSIGNED",
    "D3DTOP_ADDSIGNED2X",
    "D3DTOP_SUBTRACT",
    "D3DTOP_ADDSMOOTH",
    "D3DTOP_BLENDDIFFUSEALPHA",
    "D3DTOP_BLENDTEXTUREALPHA",
    "D3DTOP_BLENDFACTORALPHA",
    "D3DTOP_BLENDTEXTUREALPHAPM",
    "D3DTOP_BLENDCURRENTALPHA",
    "D3DTOP_PREMODULATE",
    "D3DTOP_MODULATEALPHA_ADDCOLOR",
    "D3DTOP_MODULATECOLOR_ADDALPHA",
    "D3DTOP_MODULATEINVALPHA_ADDCOLOR",
    "D3DTOP_MODULATEINVCOLOR_ADDALPHA",
    "D3DTOP_BUMPENVMAP",
    "D3DTOP_BUMPENVMAPLUMINANCE",
    "D3DTOP_DOTPRODUCT3"
};

char szD3DArg[][64] =
{
    "D3DTA_DIFFUSE",
    "D3DTA_CURRENT",
    "D3DTA_TEXTURE",
    "D3DTA_TFACTOR",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "D3DTA_DIFFUSE | D3DTA_COMPLEMENT",
    "D3DTA_CURRENT | D3DTA_COMPLEMENT",
    "D3DTA_TEXTURE | D3DTA_COMPLEMENT",
    "D3DTA_TFACTOR | D3DTA_COMPLEMENT",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "D3DTA_DIFFUSE | D3DTA_ALPHAREPLICATE",
    "D3DTA_CURRENT | D3DTA_ALPHAREPLICATE",
    "D3DTA_TEXTURE | D3DTA_ALPHAREPLICATE",
    "D3DTA_TFACTOR | D3DTA_ALPHAREPLICATE",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "D3DTA_DIFFUSE | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE",
    "D3DTA_CURRENT | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE",
    "D3DTA_TEXTURE | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE",
    "D3DTA_TFACTOR | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID",
    "INVALID"
};

char szD3DArgModifier[][32] =
{
    "D3DTA_NORMAL",
    "D3DTA_COMPLEMENT",
    "D3DTA_ALPHAREPLICATE"
};

char szD3DTextureMagFilter[][32] =
{
    "NULL",
    "D3DTFG_POINT",
    "D3DTFG_LINEAR",
    "D3DTFG_FLATCUBIC",
    "D3DTFG_GAUSSIANCUBIC",
    "D3DTFG_ANISOTROPIC"
};

char szD3DTextureMinFilter[][32] =
{
    "NULL",
    "D3DTFN_POINT",
    "D3DTFN_LINEAR",
    "D3DTFN_ANISOTROPIC"
};

char szD3DTextureMipFilter[][32] =
{
    "NULL",
    "D3DTFP_POINT",
    "D3DTFP_LINEAR"
};

char szD3DRenderStateLookupTable[D3D_RENDERSTATE_MAX+1][50] =
{
    "D3DRENDERSTATE_UNKNOWN",                       // 0
    "D3DRENDERSTATE_TEXTUREHANDLE",                 // 1
    "D3DRENDERSTATE_ANTIALIAS",                     // 2   D3DANTIALIASMODE
    "D3DRENDERSTATE_TEXTUREADDRESS",                // 3
    "D3DRENDERSTATE_TEXTUREPERSPECTIVE",            // 4   TRUE for perspective correction
    "D3DRENDERSTATE_WRAPU",                         // 5
    "D3DRENDERSTATE_WRAPV",                         // 6
    "D3DRENDERSTATE_ZENABLE",                       // 7   D3DZBUFFERTYPE (or TRUE/FALSE for legacy)
    "D3DRENDERSTATE_FILLMODE",                      // 8   D3DFILL_MODE
    "D3DRENDERSTATE_SHADEMODE",                     // 9   D3DSHADEMODE
    "D3DRENDERSTATE_LINEPATTERN",                   // 10  D3DLINEPATTERN
    "D3DRENDERSTATE_MONOENABLE",                    // 11  TRUE to enable mono rasterization
    "D3DRENDERSTATE_ROP2",                          // 12  ROP2
    "D3DRENDERSTATE_PLANEMASK",                     // 13
    "D3DRENDERSTATE_ZWRITEENABLE",                  // 14  TRUE to enable z writes
    "D3DRENDERSTATE_ALPHATESTENABLE",               // 15  TRUE to enable alpha tests
    "D3DRENDERSTATE_LASTPIXEL",                     // 16  TRUE for last-pixel on lines
    "D3DRENDERSTATE_TEXTUREMAG",                    // 17
    "D3DRENDERSTATE_TEXTUREMIN",                    // 18
    "D3DRENDERSTATE_SRCBLEND",                      // 19  D3DBLEND
    "D3DRENDERSTATE_DESTBLEND",                     // 20  D3DBLEND
    "D3DRENDERSTATE_TEXTUREMAPBLEND",               // 21
    "D3DRENDERSTATE_CULLMODE",                      // 22  D3DCULL
    "D3DRENDERSTATE_ZFUNC",                         // 23  D3DCMPFUNC
    "D3DRENDERSTATE_ALPHAREF",                      // 24  D3DFIXED
    "D3DRENDERSTATE_ALPHAFUNC",                     // 25  D3DCMPFUNC
    "D3DRENDERSTATE_DITHERENABLE",                  // 26  TRUE to enable dithering
    "D3DRENDERSTATE_ALPHABLENDENABLE",              // 27  TRUE to enable alpha blending
    "D3DRENDERSTATE_FOGENABLE",                     // 28  TRUE to enable fog blending
    "D3DRENDERSTATE_SPECULARENABLE",                // 29  TRUE to enable specular
    "D3DRENDERSTATE_ZVISIBLE",                      // 30  TRUE to enable z checking
    "D3DRENDERSTATE_SUBPIXEL",                      // 31
    "D3DRENDERSTATE_SUBPIXELX",                     // 32
    "D3DRENDERSTATE_STIPPLEDALPHA",                 // 33  TRUE to enable stippled alpha (RGB device only)
    "D3DRENDERSTATE_FOGCOLOR",                      // 34  D3DCOLOR
    "D3DRENDERSTATE_FOGTABLEMODE",                  // 35  D3DFOGMODE
    "D3DRENDERSTATE_FOGSTART",                      // 36  Fog start (for both vertex and pixel fog)
    "D3DRENDERSTATE_FOGEND",                        // 37  Fog end
    "D3DRENDERSTATE_FOGDENSITY",                    // 38  Fog density
    "D3DRENDERSTATE_STIPPLEENABLE",                 // 39  TRUE to enable stippling
    "D3DRENDERSTATE_EDGEANTIALIAS",                 // 40  TRUE to enable edge antialiasing
    "D3DRENDERSTATE_COLORKEYENABLE",                // 41  TRUE to enable source colorkeyed textures
    "D3DRENDERSTATE_UNKNOWN",                       // 42
    "D3DRENDERSTATE_BORDERCOLOR",                   // 43  Border color for texturing w/border
    "D3DRENDERSTATE_TEXTUREADDRESSU",               // 44  Texture addressing mode for U coordinate
    "D3DRENDERSTATE_TEXTUREADDRESSV",               // 45  Texture addressing mode for V coordinate
    "D3DRENDERSTATE_MIPMAPLODBIAS",                 // 46  D3DVALUE Mipmap LOD bias
    "D3DRENDERSTATE_ZBIAS",                         // 47  LONG Z bias
    "D3DRENDERSTATE_RANGEFOGENABLE",                // 48  Enables range-based fog
    "D3DRENDERSTATE_ANISOTROPY",                    // 49  Max. anisotropy. 1 = no anisotropy
    "D3DRENDERSTATE_FLUSHBATCH",                    // 50  Explicit flush for DP batching (DX5 Only)
    "D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT",    // 51  BOOL enable sort-independent transparency
    "D3DRENDERSTATE_STENCILENABLE",                 // 52  BOOL enable/disable stenciling
    "D3DRENDERSTATE_STENCILFAIL",                   // 53  D3DSTENCILOP to do if stencil test fails
    "D3DRENDERSTATE_STENCILZFAIL",                  // 54  D3DSTENCILOP to do if stencil test passes and Z test fails
    "D3DRENDERSTATE_STENCILPASS",                   // 55  D3DSTENCILOP to do if both stencil and Z tests pass
    "D3DRENDERSTATE_STENCILFUNC",                   // 56  D3DCMPFUNC fn.  Stencil Test passes if ((ref & mask) stencilfn (stencil & mask)) is true
    "D3DRENDERSTATE_STENCILREF",                    // 57  Reference value used in stencil test
    "D3DRENDERSTATE_STENCILMASK",                   // 58  Mask value used in stencil test
    "D3DRENDERSTATE_STENCILWRITEMASK",              // 59  Write mask applied to values written to stencil buffer
    "D3DRENDERSTATE_TEXTUREFACTOR",                 // 60  D3DCOLOR used for multi-texture blend
    "D3DRENDERSTATE_EVICTMANAGEDTEXTURES",          // 61  D3DRENDERSTATE_EVICTMANAGEDTEXTURES???
    "D3DRENDERSTATE_SCENECAPTURE",                  // 62  D3DRENDERSTATE_SCENECAPTURE???
    "D3DRENDERSTATE_UNKNOWN",                       // 63  invalid???
    "D3DRENDERSTATE_STIPPLEPATTERN00",              // 64  Stipple pattern 01...
    "D3DRENDERSTATE_STIPPLEPATTERN01",              // 65
    "D3DRENDERSTATE_STIPPLEPATTERN02",              // 66
    "D3DRENDERSTATE_STIPPLEPATTERN03",              // 67
    "D3DRENDERSTATE_STIPPLEPATTERN04",              // 68
    "D3DRENDERSTATE_STIPPLEPATTERN05",              // 69
    "D3DRENDERSTATE_STIPPLEPATTERN06",              // 70
    "D3DRENDERSTATE_STIPPLEPATTERN07",              // 71
    "D3DRENDERSTATE_STIPPLEPATTERN08",              // 72
    "D3DRENDERSTATE_STIPPLEPATTERN09",              // 73
    "D3DRENDERSTATE_STIPPLEPATTERN10",              // 74
    "D3DRENDERSTATE_STIPPLEPATTERN11",              // 75
    "D3DRENDERSTATE_STIPPLEPATTERN12",              // 76
    "D3DRENDERSTATE_STIPPLEPATTERN13",              // 77
    "D3DRENDERSTATE_STIPPLEPATTERN14",              // 78
    "D3DRENDERSTATE_STIPPLEPATTERN15",              // 79
    "D3DRENDERSTATE_STIPPLEPATTERN16",              // 80
    "D3DRENDERSTATE_STIPPLEPATTERN17",              // 81
    "D3DRENDERSTATE_STIPPLEPATTERN18",              // 82
    "D3DRENDERSTATE_STIPPLEPATTERN19",              // 83
    "D3DRENDERSTATE_STIPPLEPATTERN20",              // 84
    "D3DRENDERSTATE_STIPPLEPATTERN21",              // 85
    "D3DRENDERSTATE_STIPPLEPATTERN22",              // 86
    "D3DRENDERSTATE_STIPPLEPATTERN23",              // 87
    "D3DRENDERSTATE_STIPPLEPATTERN24",              // 88
    "D3DRENDERSTATE_STIPPLEPATTERN25",              // 89
    "D3DRENDERSTATE_STIPPLEPATTERN26",              // 90
    "D3DRENDERSTATE_STIPPLEPATTERN27",              // 91
    "D3DRENDERSTATE_STIPPLEPATTERN28",              // 92
    "D3DRENDERSTATE_STIPPLEPATTERN29",              // 93
    "D3DRENDERSTATE_STIPPLEPATTERN30",              // 94
    "D3DRENDERSTATE_STIPPLEPATTERN31",              // 95
    "D3DRENDERSTATE_UNKNOWN",                       // 96
    "D3DRENDERSTATE_UNKNOWN",                       // 97
    "D3DRENDERSTATE_UNKNOWN",                       // 98
    "D3DRENDERSTATE_UNKNOWN",                       // 99
    "D3DRENDERSTATE_UNKNOWN",                       // 100
    "D3DRENDERSTATE_UNKNOWN",                       // 101
    "D3DRENDERSTATE_UNKNOWN",                       // 102
    "D3DRENDERSTATE_UNKNOWN",                       // 103
    "D3DRENDERSTATE_UNKNOWN",                       // 104
    "D3DRENDERSTATE_UNKNOWN",                       // 105
    "D3DRENDERSTATE_UNKNOWN",                       // 106
    "D3DRENDERSTATE_UNKNOWN",                       // 107
    "D3DRENDERSTATE_UNKNOWN",                       // 108
    "D3DRENDERSTATE_UNKNOWN",                       // 109
    "D3DRENDERSTATE_UNKNOWN",                       // 110
    "D3DRENDERSTATE_UNKNOWN",                       // 111
    "D3DRENDERSTATE_UNKNOWN",                       // 112
    "D3DRENDERSTATE_UNKNOWN",                       // 113
    "D3DRENDERSTATE_UNKNOWN",                       // 114
    "D3DRENDERSTATE_UNKNOWN",                       // 115
    "D3DRENDERSTATE_UNKNOWN",                       // 116
    "D3DRENDERSTATE_UNKNOWN",                       // 117
    "D3DRENDERSTATE_UNKNOWN",                       // 118
    "D3DRENDERSTATE_UNKNOWN",                       // 119
    "D3DRENDERSTATE_UNKNOWN",                       // 120
    "D3DRENDERSTATE_UNKNOWN",                       // 121
    "D3DRENDERSTATE_UNKNOWN",                       // 122
    "D3DRENDERSTATE_UNKNOWN",                       // 123
    "D3DRENDERSTATE_UNKNOWN",                       // 124
    "D3DRENDERSTATE_UNKNOWN",                       // 125
    "D3DRENDERSTATE_UNKNOWN",                       // 126
    "D3DRENDERSTATE_UNKNOWN",                       // 127
    "D3DRENDERSTATE_WRAP0",                         // 128  wrap for 1st texture coord. set
    "D3DRENDERSTATE_WRAP1",                         // 129  wrap for 2nd texture coord. set
    "D3DRENDERSTATE_WRAP2",                         // 130  wrap for 3rd texture coord. set
    "D3DRENDERSTATE_WRAP3",                         // 131  wrap for 4th texture coord. set
    "D3DRENDERSTATE_WRAP4",                         // 132  wrap for 5th texture coord. set
    "D3DRENDERSTATE_WRAP5",                         // 133  wrap for 6th texture coord. set
    "D3DRENDERSTATE_WRAP6",                         // 134  wrap for 7th texture coord. set
    "D3DRENDERSTATE_WRAP7",                         // 135  wrap for 8th texture coord. set
    "D3DRENDERSTATE_CLIPPING",                      // 136
    "D3DRENDERSTATE_LIGHTING",                      // 137
    "D3DRENDERSTATE_EXTENTS",                       // 138
    "D3DRENDERSTATE_AMBIENT",                       // 139
    "D3DRENDERSTATE_FOGVERTEXMODE",                 // 140
    "D3DRENDERSTATE_COLORVERTEX",                   // 141
    "D3DRENDERSTATE_LOCALVIEWER",                   // 142
    "D3DRENDERSTATE_NORMALIZENORMALS",              // 143
    "D3DRENDERSTATE_COLORKEYBLENDENABLE",           // 144
    "D3DRENDERSTATE_DIFFUSEMATERIALSOURCE",         // 145
    "D3DRENDERSTATE_SPECULARMATERIALSOURCE",        // 146
    "D3DRENDERSTATE_AMBIENTMATERIALSOURCE",         // 147
    "D3DRENDERSTATE_EMISSIVEMATERIALSOURCE",        // 148
    "D3DRENDERSTATE_UNKNOWN",                       // 149
    "D3DRENDERSTATE_UNKNOWN",                       // 150
    "D3DRENDERSTATE_VERTEXBLEND",                   // 151
    "D3DRENDERSTATE_CLIPPLANEENABLE",               // 152
    "D3DRS_SOFTWAREVERTEXPROCESSING",               // 153
    "D3DRS_POINTSIZE",                              // 154
    "D3DRS_POINTSIZE_MIN",                          // 155
    "D3DRS_POINTSPRITEENABLE",                      // 156
    "D3DRS_POINTSCALEENABLE",                       // 157
    "D3DRS_POINTSCALE_A",                           // 158
    "D3DRS_POINTSCALE_B",                           // 159
    "D3DRS_POINTSCALE_C",                           // 160
    "D3DRS_MULTISAMPLEANTIALIAS",                   // 161
    "D3DRS_MULTISAMPLEMASK",                        // 162
    "D3DRS_PATCHEDGESTYLE",                         // 163
    "D3DRS_PRIMSEGMENTS",                           // 164
    "D3DRS_DEBUGMONITORTOKEN",                      // 165
    "D3DRS_POINTSIZE_MAX",                          // 166
    "D3DRS_INDEXEDVERTEXBLENDENABLE",               // 167
    "D3DRS_COLORWRITEENABLE",                       // 168
    "D3DRENDERSTATE_UNKNOWN",                       // 169
    "D3DRS_TWEENFACTOR",                            // 170
    "D3DRS_BLENDOP"                                 // 171
};

char szD3DDP2OpLookupTable[D3D_DP2OP_MAX+1][64] =
{
    "D3DDP2OP_UNKNOWN",                             //  0
    "D3DDP2OP_POINTS",                              //  1
    "D3DDP2OP_INDEXEDLINELIST",                     //  2
    "D3DDP2OP_INDEXEDTRIANGLELIST",                 //  3
    "D3DDP2OP_RESERVED0",                           //  4
    "D3DDP2OP_UNKNOWN",                             //  5
    "D3DDP2OP_UNKNOWN",                             //  6
    "D3DDP2OP_UNKNOWN",                             //  7
    "D3DDP2OP_RENDERSTATE",                         //  8
    "D3DDP2OP_UNKNOWN",                             //  9
    "D3DDP2OP_UNKNOWN",                             // 10
    "D3DDP2OP_END",                                 // 11
    "D3DDP2OP_UNKNOWN",                             // 12
    "D3DDP2OP_UNKNOWN",                             // 13
    "D3DDP2OP_UNKNOWN",                             // 14
    "D3DDP2OP_LINELIST",                            // 15
    "D3DDP2OP_LINESTRIP",                           // 16
    "D3DDP2OP_INDEXEDLINESTRIP",                    // 17
    "D3DDP2OP_TRIANGLELIST",                        // 18
    "D3DDP2OP_TRIANGLESTRIP",                       // 19
    "D3DDP2OP_INDEXEDTRIANGLESTRIP",                // 20
    "D3DDP2OP_TRIANGLEFAN",                         // 21
    "D3DDP2OP_INDEXEDTRIANGLEFAN",                  // 22
    "D3DDP2OP_TRIANGLEFAN_IMM",                     // 23
    "D3DDP2OP_LINELIST_IMM",                        // 24
    "D3DDP2OP_TEXTURESTAGESTATE",                   // 25
    "D3DDP2OP_INDEXEDTRIANGLELIST2",                // 26
    "D3DDP2OP_INDEXEDLINELIST2",                    // 27
    "D3DDP2OP_VIEWPORTINFO",                        // 28
    "D3DDP2OP_WINFO",                               // 29
    "D3DDP2OP_SETPALETTE",                          // 30
    "D3DDP2OP_UPDATEPALETTE",                       // 31
    "D3DDP2OP_ZRANGE",                              // 32
    "D3DDP2OP_SETMATERIAL",                         // 33
    "D3DDP2OP_SETLIGHT",                            // 34
    "D3DDP2OP_CREATELIGHT",                         // 35
    "D3DDP2OP_SETTRANSFORM",                        // 36
    "D3DDP2OP_EXT",                                 // 37
    "D3DDP2OP_TEXBLT",                              // 38
    "D3DDP2OP_STATESET",                            // 39
    "D3DDP2OP_SETPRIORITY",                         // 40
    "D3DDP2OP_SETRENDERTARGET",                     // 41
    "D3DDP2OP_CLEAR",                               // 42
    "D3DDP2OP_SETTEXLOD",                           // 43
    "D3DDP2OP_SETCLIPPLANE",                        // 44
    "D3DDP2OP_CREATEVERTEXSHADER",                  // 45
    "D3DDP2OP_DELETEVERTEXSHADER",                  // 46
    "D3DDP2OP_SETVERTEXSHADER",                     // 47
    "D3DDP2OP_SETVERTEXSHADERCONST",                // 48
    "D3DDP2OP_SETSTREAMSOURCE",                     // 49
    "D3DDP2OP_SETSTREAMSOURCEUM",                   // 50
    "D3DDP2OP_SETINDICES",                          // 51
    "D3DDP2OP_DRAWPRIMITIVE",                       // 52
    "D3DDP2OP_DRAWINDEXEDPRIMITIVE",                // 53
    "D3DDP2OP_CREATEPIXELSHADER",                   // 54
    "D3DDP2OP_DELETEPIXELSHADER",                   // 55
    "D3DDP2OP_SETPIXELSHADER",                      // 56
    "D3DDP2OP_SETPIXELSHADERCONST",                 // 57
    "D3DDP2OP_CLIPPEDTRIANGLEFAN",                  // 58
    "D3DDP2OP_DRAWPRIMITIVE2",                      // 59
    "D3DDP2OP_DRAWINDEXEDPRIMITIVE2",               // 60
    "D3DDP2OP_DRAWRECTSURFACE",                     // 61
    "D3DDP2OP_DRAWTRISURFACE",                      // 62
    "D3DDP2OP_VOLUMEBLT",                           // 63
    "D3DDP2OP_BUFFERBLT",                           // 64
    "D3DDP2OP_MULTIPLYTRANSFORM"                    // 65
};

#endif  // DEBUG

//-------------------------------------------------------------------------
// DEBUG PRINTING
//---------------------------------------------------------------------------

#ifdef DEBUG

// conditionally print a string out as debug message and/or to a file

void __cdecl dbgDPFAndDump (DWORD flag, LPSTR szFormat, ...)
{
    char str[256];

    nvSprintfVAL (str, szFormat, (va_list)(&szFormat+1));

    if ((flag == NVDBG_SHOW_MANUAL_OVERRIDE) || (dbgShowState & flag)) {
        DPF("%s", str);
    }

    if ((flag == NVDBG_SHOW_MANUAL_OVERRIDE) || (dbgDumpState & flag)) {
        char  *filename;
        HANDLE hFile;
        DWORD  dwJunk;

        // find the appropriate filename
        switch (flag) {
            case NVDBG_SHOW_RENDER_STATE:
                filename = NVDBG_DUMP_RENDER_STATE_FILENAME;
                break;
            case NVDBG_SHOW_DX5_CLASS_STATE:
                filename = NVDBG_DUMP_DX5_CLASS_STATE_FILENAME;
                break;
            case NVDBG_SHOW_SURFACE_STATE:
                filename = NVDBG_DUMP_SURFACE_STATE_FILENAME;
                break;
            case NVDBG_SHOW_VERTICES:
                filename = NVDBG_DUMP_VERTICES_FILENAME;
                break;
            case NVDBG_SHOW_MTS_STATE:
                filename = NVDBG_DUMP_MTS_STATE_FILENAME;
                break;
            case NVDBG_SHOW_DX6_CLASS_STATE:
                filename = NVDBG_DUMP_DX6_CLASS_STATE_FILENAME;
                break;
            case NVDBG_SHOW_DRAWPRIM2_INFO:
                filename = NVDBG_DUMP_DRAWPRIM2_INFO_FILENAME;
                break;
            case NVDBG_SHOW_MANUAL_OVERRIDE:
                filename = NVDBG_DUMP_MANUAL_OVERRIDE_FILENAME;
                break;
            default:
                DPF("dbgDPFAndDump: unknown flag");
                return;
                break;
        }

        // open the file if it exists, create it if not.
        hFile = NvCreateFile(filename,GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);
        if (hFile == INVALID_HANDLE_VALUE) {
            DPF ("dbgDPFAndDump: File open failed");
            __asm int 3;
        }

        // set the file pointer to the end. this appears to be
        // the only way to append to a file. how retarded.
        SetFilePointer(hFile, 0,0, FILE_END);

        NvWriteFile(hFile,str,nvStrLen(str),&dwJunk,0);
        NvWriteFile(hFile,"\r\n",2,&dwJunk,0);
        FlushFileBuffers(hFile);
        NvCloseHandle(hFile);
    }

}

//-------------------------------------------------------------------------
// STATE DUMPING
//-------------------------------------------------------------------------

void dbgDisplayContextState
(
    DWORD           dwFlags,
    PNVD3DCONTEXT   pContext
)
{
    BOOL  bDPF, bDump;
    DWORD flag;

    if (!(dbgShowState || dbgDumpState)) return;

    bDPF = dbgShowState & NVDBG_SHOW_RENDER_STATE;
    bDump = dbgDumpState & NVDBG_SHOW_RENDER_STATE;
    flag = NVDBG_SHOW_RENDER_STATE;

    if ((bDPF || bDump) &&
        (dwFlags & NVDBG_SHOW_RENDER_STATE)) {
        dbgDPFAndDump(flag, "D3D:Context Render State:");
        dbgDPFAndDump(flag, "    TextureHandle *    = %08x", pContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE]);
        dbgDPFAndDump(flag, "    AntiAlias          = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_ANTIALIAS]]);
        dbgDPFAndDump(flag, "    TextureAddress *   = %s",   szD3DTextureAddress[pContext->dwRenderState[D3DRENDERSTATE_TEXTUREADDRESS]]);
        dbgDPFAndDump(flag, "    TexturePerspective = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE]]);
        dbgDPFAndDump(flag, "    WrapU              = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_WRAPU]]);
        dbgDPFAndDump(flag, "    WrapV              = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_WRAPV]]);
        dbgDPFAndDump(flag, "    ZEnable            = %s",   szD3DZBufferType[pContext->dwRenderState[D3DRENDERSTATE_ZENABLE]]);
        dbgDPFAndDump(flag, "    FillMode           = %s",   szD3DFillMode[pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]]);
        dbgDPFAndDump(flag, "    ShadeMode          = %s",   szD3DShadeMode[pContext->dwRenderState[D3DRENDERSTATE_SHADEMODE]]);
        dbgDPFAndDump(flag, "    LinePattern        = %08x", pContext->dwRenderState[D3DRENDERSTATE_LINEPATTERN]);
        dbgDPFAndDump(flag, "    MonoEnable         = %08x", pContext->dwRenderState[D3DRENDERSTATE_MONOENABLE]);
        dbgDPFAndDump(flag, "    Rop2               = %08x", pContext->dwRenderState[D3DRENDERSTATE_ROP2]);
        dbgDPFAndDump(flag, "    PlaneMask          = %08x", pContext->dwRenderState[D3DRENDERSTATE_PLANEMASK]);
        dbgDPFAndDump(flag, "    ZWriteEnable       = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE]]);
        dbgDPFAndDump(flag, "    AlphaTestEnable    = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_ALPHATESTENABLE]]);
        dbgDPFAndDump(flag, "    LastPixelEnable    = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_LASTPIXEL]]);
        dbgDPFAndDump(flag, "    TextureMag         = %s",   szD3DTextureFilter[pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAG]]);
        dbgDPFAndDump(flag, "    TextureMin         = %s",   szD3DTextureFilter[pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMIN]]);
        dbgDPFAndDump(flag, "    SrcBlend           = %s",   szD3DBlend[pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND]]);
        dbgDPFAndDump(flag, "    DstBlend           = %s",   szD3DBlend[pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND]]);
        dbgDPFAndDump(flag, "    TextureMapBlend    = %s",   szD3DTextureBlend[pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAPBLEND]]);
        dbgDPFAndDump(flag, "    CullMode           = %s",   szD3DCull[pContext->dwRenderState[D3DRENDERSTATE_CULLMODE]]);
        dbgDPFAndDump(flag, "    ZFunc              = %s",   szD3DCmpFunc[pContext->dwRenderState[D3DRENDERSTATE_ZFUNC]]);
        dbgDPFAndDump(flag, "    AlphaRef           = %08x", pContext->dwRenderState[D3DRENDERSTATE_ALPHAREF]);
        dbgDPFAndDump(flag, "    AlphaFunc          = %s",   szD3DCmpFunc[pContext->dwRenderState[D3DRENDERSTATE_ALPHAFUNC]]);
        dbgDPFAndDump(flag, "    DitherEnable       = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_DITHERENABLE]]);
        dbgDPFAndDump(flag, "    AlphaBlendEnable   = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]]);
        dbgDPFAndDump(flag, "    FogEnable          = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_FOGENABLE]]);
        dbgDPFAndDump(flag, "    SpecularEnable     = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE]]);
        dbgDPFAndDump(flag, "    ZVisible           = %08x", pContext->dwRenderState[D3DRENDERSTATE_ZVISIBLE]);
        dbgDPFAndDump(flag, "    SubPixel           = %08x", pContext->dwRenderState[D3DRENDERSTATE_SUBPIXEL]);
        dbgDPFAndDump(flag, "    SubPixelX          = %08x", pContext->dwRenderState[D3DRENDERSTATE_SUBPIXELX]);
        dbgDPFAndDump(flag, "    StippledAlpha      = %08x", pContext->dwRenderState[D3DRENDERSTATE_STIPPLEDALPHA]);
        dbgDPFAndDump(flag, "    FogColor           = %08x", pContext->dwRenderState[D3DRENDERSTATE_FOGCOLOR]);
        dbgDPFAndDump(flag, "    FogTableMode       = %s",   szD3DFogMode[pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEMODE]]);
        dbgDPFAndDump(flag, "    FogTableStart      = %f",   pContext->dwRenderState[D3DRENDERSTATE_FOGTABLESTART]);
        dbgDPFAndDump(flag, "    FogTableEnd        = %f",   pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEEND]);
        dbgDPFAndDump(flag, "    FogTableDensity    = %f",   pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEDENSITY]);
        dbgDPFAndDump(flag, "    StippledEnable     = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_STIPPLEENABLE]]);
        dbgDPFAndDump(flag, "    EdgeAntiAlias      = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_EDGEANTIALIAS]]);
        dbgDPFAndDump(flag, "    ColorKeyEnable     = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_COLORKEYENABLE]]);
        dbgDPFAndDump(flag, "    BorderColor        = %08x", pContext->dwRenderState[D3DRENDERSTATE_BORDERCOLOR]);
        dbgDPFAndDump(flag, "    TextureAddressU *  = %s",   szD3DTextureAddress[pContext->dwRenderState[D3DRENDERSTATE_TEXTUREADDRESSU]]);
        dbgDPFAndDump(flag, "    TextureAddressV *  = %s",   szD3DTextureAddress[pContext->dwRenderState[D3DRENDERSTATE_TEXTUREADDRESSV]]);
        dbgDPFAndDump(flag, "    MipMapLODBias *    = %08x", pContext->dwRenderState[D3DRENDERSTATE_MIPMAPLODBIAS]);
        dbgDPFAndDump(flag, "    ZBias              = %08x", pContext->dwRenderState[D3DRENDERSTATE_ZBIAS]);
        dbgDPFAndDump(flag, "    RangeFogEnable     = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_RANGEFOGENABLE]]);
        dbgDPFAndDump(flag, "    Anisotropy *       = %08x", pContext->dwRenderState[D3DRENDERSTATE_ANISOTROPY]);
        dbgDPFAndDump(flag, "    FlushBatch         = %08x", pContext->dwRenderState[D3DRENDERSTATE_FLUSHBATCH]);
        dbgDPFAndDump(flag, "    TranslucentSortInd = %08x", pContext->dwRenderState[D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT]);
        dbgDPFAndDump(flag, "    StencilEnable      = %s",   szD3DBoolean[pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE]]);
        dbgDPFAndDump(flag, "    StencilFail        = %s",   szD3DStencilOp[pContext->dwRenderState[D3DRENDERSTATE_STENCILFAIL]]);
        dbgDPFAndDump(flag, "    StencilZFail       = %s",   szD3DStencilOp[pContext->dwRenderState[D3DRENDERSTATE_STENCILZFAIL]]);
        dbgDPFAndDump(flag, "    StencilPass        = %s",   szD3DStencilOp[pContext->dwRenderState[D3DRENDERSTATE_STENCILPASS]]);
        dbgDPFAndDump(flag, "    StencilFunc        = %s",   szD3DCmpFunc[pContext->dwRenderState[D3DRENDERSTATE_STENCILFUNC]]);
        dbgDPFAndDump(flag, "    StencilRef         = %08x", pContext->dwRenderState[D3DRENDERSTATE_STENCILREF]);
        dbgDPFAndDump(flag, "    StencilMask        = %08x", pContext->dwRenderState[D3DRENDERSTATE_STENCILMASK]);
        dbgDPFAndDump(flag, "    StencilWriteMask   = %08x", pContext->dwRenderState[D3DRENDERSTATE_STENCILWRITEMASK]);
        dbgDPFAndDump(flag, "    TextureFactor      = %08x", pContext->dwRenderState[D3DRENDERSTATE_TEXTUREFACTOR]);
        dbgDPFAndDump(flag, "    Wrap0              = %08x", pContext->dwRenderState[D3DRENDERSTATE_WRAP0]);
        dbgDPFAndDump(flag, "    Wrap1              = %08x", pContext->dwRenderState[D3DRENDERSTATE_WRAP1]);
        dbgDPFAndDump(flag, "    Wrap2              = %08x", pContext->dwRenderState[D3DRENDERSTATE_WRAP2]);
        dbgDPFAndDump(flag, "    Wrap3              = %08x", pContext->dwRenderState[D3DRENDERSTATE_WRAP3]);
        dbgDPFAndDump(flag, "    Wrap4              = %08x", pContext->dwRenderState[D3DRENDERSTATE_WRAP4]);
        dbgDPFAndDump(flag, "    Wrap5              = %08x", pContext->dwRenderState[D3DRENDERSTATE_WRAP5]);
        dbgDPFAndDump(flag, "    Wrap6              = %08x", pContext->dwRenderState[D3DRENDERSTATE_WRAP6]);
        dbgDPFAndDump(flag, "    Wrap7              = %08x", pContext->dwRenderState[D3DRENDERSTATE_WRAP7]);
        dbgDPFAndDump(flag, "");
        dbgDPFAndDump(flag, "* These fields may contain invalid junk. They have been superceded");
        dbgDPFAndDump(flag, "  by equivalent fields in tssState[0] and should never be referenced.");
        dbgDPFAndDump(flag, "");
    }

    bDPF = dbgShowState & NVDBG_SHOW_MTS_STATE;
    bDump = dbgDumpState & NVDBG_SHOW_MTS_STATE;
    flag = NVDBG_SHOW_MTS_STATE;

    if ((bDPF || bDump) &&
        (dwFlags & NVDBG_SHOW_MTS_STATE)) {
        DWORD dwStage, dwNumStages;

        dwNumStages = (dbgShowState & NVDBG_SHOW_MTS_STATE) >> NVDBG_SHOW_MTS_STATE_SHIFT;
        dwNumStages = (dwNumStages <= NVDBG_SHOW_MTS_STATE_MAX) ? dwNumStages : NVDBG_SHOW_MTS_STATE_MAX;

        for (dwStage = 0; dwStage < dwNumStages; dwStage++) {
            dbgDPFAndDump(flag, "D3D:Texture Stage %d State:", dwStage);
            dbgDPFAndDump(flag, "    TextureMap     = %08x", pContext->tssState[dwStage].dwValue[D3DTSS_TEXTUREMAP]);
            dbgDPFAndDump(flag, "    AddressU       = %s",   szD3DTextureAddress[pContext->tssState[dwStage].dwValue[D3DTSS_ADDRESSU]]);
            dbgDPFAndDump(flag, "    AddressV       = %s",   szD3DTextureAddress[pContext->tssState[dwStage].dwValue[D3DTSS_ADDRESSV]]);
            dbgDPFAndDump(flag, "    MagFilter      = %s",   szD3DTextureMagFilter[pContext->tssState[dwStage].dwValue[D3DTSS_MAGFILTER]]);
            dbgDPFAndDump(flag, "    MinFilter      = %s",   szD3DTextureMinFilter[pContext->tssState[dwStage].dwValue[D3DTSS_MINFILTER]]);
            dbgDPFAndDump(flag, "    MipFilter      = %s",   szD3DTextureMipFilter[pContext->tssState[dwStage].dwValue[D3DTSS_MIPFILTER]]);
            dbgDPFAndDump(flag, "    ColorOp        = %s",   szD3DTextureOp[pContext->tssState[dwStage].dwValue[D3DTSS_COLOROP]]);
            dbgDPFAndDump(flag, "    ColorArg1      = %s",   szD3DArg[pContext->tssState[dwStage].dwValue[D3DTSS_COLORARG1]]);
            dbgDPFAndDump(flag, "    ColorArg2      = %s",   szD3DArg[pContext->tssState[dwStage].dwValue[D3DTSS_COLORARG2]]);
            dbgDPFAndDump(flag, "    AlphaOp        = %s",   szD3DTextureOp[pContext->tssState[dwStage].dwValue[D3DTSS_ALPHAOP]]);
            dbgDPFAndDump(flag, "    AlphaArg1      = %s",   szD3DArg[pContext->tssState[dwStage].dwValue[D3DTSS_ALPHAARG1]]);
            dbgDPFAndDump(flag, "    AlphaArg2      = %s",   szD3DArg[pContext->tssState[dwStage].dwValue[D3DTSS_ALPHAARG2]]);
            dbgDPFAndDump(flag, "    BumpEnvMat00   = %08x", pContext->tssState[dwStage].dwValue[D3DTSS_BUMPENVMAT00]);
            dbgDPFAndDump(flag, "    BumpEnvMat01   = %08x", pContext->tssState[dwStage].dwValue[D3DTSS_BUMPENVMAT01]);
            dbgDPFAndDump(flag, "    BumpEnvMat10   = %08x", pContext->tssState[dwStage].dwValue[D3DTSS_BUMPENVMAT10]);
            dbgDPFAndDump(flag, "    BumpEnvMat11   = %08x", pContext->tssState[dwStage].dwValue[D3DTSS_BUMPENVMAT11]);
            dbgDPFAndDump(flag, "    TexCoordIndex  = %08x", pContext->tssState[dwStage].dwValue[D3DTSS_TEXCOORDINDEX]);
            dbgDPFAndDump(flag, "    BorderColor    = %08x", pContext->tssState[dwStage].dwValue[D3DTSS_BORDERCOLOR]);
            dbgDPFAndDump(flag, "    MipMapLODBias  = %08x", pContext->tssState[dwStage].dwValue[D3DTSS_MIPMAPLODBIAS]);
            dbgDPFAndDump(flag, "    MaxMipMapLevel = %08x", pContext->tssState[dwStage].dwValue[D3DTSS_MAXMIPLEVEL]);
            dbgDPFAndDump(flag, "    MaxAnisotropy  = %08x", pContext->tssState[dwStage].dwValue[D3DTSS_MAXANISOTROPY]);
            dbgDPFAndDump(flag, "    BumpEnvlScale  = %08x", pContext->tssState[dwStage].dwValue[D3DTSS_BUMPENVLSCALE]);
            dbgDPFAndDump(flag, "    BumpEnvlOffset = %08x", pContext->tssState[dwStage].dwValue[D3DTSS_BUMPENVLOFFSET]);
            dbgDPFAndDump(flag, "");
        }
    }

    bDPF = dbgShowState & NVDBG_SHOW_DX5_CLASS_STATE;
    bDump = dbgDumpState & NVDBG_SHOW_DX5_CLASS_STATE;
    flag = NVDBG_SHOW_DX5_CLASS_STATE;

    if ((bDPF || bDump) &&
        (dwFlags & NVDBG_SHOW_DX5_CLASS_STATE)) {
        dbgDPFAndDump(flag, "D3D:NV4 DX5 Class Context State:");
        dbgDPFAndDump(flag, "    ColorKey           = %08x", pContext->ctxInnerLoop.dwColorKey);
        dbgDPFAndDump(flag, "    TextureOffset      = %08x", pContext->ctxInnerLoop.dwTextureOffset);
        dbgDPFAndDump(flag, "    Format             = %08x", pContext->ctxInnerLoop.dwFormat);
        dbgDPFAndDump(flag, "    Filter             = %08x", pContext->ctxInnerLoop.dwFilter);
        dbgDPFAndDump(flag, "    Blend              = %08x", pContext->ctxInnerLoop.dwBlend);
        dbgDPFAndDump(flag, "    Control            = %08x", pContext->ctxInnerLoop.dwControl);
        dbgDPFAndDump(flag, "    FogColor           = %08x", pContext->ctxInnerLoop.dwFogColor);
        dbgDPFAndDump(flag, "");
    }

    bDPF = dbgShowState & NVDBG_SHOW_DX6_CLASS_STATE;
    bDump = dbgDumpState & NVDBG_SHOW_DX6_CLASS_STATE;
    flag = NVDBG_SHOW_DX6_CLASS_STATE;

    if ((bDPF || bDump) &&
        (dwFlags & NVDBG_SHOW_DX6_CLASS_STATE)) {
        dbgDPFAndDump(flag, "D3D:NV4 DX6 Class Context State:");
        dbgDPFAndDump(flag, "    TextureOffset[0]   = %08x", pContext->mtsState.dwTextureOffset[0]);
        dbgDPFAndDump(flag, "    TextureOffset[1]   = %08x", pContext->mtsState.dwTextureOffset[1]);
        dbgDPFAndDump(flag, "    TextureFormat[0]   = %08x", pContext->mtsState.dwTextureFormat[0]);
        dbgDPFAndDump(flag, "    TextureFormat[1]   = %08x", pContext->mtsState.dwTextureFormat[1]);
        dbgDPFAndDump(flag, "    TextureFilter[0]   = %08x", pContext->mtsState.dwTextureFilter[0]);
        dbgDPFAndDump(flag, "    TextureFilter[1]   = %08x", pContext->mtsState.dwTextureFilter[1]);
        dbgDPFAndDump(flag, "    Combine0Alpha      = %08x", pContext->mtsState.dwCombine0Alpha);
        dbgDPFAndDump(flag, "    Combine0Color      = %08x", pContext->mtsState.dwCombine0Color);
        dbgDPFAndDump(flag, "    Combine1Alpha      = %08x", pContext->mtsState.dwCombine1Alpha);
        dbgDPFAndDump(flag, "    Combine1Color      = %08x", pContext->mtsState.dwCombine1Color);
        dbgDPFAndDump(flag, "    CombineFactor      = %08x", pContext->mtsState.dwCombineFactor);
        dbgDPFAndDump(flag, "    Blend              = %08x", pContext->mtsState.dwBlend);
        dbgDPFAndDump(flag, "    Control0           = %08x", pContext->mtsState.dwControl0);
        dbgDPFAndDump(flag, "    Control1           = %08x", pContext->mtsState.dwControl1);
        dbgDPFAndDump(flag, "    Control2           = %08x", pContext->mtsState.dwControl2);
        dbgDPFAndDump(flag, "    FogColor           = %08x", pContext->mtsState.dwFogColor);
        dbgDPFAndDump(flag, "");
    }

    bDPF = dbgShowState & NVDBG_SHOW_SURFACE_STATE;
    bDump = dbgDumpState & NVDBG_SHOW_SURFACE_STATE;
    flag = NVDBG_SHOW_SURFACE_STATE;

    if ((bDPF || bDump) &&
        (dwFlags & NVDBG_SHOW_SURFACE_STATE)) {
        dbgDPFAndDump(flag, "D3D:NV4 Surface State:");
        dbgDPFAndDump(flag, "    ClipStart (x, y)   = %04d, %04d", pContext->surfaceViewport.clipHorizontal.wX, pContext->surfaceViewport.clipVertical.wY);
        dbgDPFAndDump(flag, "    ClipSize (w, h)    = %04d, %04d", pContext->surfaceViewport.clipHorizontal.wWidth, pContext->surfaceViewport.clipVertical.wHeight);
        dbgDPFAndDump(flag, "    SurfaceAddr        = %08x",       pContext->pRenderTarget->getAddress());
        dbgDPFAndDump(flag, "    SurfaceOffset      = %08x",       pContext->pRenderTarget->getOffset());
        dbgDPFAndDump(flag, "    SurfacePitch       = %04x",       pContext->pRenderTarget->getPitch());
        dbgDPFAndDump(flag, "    SurfaceFormat      = %08x",       pContext->pRenderTarget->getFormat());
        dbgDPFAndDump(flag, "    SurfaceBPP         = %08x",       pContext->pRenderTarget->getBPP());
        dbgDPFAndDump(flag, "    Z-BufferAddr       = %08x",       pContext->pZetaBuffer->getAddress());
        dbgDPFAndDump(flag, "    Z-BufferOffset     = %08x",       pContext->pZetaBuffer->getOffset());
        dbgDPFAndDump(flag, "    Z-BufferPitch      = %04x",       pContext->pZetaBuffer->getPitch());
        dbgDPFAndDump(flag, "");
    }

    return;
}

//-------------------------------------------------------------------------

void dbgShowRenderStateChange (BOOL bChanged, DWORD dwStateType, DWORD dwStateValue)
{
    if (dbgShowState & NVDBG_SHOW_RENDER_STATE) {
        if (bChanged) {
            DPF("nvSetContextState: Render State changed");
        }
        else {
            DPF("nvSetContextState: Render State unchanged");
        }
        DPF("  State = %s (%08d)", szD3DRenderStateLookupTable[dwStateType], dwStateType);
        DPF("  Data  = 0x%08x",    dwStateValue);
    }
}

//-------------------------------------------------------------------------

void dbgDisplayDrawPrimitives2Info (BYTE bCommand, WORD wCommandCount)
{
    BOOL  bDPF, bDump;
    DWORD flag;

    bDPF  = dbgShowState & NVDBG_SHOW_DRAWPRIM2_INFO;
    bDump = dbgDumpState & NVDBG_SHOW_DRAWPRIM2_INFO;
    flag  = NVDBG_SHOW_DRAWPRIM2_INFO;

    if (!(bDPF || bDump)) return;

    if (bCommand <= D3D_DP2OP_MAX) {
        dbgDPFAndDump(flag, "%s (%d) : %08x", szD3DDP2OpLookupTable[bCommand], (DWORD)bCommand, (DWORD)wCommandCount);
    }
    else {
        dbgDPFAndDump(flag, "%s (%d) : %08x", "D3DDP2OP_UNKNOWN", (DWORD)bCommand, (DWORD)wCommandCount);
    }
}

//-------------------------------------------------------------------------

void dbgDisplayVertexData
(
    BOOL    dx6,      // dx6 ? two sets of texture coordinates : one set
    DWORD   *pVertex  // array of vertex components (e.g. D3DTLVERTEX)
)
{
    static DWORD dbgVertexCount = 0;
    BOOL   bDPF, bDump;
    DWORD  flag;

    static float xmin   =  100000.0;
    static float ymin   =  100000.0;
    static float zmin   =  100000.0;
    static float rhwmin =  100000.0;
    static float xmax   = -100000.0;
    static float ymax   = -100000.0;
    static float zmax   = -100000.0;
    static float rhwmax = -100000.0;

    bDPF  = dbgShowState & NVDBG_SHOW_VERTICES;
    bDump = dbgDumpState & NVDBG_SHOW_VERTICES;
    flag  = NVDBG_SHOW_VERTICES;

    dbgVertexCount++;

    if (bDPF || bDump) {
        dbgDPFAndDump(flag, "D3D:NV4 Vertex Data (#%d):", dbgVertexCount);
        dbgDPFAndDump(flag, "    X        = %f",    FLOAT_FROM_DWORD(pVertex[0]));
        dbgDPFAndDump(flag, "    Y        = %f",    FLOAT_FROM_DWORD(pVertex[1]));
        dbgDPFAndDump(flag, "    Z        = %f",    FLOAT_FROM_DWORD(pVertex[2]));
        dbgDPFAndDump(flag, "    RHW      = %f",    FLOAT_FROM_DWORD(pVertex[3]));
        dbgDPFAndDump(flag, "    Diffuse  = %08x",  pVertex[4]);
        dbgDPFAndDump(flag, "    Specular = %08x",  pVertex[5]);
        dbgDPFAndDump(flag, "    U        = %f",    FLOAT_FROM_DWORD(pVertex[6]));
        dbgDPFAndDump(flag, "    V        = %f",    FLOAT_FROM_DWORD(pVertex[7]));

        if (dx6) {
            dbgDPFAndDump(flag, "    U2       = %f", FLOAT_FROM_DWORD(pVertex[8]));
            dbgDPFAndDump(flag, "    V2       = %f", FLOAT_FROM_DWORD(pVertex[9]));
        }

        dbgDPFAndDump(flag, "");
    }

    bDPF  = dbgShowState & NVDBG_SHOW_VERTEX_MAX_MIN;;
    bDump = dbgDumpState & NVDBG_SHOW_VERTEX_MAX_MIN;;
    flag  = NVDBG_SHOW_VERTEX_MAX_MIN;

    if (bDPF || bDump) {

        float f;
        f = FLOAT_FROM_DWORD(pVertex[0]);
        if (f > xmax) xmax = f;
        if (f < xmin) xmin = f;
        f = FLOAT_FROM_DWORD(pVertex[1]);
        if (f > ymax) ymax = f;
        if (f < ymin) ymin = f;
        f = FLOAT_FROM_DWORD(pVertex[2]);
        if (f > zmax) zmax = f;
        if (f < zmin) zmin = f;
        f = FLOAT_FROM_DWORD(pVertex[3]);
        if (f > rhwmax) rhwmax = f;
        if (f < rhwmin) rhwmin = f;

        dbgDPFAndDump(flag,"Minimum / Maximum Values");
        dbgDPFAndDump(flag,"  X   => %f / %f", xmin,xmax);
        dbgDPFAndDump(flag,"  Y   => %f / %f", ymin,ymax);
        dbgDPFAndDump(flag,"  Z   => %f / %f", zmin,zmax);
        dbgDPFAndDump(flag,"  RHW => %f / %f", rhwmin,rhwmax);
        dbgDPFAndDump(flag,"\r\n");

    } else {

        // if NVDBG_SHOW_VERTEX_MAX_MIN is off, then reset values
        xmin   =  100000.0;
        ymin   =  100000.0;
        zmin   =  100000.0;
        rhwmin =  100000.0;
        xmax   = -100000.0;
        ymax   = -100000.0;
        zmax   = -100000.0;
        rhwmax = -100000.0;

    }

}

//-------------------------------------------------------------------------

void dbgDisplayLight
(
    LPD3DLIGHT7 pLight7
)
{
    if (dbgShowState & NVDBG_SHOW_LIGHTS)
    {
        static DWORD dwCount = 0;
        dwCount++;

        //if ((dwCount == 1) || (dwCount == 30))
        {
            DPF ("D3DLIGHT7 (call #%d):-  (note: large floats will not be printed correctly)",dwCount);
            switch (pLight7->dltType)
            {
                case D3DLIGHT_SPOT:         DPF ("    type: SPOT");
                                            break;
                case D3DLIGHT_POINT:        DPF ("    type: POINT");
                                            break;
                case D3DLIGHT_DIRECTIONAL:  DPF ("    type: DIRECTIONAL");
                                            break;
            }
            DPF (" diffuse: ARGB = %02x %02x %02x %02x",
                      int(255.0 * pLight7->dcvDiffuse.a),
                      int(255.0 * pLight7->dcvDiffuse.r),
                      int(255.0 * pLight7->dcvDiffuse.g),
                      int(255.0 * pLight7->dcvDiffuse.b));
            DPF ("specular: ARGB = %02x %02x %02x %02x",
                      int(255.0 * pLight7->dcvSpecular.a),
                      int(255.0 * pLight7->dcvSpecular.r),
                      int(255.0 * pLight7->dcvSpecular.g),
                      int(255.0 * pLight7->dcvSpecular.b));
            DPF (" ambient: ARGB = %02x %02x %02x %02x",
                      int(255.0 * pLight7->dcvAmbient.a),
                      int(255.0 * pLight7->dcvAmbient.r),
                      int(255.0 * pLight7->dcvAmbient.g),
                      int(255.0 * pLight7->dcvAmbient.b));

            DPF ("position: %d.%04d %d.%04d %d.%04d",
                      int(pLight7->dvPosition.x),ABS(int(pLight7->dvPosition.x * 10000) % 10000),
                      int(pLight7->dvPosition.y),ABS(int(pLight7->dvPosition.y * 10000) % 10000),
                      int(pLight7->dvPosition.z),ABS(int(pLight7->dvPosition.z * 10000) % 10000));

            DPF ("     dir: %d.%04d %d.%04d %d.%04d",
                      int(pLight7->dvDirection.x),ABS(int(pLight7->dvDirection.x * 10000) % 10000),
                      int(pLight7->dvDirection.y),ABS(int(pLight7->dvDirection.y * 10000) % 10000),
                      int(pLight7->dvDirection.z),ABS(int(pLight7->dvDirection.z * 10000) % 10000));

            DPF ("   range: %d.%04d",int(pLight7->dvRange),ABS(int(pLight7->dvRange * 10000) % 10000));
            DPF (" falloff: %d.%04d",int(pLight7->dvFalloff),ABS(int(pLight7->dvFalloff * 10000) % 10000));
            DPF ("    att0: %d.%04d",int(pLight7->dvAttenuation0),ABS(int(pLight7->dvAttenuation0 * 10000) % 10000));
            DPF ("    att1: %d.%04d",int(pLight7->dvAttenuation1),ABS(int(pLight7->dvAttenuation1 * 10000) % 10000));
            DPF ("    att2: %d.%04d",int(pLight7->dvAttenuation2),ABS(int(pLight7->dvAttenuation2 * 10000) % 10000));
            DPF ("   theta: %d.%04d",int(pLight7->dvTheta),ABS(int(pLight7->dvTheta * 10000) % 10000));
            DPF ("     phi: %d.%04d",int(pLight7->dvPhi),ABS(int(pLight7->dvPhi * 10000) % 10000));
        }
    }
}

//-------------------------------------------------------------------------
// STATE VALIDATION
//-------------------------------------------------------------------------

BOOL dbgValidateControlRegisters
(
    PNVD3DCONTEXT   pContext
)
{
    DWORD   drfValue;

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    /*
     * Validate the Format register.
     */
    drfValue = DRF_VAL(054, _FORMAT, _CONTEXT_DMA, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_CONTEXT_DMA_A)
        && (drfValue != NV054_FORMAT_CONTEXT_DMA_B)) {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_CONTEXT_DMA field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _COLORKEYENABLE, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_COLORKEYENABLE_FALSE)
        && (drfValue != NV054_FORMAT_COLORKEYENABLE_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_COLORKEYENABLE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _ORIGIN_ZOH, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_ORIGIN_ZOH_CENTER)
        && (drfValue != NV054_FORMAT_ORIGIN_ZOH_CORNER)) {
        DPF("dbgValidateControlRegisters: NV054_FORMAT__ORIGIN_ZOH field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _ORIGIN_FOH, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_ORIGIN_FOH_CENTER)
        && (drfValue != NV054_FORMAT_ORIGIN_FOH_CORNER)) {
        DPF("dbgValidateControlRegisters: NV054_FORMAT__ORIGIN_FOH field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _COLOR, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_COLOR_LE_Y8)
        && (drfValue != NV054_FORMAT_COLOR_LE_A1R5G5B5)
        && (drfValue != NV054_FORMAT_COLOR_LE_X1R5G5B5)
        && (drfValue != NV054_FORMAT_COLOR_LE_A4R4G4B4)
        && (drfValue != NV054_FORMAT_COLOR_LE_R5G6B5)
        && (drfValue != NV054_FORMAT_COLOR_LE_A8R8G8B8)
        && (drfValue != NV054_FORMAT_COLOR_LE_X8R8G8B8)) {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_COLOR field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
//    drfValue = DRF_VAL(054, _FORMAT, _MIPMAP_LEVELS, pContext->ctxInnerLoop.dwFormat);
//    if (drfValue )
//    {
//        DPF("dbgValidateControlRegisters: NV054_FORMAT_MIPMAP_LEVELS field invalid 0x%08x", drfValue);
//        dbgD3DError();
//    }
    drfValue = DRF_VAL(054, _FORMAT, _BASE_SIZE_U, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_BASE_SIZE_U_1)
        && (drfValue != NV054_FORMAT_BASE_SIZE_U_2)
        && (drfValue != NV054_FORMAT_BASE_SIZE_U_4)
        && (drfValue != NV054_FORMAT_BASE_SIZE_U_8)
        && (drfValue != NV054_FORMAT_BASE_SIZE_U_16)
        && (drfValue != NV054_FORMAT_BASE_SIZE_U_32)
        && (drfValue != NV054_FORMAT_BASE_SIZE_U_64)
        && (drfValue != NV054_FORMAT_BASE_SIZE_U_128)
        && (drfValue != NV054_FORMAT_BASE_SIZE_U_256)
        && (drfValue != NV054_FORMAT_BASE_SIZE_U_512)
        && (drfValue != NV054_FORMAT_BASE_SIZE_U_1024)
        && (drfValue != NV054_FORMAT_BASE_SIZE_U_2048)) {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_BASE_SIZE_U field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _BASE_SIZE_V, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_BASE_SIZE_V_1)
        && (drfValue != NV054_FORMAT_BASE_SIZE_V_2)
        && (drfValue != NV054_FORMAT_BASE_SIZE_V_4)
        && (drfValue != NV054_FORMAT_BASE_SIZE_V_8)
        && (drfValue != NV054_FORMAT_BASE_SIZE_V_16)
        && (drfValue != NV054_FORMAT_BASE_SIZE_V_32)
        && (drfValue != NV054_FORMAT_BASE_SIZE_V_64)
        && (drfValue != NV054_FORMAT_BASE_SIZE_V_128)
        && (drfValue != NV054_FORMAT_BASE_SIZE_V_256)
        && (drfValue != NV054_FORMAT_BASE_SIZE_V_512)
        && (drfValue != NV054_FORMAT_BASE_SIZE_V_1024)
        && (drfValue != NV054_FORMAT_BASE_SIZE_V_2048)) {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_BASE_SIZE_V field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _TEXTUREADDRESSU, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_TEXTUREADDRESSU_WRAP)
        && (drfValue != NV054_FORMAT_TEXTUREADDRESSU_MIRROR)
        && (drfValue != NV054_FORMAT_TEXTUREADDRESSU_CLAMP)
        && (drfValue != NV054_FORMAT_TEXTUREADDRESSU_BORDER)) {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_TEXTUREADDRESSU field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _WRAPU, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_WRAPU_FALSE)
        && (drfValue != NV054_FORMAT_WRAPU_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_WRAPU field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _TEXTUREADDRESSV, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_TEXTUREADDRESSV_WRAP)
        && (drfValue != NV054_FORMAT_TEXTUREADDRESSV_MIRROR)
        && (drfValue != NV054_FORMAT_TEXTUREADDRESSV_CLAMP)
        && (drfValue != NV054_FORMAT_TEXTUREADDRESSV_BORDER)) {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_TEXTUREADDRESSV field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FORMAT, _WRAPV, pContext->ctxInnerLoop.dwFormat);
    if ((drfValue != NV054_FORMAT_WRAPV_FALSE)
        && (drfValue != NV054_FORMAT_WRAPV_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_FORMAT_WRAPV field invalid 0x%08x", drfValue);
        dbgD3DError();
    }

    // Validate the Filter register.
    drfValue = DRF_VAL(054, _FILTER, _MIPMAP_DITHER_ENABLE, pContext->ctxInnerLoop.dwFilter);
    if ((drfValue != NV054_FILTER_MIPMAP_DITHER_ENABLE_FALSE)
        && (drfValue != NV054_FILTER_MIPMAP_DITHER_ENABLE_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_FILTER_MIPMAP_DITHER_ENABLE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FILTER, _TEXTUREMIN, pContext->ctxInnerLoop.dwFilter);
    if ((drfValue != NV054_FILTER_TEXTUREMIN_NEAREST)
        && (drfValue != NV054_FILTER_TEXTUREMIN_LINEAR)
        && (drfValue != NV054_FILTER_TEXTUREMIN_MIPNEAREST)
        && (drfValue != NV054_FILTER_TEXTUREMIN_MIPLINEAR)
        && (drfValue != NV054_FILTER_TEXTUREMIN_LINEARMIPNEAREST)
        && (drfValue != NV054_FILTER_TEXTUREMIN_LINEARMIPLINEAR)) {
        DPF("dbgValidateControlRegisters: NV054_FILTER_TEXTUREMIN field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FILTER, _ANISOTROPIC_MINIFY_ENABLE, pContext->ctxInnerLoop.dwFilter);
    if ((drfValue != NV054_FILTER_ANISOTROPIC_MINIFY_ENABLE_FALSE)
        && (drfValue != NV054_FILTER_ANISOTROPIC_MINIFY_ENABLE_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_FILTER_ANISOTROPIC_MINIFY_ENABLE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FILTER, _TEXTUREMAG, pContext->ctxInnerLoop.dwFilter);
    if ((drfValue != NV054_FILTER_TEXTUREMAG_NEAREST)
        && (drfValue != NV054_FILTER_TEXTUREMAG_LINEAR)
        && (drfValue != NV054_FILTER_TEXTUREMAG_MIPNEAREST)
        && (drfValue != NV054_FILTER_TEXTUREMAG_MIPLINEAR)
        && (drfValue != NV054_FILTER_TEXTUREMAG_LINEARMIPNEAREST)
        && (drfValue != NV054_FILTER_TEXTUREMAG_LINEARMIPLINEAR)) {
        DPF("dbgValidateControlRegisters: NV054_FILTER_TEXTUREMAG field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _FILTER, _ANISOTROPIC_MAGNIFY_ENABLE, pContext->ctxInnerLoop.dwFilter);
    if ((drfValue != NV054_FILTER_ANISOTROPIC_MAGNIFY_ENABLE_FALSE)
        && (drfValue != NV054_FILTER_ANISOTROPIC_MAGNIFY_ENABLE_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_FILTER_ANISOTROPIC_MAGNIFY_ENABLE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }

    // Validate the Blend register.
    drfValue = DRF_VAL(054, _BLEND, _TEXTUREMAPBLEND, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_TEXTUREMAPBLEND_DECAL)
        && (drfValue != NV054_BLEND_TEXTUREMAPBLEND_MODULATE)
        && (drfValue != NV054_BLEND_TEXTUREMAPBLEND_DECALALPHA)
        && (drfValue != NV054_BLEND_TEXTUREMAPBLEND_MODULATEALPHA)
        && (drfValue != NV054_BLEND_TEXTUREMAPBLEND_DECALMASK)
        && (drfValue != NV054_BLEND_TEXTUREMAPBLEND_MODULATEMASK)
        && (drfValue != NV054_BLEND_TEXTUREMAPBLEND_COPY)
        && (drfValue != NV054_BLEND_TEXTUREMAPBLEND_ADD)) {
        DPF("dbgValidateControlRegisters: NV054_BLEND_TEXTUREMAPBLEND field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _MASK_BIT, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_MASK_BIT_LSB)
        && (drfValue != NV054_BLEND_MASK_BIT_MSB)) {
        DPF("dbgValidateControlRegisters: NV054_BLEND_MASK_BIT field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _SHADEMODE, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_SHADEMODE_FLAT)
        && (drfValue != NV054_BLEND_SHADEMODE_GOURAUD)
        && (drfValue != NV054_BLEND_SHADEMODE_PHONG)) {
        DPF("dbgValidateControlRegisters: NV054_BLEND_SHADEMODE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _TEXTUREPERSPECTIVE, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_TEXTUREPERSPECTIVE_FALSE)
        && (drfValue != NV054_BLEND_TEXTUREPERSPECTIVE_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_BLEND_TEXTUREPERSPECTIVE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _SPECULARENABLE, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_SPECULARENABLE_FALSE)
        && (drfValue != NV054_BLEND_SPECULARENABLE_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_BLEND_SPECULARENABLE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _FOGENABLE, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_FOGENABLE_FALSE)
        && (drfValue != NV054_BLEND_FOGENABLE_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_BLEND_FOGENABLE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _ALPHABLENDENABLE, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_ALPHABLENDENABLE_FALSE)
        && (drfValue != NV054_BLEND_ALPHABLENDENABLE_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_BLEND_ALPHABLENDENABLE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _SRCBLEND, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_SRCBLEND_ZERO)
        && (drfValue != NV054_BLEND_SRCBLEND_ONE)
        && (drfValue != NV054_BLEND_SRCBLEND_SRCCOLOR)
        && (drfValue != NV054_BLEND_SRCBLEND_INVSRCCOLOR)
        && (drfValue != NV054_BLEND_SRCBLEND_SRCALPHA)
        && (drfValue != NV054_BLEND_SRCBLEND_INVSRCALPHA)
        && (drfValue != NV054_BLEND_SRCBLEND_DESTALPHA)
        && (drfValue != NV054_BLEND_SRCBLEND_INVDESTALPHA)
        && (drfValue != NV054_BLEND_SRCBLEND_DESTCOLOR)
        && (drfValue != NV054_BLEND_SRCBLEND_INVDESTCOLOR)
        && (drfValue != NV054_BLEND_SRCBLEND_SRCALPHASAT)) {
        DPF("dbgValidateControlRegisters: NV054_BLEND_SRCBLEND field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _BLEND, _DESTBLEND, pContext->ctxInnerLoop.dwBlend);
    if ((drfValue != NV054_BLEND_DESTBLEND_ZERO)
        && (drfValue != NV054_BLEND_DESTBLEND_ONE)
        && (drfValue != NV054_BLEND_DESTBLEND_SRCCOLOR)
        && (drfValue != NV054_BLEND_DESTBLEND_INVSRCCOLOR)
        && (drfValue != NV054_BLEND_DESTBLEND_SRCALPHA)
        && (drfValue != NV054_BLEND_DESTBLEND_INVSRCALPHA)
        && (drfValue != NV054_BLEND_DESTBLEND_DESTALPHA)
        && (drfValue != NV054_BLEND_DESTBLEND_INVDESTALPHA)
        && (drfValue != NV054_BLEND_DESTBLEND_DESTCOLOR)
        && (drfValue != NV054_BLEND_DESTBLEND_INVDESTCOLOR)
        && (drfValue != NV054_BLEND_DESTBLEND_SRCALPHASAT)) {
        DPF("dbgValidateControlRegisters: NV054_BLEND_DESTBLEND field invalid 0x%08x", drfValue);
        dbgD3DError();
    }

    // Validate the Control register.
    drfValue = DRF_VAL(054, _CONTROL, _ALPHAFUNC, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_ALPHAFUNC_NEVER)
        && (drfValue != NV054_CONTROL_ALPHAFUNC_LESS)
        && (drfValue != NV054_CONTROL_ALPHAFUNC_EQUAL)
        && (drfValue != NV054_CONTROL_ALPHAFUNC_LESSEQUAL)
        && (drfValue != NV054_CONTROL_ALPHAFUNC_GREATER)
        && (drfValue != NV054_CONTROL_ALPHAFUNC_NOTEQUAL)
        && (drfValue != NV054_CONTROL_ALPHAFUNC_GREATEREQUAL)
        && (drfValue != NV054_CONTROL_ALPHAFUNC_ALWAYS)) {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_ALPHAFUNC field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _ALPHATESTENABLE, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_ALPHATESTENABLE_FALSE)
        && (drfValue != NV054_CONTROL_ALPHATESTENABLE_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_ALPHATESTENABLE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _ZENABLE, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_ZENABLE_FALSE)
        && (drfValue != NV054_CONTROL_ZENABLE_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_ZENABLE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _ZFUNC, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_ZFUNC_NEVER)
        && (drfValue != NV054_CONTROL_ZFUNC_LESS)
        && (drfValue != NV054_CONTROL_ZFUNC_EQUAL)
        && (drfValue != NV054_CONTROL_ZFUNC_LESSEQUAL)
        && (drfValue != NV054_CONTROL_ZFUNC_GREATER)
        && (drfValue != NV054_CONTROL_ZFUNC_NOTEQUAL)
        && (drfValue != NV054_CONTROL_ZFUNC_GREATEREQUAL)
        && (drfValue != NV054_CONTROL_ZFUNC_ALWAYS)) {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_ZFUNC field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _CULLMODE, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_CULLMODE_NONE)
        && (drfValue != NV054_CONTROL_CULLMODE_CW)
        && (drfValue != NV054_CONTROL_CULLMODE_CCW)) {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_CULLMODE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _DITHERENABLE, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_DITHERENABLE_FALSE)
        && (drfValue != NV054_CONTROL_DITHERENABLE_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_DITHERENABLE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _Z_PERSPECTIVE_ENABLE, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_Z_PERSPECTIVE_ENABLE_FALSE)
        && (drfValue != NV054_CONTROL_Z_PERSPECTIVE_ENABLE_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_Z_PERSPECTIVE_ENABLE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _ZWRITEENABLE, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_ZWRITEENABLE_FALSE)
        && (drfValue != NV054_CONTROL_ZWRITEENABLE_TRUE)) {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_ZWRITEENABLE field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    drfValue = DRF_VAL(054, _CONTROL, _Z_FORMAT, pContext->ctxInnerLoop.dwControl);
    if ((drfValue != NV054_CONTROL_Z_FORMAT_FIXED)
        && (drfValue != NV054_CONTROL_Z_FORMAT_FLOAT)) {
        DPF("dbgValidateControlRegisters: NV054_CONTROL_Z_FORMAT field invalid 0x%08x", drfValue);
        dbgD3DError();
    }
    return(TRUE);
}

#endif // DEBUG

//-------------------------------------------------------------------------
// TEXTURE PREVIEWING
//-------------------------------------------------------------------------

#ifdef DEBUG

// display a particular texture mipmap level at screen position (dwX, dwY)

#define CLEAR_BORDER_SIZE 24

// set one pixel's worth of data from pSrc, subject to dwBPP
#define SETPIXEL1(pPix, pSrc, dwBPP)                \
{                                                   \
    if ((dwBPP) == 2) {                             \
        *(WORD*)(pPix) = *(WORD*)(pSrc);            \
    }                                               \
    else {                                          \
        *(DWORD*)(pPix) = *(DWORD*)(pSrc);          \
    }                                               \
}

// set one pixel's data from BYTES a, r, g, and b, subject to dwBPP
#define SETPIXEL2(pPix, a,r,g,b, dwBPP)             \
{                                                   \
    if ((dwBPP) == 2) {                             \
        *(WORD*)(pPix) = ((((r) & 0xf8) << 8) |     \
                          (((g) & 0xfc) << 3) |     \
                          (((b) & 0xf8) >> 3));     \
    }                                               \
    else {                                          \
        *(DWORD*)(pPix) = (((a) << 24) |            \
                           ((r) << 16) |            \
                           ((g) <<  8) |            \
                           ((b) <<  0));            \
    }                                               \
}

//---------------------------------------------------------------------------

void dbgTextureDisplayLevel
(
    CTexture *pTexture,
    DWORD     dwX,           // horizontal location for output
    DWORD     dwY,           // vertical location for output
    DWORD     dwClearColor
)
{
    DWORD u, v, u0, v0, uu, vv;
    DWORD dwNonZeroAlphaCount = 0;
    DWORD dwTexWidth, dwTexHeight, dwTexPitch;
    DWORD dwTexLogicalWidth, dwTexLogicalHeight;
    DWORD dwXOffset, dwXOffsetMax, dwYMax;
    DWORD dwFBOffset, dwFBIndexShift;
    DWORD dwTexelIndex, dwTexIndexShift;
    DWORD dwColors, dwBits;
    PBYTE pTextureBase, pTexel, pPalette;
    PBYTE pFB, pFB0;
    float a0, r0, g0, b0;
    float a1, r1, g1, b1;
    float da, dr, dg, db;
    WORD  wInterpIndex, wInterp;
    BYTE  a, r, g, b;
    BOOL  bLinear;

    bLinear = (dbgTexturePreview & NVDBG_TEXTURE_PREVIEW_LINEAR) ? TRUE : FALSE;

    dwTexWidth         = pTexture->getWidth();
    dwTexLogicalWidth  = pTexture->getLogicalWidth();
    dwTexHeight        = pTexture->getHeight();
    dwTexLogicalHeight = pTexture->getLogicalHeight();
    dwTexPitch         = pTexture->getPitch();

    // make sure we don't draw outside the primary
    dwXOffset    = dwX * dbgPrimaryBPP;
    dwXOffsetMax = dbgPrimaryPitch  - dbgPrimaryBPP * (dwTexLogicalWidth + CLEAR_BORDER_SIZE);
    dwYMax       = dbgPrimaryHeight - (dwTexLogicalHeight + CLEAR_BORDER_SIZE);

    dwXOffset = min (dwXOffset, dwXOffsetMax);
    dwY       = min (dwY, dwYMax);

    dwFBOffset = dwY*dbgPrimaryPitch + dwXOffset;

    pFB  = (PBYTE) VIDMEM_ADDR(pDriverData->CurrentVisibleSurfaceAddress);
    pFB  = pFB + dwFBOffset;
    pFB0 = pFB;

    pTextureBase = bLinear ?
                   (PBYTE) (pTexture->getLinear()->getAddress()) :
                   (PBYTE) (pTexture->getSwizzled()->getAddress());

    if (!pTextureBase) {
        DPF ("dbgTextureDisplayLevel: couldn't get texture base. aborting preview");
        return;
    }

    dwTexIndexShift = pTexture->getBPP();
    ASM_LOG2 (dwTexIndexShift);

    dwFBIndexShift = dbgPrimaryBPP;
    ASM_LOG2 (dwFBIndexShift);

    // clear the area first

    for (v = 0; v < dwTexLogicalHeight+CLEAR_BORDER_SIZE; v++) {
        for (u = 0; u < dwTexLogicalWidth+CLEAR_BORDER_SIZE; u++) {
            SETPIXEL1 (pFB+(u<<dwFBIndexShift), &dwClearColor, dbgPrimaryBPP);
        }
        pFB += dbgPrimaryPitch;
    }
    pFB = pFB0;

    // render the texture

    if (pTexture->isDXT()) {

        // iterate over the blocks
        for (v=0; v < dwTexHeight; v++) {

            // start pFB in the upper-left corner of this row of 4x4 blocks
            pFB = pFB0 + (dbgPrimaryPitch * (v<<2));

            for (u=0; u < dwTexWidth; u++) {

                dwTexelIndex = dwTexWidth * v + u;
                pTexel = pTextureBase + (dwTexelIndex << dwTexIndexShift);

                switch (pTexture->getFormat()) {

                    case NV_SURFACE_FORMAT_DXT1_A1R5G5B5:
                        // ignore the 1-bit alpha sub-case of DXT1
                        dwColors = ((DWORD*)pTexel)[0];
                        dwBits   = ((DWORD*)pTexel)[1];
                        break;

                    case NV_SURFACE_FORMAT_DXT23_A8R8G8B8:
                    case NV_SURFACE_FORMAT_DXT45_A8R8G8B8:
                        // ignore the alpha component completely for DXT2-5
                        dwColors = ((DWORD*)pTexel)[2];
                        dwBits   = ((DWORD*)pTexel)[3];
                        break;

                    default:
                        DPF ("unhandled texture format in dbgTextureDisplay");
                        dbgD3DError();
                        return;
                        break;

                }  // switch

                a0 = (float) (0);
                r0 = (float) ((dwColors >> 8) & 0xf8);
                g0 = (float) ((dwColors >> 3) & 0xfc);
                b0 = (float) ((dwColors << 3) & 0xf8);

                a1 = (float) (0);
                r1 = (float) ((dwColors >> 24) & 0xf8);
                g1 = (float) ((dwColors >> 19) & 0xfc);
                b1 = (float) ((dwColors >> 13) & 0xf8);

                da = (float) ((a1 - a0) / 3);
                dr = (float) ((r1 - r0) / 3);
                dg = (float) ((g1 - g0) / 3);
                db = (float) ((b1 - b0) / 3);

                for (vv=0; vv<4; vv++) {
                    for (uu=0; uu<4; uu++) {
                        wInterpIndex = (WORD)(dwBits & 0x3);
                        wInterp = (wInterpIndex == 0x0) ? 0 :
                                  (wInterpIndex == 0x1) ? 3 :
                                  (wInterpIndex == 0x2) ? 1 : 2;
                        dwBits >>= 2;
                        a = (BYTE) (a0 + wInterp*da);
                        r = (BYTE) (r0 + wInterp*dr);
                        g = (BYTE) (g0 + wInterp*dg);
                        b = (BYTE) (b0 + wInterp*db);
                        SETPIXEL2 ((pFB + vv*dbgPrimaryPitch) + (uu<<dwFBIndexShift), a,r,g,b, dbgPrimaryBPP);
                    }
                }

                // move over to the next 4x4 block
                pFB += (4 << dwFBIndexShift);

            }  // u

        }  // v

    }

    else {  // !DXT

        // check for palettized surfaces
        if (pTexture->isPalettized()) {
            nvAssert (pTexture->getWrapper());
            if (pTexture->getWrapper()->getPalette()) {
                nvAssert (pTexture->getWrapper()->getPalette()->getPaletteSurface());
                pPalette = (PBYTE)(pTexture->getWrapper()->getPalette()->getPaletteSurface()->getAddress());
            } else {
                DPF("preview texture does not yet have a palette (normal if previewing from blit)");
                return;
            }
        }
        else if (pTexture->hasAutoPalette()) {
            pPalette = (PBYTE)(pTexture->getAutoPaletteOffset() +
                       pTexture->getSwizzled()->getAddress() -
                       pTexture->getSwizzled()->getOffset());
        }

        for (v=0; v < dwTexHeight; v++) {

            V_INTERLEAVE (v0, v, dwTexWidth, dwTexHeight);

            for (u=0; u < dwTexWidth; u++) {

                U_INTERLEAVE (u0, u, dwTexWidth, dwTexHeight);

                if (bLinear) {
                    pTexel = pTextureBase + (v * dwTexPitch) + (u << dwTexIndexShift);
                }
                else {
                    dwTexelIndex = u0 | v0;
                    pTexel = pTextureBase + (dwTexelIndex << dwTexIndexShift);
                }

                switch (pTexture->getFormat()) {

                    case NV_SURFACE_FORMAT_A1R5G5B5:

                        a = (BYTE)((*(WORD*)pTexel >> 8) & 0x80);
                        r = (BYTE)((*(WORD*)pTexel >> 7) & 0xf8);
                        g = (BYTE)((*(WORD*)pTexel >> 2) & 0xf8);
                        b = (BYTE)((*(WORD*)pTexel << 3) & 0xf8);
                        break;

                    case NV_SURFACE_FORMAT_X1R5G5B5:

                        a = (BYTE)(0xFF);
                        r = (BYTE)((*(WORD*)pTexel >> 7) & 0xf8);
                        g = (BYTE)((*(WORD*)pTexel >> 2) & 0xf8);
                        b = (BYTE)((*(WORD*)pTexel << 3) & 0xf8);
                        break;

                    case NV_SURFACE_FORMAT_A4R4G4B4:

                        a = (BYTE)((*(WORD*)pTexel >> 8) & 0xf0);
                        r = (BYTE)((*(WORD*)pTexel >> 4) & 0xf0);
                        g = (BYTE)((*(WORD*)pTexel >> 0) & 0xf0);
                        b = (BYTE)((*(WORD*)pTexel << 4) & 0xf0);
                        break;

                    case NV_SURFACE_FORMAT_R5G6B5:

                        a = (BYTE)(0xFF);
                        r = (BYTE)((*(WORD*)pTexel >> 8) & 0xf8);
                        g = (BYTE)((*(WORD*)pTexel >> 3) & 0xfc);
                        b = (BYTE)((*(WORD*)pTexel << 3) & 0xf8);
                        break;

                    case NV_SURFACE_FORMAT_A8R8G8B8:

                        a = (BYTE)((*(DWORD*)pTexel >> 24) & 0xff);
                        r = (BYTE)((*(DWORD*)pTexel >> 16) & 0xff);
                        g = (BYTE)((*(DWORD*)pTexel >>  8) & 0xff);
                        b = (BYTE)((*(DWORD*)pTexel >>  0) & 0xff);
                        break;

                    case NV_SURFACE_FORMAT_X8R8G8B8:

                        a = (BYTE)(0xFF);
                        r = (BYTE)((*(DWORD*)pTexel >> 16) & 0xff);
                        g = (BYTE)((*(DWORD*)pTexel >>  8) & 0xff);
                        b = (BYTE)((*(DWORD*)pTexel >>  0) & 0xff);
                        break;

                    case NV_SURFACE_FORMAT_DV8DU8:

                        a = (BYTE)(0xFF);
                        r = (BYTE)(0);
                        g = (BYTE)((*(WORD*)pTexel >> 8) & 0xff);
                        b = (BYTE)((*(WORD*)pTexel >> 0) & 0xff);
                        break;

                    case NV_SURFACE_FORMAT_L6DV5DU5:

                        a = (BYTE)(0xFF);
                        r = (BYTE)((*(WORD*)pTexel >> 8) & 0xfc);
                        g = (BYTE)((*(WORD*)pTexel >> 2) & 0xf8);
                        b = (BYTE)((*(WORD*)pTexel << 3) & 0xf8);
                        break;

                    case NV_SURFACE_FORMAT_X8L8DV8DU8:

                        a = (BYTE)(0xFF);
                        r = (BYTE)((*(DWORD*)pTexel >> 16) & 0xff);
                        g = (BYTE)((*(DWORD*)pTexel >>  8) & 0xff);
                        b = (BYTE)((*(DWORD*)pTexel >>  0) & 0xff);
                        break;

                    case NV_SURFACE_FORMAT_I8_A8R8G8B8:

                        nvAssert(pPalette);
                        dwColors = ((DWORD *)pPalette)[*pTexel];
                        a = (BYTE)((dwColors >> 24) & 0xff);
                        r = (BYTE)((dwColors >> 16) & 0xff);
                        g = (BYTE)((dwColors >>  8) & 0xff);
                        b = (BYTE)((dwColors >>  0) & 0xff);
                        break;

                    default:

                        DPF ("unhandled texture format in dbgTextureDisplay");
                        dbgD3DError();
                        return;
                        break;

                }  // switch

                if (dbgTexturePreview & NVDBG_TEXTURE_PREVIEW_ALPHA) r=g=b=a;
                if (a) dwNonZeroAlphaCount++;

                SETPIXEL2 (pFB+(u<<dwFBIndexShift), a,r,g,b, dbgPrimaryBPP);

            }  // loop on u

            pFB += dbgPrimaryPitch;

        }  // loop on v

    }  // !DXT

    if (pTexture->hasAlpha()) {
        if (dwNonZeroAlphaCount) {
            DPF_LEVEL (NVDBG_LEVEL_INFO, "dbgTextureDisplay - Non Zero Alpha Count = %08x of %08x",
                       dwNonZeroAlphaCount, dwTexWidth * dwTexHeight);
        }
        else {
            DPF_LEVEL (NVDBG_LEVEL_INFO, "dbgTextureDisplay - alpha texture has no alpha!!!!");
        }
    }
}

//---------------------------------------------------------------------------

void dbgTextureDisplay
(
    CTexture *pTexture
)
{
    CNvObject *pNvObjA, *pNvObjB;
    DWORD      dwX, dwY;
    DWORD      dwClearColor;

    nvAssert (pTexture);

    if (dbgTexturePreview & NVDBG_TEXTURE_PREVIEW_CUBE) {

        dwClearColor = (DWORD)(0xffffffff * ((double)rand() / RAND_MAX));
        dwX = 0;
        pNvObjB = pTexture->getWrapper();
        while (pNvObjB) {
            if (dbgTexturePreview & NVDBG_TEXTURE_PREVIEW_MIP) {
                dwY = 0;
                pNvObjA = pNvObjB;
                while (pNvObjA) {
                    dbgTextureDisplayLevel (pNvObjA->getTexture(), dwX, dwY, dwClearColor);
                    dwY += pNvObjA->getTexture()->getLogicalHeight();
                    pNvObjA = pNvObjA->getAttachedA();
                }
            }
            else {
                dbgTextureDisplayLevel (pNvObjB->getTexture(), dwX, 0, dwClearColor);
            }
            dwX += pNvObjB->getTexture()->getLogicalWidth();
            pNvObjB = pNvObjB->getAttachedB();
            dwClearColor = (DWORD)(0xffffffff * ((double)rand() / RAND_MAX));
        }

    }

    else if (dbgTexturePreview & NVDBG_TEXTURE_PREVIEW_MIP) {

        dwClearColor = (DWORD)(0xffffffff * ((double)rand() / RAND_MAX));
        dwY = 0;
        pNvObjA = pTexture->getWrapper();
        while (pNvObjA) {
            dbgTextureDisplayLevel (pNvObjA->getTexture(), 0, dwY, dwClearColor);
            dwY += pNvObjA->getTexture()->getLogicalHeight();
            pNvObjA = pNvObjA->getAttachedA();
        }

    }

    else if (dbgTexturePreview & NVDBG_TEXTURE_PREVIEW_BASE) {

        dwClearColor = (DWORD)(0xffffffff * ((double)rand() / RAND_MAX));
        dbgTextureDisplayLevel (pTexture, 0, 0, dwClearColor);

    }
}

#endif  // DEBUG

//-------------------------------------------------------------------------
// FRONT RENDERING
//-------------------------------------------------------------------------

#ifdef DEBUG

void dbgSetFrontRenderTarget (PNVD3DCONTEXT pContext, CSimpleSurface *pSurfaceToMimic)
{
    if (dbgFrontRender) {
        if (!pSurfaceToMimic->getWrapper()->getTexture()) {  // don't try to co-opt texture rendering
            dbgFrontRenderSurface.disown();
            dbgFrontRenderSurface.own (VIDMEM_ADDR(pDriverData->CurrentVisibleSurfaceAddress),
                                       dbgPrimaryPitch,
                                       pSurfaceToMimic->getHeight(),
                                       CSimpleSurface::HEAP_VID, FALSE);
            dbgFrontRenderSurface.setFormat (pSurfaceToMimic->getFormat());
            dbgFrontRenderSurface.setWidth (pSurfaceToMimic->getWidth());
            dbgFrontRenderSurface.setBPP (pSurfaceToMimic->getBPP());
            dbgFrontRenderSurface.setBPPRequested (pSurfaceToMimic->getBPPRequested());
            dbgFrontRenderSurface.setWrapper (pSurfaceToMimic->getWrapper());
            pContext->pRenderTarget = &(dbgFrontRenderSurface);
        }
    }
}

#endif // DEBUG

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\d3dMini.cpp ===
/*
 * Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: d3dMini.cpp                                                       *
*   The Direct3D HAL driver routines are implemented in this module.        *
*   This file is a hardware independant file.                               *
*   DO NOT PUT HARDWARE SPECIFIC CODE IN THIS FILE                          *
*   Hardware specific code can be found in:                                 *
*   nv3mini.c, nv4mini.c, ...                                               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/02/97 - re-wrote and cleaned up.     *
*       Charles Inman               01/31/98 - Ported for NV4               *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

/*
 * Direct3D HAL Callback Table.
 */
static D3DHAL_CALLBACKS NvD3DHALCallbacks =
{
    sizeof(D3DHAL_CALLBACKS),
    /*
     * Device context
     */
    nvContextCreate,            /* Required. */
    nvContextDestroy,           /* Required. */
    nvContextDestroyAll,        /* Required. */
    /*
     * Scene capture
     */
    nvSceneCapture,             /* Optional. */
    /*
     * Execution
     */
    0,                          /* Optional. Not needed if only rasterization */
    0,
#ifdef WINNT                    // must be at least DX7 and these calls are therefore obsolete
    0L,
    0L,
#else
    nvRenderState,              /* Required if no Execute */
    nvRenderPrimitive,          /* Required if no Execute */
#endif
    0L,                         /* Reserved, must be zero */
    /*
     * Textures
     */
    nvTextureCreate,            /* If any of these calls are supported, */
    nvTextureDestroy,           /* they must all be. */
    nvTextureSwap,              /* ditto - but can always fail. */
    nvTextureGetSurf,           /* ditto - but can always fail. */
    /*
     * Transform - must be supported if lighting is supported.
     */
    0,                          /* If any of these calls are supported, */
    0,                          /* they must all be. */
    0,                          /* ditto */
    0,                          /* ditto */
    0,                          /* ditto */
    /*
     * Lighting
     */
    0,                          /* If any of these calls are supported, */
    0,                          /* they must all be. */
    0,                          /* ditto */
    0,                          /* ditto */
    0,                          /* ditto */
    /*
     * Pipeline state
     */
#ifdef WINNT                    // must be at least DX7 and these calls are therefore obsolete
    0,
#else
    nvGetState,                 /* Required if implementing Execute. */
#endif // !WINNT
    /*
     * Reserved
     */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
    0L,                         /* Reserved, must be zero */
};

/*
 * Define supported vertex buffer callbacks
 */
static DDHAL_DDEXEBUFCALLBACKS NvD3DBufCallbacks =
{
    sizeof(DDHAL_DDEXEBUFCALLBACKS),
    0x1F,       // hardcoded to all, runtime doesn't even check, so it doesn't REALLY matter
    D3DCanCreateExecuteBuffer32,
    D3DCreateExecuteBuffer32,
    D3DDestroyExecuteBuffer32,
    D3DLockExecuteBuffer32,
    D3DUnlockExecuteBuffer32,
};

#ifndef TEXFORMAT_CRD

/*
 * Define supported texture formats.
 */
static DDSURFACEDESC Nv4TextureFormats[] =
{
    NV4_TEXTURE_FORMATS             // Texture formats defined in NVTEXFMTS.H
};

static DDSURFACEDESC celsiusTextureFormats[] =
{
    CELSIUS_TEXTURE_FORMATS         // Texture formats defined in NVTEXFMTS.H
};
static DDSURFACEDESC celsiusTextureFormatsNoDXT[] =
{
    CELSIUS_TEXTURE_FORMATS_NO_DXT  // Texture formats defined in NVTEXFMTS.H
};

#if (NVARCH >= 0x020)
static DDSURFACEDESC kelvinTextureFormats[] =
{
    KELVIN_TEXTURE_FORMATS         // Texture formats defined in NVTEXFMTS.H
};

static DDSURFACEDESC kelvinTextureFormatsNoDXT[] =
{
    KELVIN_TEXTURE_FORMATS_NO_DXT  // Texture formats defined in NVTEXFMTS.H
};
#endif // (NVARCH >= 0x020)

#endif  // !TEXFORMAT_CRD

/*
 * --------------------------------------------------------------------------
 *  Direct 3D HAL driver creation routines.
 *  Functions used to instantiate the 3D portion of the DirectDraw HAL
 *  Will be called (for example) from invokeCreateDriver() from ddsamp.
 *
 *  D3DHALCreateDriver
 *
 *  LPD3DHAL_GLOBALDRIVERDATA lpGlobal
 *      - A pointer to a structure containing alot of global information about
 *        our driver.
 *
 *  LPD3DHAL_CALLBACKS* lplpHALCallbacks
 *      - A pointer to a structure we fill in with the callbacks that this
 *        driver supports.
 * --------------------------------------------------------------------------
 */
BOOL __stdcall D3DHALCreateDriver
(
    LPD3DHAL_GLOBALDRIVERDATA  lpGlobal,
    LPD3DHAL_CALLBACKS         *lplpHALCallbacks,
    LPDDHAL_DDEXEBUFCALLBACKS  *lplpBufCallbacks,
    GLOBALDATA                 *pDriverData
)
{
    /*
     * check if driver is valid
     */
    {
        extern BYTE bDeveloperID[32 + 32];
        DWORD i,c;

        for (i = 32,c = 0; i < 64; i++)
        {
            if ((i & 7) == 7)
            {
                c ^= 0x42;
                if ((c ^ bDeveloperID[i]) & 0xfe)
                {
                    DPF_LEVEL (NVDBG_LEVEL_ERROR, "Invalid Driver ID");
                    return FALSE;
                }
                c = 0;
            }
            else
            {
                c ^= bDeveloperID[i];
            }
        }
    }

    // create context tables
    if (!CreateItemArrays(pDriverData))
    {
        DPF_LEVEL (NVDBG_LEVEL_ERROR, "Failed to initialize arrays");
        return FALSE;
    }

    //
    // Here we fill in the supplied structures.
    //
    memset(lpGlobal, 0, sizeof(D3DHAL_GLOBALDRIVERDATA));
    lpGlobal->dwSize              = sizeof(D3DHAL_GLOBALDRIVERDATA);
    lpGlobal->hwCaps              = getDC()->nvD3DDevCaps.dd1Caps;
    lpGlobal->dwNumVertices       = 32768;
    lpGlobal->dwNumClipVertices   = 32768;

#ifdef TEXFORMAT_CRD // --------------------------------

    lpGlobal->dwNumTextureFormats = getDC()->dwSurfaceDescriptorCount;
    lpGlobal->lpTextureFormats    = getDC()->pSurfaceDescriptors;

#else  // !TEXFORMAT_CRD // --------------------------------

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)
    {
#ifdef DXT_SUPPORT
        if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_TEXTURECOMPRESSIONENABLE_MASK) == D3D_REG_TEXTURECOMPRESSIONENABLE_ENABLE) {
            lpGlobal->dwNumTextureFormats = sizeof(kelvinTextureFormats) / sizeof(DDSURFACEDESC);
            lpGlobal->lpTextureFormats    = &kelvinTextureFormats[0];
        }
        else
#endif  // DXT_SUPPORT
        {
            lpGlobal->dwNumTextureFormats = sizeof(kelvinTextureFormatsNoDXT) / sizeof(DDSURFACEDESC);
            lpGlobal->lpTextureFormats    = &kelvinTextureFormatsNoDXT[0];
        }
    }
    else
#endif  // NVARCH >= 0x020
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS)
    {
#ifdef DXT_SUPPORT
        if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_TEXTURECOMPRESSIONENABLE_MASK) == D3D_REG_TEXTURECOMPRESSIONENABLE_ENABLE) {
            lpGlobal->dwNumTextureFormats = sizeof(celsiusTextureFormats) / sizeof(DDSURFACEDESC);
            lpGlobal->lpTextureFormats    = &celsiusTextureFormats[0];
        }
        else
#endif  // DXT_SUPPORT
        {
            lpGlobal->dwNumTextureFormats = sizeof(celsiusTextureFormatsNoDXT) / sizeof(DDSURFACEDESC);
            lpGlobal->lpTextureFormats    = &celsiusTextureFormatsNoDXT[0];
        }
    }
    else
#endif (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_DXTRI) {
        lpGlobal->dwNumTextureFormats = sizeof(Nv4TextureFormats) / sizeof(DDSURFACEDESC);
        lpGlobal->lpTextureFormats    = &Nv4TextureFormats[0];
    }
    else {
        DPF("Unknown architecture");
        dbgD3DError();
        lpGlobal->dwNumTextureFormats = sizeof(Nv4TextureFormats) / sizeof(DDSURFACEDESC);
        lpGlobal->lpTextureFormats    = &Nv4TextureFormats[0];
    }

#endif  // !TEXFORMAT_CRD --------------------------------

    /*
     * Modify the capabilities as neccessary for the registry settings.
     */
    D3DModifyCapabilities(lpGlobal, pDriverData);

    /*
     * Return the HAL table.
     */
    *lplpHALCallbacks = &NvD3DHALCallbacks;
#ifndef DO_NOT_SUPPORT_VERTEX_BUFFERS // see nvprecomp.h
    if (
#if (NVARCH >= 0x020)
        (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) ||
#endif // (NVARCH >= 0x020)
        (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS)
       )
    {

        *lplpBufCallbacks = &NvD3DBufCallbacks;
    }
    else
#endif
    {
        *lplpBufCallbacks = NULL;
    }
    return (TRUE);
}

/*
 * --------------------------------------------------------------------------
 * Initialization routines.
 * --------------------------------------------------------------------------
 */

/*
 * This routine creates the various dynamic item arrays used by the Direct3D
 * driver for managing contexts and textures. This routine should be called
 * at DLL_PROCESS_ATTACH time from DllMain.
 */
BOOL CreateItemArrays
(
    GLOBALDATA *pDriverData
)
{
    /*
     * Initialize memory system.
     */
    if (!DDrvItemArrayInit())
    {
        DPF_LEVEL (NVDBG_LEVEL_ERROR, "CreateItemArrays - Failed to initialize memory subsystem");
        return (FALSE);
    }

    /*
     * Create the D3D context heap.
     */
    if (!nvCreateContextListHeap(pDriverData))
        return (FALSE);

    /*
     * done
     */
    return (TRUE);
}

/*
 * --------------------------------------------------------------------------
 * Termination routines.
 * --------------------------------------------------------------------------
 */

/*
 * This routine destroys the various dynamic item arrays used by the
 * Direct3D driver for managing contexts and textures. This routine should
 * be called at DLL_PROCESS_DETACH time from DllMain.
 */
BOOL DestroyItemArrays
(
    void
)
{
    // Cleanup the D3D context heap.
    nvDestroyContextListHeap();

    // Cleanup memory.
    return (DDrvItemArrayFini());
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\d3dMath.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/********************************* Direct 3D *******************************\
*                                                                           *
* Module: d3dMath.cpp                                                       *
*     matrix, vector, and other math routines                               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler    (bertrem)   09Sep99     created                 *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

#include "x86.h"

//---------------------------------------------------------------------------

// returns  1 / sqrt(x)

static float _0_47 = 0.47f;
static float _1_47 = 1.47f;

float __fastcall JBInvSqrt (const float x)
{
    DWORD y;
    float r;

    _asm
    {
        mov     eax, 07F000000h+03F800000h  // (ONE_AS_INTEGER<<1) + ONE_AS_INTEGER
        sub     eax, x
        sar     eax, 1

        mov     y, eax                      // y
        fld     _0_47                       // 0.47
        fmul    DWORD PTR x                 // x*0.47

        fld     DWORD PTR y
        fld     st(0)                       // y y x*0.47
        fmul    st(0), st(1)                // y*y y x*0.47

        fld     _1_47                       // 1.47 y*y y x*0.47
        fxch    st(3)                       // x*0.47 y*y y 1.47
        fmulp   st(1), st(0)                // x*0.47*y*y y 1.47
        fsubp   st(2), st(0)                // y 1.47-x*0.47*y*y
        fmulp   st(1), st(0)                // result
        fstp    y
    }

    y &= 0x7FFFFFFF;  // make it positive
    r = FLOAT_FROM_DWORD(y);

    // optional
    r = (3.0f - x * (r * r)) * r * 0.5f;    // remove for low accuracy

    return (r);
}

//---------------------------------------------------------------------------

//  sqrt(x) = x * (1/sqrt(x))

float __fastcall nvSqrt (float x)
{
    return (x*JBInvSqrt(x));
}

//---------------------------------------------------------------------------

//  1/x = 1 / sqrt(x*x) plus sign bit

float __fastcall nvInv (float x)
{
    DWORD dwSign = *(DWORD *)&x & 0x80000000;
    float invSqRt = JBInvSqrt (x*x);
    DWORD dwInv = dwSign | *(DWORD *)&invSqRt;
    return (FLOAT_FROM_DWORD(dwInv));
}

//---------------------------------------------------------------------------

// reverse a 3-component vector

void __fastcall ReverseVector3 (D3DVECTOR *out, D3DVECTOR *in)
{
    out->x = -(in->x);
    out->y = -(in->y);
    out->z = -(in->z);
}

//---------------------------------------------------------------------------

// scale a 3-component vector

void __fastcall ScaleVector3 (D3DVECTOR *out, D3DVECTOR *v1, D3DVALUE scale)
{
    out->x = scale * v1->x;
    out->y = scale * v1->y;
    out->z = scale * v1->z;
}

//---------------------------------------------------------------------------

// add two 3-component vectors

void __fastcall AddVectors3 (D3DVECTOR *out, D3DVECTOR *v1, D3DVECTOR *v2)
{
    out->x = v1->x + v2->x;
    out->y = v1->y + v2->y;
    out->z = v1->z + v2->z;
}

//---------------------------------------------------------------------------

// subtract two 3-component vectors

void __fastcall SubtractVectors3 (D3DVECTOR *out, D3DVECTOR *v1, D3DVECTOR *v2)
{
    out->x = v1->x - v2->x;
    out->y = v1->y - v2->y;
    out->z = v1->z - v2->z;
}

//---------------------------------------------------------------------------

// return the square of the magnitude of a 3-component vectors

D3DVALUE __fastcall SquareMagnitude3 (D3DVECTOR *v)
{
    return (v->x*v->x + v->y*v->y + v->z*v->z);
}

//---------------------------------------------------------------------------

// return the magnitude of a 3-component vector

D3DVALUE __fastcall Magnitude3 (D3DVECTOR *v)
{
    return (D3DVALUE) nvSqrt(SquareMagnitude3(v));
}

//---------------------------------------------------------------------------

// normalize a 3-component vector

void __fastcall NormalizeVector3 (D3DVECTOR *v)
{
    D3DVALUE invmag = JBInvSqrt (SquareMagnitude3(v));
    nvAssert (invmag > 0);
    v->x *= invmag;
    v->y *= invmag;
    v->z *= invmag;
}

//---------------------------------------------------------------------------

// dot product of a 3-component vector

D3DVALUE __fastcall DotProduct3 (D3DVECTOR *v1, D3DVECTOR *v2)
{
    return (v1->x*v2->x + v1->y*v2->y + v1->z*v2->z);
}

//---------------------------------------------------------------------------

// Multiplies row vector [v.x v.y v.z w] by 4x3 matrix m
// res and v should not be the same

void __fastcall XformBy4x3 (D3DVECTOR *res, D3DVECTOR *v, D3DVALUE w, D3DMATRIX *m)
{
    nvAssert (res != v);
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + w*m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + w*m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + w*m->_43;
}

//---------------------------------------------------------------------------

// Multiplies vector (x,y,z) by 3x3 matrix
// res and v should not be the same

void __fastcall XformVector3 (D3DVECTOR *res, D3DVECTOR *v, D3DMATRIX *m)
{
    nvAssert (res != v);
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33;
}

//---------------------------------------------------------------------------

// Multiplies vector (x,y,z,w) by 4x4 matrix
// res and v should not be the same

void __fastcall XformVector4 (D3DVALUE *res, D3DVALUE *v, D3DMATRIX *m)
{
    nvAssert (res != v);
    res[0] = v[0]*m->_11 + v[1]*m->_21 + v[2]*m->_31 + v[3]*m->_41;
    res[1] = v[0]*m->_12 + v[1]*m->_22 + v[2]*m->_32 + v[3]*m->_42;
    res[2] = v[0]*m->_13 + v[1]*m->_23 + v[2]*m->_33 + v[3]*m->_43;
    res[3] = v[0]*m->_14 + v[1]*m->_24 + v[2]*m->_34 + v[3]*m->_44;
}

//---------------------------------------------------------------------------

void __fastcall MatrixProduct3x3 (D3DMATRIX *res, D3DMATRIX *a, D3DMATRIX *b)
{
    res->_11 = a->_11*b->_11 + a->_12*b->_21 + a->_13*b->_31;
    res->_12 = a->_11*b->_12 + a->_12*b->_22 + a->_13*b->_32;
    res->_13 = a->_11*b->_13 + a->_12*b->_23 + a->_13*b->_33;

    res->_21 = a->_21*b->_11 + a->_22*b->_21 + a->_23*b->_31;
    res->_22 = a->_21*b->_12 + a->_22*b->_22 + a->_23*b->_32;
    res->_23 = a->_21*b->_13 + a->_22*b->_23 + a->_23*b->_33;

    res->_31 = a->_31*b->_11 + a->_32*b->_21 + a->_33*b->_31;
    res->_32 = a->_31*b->_12 + a->_32*b->_22 + a->_33*b->_32;
    res->_33 = a->_31*b->_13 + a->_32*b->_23 + a->_33*b->_33;
}

//---------------------------------------------------------------------------

void __fastcall MatrixProduct4x4 (D3DMATRIX *res, D3DMATRIX *a, D3DMATRIX *b)
{
    res->_11 = a->_11*b->_11 + a->_12*b->_21 + a->_13*b->_31 + a->_14*b->_41;
    res->_12 = a->_11*b->_12 + a->_12*b->_22 + a->_13*b->_32 + a->_14*b->_42;
    res->_13 = a->_11*b->_13 + a->_12*b->_23 + a->_13*b->_33 + a->_14*b->_43;
    res->_14 = a->_11*b->_14 + a->_12*b->_24 + a->_13*b->_34 + a->_14*b->_44;

    res->_21 = a->_21*b->_11 + a->_22*b->_21 + a->_23*b->_31 + a->_24*b->_41;
    res->_22 = a->_21*b->_12 + a->_22*b->_22 + a->_23*b->_32 + a->_24*b->_42;
    res->_23 = a->_21*b->_13 + a->_22*b->_23 + a->_23*b->_33 + a->_24*b->_43;
    res->_24 = a->_21*b->_14 + a->_22*b->_24 + a->_23*b->_34 + a->_24*b->_44;

    res->_31 = a->_31*b->_11 + a->_32*b->_21 + a->_33*b->_31 + a->_34*b->_41;
    res->_32 = a->_31*b->_12 + a->_32*b->_22 + a->_33*b->_32 + a->_34*b->_42;
    res->_33 = a->_31*b->_13 + a->_32*b->_23 + a->_33*b->_33 + a->_34*b->_43;
    res->_34 = a->_31*b->_14 + a->_32*b->_24 + a->_33*b->_34 + a->_34*b->_44;

    res->_41 = a->_41*b->_11 + a->_42*b->_21 + a->_43*b->_31 + a->_44*b->_41;
    res->_42 = a->_41*b->_12 + a->_42*b->_22 + a->_43*b->_32 + a->_44*b->_42;
    res->_43 = a->_41*b->_13 + a->_42*b->_23 + a->_43*b->_33 + a->_44*b->_43;
    res->_44 = a->_41*b->_14 + a->_42*b->_24 + a->_43*b->_34 + a->_44*b->_44;
}

//---------------------------------------------------------------------------

// transpose a 4x4 matrix. res and m should not be the same.

void __fastcall MatrixTranspose4x4 (D3DMATRIX *res, D3DMATRIX *m)
{
    assert (res != m);

    res->_11 = m->_11;
    res->_12 = m->_21;
    res->_13 = m->_31;
    res->_14 = m->_41;

    res->_21 = m->_12;
    res->_22 = m->_22;
    res->_23 = m->_32;
    res->_24 = m->_42;

    res->_31 = m->_13;
    res->_32 = m->_23;
    res->_33 = m->_33;
    res->_34 = m->_43;

    res->_41 = m->_14;
    res->_42 = m->_24;
    res->_43 = m->_34;
    res->_44 = m->_44;
}

//---------------------------------------------------------------------------

// This function uses Cramer's Rule to calculate the inverse of a 3x3 matrix
// (or the upper 3x3 portion of a larger matrix)
//
// Returns:
//    0 - if success
//   -1 - if input matrix is singular

#define DETERMINANT(m, r1, r2, c1, c2) (m->_##r1##c1 * m->_##r2##c2 - m->_##r1##c2 * m->_##r2##c1)

int __fastcall Inverse3x3 (D3DMATRIX *inverse, D3DMATRIX *src, BOOL bNormalize)
{
    float b11,b12,b13;
    float b21,b22,b23;
    float b31,b32,b33;
    float det, idet;
    DWORD dwSign;

    b11 =  DETERMINANT(src, 2,3,2,3);
    b12 = -DETERMINANT(src, 2,3,1,3);
    b13 =  DETERMINANT(src, 2,3,1,2);
    b21 = -DETERMINANT(src, 1,3,2,3);
    b22 =  DETERMINANT(src, 1,3,1,3);
    b23 = -DETERMINANT(src, 1,3,1,2);
    b31 =  DETERMINANT(src, 1,2,2,3);
    b32 = -DETERMINANT(src, 1,2,1,3);
    b33 =  DETERMINANT(src, 1,2,1,2);

    // compute 3x3 determinant
    det = (src->_11 * b11) + (src->_12 * b12) + (src->_13 * b13);
    if (det == 0.0) {
        return (-1);
    }

    if (bNormalize) {
        // get the reciprocal of the determinant
        // and multiply all 3x3 cofactors by it
        idet = nvInv (det);
        inverse->_11 = (D3DVALUE) (idet * b11);
        inverse->_12 = (D3DVALUE) (idet * b21);
        inverse->_13 = (D3DVALUE) (idet * b31);
        inverse->_21 = (D3DVALUE) (idet * b12);
        inverse->_22 = (D3DVALUE) (idet * b22);
        inverse->_23 = (D3DVALUE) (idet * b32);
        inverse->_31 = (D3DVALUE) (idet * b13);
        inverse->_32 = (D3DVALUE) (idet * b23);
        inverse->_33 = (D3DVALUE) (idet * b33);
    }

    else {
        // just get the sign of the determinant and multiply all
        // cofactors by that. since we're not normalizing, we don't
        // care about the magnitude, but we do care about the sense.
        dwSign = FP_SIGN_BIT(det);
        DWORD_FROM_FLOAT(b11) ^= dwSign;
        inverse->_11 = (D3DVALUE) (b11);
        DWORD_FROM_FLOAT(b21) ^= dwSign;
        inverse->_12 = (D3DVALUE) (b21);
        DWORD_FROM_FLOAT(b31) ^= dwSign;
        inverse->_13 = (D3DVALUE) (b31);
        DWORD_FROM_FLOAT(b12) ^= dwSign;
        inverse->_21 = (D3DVALUE) (b12);
        DWORD_FROM_FLOAT(b22) ^= dwSign;
        inverse->_22 = (D3DVALUE) (b22);
        DWORD_FROM_FLOAT(b32) ^= dwSign;
        inverse->_23 = (D3DVALUE) (b32);
        DWORD_FROM_FLOAT(b13) ^= dwSign;
        inverse->_31 = (D3DVALUE) (b13);
        DWORD_FROM_FLOAT(b23) ^= dwSign;
        inverse->_32 = (D3DVALUE) (b23);
        DWORD_FROM_FLOAT(b33) ^= dwSign;
        inverse->_33 = (D3DVALUE) (b33);
    }

    return (0);
}

//---------------------------------------------------------------------------

// This function uses Cramer's Rule to calculate the matrix inverse.
//
// Returns:
//    0 - if success
//   -1 - if input matrix is singular

int __fastcall Inverse4x4 (D3DMATRIX *inverse, D3DMATRIX *src, BOOL bNormalize)
{
    float x00, x01, x02;
    float x10, x11, x12;
    float x20, x21, x22;
    float x30, x31, x32;
    float rcp;
    float y01, y02, y03, y12, y13, y23;
    float z02, z03, z12, z13, z22, z23, z32, z33;
    DWORD  dwSign;

#define x03 x01
#define x13 x11
#define x23 x21
#define x33 x31
#define z00 x02
#define z10 x12
#define z20 x22
#define z30 x32
#define z01 x03
#define z11 x13
#define z21 x23
#define z31 x33

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all six 2x2 determinants of 1st two columns */
    y01 = x00*x11 - x10*x01;
    y02 = x00*x21 - x20*x01;
    y03 = x00*x31 - x30*x01;
    y12 = x10*x21 - x20*x11;
    y13 = x10*x31 - x30*x11;
    y23 = x20*x31 - x30*x21;

    /* read 2nd two columns of matrix into registers */
    x02 = src->_13;
    x03 = src->_14;
    x12 = src->_23;
    x13 = src->_24;
    x22 = src->_33;
    x23 = src->_34;
    x32 = src->_43;
    x33 = src->_44;

    /* compute all 3x3 cofactors for 2nd two columns */
    z33 = x02*y12 - x12*y02 + x22*y01;
    z23 = x12*y03 - x32*y01 - x02*y13;
    z13 = x02*y23 - x22*y03 + x32*y02;
    z03 = x22*y13 - x32*y12 - x12*y23;
    z32 = x13*y02 - x23*y01 - x03*y12;
    z22 = x03*y13 - x13*y03 + x33*y01;
    z12 = x23*y03 - x33*y02 - x03*y23;
    z02 = x13*y23 - x23*y13 + x33*y12;

    /* compute all six 2x2 determinants of 2nd two columns */
    y01 = x02*x13 - x12*x03;
    y02 = x02*x23 - x22*x03;
    y03 = x02*x33 - x32*x03;
    y12 = x12*x23 - x22*x13;
    y13 = x12*x33 - x32*x13;
    y23 = x22*x33 - x32*x23;

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all 3x3 cofactors for 1st column */
    z30 = x11*y02 - x21*y01 - x01*y12;
    z20 = x01*y13 - x11*y03 + x31*y01;
    z10 = x21*y03 - x31*y02 - x01*y23;
    z00 = x11*y23 - x21*y13 + x31*y12;

    /* compute all 3x3 cofactors for 2nd column */
    z31 = x00*y12 - x10*y02 + x20*y01;
    z21 = x10*y03 - x30*y01 - x00*y13;
    z11 = x00*y23 - x20*y03 + x30*y02;
    z01 = x20*y13 - x30*y12 - x10*y23;

    // compute 4x4 determinant
    rcp = x30*z30 + x20*z20 + x10*z10 + x00*z00;
    if (rcp == 0.f) return (-1);

    if (bNormalize) {
        // get the reciprocal of the determinant
        // and multiply all 3x3 cofactors by it
        rcp = nvInv (rcp);
        inverse->_11 = z00*rcp;
        inverse->_21 = z01*rcp;
        inverse->_12 = z10*rcp;
        inverse->_31 = z02*rcp;
        inverse->_13 = z20*rcp;
        inverse->_41 = z03*rcp;
        inverse->_14 = z30*rcp;
        inverse->_22 = z11*rcp;
        inverse->_32 = z12*rcp;
        inverse->_23 = z21*rcp;
        inverse->_42 = z13*rcp;
        inverse->_24 = z31*rcp;
        inverse->_33 = z22*rcp;
        inverse->_43 = z23*rcp;
        inverse->_34 = z32*rcp;
        inverse->_44 = z33*rcp;
    }

    else {
        // just get the sign of the determinant and multiply all
        // cofactors by that. since we're not normalizing, we don't
        // care about the magnitude, but we do care about the sense.
        dwSign = FP_SIGN_BIT(rcp);
        DWORD_FROM_FLOAT(z00) ^= dwSign;
        inverse->_11 = z00;
        DWORD_FROM_FLOAT(z01) ^= dwSign;
        inverse->_21 = z01;
        DWORD_FROM_FLOAT(z10) ^= dwSign;
        inverse->_12 = z10;
        DWORD_FROM_FLOAT(z02) ^= dwSign;
        inverse->_31 = z02;
        DWORD_FROM_FLOAT(z20) ^= dwSign;
        inverse->_13 = z20;
        DWORD_FROM_FLOAT(z03) ^= dwSign;
        inverse->_41 = z03;
        DWORD_FROM_FLOAT(z30) ^= dwSign;
        inverse->_14 = z30;
        DWORD_FROM_FLOAT(z11) ^= dwSign;
        inverse->_22 = z11;
        DWORD_FROM_FLOAT(z12) ^= dwSign;
        inverse->_32 = z12;
        DWORD_FROM_FLOAT(z21) ^= dwSign;
        inverse->_23 = z21;
        DWORD_FROM_FLOAT(z13) ^= dwSign;
        inverse->_42 = z13;
        DWORD_FROM_FLOAT(z31) ^= dwSign;
        inverse->_24 = z31;
        DWORD_FROM_FLOAT(z22) ^= dwSign;
        inverse->_33 = z22;
        DWORD_FROM_FLOAT(z23) ^= dwSign;
        inverse->_43 = z23;
        DWORD_FROM_FLOAT(z32) ^= dwSign;
        inverse->_34 = z32;
        DWORD_FROM_FLOAT(z33) ^= dwSign;
        inverse->_44 = z33;
    }

    return (0);

#undef x03
#undef x13
#undef x23
#undef x33
#undef z00
#undef z10
#undef z20
#undef z30
#undef z01
#undef z11
#undef z21
#undef z31

}

// More accurate matrix inversion. The reciprocal of the determinant computed by Inverse4x4
// is often really, really bad.
int __fastcall STInverse4x4 (D3DMATRIX *inverse, D3DMATRIX *src)
{
    float x00, x01, x02;
    float x10, x11, x12;
    float x20, x21, x22;
    float x30, x31, x32;
    float rcp;
    float y01, y02, y03, y12, y13, y23;
    float z02, z03, z12, z13, z22, z23, z32, z33;

#define x03 x01
#define x13 x11
#define x23 x21
#define x33 x31
#define z00 x02
#define z10 x12
#define z20 x22
#define z30 x32
#define z01 x03
#define z11 x13
#define z21 x23
#define z31 x33

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all six 2x2 determinants of 1st two columns */
    y01 = x00*x11 - x10*x01;
    y02 = x00*x21 - x20*x01;
    y03 = x00*x31 - x30*x01;
    y12 = x10*x21 - x20*x11;
    y13 = x10*x31 - x30*x11;
    y23 = x20*x31 - x30*x21;

    /* read 2nd two columns of matrix into registers */
    x02 = src->_13;
    x03 = src->_14;
    x12 = src->_23;
    x13 = src->_24;
    x22 = src->_33;
    x23 = src->_34;
    x32 = src->_43;
    x33 = src->_44;

    /* compute all 3x3 cofactors for 2nd two columns */
    z33 = x02*y12 - x12*y02 + x22*y01;
    z23 = x12*y03 - x32*y01 - x02*y13;
    z13 = x02*y23 - x22*y03 + x32*y02;
    z03 = x22*y13 - x32*y12 - x12*y23;
    z32 = x13*y02 - x23*y01 - x03*y12;
    z22 = x03*y13 - x13*y03 + x33*y01;
    z12 = x23*y03 - x33*y02 - x03*y23;
    z02 = x13*y23 - x23*y13 + x33*y12;

    /* compute all six 2x2 determinants of 2nd two columns */
    y01 = x02*x13 - x12*x03;
    y02 = x02*x23 - x22*x03;
    y03 = x02*x33 - x32*x03;
    y12 = x12*x23 - x22*x13;
    y13 = x12*x33 - x32*x13;
    y23 = x22*x33 - x32*x23;

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all 3x3 cofactors for 1st column */
    z30 = x11*y02 - x21*y01 - x01*y12;
    z20 = x01*y13 - x11*y03 + x31*y01;
    z10 = x21*y03 - x31*y02 - x01*y23;
    z00 = x11*y23 - x21*y13 + x31*y12;

    /* compute all 3x3 cofactors for 2nd column */
    z31 = x00*y12 - x10*y02 + x20*y01;
    z21 = x10*y03 - x30*y01 - x00*y13;
    z11 = x00*y23 - x20*y03 + x30*y02;
    z01 = x20*y13 - x30*y12 - x10*y23;

    // compute 4x4 determinant
    rcp = x30*z30 + x20*z20 + x10*z10 + x00*z00;
    if (rcp == 0.f) return (-1);

    // get the reciprocal of the determinant
    // and multiply all 3x3 cofactors by it
    rcp = 1.0f / rcp;
    inverse->_11 = z00*rcp;
    inverse->_21 = z01*rcp;
    inverse->_12 = z10*rcp;
    inverse->_31 = z02*rcp;
    inverse->_13 = z20*rcp;
    inverse->_41 = z03*rcp;
    inverse->_14 = z30*rcp;
    inverse->_22 = z11*rcp;
    inverse->_32 = z12*rcp;
    inverse->_23 = z21*rcp;
    inverse->_42 = z13*rcp;
    inverse->_24 = z31*rcp;
    inverse->_33 = z22*rcp;
    inverse->_43 = z23*rcp;
    inverse->_34 = z32*rcp;
    inverse->_44 = z33*rcp;

    return (0);

#undef x03
#undef x13
#undef x23
#undef x33
#undef z00
#undef z10
#undef z20
#undef z30
#undef z01
#undef z11
#undef z21
#undef z31

}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// helper routines ///////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

void nvComputeBoundingBox
(
    BYTE  *pVertices,
    DWORD  dwCount,
    DWORD  dwVertexStride,
    float *pafMinMaxInfo        // 6 floats, x,y,z min; x,y,z max
)
{
    if (!dwCount)
    {
        pafMinMaxInfo[0] = pafMinMaxInfo[1]
                         = pafMinMaxInfo[2]
                         = pafMinMaxInfo[3]
                         = pafMinMaxInfo[4]
                         = pafMinMaxInfo[5]
                         = 0.0f;
        return;
    }

    //
    // todo - use SIMD for AMD and KNI
    //
    pafMinMaxInfo[0] = +1e37f;
    pafMinMaxInfo[1] = +1e37f;
    pafMinMaxInfo[2] = +1e37f;
    pafMinMaxInfo[3] = -1e37f;
    pafMinMaxInfo[4] = -1e37f;
    pafMinMaxInfo[5] = -1e37f;
    while (dwCount)
    {
        float x = *(float*)(pVertices + 0);
        float y = *(float*)(pVertices + 4);
        float z = *(float*)(pVertices + 8);

        if (x < pafMinMaxInfo[0]) pafMinMaxInfo[0] = x;
        if (y < pafMinMaxInfo[1]) pafMinMaxInfo[1] = y;
        if (z < pafMinMaxInfo[2]) pafMinMaxInfo[2] = z;

        if (x > pafMinMaxInfo[3]) pafMinMaxInfo[3] = x;
        if (y > pafMinMaxInfo[4]) pafMinMaxInfo[4] = y;
        if (z > pafMinMaxInfo[5]) pafMinMaxInfo[5] = z;

        pVertices += dwVertexStride;
        dwCount--;
    }
}

//////////////////////////////////////////////////////////////////////////////

#define X pfVerticesOut[0]
#define Y pfVerticesOut[1]
#define Z pfVerticesOut[2]
#define W pfVerticesOut[3]

void nvComputeXfmAndOutCodes
(
    D3DMATRIX *pXfm,
    float     *pfVerticesIn,
    float     *pfVerticesOut,
    DWORD      dwCount,
    DWORD     *pdwOutCodes
)
{
    //
    // todo - use SIMD for AMD and KNI
    //
    while (dwCount)
    {
        // xfm
        XformVector4 (pfVerticesOut,pfVerticesIn,pXfm);

        // outcodes
        DWORD dwOutCode = 0;
        if (X < -W) dwOutCode |= 1;
        if (X >  W) dwOutCode |= 2;
        if (Y < -W) dwOutCode |= 4;
        if (Y >  W) dwOutCode |= 8;
        if (Z <  0) dwOutCode |= 16;
        if (Z >  W) dwOutCode |= 32;
        *pdwOutCodes = dwOutCode;

        // next
        pfVerticesIn  += 4;
        pfVerticesOut += 4;
        pdwOutCodes   ++;
        dwCount       --;
    }
}

#undef X
#undef Y
#undef Z
#undef W

//////////////////////////////////////////////////////////////////////////////


#endif  // (NVARCH >= 0x04)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\d3dState.cpp ===
/*
 * Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: d3dState.cpp                                                      *
*   The Direct3D state routines.                                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/02/97 - re-wrote and cleaned up.     *
*                                                                           *
\***************************************************************************/

#include "nvprecomp.h"
#if (NVARCH >= 0x04)


//-------------------------------------------------------------------------

#ifndef WINNT  // these calls are obsolete on NT (DX7)

DWORD __stdcall nvGetState
(
    LPD3DHAL_GETSTATEDATA pgsd
)
{
    /*
     * NOTES:
     * This callback is called when Direct3D requires information about
     * the state of a particular stage in the pipeline. If you only handle
     * rasterisation then you only need to respond to D3DHALSTATE_GET_RENDER
     * calls.
     * The state wanted is in pgsd->ddState.drstRenderStateType.
     * Return the answer in pgsd->ddState.dwArg[0].
     */
    if (!pgsd->dwhContext)
    {
        pgsd->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }
    if (pgsd->dwWhich != D3DHALSTATE_GET_RENDER)
    {
        pgsd->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }
    pgsd->ddState.dwArg[0] = 1;
    pgsd->ddrval           = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
}

#endif  // !WINNT

//remove these defines when they get into the MS runtime.
typedef struct    _D3DDEVINFO_VCACHEPARAM
{
DWORD Pattern; // bit pattern,return value must be FOUR_CC('C', 'A', 'C', 'H')
DWORD OptMethod;//optimization method 0 means longest strips, 1 means vertex cache based
DWORD CacheSize;// cache size to optimize for  (only required if type is 1)
DWORD MagicNumber; // used to determine when to restart strips 
} D3DDEVINFO_VCACHEPARAM;
 
#define D3DDEVINFOID_VCACHEPARAM   4
//end remove


//-------------------------------------------------------------------------
// This fdunction is a general purpose callback.  Almost ANYTHING can be passed
// back and forth.  It is currently used for Vertex Cache information and texture
// management, but is easily extended.


DWORD __stdcall nvGetDriverState
(
    LPDDHAL_GETDRIVERSTATEDATA pgdsd
)
{
    DWORD dwHandled=DDHAL_DRIVER_NOTHANDLED;
    PNVD3DCONTEXT pContext = (PNVD3DCONTEXT)pgdsd->dwhContext;

    dbgTracePush ("nvGetDriverState");
    
    nvSetDriverDataPtrFromContext(pContext);

#if (NVARCH >= 0x010)    
    if (pgdsd->dwFlags == D3DDEVINFOID_VCACHEPARAM && 
        pgdsd->dwLength >= sizeof(D3DDEVINFO_VCACHEPARAM) )
    {
        D3DDEVINFO_VCACHEPARAM *lpVCache = (D3DDEVINFO_VCACHEPARAM *)pgdsd->lpdwStates;

        lpVCache->Pattern = mmioFOURCC('C', 'A', 'C', 'H');
        lpVCache->OptMethod = 1;
        lpVCache->MagicNumber = 7;
#if (NVARCH >= 0x020)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) 
        {
            lpVCache->CacheSize = 16;
        }
        else 
#endif
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) 
        {
            lpVCache->CacheSize = 12;
        }
        pgdsd->ddRVal = DD_OK;
        dwHandled = DDHAL_DRIVER_HANDLED;
    }
#endif
    dbgTracePop();
    DDHAL_EXIT(dwHandled);
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\d3dTex.cpp ===
/*
 * Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 * (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: d3dTex.cpp                                                        *
*   The Direct3D texture routines.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/02/97 - re-wrote and cleaned up.     *
*       Ben de Waal (bdw)           08/28/97 - enabled locked tex status    *
*                                   09/19/97 - optimize mipmap creation     *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

/*
 * --------------------------------------------------------------------------
 * D3D HAL texture callback routines
 * --------------------------------------------------------------------------
 */
DWORD __stdcall nvTextureCreate
(
    LPD3DHAL_TEXTURECREATEDATA  pTextureCreateData
)
{
    dbgTracePush ("nvTextureCreate");

    LPDDRAWI_DDRAWSURFACE_LCL   lpLcl;

    /*
     * NOTES:
     *
     * This callback is invoked when a texture is to be created from a
     *  DirectDrawSurface.
     * We must pass back the created handle.
     */

    /*
     * Get the pointer to the context this texture is associated with.
     */
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pTextureCreateData);

    /*
     * Validate the parameters of the texture being created.
     */
    lpLcl = NvLockTextureSurface(pTextureCreateData);
    if (!lpLcl)
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureCreate - Texture Create Failed");
        dbgD3DError();
        pTextureCreateData->ddrval = D3DERR_TEXTURE_CREATE_FAILED;
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Get pointer to global driver. data structure.
     */
    nvSetDriverDataPtrFromContext(pContext);

    /*
     * verify that we have the DX6 runtime. Should never happen on DX7.
     */
    nvAssert (global.dwDXRuntimeVersion < 0x0700);

    /*
     * get texture pointer
     */
    CNvObject *pNvObj = GET_PNVOBJ (lpLcl);

    if (lpLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) {

        // Not that much we can do about a system memory texture. We just need to
        // create an object which we will use from now on.
        if (!IS_VALID_PNVOBJ(pNvObj)) {
            //The object hasn't been allocated yet.
            if ((pTextureCreateData->ddrval = nvCreateSystemMemorySurface(lpLcl)) != DD_OK)
            {
                dbgD3DError();
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureCreate - out of memory");
                pTextureCreateData->ddrval = D3DERR_TEXTURE_CREATE_FAILED;
            }
            pNvObj = GET_PNVOBJ (lpLcl);
        }
        else {
            //Nothing to do at all
            pTextureCreateData->ddrval = DD_OK;
        }

        nvAssert (IS_VALID_PNVOBJ(pNvObj));
        pTextureCreateData->dwHandle = (DWORD) pNvObj;
        // For DX6 runtime we will reuse the Object->Handle to keep a pointer to the local.
        pNvObj->setHandle ((DWORD)lpLcl);

        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    CTexture *pTexture = pNvObj ? pNvObj->getTexture() : NULL;

    /*
     * is texture object allocated yet?
     */
    if (!pTexture)
    {
        /*
         * verify that we do not overwrite a different object
         */
        nvAssert (GET_PNVOBJ(lpLcl) == NULL);

        /*
         * The internal texture data structure has not been allocated yet. This can
         * happen if the application allocates it's texture handles before it creates the
         * texture surfaces.  (Ziff Davis 3D Winbench)
         * So we have to handle both cases.  If the data structure has not been allocated
         * yet, allocate it here.
         */
        pNvObj   = new CNvObject (pContext->pid);
        pTexture = new CTexture;

        if (!pNvObj || !pTexture)
        {
            /*
             * Bad news.  Could not allocate the internal data structure.  No choice but to
             * return an error.
             */
            dbgD3DError();
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureCreate - out of memory");
            if (pNvObj) pNvObj->release();
            NvReleaseSemaphore(pDriverData);
            pTextureCreateData->ddrval = D3DERR_TEXTURE_CREATE_FAILED;
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }

        /*
         * update stats
         */
        getDC()->dwD3DTextureCount++;

        /*
         * Store the handle of the internal texture structure in the local surface structure
         * driver reserved field.
         */
        pNvObj->setObject (CNvObject::NVOBJ_TEXTURE, pTexture);
        SET_PNVOBJ (lpLcl, pNvObj);
    }

    /*
     * Return the new texture handle.
     */
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvTextureCreate - New texture handle = %08x", pTexture);
    pTextureCreateData->dwHandle = (DWORD)pNvObj;

    /*
     * A handle is only ever allocated for the top-most level of the mipmap chain.
     * run down the chain and update the mipmap base texture for each mipmap.
     */
    if ((lpLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP)
     && (!lpLcl->lpAttachListFrom)
     && (lpLcl->lpAttachList))
    {
        LPDDRAWI_DDRAWSURFACE_LCL lclMip;
        lclMip = lpLcl->lpAttachList->lpAttached;
        while (lclMip)
        {
            CTexture *pMipMap;

            pMipMap = GET_PNVOBJ(lclMip)->getTexture();
            if (IS_VALID_PNVOBJ(pMipMap))
            {
                pMipMap->tagUserMipLevel();
                pMipMap->setBaseTexture (pTexture);
            }
            if (lclMip->lpAttachList) {
                lclMip = lclMip->lpAttachList->lpAttached;
            }
            else {
                lclMip = 0;
            }
        }
    }

    NvUnlockTextureSurface(lpLcl);
    /*
     * Show that the texture has not been loaded yet and that it is not locked.
     */
    pTexture->tagHasHandle();

    /*
     * Load convert the texture immediately so that hopefully real game speed does not
     * get impacted during actual game play.  This has no effect on the benchmarks, but
     * it can sometimes help out games (like moto racer with the polygon patch).
     */
    if (!pTexture->getSwizzled()->isValid() && pTexture->getLinear()->isValid())
    {
        pTexture->updateSwizzleSurface (pContext);
    }

    /*
     * For DX6 runtime we will reuse the Object->Handle to keep a pointer to
     * the local.
     */
     pNvObj->setHandle((DWORD)lpLcl);
     pNvObj->reference();    //add a reference so we don't go and delete this object
                             //when we 'release' the texture in the symmetric destroy call.

    /*
     * Texture creation successful.
     */
    NvReleaseSemaphore(pDriverData);
    pTextureCreateData->ddrval = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

//-------------------------------------------------------------------------

DWORD __stdcall nvTextureDestroy
(
    LPD3DHAL_TEXTUREDESTROYDATA pTextureDestroyData
)
{
    CNvObject *pNvObj;
    CTexture  *pTexture;

    dbgTracePush ("nvTextureDestroy - handle=%08x", pTextureDestroyData->dwHandle);

    /*
     * get context
     */
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pTextureDestroyData);

    nvSetDriverDataPtrFromContext (pContext);

    /*
     * verify that we have the DX6 runtime. Should never happen on DX7.
     */
    nvAssert (global.dwDXRuntimeVersion < 0x0700);

    pNvObj   = (CNvObject *)pTextureDestroyData->dwHandle;

    if (pNvObj->getClass() == CNvObject::NVOBJ_SIMPLESURFACE) {
        /* This handle is associated with a texture in system memory.
         * We just need to release the object.
         */
        LPDDRAWI_DDRAWSURFACE_LCL lpLcl = (LPDDRAWI_DDRAWSURFACE_LCL)pNvObj->getHandle();
        nvDeleteSystemMemorySurface(lpLcl);
        pTextureDestroyData->ddrval = DD_OK;
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    pTexture = pNvObj->getTexture();

    /*
     * Perform all the neccessary steps for destroying this texture handle.
     * Destruction of the actual texture data structure is actually
     * dependent on the current state of the texture surface structure.
     */
    if (pTexture)
    {
        // Make sure the texture is not the currently selected handle in the context.
        DWORD   dwStage;

        for (dwStage = 0; dwStage < 8; dwStage++)
        {
            if (pContext->tssState[dwStage].dwValue[D3DTSS_TEXTUREMAP] == (DWORD)pNvObj) {
                pContext->tssState[dwStage].dwValue[D3DTSS_TEXTUREMAP] = NULL;
                pContext->tssState[dwStage].dwHandle = 0;
            }
        }

        // Destroy the internal texture data structure.
        //this seems circular if we had a pNvObj above.
        //CNvObject *pNvObj = pTexture->getWrapper();

        //don't remove the pnvobj here -- we shouldn't actually destroy surfaces here
        //LPDDRAWI_DDRAWSURFACE_LCL lpLcl = (LPDDRAWI_DDRAWSURFACE_LCL)pNvObj->getHandle();
        //SET_PNVOBJ (lpLcl, NULL);

        pNvObj->release();
    }

    // Texture destroyed successfully.
    pTextureDestroyData->ddrval = DD_OK;
    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

//-------------------------------------------------------------------------

/*
 * nvTextureSwap
 *
 * This callback is invoked when two texture handles are to be swapped.
 * I.e. the data refered to by the two handles is to be swapped.
 */
DWORD __stdcall nvTextureSwap
(
    LPD3DHAL_TEXTURESWAPDATA pTextureSwapData
)
{
    dbgTracePush ("nvTextureSwap - hContext=%08x, h1=%08x, h2=%08x",
                  pTextureSwapData->dwhContext, pTextureSwapData->dwHandle1, pTextureSwapData->dwHandle2);

    // get a pointer to the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pTextureSwapData);

    nvSetDriverDataPtrFromContext(pContext);

    // verify that we have the DX6 runtime. Should never happen on DX7.
    nvAssert (global.dwDXRuntimeVersion < 0x0700);

    // Get pointers and classes
    CNvObject *pNvObj1, *pNvObj2;
    DWORD      dwClass1, dwClass2;

    pNvObj1  = (CNvObject *)(pTextureSwapData->dwHandle1);
    pNvObj2  = (CNvObject *)(pTextureSwapData->dwHandle2);
    nvAssert (pNvObj1);
    nvAssert (pNvObj2);
    dwClass1 = pNvObj1->getClass();
    dwClass2 = pNvObj2->getClass();

    if ((dwClass1 != CNvObject::NVOBJ_SIMPLESURFACE) &&
        (dwClass1 != CNvObject::NVOBJ_TEXTURE)) {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureSwap - Bad Texture 1");
        dbgD3DError();
        NvReleaseSemaphore(pDriverData);
        pTextureSwapData->ddrval = DDERR_INVALIDPARAMS;
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    if ((dwClass2 != CNvObject::NVOBJ_SIMPLESURFACE) &&
        (dwClass2 != CNvObject::NVOBJ_TEXTURE)) {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureSwap - Bad Texture 2");
        dbgD3DError();
        NvReleaseSemaphore(pDriverData);
        pTextureSwapData->ddrval = DDERR_INVALIDPARAMS;
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    // swap the contents of the pNvObjects
    pNvObj1->swap (pNvObj2);

    // fix up the back-pointers in the DDSLcls
    SET_PNVOBJ (((LPDDRAWI_DDRAWSURFACE_LCL)pNvObj1->getHandle()), pNvObj1);
    SET_PNVOBJ (((LPDDRAWI_DDRAWSURFACE_LCL)pNvObj2->getHandle()), pNvObj2);

    // Texture swap was successful.
    NvReleaseSemaphore(pDriverData);
    pTextureSwapData->ddrval = DD_OK;
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

//-------------------------------------------------------------------------

/*
 * nvTextureGetSurf
 *
 * This callback is invoked when d3d needs to obtain the surface
 * referred to by a handle.
 */
DWORD __stdcall nvTextureGetSurf
(
    LPD3DHAL_TEXTUREGETSURFDATA pTextureGetSurfData
)
{
    dbgTracePush ("nvTextureGetSurf - handle=%08x", pTextureGetSurfData->dwHandle);

    /*
     * Get the pointer to the specified context.
     */
    PNVD3DCONTEXT pContext = (PNVD3DCONTEXT)pTextureGetSurfData->dwhContext;
    if (!pContext)
    {
        dbgD3DError();
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvTextureGetSurf - Bad Context");
        pTextureGetSurfData->ddrval = D3DHAL_CONTEXT_BAD;
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * verify that we have the DX6 runtime. Should never happen on DX7.
     */
    nvAssert (global.dwDXRuntimeVersion < 0x0700);
#ifndef WINNT
// WINNT BUG
    CNvObject *pNvObj = (CNvObject *)pTextureGetSurfData->dwHandle;
    LPDDRAWI_DDRAWSURFACE_LCL lpLcl = (LPDDRAWI_DDRAWSURFACE_LCL)pNvObj->getHandle();
    pTextureGetSurfData->lpDDS = (ULONG_PTR)lpLcl;
#endif

    // Texture surface was gotten successfully.
    pTextureGetSurfData->ddrval = DD_OK;
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

/*
 * --------------------------------------------------------------------------
 * Texture heap management routines.
 * --------------------------------------------------------------------------
 */

// nvPCICreateHeap
// top-level routine for creation of the PCI heap

BOOL nvPCICreateHeap
(
    void
)
{
    DWORD status;
    DWORD dwBlockStartOffset;

    dbgTracePush ("nvPCICreateHeap");

    // shouldn't create the heap more than once
    nvAssert(!pDriverData->nvD3DTexHeapData.dwHandle);

    // should only do this if AGP is not available
    nvAssert(!pDriverData->GARTLinearBase);

    // The texture heap always starts out empty.
    getDC()->nvD3DTexHeapData.dwAllocSize = 0;

    // Get the maximum size of the texture heap.
    getDC()->nvD3DTexHeapData.dwSizeMax = getDC()->nvD3DRegistryData.regPCITexHeapSize ?
                                          getDC()->nvD3DRegistryData.regPCITexHeapSize :
                                          pDriverData->nvD3DPerfData.dwRecommendedPCITexHeapSize;

    if (!(getDC()->nvD3DTexHeapData.dwSizeMax)) {
        dbgTracePop();
        return (TRUE);
    }

    do {
        // Create the texture heap.
        getDC()->nvD3DTexHeapData.dwHandle = (DWORD)HeapCreate(HEAP_SHARED, getDC()->nvD3DTexHeapData.dwSizeMax, 0);
        if (!getDC()->nvD3DTexHeapData.dwHandle) {
            dbgTracePop();
            return (FALSE);
        }

        // Allocate the entire heap up front for management.
        getDC()->nvD3DTexHeapData.dwBaseRaw = (unsigned long)HeapAlloc((HANDLE)getDC()->nvD3DTexHeapData.dwHandle, HEAP_ZERO_MEMORY, getDC()->nvD3DTexHeapData.dwSizeMax);
        if (!getDC()->nvD3DTexHeapData.dwBaseRaw)
        {
            HeapDestroy((HANDLE)getDC()->nvD3DTexHeapData.dwHandle);
            getDC()->nvD3DTexHeapData.dwHandle = (DWORD)NULL;
            dbgTracePop();
            return (FALSE);
        }

        // Get the size of the allocated heap and set the maximum heap limit. The size shouldn't be different
        // than what we asked for, but on win9x, we do the check just to be safe. (On WinNT, we can't, because
        // the function HeapSize does not exist)
#ifndef WINNT
        getDC()->nvD3DTexHeapData.dwSizeMax = (DWORD) HeapSize ((HANDLE)getDC()->nvD3DTexHeapData.dwHandle, 0, (PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwBaseRaw);
#endif

        // Align the heap properly.
        getDC()->nvD3DTexHeapData.dwBase      = ((getDC()->nvD3DTexHeapData.dwBaseRaw + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN);
        getDC()->nvD3DTexHeapData.dwSizeMax  -= (getDC()->nvD3DTexHeapData.dwBase - getDC()->nvD3DTexHeapData.dwBaseRaw);
        getDC()->nvD3DTexHeapData.dwSizeMax  &= 0xFFFFFF00;
        getDC()->nvD3DTexHeapData.dwLimitMax  = getDC()->nvD3DTexHeapData.dwSizeMax - 1;
        getDC()->nvD3DTexHeapData.dwFreeSize  = getDC()->nvD3DTexHeapData.dwSizeMax - NV_TEXTURE_PAD;
        getDC()->nvD3DTexHeapData.dwSize      = getDC()->nvD3DTexHeapData.dwSizeMax;
        getDC()->nvD3DTexHeapData.dwLimit     = getDC()->nvD3DTexHeapData.dwSize - 1;

        // Try and lock down the entire heap.
        status = D3DCreateTextureContexts (getDC()->nvD3DTexHeapData.dwBase, getDC()->nvD3DTexHeapData.dwLimit);

        if (status)
        {
            // Map the context to the frame buffer because the RM/Hardware doesn't
            // like having limts of 0.
//            D3DCreateTextureContexts (VIDMEM_ADDR(pDriverData->BaseAddress), 0xFF, 0xFF);
            HeapFree((HANDLE)getDC()->nvD3DTexHeapData.dwHandle, 0, (PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwBaseRaw);
            HeapDestroy((HANDLE)getDC()->nvD3DTexHeapData.dwHandle);
            getDC()->nvD3DTexHeapData.dwHandle  = (DWORD)NULL;
            getDC()->nvD3DTexHeapData.dwBaseRaw = (unsigned long)NULL;

            // reduce the size and try again
            getDC()->nvD3DTexHeapData.dwSizeMax -= min(getDC()->nvD3DTexHeapData.dwSizeMax, HEAP_SIZE_ADJUST);
            if (!getDC()->nvD3DTexHeapData.dwSizeMax)
            {
                nvAssert(0);
                // Can't lock down even a minimal heap.  Disable system memory textures.
                pDriverData->nvD3DPerfData.dwRecommendedPCITexHeapSize = 0;
                getDC()->nvD3DRegistryData.regPCITexHeapSize           = 0;
                getDC()->nvD3DTexHeapData.dwSizeMax                    = 0;
                getDC()->nvD3DTexHeapData.dwLimitMax                   = 0;
                dbgTracePop();
                return (FALSE);
            }
        }

    } while (!getDC()->nvD3DTexHeapData.dwHandle);

    /*
     * Align the start of the texture.
     * 1) Original way was aligning the texture heap base address then aligning each
     *    individual texture start offset off of the texture heap base address.
     */
//    dwBlockStartOffset                       = (sizeof(TEXHEAPHEADER) + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN;
    /*
     * 2) New way is to align the texture heap address and align the start address of each
     *    texture.
     */
    dwBlockStartOffset = (((getDC()->nvD3DTexHeapData.dwBase + sizeof(TEXHEAPHEADER) + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN) - getDC()->nvD3DTexHeapData.dwBase);

    // Fill in the initial block structure.
    (getDC()->nvD3DTexHeapData.dwFreeHead)                                     = (unsigned long)(getDC()->nvD3DTexHeapData.dwBase + dwBlockStartOffset - sizeof(TEXHEAPHEADER));
    (getDC()->nvD3DTexHeapData.dwFreeTail)                                     = (unsigned long)getDC()->nvD3DTexHeapData.dwFreeHead;
    ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwFreeHead)->dwTag              = HEAP_TAG_FREE;
    ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwFreeHead)->dwBlockSize        = getDC()->nvD3DTexHeapData.dwSizeMax - dwBlockStartOffset;
    ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwFreeHead)->dwBlockStartOffset = dwBlockStartOffset;
    ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwFreeHead)->pNextFreeBlock     = (PTEXHEAPHEADER)NULL;
    ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwFreeHead)->pPrevFreeBlock     = (PTEXHEAPHEADER)NULL;
    ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwFreeHead)->pNextAllocBlock    = (PTEXHEAPHEADER)NULL;
    ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwFreeHead)->pPrevAllocBlock    = (PTEXHEAPHEADER)NULL;

    // Dump some information about the texture heap.
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCICreateHeap:");
    DPF_LEVEL(NVDBG_LEVEL_INFO, "   dwBase      = %08x", getDC()->nvD3DTexHeapData.dwBase);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "   dwSizeMax   = %08x", getDC()->nvD3DTexHeapData.dwSizeMax);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "   dwLimitMax  = %08x", getDC()->nvD3DTexHeapData.dwLimitMax);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "   dwSize      = %08x", getDC()->nvD3DTexHeapData.dwSize);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "   dwLimit     = %08x", getDC()->nvD3DTexHeapData.dwLimit);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "   dwFreeSize  = %08x", getDC()->nvD3DTexHeapData.dwFreeSize);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "   dwAllocSize = %08x", getDC()->nvD3DTexHeapData.dwAllocSize);

    // Return successfully.
    dbgTracePop();
    return (TRUE);
}

//-------------------------------------------------------------------------

// DestroyTextureHeap
// top-level routine for destruction of the PCI heap

BOOL nvPCIDestroyHeap
(
    void
)
{
    dbgTracePush ("nvPCIDestroyHeap");

    D3DDestroyTextureContexts (pDriverData);

    // Can't destroy a heap if there isn't one.
    nvAssert (getDC()->nvD3DTexHeapData.dwHandle);

    if (!(getDC()->nvD3DTexHeapData.dwHandle)) { return TRUE; }

    nvAssert(pDriverData->GARTLinearBase == 0);

    // Only need to free the heap if it was allocated.  (it won't be allocated on an AGP system)
    HeapFree((HANDLE)getDC()->nvD3DTexHeapData.dwHandle, 0, (PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwBaseRaw);
    HeapDestroy((HANDLE)getDC()->nvD3DTexHeapData.dwHandle);

    // Clean up a little bit.
    getDC()->nvD3DTexHeapData.dwHandle    = (DWORD)NULL;
    getDC()->nvD3DTexHeapData.dwBaseRaw   = (unsigned long)NULL;
    getDC()->nvD3DTexHeapData.dwBase      = (unsigned long)NULL;
    getDC()->nvD3DTexHeapData.dwAllocHead = (unsigned long)NULL;
    getDC()->nvD3DTexHeapData.dwAllocTail = (unsigned long)NULL;
    getDC()->nvD3DTexHeapData.dwFreeHead  = (unsigned long)NULL;
    getDC()->nvD3DTexHeapData.dwFreeTail  = (unsigned long)NULL;
    getDC()->nvD3DTexHeapData.dwSize      = 0;
    getDC()->nvD3DTexHeapData.dwSizeMax   = 0;
    getDC()->nvD3DTexHeapData.dwLimit     = 0;
    getDC()->nvD3DTexHeapData.dwLimitMax  = 0;
    getDC()->nvD3DTexHeapData.dwAllocSize = 0;
    getDC()->nvD3DTexHeapData.dwFreeSize  = 0;

    dbgTracePop();
    return (TRUE);
}

//-------------------------------------------------------------------------

DWORD nvPCIAlloc
(
    DWORD   dwSizeRequest
)
{
    DWORD           dwAllocBlockSize;
    DWORD           dwNewFreeBlockSize;
    DWORD           dwNewFreeBlockOffset;
    DWORD           dwNewFreeBlockStartOffset;
    DWORD           dwAllocLimit;
    PTEXHEAPHEADER  pAllocBlock;
    PTEXHEAPHEADER  pList;
    PTEXHEAPHEADER  pNextFree;
    PTEXHEAPHEADER  pPrevFree;
    PTEXHEAPHEADER  pNewFree;

    dbgTracePush ("nvPCIAlloc");

    // make sure we have a heap to allocate from
    nvAssert (getDC()->nvD3DTexHeapData.dwHandle);

    /*
     * If the free list is null, then there's no memory to be allocated.
     */
    if ((!getDC()->nvD3DTexHeapData.dwFreeHead)
     || (getDC()->nvD3DTexHeapData.dwFreeSize < dwSizeRequest))
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvPCIAlloc - Not enough free memory to fill request!");
        dbgTracePop();
        return (0);
    }

    /*
     * Search the free block list for a block large enough to fill this
     * request.
     */
    pAllocBlock      = (PTEXHEAPHEADER)NULL;
    dwAllocBlockSize = 0;
    pList            = (PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwFreeHead;

    /*
     * The search will end when a block has been found that exactly matches
     * the requested size or the end of the free list has been reached. In the
     * event that an exact size match is not found, then the first block that is
     * closest to the requested size will be used.
     *
     * CHASNOTE: Potential problem with this method is that a larger block might
     * be passed up for a smaller block later in the heap and this could mean that
     * the context limit will fail shrink when it may have otherwise if the larger
     * block was used.
     */
    while ((pList)
        && (dwAllocBlockSize != dwSizeRequest))
    {
        if (pList->dwBlockSize >= dwSizeRequest)
        {
            if ((!dwAllocBlockSize)
             || (pList->dwBlockSize < dwAllocBlockSize))
            {
                pAllocBlock      = pList;
                dwAllocBlockSize = pList->dwBlockSize;
            }
        }
        pList = pList->pNextFreeBlock;
    }

    /*
     * If there was no block large enough to fill the request, return unsuccessful.
     */
    if (!pAllocBlock) {
        dbgTracePop();
        return (0);
    }

    /*
     * Get a few pointers.
     */
    pPrevFree                   = pAllocBlock->pPrevFreeBlock;
    pNextFree                   = pAllocBlock->pNextFreeBlock;
    pAllocBlock->pPrevFreeBlock = (PTEXHEAPHEADER)NULL;
    pAllocBlock->pNextFreeBlock = (PTEXHEAPHEADER)NULL;

    /*
     * Initialize the newly allocated block header and create
     * the new free block as neccessary.
     */
    pAllocBlock->dwTag       = HEAP_TAG_ALLOC;
    pAllocBlock->dwBlockSize = dwSizeRequest;

    /*
     * Allocate any new free block if the block being used for the allocation
     * is larger than the requested block size.
     */
    dwNewFreeBlockSize = dwAllocBlockSize - dwSizeRequest;

    /*
     * Adjust alignment so the next free block starts on the correct boundry for an NV3
     * texture.
     */
    if (dwNewFreeBlockSize >= (sizeof(TEXHEAPHEADER) + NV_MIN_TEXTURE_SIZE))
    {
        DWORD dwNextBlockOffset;
        DWORD dwExcess;

        dwNextBlockOffset = pAllocBlock->dwBlockStartOffset + dwSizeRequest;
        /*
         * Align the start of the texture.
         * 1) Original way was aligning the texture heap base address then aligning each
         *    individual texture start offset off of the texture heap base address.
         */
//        dwNewFreeBlockStartOffset = (dwNextBlockOffset + sizeof(TEXHEAPHEADER) + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN;
        /*
         * 2) New way is to align the texture heap address and align the start address of each
         *    texture.
         */
        dwNewFreeBlockStartOffset = ((((getDC()->nvD3DTexHeapData.dwBase + dwNextBlockOffset + sizeof(TEXHEAPHEADER)) + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN) - getDC()->nvD3DTexHeapData.dwBase);
        dwNewFreeBlockOffset      = dwNewFreeBlockStartOffset - sizeof(TEXHEAPHEADER);
        dwExcess                  = dwNewFreeBlockOffset - dwNextBlockOffset;
        dwNewFreeBlockSize       -= dwExcess;
        pAllocBlock->dwBlockSize += dwExcess;
    }

    /*
     * Now that the block has been aligned on the correct boundry, check again to make sure
     * that there's still enough room for a minimum sized texture.
     */
    if (dwNewFreeBlockSize >= (sizeof(TEXHEAPHEADER) + NV_MIN_TEXTURE_SIZE))
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIAlloc - Create new free block at end of allocation block.");

        /*
         * Create the new free block.
         */
        pNewFree                     = (PTEXHEAPHEADER)(getDC()->nvD3DTexHeapData.dwBase + dwNewFreeBlockOffset);
        pNewFree->dwTag              = HEAP_TAG_FREE;
        pNewFree->dwBlockStartOffset = dwNewFreeBlockStartOffset;
        pNewFree->dwBlockSize        = dwNewFreeBlockSize - sizeof(TEXHEAPHEADER);
        pNewFree->pNextFreeBlock     = pNextFree;
        pNewFree->pPrevFreeBlock     = pPrevFree;
        pNewFree->pNextAllocBlock    = (PTEXHEAPHEADER)NULL;
        pNewFree->pPrevAllocBlock    = (PTEXHEAPHEADER)NULL;

        /*
         * Insert the new free block into the free block list.
         */
        if (pPrevFree) {
            pPrevFree->pNextFreeBlock = pNewFree;
        }
        else {
            getDC()->nvD3DTexHeapData.dwFreeHead = (unsigned long)pNewFree;
        }

        if (pNextFree) {
            pNextFree->pPrevFreeBlock = pNewFree;
        }
        else {
            getDC()->nvD3DTexHeapData.dwFreeTail = (unsigned long)pNewFree;
        }
    }
    else
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIAlloc - Tack excess free memory  onto end of allocation block.");

        /*
         * Tack the excess memory on to the end of the block.
         */
        pAllocBlock->dwBlockSize += dwNewFreeBlockSize;

        /*
         * Remove the block from the free block list.
         */
        if (pPrevFree) {
            pPrevFree->pNextFreeBlock = pNextFree;
        }
        else {
            getDC()->nvD3DTexHeapData.dwFreeHead = (unsigned long)pNextFree;
        }

        if (pNextFree) {
            pNextFree->pPrevFreeBlock = pPrevFree;
        }
        else {
            getDC()->nvD3DTexHeapData.dwFreeTail = (unsigned long)pPrevFree;
        }
    }

    /*
     * Update the allocation sizes.
     */
    getDC()->nvD3DTexHeapData.dwAllocSize += pAllocBlock->dwBlockSize;
    getDC()->nvD3DTexHeapData.dwFreeSize  -= pAllocBlock->dwBlockSize;

    /*
     * Insert the newly allocated block into the allocation list.
     * First handle the best case scenarios, the block is either the first block
     * to be allocated, the block comes before the current head of the allocation
     * list, or the block comes after the current tail of the allocation list.
     * In these cases, its simply a case of updating a few pointers.
     */
    if (!getDC()->nvD3DTexHeapData.dwAllocHead)
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIAlloc - Insert new allocation block at head of allocation list. First time.");
        pAllocBlock->pPrevAllocBlock          = (PTEXHEAPHEADER)NULL;
        pAllocBlock->pNextAllocBlock          = (PTEXHEAPHEADER)NULL;
        getDC()->nvD3DTexHeapData.dwAllocHead = (unsigned long)pAllocBlock;
        getDC()->nvD3DTexHeapData.dwAllocTail = (unsigned long)pAllocBlock;

        /*
         * The tail of allocation list has changed. Check to see if the texture context
         * needs to be udpated to reflect the change.
         */
        if (getDC()->nvD3DTexHeapData.dwAllocTail) {
            dwAllocLimit = ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwAllocTail)->dwBlockStartOffset +
                           ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwAllocTail)->dwBlockSize - 1;
        }
        else {
            dwAllocLimit = 0;
        }
    }
    else if (pAllocBlock < (PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwAllocHead)
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIAlloc - Insert new allocation block at head of allocation list.");
        ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwAllocHead)->pPrevAllocBlock = pAllocBlock;
        pAllocBlock->pPrevAllocBlock          = (PTEXHEAPHEADER)NULL;
        pAllocBlock->pNextAllocBlock          = (PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwAllocHead;
        getDC()->nvD3DTexHeapData.dwAllocHead = (unsigned long)pAllocBlock;
    }
    else if (pAllocBlock > (PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwAllocTail)
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIAlloc - Insert new allocation block at tail of allocation list.");
        ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwAllocTail)->pNextAllocBlock = pAllocBlock;
        pAllocBlock->pPrevAllocBlock          = (PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwAllocTail;
        pAllocBlock->pNextAllocBlock          = (PTEXHEAPHEADER)NULL;
        getDC()->nvD3DTexHeapData.dwAllocTail = (unsigned long)pAllocBlock;

        /*
         * The tail of allocation list has changed. Check to see if the texture context
         * needs to be udpated to reflect the change.
         */
        if (getDC()->nvD3DTexHeapData.dwAllocTail) {
            dwAllocLimit = ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwAllocTail)->dwBlockStartOffset +
                           ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwAllocTail)->dwBlockSize - 1;
        }
        else {
            dwAllocLimit = 0;
        }
    }
    else
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIAlloc - Insert new allocation block in middle of allocation list.");

        /* WORST CASE
         * The newly allocated block falls between the head and tail of the allocation
         * list. Search all memory blocks following the new allocation block to find the
         * next allocated block, then just update the pointers.
         */
        pList = (PTEXHEAPHEADER)((DWORD)pAllocBlock + sizeof(TEXHEAPHEADER) + pAllocBlock->dwBlockSize);
        while ((pList) && (pList->dwTag != HEAP_TAG_ALLOC))
        {
            pList = (PTEXHEAPHEADER)((DWORD)pList + sizeof(TEXHEAPHEADER) + pList->dwBlockSize);
        }
        /*
         * This should never happen, if it does, then we've got problems.
         */
        if (!pList)
        {
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvPCIAlloc - Error inserting new allocation block!!");
            dbgTracePop();
            return (pAllocBlock->dwBlockStartOffset);
        }

        /*
         * Update the pointers.
         */
        pAllocBlock->pPrevAllocBlock                  = pList->pPrevAllocBlock;
        pAllocBlock->pNextAllocBlock                  = pList;
        pList->pPrevAllocBlock                        = pAllocBlock;
        pAllocBlock->pPrevAllocBlock->pNextAllocBlock = pAllocBlock;
    }

    /*
     * Dump some information about the texture heap allocation.
     */
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIAlloc - pAllocBlock->dwBlockStartOffset = %08x", (DWORD)pAllocBlock->dwBlockStartOffset);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIAlloc - dwSize                          = %08x", getDC()->nvD3DTexHeapData.dwSize);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIAlloc - dwLimit                         = %08x", getDC()->nvD3DTexHeapData.dwLimit);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIAlloc - dwFreeSize                      = %08x", getDC()->nvD3DTexHeapData.dwFreeSize);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIAlloc - dwAllocSize                     = %08x", getDC()->nvD3DTexHeapData.dwAllocSize);

    /*
     * Return the offset to the allocated block.
     */
    dbgTracePop();
    return (pAllocBlock->dwBlockStartOffset);
}

//-------------------------------------------------------------------------

BOOL nvPCIFree
(
    DWORD   dwFreeBlockOffset
)
{
    DWORD           dwAllocLimit;
    PTEXHEAPHEADER  pList;
    PTEXHEAPHEADER  pFreeBlock;
    PTEXHEAPHEADER  pPrevFree;
    PTEXHEAPHEADER  pNextFree;
    PTEXHEAPHEADER  pPrevAlloc;
    PTEXHEAPHEADER  pNextAlloc;

    dbgTracePush ("nvPCIFree");

    /*
     * Make sure there is a valid texture heap to free the memory from.
     */
    if (!getDC()->nvD3DTexHeapData.dwBase) {
        dbgTracePop();
        return (TRUE);
    }

    /*
     * Make sure there is actually a valid texture block to free.
     */
    if (!dwFreeBlockOffset) {
        dbgTracePop();
        return (FALSE);
    }

    /*
     * Calculate the pointer to the header of the block being freed.
     */
    pFreeBlock = (PTEXHEAPHEADER)(getDC()->nvD3DTexHeapData.dwBase + (dwFreeBlockOffset - sizeof(TEXHEAPHEADER)));
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIFree - pFreeBlock->dwBlockSize = %08x", pFreeBlock->dwBlockSize);

    /*
     * Make sure we are pointer to an actual allocated block header.
     */
    if (pFreeBlock->dwTag != HEAP_TAG_ALLOC) {
        dbgTracePop();
        return (FALSE);
    }

    /*
     * Get a few pointers.
     */
    pPrevAlloc                  = pFreeBlock->pPrevAllocBlock;
    pNextAlloc                  = pFreeBlock->pNextAllocBlock;
    pFreeBlock->pPrevAllocBlock = (PTEXHEAPHEADER)NULL;
    pFreeBlock->pNextAllocBlock = (PTEXHEAPHEADER)NULL;

    /*
     * Remove the block from the allocation list.
     */
    if (pPrevAlloc)
        pPrevAlloc->pNextAllocBlock = pNextAlloc;
    else
        getDC()->nvD3DTexHeapData.dwAllocHead = (unsigned long)pNextAlloc;
    if (pNextAlloc)
        pNextAlloc->pPrevAllocBlock = pPrevAlloc;
    else
    {
        getDC()->nvD3DTexHeapData.dwAllocTail = (unsigned long)pPrevAlloc;

        /*
         * The tail of allocation list has changed. Check to see if the texture context
         * needs to be udpated to reflect the change.
         */
        if (getDC()->nvD3DTexHeapData.dwAllocTail)
            dwAllocLimit = ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwAllocTail)->dwBlockStartOffset + ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwAllocTail)->dwBlockSize - 1;
        else
            dwAllocLimit = 0;
    }

    /*
     * Mark the block as freed and get the size of the block.
     */
    pFreeBlock->dwTag = HEAP_TAG_FREE;

    /*
     * Update the allocation sizes.
     */
    getDC()->nvD3DTexHeapData.dwAllocSize -= pFreeBlock->dwBlockSize;
    getDC()->nvD3DTexHeapData.dwFreeSize  += pFreeBlock->dwBlockSize;

    /*
     * Insert the newly freed block into the free list.
     */
    if (!getDC()->nvD3DTexHeapData.dwFreeHead)
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIFree - Insert new free block at head of free list. First time.");
        pFreeBlock->pPrevFreeBlock    = (PTEXHEAPHEADER)NULL;
        pFreeBlock->pNextFreeBlock    = (PTEXHEAPHEADER)NULL;
        getDC()->nvD3DTexHeapData.dwFreeHead = (unsigned long)pFreeBlock;
        getDC()->nvD3DTexHeapData.dwFreeTail = (unsigned long)pFreeBlock;
    }
    else if (pFreeBlock < (PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwFreeHead)
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIFree - Insert new free block at head of free list.");
        ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwFreeHead)->pPrevFreeBlock = pFreeBlock;
        pFreeBlock->pPrevFreeBlock           = (PTEXHEAPHEADER)NULL;
        pFreeBlock->pNextFreeBlock           = (PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwFreeHead;
        getDC()->nvD3DTexHeapData.dwFreeHead = (unsigned long)pFreeBlock;
    }
    else if (pFreeBlock > (PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwFreeTail)
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIFree - Insert new free block at tail of free list.");
        ((PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwFreeTail)->pNextFreeBlock = pFreeBlock;
        pFreeBlock->pPrevFreeBlock           = (PTEXHEAPHEADER)getDC()->nvD3DTexHeapData.dwFreeTail;
        pFreeBlock->pNextFreeBlock           = (PTEXHEAPHEADER)NULL;
        getDC()->nvD3DTexHeapData.dwFreeTail = (unsigned long)pFreeBlock;
    }
    else
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIFree - Insert new free block in middle of free list.");

        /* WORST CASE
         * The newly freed block falls between the head and tail of the free
         * list. Search all memory blocks following the new freed block to find the
         * next free block, then just update the pointers.
         */
        pList = (PTEXHEAPHEADER)((DWORD)pFreeBlock + sizeof(TEXHEAPHEADER) + pFreeBlock->dwBlockSize);
        while ((pList)
            && (pList->dwTag != HEAP_TAG_FREE))
        {
            pList = (PTEXHEAPHEADER)((DWORD)pList + sizeof(TEXHEAPHEADER) + pList->dwBlockSize);
        }
        /*
         * This should never happen, if it does, then we've got problems.
         */
        if (!pList)
        {
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvPCIFree - Error inserting newly freed block!!");
            dbgTracePop();
            return (TRUE);
        }

        /*
         * Update the pointers.
         */
        pFreeBlock->pPrevFreeBlock                 = pList->pPrevFreeBlock;
        pFreeBlock->pNextFreeBlock                 = pList;
        pList->pPrevFreeBlock                      = pFreeBlock;
        pFreeBlock->pPrevFreeBlock->pNextFreeBlock = pFreeBlock;
    }

    /*
     * Do some basic garbage collection to try and consolidate contiguous free
     * blocks.
     */
    pPrevFree = pFreeBlock->pPrevFreeBlock;
    pNextFree = pFreeBlock->pNextFreeBlock;

    if ((pPrevFree)
     && (((DWORD)pPrevFree + sizeof(TEXHEAPHEADER) + pPrevFree->dwBlockSize) == (DWORD)pFreeBlock))
    {
        /*
         * Merge the previous free block with the new free block.
         */
        pPrevFree->dwBlockSize += sizeof(TEXHEAPHEADER) + pFreeBlock->dwBlockSize;
        if (pPrevFree->pNextFreeBlock = pNextFree) {
            pNextFree->pPrevFreeBlock = pPrevFree;
        }
        else {
            getDC()->nvD3DTexHeapData.dwFreeTail = (unsigned long)pPrevFree;
        }

        /*
         * Clean out the old free block header.
         */
        pFreeBlock->dwTag              = 0;
        pFreeBlock->dwBlockSize        = 0;
        pFreeBlock->dwBlockStartOffset = 0;
        pFreeBlock->pPrevFreeBlock     = (PTEXHEAPHEADER)NULL;
        pFreeBlock->pNextFreeBlock     = (PTEXHEAPHEADER)NULL;
        pFreeBlock->pPrevAllocBlock    = (PTEXHEAPHEADER)NULL;
        pFreeBlock->pNextAllocBlock    = (PTEXHEAPHEADER)NULL;

        /*
         * Update the free block pointer to point to the new consolidated block.
         */
        pFreeBlock = pPrevFree;
    }

    if ((pNextFree)
     && (((DWORD)pFreeBlock + sizeof(TEXHEAPHEADER) + pFreeBlock->dwBlockSize) == (DWORD)pNextFree))
    {
        /*
         * Merge the new free block with the next free block.
         */
        pFreeBlock->dwBlockSize += sizeof(TEXHEAPHEADER) + pNextFree->dwBlockSize;
        if (pFreeBlock->pNextFreeBlock = pNextFree->pNextFreeBlock)
            pNextFree->pNextFreeBlock->pPrevFreeBlock = pFreeBlock;
        else
            getDC()->nvD3DTexHeapData.dwFreeTail = (unsigned long)pFreeBlock;

        /*
         * Clean out the old free block header.
         */
        pNextFree->dwTag              = 0;
        pNextFree->dwBlockSize        = 0;
        pNextFree->dwBlockStartOffset = 0;
        pNextFree->pPrevFreeBlock     = (PTEXHEAPHEADER)NULL;
        pNextFree->pNextFreeBlock     = (PTEXHEAPHEADER)NULL;
        pNextFree->pPrevAllocBlock    = (PTEXHEAPHEADER)NULL;
        pNextFree->pNextAllocBlock    = (PTEXHEAPHEADER)NULL;
    }

    /*
     * Dump some information about the texture heap allocation.
     */
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIFree - dwSize      = %08x", getDC()->nvD3DTexHeapData.dwSize);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIFree - dwLimit     = %08x", getDC()->nvD3DTexHeapData.dwLimit);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIFree - dwFreeSize  = %08x", getDC()->nvD3DTexHeapData.dwFreeSize);
    DPF_LEVEL(NVDBG_LEVEL_INFO, "nvPCIFree - dwAllocSize = %08x", getDC()->nvD3DTexHeapData.dwAllocSize);

    /*
     * Return successfully.
     */
    dbgTracePop();
    return (TRUE);
}

//-------------------------------------------------------------------------

#ifdef NV_TRACKAGP

#undef DDHAL32_VidMemAlloc
#undef DDHAL32_VidMemFree

FLATPTR EXTERN_DDAPI DDHAL32_VidMemAlloc (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, DWORD dwXDim, DWORD dwYDim);
void EXTERN_DDAPI DDHAL32_VidMemFree (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, FLATPTR ptr);

typedef struct
{
    FLATPTR ptr;
    DWORD size;
} TABLE;

static TABLE *lpTable = NULL;
static DWORD dwMax    = 0;
static DWORD dwTotal  = 0;

//-------------------------------------------------------------------------

FLATPTR EXTERN_DDAPI __DDHAL32_VidMemAlloc
(
    LPDDRAWI_DIRECTDRAW_GBL pdrv,
    int heap,
    DWORD dwXDim,
    DWORD dwYDim
)
{
    dbgTracePush ("__DDHAL32_VidMemAlloc");

    FLATPTR ptr = DDHAL32_VidMemAlloc (pdrv, heap, dwXDim, dwYDim);

    if (ptr && (heap == AGP_HEAP))
    {
        DWORD i;

        dwTotal += dwXDim * dwYDim;
        DPF ("a %d", dwTotal);

        for (i = 0; i < dwMax; i++)
        {
            if (lpTable[i].ptr == (FLATPTR)NULL)
            {
                lpTable[i].ptr = ptr;
                lpTable[i].size = dwXDim * dwYDim;
                dbgTracePop();
                return ptr;
            }
        }
        dwMax += 128;
        lpTable = (TABLE*)ReallocIPM(lpTable, dwMax * sizeof(TABLE));
        lpTable[i].ptr = ptr;
        lpTable[i].size = dwXDim * dwYDim;
        dbgTracePop();
        return ptr;
    }

    dbgTracePop();
    return ptr;
}

//-------------------------------------------------------------------------

void EXTERN_DDAPI __DDHAL32_VidMemFree
(
    LPDDRAWI_DIRECTDRAW_GBL pdrv,
    int heap,
    FLATPTR ptr
)
{
    dbgTracePush ("__DDHAL32_VidMemFree");

    if (heap == AGP_HEAP)
    {
        DWORD i;

        for (i = 0; i<dwMax; i++)
        {
            if (lpTable[i].ptr == ptr)
            {
                dwTotal -= lpTable[i].size;
                lpTable[i].ptr = (FLATPTR)NULL;

                DPF ("f %d", dwTotal);

                DDHAL32_VidMemFree (pdrv, heap, ptr);
                dbgTracePop();
                return;
            }
        }

        // should not get here
        __asm int 3;
    }

    DDHAL32_VidMemFree (pdrv, heap, ptr);
    dbgTracePop();
}

//-------------------------------------------------------------------------

void __Reset (void)
{
    dbgTracePush ("__Reset");

    FreeIPM (lpTable);
    lpTable = NULL;
    dwTotal = dwMax = 0;
    DPF ("reset");

    dbgTracePop();
}

#endif //NV_TRACKAGP

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\ddDrvMem.cpp ===
// =========================================================
// Memory allocator for display drivers.
// =========================================================
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

//
// Local Memory Management macros, variables, etc.
//

#define HEAP_SHARED 0x04000000UL    // put heap in shared memory

HANDLE g_hD3DHAL_DriverHeap = (HANDLE)NULL;

#define MEMINIT    {g_hD3DHAL_DriverHeap = (HANDLE)HeapCreate(HEAP_SHARED, 0x2000, 0 );}
#define MEMFINI     (HeapDestroy (g_hD3DHAL_DriverHeap) ? (g_hD3DHAL_DriverHeap = NULL, TRUE) : (g_hD3DHAL_DriverHeap = NULL, FALSE))
#define MEMCHECK    (g_hD3DHAL_DriverHeap ? TRUE : FALSE)



// Defaults
#define DDRV_DEFAULT_SIZE    4
#define DDRV_DEFAULT_DELTA   4

#define NOT_FOUND ((DWORD)-1)

typedef struct __ddrvitemarraydata {
    void    *pBase;         // Pointer to array of Items
    BOOL    *pValid;        // Pointer to boolean array of valid items
    DWORD   dwSize;         // Size of each Item in array (in Bytes)
    DWORD   dwDelta;        // Growth Factor of array
    DWORD   dwNumItems;     // Num of items in array
    BOOL    bValidArray;    // Is this array in use ???
} DDRVITEMARRAYDATA, *LPDDRVITEMARRAYDATA;

LPDDRVITEMARRAYDATA pArrays = 0;
DWORD dwNumArrays = 0;


/*
**-----------------------------------------------------------------------------
** Name:    DDrvItemArrayInit
** Purpose: Creates an array of item arrays
**-----------------------------------------------------------------------------
*/

BOOL
DDrvItemArrayInit ()
{
    // Initialize Memory ?!?
    if (! MEMCHECK) {
        MEMINIT;
        if (! MEMCHECK) {
            return FALSE;
        }
    }

    // Create Starting Arrays
    if (!pArrays) {
        pArrays = (LPDDRVITEMARRAYDATA) MEMALLOC (DDRV_DEFAULT_SIZE * sizeof(DDRVITEMARRAYDATA));
        if (! pArrays) {
            return FALSE;
        }

        dwNumArrays = DDRV_DEFAULT_SIZE;
    }
    return TRUE;
}


/*
**-----------------------------------------------------------------------------
** Name:    DDrvItemArrayFini
** Purpose: Destroys an array of item arrays
**-----------------------------------------------------------------------------
*/

BOOL
DDrvItemArrayFini ()
{
    BOOL ret;

    if (! MEMCHECK) {
        return TRUE;
    }

    // Cleanup Memory ?!?
    ret = MEMFINI;
    return ret;
}



/*
**-----------------------------------------------------------------------------
** Name:    DDrvItemArrayCreate
** Purpose: Creates a new item array, returns handle to new array
**-----------------------------------------------------------------------------
*/

BOOL
DDrvItemArrayCreate (DWORD nItems, DWORD dwSize,
                     DWORD dwDelta, LPHDDRVITEMARRAY phArray)
{
    DWORD i;

    // Find first empty array
    for (i = 0; i < dwNumArrays; i += 1)
        if (! pArrays[i].bValidArray)
            break;

    // If no empty arrays, then grow number of arrays
    if (i == dwNumArrays) {
        LPDDRVITEMARRAYDATA newArrays = (LPDDRVITEMARRAYDATA) MEMALLOC ((dwNumArrays+DDRV_DEFAULT_DELTA)*sizeof(DDRVITEMARRAYDATA));
        if (! newArrays) {
            return FALSE;
        }

        MEMCOPY(newArrays, pArrays, dwNumArrays * sizeof(DDRVITEMARRAYDATA));
        MEMFREE(pArrays);

        pArrays = newArrays;
        dwNumArrays += DDRV_DEFAULT_DELTA;
    }

    // Create new array of items
    dwSize = (dwSize + 7) & ~7;

    pArrays[i].pBase = MEMALLOC (nItems*dwSize);
    if (! pArrays[i].pBase) {
        return FALSE;
    }

    pArrays[i].pValid = (BOOL *) MEMALLOC (nItems * sizeof(BOOL));
    if (! pArrays[i].pValid) {
        MEMFREE(pArrays[i].pBase);
        pArrays[i].pBase = NULL;
        return FALSE;
    }

    pArrays[i].dwSize       = dwSize;
    pArrays[i].dwDelta      = dwDelta;
    pArrays[i].dwNumItems   = nItems;
    pArrays[i].bValidArray  = TRUE;

    *phArray = (i+1);
    return TRUE;
}


/*
**-----------------------------------------------------------------------------
** Name:    DDrvItemArrayDestroy
** Purpose: Destroys an item array
**-----------------------------------------------------------------------------
*/

BOOL
DDrvItemArrayDestroy (HDDRVITEMARRAY hArray)
{
    DWORD dwArray = hArray - 1;
    LPDDRVITEMARRAYDATA lpArray = pArrays + dwArray;

    if ((dwArray >= dwNumArrays) || (! lpArray->bValidArray))
    {
        return FALSE;
    }

    // Destroy array of items
    if (lpArray->pValid) {
        MEMFREE (lpArray->pValid);
        lpArray->pValid = NULL;
    }

    if (lpArray->pBase) {
        MEMFREE (lpArray->pBase);
        lpArray->pBase = NULL;
    }

    lpArray->bValidArray = FALSE;
    return TRUE;
}



/*
**-----------------------------------------------------------------------------
** Name:    DDrvItemArrayDestroy
** Purpose: Flushes an item array by marking all item slots
**          as empty
**-----------------------------------------------------------------------------
*/

BOOL
DDrvItemArrayFlush (HDDRVITEMARRAY hArray)
{
    DWORD i;
    DWORD dwArray = hArray - 1;
    LPDDRVITEMARRAYDATA lpArray = pArrays + dwArray;

    if ((dwArray >= dwNumArrays) || (! lpArray->bValidArray))
    {
        return FALSE;
    }

    // Mark all items in array as empty
    for (i = 0; i < lpArray->dwNumItems; i++) {
        lpArray->pValid[i] = FALSE;
    }

    return TRUE;
}



/*
**-----------------------------------------------------------------------------
** Name:    DDrvItemArrayAlloc
** Purpose: Creates a new item in specified item array
**-----------------------------------------------------------------------------
*/

BOOL
DDrvItemArrayAlloc (HDDRVITEMARRAY hArray, LPHDDRVITEM lphItem)
{
    DWORD dwArray = hArray - 1;
    DWORD i;
    LPDDRVITEMARRAYDATA lpArray = pArrays + dwArray;

    if ((dwArray >= dwNumArrays) || (! lpArray->bValidArray))
    {
        return FALSE;
    }

    // Find first empty item in array
    for (i = 0; i < lpArray->dwNumItems; i++) {
        if (! (lpArray->pValid[i]))
            break;
    }

    // If no empty items in array
    // then grow array
    if (i == lpArray->dwNumItems) {
        BOOL * newpValid;
        LPVOID newpBase;
        DWORD  dwNewSize = lpArray->dwNumItems + lpArray->dwDelta;

        // Check for static array
        if (! lpArray->dwDelta) {
            return FALSE;
        }

        newpBase = MEMALLOC (dwNewSize * lpArray->dwSize);
        if (! newpBase) {
            return FALSE;
        }

        newpValid = (BOOL *) MEMALLOC ((dwNewSize) * sizeof(BOOL));
        if (! newpValid) {
            MEMFREE (newpBase);
            return FALSE;
        }

        MEMCOPY (newpValid, lpArray->pValid, lpArray->dwNumItems * sizeof(DWORD));
        MEMCOPY (newpBase, lpArray->pBase, lpArray->dwNumItems * lpArray->dwSize);

        MEMFREE (lpArray->pValid);
        lpArray->pValid = newpValid;

        MEMFREE (lpArray->pBase);
        lpArray->pBase  = newpBase;

        lpArray->dwNumItems += lpArray->dwDelta;
    }

    // Return handle to item
    lpArray->pValid[i] = TRUE;
    *lphItem = i+1;
    return TRUE;
}

/*
**-----------------------------------------------------------------------------
** Name:    DDrvItemArrayGetPtr
** Purpose: Gets a pointer to item in item array
**-----------------------------------------------------------------------------
*/

LPVOID
DDrvItemArrayGetPtr (HDDRVITEMARRAY hArray, HDDRVITEM hItem)
{
    DWORD dwItem    = hItem - 1;
    DWORD dwArray   = hArray - 1;
    LPDDRVITEMARRAYDATA lpArray = pArrays + dwArray;

    if (hArray >= dwNumArrays ||
        lpArray->bValidArray == FALSE ||
        dwItem >= lpArray->dwNumItems ||
        lpArray->pValid[dwItem] == FALSE) {
        return NULL;
    }

    // Return pointer to item
    return ((char *)(lpArray->pBase) + dwItem * lpArray->dwSize);
}



/*
**-----------------------------------------------------------------------------
** Name:    DDrvItemArrayFree
** Purpose: Frees item from item array
**-----------------------------------------------------------------------------
*/

BOOL
DDrvItemArrayFree (HDDRVITEMARRAY hArray, HDDRVITEM hItem)
{
    DWORD dwItem  = hItem - 1;
    DWORD dwArray = hArray - 1;
    LPDDRVITEMARRAYDATA lpArray = pArrays + dwArray;

    if (hArray >= dwNumArrays ||
        lpArray->bValidArray == FALSE ||
        dwItem >= lpArray->dwNumItems ||
        lpArray->pValid[dwItem] == FALSE) {
        return FALSE;
    }

    // Set valid flag to false
    lpArray->pValid[dwItem] = FALSE;
    return TRUE;
}



/*
**-----------------------------------------------------------------------------
** Name:    DDrvItemFindFirstValid
** Purpose: Finds first valid item in array
**-----------------------------------------------------------------------------
*/

BOOL
DDrvItemArrayFindFirstValid (
    HDDRVITEMARRAY  hArray,
    LPHDDRVITEM     lpNextValid)
{
    DWORD i;
    DWORD dwArray = hArray - 1;
    LPDDRVITEMARRAYDATA lpArray = pArrays + dwArray;

    if ((dwArray >= dwNumArrays) || (! lpArray->bValidArray))
    {
        return FALSE;
    }

    // Find first valid array item
    for (i = 0; i < lpArray->dwNumItems; i++) {
        if (lpArray->pValid[i]) {
            if (lpNextValid) {
                *lpNextValid = i + 1;
            }
            return TRUE;
        }
    }

    return FALSE;
} // End Find First Valid


/*
**-----------------------------------------------------------------------------
** Name:    DDrvItemFindNextValid
** Purpose: Finds next valid item in array,
**          after specified start item
**-----------------------------------------------------------------------------
*/

BOOL
DDrvItemArrayFindNextValid (
    HDDRVITEMARRAY  hArray,
    HDDRVITEM       hStartFrom,
    LPHDDRVITEM     lpNextValid)
{
    DWORD i;
    DWORD dwArray = hArray - 1;
    LPDDRVITEMARRAYDATA lpArray = pArrays + dwArray;

    if ((dwArray >= dwNumArrays) || (! lpArray->bValidArray))
    {
        return FALSE;
    }

    // Find next valid array item after hStartFrom
    for (i = hStartFrom; i < lpArray->dwNumItems; i++) {
        if (lpArray->pValid[i]) {
            if (lpNextValid) {
                *lpNextValid = i + 1;
            }
            return TRUE;
        }
    }

    return FALSE;
} // End Find Next Valid


/*
**-----------------------------------------------------------------------------
** Name:    DDrvItemArrayApplyValid
** Purpose: Apply specified callback to each valid item in array
**-----------------------------------------------------------------------------
*/

BOOL
DDrvItemArrayApplyValid (
    HDDRVITEMARRAY  hArray,
    DDRVAPPLYFUNC   lpCallback,
    DWORD           dwExtra)
{
    DWORD i;
    DWORD dwRet;
    DWORD dwArray = hArray - 1;
    DWORD dwSuccessCount;
    LPDDRVITEMARRAYDATA lpArray = pArrays + dwArray;

    dwSuccessCount = 0;
    if ((dwArray >= dwNumArrays) || (! lpArray->bValidArray))
        return (dwSuccessCount);

    if (! lpCallback)
        return (dwSuccessCount);

    for (i = 0; i < lpArray->dwNumItems; i++) {
        if (lpArray->pValid[i]) {

            // Call user callback
            dwRet = (*lpCallback)(((char *)(lpArray->pBase) + (i * lpArray->dwSize)),
                                  (i+1),
                                  dwExtra);

            // Check Return Value
            switch (dwRet)
            {
            case DDRV_SUCCESS_CONTINUE:
                dwSuccessCount++;
                break;
            case DDRV_ERROR_CONTINUE:
                break;

            case DDRV_SUCCESS_STOP:
                return (dwSuccessCount);

            case DDRV_ERROR_STOP:
            default:
                return (dwSuccessCount);
            }
        }
    }

    return (dwSuccessCount);
} // End DDrvItemArrayApplyValid


/*
**-----------------------------------------------------------------------------
** Name:    DDrvItemApplyAll
** Purpose: Apply specified callback to each item in array
**-----------------------------------------------------------------------------
*/

BOOL
DDrvItemArrayApplyAll (
    HDDRVITEMARRAY  hArray,
    DDRVAPPLYFUNC   lpCallback,
    DWORD           dwExtra)
{
    DWORD i;
    DWORD dwRet;
    DWORD dwArray = hArray - 1;
    DWORD dwSuccessCount;
    LPDDRVITEMARRAYDATA lpArray = pArrays + dwArray;

    dwSuccessCount = 0;
    if ((dwArray >= dwNumArrays) || (! lpArray->bValidArray))
        return (dwSuccessCount);

    if (! lpCallback)
        return (dwSuccessCount);

    for (i = 0; i < lpArray->dwNumItems; i++) {
        // Call user callback
        dwRet = (*lpCallback)(((char *)(lpArray->pBase) + (i * lpArray->dwSize)),
                              (i+1),
                              dwExtra);

        // Check Return Value
        switch (dwRet)
        {
        case DDRV_SUCCESS_CONTINUE:
            dwSuccessCount++;
            break;
        case DDRV_ERROR_CONTINUE:
            break;

        case DDRV_SUCCESS_STOP:
            return (dwSuccessCount);

        case DDRV_ERROR_STOP:
        default:
            return (dwSuccessCount);
        }
    }

    return (dwSuccessCount);
} // End DDrvItemArrayApplyAll

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\ddFlip.cpp ===
/***************************************************************************\
* Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
*  Portions: Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
*
* Module: ddFlip.cpp                                                        *
*                                                                           *
*****************************************************************************
*  Content:    DirectDraw HAL surface flipping support
*                                                                           *
* History:                                                                  *
*       schaefer           7/6/99                                           *
*                                                                           *
\***************************************************************************/

#include "nvprecomp.h"
#include "wincommon.h"

extern DWORD __stdcall ConvertOverlay32 ( LPDDRAWI_DDRAWSURFACE_LCL, BOOL waitForCompletion, LPDWORD lpDstYOffset);

extern BOOL pmAddProcess(GLOBALDATA *pDriverData, DWORD processID);
extern BOOL pmDeleteProcess(DWORD processID);

extern BOOL ResetTwinViewState(GLOBALDATA *pDriverData);

//---------------------------------------------------------------------------

inline DWORD getFlipCountNotifier()
{
    // since the notifier buffers are used for alternate flips,
    // each notifier buffer will increment in steps of two.
    // we must check both and return the larger of the two

    // in the multihead case, there are also two dac objects.
    // in clone mode we must wait for both dacs to finish,
    // so we use the smaller of the two dac object notifiers

    if ((pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE) ||
        (pDriverData->dwDesktopState == NVTWINVIEW_STATE_SPAN))
    {
        NvNotification *pNotifierFlat1 = &pDriverData->pDmaFlipPrimaryNotifierFlat[0 * 16]; // head 0
        NvNotification *pNotifierFlat2 = &pDriverData->pDmaFlipPrimaryNotifierFlat[1 * 16]; // head 1
        DWORD dwCount1 = max(pNotifierFlat1[1].info32, pNotifierFlat1[2].info32);
        DWORD dwCount2 = max(pNotifierFlat2[1].info32, pNotifierFlat2[2].info32);

        return min(dwCount1, dwCount2);
    }
    else
    {
        DWORD dwHead = GET_CURRENT_HEAD();
        NvNotification *pNotifierFlat = &pDriverData->pDmaFlipPrimaryNotifierFlat[dwHead * 16];

        return max(pNotifierFlat[1].info32, pNotifierFlat[2].info32);
    }
}

//---------------------------------------------------------------------------

/*
 * getFlipStatusPrimary
 *
 * Checks if the most recent flip on the given primary surface has completed.
 * If the given primary is 0, checks for pending flips on any surface
 */

HRESULT __stdcall getFlipStatusPrimary (FLATPTR fpVidMem)
{

#if (NVARCH >= 0x010) && defined(HWFLIP)

    DWORD dwCurrentIndex, dwIndex;

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_1196_CELSIUS | NVCLASS_0096_CELSIUS | NVCLASS_FAMILY_KELVIN))
#else
    if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_1196_CELSIUS | NVCLASS_0096_CELSIUS))
#endif
    {
        DWORD dwQueuedFlips, dwFlipCountNotifier;

        dwFlipCountNotifier = getFlipCountNotifier();
        if (CURRENT_FLIP >= dwFlipCountNotifier) {
            dwQueuedFlips = CURRENT_FLIP - dwFlipCountNotifier;
        }
        else { // handle the wrap around case
            dwQueuedFlips = dwFlipCountNotifier - CURRENT_FLIP;
        }

        if (dwQueuedFlips && (fpVidMem == FLIP_ANYSURFACE))
            return DDERR_WASSTILLDRAWING;

        dwCurrentIndex = getDC()->flipHistory.dwIndex;
        for (DWORD i = 0; i < dwQueuedFlips; i++) {
            dwIndex = (dwCurrentIndex - i) & FLIP_HISTORY_MASK;
#ifdef CHECK_FLIP_TO
            if ((getDC()->flipHistory.surfacesFrom[dwIndex] == fpVidMem) ||
                (getDC()->flipHistory.surfacesTo[dwIndex]   == fpVidMem)) {
        return (DDERR_WASSTILLDRAWING);
            }
#else
            if (getDC()->flipHistory.surfacesFrom[dwIndex] == fpVidMem) {
                return (DDERR_WASSTILLDRAWING);
            }
#endif
        }

        return (DD_OK);
    }

#endif  // HWFLIP

    /*
     * see if a flip has happened recently
     */
    if (getDC()->flipPrimaryRecord.bFlipFlag &&
        ((fpVidMem == FLIP_ANYSURFACE) || (fpVidMem == getDC()->flipPrimaryRecord.fpFlipFrom)) ) {

        NvNotification *pDmaFlipPrimaryNotifier = pDriverData->pDmaFlipPrimaryNotifierFlat;

        // D3D: if VSYNC is forced off, we always advertise that flips have completed
        //      this can break ddraw apps and maybe even fail WHQL - therefore
        //      we do not recommend VSYNC ever be disabled by default
        if (getDC()->nvD3DRegistryData.regVSyncMode == D3D_REG_VSYNCMODE_FORCEOFF) {
            return DD_OK;
        }

        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_5) {
            if (((volatile)pDmaFlipPrimaryNotifier[1].status == NV_IN_PROGRESS) ||
                ((volatile)pDmaFlipPrimaryNotifier[2].status == NV_IN_PROGRESS))
                return (DDERR_WASSTILLDRAWING);
            else {
                pDriverData->CurrentVisibleSurfaceAddress = getDC()->flipPrimaryRecord.fpFlipTo;
                getDC()->flipPrimaryRecord.bFlipFlag = FALSE;
                return (DD_OK);
            }
        }
        else {
            NvNotification *pDmaSyncNotifier = pDriverData->pDmaSyncNotifierFlat;
            /* pDmaSyncNotifier is used for NOVSYNC flips for devices < NV5 */
            if (((volatile)pDmaFlipPrimaryNotifier[1].status == NV_IN_PROGRESS) ||
                ((volatile)pDmaFlipPrimaryNotifier[2].status == NV_IN_PROGRESS) ||
                ((pDriverData->fIsBltStyleFlip) &&
                 (pDmaSyncNotifier->status == NV_IN_PROGRESS)))
                return (DDERR_WASSTILLDRAWING);
            else {
                pDriverData->CurrentVisibleSurfaceAddress = getDC()->flipPrimaryRecord.fpFlipTo;
                getDC()->flipPrimaryRecord.bFlipFlag = FALSE;
                return (DD_OK);
            }
        }
    }

    return (DD_OK);

} // getFlipStatusPrimary

//---------------------------------------------------------------------------

/*
 * getFrameStatusOverlay
 *
 * Checks if the most recent flip on the given overlay surface has occurred
 */

HRESULT __stdcall getFlipStatusOverlay (FLATPTR fpVidMem)
{
    int iIndex;

    if (getDC()->flipOverlayRecord.bFlipFlag &&
        ((fpVidMem == FLIP_ANYSURFACE) ||
         (fpVidMem == getDC()->flipOverlayRecord.fpFlipFrom) ||
         (fpVidMem == getDC()->flipOverlayRecord.fpPreviousFlipFrom)) ) {

        NvNotification *pPioFlipOverlayNotifier = pDriverData->pPioFlipOverlayNotifierFlat;

        if (pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) {
            if (fpVidMem == getDC()->flipOverlayRecord.fpPreviousFlipFrom) {
                // only need for one to flush out
                iIndex = pDriverData->vpp.overlayBufferIndex + 1;
                if (pPioFlipOverlayNotifier[iIndex].status == NV_IN_PROGRESS)
                    return (DDERR_WASSTILLDRAWING);
            } else {
                // need to wait for both flips to flush out
                if (((volatile)pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) ||
                    ((volatile)pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) {
                    return (DDERR_WASSTILLDRAWING);
                } else {
                    getDC()->flipOverlayRecord.bFlipFlag = FALSE;
                }
            }
        } else {
            if (fpVidMem == getDC()->flipOverlayRecord.fpPreviousFlipFrom) {
/* The WHQL flip status test doesn't like this conservatism.  Comment out for now.
                LONGLONG timeNow;
                // only need for one to flush out, no way to really determine this on NV10,
                // but if we wait at least one CRTC refresh since it was issued, we can
                // guarantee it has been flushed through
                if ((pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) &&
                    (pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) {
                    QueryPerformanceCounter((LARGE_INTEGER *) &timeNow);
                    if ((timeNow - getDC()->flipOverlayRecord.llFlipTime) < (getDC()->flipPrimaryRecord.dwFlipDuration * 2)) {
                        return (DDERR_WASSTILLDRAWING);
                    }
                }
*/
            } else {
                if (fpVidMem == getDC()->flipOverlayRecord.fpFlipFrom) {
                    LONGLONG timeNow = 0x7FFFFFFFFFFFFFFF;
                    DWORD    dwTimeoutCount;

                    // We use different timeout values for 640x480 and higher res modes.
                    if (GET_MODE_HEIGHT() <= 480)
                        dwTimeoutCount = 4;
                    else
                        dwTimeoutCount = 16;

                    // need to wait for both flips to flush out
                    if (((volatile)pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) &&
                        ((volatile)pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) {
                        LONGLONG timeNow = 0x7FFFFFFFFFFFFFFF;

                        // If notifiers don't get set for two CRTC refresh times, time out and return success.
                        QueryPerformanceCounter((LARGE_INTEGER *) &timeNow);
                        if ((timeNow - getDC()->flipOverlayRecord.llFlipTime) < (getDC()->flipPrimaryRecord.dwFlipDuration * dwTimeoutCount)) {
                            return (DDERR_WASSTILLDRAWING);
                        }
                        else {
                            getDC()->flipOverlayRecord.bFlipFlag = FALSE;

                            // Reset notifiers that may be stuck.
                            pPioFlipOverlayNotifier[1].status = 0;
                            pPioFlipOverlayNotifier[2].status = 0;
                        }
                    } else {
                        getDC()->flipOverlayRecord.bFlipFlag = FALSE;
                    }
                }
            }
        }
        return (DD_OK);
    }

    return (DD_OK);

} // getFrameStatusOverlay

//---------------------------------------------------------------------------

// update frame status on surface of indeterminate type

HRESULT __stdcall getFlipStatus (FLATPTR fpVidMem, DWORD dwType)
{
    if (dwType & (DDSCAPS_OVERLAY | DDSCAPS_VIDEOPORT)) {
        return getFlipStatusOverlay (fpVidMem);
    }
    else {
        return getFlipStatusPrimary (fpVidMem);
    }
}

//---------------------------------------------------------------------------

// GetFlipStatus32

DWORD __stdcall GetFlipStatus32 (LPDDHAL_GETFLIPSTATUSDATA lpGetFlipStatus)
{
    nvSetDriverDataPtrFromDDGbl (lpGetFlipStatus->lpDD);

    // validate device
    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        NvReleaseSemaphore(pDriverData);
        lpGetFlipStatus->ddRVal = DDERR_SURFACELOST;
        return (DDHAL_DRIVER_HANDLED);
    }

    // validate flags
    DWORD dwFlagsAll = (DDGFS_CANFLIP | DDGFS_ISFLIPDONE);
    DWORD dwFlagsSet = lpGetFlipStatus->dwFlags & dwFlagsAll;
    if ((dwFlagsSet == 0) || (dwFlagsSet == dwFlagsAll)) {
        DPF ("invalid params in GetBlitStatus32");
        NvReleaseSemaphore(pDriverData);
        lpGetFlipStatus->ddRVal = DDERR_INVALIDPARAMS;
        return (DDHAL_DRIVER_HANDLED);
    }

    if (dwFlagsSet & DDGFS_CANFLIP) {

        if (lpGetFlipStatus->lpDDSurface->ddsCaps.dwCaps & (DDSCAPS_OVERLAY | DDSCAPS_VIDEOPORT)) {

            // handle overlays and videoports
            LPPROCESSINFO lpProcInfo = pmGetProcess(pDriverData, GetCurrentProcessId());
            if ((IS_EVENT_ERROR(NvWaitEvent(lpProcInfo->hOvlFlipEvenEvent3, 0))) &&
                (IS_EVENT_ERROR(NvWaitEvent(lpProcInfo->hOvlFlipOddEvent3, 0)))) {
                lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;
            }
            /*
            NvNotification *pPioFlipOverlayNotifier = (NvNotification *)pDriverData->NvPioFlipOverlayNotifierFlat;
            iIndex = pDriverData->OverlayBufferIndex + 1;
            if (pPioFlipOverlayNotifier[iIndex].status == NV_IN_PROGRESS)
                lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;  */

        }

        else {

            // get flip status for the primary
#if (NVARCH >= 0x010) && defined(HWFLIP)
#if (NVARCH >= 0x020)
            if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_1196_CELSIUS | NVCLASS_0096_CELSIUS | NVCLASS_FAMILY_KELVIN))
#else
            if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_1196_CELSIUS | NVCLASS_0096_CELSIUS))
#endif
            {
                // with nv15 (etc), we can always flip
                lpGetFlipStatus->ddRVal = DD_OK;
            }
            else
#endif  // HWFLIP
            {
                // make sure we sync with other channels before writing put
                getDC()->nvPusher.setSyncChannelFlag();
                if (getDC()->nvPusher.isIdle(TRUE)) {
                    lpGetFlipStatus->ddRVal = DD_OK;
                }
                else {
                    nvPusherStart (TRUE);
                    lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;
                }
            }
        }
    }

    else {  // DDGFS_ISFLIPDONE

        // simply get flip status
        lpGetFlipStatus->ddRVal = getFlipStatus (lpGetFlipStatus->lpDDSurface->lpGbl->fpVidMem,
                                                 lpGetFlipStatus->lpDDSurface->ddsCaps.dwCaps);

        // OLD CODE FOR OVERLAYS ONLY:
        // (current thinking is that getFrameStatus always works)
        /*
                NvNotification *pPioFlipOverlayNotifier = (NvNotification *)pDriverData->NvPioFlipOverlayNotifierFlat;
                if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10)
                {
                    if (((pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) &&
                        (pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) &&
                        ((fpVidMem == getDC()->flipOverlayRecord.fpPreviousFlipFrom) ||
                         (fpVidMem == getDC()->flipOverlayRecord.fpFlipFrom) ||
                         (fpVidMem == getDC()->flipOverlayRecord.fpFlipTo) ||
                         (fpVidMem == NULL)))
                        lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;
                }
                else
                {
                    if (((pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) ||
                         (pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) &&
                        ((fpVidMem == getDC()->flipOverlayRecord.fpPreviousFlipFrom) ||
                         (fpVidMem == getDC()->flipOverlayRecord.fpFlipFrom) ||
                         (fpVidMem == getDC()->flipOverlayRecord.fpFlipTo) ||
                         (fpVidMem == NULL)))
                        lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;
                }
    */

    }

    NvReleaseSemaphore(pDriverData);
    return (DDHAL_DRIVER_HANDLED);

} // GetFlipStatus32

//---------------------------------------------------------------------------

// Check how many frames we are ahead
// we want to limit this since we have serious lag effect on fast CPUs.
// if we're too many frames ahead, we wait.
// free count for d3d stuff must be accurate

void nvCheckQueuedFlips (void)
{
    // max queued frames is regPreRenderLimit (defaults to 3 - PC99 spec)
    DWORD dwMaxQueuedFrames = getDC()->nvD3DRegistryData.regPreRenderLimit;

    // get HW frame #
    COMPLETED_FLIP = getFlipCountNotifier();

    // have we progressed too far?
    while (int(CURRENT_FLIP - COMPLETED_FLIP) > int(dwMaxQueuedFrames))
    {
        // kick off buffer
        nvPusherStart (TRUE);
        // wait for HW to catch up
        nvDelay();
        COMPLETED_FLIP = getFlipCountNotifier();
    }
}

//---------------------------------------------------------------------------

void nvUpdateFlipTracker (DWORD dwSurfaceFrom, DWORD dwSurfaceTo)
{
    // make a note of the fact that we've queued a flip or blit involving these surfaces
    getDC()->flipHistory.dwIndex ++;
    getDC()->flipHistory.dwIndex &= FLIP_HISTORY_MASK;
    getDC()->flipHistory.surfacesFrom[getDC()->flipHistory.dwIndex] = dwSurfaceFrom;
#ifdef CHECK_FLIP_TO
    getDC()->flipHistory.surfacesTo[getDC()->flipHistory.dwIndex]   = dwSurfaceTo;
#endif
    // update frame counters
    CURRENT_FLIP ++;
}

//---------------------------------------------------------------------------

// do a blit instead of a flip

void nvFlipBlit (LPDDHAL_FLIPDATA pfd)
{
    NvNotification *pDmaSyncNotifier = pDriverData->pDmaSyncNotifierFlat;

    DWORD dwSrcOffset = (DWORD)pfd->lpSurfTarg->lpGbl->fpVidMem - (DWORD)pDriverData->BaseAddress;
    DWORD dwDstOffset = (DWORD)pfd->lpSurfCurr->lpGbl->fpVidMem - (DWORD)pDriverData->BaseAddress;
    DWORD dwPitch     = (pfd->lpSurfTarg->lpGbl->lPitch  << 16) | pfd->lpSurfCurr->lpGbl->lPitch;
    DWORD dwDims      = (pfd->lpSurfCurr->lpGbl->wHeight << 16) | pfd->lpSurfCurr->lpGbl->wWidth;

    if (dwDstOffset == dwSrcOffset) dwDstOffset = 0;

    if (pDriverData->dwSharedClipChangeCount != pDriverData->dwDDMostRecentClipChangeCount) {

        nvPushData (0,dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000);
        nvPushData (1,NV_DD_IMAGE_BLACK_RECTANGLE);
        nvPushData (2,dDrawSubchannelOffset(NV_DD_SURFACES) + IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000);
        nvPushData (3,0);
        nvPushData (4,asmMergeCoords(NV_MAX_X_CLIP, NV_MAX_Y_CLIP));
        nvPushData (5,dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000);
        nvPushData (6,NV_DD_SURFACES_2D);

        nvPusherAdjust (7);
        nvPusherStart  (TRUE);

        pDriverData->dwSharedClipChangeCount++;

        pDriverData->dwDDMostRecentClipChangeCount = pDriverData->dwSharedClipChangeCount;
    }

    nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP) + SET_ROP_OFFSET | 0x40000);
    nvPushData (1,SRCCOPYINDEX);
    pDriverData->bltData.dwLastRop = SRCCOPYINDEX;

    nvPushData (2,dDrawSubchannelOffset(NV_DD_SURFACES) + SURFACES_2D_PITCH_OFFSET | 0xC0000);
    nvPushData (3,dwPitch);
    nvPushData (4,dwSrcOffset);
    nvPushData (5,dwDstOffset);
    pDriverData->bltData.dwLastCombinedPitch = dwPitch;
    pDriverData->bltData.dwLastSrcOffset = dwSrcOffset;
    pDriverData->bltData.dwLastDstOffset = dwDstOffset;

    nvPushData (6,dDrawSubchannelOffset(NV_DD_BLIT) + BLIT_POINT_IN_OFFSET | 0xC0000);
    nvPushData (7,0);
    nvPushData (8,0);
    nvPushData (9,dwDims);

    nvPusherAdjust (10);

    if (pfd->dwFlags & DDFLIP_NOVSYNC) {

        getDC()->flipPrimaryRecord.fpFlipFrom = pfd->lpSurfCurr->lpGbl->fpVidMem;
        getDC()->flipPrimaryRecord.fpFlipTo = pfd->lpSurfTarg->lpGbl->fpVidMem;
        getDC()->flipPrimaryRecord.bFlipFlag = TRUE;
        pDriverData->fIsBltStyleFlip = TRUE;

        pDmaSyncNotifier->status = NV_IN_PROGRESS;

        nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000);
        nvPushData (1,0);
        nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000);
        nvPushData (3,0);

        nvPusherAdjust (4);
    }

    nvUpdateFlipTracker (pfd->lpSurfCurr->lpGbl->fpVidMem, pfd->lpSurfTarg->lpGbl->fpVidMem);

    nvPusherStart (TRUE);

    // flip the vidmem pointers (so ddraw can flip them back)
    pfd->lpSurfCurr->lpGbl->fpVidMem = dwSrcOffset + (DWORD)pDriverData->BaseAddress;
    pfd->lpSurfTarg->lpGbl->fpVidMem = dwDstOffset + (DWORD)pDriverData->BaseAddress;

}

//---------------------------------------------------------------------------

void nvFlipPrimary (LPDDHAL_FLIPDATA pfd, BOOL bNoVSync)
{
    LPDDRAWI_DDRAWSURFACE_GBL   pSurfTarg_gbl;

    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        pfd->ddRVal = DDERR_SURFACELOST;
        return;
    }

    pSurfTarg_gbl = pfd->lpSurfTarg->lpGbl;

    // assume OK unless we find otherwise
    pfd->ddRVal = DD_OK;

#if (NVARCH >= 0x010) && defined(HWFLIP)

#if (NVARCH >= 0x020)

#ifdef KELVIN_SEMAPHORES
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        getDC()->nvFlipper.flip (&(getDC()->nvPusher), &(getDC()->nvPusherDAC),
                                 pfd->lpSurfCurr, pfd->lpSurfTarg, bNoVSync);
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_1196_CELSIUS | NVCLASS_0096_CELSIUS)) {
#else // !KELVIN_SEMAPHORES
    if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_1196_CELSIUS | NVCLASS_0096_CELSIUS | NVCLASS_FAMILY_KELVIN)) {
#endif // !KELVIN_SEMAPHORES

#else // !(NVARCH >= 0x020)

    if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_1196_CELSIUS | NVCLASS_0096_CELSIUS)) {

#endif // !(NVARCH >= 0x020)

        // tell the HW we want to start writing to the next buffer
        nvglSetNv15CelsiusSyncIncWrite (NV_DD_CELSIUS);

        // a bug in the HW requires a no-op here. otherwise the stall may
        // get processed before the write actually gets done.
        nvglSetNv10CelsiusNoOp (NV_DD_CELSIUS);

        PRIMARY_BUFFER_INDEX ^= 0x1;

        BOOL  bCloneMode = (pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE);
        BOOL  bSpanMode  = (pDriverData->dwDesktopState == NVTWINVIEW_STATE_SPAN);
        DWORD dwNumHeads = (bCloneMode || bSpanMode) ? pDriverData->dwHeads : 1;
        DWORD dwFormat   = (NV07C_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY << 31) |
                           (NV07C_SET_IMAGE_FORMAT_FLAGS_COMPLETE_ON_OBJECT_CLEANUP << 25) |
                           pSurfTarg_gbl->lPitch;
        dwFormat |= bNoVSync   ? (NV07C_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY << 20) :
                                 (NV07C_SET_IMAGE_FORMAT_WHEN_NOT_WITHIN_BUFFER << 20);
        dwFormat |= (bCloneMode || bSpanMode) ? (NV07C_SET_IMAGE_FORMAT_MULTIHEAD_SYNC_ENABLED << 24) :
                                                (NV07C_SET_IMAGE_FORMAT_MULTIHEAD_SYNC_DISABLED << 24);

        for (DWORD dwLogicalHead = 0; dwLogicalHead < dwNumHeads; dwLogicalHead++) {
            // calculate offset, the RM will add the pan & scan adjustment from the display driver if needed
            DWORD dwOffset = pSurfTarg_gbl->fpVidMem - pDriverData->BaseAddress;
#ifdef WINNT
            DWORD dwDAC          = NV_DD_VIDEO_LUT_CURSOR_DAC;
            DWORD dwPhysicalHead = ppdev->ulDeviceDisplay[dwLogicalHead];
#else // !WINNT
            DWORD dwDAC          = NV_DD_VIDEO_LUT_CURSOR_DAC + (bCloneMode ? 0 : GET_CURRENT_HEAD());
            DWORD dwPhysicalHead = dwLogicalHead;
#endif // !WINNT

            if (bSpanMode) {
                // add the span mode offset
                dwOffset += GET_SPAN_OFFSET(dwPhysicalHead);
            }

            // program the flip
            nvglSetObject (NV_DD_SURFACES, dwDAC + dwPhysicalHead); // load the DAC object
            nvglSetNv15VideoLUTCursorDACImageData (NV_DD_SURFACES, PRIMARY_BUFFER_INDEX, dwOffset , dwFormat);
        }

        // stall the graphics pipe until we've flipped away from the buffer we want to write to
        nvglSetNv15CelsiusSyncStall (NV_DD_CELSIUS);

        // put back the NV_DD_SURFACES_2D object
        nvglSetObject (NV_DD_SURFACES, NV_DD_SURFACES_2D);
    }

    else
#endif  // HWFLIP
    {
        NvNotification *pDmaSyncNotifier        = pDriverData->pDmaSyncNotifierFlat;
        NvNotification *pDmaFlipPrimaryNotifier = pDriverData->pDmaFlipPrimaryNotifierFlat;

        // find out if any previous flips are still pending
        HRESULT ddrval = getFlipStatusPrimary (FLIP_ANYSURFACE);

        if (ddrval != DD_OK) {
            // flush the push buffer if we haven't yet done so for this particular flip
            if (!(pDriverData->fDmaPushBufferHasBeenFlushed)) {

                // make sure we sync with other channels before writing put
                getDC()->nvPusher.setSyncChannelFlag();

                // Let D3D code know that we have touched NV
                pDriverData->TwoDRenderingOccurred = 1;

                pDmaSyncNotifier->status = NV_IN_PROGRESS;
                nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000);
                nvPushData (1,0);
                nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000);
                nvPushData (3,0);

                nvPusherAdjust (4);
                nvPusherStart  (TRUE);

                pDriverData->fDmaPushBufferHasBeenFlushed = TRUE;
            }

            // if we've been instructed to wait, wait until we can do the flip and proceed
            // otherwise, just return the failure (the app will try again)
            if (pfd->dwFlags & DDFLIP_WAIT) {
                while (ddrval != DD_OK) {
                    NV_SLEEPFLIP;
                    ddrval = getFlipStatusPrimary(FLIP_ANYSURFACE);
                }
            }
            else {
                pfd->ddRVal = ddrval;
                return;
            }

        }

        // make sure we sync with other channels before writing put
        getDC()->nvPusher.setSyncChannelFlag();

        // we do not want this flip to wait for itself
        getDC()->nvPusher.clearSyncFlipFlag();

        PRIMARY_BUFFER_INDEX ^= 0x1;

        if (!bNoVSync) {
            pDmaFlipPrimaryNotifier[PRIMARY_BUFFER_INDEX + 1].status = NV_IN_PROGRESS;
        }

        // Temporarily load VIDEO_LUT_CURSOR_DAC object
        nvPushData (0,dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000);
        nvPushData (1,NV_DD_VIDEO_LUT_CURSOR_DAC);
        nvPushData (2,dDrawSubchannelOffset(NV_DD_SURFACES) + NV067_SET_IMAGE_OFFSET(PRIMARY_BUFFER_INDEX) | 0x80000);
        nvPushData (3,pSurfTarg_gbl->fpVidMem - pDriverData->BaseAddress);
        if (bNoVSync) {
            nvPushData (4,(NV067_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY << 31) |
                          (NV067_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY << 20)  |
                          pSurfTarg_gbl->lPitch);
        }
        else {
            nvPushData (4,(NV067_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY << 31)      |
                          (NV067_SET_IMAGE_FORMAT_WHEN_NOT_WITHIN_BUFFER << 20) |
                          pSurfTarg_gbl->lPitch);
        }
        // put back the NV_DD_SURFACES2D object
        nvPushData (5,dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000);
        nvPushData (6,NV_DD_SURFACES_2D);

        nvPusherAdjust (7);

        getDC()->flipPrimaryRecord.fpFlipFrom = pfd->lpSurfCurr->lpGbl->fpVidMem;
        getDC()->flipPrimaryRecord.fpFlipTo   = pSurfTarg_gbl->fpVidMem;
        getDC()->flipPrimaryRecord.bFlipFlag  = TRUE;

        pDriverData->fDmaPushBufferHasBeenFlushed = FALSE;
    }

    // make a note of the fact that we've advanced a frame
    nvUpdateFlipTracker (pfd->lpSurfCurr->lpGbl->fpVidMem, pfd->lpSurfTarg->lpGbl->fpVidMem);

    // get things started
    nvPusherStart (TRUE);
#if (NVARCH >= 0x020)
#ifdef KELVIN_SEMAPHORES
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
#ifdef NV_PROFILE_PUSHER
        nvpSetLogPusher(false);
#endif
        getDC()->nvPusherDAC.start (TRUE);
#ifdef NV_PROFILE_PUSHER
        nvpSetLogPusher(true);
#endif
    }
#endif
#endif

    DPF_LEVEL (NVDBG_LEVEL_SURFACE, "nvFlipPrimary: RGB Flip request completed successfully");
}

//---------------------------------------------------------------------------

/* NOTES:
 *
 * When flipping overlay surfaces NOT associated with a video port
 * the surface will be flipped according to the following criteria.
 * DDOVER_INTERLEAVED and DDOVER_BOB values used are those set on most
 * recent UpdateOverlay32 call referencing this overlay surface.
 *
 *  DDOVER_INTERLEAVED  DDOVER_BOB  DDFLIP_EVEN DDFLIP_ODD  DISPLAYED
 *
 *          1               1            1          0       Even field
 *          1               1            X          1       Odd field with BOB
 *          1               1            0          0       Full interleaved surface
 *          1               0            1          0       Even field
 *          1               0            X          1       Odd field
 *          1               0            0          0       Full interleaved surface
 *          0               1            X          X       Full non-interleaved surface
 *          0               0            X          X       Full non-interleaved surface
 */

void nvFlipOverlay (LPDDHAL_FLIPDATA pfd)
{
    LPDDRAWI_DDRAWSURFACE_LCL   lpSurfTarg;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurfTarg_gbl;

    DWORD   dwVPPFlags;
#ifndef WINNT
    DWORD   dwSavedNBData;
#endif
    HRESULT ddrval;

    dbgTracePush ("nvFlipOverlay");

    lpSurfTarg    = pfd->lpSurfTarg;
    pSurfTarg_gbl = lpSurfTarg->lpGbl;

    // presume OK unless we find otherwise
    pfd->ddRVal = DD_OK;

#ifdef WINNT
    // WIN2K HACK: DX7 under win2k presents incorrect flags, so manually fix them
    if (pfd->lpSurfCurr) {
        pfd->lpSurfCurr->ddsCaps.dwCaps &= ~(DDSCAPS_VISIBLE | DDSCAPS_FRONTBUFFER);
        pfd->lpSurfCurr->ddsCaps.dwCaps |= DDSCAPS_BACKBUFFER;
    }
    lpSurfTarg->ddsCaps.dwCaps |= DDSCAPS_VISIBLE | DDSCAPS_FRONTBUFFER;
    lpSurfTarg->ddsCaps.dwCaps &= ~DDSCAPS_BACKBUFFER;

    // WIN2K HACK: More flags that aren't set properly by Win2K DX7:
    // dwOverlayFlags may have Bob and Interleaved flags set for some overlay buffers in
    // the flip chain but not others.  We need to fix them for Bob mode to work later on.
    if ((lpSurfTarg->lpGbl->ddpfSurface.dwFourCC == FOURCC_NV12) && (lpSurfTarg->lpSurfMore)) {
        if (pfd->dwFlags & (DDFLIP_ODD | DDFLIP_EVEN)) {
            pfd->lpSurfTarg->lpSurfMore->dwOverlayFlags |= DDOVER_INTERLEAVED;
            pfd->lpSurfTarg->lpSurfMore->dwOverlayFlags |= DDOVER_BOB;
        }
        else {
            pfd->lpSurfTarg->lpSurfMore->dwOverlayFlags &= ~DDOVER_INTERLEAVED;
            pfd->lpSurfTarg->lpSurfMore->dwOverlayFlags &= ~DDOVER_BOB;
        }
    }

#endif WINNT

    pDriverData->vpp.dwOverlayLastVisibleSurfaceLCL = (DWORD) lpSurfTarg;
    pDriverData->vpp.dwOverlayLastVisibleFpVidMem = pSurfTarg_gbl->fpVidMem;
    pDriverData->vpp.dwOverlayLastVisiblePitch = pSurfTarg_gbl->lPitch;
    pDriverData->vpp.dwOverlayLastVisiblePixelFormat = pSurfTarg_gbl->ddpfSurface.dwFourCC;

    if (pDriverData->vpp.dwOverlayFSHead == 0xFFFFFFFE &&
        pDriverData->vpp.dwOverlayFSTwinData.nvtwPhysicalModeImmediate.pHWCrtcCX == 0) {
        // TwinView state has changed while video mirror enabled, make the app reinstantiate the overlay
        pfd->ddRVal = DDERR_SURFACELOST;
    }

    // Do some DirectShow compatibility stuff
    if (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_NVMC) {
#if (NVARCH >= 0x10)
        dbgTracePop();
        return;
#endif  // NVARCH >= 0x10
    }

    else if ((pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_NV12) || (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_NVDS)) {

        LPNVMCSURFACEFLAGS lpSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

#if (NVARCH >= 0x10)

        if (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_NVDS) {
            LPNVMCFRAMEDATA lpNvMCFrameData = (LPNVMCFRAMEDATA) VIDMEM_ADDR(pSurfTarg_gbl->fpVidMem);
            DWORD dwIndex = lpNvMCFrameData->bMCDestinationSurfaceIndex;
            if (dwIndex >= 8) {
                dbgTracePop();
                return;
            }
            lpSurfTarg = (LPDDRAWI_DDRAWSURFACE_LCL)(pDriverData->dwMCNV12Surface[dwIndex]);
            pSurfTarg_gbl = lpSurfTarg->lpGbl;

            // Check for mode switches and full screen DOS interruptions
            if (pDriverData->dwMCDestinationSurface == 0) {
                pfd->ddRVal = DDERR_SURFACELOST;
                dbgTracePop();
                return;
            }
        }

        while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
               (lpSurfaceFlags->dwMCSurfaceBase != pSurfTarg_gbl->fpVidMem)) {
            lpSurfaceFlags++;
        }

        // If this is an NV12 surface and DXVA Back End alpha blending is enabled,
        // perform an alpha blend operation on this frame.
        if ((pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_NV12) &&
            (pDriverData->dwDXVAFlags & DXVA_BACK_END_ALPHA_ENABLED) &&
            pDriverData->dwMCNVMCSurface) {

            // Make sure you only blend each frame once -- in Bob mode we get two Flips per frame.
            if (lpSurfaceFlags->bMCFrameIsComposited == FALSE) {
                nvDXVABackEndAlphaBlend(lpSurfTarg->lpGbl->fpVidMem);
                lpSurfaceFlags->bMCFrameIsComposited = TRUE;
            }
        }

        // Make sure the surface has been format converted
        if ((lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) &&
            (lpSurfaceFlags->bMCFrameAlreadyFormatConverted < 15))
            nvMoCompConvertSurfaceFormat(pSurfTarg_gbl->fpVidMem, TRUE, 15);
        else if ((lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD) &&
            ((lpSurfaceFlags->bMCFrameAlreadyFormatConverted & 3) < 3))
            nvMoCompConvertSurfaceFormat(pSurfTarg_gbl->fpVidMem, TRUE, 3);
        else if ((lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_BOTTOM_FIELD) &&
            (lpSurfaceFlags->bMCFrameAlreadyFormatConverted < 12))
            nvMoCompConvertSurfaceFormat(pSurfTarg_gbl->fpVidMem, TRUE, 12);

        if ((lpSurfaceFlags->bMCFrameAlreadyFormatConverted == 15) &&
            (lpSurfaceFlags->bMCFrameIsFiltered == FALSE) &&
            (lpSurfaceFlags->bMCFrameIsComposited == FALSE) &&
            (pDriverData->bMCTemporalFilterDisabled == FALSE) &&
            ((pfd->dwFlags & (DDFLIP_ODD | DDFLIP_EVEN)) != 0))
            nvMoCompTemporalFilter(pSurfTarg_gbl->fpVidMem, pDriverData->bMCPercentCurrentField);

#endif  // NVARCH >= 0x10

        if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
            pfd->ddRVal = DDERR_SURFACELOST;
            dbgTracePop();
            return;
        }

        // Wait for the surface to finish format conversion.
        getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                       lpSurfaceFlags->dwMCFormatCnvReferenceCount);

        // If this is a composited surface, wait for it to finish compositing.
        if (lpSurfaceFlags->bMCFrameIsComposited) {
            getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                      lpSurfaceFlags->dwMCCompositeReferenceCount);
        }

        // If this is a filtered surface, wait for it to finish filtering.
        if (lpSurfaceFlags->bMCFrameIsFiltered) {
            getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                           lpSurfaceFlags->dwMCTemporalFilterReferenceCount);
        }

        // Check if filtering is disabled on this surface for this display call only
        if (lpSurfaceFlags->bMCFrameType & TEMPORAL_FILTER_DISABLE_ON_SINGLE_SURFACE) {
            lpSurfaceFlags->bMCFrameIsFiltered = FALSE;
            lpSurfaceFlags->bMCFrameType &= ~TEMPORAL_FILTER_DISABLE_ON_SINGLE_SURFACE;
        }

        // Always display non-filtered portion of non-interleaved frames
        if ((pfd->dwFlags & (DDFLIP_ODD | DDFLIP_EVEN)) == 0) {
            if (lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_FRAME)
                lpSurfaceFlags->bMCFrameIsFiltered = FALSE;
        }
    }

    if ((getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) ||
        pDriverData->vpp.dwOverlayFSOvlLost) {
        pfd->ddRVal = DDERR_SURFACELOST;
        dbgTracePop();
        return;
    }

    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_DDRAW) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvDDrawRecover();
        }
        else {
            pfd->ddRVal = DDERR_SURFACEBUSY;
            dbgTracePop();
            return;
        }
    }

#ifndef WINNT
    // check for VIA 82C598 north bridge
    if (IS_VIA_MVP3_NB_ID(pDriverData->northBridgeID)) {
        // turn off write posting
        _asm {
                mov edx, 0cf8h
                mov eax, 80000840h
                out dx, eax
                mov edx, 0cfch
                mov eax, 0
                in  al, dx
                mov dwSavedNBData, eax
                and eax, 0FFFFFF7Fh
                out dx, al
        }
    }
#endif

    /* Limit flips to 1 at a time to work around NV4 RM limitation */
    ddrval = getFlipStatusOverlay (pSurfTarg_gbl->fpVidMem);

    /* Only reject flip requests when flipping frames (but allow fields to proceed) */
    if ((pfd->dwFlags & (DDFLIP_ODD | DDFLIP_EVEN)) == 0) {
        if (ddrval != DD_OK) {
            if (pfd->dwFlags & DDFLIP_WAIT) {
                while (ddrval != DD_OK) {
                    LPPROCESSINFO lpProcInfo = pmGetProcess (pDriverData, GetCurrentProcessId());
                    if (IS_EVENT_ERROR(NvWaitEvent(lpProcInfo->hOvlFlipEvenEvent3, VPP_TIMEOUT_TIME))) {
                        EVENT_ERROR;
                    }
                    if (IS_EVENT_ERROR(NvWaitEvent(lpProcInfo->hOvlFlipOddEvent3, VPP_TIMEOUT_TIME))) {
                        EVENT_ERROR;
                    }
                    ddrval = getFlipStatusOverlay (pSurfTarg_gbl->fpVidMem);
                }
            }

            else {
                pfd->ddRVal = ddrval;
#ifndef WINNT
                // check for VIA 82C598 north bridge
                if (IS_VIA_MVP3_NB_ID(pDriverData->northBridgeID)) {
                    // restore write posting value
                    _asm {
                            mov edx, 0cf8h
                            mov eax, 80000840h
                            out dx, eax
                            mov edx, 0cfch
                            mov eax, dwSavedNBData
                            out dx, al
                    }
                }
#endif
                dbgTracePop();
                return;
            }
        }

    } else if (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_NV12) {
        if (ddrval != DD_OK) {
            NV_SLEEPFLIP;
            pfd->ddRVal = ddrval;
            dbgTracePop();
            return;
        }
    }

    /*
     * make sure we sync with other channels before writing put
     */
    getDC()->nvPusher.setSyncChannelFlag();

    dwVPPFlags = VPP_ALL;
    if ((pfd->lpSurfTarg->lpGbl->ddpfSurface.dwFourCC == FOURCC_NVDS) && (pfd->lpSurfTarg->lpSurfMore)) {
        if (pfd->lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_INTERLEAVED) {
            dwVPPFlags |= VPP_INTERLEAVED;
        }
        if (pfd->lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_BOB) {
            dwVPPFlags |= VPP_BOB;
        }
    } else if (lpSurfTarg->lpSurfMore) {
        if (lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_INTERLEAVED) {
            dwVPPFlags |= VPP_INTERLEAVED;
        }
        if (lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_BOB) {
            dwVPPFlags |= VPP_BOB;
        }
    }
    if (pfd->dwFlags & DDFLIP_ODD) {
        dwVPPFlags |= VPP_ODD;
    } else if (pfd->dwFlags & DDFLIP_EVEN) {
        dwVPPFlags |= VPP_EVEN;
    }
    if (lpSurfTarg->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT) {
        dwVPPFlags |= VPP_VIDEOPORT;
    }
    if (pfd->dwFlags & DDFLIP_WAIT) {
        dwVPPFlags |= VPP_WAIT;
    }

    // don't call VPP stuff if the Ring0 KMVT stuff is active
    if (pDriverData->bRing0FlippingFlag == FALSE) {
#ifdef DEBUG
#if (NVARCH >= 0x010)
        if ((moCompDebugLevel > 0) && (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_NV12)) {
            if (overlaySurfaceBase == 0)
                overlaySurfaceBase = pSurfTarg_gbl->fpVidMem;

            dwVPPFlags &= ~VPP_BOB;
            dwVPPFlags &= ~VPP_EVEN;
            dwVPPFlags &= ~VPP_ODD;

            if (!VppDoFlip(&(pDriverData->vpp),
                                overlaySurfaceBase - pDriverData->BaseAddress,
                               pSurfTarg_gbl->lPitch,
                               pSurfTarg_gbl->wWidth,
                               pSurfTarg_gbl->wHeight,
                               pSurfTarg_gbl->ddpfSurface.dwFourCC,
                               dwVPPFlags)) {
#ifndef WINNT
                // check for VIA 82C598 north bridge
                if (IS_VIA_MVP3_NB_ID(pDriverData->northBridgeID)) {
                    // restore write posting value
                    _asm {
                            mov edx, 0cf8h
                            mov eax, 80000840h
                            out dx, eax
                            mov edx, 0cfch
                            mov eax, dwSavedNBData
                            out dx, al
                    }

                }
#endif
                pfd->ddRVal = DDERR_WASSTILLDRAWING;
                dbgTracePop();
                return;
            }
        }
        else
#endif  // NVARCH >= 0x010
#endif  // DEBUG
        {
            if (!VppDoFlip(&(pDriverData->vpp),
                               pSurfTarg_gbl->fpVidMem - pDriverData->BaseAddress,
                               pSurfTarg_gbl->lPitch,
                               pSurfTarg_gbl->wWidth,
                               pSurfTarg_gbl->wHeight,
                               pSurfTarg_gbl->ddpfSurface.dwFourCC,
                               dwVPPFlags)) {
#ifndef WINNT
                // check for VIA 82C598 north bridge
                if (IS_VIA_MVP3_NB_ID(pDriverData->northBridgeID)) {
                    // restore write posting value
                    _asm {
                            mov edx, 0cf8h
                            mov eax, 80000840h
                            out dx, eax
                            mov edx, 0cfch
                            mov eax, dwSavedNBData
                            out dx, al
                    }

                }
#endif
                pfd->ddRVal = DDERR_WASSTILLDRAWING;
                dbgTracePop();
                return;
            }
        }
    }

    getDC()->flipOverlayRecord.llPreviousFlipTime = getDC()->flipOverlayRecord.llFlipTime;
    QueryPerformanceCounter((LARGE_INTEGER *) &getDC()->flipOverlayRecord.llFlipTime);
    getDC()->flipOverlayRecord.fpPreviousFlipFrom = getDC()->flipOverlayRecord.fpFlipFrom;
    getDC()->flipOverlayRecord.fpFlipFrom = pfd->lpSurfCurr->lpGbl->fpVidMem;
    getDC()->flipOverlayRecord.fpFlipTo = pSurfTarg_gbl->fpVidMem;

    getDC()->flipOverlayRecord.bFlipFlag = TRUE;

#ifndef WINNT
    // check for VIA 82C598 north bridge
    if (IS_VIA_MVP3_NB_ID(pDriverData->northBridgeID)) {
        // restore write posting value
        _asm {
                mov edx, 0cf8h
                mov eax, 80000840h
                out dx, eax
                mov edx, 0cfch
                mov eax, dwSavedNBData
                out dx, al
        }
    }
#endif

    dbgTracePop();
}

//---------------------------------------------------------------------------

// Flip32
// Flip RGB or overlay surfaces.

#ifdef NV_PROFILE_DP2OPS
DWORD flags = 0;
#endif

DWORD __stdcall Flip32 (LPDDHAL_FLIPDATA pfd)
{
    dbgTracePush ("Flip32");

    DDSTARTTICK(SURF4_FLIP);
    DDFLIPTICKS(FEFLIP);
#ifdef CNT_TEX
    g_dwFrames++;
#endif
    nvSetDriverDataPtrFromDDGbl (pfd->lpDD);

#ifdef  STEREO_SUPPORT
    StereoFlipNotify(pfd);
#endif  //STEREO_SUPPORT

#ifdef NV_PROFILE_DP2OPS
    if (pDriverData->pBenchmark == NULL) {
        pDriverData->pBenchmark = new CBenchmark;
        pDriverData->pBenchmark->resetData();
    }
    else
        pDriverData->pBenchmark->outputData(flags);
#endif

    /*
     * NOTES:
     *
     * This callback is invoked whenever we are about to flip from
     * one surface to another.   pfd->lpSurfCurr is the surface we were at,
     * pfd->lpSurfTarg is the one we are flipping to.
     *
     * You should point the hardware registers at the new surface, and
     * also keep track of the surface that was flipped away from, so
     * that if the user tries to lock it, you can be sure that it is done
     * being displayed
     */


    DPF_LEVEL(NVDBG_LEVEL_FLIP,"Flip32: curr=%08x, targ=%08x", pfd->lpSurfCurr, pfd->lpSurfTarg );
    DPF_LEVEL(NVDBG_LEVEL_FLIP,"        vidmem ptrs change: %08x->%08x",
              pfd->lpSurfCurr->lpGbl->fpVidMem,
              pfd->lpSurfTarg->lpGbl->fpVidMem );

    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_TWINVIEW_STATE_CHANGE) {
        if (pfd->lpSurfTarg->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
            VppDestroyFSMirror(&pDriverData->vpp);
            VppDestroyOverlay(&pDriverData->vpp);
            ResetTwinViewState(pDriverData);
            VppCreateOverlay(&pDriverData->vpp);
            VppCreateFSMirror(&pDriverData->vpp, pDriverData->vpp.dwOverlayFSSrcWidth, pDriverData->vpp.dwOverlayFSSrcHeight);
        } else {
            ResetTwinViewState(pDriverData);
        }
    }

    // front buffer rendering will fake flip
    if (dbgFrontRender)
    {
        DWORD dwTemp = pfd->lpSurfCurr->lpGbl->fpVidMem;
        NvReleaseSemaphore(pDriverData);
        pfd->lpSurfCurr->lpGbl->fpVidMem = pfd->lpSurfTarg->lpGbl->fpVidMem;
        pfd->lpSurfTarg->lpGbl->fpVidMem = dwTemp;
        pfd->ddRVal = DD_OK;
        DDENDTICK(SURF4_FLIP);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    // figure out whether we should vsync
    BOOL bNoVSyncCapable, bNoVSync;
    bNoVSyncCapable = (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_0049_DAC |
                                                                 NVCLASS_0067_DAC |
                                                                 NVCLASS_007C_DAC));
    if (bNoVSyncCapable) {
        switch (getDC()->nvD3DRegistryData.regVSyncMode) {
            case D3D_REG_VSYNCMODE_PASSIVE:
                bNoVSync = (pfd->dwFlags & DDFLIP_NOVSYNC) ? TRUE : FALSE;
                break;
            case D3D_REG_VSYNCMODE_FORCEOFF:
                bNoVSync = TRUE;
                break;
            case D3D_REG_VSYNCMODE_FORCEON:
                bNoVSync = FALSE;
                break;
            default:
                DPF ("unknown VSYNC mode in Flip32");
                dbgD3DError();
                break;
        } // switch
    }
    else {
        bNoVSync = FALSE;
    }

    if (!(pfd->lpSurfTarg->ddsCaps.dwCaps & (DDSCAPS_OVERLAY | DDSCAPS_VIDEOPORT))) {
#if (NVARCH >= 0x010) && defined(HWFLIP)
        if ((bNoVSync)
            ||
            (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_1196_CELSIUS | NVCLASS_0096_CELSIUS))
#if (NVARCH >= 0x020)
            ||
            (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)
#endif  // NVARCH >= 0x020
            )
        {
            nvCheckQueuedFlips ();
        }
#else  // !HWFLIP
        if (bNoVSync)
        {
            nvCheckQueuedFlips ();
        }
#endif  // !HWFLIP
    }

#if (NVARCH >= 0x010)
    // Handle AA: make sure that the regular buffer has updated before flipping
    if (getDC()->dwAAContextCount >= 1)
    {
        CNvObject *pObj = GET_PNVOBJ(pfd->lpSurfTarg);
        if (pObj) {
            PNVD3DCONTEXT pContext;
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                pContext = CKelvinAAState::GetContext(pObj->getSimpleSurface());
            } else {
                pContext = nvCelsiusAAFindContext(pObj->getSimpleSurface());
            }

            if (pContext) {
                pContext->aa.Flip(pContext);
                pContext->kelvinAA.Flip();
            }
        }
    }
#endif  // NVARCH >= 0x010

#ifdef  STEREO_SUPPORT
    StereoBackend(pfd);
#endif  //STEREO_SUPPORT

    // perform flip by either flipping at horz retrace or blt if that is not supported
    if ((bNoVSync) &&
        (pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_5))
    {
        // do the blit
        nvFlipBlit (pfd);
        // done
        pfd->ddRVal = DD_OK;
        DDENDTICK(SURF4_FLIP);
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    // everything is OK, do the flip here
    pDriverData->fIsBltStyleFlip = FALSE;

    if (!(pfd->lpSurfTarg->ddsCaps.dwCaps & (DDSCAPS_OVERLAY | DDSCAPS_VIDEOPORT))) {
        nvFlipPrimary (pfd, bNoVSync);
    }

    else if (pfd->lpSurfTarg->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
        nvFlipOverlay (pfd);
    }

    else {  // Video port flips handled by FlipVideoPort32
        pfd->ddRVal = DDERR_INVALIDSURFACETYPE;
    }

/* DO NOT REMOVE - force flip to be slower than a given speed
    if (getDC()->dwD3DContextCount > 0)
    {
               double maxRefresh = 85.0; // set max refresh rate here
               double microWait  = (1e6/maxRefresh);
               double tick2micro = (1e6/500e6);
        static double last       = 0.0;

        if (last)
        {
            double now;

            do
            {
                __int64 i64;
                __asm
                {
                    _emit 0x0f
                    _emit 0x31
                    mov dword ptr [i64],eax
                    mov dword ptr [i64 + 4],edx
                }
                now = ((double)i64) * tick2micro;
            }
            while ((now - last) < microWait);
            last = now;
        }
        else
        {
            __int64 i64;
            __asm
            {
                _emit 0x0f
                _emit 0x31
                mov dword ptr [i64],eax
                mov dword ptr [i64 + 4],edx
            }
            last = ((double)i64) * tick2micro;
        }
    }
//*/
    dbgFlushType (NVDBG_FLUSH_2D);
    DDENDTICK(SURF4_FLIP);

    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);

} // Flip32
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\d3dRender.cpp ===
/*
 * Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 * (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: d3dRender.cpp                                                     *
*   The Direct3D rendering routines.                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/02/97 - re-wrote and cleaned up.     *
*       Ben de Waal (bdw)           11/06/97 - Linear MipMap xxx            *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

/*
 * Dma Pushing loop stats.
 */
DWORD   statDmaSyncLoop      = 0;
DWORD   statDmaSyncOverflow  = 0;
DWORD   statDmaBusyLoop      = 0;
DWORD   statDmaBusyOverflow  = 0;
DWORD   statDmaFlushLoop     = 0;
DWORD   statDmaFlushOverflow = 0;

#ifndef WINNT  // these calls are obsolete on NT (DX7)
/*
 * --------------------------------------------------------------------------
 * nvRenderState
 *
 * LPD3DHAL_RENDERSTATEDATA
 * - Points to the instruction in the execute buffer.
 *
 * We get the count of states to set and then walk the execute buffer
 * handling each one at a time.
 * --------------------------------------------------------------------------
 */
DWORD __stdcall nvRenderState
(
    LPD3DHAL_RENDERSTATEDATA prd
)
{
    DWORD           i;
    LPBYTE          lpData;
    LPD3DSTATE      lpState;
    DWORD override;

    dbgTracePush ("nvRenderState");

    // get the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, prd);

    // Get pointer to global driver. data structure.
    nvSetDriverDataPtrFromContext(pContext);

    lpData = (LPBYTE)(((LPDDRAWI_DDRAWSURFACE_INT)prd->lpExeBuf)->lpLcl->lpGbl->fpVidMem);
    for (i = 0, lpState = (LPD3DSTATE)(lpData + prd->dwOffset);
         i < prd->dwCount; i++, lpState++)
    {
        DWORD rtype = (DWORD) lpState->drstRenderStateType;

        if (IS_OVERRIDE(rtype))
        {
            override = GET_OVERRIDE(rtype);
            if (((override - 1) >> DWORD_SHIFT) >= (MAX_STATE >> DWORD_SHIFT))
            {
                DPF("Invalid state override\n");
                dbgD3DError();
                continue;
            }

            if (lpState->dwArg[0])
            {
                DPF_LEVEL (NVDBG_LEVEL_INFO, "nvRenderState - setting override for state %08x", override);
                STATESET_SET(pContext->overrides, override);
            }
            else
            {
                DPF_LEVEL (NVDBG_LEVEL_INFO, "nvRenderState, clearing override for state %08x", override);
                STATESET_CLEAR(pContext->overrides, override);
            }
            DDTICKOFFSET(rtype, lpState->dwArg[0]);

            continue;
        }
        if (STATESET_ISSET(pContext->overrides, rtype))
        {
            DPF_LEVEL (NVDBG_LEVEL_INFO, "nvRenderState, state %08x is overridden, ignoring", rtype);
            DDTICKOFFSET(rtype, lpState->dwArg[0]);
            continue;
        }
        nvSetContextState (pContext, lpState->drstRenderStateType, lpState->dwArg[0], &prd->ddrval);
        if (prd->ddrval != DD_OK)
        {
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }

    }

    NvReleaseSemaphore(pDriverData);
    prd->ddrval = DD_OK;
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}
#endif  // !WINNT

//---------------------------------------------------------------------------

DWORD __stdcall nvSetRenderTarget
(
    LPD3DHAL_SETRENDERTARGETDATA pRTData
)
{
    LPDDRAWI_DDRAWSURFACE_INT pDDS, pDDSZ;
    LPDDRAWI_DDRAWSURFACE_LCL lpDDSLcl, lpDDSLclZ;
    DWORD                     dwTargetHandle, dwZHandle;
    DWORD                     dwErrorReturnValue;

    dbgTracePush ("nvSetRenderTarget");

    // this now becomes a wrapper for the DX7 version.
    nvAssert (global.dwDXRuntimeVersion < 0x0700);

    // get the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pRTData);

    // Select the appropriate return value.
    // Normally, DDHAL_DRIVER_HANDLED would be returned from this routine when
    // an error is encountered during processing.  However, DX6 has a bug in which
    // it only returns the pRTData->ddrval error value to the application if
    // DDHAL_DRIVER_NOTHANDLED is returned from SetRenderTarget.
    // Based on the registry setting, return the desired value when an error occurs.
    if (getDC()->nvD3DRegistryData.regValidateZMethod == D3D_REG_VALIDATEZMETHOD_SRTRETURNNOTHANDLED) {
        dwErrorReturnValue = DDHAL_DRIVER_NOTHANDLED;
    }
    else {
        dwErrorReturnValue = DDHAL_DRIVER_HANDLED;
    }

    pDDS = (LPDDRAWI_DDRAWSURFACE_INT)pRTData->lpDDS;
    if (!pDDS) {
        dbgD3DError();
        pRTData->ddrval = DDERR_CURRENTLYNOTAVAIL;
        dbgTracePop();
        return (dwErrorReturnValue);
    }
    lpDDSLcl = pDDS->lpLcl;
    if (!lpDDSLcl) {
        dbgD3DError();
        pRTData->ddrval = DDERR_CURRENTLYNOTAVAIL;
        dbgTracePop();
        return (dwErrorReturnValue);
    }

    dwTargetHandle = (DWORD)lpDDSLcl;

    // get the zbuffer handle if we've got one
    if ((pDDSZ = (LPDDRAWI_DDRAWSURFACE_INT)pRTData->lpDDSZ) != NULL) {
        lpDDSLclZ = pDDSZ->lpLcl;
    }
    else {
        lpDDSLclZ = NULL;
    }
    dwZHandle = (DWORD)lpDDSLclZ;

    // update the associated NvObjects back-pointers since the runtime
    // may have moved nvObject pointers around amongst DDSLcls.
    CNvObject *pNvObj;
    pNvObj = GET_PNVOBJ (lpDDSLcl);
    pNvObj->setHandle ((DWORD)lpDDSLcl);
    if (lpDDSLclZ) {
        pNvObj = GET_PNVOBJ (lpDDSLclZ);
        pNvObj->setHandle ((DWORD)lpDDSLclZ);
    }

    pRTData->ddrval = nvSetRenderTargetDX7 (pContext, dwTargetHandle, dwZHandle);

    if (pRTData->ddrval != DD_OK) {
        dbgTracePop();
        return (dwErrorReturnValue);
    }

    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

//---------------------------------------------------------------------------

BOOL nvAdjustZBuffer (CSimpleSurface *pZetaBuffer, LPDDRAWI_DDRAWSURFACE_LCL pDDSLclZ, DWORD dwNewBPP)
{
    if (pZetaBuffer->recreate (dwNewBPP)) {
        // successful allocation. reset some stuff in MS land
        if (pDDSLclZ) {
            pDDSLclZ->lpGbl->fpVidMem                      = pZetaBuffer->getfpVidMem();
            pDDSLclZ->lpGbl->lPitch                        = pZetaBuffer->getPitch();
            pDDSLclZ->lpGbl->lSlicePitch                   = pZetaBuffer->getSlicePitch();
            pDDSLclZ->lpGbl->ddpfSurface.dwZBufferBitDepth = dwNewBPP << 3;
            pDDSLclZ->lpGbl->ddpfSurface.dwZBitMask        = (dwNewBPP==2) ? 0x0000ffff : 0xffffff00;
        }
    }
    else {
        // re-allocation failed. now things are really bad.
        DPF ("nvCheckBufferCompatibility: z-buffer reallocation failed");
        nvAssert(0);
        return FALSE;
    }
    return TRUE;
}

//---------------------------------------------------------------------------

// check that we can actually render with this combination of z-buffer and
// render target. if not, try to fix things up for pre-DX7 apps.
// returns TRUE if everything is OK, FALSE otherwise

BOOL nvCheckBufferCompatibility (CSimpleSurface *pRenderTarget, CSimpleSurface *pZetaBuffer,
                                 LPDDRAWI_DDRAWSURFACE_LCL pDDSLclZ, DWORD dwDXAppVersion)
{
    if ((pZetaBuffer == NULL) || (pRenderTarget == NULL)) {
        // non-existent buffers can't conflict
        return TRUE;
    }

    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0097_KELVIN) {
        // with kelvin, all combinations of bit depths are ok
    }

    else if (dwDXAppVersion >= 0x800) { // !kelvin && DX8

        // DX8 apps convert Z if necessary
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_1196_CELSIUS) {
            // NV 11 supports C32/Z16
            if (pZetaBuffer->getBPP() > pRenderTarget->getBPP()) {
                DPF ("nvCheckBufferCompatibility: downgrading NV11 depth buffer for DX8 app");
                if (!nvAdjustZBuffer(pZetaBuffer, pDDSLclZ, pRenderTarget->getBPP())) {
                    return FALSE;
                }
            }
        }
        else if (pZetaBuffer->getBPP() != pRenderTarget->getBPP()) {
            // !NV11
            DPF ("nvCheckBufferCompatibility: forcing congruent bit depths for DX8 app");
            nvAdjustZBuffer(pZetaBuffer, pDDSLclZ, pRenderTarget->getBPP());
        }

    }

    else if (dwDXAppVersion >= 0x700) { // !kelvin && dx7

        // DX7 apps are expected to be compliant
        if ((pZetaBuffer->getBPPRequested() > pRenderTarget->getBPPRequested())
            ||
            ((!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_1196_CELSIUS)) &&
            (pZetaBuffer->getBPP() != pRenderTarget->getBPP())))
        {
            DPF ("nvCheckBufferCompatibility: mixed bit depths are disallowed for dx7");
            nvAssert(0);
            return FALSE;
        }

    }

    else { // !kelvin && DX6 or earlier

        // we try to cater to legacy apps no matter what they requested
        if ((pZetaBuffer->getBPP() > pRenderTarget->getBPP())
            ||
            ((!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_1196_CELSIUS)) &&
            (pZetaBuffer->getBPP() != pRenderTarget->getBPP())))
        {
            DPF ("nvCheckBufferCompatibility: forcing congruent bit depths for legacy app");
            if (!nvAdjustZBuffer(pZetaBuffer, pDDSLclZ, pRenderTarget->getBPP())) {
                return FALSE;
            }
        }

    }

    // check that the z-buffer is big enough
    if ((pRenderTarget->getHeight() > pZetaBuffer->getHeight()) ||
        (pRenderTarget->getWidth() > pZetaBuffer->getWidth())) {
        DPF ("nvCheckBufferCompatibility: z-buffer is insufficiently large");
        return FALSE;
    }

    return TRUE;
}

//---------------------------------------------------------------------------

DWORD nvSetRenderTargetDX7
(
    PNVD3DCONTEXT pContext,
    DWORD dwTargetHandle,
    DWORD dwZBufferHandle
)
{
    CNvObject       *pObj, *pZObj;
    CSimpleSurface  *pSurface, *pZSurface;
    CTexture        *pTexture;
    DWORD            dwClass;
    BOOL             bRTChanged;

    dbgTracePush ("nvSetRenderTargetDX7 (rt = %d, zb = %d)", dwTargetHandle, dwZBufferHandle);

    // Set pointer to global driver data structure.
    nvSetDriverDataPtrFromContext (pContext);

    // get the z surface
    if (dwZBufferHandle) {
        pZObj = nvGetObjectFromHandle (pContext->dwDDLclID, dwZBufferHandle, &global.pNvSurfaceLists);
        pZSurface = pZObj ? pZObj->getSimpleSurface() : NULL;
    }
    else {
        pZSurface = NULL;
    }

    // set the render target ------------------------------------------------

#ifdef WINNT
    pObj = nvGetObjectFromHandle (pContext->dwDDLclID, dwTargetHandle, &global.pNvSurfaceLists);
#else // !WINNT
    // runtime bug in dx7 when running dx5 apps - we will get a handle of 0 here for the primary surface
    // the runtime is supposed to swap the surface handles internally
    pObj = dwTargetHandle ? nvGetObjectFromHandle (pContext->dwDDLclID, dwTargetHandle, &global.pNvSurfaceLists) : (CNvObject*)pDXShare->pNvPrimarySurf;
#endif // !WINNT
    dwClass = pObj ? pObj->getClass() : CNvObject::NVOBJ_UNKNOWN;

    switch (dwClass) {

        case CNvObject::NVOBJ_SIMPLESURFACE :

#if (NVARCH >= 0x010)
            if (pContext->aa.isSuspended()) {
                pContext->aa.modFlags (~AASTATE::FLAG_SUSPENDED,AASTATE::FLAG_ENABLED);
            }
#endif  // NVARCH >= 0x010
#if (NVARCH >= 0x020)
            pContext->kelvinAA.Resume();
#endif
            pSurface = pObj->getSimpleSurface();

#ifdef  STEREO_SUPPORT
            //Make sure the render target has the right eye.
            if (STEREO_ENABLED && !pSurface->isStereo())
            {
                if (!pSurface->createStereo()) {
                    LOG("nvSetRenderTargetDX7: Can't create a stereo surface");
                }
            }
#endif  //STEREO_SUPPORT

            // make sure this is something we can write to
            if (!pSurface->hwCanWrite()) {
                NvReleaseSemaphore(pDriverData);
                dbgD3DError();
                dbgTracePop();
                return (DDERR_CURRENTLYNOTAVAIL);
            }
            break;

        case CNvObject::NVOBJ_TEXTURE :

#if (NVARCH >= 0x010)
            if (pContext->aa.isEnabled())  {
                pContext->aa.modFlags (~AASTATE::FLAG_ENABLED,AASTATE::FLAG_SUSPENDED);
            }
#endif  // NVARCH >= 0x010
#if (NVARCH >= 0x020)
            pContext->kelvinAA.Suspend();
#endif

            pTexture = pObj->getTexture();

            // render to the linear copy if it's newer or if we have dissimilar bit
            // depths on NV11/NV20 which can't handle mixed swizzled rendering
            if ( (pTexture->getLinear()->isUpToDate() && !pTexture->getSwizzled()->isUpToDate())
                 ||
                 (pZSurface && (pZSurface->getBPP() != pTexture->getBPP()))       // and mixed
               )
            {
                pSurface = pTexture->getLinear();
                // make certain we have a video memory linear surface
                if (!pTexture->prepareLinearAsRenderTarget()) {
                    NvReleaseSemaphore(pDriverData);
                    dbgD3DError();
                    dbgTracePop();
                    return (DDERR_OUTOFVIDEOMEMORY);
                }
            }
            else
            {
                // use swizzled rendering in hardware
                pTexture->updateSwizzleSurface(pContext);
                pSurface = pTexture->getSwizzled();
                pSurface->setWrapper (pTexture->getWrapper());
                pSurface->setFormat (pTexture->getFormat());
                pSurface->setBPP (pTexture->getBPP());
                pSurface->setBPPRequested (pTexture->getBPPRequested());
                pSurface->setWidth (pTexture->getWidth());
                pSurface->setHeight (pTexture->getHeight());
                pSurface->setDepth (pTexture->getDepth());
                pSurface->setPitch (pTexture->getPitch());
                pSurface->setSlicePitch (pTexture->getSlicePitch());
                pSurface->tagAsSwizzled();
            }
            break;

        default:
            // no formatted surface available
            DPF("nvSetRenderTarget - NULL target");
            NvReleaseSemaphore(pDriverData);
            dbgD3DError();
            dbgTracePop();
            return (DDERR_CURRENTLYNOTAVAIL);
            break;

    } // switch

    // if required, make certain that the previous flip has completed
    nvPusherSignalWaitForFlip (pSurface->getfpVidMem(), DDSCAPS_PRIMARYSURFACE);

    // mark RT as up to date
    pObj->clearDirty();

    // set the z-buffer -----------------------------------------------------

    if (pZSurface) {
        // enter if AA is not enabled.  Note that AA may have been created but is suspended at the moment
        // due to rendering to a texture or some such.
        // if AA is on and not suspended, then we'll assume that everything works--after all, we created the Z buffer,
        // so we're pretty sure it's valid.
        if (!pContext->kelvinAA.IsEnabled()) {
            if (pContext->kelvinAA.IsCreated()) {
                // if kelvin AA is or was on, we may have destroyed the z-buffer. attempt to re-create it now
                if (!pZSurface->isValid()) {
                    pContext->kelvinAA.ReCreateZBuffer();
                }
            }

            // if the z-surface is still invalid or isn't something the HW can write, bail out now
            if (!pZSurface->isValid() || !pZSurface->hwCanWrite()) {
                NvReleaseSemaphore(pDriverData);
                dbgD3DError();
                dbgTracePop();
                return (DDERR_CURRENTLYNOTAVAIL);
            }
        }

        // disable CT if the z-buffer is being associated with a render target whose size
        // is different from that of the render target with which it was last associated
        DWORD dwLastW = pZObj->getContextualValue0();
        DWORD dwLastH = pZObj->getContextualValue1();
        if (((dwLastW != 0) && (dwLastW != pSurface->getWidth()))
            ||
            ((dwLastH != 0) && (dwLastH != pSurface->getHeight())))
        {
            pZObj->disableCT();
        }
        pZObj->setContextualValue0 (pSurface->getWidth());
        pZObj->setContextualValue1 (pSurface->getHeight());
        // check that the z-buffer is big enough
        if ((pSurface->getHeight() > pZSurface->getHeight()) ||
            (pSurface->getWidth() > pZSurface->getWidth()))
        {
            DPF("z-buffer disabled due to insufficient space");
            pZSurface = NULL;
            dwZBufferHandle = 0;
        }
    }

    else {
        // according to MS, (dwZBufferHandle == 0) => disable z-buffer
        pZSurface = NULL;
    }

    // check that we can render with this combination
    if (!nvCheckBufferCompatibility (pSurface, pZSurface, NULL, pContext->dwDXAppVersion)) {
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DDERR_CURRENTLYNOTAVAIL);
    }

    // only now that all sanity checks have passed, update values in the context
    bRTChanged = (pContext->pRenderTarget != pSurface) ? TRUE : FALSE;
    pContext->dwRTHandle    = dwTargetHandle;
    pContext->dwZBHandle    = dwZBufferHandle;
    pContext->pRenderTarget = pSurface;
    pContext->pZetaBuffer   = pZSurface;

    dbgSetFrontRenderTarget (pContext, pSurface);

    // fix up AA if render target changed
    if (bRTChanged) {
        if (getDC()->dwAAContextCount >= 1) {
#if (NVARCH >= 0x020)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            pContext->kelvinAA.UpdateZBuffer();
            pContext->kelvinAA.UpdateRenderTarget();
        } else
#endif  // NVARCH >= 0x020
#if (NVARCH >= 0x010)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
            // Magnify the new render target into the super buffer
            if (pContext->aa.mAppCompat.bDiscardSRT){
//              pContext->aa.invalidateSRT();
                pContext->aa.makeSuperBufferValid(pContext);
            }
        }
#endif  // NVARCH >= 0x010
        }
    }

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= (CELSIUS_DIRTY_SURFACE   |
                                       CELSIUS_DIRTY_TRANSFORM |
                                       CELSIUS_DIRTY_SPECFOG_COMBINER);
    pContext->hwState.dwDirtyFlags |= (KELVIN_DIRTY_SURFACE   |
                                       KELVIN_DIRTY_TRANSFORM |
                                       KELVIN_DIRTY_COMBINERS_SPECFOG);
#endif
    pDriverData->bDirtyRenderTarget = TRUE;

    nvSetD3DSurfaceState (pContext);

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        pContext->kelvinAA.TestCreation(pContext);
    } else
#endif
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        pContext->aa.Create(pContext);
    }
#endif  // NVARCH >= 0x010

    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (DD_OK);
}
#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\ddDrv.cpp ===
/***************************************************************************\
* Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
*  Portions: Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.*
*                                                                           *
* Module: ddDrv.cpp                                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           7/6/99                                           *
*                                                                           *
\***************************************************************************/
// NB: This file is 'opted out' of using precompiled headers
#define INITGUID
#include "nvprecomp.h"

#include "escape.h"
#include "dxshare.h"
#include "nvcm.h"
#include "nvreg.h"
#include "nvILHash.h"
#include "..\..\..\modeset.mhd\include\modeext.h"
#include "wincommon.h"


#ifdef WINNT
    #ifdef _NO_COM
        #include <ddkernel.h>
    #else
        #define _NO_COM
        #include <ddkernel.h>
        #undef _NO_COM
    #endif // _NO_COM
#endif // WINNT

#ifdef WINNT
    PDEV    *ppdev;
#else
    DISPDRVDIRECTXCOMMON *pDXShare;

    U032  __stdcall SetSharedFSDOSBoxPtr (U032 *pData);
    DWORD __stdcall buildDDHALInfo16 (void);
    DWORD __stdcall UpdateNonLocalHeap32 (LPDDHAL_UPDATENONLOCALHEAPDATA lpd);
    DWORD __stdcall nvModeSetPrepare16 (void);
    DWORD __stdcall nvModeSetCleanup16 (void);
    void  __stdcall BuildDefaultDDHalModeTable (void);
    DWORD __stdcall GetSelectorsFromDisplayDriver (void);
    DWORD __stdcall FreeSelectorsFromDisplayDriver (void);
    void  __stdcall BuildDDHalModeTable (void);
#endif // !WINNT

#define NV_BUS_TYPE_AGP 4

CDriverContext         *pDriverData;

#ifdef CNT_TEX
DWORD g_dwVidTexDL[MAX_FRAME_CNT];
DWORD g_dwAgpTexDL[MAX_FRAME_CNT];
DWORD g_dwFrames;
#endif

/*
 * list of ROPs we support
 *
 * SRCCOPY is the key one to support
 */
static DWORD ropList[] = {
    BLACKNESSBIT | NOTSRCERASEBIT,               // 0x00 - 0x1F
    NOTSRCCOPYBIT,                               // 0x20 - 0x3F
    SRCERASEBIT,                                 // 0x40 - 0x5F
    SRCINVERTBIT,                                // 0x60 - 0x7F
    SRCANDBIT,                                   // 0x80 - 0x9F
    MERGEPAINTBIT,                               // 0xA0 - 0xBF
    SRCCOPYBIT,                                  // 0xC0 - 0xDF
    SRCPAINTBIT | WHITENESSBIT                   // 0xE0 - 0xFF
};

#ifdef WINNT
    // caps are not dynamic on WINNT, so always declare overlay and just fail creation if we need to
    #define NO_OVERLAY (FALSE)
#else
    #define NO_OVERLAY (pDriverData->dwHeads > 1 &&                                         \
                        pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE &&            \
                      !(pDriverData->vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSDEVICEMASK) &&   \
                      !(pDriverData->vpp.regOverlayMode3 & NV4_REG_OVL_MODE3_ALLOWOVL))
#endif

#if WINNT
extern "C" void __cdecl nvDDrawSynWithNvGdiDrv(PDEV*   ppdev);
#endif

/*
 * IN_VBLANK should be replaced by a test to see if the hardware is currently
 * in the vertical blank
 */
static BOOL     bInVBlank;
static BOOL     bInDisplay;
#define IN_VBLANK               (bInVBlank= !bInVBlank)
#define IN_DISPLAY              (bInDisplay= !bInDisplay)

/*
 * DRAW_ENGINE_BUSY should be replaced by a test to see the bltter is still
 * busy drawing
 */
#define DRAW_ENGINE_BUSY        FALSE

/*
 * ENOUGH_FIFO_FOR_BLT should be replaced with a test to see if there is enough
 * room in the hardware fifo for a blt
 */
#define ENOUGH_FIFO_FOR_BLT     TRUE

/*
 * CURRENT_VLINE should be replaced by a macro to retrieve the current
 * scanline
 */
#define CURRENT_VLINE   0

extern Nv10ControlDma * __stdcall NvSysOpenDma(char *, int, int, int);
extern DWORD __stdcall NvSysOpen(DWORD);
extern void  __stdcall NvSysClose(DWORD);

#ifndef WINNT   // Win9x Hackery
#ifndef NVPE
extern DWORD HookUpVxdStorage();
#endif
extern vpSurfaces* pMySurfaces;
#endif // !WINNT

#ifdef NVD3D
/*
 * D3D Hal Fcts
 */
extern BOOL DestroyItemArrays(void);
#endif // NVD3D

#ifdef NVSTATDRIVER
/*
 * Statitistics driver functions
 */
void __stdcall AttachNVStat();
void __stdcall DetachNVStat();

#endif // NVSTATDRIVER

#ifdef NV_TRACKAGP
void __Reset (void);
#endif //NV_TRACKAGP

/*
 * Define the Z-Buffer/Stencil Buffer Formats supported.
 * 16bit Formats should appear first in the data structure and then 24/32 bit formats.
 */
#define NV_NUM_16BIT_ZBUFFER_FORMATS    1
#define NV_NUM_ZBUFFER_FORMATS          3

typedef struct _def_zpixel_formats
{
    DWORD           dwNumZFormats;
    DDPIXELFORMAT   NvZBufferFormats[NV_NUM_ZBUFFER_FORMATS];
} ZPIXELFORMATS;

static  ZPIXELFORMATS  NvZPixelFormats =
{
    NV_NUM_ZBUFFER_FORMATS,
    {
        /*
         * 16 bit z buffer
         */
        {
            sizeof (DDPIXELFORMAT),                 // dwSize
            DDPF_ZBUFFER,                           // dwFlags
            0,                                      // dwFourCC (Not used)
            16,                                     // dwZBufferBitDepth
            0,                                      // dwStencilBitDepth
            0x0000FFFF,                             // dwZBitMask
            0x00000000,                             // dwStencilBitMask
            0x00000000                              // dwRGBZBitMask (Not used)
        },
        /*
         * 24 bit z-buffer, no stencil
         */
        {
            sizeof (DDPIXELFORMAT),                 // dwSize
            DDPF_ZBUFFER,                           // dwFlags
            0,                                      // dwFourCC (Not used)
            24,                                     // dwZBufferBitDepth
            0,                                      // dwStencilBitDepth
            0xFFFFFF00,                             // dwZBitMask
            0x00000000,                             // dwStencilBitMask
            0x00000000                              // dwRGBZBitMask (Not used)
        },
        /*
         * 24 bit z-buffer, 8 bit stencil
         */
        {
            sizeof (DDPIXELFORMAT),                 // dwSize
            DDPF_ZBUFFER | DDPF_STENCILBUFFER,      // dwFlags
            0,                                      // dwFourCC (Not used)
            32,                                     // dwZBufferBitDepth - This is so brain dead.  MS needs to learn consistency.
            8,                                      // dwStencilBitDepth
            0xFFFFFF00,                             // dwZBitMask
            0x000000FF,                             // dwStencilBitMask
            0x00000000                              // dwRGBZBitMask (Not used)
        }
    }
};

#ifndef TEXFORMAT_CRD

// DX8 Texture/Z/Render formats
static DDPIXELFORMAT celsiusPixelFormatsDX8[] =
{
    CELSIUS_TEXTURE_FORMATS_DX8         // Texture formats defined in NVTEXFMTS.H
};

static DDPIXELFORMAT celsiusPixelFormatsDX8NoDXT[] =
{
    CELSIUS_TEXTURE_FORMATS_NO_DXT_DX8  // Texture formats defined in NVTEXFMTS.H
};
#if (NVARCH >= 0x020)
static DDPIXELFORMAT kelvinPixelFormatsDX8[] =
{
    KELVIN_TEXTURE_FORMATS_DX8         // Texture formats defined in NVTEXFMTS.H
};

static DDPIXELFORMAT kelvinPixelFormatsDX8NoDXT[] =
{
    KELVIN_TEXTURE_FORMATS_NO_DXT_DX8  // Texture formats defined in NVTEXFMTS.H
};
#endif // (NVARCH >= 0x020)

#endif  // !TEXFORMAT_CRD

//---------------------------------------------------------------------------

#ifndef WINNT
BOOL MyExtEscape (DWORD dwHead, int nEscapeID, int nInBytes, LPCSTR lpIn, int nOutBytes, LPSTR lpOut)
{
    DISPDRVDIRECTXCOMMON *pDXS;
    BOOL bRet;

    dbgTracePush ("MyExtEscape");

    nvAssert (pDXShare);

    // fetch the appropriate DXShare
    pDXS = getDXShare (pDXShare->dwRootHandle, dwHead);

    if (pDXS) {
        // get the DC handle for this pDXShare
        HDC hDC = nvCreateDCHandle (pDXS);
        nvAssert (GetObjectType(hDC));
        // make the escape call
        bRet = ExtEscape (hDC, nEscapeID, nInBytes, lpIn, nOutBytes, lpOut);
        // release the handle
        nvDestroyDCHandle (hDC);
    }
    else {
        // no heads are enabled
        bRet = FALSE;
    }

    dbgTracePop();
    return (bRet);
}
#endif // !WINNT

//---------------------------------------------------------------------------

DWORD WaitForIdle(BOOL bWait, BOOL bUseEvent)
{
    NvNotification *pDmaSyncNotifier = pDriverData->pDmaSyncNotifierFlat;
    LPPROCESSINFO   lpProcInfo;

    dbgTracePush ("WaitForIdle");

    if (bUseEvent) {
        lpProcInfo = pmGetProcess(pDriverData, GetCurrentProcessId());
        if ((lpProcInfo == NULL) || (lpProcInfo->hIdleSyncEvent3 == 0)) {
            DPF("WaitForIdle: Unable to get process ID, using NV_SLEEP");
            bUseEvent = FALSE;
        }
        else {
            NvResetEvent(lpProcInfo->hIdleSyncEvent3);
        }
    }

    if ((pDmaSyncNotifier == NULL) || (!getDC()->nvPusher.isValid())) {
        DPF("WaitForIdle: Invalid parameters");
        dbgTracePop();
        return (DD_OK);
    }

    // Waiting for a notifier with the FIFO in this state guarantees a hang
    if (pDriverData->dwFullScreenDOSStatus & (FSDOSSTATUS_RECOVERYNEEDED_D3D | FSDOSSTATUS_RECOVERYNEEDED_DDRAW)) {
        DPF("WaitForIdle: Early exit due to DosOccurred flag");
        dbgTracePop();
        return (DD_OK);
    }

    pDriverData->TwoDRenderingOccurred = 1;

    // wait for other dma channels to go idle
    getDC()->nvPusher.waitForOtherChannels();

    // MUST wait for any pending notification to prevent possible loss of notification serialization
    if (!bUseEvent && bWait) {
        while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP;
#ifdef CAPTURE
        if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
            CAPTURE_SYNC3 sync;
            sync.dwJmpCommand         = CAPTURE_JMP_COMMAND;
            sync.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
            sync.dwExtensionID        = CAPTURE_XID_SYNC3;
            sync.dwType               = CAPTURE_SYNC3_TYPE_NOTIFIER;
            sync.dwCtxDMAHandle       = NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
            sync.dwOffset             = 0;
            sync.dwValue              = 0;
            captureLog (&sync,sizeof(sync));
        }
#endif // CAPTURE
    }

    pDmaSyncNotifier->status = NV_IN_PROGRESS;

    nvPushData (0, dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000);
    nvPushData (1, ((bWait && bUseEvent) ? NV04A_NOTIFY_WRITE_THEN_AWAKEN : 0));
    nvPushData (2, dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000);
    nvPushData (3, 0);

    nvPusherAdjust (4);
    nvPusherStart  (TRUE);

    if (bWait) {
        if (bUseEvent) {
            if (IS_EVENT_ERROR(NvWaitEvent(lpProcInfo->hIdleSyncEvent3, 500))) {
                // timeout, our process list must be messed up
                EVENT_ERROR;
            }
        } else {
            while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP;
#ifdef CAPTURE
            if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                CAPTURE_SYNC3 sync;
                sync.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                sync.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                sync.dwExtensionID        = CAPTURE_XID_SYNC3;
                sync.dwType               = CAPTURE_SYNC3_TYPE_NOTIFIER;
                sync.dwCtxDMAHandle       = NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
                sync.dwOffset             = 0;
                sync.dwValue              = 0;
                captureLog (&sync,sizeof(sync));
            }
#endif // CAPTURE
        }
    }
    else {
        NV_SLEEP;
        if (pDmaSyncNotifier->status == NV_IN_PROGRESS) {
            dbgTracePop();
            return (DDERR_WASSTILLDRAWING);
        }
    }

    dbgTracePop();
    return (DD_OK);
}

//---------------------------------------------------------------------------
#ifndef WINNT // HAL function not present under NT
/*
 * SetMode32

    This API call is only made on boards which do not have an
    associated display driver -- i.e. the 3D only boards. We
    should never see this on an NVidia board.
 */
DWORD __stdcall SetMode32( LPDDHAL_SETMODEDATA lpSetModeData )
{
    dbgTracePush ("SetMode32");

    nvSetDriverDataPtrFromDDGbl (lpSetModeData->lpDD);

    pDriverData->dwUseRefreshRate = lpSetModeData->useRefreshRate;

#if 0
    // Call back to 16 bit direct draw code to set mode
    MyExtEscape(NVSETDDRAWMODE, 0, 0, 0, 0);
#endif

    lpSetModeData->ddRVal = DD_OK;

    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}
#endif // !WINNT

//---------------------------------------------------------------------------

/*
 * Lock32
 */
DWORD __stdcall Lock32 (LPDDHAL_LOCKDATA lpLockData)
{
    HRESULT                     ddrval = DDHAL_DRIVER_NOTHANDLED;
    DWORD                       dwCaps;
    LPDDRAWI_DDRAWSURFACE_GBL   psurf_gbl;

    dbgTracePush ("Lock32: fpvidmem = %08x", lpLockData->lpDDSurface->lpGbl->fpVidMem);

    dwCaps = lpLockData->lpDDSurface->ddsCaps.dwCaps;

    if (dwCaps & DDSCAPS_EXECUTEBUFFER)
    {
        // silly hack for screwed up kernel calls
        DWORD dwRetVal;
        dwRetVal = D3DLockExecuteBuffer32(lpLockData);
        dbgTracePop();
        return dwRetVal;
    }

    DDSTARTTICK(SURF4_LOCK);
    nvSetDriverDataPtrFromDDGbl (lpLockData->lpDD);

    lpLockData->ddRVal = DD_OK;

    // DO THIS FIRST!! We shouldn't assign pointers below first,
    // because if we end up resetting nv via nvEnable32, the pointers
    // may have changed in the pDriverData structure.

    // Reset NV and get the monitor frequency after a mode reset
    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        getDC()->nvPusher.waitForOtherChannels();
        if (!nvEnable32 (lpLockData->lpDD)) {
            NvReleaseSemaphore(pDriverData);
            DDENDTICK(SURF4_CREATESURFACE);
            lpLockData->ddRVal = DDERR_OUTOFMEMORY;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    }

    /*
     * NOTES:
     *
     * This callback is invoked whenever a surface is about to be directly
     * accessed by the user.   This is where you need to make sure that
     * a surface can be safely accessed by the user.
     *
     * If your memory cannot be accessed while in accelerator mode, you
     * should either take the card out of accelerator mode or else
     * return DDERR_SURFACEBUSY
     *
     * If someone is accessing a surface that was just flipped away from,
     * make sure that the old surface (what was the primary) has finished
     * being displayed.
     */

    dwCaps = lpLockData->lpDDSurface->ddsCaps.dwCaps;

    psurf_gbl = lpLockData->lpDDSurface->lpGbl;

    if (pDriverData->dwFullScreenDOSStatus & (FSDOSSTATUS_RECOVERYNEEDED_D3D | FSDOSSTATUS_RECOVERYNEEDED_DDRAW)) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
                nvD3DRecover();
            }
            if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_DDRAW) {
                nvDDrawRecover();
            }
        }
        else {
            lpLockData->ddRVal = DDERR_SURFACEBUSY;
            DDENDTICK(SURF4_LOCK);
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
    }

    if (((!getDC()->nvPusher.isValid()) && (dwCaps & DDSCAPS_VIDEOMEMORY)) || // Mode switches might occur without warning
        (IS_OVERLAY(dwCaps,psurf_gbl->ddpfSurface.dwFourCC) && pDriverData->vpp.dwOverlayFSOvlLost)) {    // overlay capability has vanished
        lpLockData->ddRVal = DDERR_SURFACELOST;
        DDENDTICK(SURF4_LOCK);
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

#ifdef CAPTURE
    CNvObject *pNvObj_cap = GET_PNVOBJ(lpLockData->lpDDSurface);
    DWORD      dwHeap_cap = 0;
    DWORD      dwOffset_cap, dwSize_cap;
    if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
        if (pNvObj_cap) {
            if (pNvObj_cap->getTexture()) {
                dwHeap_cap   = pNvObj_cap->getTexture()->getSwizzled()->getHeapLocation();
                dwOffset_cap = pNvObj_cap->getTexture()->getSwizzled()->getOffset();
                dwSize_cap   = pNvObj_cap->getTexture()->getSize();
            }
            else if (pNvObj_cap->getVertexBuffer()) {
                dwHeap_cap   = pNvObj_cap->getVertexBuffer()->getHeapLocation();
                dwOffset_cap = pNvObj_cap->getVertexBuffer()->getOffset();
                dwSize_cap   = pNvObj_cap->getVertexBuffer()->getSize();
            }
            else if (pNvObj_cap->getSimpleSurface()) {
                dwHeap_cap   = pNvObj_cap->getSimpleSurface()->getHeapLocation();
                dwOffset_cap = pNvObj_cap->getSimpleSurface()->getOffset();
                dwSize_cap   = pNvObj_cap->getSimpleSurface()->getSize();
            }
            else if (pNvObj_cap->getPaletteSurface()) {
                dwHeap_cap   = pNvObj_cap->getPaletteSurface()->getHeapLocation();
                dwOffset_cap = pNvObj_cap->getPaletteSurface()->getOffset();
                dwSize_cap   = pNvObj_cap->getPaletteSurface()->getSize();
            }
        }
        if (dwHeap_cap) {
            CAPTURE_LOCK lock;
            lock.dwJmpCommand         = CAPTURE_JMP_COMMAND;
            lock.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
            lock.dwExtensionID        = CAPTURE_XID_LOCK;
            lock.dwType               = CAPTURE_LOCK_TYPE_LOCK;
            lock.dwCtxDMAHandle       = (dwHeap_cap == CSimpleSurface::HEAP_VID)
                                      ? NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY
                                      : D3D_CONTEXT_DMA_HOST_MEMORY;
            lock.dwOffset             = dwOffset_cap;
            captureLog (&lock, sizeof(lock));
        }
    }
#endif

    /*
     * Check for texture lock BEFORE syncing hard
     */
    if (dwCaps & DDSCAPS_TEXTURE) {
        /*
         * get texture
         */
        CTexture *pTexture = GET_PNVOBJ(lpLockData->lpDDSurface)->getTexture();
        /*
         * user wants to lock a texture - process elsewhere
         */
        if (IS_VALID_PNVOBJ(pTexture))
        {
            ddrval = nvTextureLock (pTexture,lpLockData);
            DDENDTICK(SURF4_LOCK);
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return ddrval;
        }
    }

#if (NVARCH >= 0x10)

    if (!(pDriverData->vpp.dwDecoderCaps & NVOCID2_OS_SCHEDULED)) {
        if (psurf_gbl->ddpfSurface.dwFlags & DDPF_FOURCC) {
            if ((psurf_gbl->ddpfSurface.dwFourCC == FOURCC_NVMC) ||
                (psurf_gbl->ddpfSurface.dwFourCC == FOURCC_NVDS)) { // Is it our motion comp. control surface ?
                LPNVMCFRAMEDATA lpNvMCFrameData = (LPNVMCFRAMEDATA) VIDMEM_ADDR(psurf_gbl->fpVidMem);
#ifdef WINNT
                lpNvMCFrameData->dwMCNvExecute = NULL;
                lpNvMCFrameData->dwMCMultiMonID = 0;
#else // !WINNT
                lpNvMCFrameData->dwMCNvExecute = (PFUNC)nvMoCompExecute;
                lpNvMCFrameData->dwMCMultiMonID = (DWORD)pDXShare;
#endif // !WINNT
                if (psurf_gbl->ddpfSurface.dwFourCC == FOURCC_NVMC) // Don't trash NVDS surfaces
                    lpNvMCFrameData->bMCDestinationSurfaceIndex = 255;
                lpNvMCFrameData->bMCForwardSurfaceIndex = 255;
                lpNvMCFrameData->bMCBackwardSurfaceIndex = 255;
                lpNvMCFrameData->bMCEndOfPicture = FALSE;
                pDriverData->bMCNewFrame = TRUE;
                DDENDTICK(SURF4_LOCK);
                NvReleaseSemaphore(pDriverData);
                dbgTracePop();
                return (DDHAL_DRIVER_NOTHANDLED);
            }

            else if (psurf_gbl->ddpfSurface.dwFourCC == FOURCC_NVID) { // Is it a motion comp. IDCT surface ?

                if (lpLockData->lpDDSurface != (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCIDCTSurface) {

                    for (DWORD dwIndex=0; dwIndex<4; dwIndex++) {
                        if (lpLockData->lpDDSurface == (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVIDSurface[dwIndex]) {
                            break;
                        }
                    }

                    if (dwIndex < 4) {

                        if (!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                                       pDriverData->dwMCNVIDSurfaceReferenceCount[dwIndex],
                                                       1)) {
                             NvReleaseSemaphore(pDriverData);
                             lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
                             DDENDTICK(SURF4_LOCK);
                             dbgTracePop();
                             return (DDHAL_DRIVER_HANDLED);
                        }
                    }
                }

                DDENDTICK(SURF4_LOCK);
                NvReleaseSemaphore(pDriverData);
                dbgTracePop();
                return (DDHAL_DRIVER_NOTHANDLED);
            }

            else if (psurf_gbl->ddpfSurface.dwFourCC == FOURCC_NV12) { // Is it a motion comp. image surface ?

                LPNVMCSURFACEFLAGS lpSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

                while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
                       (lpSurfaceFlags->dwMCSurfaceBase != psurf_gbl->fpVidMem)) {
                    lpSurfaceFlags++;
                }

                if (lpLockData->lpDDSurface == (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface) {
                    if (lpLockData->dwFlags & DDLOCK_READONLY) {
                        if (!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                                       lpSurfaceFlags->dwMCMotionCompReferenceCount,
                                                       0)) {
                            lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
                        }
                    }
                    else {

                        if ((!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                                        lpSurfaceFlags->dwMCMotionCompReferenceCount,
                                                        0))
                            ||
                            (!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                                        lpSurfaceFlags->dwMCFormatCnvReferenceCount,
                                                        0))) {
                            lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
                        }
                    }
                }
                else if ((lpLockData->lpDDSurface == (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCForwardSurface) ||
                         (lpLockData->lpDDSurface == (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface)) {
                    if (!(lpLockData->dwFlags & DDLOCK_READONLY)) {
                        if (!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                                       lpSurfaceFlags->dwMCMotionCompReferenceCount,
                                                       0)) {
                            lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
                        }
                    }
                }

                // If DXVA locks this NV12 surface it means the decoder is probably going to
                // change the contents, so force a reconversion from NV12 to YUY2 at Flip32 time.
                if (pDriverData->dwDXVAFlags & DXVA_MO_COMP_IN_PROGRESS)
                    lpSurfaceFlags->bMCFrameAlreadyFormatConverted = 0;

                DDENDTICK(SURF4_LOCK);
                NvReleaseSemaphore(pDriverData);
                dbgTracePop();
                if (lpLockData->ddRVal != DD_OK) {
                    return DDHAL_DRIVER_HANDLED;
                } else {
                    return DDHAL_DRIVER_NOTHANDLED;
                }
            }
        }
    }

#endif  // NVARCH >= 0x10

#if (NVARCH >= 0x010)
    // Handle AA: When locking a render target or Z buffer, minify first.
    if (getDC()->dwAAContextCount >= 1)
    {
#if (NVARCH >= 0x020)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            CNvObject *pObj = GET_PNVOBJ(lpLockData->lpDDSurface);
            if (pObj) {
                PNVD3DCONTEXT pContext = nvCelsiusAAFindContext(pObj->getSimpleSurface());
                if (pContext)
                {
                    CKelvinAAState::AccessType access = (lpLockData->dwFlags & DDLOCK_READONLY) ? CKelvinAAState::ACCESS_READ : CKelvinAAState::ACCESS_WRITE;
                    access = (lpLockData->dwFlags & DDLOCK_DISCARDCONTENTS) ? CKelvinAAState::ACCESS_WRITE_DISCARD : access;

                    if ((pObj->getSimpleSurface() == pContext->pRenderTarget)) {
                        pContext->kelvinAA.GrantAccess(CKelvinAAState::BUFFER_RT, access, false, true);
                    }
                    if ((pContext->pZetaBuffer) && (pObj->getSimpleSurface() == pContext->pZetaBuffer)) {
                        pContext->kelvinAA.GrantAccess(CKelvinAAState::BUFFER_ZB, access, false, true);
                    }
                }
            }
        } else
#endif
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
            CNvObject *pObj = GET_PNVOBJ(lpLockData->lpDDSurface);
            if (pObj) {
                PNVD3DCONTEXT pContext = nvCelsiusAAFindContext(pObj->getSimpleSurface());
                if (pContext && pContext->aa.isInit())
                {
                    if ((pObj->getSimpleSurface() == pContext->pRenderTarget)) {
                        pContext->aa.Lock(pContext);
                    }
                    if ((pContext->pZetaBuffer) && (pObj->getSimpleSurface() == pContext->pZetaBuffer)) {
                        pContext->aa.LockZ(pContext);
                    }
                }
            }
        }
    }
#endif  // NVARCH >= 0x010

    // determine conditions under which a wait is required
    BOOL bWrite = !(lpLockData->dwFlags & DDLOCK_READONLY);

    if (lpLockData->dwFlags & DDLOCK_WAIT) {
        if (bWrite) { // wait is only required if we intend to write to this surface
            // wait for flip if scanning out from this surface
            ddrval = getFlipStatus (psurf_gbl->fpVidMem, dwCaps);
            while (ddrval != DD_OK) {
                NV_SLEEP;
                ddrval = getFlipStatus (psurf_gbl->fpVidMem, dwCaps);
            }
        }
        // flush out all blit and clear operations
        if (IS_OVERLAY(dwCaps,psurf_gbl->ddpfSurface.dwFourCC) ||
            psurf_gbl->ddpfSurface.dwFourCC == FOURCC_NV12 ||
            psurf_gbl->ddpfSurface.dwFourCC == FOURCC_NVID ||
            psurf_gbl->ddpfSurface.dwFourCC == FOURCC_NVMC ||
            psurf_gbl->ddpfSurface.dwFourCC == FOURCC_NVDS ||
            psurf_gbl->ddpfSurface.dwFourCC == FOURCC_NVSP ||
           (lpLockData->lpDDSurface->ddsCaps.dwCaps & (DDSCAPS_VIDEOPORT | DDSCAPS_HWCODEC | DDSCAPS_PRIMARYSURFACE))) {
            // yielding stall for video
            WaitForIdle(TRUE, TRUE);
        } else {
            // polling stall for D3D
            getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);
        }

        if (lpLockData->lpDDSurface->ddsCaps.dwCaps & (DDSCAPS_FRONTBUFFER | DDSCAPS_PRIMARYSURFACE | DDSCAPS_VISIBLE)) {
#ifdef WINNT
            nvDDrawSynWithNvGdiDrv(ppdev);
#else
            // flush out all GDI blits (MS does this for us in all cases except the primary)
            void *lpPDevice = GET_HALINFO()->lpPDevice;
            DrvCallbackFunc(NV_DRVSERVICE_BEGINACCESS, lpPDevice, NULL);
#endif
        }
    } else {
        // return error code if required
        if ((bWrite && (getFlipStatus (psurf_gbl->fpVidMem, dwCaps) != DD_OK)) || !getDC()->nvPusher.isIdle(TRUE)) {
            lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
            DDENDTICK(SURF4_LOCK);
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
#ifdef WINNT
        if (lpLockData->lpDDSurface->ddsCaps.dwCaps & (DDSCAPS_FRONTBUFFER | DDSCAPS_PRIMARYSURFACE | DDSCAPS_VISIBLE)) 
        {
            nvDDrawSynWithNvGdiDrv(ppdev);
        }
#endif
    }

    if ((pDriverData->pGenericScaledImageNotifier->status == NV_IN_PROGRESS) &&
        (pDriverData->NvDmaFromMemSurfaceMem == psurf_gbl->fpVidMem)) {
        lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
        DDENDTICK(SURF4_LOCK);
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    //
    // check if at least one 3d context exists
    //
    if ((getDC()->dwD3DContextCount > 0)
     && (pDriverData->nvD3DPerfData.dwPerformanceStrategy & (PS_CONTROL_TRAFFIC_16 | PS_CONTROL_TRAFFIC_32)))
    {
        CNvObject *pNvObj = GET_PNVOBJ(lpLockData->lpDDSurface);

        // test for traffic control
        if (dwCaps & DDSCAPS_ZBUFFER)
        {
            if (IS_VALID_PNVOBJ(pNvObj) && pNvObj->hasCTEnabled())
            {
                pNvObj->tagZLock();
                pNvObj->disableCT();
                nvCTDecodeBuffer (pNvObj,
                                  VIDMEM_ADDR(psurf_gbl->fpVidMem),
                                  psurf_gbl->ddpfSurface.dwRGBBitCount >> 3,
                                  psurf_gbl->lPitch,
                                  psurf_gbl->wWidth,
                                  psurf_gbl->wHeight);
            }
        }
        else
        {
            PNVD3DCONTEXT pContext = (PNVD3DCONTEXT)getDC()->dwContextListHead;
            while (pContext)
            {
                if ((pContext->pRenderTarget) &&
                    (pContext->pRenderTarget->getWrapper() == pNvObj))
                {
                    if (pContext->pZetaBuffer)
                    {
                        nvAssert (pContext->pZetaBuffer->getWrapper());
                        pContext->pZetaBuffer->getWrapper()->tagFLock();
                    }
                    break;
                }
                pContext = pContext->pContextNext;
            }
        }
    }

    // Note that this may return NULL
    CNvObject *pNvObj;
    pNvObj = GET_PNVOBJ(lpLockData->lpDDSurface);

    if ((dwCaps & DDSCAPS_VIDEOMEMORY) && ((dwCaps & DDSCAPS_TEXTURE) == 0)) {
        // No need to lock textures even though they may currently be in use because
        //     their surface memory is not used directly when rendering
        // Every other surface type with DDSCAPS_VIDMEMORY set does need locked however
        if(pNvObj && pNvObj->getSimpleSurface())
        {
            DDLOCKINDEX(NVSTAT_LOCK_VID_TEX);
            pNvObj->getSimpleSurface()->cpuLock(CSimpleSurface::LOCK_NORMAL);
            if (dwCaps & DDSCAPS_BACKBUFFER)
            {
                // avoid clearing the render target in 3D Mark 2000
                pNvObj->setRTLocked();
            }
        }
    }

#ifdef  STEREO_SUPPORT
    BOOL bLockSubstituted = StereoLockSubstitute(lpLockData);
#endif  //STEREO_SUPPORT


    if (pNvObj
#ifdef  STEREO_SUPPORT
        && bLockSubstituted == FALSE
#endif  //STEREO_SUPPORT
        )
    {
        // update MS cached pointer, which might be different if we renamed or otherwise
        // recreated the surface
        CSimpleSurface *pSurface = pNvObj->getSimpleSurface();

        if (pSurface) {
            switch(pSurface->getHeapLocation()) {
            case CSimpleSurface::HEAP_VID:
                psurf_gbl->fpVidMem = pSurface->getfpVidMem();
                break;
#ifdef NV_AGP
            case CSimpleSurface::HEAP_AGP:
                psurf_gbl->fpVidMem = nvAGPGetUserAddr(pSurface->getAddress());
                break;
#endif
            }
        }
    }

#ifndef WINNT
    // Currently works only for pDriverData->bi.biBitCount pixel depth surfaces
    DWORD dwOffset;
    if (lpLockData->bHasRect) {
        dwOffset = lpLockData->rArea.top * psurf_gbl->lPitch;
        dwOffset += (lpLockData->rArea.left * (GET_MODE_BPP() >> 3));
    }
    else {
        dwOffset = 0;
    }

    lpLockData->lpSurfData = (VOID *)((DWORD)psurf_gbl->fpVidMem + dwOffset);
#endif // !WINNT

#ifdef  STEREO_SUPPORT
    if (bLockSubstituted && lpLockData->ddRVal == DD_OK)
    {
        //We can't return DDHAL_DRIVER_NOTHANDLED for stereo if we really want to fool DX and substitute the
        //stereo buffer address. Otherwise DX retrieves the buffer address from its own internal structures
        //depending on the surface capabilities sometimes ignoring what we specified in the lpLockData->lpSurfData
        //or psurf_gbl->fpVidMem. For instance for the front buffer it retrieves the memory address from
        //LPDDRAWI_DIRECTDRAW_GBL->vmiData.fpPrimary. It is a pain in the ... for us to handle all the cases.
        //If we return DDHAL_DRIVER_HANDLED though it uses lpLockData->lpSurfData for sure (Andrei Osnovich).
        ddrval = DDHAL_DRIVER_HANDLED;
    }
#endif  //STEREO_SUPPORT

    DDENDTICK(SURF4_LOCK);
    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return ddrval;

}  // Lock32

//---------------------------------------------------------------------------

/*
 * Unlock32
 */
DWORD __stdcall Unlock32( LPDDHAL_UNLOCKDATA lpUnlockData )
{
    LPDDRAWI_DDRAWSURFACE_GBL   pDDSGbl;
    DWORD                       caps;
    DWORD   ddrval;

    dbgTracePush ("Unlock32: fpvidmem = %08x", lpUnlockData->lpDDSurface->lpGbl->fpVidMem);

    if (lpUnlockData->lpDDSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
    {
        //silly hack for screwed up kernel calls
        DWORD dwRetVal;
        dwRetVal = D3DUnlockExecuteBuffer32(lpUnlockData);
        dbgTracePop();
        return dwRetVal;
    }

    DDSTARTTICK(SURF4_UNLOCK);
    nvSetDriverDataPtrFromDDGbl (lpUnlockData->lpDD);

    caps = lpUnlockData->lpDDSurface->ddsCaps.dwCaps;

    if ((!getDC()->nvPusher.isValid()) && (caps & DDSCAPS_VIDEOMEMORY)) {  /* Mode switches might occur without warning */
        lpUnlockData->ddRVal = DDERR_SURFACELOST;
        DDENDTICK(SURF4_UNLOCK);
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

#ifdef CAPTURE
    CNvObject *pNvObj_cap = GET_PNVOBJ(lpUnlockData->lpDDSurface);
    DWORD      dwHeap_cap = 0;
    DWORD      dwAddr_cap, dwOffset_cap, dwSize_cap;
    if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
        if (pNvObj_cap) {
            if (pNvObj_cap->getTexture()) {
                dwHeap_cap   = pNvObj_cap->getTexture()->getSwizzled()->getHeapLocation();
                dwAddr_cap   = pNvObj_cap->getTexture()->getSwizzled()->getAddress();
                dwOffset_cap = pNvObj_cap->getTexture()->getSwizzled()->getOffset();
                dwSize_cap   = pNvObj_cap->getTexture()->getSize();
            }
            else if (pNvObj_cap->getVertexBuffer()) {
                dwHeap_cap   = pNvObj_cap->getVertexBuffer()->getHeapLocation();
                dwAddr_cap   = pNvObj_cap->getVertexBuffer()->getAddress();
                dwOffset_cap = pNvObj_cap->getVertexBuffer()->getOffset();
                dwSize_cap   = pNvObj_cap->getVertexBuffer()->getSize();
            }
            else if (pNvObj_cap->getSimpleSurface()) {
                dwHeap_cap   = pNvObj_cap->getSimpleSurface()->getHeapLocation();
                dwAddr_cap   = pNvObj_cap->getSimpleSurface()->getAddress();
                dwOffset_cap = pNvObj_cap->getSimpleSurface()->getOffset();
                dwSize_cap   = pNvObj_cap->getSimpleSurface()->getSize();
            }
            else if (pNvObj_cap->getPaletteSurface()) {
                dwHeap_cap   = pNvObj_cap->getPaletteSurface()->getHeapLocation();
                dwAddr_cap   = pNvObj_cap->getPaletteSurface()->getAddress();
                dwOffset_cap = pNvObj_cap->getPaletteSurface()->getOffset();
                dwSize_cap   = pNvObj_cap->getPaletteSurface()->getSize();
            }
        }
        if (dwHeap_cap) {
            CAPTURE_LOCK lock;
            lock.dwJmpCommand         = CAPTURE_JMP_COMMAND;
            lock.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
            lock.dwExtensionID        = CAPTURE_XID_LOCK;
            lock.dwType               = CAPTURE_LOCK_TYPE_UNLOCK;
            lock.dwCtxDMAHandle       = (dwHeap_cap == CSimpleSurface::HEAP_VID)
                                      ? NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY
                                      : D3D_CONTEXT_DMA_HOST_MEMORY;
            lock.dwOffset             = dwOffset_cap;
            captureLog (&lock, sizeof(lock));
        }
    }
#endif

    /*
     * Signal that the texture surface has been unlocked.
     */
    if (caps & DDSCAPS_TEXTURE) {
        /*
         * get texture
         */
        CTexture *pTexture = GET_PNVOBJ(lpUnlockData->lpDDSurface)->getTexture();

        /*
         * user wants to unlock a texture - process elsewhere
         */
        if (IS_VALID_PNVOBJ(pTexture))
        {
            ddrval = nvTextureUnlock(pTexture,lpUnlockData);
            DDENDTICK(SURF4_UNLOCK);
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return ddrval;
        }
    }

    if ((caps & DDSCAPS_VIDEOMEMORY) && ((caps & DDSCAPS_TEXTURE) == 0)) {
        //unlock the video surface
        CNvObject *pNvObj;
        pNvObj = GET_PNVOBJ(lpUnlockData->lpDDSurface);
        if(pNvObj && pNvObj->getSimpleSurface()) pNvObj->getSimpleSurface()->cpuUnlock();
    }

#ifdef  STEREO_SUPPORT
    StereoLockSubstituteRestore(lpUnlockData);
#endif  //STEREO_SUPPORT

    pDDSGbl = lpUnlockData->lpDDSurface->lpGbl;

#ifndef WINNT
        if (lpUnlockData->lpDDSurface->ddsCaps.dwCaps & (DDSCAPS_FRONTBUFFER | DDSCAPS_PRIMARYSURFACE | DDSCAPS_VISIBLE)) {
            // signal "end access" to the display driver
            void *lpPDevice = GET_HALINFO()->lpPDevice;
            DrvCallbackFunc(NV_DRVSERVICE_ENDACCESS, lpPDevice, NULL);
        }
#endif

    if (IS_OVERLAY(caps,pDDSGbl->ddpfSurface.dwFourCC) &&
        (pDDSGbl->ddpfSurface.dwFourCC != FOURCC_NV12) &&
        ((caps & (DDSCAPS_VISIBLE | DDSCAPS_FRONTBUFFER)) ||
         (pDriverData->vpp.dwOverlaySurfaces < 3))) {

        // (H.AZAR: 08/17/99): surface must be visible to call VPP flip !
        if (!(caps & DDSCAPS_VIDEOPORT) && (caps & (DDSCAPS_VISIBLE
#ifndef WINNT
        | DDSCAPS_FRONTBUFFER
#endif
        )) && (pDriverData->bRing0FlippingFlag == FALSE)) {
            VppDoFlip(&(pDriverData->vpp),
                          pDDSGbl->fpVidMem - pDriverData->BaseAddress,
                          pDDSGbl->lPitch,
                          pDDSGbl->wWidth,
                          pDDSGbl->wHeight,
                          pDDSGbl->ddpfSurface.dwFourCC,
                          VPP_STATIC | VPP_WAIT);
        }
    }
#if (NVARCH >= 0x10)
    else if (pDDSGbl->ddpfSurface.dwFlags & DDPF_FOURCC) {
        if ((pDDSGbl->ddpfSurface.dwFourCC == FOURCC_NVMC) ||
            (pDDSGbl->ddpfSurface.dwFourCC == FOURCC_NVDS)) { // Is it our motion comp. control surface ?
            LPNVMCFRAMEDATA lpNvMCFrameData = (LPNVMCFRAMEDATA) VIDMEM_ADDR(pDDSGbl->fpVidMem);

            if (lpNvMCFrameData->bMCDestinationSurfaceIndex == 255) {
                lpUnlockData->ddRVal = DDERR_INVALIDPARAMS;
                DDENDTICK(SURF4_UNLOCK);
                NvReleaseSemaphore(pDriverData);
                dbgTracePop();
                return (DDHAL_DRIVER_HANDLED);
            } else if ((pDDSGbl->ddpfSurface.dwFourCC != FOURCC_NVDS) &&
                       (lpNvMCFrameData->bMCEndOfPicture))  {
                LPNVMCSURFACEFLAGS lpSurfaceFlags =
                    (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

                while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
                       (lpSurfaceFlags->dwMCSurfaceBase != pDriverData->dwMCMostRecentlyDecodedSurfaceBase)) {
                    lpSurfaceFlags++;
                }

                // Make sure surface has been format converted
                if (lpSurfaceFlags->dwMCSurfaceBase != 0) {
                    if ((lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) &&
                        (lpSurfaceFlags->bMCFrameAlreadyFormatConverted < 15))
                        nvMoCompConvertSurfaceFormat(lpSurfaceFlags->dwMCSurfaceBase, TRUE, 15);
                    else if (lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD) {
                        if ((lpSurfaceFlags->bMCFrameAlreadyFormatConverted & 3) < 3)
                            nvMoCompConvertSurfaceFormat(lpSurfaceFlags->dwMCSurfaceBase, TRUE, 3);
                    } else if (lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_BOTTOM_FIELD) {
                        if (lpSurfaceFlags->bMCFrameAlreadyFormatConverted < 12)
                            nvMoCompConvertSurfaceFormat(lpSurfaceFlags->dwMCSurfaceBase, TRUE, 12);
                    }
                    if ((lpSurfaceFlags->bMCFrameAlreadyFormatConverted == 15) &&
                        (lpSurfaceFlags->bMCFrameIsFiltered == FALSE) &&
                        (pDriverData->bMCTemporalFilterDisabled == FALSE))
                        nvMoCompTemporalFilter(lpSurfaceFlags->dwMCSurfaceBase, pDriverData->bMCPercentCurrentField);
                }
            }
        }
    }
#endif  // NVARCH >= 0x10

#ifdef CAPTURE
    if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
        if (dwHeap_cap) {
            CAPTURE_MEMORY_WRITE memwr;
            memwr.dwJmpCommand         = CAPTURE_JMP_COMMAND;
            memwr.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
            memwr.dwExtensionID        = CAPTURE_XID_MEMORY_WRITE;
            memwr.dwCtxDMAHandle       = (dwHeap_cap == CSimpleSurface::HEAP_VID)
                                       ? NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY
                                       : D3D_CONTEXT_DMA_HOST_MEMORY;
            memwr.dwOffset             = dwOffset_cap;
            memwr.dwSize               = dwSize_cap;
            captureLog (&memwr, sizeof(memwr));
            captureLog ((void*)dwAddr_cap, memwr.dwSize);
        }
    }
#endif

    // Handle AA: When unlocking a render target or Z buffer, magnify the
    // modified buffer back into the super buffer.
    // Scott C: Removed AA stuff, we'll leave the buffers as they are
    // (we just have to make sure to supersize the buffers if we start 3D
    // rendering again)

    lpUnlockData->ddRVal = DD_OK;

    DDENDTICK(SURF4_UNLOCK);
    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);

} /* Unlock32 */

//---------------------------------------------------------------------------

/*
 * WaitForVerticalBlank32
 */
// Old macro used when accessing raster register through the RM
#if 0
#define IS_IN_VBLANK(a) ((a)==0 || (a)>=(DWORD)GET_MODE_PHYSICAL_HEIGHT(cfgParams.Head))
#endif

// Macros used when accessing raster register directly
#define MASK_IN_VBLANK(a) (a & 0x00010000)
#define MASK_SCANLINE(a) (a & 0x000007FF)
#define VBLANK_REGISTER_OFFSET  0x600808    // Physical head 0, add 0x2000 for head 1

DWORD __stdcall WaitForVerticalBlank32 (LPDDHAL_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank)
{
    LONGLONG timeStart;
    LONGLONG timeFrequency;
    NV_CFGEX_CURRENT_SCANLINE_MULTI_PARAMS cfgParams;
    BOOL timeOut;
    #ifdef WINNT
    int dwTimeoutCount;
    #endif

    dbgTracePush ("WaitForVerticalBlank32");

    DDSTARTTICK(DEVICE_WAITVBL);
    nvSetDriverDataPtrFromDDGbl (lpWaitForVerticalBlank->lpDD);

    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvD3DRecover();
        }
        else {
            lpWaitForVerticalBlank->ddRVal = DD_OK;
            DDENDTICK(DEVICE_WAITVBL);
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
    }

#ifdef WINNT
    // under WINNT, we have a virtual desktop which spans both monitors, and it is not really possible
    // to make this work as a head specific thing, so just pick a head.
    cfgParams.Head = GET_CURRENT_HEAD();
    dwTimeoutCount = 1000000;
#else
    cfgParams.Head = pDXShare->dwPhysicalHeadNumber;
#endif

    if (GET_MODE_PHYSICAL_HEIGHT(cfgParams.Head) == 0) {
        // can have this degenerate case in win2k, a call into this routine without nvEnable being called
        // at a minimum, we need to init some of these display timing structures
        getDisplayDuration();
    }

    timeOut = FALSE;

    // **** IMPORTANT ****
    // The following piece of code could break with future versions of the chip
    // if the raster register is moved.  Unfortunately, accessing this register directly
    // is the only way to limit the time spent in this function and allow the
    // WHQL Surface Flipping test to succeed.
    // 02/02/2001 PG/Video group

    volatile DWORD* npNvRasterRegister;
    volatile DWORD dwRaster = 0;

    npNvRasterRegister = (DWORD*) pDriverData->NvBaseFlat;
    npNvRasterRegister += ((VBLANK_REGISTER_OFFSET + (cfgParams.Head == 1 ? 0x2000 : 0)) >> 2);

    switch ( lpWaitForVerticalBlank->dwFlags ) {

        case DDWAITVB_I_TESTVB:
            /*
             * if testvb is just a request for the current vertical blank status
             */
            lpWaitForVerticalBlank->ddRVal = DD_OK;

            /*
             * Monitor is on
             */

            // Read the raster register directly
            dwRaster = *npNvRasterRegister;

            lpWaitForVerticalBlank->bIsInVB = (MASK_IN_VBLANK(dwRaster) ? TRUE : FALSE);  // Bit 16 is one when in the VBLANK

            DDENDTICK(DEVICE_WAITVBL);
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);

        case DDWAITVB_BLOCKBEGIN:

            // The following code is for debug of 20001211-143119.
            // I am having trouble accessing this fields using softice.
            //   ... and I don't know why. -mlavoie
            {
                DWORD physicalModeHeight = (DWORD)GET_MODE_PHYSICAL_HEIGHT(cfgParams.Head);
                DWORD physicalModeHeight2 = pDriverData->flipPrimaryRecord.nvTimingInfo[cfgParams.Head].VDisplayEnd;

            }

            /*
             * Monitor is ON
             */
            /*
             * if blockbegin is requested we wait until the vertical blank
             * is over, and then wait for the display period to end.
             */
            // get start time for timeouts (display may be disabled)
            QueryPerformanceFrequency((LARGE_INTEGER *)&timeFrequency);
            QueryPerformanceCounter((LARGE_INTEGER*)&timeStart);

            dwRaster = *npNvRasterRegister;
            cfgParams.RasterPosition = MASK_SCANLINE(dwRaster);  // Keep the raster position (bits 10:0)

            while (MASK_IN_VBLANK(dwRaster) && !timeOut) {
                dwRaster = *npNvRasterRegister;
                cfgParams.RasterPosition = MASK_SCANLINE(dwRaster);  // Keep the raster position (bits 10:0)
#ifdef WINNT
                if (dwTimeoutCount-- <= 0)
                    timeOut = TRUE;
#else
                LONGLONG timeNow;
                QueryPerformanceCounter((LARGE_INTEGER*)&timeNow);
                if ((timeNow - timeStart) >= (timeFrequency / 20)) timeOut = TRUE;  // timout of 1/20th of a second
#endif
            }
            while (!MASK_IN_VBLANK(dwRaster) && !timeOut) {
                dwRaster = *npNvRasterRegister;
                cfgParams.RasterPosition = MASK_SCANLINE(dwRaster);  // Keep the raster position (bits 10:0)
#ifdef WINNT
                if (dwTimeoutCount-- <= 0)
                    timeOut = TRUE;
#else
                LONGLONG timeNow;
                QueryPerformanceCounter((LARGE_INTEGER*)&timeNow);
                if ((timeNow - timeStart) >= (timeFrequency / 20)) timeOut = TRUE;  // timout of 1/20th of a second
#endif
            }

            lpWaitForVerticalBlank->ddRVal = DD_OK;
            DDENDTICK(DEVICE_WAITVBL);
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);

        case DDWAITVB_BLOCKEND:

            /*
             * Monitor is ON
             */
            /*
             * if blockend is requested we wait for the vblank interval to end.
             */
            // get start time for timeouts (display may be disabled)
            QueryPerformanceFrequency((LARGE_INTEGER *)&timeFrequency);
            QueryPerformanceCounter((LARGE_INTEGER*)&timeStart);

            dwRaster = *npNvRasterRegister;
            cfgParams.RasterPosition = MASK_SCANLINE(dwRaster);  // Keep the raster position (bits 10:0)

            while (!MASK_IN_VBLANK(dwRaster) && !timeOut) {
                dwRaster = *npNvRasterRegister;
                cfgParams.RasterPosition = MASK_SCANLINE(dwRaster);  // Keep the raster position (bits 10:0)
#ifdef WINNT
                if (dwTimeoutCount-- <= 0)
                    timeOut = TRUE;
#else
                LONGLONG timeNow;
                QueryPerformanceCounter((LARGE_INTEGER*)&timeNow);
                if ((timeNow - timeStart) >= (timeFrequency / 20)) timeOut = TRUE;  // timout of 1/20th of a second
#endif
            }
            while (MASK_IN_VBLANK(dwRaster) && !timeOut) {
                dwRaster = *npNvRasterRegister;
                cfgParams.RasterPosition = MASK_SCANLINE(dwRaster);  // Keep the raster position (bits 10:0)
#ifdef WINNT
                if (dwTimeoutCount-- <= 0)
                    timeOut = TRUE;
#else
                LONGLONG timeNow;
                QueryPerformanceCounter((LARGE_INTEGER*)&timeNow);
                if ((timeNow - timeStart) >= (timeFrequency / 20)) timeOut = TRUE;  // timout of 1/20th of a second
#endif
            }

            lpWaitForVerticalBlank->ddRVal = DD_OK;
            DDENDTICK(DEVICE_WAITVBL);
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
    }

    DDENDTICK(DEVICE_WAITVBL);
    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (DDHAL_DRIVER_NOTHANDLED);

} /* WaitForVerticalBlank32 */

//---------------------------------------------------------------------------

/*
 * GetScanLine32
 */
DWORD __stdcall GetScanLine32( LPDDHAL_GETSCANLINEDATA lpGetScanLine )
{
    volatile DWORD* npNvRasterRegister;
    volatile DWORD dwRaster;
    NV_CFGEX_CURRENT_SCANLINE_MULTI_PARAMS cfgParams;
#if 0
    DWORD dwModeHeight;
#endif

    dbgTracePush ("GetScanLine32");

    DDSTARTTICK(DEVICE_GETSCANLINE);
    nvSetDriverDataPtrFromDDGbl (lpGetScanLine->lpDD);

    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvD3DRecover();
        }
        else {
            lpGetScanLine->ddRVal = DDERR_VERTICALBLANKINPROGRESS;
            DDENDTICK(DEVICE_GETSCANLINE);
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return(DDHAL_DRIVER_HANDLED);
        }
    }

    /*
     * If a vertical blank is in progress the scan line is in
     * indeterminant. If the scan line is indeterminant we return
     * the error code DDERR_VERTICALBLANKINPROGRESS.
     * Otherwise we return the scan line and a success code
     */
#ifdef WINNT
    // under WINNT, we have a virtual desktop which spans both monitors, and it is not really possible
    // to make this work as a head specific thing, so just pick the primary head.
    cfgParams.Head = GET_CURRENT_HEAD();
    if (GET_MODE_PHYSICAL_HEIGHT(cfgParams.Head) == 0) {
         // can have this degenerate case in win2k, a call into this routine without nvEnable being called
        // at a minimum, we need to init some of these display timing structures
        getDisplayDuration();

    }
#if 0
    dwModeHeight = (DWORD)GET_MODE_PHYSICAL_HEIGHT(cfgParams.Head);

    if ((ppdev->ulDesktopMode & NV_SPANNING_MODE) &&
         ppdev->TwinView_Orientation == VERTICAL_ORIENTATION) {
        dwModeHeight >>= 1;
    }
#endif

#else
    // RM needs physical head, map logical to physical
    NVTWINVIEWDATA twinData;
    twinData.dwFlag   = NVTWINVIEW_FLAG_GET;
    twinData.dwAction = NVTWINVIEW_ACTION_MAP_LOG_TO_PHYS_HEAD;
    twinData.dwCrtc   = pDXShare->dwHeadNumber;
    MyExtEscape (pDXShare->dwHeadNumber, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPCSTR) &twinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &twinData);

    cfgParams.Head    = twinData.dwCrtc;
    if (GET_MODE_PHYSICAL_HEIGHT(cfgParams.Head) == 0) {
        // can have this degenerate case in win2k, a call into this routine without nvEnable being called
        // at a minimum, we need to init some of these display timing structures
        getDisplayDuration();
    }
#if 0
    dwModeHeight = (DWORD)GET_MODE_PHYSICAL_HEIGHT(cfgParams.Head);

    // not really possible to make this work correctly for both heads in clone mode, one will always be wrong
    NvRmConfigGetEx (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
        NV_CFGEX_CURRENT_SCANLINE_MULTI, &cfgParams, sizeof(cfgParams));

    lpGetScanLine->dwScanLine = cfgParams.RasterPosition;
#endif

#endif
    // **** IMPORTANT ****
    // The following piece of code could break with future versions of the chip
    // if the raster register is moved.  Unfortunately, accessing this register directly
    // is the only way to limit the time spent in this function and allow the
    // WHQL Read Scanline test to succeed.
    // Kept the old way of doing for future reference or in case we can ever go back to it.
    // 02/01/2001 PG/Video Group

    // Read the raster register directly
    npNvRasterRegister = (DWORD*) pDriverData->NvBaseFlat;
    npNvRasterRegister += ((VBLANK_REGISTER_OFFSET + (cfgParams.Head == 1 ? 0x2000 : 0)) >> 2);
    dwRaster = *npNvRasterRegister;
    lpGetScanLine->dwScanLine = MASK_SCANLINE(dwRaster);  // Keep the raster position (bits 10:0)

    if (MASK_IN_VBLANK(dwRaster))  // Bit 16 is one when in the VBLANK
        lpGetScanLine->ddRVal = DDERR_VERTICALBLANKINPROGRESS;
    else
        lpGetScanLine->ddRVal = DD_OK;

    DDENDTICK(DEVICE_GETSCANLINE);
    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);

} /* GetScanLine32 */

//---------------------------------------------------------------------------

/*
 * SetSurfaceColorKey32
 */

DWORD __stdcall SetSurfaceColorKey32(LPDDHAL_SETCOLORKEYDATA lpSetColorKey)
{
    LPDDRAWI_DIRECTDRAW_GBL   pdrv;
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl;

    dbgTracePush ("SetSurfaceColorKey32: lpSetCK->lpDD=%08x, lpSetCK->lpDDSurface = %08x",
                  lpSetColorKey->lpDD, lpSetColorKey->lpDDSurface);

    DDSTARTTICK(SURF4_SETCOLORKEY);
    nvSetDriverDataPtrFromDDGbl (lpSetColorKey->lpDD);

    pdrv = lpSetColorKey->lpDD;
    pDDSLcl = lpSetColorKey->lpDDSurface;

    if (lpSetColorKey->dwFlags == DDCKEY_SRCBLT) {
        pDDSLcl->ddckCKSrcBlt.dwColorSpaceLowValue  = lpSetColorKey->ckNew.dwColorSpaceLowValue & pDriverData->physicalColorMask;
        // Use no mask on this one on NV3 so that our D3D driver can get all the bits when surface is 565
        pDDSLcl->ddckCKSrcBlt.dwColorSpaceHighValue = lpSetColorKey->ckNew.dwColorSpaceHighValue;
        CNvObject *pNvObj = GET_PNVOBJ (pDDSLcl);
        if (IS_VALID_PNVOBJ(pNvObj) && (pNvObj->getClass() == CNvObject::NVOBJ_TEXTURE)) {
            CTexture *pTex = pNvObj->getTexture();
            DWORD     dwColorKey;
            BOOL      bRV;
            bRV = nvCalculateColorKey (&dwColorKey, pDDSLcl, pTex->getFormat());
            nvAssert (bRV);
            pTex->tagColorKey();
            pTex->setColorKey (dwColorKey);
        }
    }

    else if (lpSetColorKey->dwFlags == DDCKEY_DESTOVERLAY) {
        pDDSLcl->ddckCKDestOverlay.dwColorSpaceLowValue  = lpSetColorKey->ckNew.dwColorSpaceLowValue & pDriverData->physicalColorMask;
        pDDSLcl->ddckCKDestOverlay.dwColorSpaceHighValue = lpSetColorKey->ckNew.dwColorSpaceHighValue & pDriverData->physicalColorMask;
    }

    else {
        lpSetColorKey->ddRVal = DDERR_UNSUPPORTED;
        DDENDTICK(SURF4_SETCOLORKEY);
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    lpSetColorKey->ddRVal = DD_OK;
    DDENDTICK(SURF4_SETCOLORKEY);
    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}


/********************************************************************************
 *
 * FUNCTION: GetK32ProcAddress
 *
 * DESC: A helper routine for getting the Win16 mutex.
 *
 *
 * Win32 code to import by ordinal from KERNEL32.DLL in Windows 95
 *
 * Andrew Schulman
 * andrew@ora.com
 * http://www.ora.com/windows/
 * ftp://ftp.ora.com/pub/examples/windows/win95.update/schulman.html
 * August 1995
 *
 ********************************************************************************/

#include "k32exp.h"

#define ENEWHDR     0x003CL         /* offset of new EXE header */
#define EMAGIC      0x5A4D          /* old EXE magic id:  'MZ'  */
#define PEMAGIC     0x4550          /* NT portable executable */

#define GET_DIR(x)  (hdr->OptionalHeader.DataDirectory[x].VirtualAddress)

static DWORD WINAPI GetK32ProcAddress(HMODULE hMod, int ord)
{
    IMAGE_NT_HEADERS       *hdr;
    IMAGE_EXPORT_DIRECTORY *exp;
    DWORD                  *AddrFunc;
    WORD                   enewhdr, *pw;
    BYTE                   *moddb;

    dbgTracePush ("GetK32ProcAddress");

    moddb = (BYTE *) hMod;
    pw = (WORD *) &moddb[0];
    if (*pw != EMAGIC) {
        dbgTracePop();
        return 0;
    }
    pw = (WORD *) &moddb[ENEWHDR];
    enewhdr = *pw;
    pw = (WORD *) &moddb[enewhdr];
    if (*pw != PEMAGIC) {
        dbgTracePop();
        return 0;
    }
    hdr = (IMAGE_NT_HEADERS *) pw;

    // Note: offset from moddb, *NOT* from hdr!
    exp = (IMAGE_EXPORT_DIRECTORY *) (((DWORD) moddb) +
                                      ((DWORD) GET_DIR(IMAGE_DIRECTORY_ENTRY_EXPORT)));
    AddrFunc = (DWORD *) (moddb + (DWORD) exp->AddressOfFunctions);

    // should verify that e.g.:
    // GetProcAddress(nvProcessGlobalData.win9x.hmod, "VirtualAlloc") == GetK32ProcAddress(710);

    ord--;  // table is 0-based, ordinals are 1-based
    if (ord < (int)exp->NumberOfFunctions) {
        dbgTracePop();
        return ((DWORD)(moddb + AddrFunc[ord]));
    }

    dbgTracePop();
    return (0);
}

#ifndef WINNT
/********************************************************************************
 *
 * FUNCTION: nvGetWin16MutexProcAddresses
 *
 * DESC: Get a pointer to the Win16 mutex routines in kernel32.dll.
 *
 ********************************************************************************/
typedef void (WINAPI *GETPWIN16MUTEX)(DWORD *);
typedef void (WINAPI *ENTERSYSLEVEL)(DWORD);
typedef void (WINAPI *LEAVESYSLEVEL)(DWORD);

BOOL nvGetWin16MutexProcAddresses(LPDWORD         win16Mutex,
                                  GETPWIN16MUTEX *lpfnGetpWin16Mutex,
                                  ENTERSYSLEVEL  *lpfnEnterSysLevel,
                                  ENTERSYSLEVEL  *lpfnLeaveSysLevel)
{
    HMODULE hMod = NULL;

    dbgTracePush ("nvGetWin16MutexProcAddresses");

    *win16Mutex         = 0;
    *lpfnGetpWin16Mutex = NULL;
    *lpfnEnterSysLevel  = NULL;
    *lpfnLeaveSysLevel  = NULL;

    hMod = GetModuleHandle("KERNEL32");

    if (hMod == NULL) { // still
        dbgTracePop();
        return FALSE;
    }

    *lpfnGetpWin16Mutex = (GETPWIN16MUTEX)GetProcAddress(hMod, "GetpWin16Lock");
    *lpfnEnterSysLevel  = (ENTERSYSLEVEL) GetProcAddress(hMod, "_EnterSysLevel");
    *lpfnLeaveSysLevel  = (LEAVESYSLEVEL) GetProcAddress(hMod, "_LeaveSysLevel");

    if (*lpfnGetpWin16Mutex == NULL) {
        *lpfnGetpWin16Mutex = (GETPWIN16MUTEX)GetK32ProcAddress(hMod, GETPWIN16MUTEX_ORD);
        *lpfnEnterSysLevel  = (ENTERSYSLEVEL) GetK32ProcAddress(hMod, ENTERSYSLEVEL_ORD);
        *lpfnLeaveSysLevel  = (LEAVESYSLEVEL) GetK32ProcAddress(hMod, LEAVESYSLEVEL_ORD);
    }

    if (*lpfnGetpWin16Mutex) {
        (*(*lpfnGetpWin16Mutex))(win16Mutex);
        dbgTracePop();
        return TRUE;
    }
    dbgTracePop();
    return (FALSE);
}

//---------------------------------------------------------------------------

// enumerate all the NVIDIA boards and store their pDXShare pointers in the g_adapterData table.
// returns TRUE if an nvidia display adapter is found and enabled, false otherwise.

BOOL nvFillAdapterTable (void)
{
    dbgTracePush ("nvFillAdapterTable");

    BOOL bEnabled = FALSE;

    if (global.pfEnumDisplayDevices) {

        DISPLAY_DEVICE DisplayDevice;
        DisplayDevice.cb = sizeof(DisplayDevice);

        for (DWORD dwDevNum=0; global.pfEnumDisplayDevices(NULL, dwDevNum, &DisplayDevice, 0); dwDevNum++) {

            if (DisplayDevice.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP) {

                // create a DC for this display
                HDC hDC = CreateDC (NULL, (LPCSTR)DisplayDevice.DeviceName, NULL, NULL);

                if (hDC) {

                    // make sure this is an NVidia display driver
                    DISPDRVDIRECTXCOMMON *pThisDXShare = 0;

                    if (ExtEscape (hDC, NV_ESC_GET_FLAT_DIRECTX_SHARED_DATA, 0, NULL, 8, (LPSTR) &pThisDXShare) && pThisDXShare) {

                        // add this pDXShare to our g_adapterData table
                        g_adapterData[dwDevNum].pDXShare = pThisDXShare;

                        // only return TRUE if the current pDXShare belongs to an active driver
                        if (pDXShare == pThisDXShare) {
                            bEnabled = TRUE;
                        }

                        // get logical to physical head mapping
                        NVTWINVIEWDATA twinData;
                        twinData.dwFlag   = NVTWINVIEW_FLAG_GET;
                        twinData.dwAction = NVTWINVIEW_ACTION_MAP_LOG_TO_PHYS_HEAD;
                        twinData.dwCrtc   = pThisDXShare->dwHeadNumber;
                        ExtEscape(hDC, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPCSTR) &twinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &twinData);
                        pThisDXShare->dwPhysicalHeadNumber = twinData.dwCrtc;
                    } else {

                        // not an NVIDIA driver
                        g_adapterData[dwDevNum].pDXShare    = NULL;
                        g_adapterData[dwDevNum].pDriverData = NULL;

                    }

                    DeleteDC (hDC);

                } // if (hDC)

            } else {

                // not attached to desktop (inactive)
                g_adapterData[dwDevNum].pDXShare    = NULL;
                g_adapterData[dwDevNum].pDriverData = NULL;

            }

        }  // for

    }

    else {

        // Windows 95 - no multi-mon
        bEnabled = TRUE;
        g_adapterData[0].pDXShare = pDXShare;

    }

    dbgTracePop();
    return (bEnabled);
}

//---------------------------------------------------------------------------

// return a DC handle for the specified device.

HDC nvCreateDCHandle (DISPDRVDIRECTXCOMMON *pDXS)
{
    dbgTracePush ("nvCreateDCHandle");

    if (global.pfEnumDisplayDevices) {

        DISPLAY_DEVICE DisplayDevice;
        DisplayDevice.cb = sizeof(DisplayDevice);

        for (DWORD dwDevNum=0; global.pfEnumDisplayDevices(NULL, dwDevNum, &DisplayDevice, 0); dwDevNum++) {

            if (DisplayDevice.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP) {

                // create a DC for this display
                HDC hDC = CreateDC (NULL, (LPCSTR)DisplayDevice.DeviceName, NULL, NULL);

                if (hDC) {

                    DISPDRVDIRECTXCOMMON *pThisDXShare = 0;

                    if (ExtEscape (hDC, NV_ESC_GET_FLAT_DIRECTX_SHARED_DATA, 0, NULL, 8, (LPSTR)&pThisDXShare)) {
                        if (pDXS == pThisDXShare) {
                            // success! found the DC for this display.
                            dbgTracePop();
                            return (hDC);
                        }
                    }

                    DeleteDC (hDC);

                } // if (hDC)

            } // if (ATTACHED)

        } // for

    }

    else {

        // Windows 95 - no multi-mon
        dbgTracePop();
        return (GetDC (NULL));

    }

    DPF ("failed to find hDC!");

    dbgTracePop();
    return (NULL);
}

//--------------------------------------------------------------------------

// free the given DC handle if necessary

void nvDestroyDCHandle (HDC hDC)
{
    dbgTracePush ("nvDestroyDCHandle");

    if ((global.pfEnumDisplayDevices) && (hDC)) {
        DeleteDC (hDC);
    }
    // else win95, no need to delete...

    dbgTracePop();
}
#endif // !WINNT

/***************************************************************************
 *DestroyDriver32
 ***************************************************************************/
#ifdef VTUNE_SUPPORT
void nvVTuneFlushData (void);
#endif

/*
 * Under NT, DestroyDriver32 does not exist as a HAL function. However,
 * we still need to perform its cleanup tasks when DX is disabled.
 * So the NT display driver calls this routine when DX is turned off.
 */
#ifdef WINNT
HRESULT __stdcall DestroyDriver32(GLOBALDATA *pDrvData)
#else // !WINNT
HRESULT __stdcall DestroyDriver32(LPDDHAL_DESTROYDRIVERDATA pDestroyDriverData)
#endif  // !WINNT
{
    LPDDRAWI_DIRECTDRAW_GBL     pDDGbl;
    DWORD                       index = 0;
    DWORD                       i;
    DWORD                       retval = DDHAL_DRIVER_HANDLED;
    dbgTracePush ("DestroyDriver32");

#ifdef WINNT

    pDDGbl = NULL; // Under NT this is never used.
    NvAcquireSemaphore((CDriverContext *)pDrvData);
    pDriverData = (CDriverContext *)pDrvData;

#endif

    // must flush all before destroying anything
    if (getDC()->nvPusher.isValid()) {
        getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);
        while (getFlipStatusPrimary(FLIP_ANYSURFACE) != DD_OK) {
            NV_SLEEPFLIP;
        }
    }

#ifdef KPFS
#if (NVARCH >= 0x20)
    pDriverData->nvKelvinPM.destroy();
#endif
#endif

#if IS_WIN9X

    DWORD                       win16Mutex;
    GETPWIN16MUTEX              lpfnGetpWin16Mutex;
    ENTERSYSLEVEL               lpfnEnterSysLevel;
    ENTERSYSLEVEL               lpfnLeaveSysLevel;
    DCICMD sMyDciCmd;

    // if full-screen DOS happened, destroy all the contexts as we don't get any calls from MS to do this, bad MS.
    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        D3DHAL_CONTEXTDESTROYALLDATA cdd;
        cdd.dwPID = ~0;
        nvContextDestroyAll(&cdd);
    }

    nvSetDriverDataPtrFromDDGbl (pDestroyDriverData->lpDD);
    pDDGbl = pDestroyDriverData->lpDD;

    // Assume call will succeed, will flag errors when they occur.
    pDestroyDriverData->ddRVal = DD_OK;

    pDriverData->dwDrvRefCount--;
    if (pDriverData->dwDrvRefCount != 0) {
        DWORD dwRoot;
        getAdapterIndex(pDXShare, &dwRoot);
        if (dwRoot == -1) {     // assume this is the AGP device
            // free the AGP push buffer here, a PCI push buffer should auto-create for the other device.
            nvDisable32();
        }

        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (retval);
    }

    // Call back to 16 bit direct draw code so it knows that
    // DirectX is going away.  Do this after the DC's are released.
    sMyDciCmd.dwVersion = DD_VERSION;
    sMyDciCmd.dwCommand = DDNVDESTROYDRIVEROBJECT;
    MyExtEscape(pDXShare->dwHeadNumber, DCICOMMAND, sizeof(DCICMD), (const char *)&sMyDciCmd, 0, 0);

    nvGetWin16MutexProcAddresses(&win16Mutex, &lpfnGetpWin16Mutex,
                                 &lpfnEnterSysLevel, &lpfnLeaveSysLevel);

    // grab win16 mutex
    if (lpfnEnterSysLevel) {
        (*(lpfnEnterSysLevel))(win16Mutex);
    }

#endif // !WINNT

#ifdef VTUNE_SUPPORT
    nvVTuneFlushData();
#endif

#ifdef ENABLE_VPP_DISPATCH_CODE
#ifndef WINNT
    vppDestroyDispatcher(&(pDriverData->vpp));
#endif // !WINNT
#endif

#ifdef WINNT
    //walk the pcontext list and deactivate ALL AA setup.
    //this is to fixe a strange AA config problem in MS Baseball
    PNVD3DCONTEXT pContext = (PNVD3DCONTEXT)pDriverData->dwContextListHead;
    while (pContext)
    {
        if(pContext->pDriverData == pDriverData){
            if(pContext->aa.isEnabled()) nvCelsiusAADestroy(pContext);
        }
        pContext = pContext->pContextNext; // next
    }
#endif

    // make sure all floating context DMA's are freed
    DWORD dwContextDma;
    for (i=0; i < pDriverData->bltData.dwSystemSurfaceContextDMAIndex; i+=2) {
        dwContextDma = NV_DD_FLOATING_CONTEXT_DMA_BASE + i;
        // HWFIX: deal with hw hash table bug, swap bits 1 and 2 with 11 and 22 (which are part of the hash function)
        dwContextDma = ((dwContextDma & 0x00000002) << 10) | ((dwContextDma & 0x00000800) >> 10) |
                       ((dwContextDma & 0x00000004) << 20) | ((dwContextDma & 0x00400000) >> 20) |
                       (dwContextDma & ~0x00400806);
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, dwContextDma);
    }
    pDriverData->bltData.dwSystemSurfaceContextDMAIndex = 0;

    // deallocate all blt workspaces
    if (pDriverData->bltVidMemInfo.dwLocale == BLTWS_VIDEO) {
        NVHEAP_FREE(pDriverData->bltVidMemInfo.fpVidMem);
        pDriverData->bltVidMemInfo.dwLocale = BLTWS_UNINITIALIZED;
    }
    if (pDriverData->bltSysMemInfo.dwLocale == BLTWS_SYSTEM) {
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, pDriverData->bltSysMemInfo.dwContextDma);
        FreeIPM((void*)pDriverData->bltSysMemInfo.fpVidMem);
        pDriverData->bltSysMemInfo.dwLocale = BLTWS_UNINITIALIZED;
    }
    if (pDriverData->bltAGPMemInfo.dwLocale == BLTWS_AGP) {
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, pDriverData->bltAGPMemInfo.dwContextDma);
        nvAGPFree((void*)pDriverData->bltAGPMemInfo.fpVidMem);
        pDriverData->bltAGPMemInfo.dwLocale = BLTWS_UNINITIALIZED;
    }

    // Clear motion comp context
    pDriverData->dwMCNVMCSurface = 0;
    pDriverData->dwMCNVDSSurfaceBase = 0;
    pDriverData->dwMCCurrentCelsiusIDCTCtxDma = 0;

    for (i=0; i<4; i++) {
        pDriverData->dwMCIDCTAGPSurfaceBase[i] = 0;
        if (pDriverData->dwMCIDCTAGPCtxDmaSize[i] != 0) {
            NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                     NV_DD_DMA_FLOATING_MC_IDCT0_CONTEXT_DMA_FROM_MEMORY+i);
            pDriverData->dwMCIDCTAGPCtxDmaSize[i] = 0;
        }
    }

    // If an overlay is currently active then shut it down
    if ((getDC()->nvPusher.isValid()) && (pDriverData->vpp.dwOverlaySurfaces > 0)) {

        FAST long videoFreeCount = pDriverData->NvVideoFreeCount;
        LPPROCESSINFO lpProcInfo = pmGetProcess(pDriverData, GetCurrentProcessId());

        // make sure we sync with other channels before writing put
        getDC()->nvPusher.setSyncChannelFlag();

        // Trash spare subchannel
        pDriverData->dwRingZeroMutex = TRUE;

        Sleep(VPP_TIMEOUT_TIME * 3);

        // Should not be talking directly to VPP objects -@mjl@
        nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
        nvPushData(1, NV_VPP_OVERLAY_IID);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | NV07A_STOP_OVERLAY(0) | 0x80000);
        nvPushData(3, NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE);  // StopOverlay[0]
        nvPushData(4, NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE);  // StopOverlay[1]
        nvPusherAdjust(5);
        nvPusherStart(TRUE);

        pDriverData->dwRingZeroMutex = FALSE;
        pDriverData->dDrawSpareSubchannelObject = 0;

        GET_HALINFO()->ddCaps.dwCurrVisibleOverlays = 0;
    }

    pmDeleteAllProcesses(pDriverData);


    /*
     * This routine will insure that any allocated preapproved context is destroyed.
     */
    nvDestroyPreapprovedContexts();

#ifndef WINNT
    pDriverData->HALCallbacks.lpSetInfo = 0;
#endif  // WINNT

    if (!nvDisable32()) {
#ifdef WINNT
        retval = DDHAL_DRIVER_NOTHANDLED;
#else // !WINNT
        pDestroyDriverData->ddRVal = DDERR_GENERIC;
#endif // !WINNT
    }

    // Free any existing dynamic context dma objects
    if (pDriverData->dwVidMemCtxDmaSize != 0) {
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY);
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY);
        pDriverData->dwVidMemCtxDmaSize = 0;
    }

    VppDestructor(&pDriverData->vpp);

    // Make sure we reset the current Celsius user to none
    pDriverData->dwMostRecentHWUser = MODULE_ID_NONE;

    if (pDriverData->NvDevVideoFlatPio != 0) {
        NvRmFree(pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_DD_DEV_VIDEO);
        pDriverData->NvDevVideoFlatPio = 0;
    }

    // Let 16 bit Display Driver code know that Direct Draw is no longer active
    pDriverData->DDrawVideoSurfaceCount = 0;

    pDriverData->fNvActiveFloatingContexts = 0;

#ifdef WINNT
    if (pDriverData->GARTLinearBase) {
        getDC()->defaultVB.destroy();
#ifndef NV_AGP
        NvWin2KUnmapAgpHeap(ppdev);
#endif // !NV_AGP
    }
#else // !WINNT
#ifndef NV_AGP
    // Reset AGP GART addresses
    pDriverData->GARTLinearBase = 0;
    pDriverData->GARTPhysicalBase = 0;
#endif // !NVAGP
#endif // !WINNT

    pDriverData->dwRingZeroMutex = FALSE;

#ifndef WINNT   // WINNT BUG
    pMySurfaces = NULL;

    // release win16 mutex
    if (lpfnLeaveSysLevel) {
        (*(lpfnLeaveSysLevel))(win16Mutex);
    }
#endif // !WINNT

    // delete the inner loop table entries
    for(i = 0; i < DRAW_PRIM_TABLE_ENTRIES; i++)
    {
        // release inner loops
        CILHashEntry *pEntry = (CILHashEntry*)dwDrawPrimitiveTable[i];
        while (pEntry)
        {
            CILHashEntry *pNext = pEntry->getNext();
            delete pEntry;
            pEntry = pNext;
        }
    }

    nvPatchDestroyFD();

    // clear the inner loop lookup table to zero
    memset ((void *)dwDrawPrimitiveTable, 0, DRAW_PRIM_TABLE_ENTRIES<<2);
    global.celsius.dwLoopCache = 0;
#if (NVARCH >= 0x20)
    global.kelvin.dwLoopCache = 0;
#endif
    // also clear the compiled memcopy routines
    memset (global.adwMemCopy,0,sizeof(global.adwMemCopy));

    // finally free the memory
    if (global.dwILCData) {
        // kill compiled state variables
        FreeIPM(global.dwILCData);
        global.dwILCData  = 0;
        global.dwILCCount = 0;
        global.dwILCMax   = 0;
    }


#ifdef CNT_TEX

    HANDLE hFile = CreateFile("\\TexDL.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL);

    char cTempBuf[64];
    DWORD dwTotVid, dwTotAgp, dwTot;
    dwTotVid = 0;
    dwTotAgp = 0;
    SetFilePointer(hFile, 0,0,FILE_END);
    if (g_dwFrames > MAX_FRAME_CNT)
        g_dwFrames = MAX_FRAME_CNT;

    for (int iFrmCnt=0; iFrmCnt < (int)g_dwFrames; iFrmCnt++) {
        sprintf(cTempBuf, "\nFrame: %d", iFrmCnt);
        WriteFile(hFile, cTempBuf, strlen(cTempBuf), &dwTot, NULL);
        sprintf(cTempBuf, "\n\tNumber of Video Texture Downloads: %d", g_dwVidTexDL[iFrmCnt]);
        WriteFile(hFile, cTempBuf, strlen(cTempBuf), &dwTot, NULL);
        sprintf(cTempBuf, "\n\tNumber of AGP Texture Downloads: %d\n", g_dwAgpTexDL[iFrmCnt]);
        WriteFile(hFile, cTempBuf, strlen(cTempBuf), &dwTot, NULL);

        dwTotVid += g_dwVidTexDL[iFrmCnt];
        dwTotAgp += g_dwAgpTexDL[iFrmCnt];
        g_dwVidTexDL[iFrmCnt] = 0;
        g_dwAgpTexDL[iFrmCnt] = 0;
    }

    // print out totals
    sprintf(cTempBuf, "\nTotal Number of Frames: %d", g_dwFrames);
    WriteFile(hFile, cTempBuf, strlen(cTempBuf), &dwTot, NULL);
    sprintf(cTempBuf, "\nTotal Number of Video Texture Downloads: %d", dwTotVid);
    WriteFile(hFile, cTempBuf, strlen(cTempBuf), &dwTot, NULL);
    sprintf(cTempBuf, "\nTotal Number of AGP Texture Downloads: %d\n", dwTotAgp);
    WriteFile(hFile, cTempBuf, strlen(cTempBuf), &dwTot, NULL);

    CloseHandle(hFile);

    g_dwFrames = 0;
#endif

    // bAssertModeDirectDraw checks this to know if DriverInit() needs to be called again
    // in some modeset sequences.  The initialization sequence on Win9x requires that we
    // do not clear this however... *sigh*  it's a mess.
#if IS_WINNT5
    pDriverData->dwRootHandle = 0;
#endif

#if IS_WIN9X
    // kill timer proc
    if (pDriverData->dwTVTunerTimer) {
        KillTimer(NULL, pDriverData->dwTVTunerTimer);
    }

    // compact the heap and display usage
    g_nvIPHeap.checkHeapUsage();

    // done
    pDestroyDriverData->ddRVal = DD_OK;
#endif // IS_WIN9X

#ifdef NVSTATDRIVER
            DetachNVStat();
#endif // NVSTATDRIVER

    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (retval);
} // DestroyDriver32

//---------------------------------------------------------------------------

/*
 * GetHeapAlignment32
 *
 * Returns more specific heap alignment requirements to DDRAW than
 * those described in the heap structure.
 */

DWORD __stdcall GetHeapAlignment32 (LPDDHAL_GETHEAPALIGNMENTDATA lpGhaData)
{
    dbgTracePush ("GetHeapAlignment32");

    lpGhaData->ddRVal= DD_OK;

    if (lpGhaData->dwHeap == 0) {
        lpGhaData->Alignment.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN |
                                              DDSCAPS_EXECUTEBUFFER |
                                              DDSCAPS_OVERLAY |
                                              DDSCAPS_TEXTURE |
                                              DDSCAPS_ZBUFFER |
                                              DDSCAPS_ALPHA |
                                              DDSCAPS_FLIP;

        /* Alignments in bytes */

        lpGhaData->Alignment.ExecuteBuffer.Linear.dwStartAlignment = 0;
        lpGhaData->Alignment.ExecuteBuffer.Linear.dwPitchAlignment = 0;

        lpGhaData->Alignment.Overlay.Linear.dwStartAlignment = NV_OVERLAY_BYTE_ALIGNMENT;
        lpGhaData->Alignment.Overlay.Linear.dwPitchAlignment = NV_OVERLAY_BYTE_ALIGNMENT;

        lpGhaData->Alignment.Texture.Linear.dwStartAlignment = pDriverData->dwSurfaceAlign; /* Texture surfaces, not our optimized texture alignment */
        lpGhaData->Alignment.Texture.Linear.dwPitchAlignment = pDriverData->dwSurfaceAlign;

        lpGhaData->Alignment.ZBuffer.Linear.dwStartAlignment = pDriverData->dwSurfaceAlign;
        lpGhaData->Alignment.ZBuffer.Linear.dwPitchAlignment = pDriverData->dwSurfaceAlign;

        lpGhaData->Alignment.AlphaBuffer.Linear.dwStartAlignment = pDriverData->dwSurfaceAlign;
        lpGhaData->Alignment.AlphaBuffer.Linear.dwPitchAlignment = pDriverData->dwSurfaceAlign;

        lpGhaData->Alignment.Offscreen.Linear.dwStartAlignment = pDriverData->dwSurfaceAlign;
        lpGhaData->Alignment.Offscreen.Linear.dwPitchAlignment = pDriverData->dwSurfaceAlign;

        lpGhaData->Alignment.FlipTarget.Linear.dwStartAlignment = pDriverData->dwSurfaceBitAlign;
        lpGhaData->Alignment.FlipTarget.Linear.dwPitchAlignment = pDriverData->dwSurfaceAlign;

    }
    else {
        DPF("D3D: GetHeapAlignment32 - invalid parameters 10");
        lpGhaData->ddRVal = DDERR_INVALIDPARAMS;
        dbgTracePop();
        return (DDHAL_DRIVER_NOTHANDLED);
    }

    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);

} /* GetHeapAlignment32 */

#ifndef WINNT
/*
 * This callback is Win9x specific - for its Winnt counterpart, see
 * GetDriverInfo32.GUID_UpdateNonLocalHeap.
 */

//---------------------------------------------------------------------------

/*
 * UpdateNonLocalHeap32
 *
 * Records actual AGP memory linear and physical addresses.
 */

DWORD __stdcall UpdateNonLocalHeap32( LPDDHAL_UPDATENONLOCALHEAPDATA lpd )
{
    dbgTracePush ("UpdateNonLocalHeap32");

    nvSetDriverDataPtrFromDDGbl (lpd->lpDD);

    // the heap has been ripped out from under us. mark it invalid so we don't try to use it
    nvAGPInvalidate();

    bltDestroyAllContextDMAs(lpd->lpDD);

    if (pDriverData->bltAGPMemInfo.dwLocale == BLTWS_SYSTEM) {
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, pDriverData->bltAGPMemInfo.dwContextDma);
        nvAGPFree((void*)pDriverData->bltAGPMemInfo.fpVidMem);
        pDriverData->bltAGPMemInfo.dwLocale = BLTWS_UNINITIALIZED;
    }

    if (pDriverData->dwFullScreenDOSStatus & (FSDOSSTATUS_RECOVERYNEEDED_D3D | FSDOSSTATUS_RECOVERYNEEDED_DDRAW)) {
        if (!(pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE)) {
            lpd->ddRVal = DDERR_GENERIC;
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
    }

#ifdef CAPTURE
    if ((getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) &&
        (getDC()->nvD3DRegistryData.regCaptureConfig & D3D_REG_CAPTURECONFIG_FORCEPCI)) {
        pDriverData->GARTPhysicalBase = 0;
        pDriverData->GARTLinearBase = 0;
    }
    else
#endif

    if ((lpd->dwHeap == AGP_HEAP) && (lpd->fpGARTLin != 0)) { // AGP heap

        // This is the linear non-local heap we use for DMA push buffers, textures and YV12 surfaces...
        pDriverData->GARTPhysicalBase = lpd->fpGARTDev;
        pDriverData->GARTLinearBase = lpd->fpGARTLin;

        // Let the resource manager know this information
        DWORD dwDummy;
        NvRmConfigSet (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                       NV_CFG_AGP_PHYS_BASE, pDriverData->GARTPhysicalBase, &dwDummy);
        NvRmConfigSet (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                       NV_CFG_AGP_LINEAR_BASE, pDriverData->GARTLinearBase, &dwDummy);

        if (!pDriverData->regMaxAGPLimit) {
            // MS is lazy about setting up MTRR's and sometimes this config get in DriverInit
            // will fail because they haven't done it yet.  Try to get it again here as a last
            // ditch attempt -- (this has the side affect of setting up some mapping variables
            // in pdev on the RM side).
            NvRmConfigGet (pDriverData->dwRootHandle, NV_WIN_DEVICE,
                           NV_CFG_AGP_LIMIT, &pDriverData->regMaxAGPLimit);
            if (!pDriverData->regMaxAGPLimit) {
                // we _still_ can't get the heap size. just revert to the default and pray...
                pDriverData->regMaxAGPLimit = NV_MAX_AGP_MEMORY_LIMIT;
                DPF ("falling back to default AGP heap size for lack of information from MS");
                dbgD3DError();
            }
        }

        // win9x fix for any system that sets an AGP aperature TOO large
        {
            DWORD dwMem = pDriverData->nvD3DPerfData.dwSystemMemory * 1024 * 1024 / 2 - 1;
            pDriverData->regMaxAGPLimit = min(pDriverData->regMaxAGPLimit, dwMem);
        }

        // Even though regMaxAGPLimit is accurate, we could be further limited by lpd->ulPolicyMaxBytes
        NvRmConfigSet (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                       NV_CFG_AGP_LIMIT, pDriverData->regMaxAGPLimit, &dwDummy);

#ifdef NV_TRACKAGP
        __Reset();
#endif //NV_TRACKAGP

        // reset if we weren't yet enabled or if we had a valid
        // push buffer in AGP memory (which has been blown away)
        if ((getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED)
            ||
            (getDC()->nvPusher.isValid() && (getDC()->nvPusher.getHeap() == CSimpleSurface::HEAP_AGP))) {
            nvDisable32();
            if (!nvEnable32 (lpd->lpDD)) {
                NvReleaseSemaphore(pDriverData);
                lpd->ddRVal = DDERR_OUTOFMEMORY;
                dbgTracePop();
                return DDHAL_DRIVER_HANDLED;
            }
        }
    }

    NvReleaseSemaphore(pDriverData);
    lpd->ddRVal = DD_OK;
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);

} // UpdateNonLocalHeap32

#endif // !WINNT

//---------------------------------------------------------------------------

/*
 * GetAvailDriverMemory32
 *
 * Reports amount of memory that the driver is managing itself.
 */

DWORD __stdcall GetAvailDriverMemory32( LPDDHAL_GETAVAILDRIVERMEMORYDATA lpd )
{
    dbgTracePush ("GetAvailDriverMemory32");

    // We need to see if if there has been a mode set and re-init.
    // Although this routine does nothing with hardware, the offscreen
    // memory heap will not really be accurate if we don't. Fixes
    // WQHL bug where WHQL test allocates a bunch of surfaces and then
    // frees them and then checks to make sure that there is the
    // same amount of video memory before allocating as after freeing.
    // Because we allocate some extra video memory for a notifier in
    // NvDDEnable32 on the first createSurface call and don't free
    // the notifier when the last surface is destroyed (which is
    // perfectly fine!), WHQL thinks we are losing memory, but we aren't.
    // However, I fix it by checking if NV needs a reset here which
    // will force the notifier to allocate before the memory is sized.
    nvSetDriverDataPtrFromDDGbl (lpd->lpDD);

    // Make certain that we're enabled before reporting memory.
    // Our nvEnable code does do some minor allocations which we need
    // to account for before reporting to the app how much remains
    // available to it.
    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED)
    {
        if (!nvEnable32 (lpd->lpDD)) {
            NvReleaseSemaphore(pDriverData);
            lpd->ddRVal = DDERR_OUTOFMEMORY;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    }

    // figure out what the caller requested
    BOOL bVidMem  = (lpd->DDSCaps.dwCaps & (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM))
                    == (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
    BOOL bAGPMem  = (lpd->DDSCaps.dwCaps & (DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM))
                    == (DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM);
    BOOL bTexture = (lpd->DDSCaps.dwCaps & DDSCAPS_TEXTURE) == DDSCAPS_TEXTURE;
    BOOL bZBufMem = (lpd->DDSCaps.dwCaps & DDSCAPS_ZBUFFER) == DDSCAPS_ZBUFFER;

    // Ths ZBuffer is always in video memory since the chip has to be able
    // to write to it. So, the request is really for vid mem.
    if (bZBufMem)
        bVidMem = TRUE;

    if (!bVidMem && !bAGPMem)
    {
        // if DDSCAPS_VIDEOMEMORY is set but the location is not specified we will return local vid mem only
        if (lpd->DDSCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
            bVidMem = TRUE;

        // when primary surface is specified, use local vid mem
        if (lpd->DDSCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
            bVidMem = TRUE;

        // off screen plain -> video only
        if (lpd->DDSCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN)
            bVidMem = TRUE;

        // only DDSCAPS_LOCALVIDMEM -> vid mem
        if (lpd->DDSCaps.dwCaps & DDSCAPS_LOCALVIDMEM)
            bVidMem = TRUE;

        // only DDSCAPS_NONLOCALVIDMEM -> agp mem
        if (lpd->DDSCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
            bAGPMem = TRUE;

        // only DDSCAPS_TEXTURE -> vid & agp (if it exists)
        if (bTexture)
        {
            bVidMem = TRUE;
            if (pDriverData->GARTLinearBase) {
                bAGPMem = TRUE;
            }
        }
    }

    nvCreateVidHeapVarsAndPseudoNotifier();

    lpd->dwTotal = 0;
    lpd->dwFree  = 0;

    //
    // local video memory
    //
    if (bVidMem)
    {
        // The driver is managing local video memory itself.
        // AGP memory is being managed by DirectX.  So just
        // return amount of local memory being managed.
        lpd->dwTotal += pDriverData->VideoHeapTotal - pDriverData->VideoHeapOverhead;
        lpd->dwFree  += pDriverData->VideoHeapFree;
    }

    //
    // PCI texture memory
    //
    if (bTexture
     && !bAGPMem
     && !pDriverData->GARTLinearBase)
    {
        if (getDC()->nvD3DTexHeapData.dwSizeMax == 0)
        {
             // If the current texture heap size is not initialized
             // yet, then this means D3D has not be fired up yet to
             // actually allocate the texture heap.  In this case
             // return the amount that is being requested.  Once D3D
             // is up and running, the memory sizes will be based on
             // what the heap size really is.
            DWORD dwHeapSize = getDC()->nvD3DRegistryData.regPCITexHeapSize ?
                               getDC()->nvD3DRegistryData.regPCITexHeapSize :
                               pDriverData->nvD3DPerfData.dwRecommendedPCITexHeapSize;
            lpd->dwTotal += dwHeapSize;
            lpd->dwFree  += dwHeapSize;
        }
        else
        {
            // Return the maximum and available size of the internal
            // PCI system memory texture heap
            lpd->dwTotal += getDC()->nvD3DTexHeapData.dwSizeMax;
            lpd->dwFree  += getDC()->nvD3DTexHeapData.dwFreeSize;
        }
    }

    //
    // AGP texture memory
    //
    if (bAGPMem)
    {
        // On AGP systems, the driver also manages textures, but in AGP memory.
        // Our driver allocates a chunk of AGP memory from the the DirectX
        // managed AGP heap. Then we sub-allocate from this chunk for our
        // textures. Hence, DirectX thinks there is less AGP memory available
        // than there actually is. We need to correct for that.
        DWORD total, free;

        nvAGPGetMemory (&total, &free);

#ifdef NV_AGP
        lpd->dwTotal += pDriverData->regMaxAGPLimit;
        lpd->dwFree  += pDriverData->regMaxAGPLimit - total + free;
#else // !NV_AGP
        lpd->dwTotal += 0;      // total is already correct
        lpd->dwFree  += free;   // we have this much free
#endif // !NV_AGP
    }

    lpd->ddRVal = DD_OK;
    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return(DDHAL_DRIVER_HANDLED);
}

//---------------------------------------------------------------------------

/* Safe procedures, basically if they are called nothing happens */
DWORD FAR PASCAL SafeSyncSurfaceData(LPDDHAL_SYNCSURFACEDATA lpInput)
{
    dbgTracePush ("SafeSyncSurfaceData");
    lpInput->ddRVal= DD_OK;
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

DWORD FAR PASCAL SafeSyncVideoPortData(LPDDHAL_SYNCVIDEOPORTDATA lpInput)
{
    dbgTracePush ("SafeSyncVideoPortData");
    lpInput->ddRVal= DD_OK;
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

//---------------------------------------------------------------------------

/*
 * GetTranslatedOffset(DWORD lBrightness )
 *
 * Converts linear brightness into an offset to program into
 * CSC registers, this algorithm is non-linear and
 * includes two ranges.
 */
DWORD GetTranslatedOffset( unsigned long lBrightness)
{
    DWORD dwOffset;

    dbgTracePush ("GetTranslatedOffset");

    if (lBrightness>10000)
        lBrightness = 10,000;

    if (lBrightness<=750) {
        dwOffset = 1+ ( 0x3D * (lBrightness/749) );
    }
    else {
        dwOffset = (0x69 * (lBrightness/(10,000-750)));
    }

    dbgTracePop();
    return (dwOffset);
}

//---------------------------------------------------------------------------

#define NV_PVIDEO_RED_CSC 0x680280
#define NV_PVIDEO_GREEN_CSC 0x680284
#define NV_PVIDEO_BLUE_CSC 0x680288

DWORD GetOffsetTranslated()
{
    U032 * nvBase;
    U032 dwRedCsc;

    dbgTracePush ("GetOffsetTranslated");

    // all of this is based of the red csc value
    nvBase = (U032 *) (pDriverData->NvBaseFlat);

    dwRedCsc = nvBase[NV_PVIDEO_RED_CSC/4];

    if (dwRedCsc>=0x69) {// 750 to 0 range
        dbgTracePop();
        return(750 * ((dwRedCsc-0x69)/0x3E));
    }
    else {// 750-10,000 range
        dbgTracePop();
        return(750 + ((10000-750)* ((0x69-dwRedCsc)/0x69)) );
    }
}

//---------------------------------------------------------------------------

/*
 * Colour Control
 * Extended functionality of DirectDraw/VPE
 */
DWORD __stdcall ColourControl( LPDDHAL_COLORCONTROLDATA pvpcd )
{
    U032 *nvBase;

    dbgTracePush ("ColourControl");

    nvSetDriverDataPtrFromDDGbl (pvpcd->lpDD);

    if (IS_OVERLAY(pvpcd->lpDDSurface->ddsCaps.dwCaps, pvpcd->lpDDSurface->lpGbl->ddpfSurface.dwFourCC)) {

        if (pvpcd->dwFlags & DDRAWI_GETCOLOR ) {

            pvpcd->lpColorData->dwSize = sizeof(DDCOLORCONTROL);

            pvpcd->lpColorData->dwFlags = DDCOLOR_BRIGHTNESS;
            pvpcd->lpColorData->dwFlags |= DDCOLOR_CONTRAST;
            pvpcd->lpColorData->dwFlags |= DDCOLOR_SATURATION;
            pvpcd->lpColorData->dwFlags |= DDCOLOR_HUE;

            if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
                pvpcd->lpColorData->lBrightness = pDriverData->vpp.colorCtrl.lBrightness;
                pvpcd->lpColorData->lContrast = pDriverData->vpp.colorCtrl.lContrast;
                pvpcd->lpColorData->lHue = pDriverData->vpp.colorCtrl.lHue;
                pvpcd->lpColorData->lSaturation = pDriverData->vpp.colorCtrl.lSaturation;
            }
            else {
                // is in units of 1, maximum is 10,000
                pvpcd->lpColorData->lBrightness = GetOffsetTranslated();

                // contrast ranges from 0 to 20,000 (intended to be 0 to 200%)
                pvpcd->lpColorData->lContrast = min(pDriverData->vpp.colorCtrl.lContrast * 10000 / 255, 20000);

                // hue is in range of -180 to 180 degrees
                pvpcd->lpColorData->lHue = pDriverData->vpp.colorCtrl.lHue;
                while (pvpcd->lpColorData->lHue > 180)  pvpcd->lpColorData->lHue -= 360;
                while (pvpcd->lpColorData->lHue < -180) pvpcd->lpColorData->lHue += 360;

                // saturation ranges from 0 to 20,000
                pvpcd->lpColorData->lSaturation = min(pDriverData->vpp.colorCtrl.lSaturation * 10000 / 256, 20000);
            }

            pvpcd->ddRVal = DD_OK;
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }

        if (pvpcd->dwFlags & DDRAWI_SETCOLOR ) {
            if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
                if (pvpcd->lpColorData->dwFlags & DDCOLOR_CONTRAST) {
                    pDriverData->vpp.colorCtrl.lContrast = pvpcd->lpColorData->lContrast;
                }
                if (pvpcd->lpColorData->dwFlags & DDCOLOR_BRIGHTNESS) {
                    pDriverData->vpp.colorCtrl.lBrightness = pvpcd->lpColorData->lBrightness;
                }
                if (pvpcd->lpColorData->dwFlags & DDCOLOR_SATURATION) {
                    pDriverData->vpp.colorCtrl.lSaturation = pvpcd->lpColorData->lSaturation;
                }
                if (pvpcd->lpColorData->dwFlags & DDCOLOR_HUE) {
                    pDriverData->vpp.colorCtrl.lHue = pvpcd->lpColorData->lHue;
                }
                VppSetOverlayColourControl(&(pDriverData->vpp));

                if (pvpcd->lpColorData->dwFlags & (DDCOLOR_BRIGHTNESS | DDCOLOR_CONTRAST | DDCOLOR_HUE | DDCOLOR_SATURATION)) {
                    pvpcd->ddRVal = DD_OK;
                    NvReleaseSemaphore(pDriverData);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }
            }
            else {
                if (pvpcd->lpColorData->dwFlags & DDCOLOR_BRIGHTNESS) {
                    DWORD dwCscOffset;
                    DWORD dwCscRed, dwCscGreen, dwCscBlue;

                    pDriverData->vpp.colorCtrl.lBrightness = min(pvpcd->lpColorData->lBrightness / 100, 255);
                    dwCscOffset = GetTranslatedOffset( pvpcd->lpColorData->lBrightness );

                    dwCscRed = 0x69     + dwCscOffset;
                    dwCscGreen = 0x3E   - dwCscOffset;
                    dwCscBlue  = 0x89   + dwCscOffset;

                    nvBase = (U032 *) (pDriverData->NvBaseFlat);

                    nvBase[NV_PVIDEO_RED_CSC/4] = dwCscRed;
                    nvBase[NV_PVIDEO_GREEN_CSC/4] = dwCscGreen;
                    nvBase[NV_PVIDEO_BLUE_CSC/4] = dwCscBlue;
                }
                if (pvpcd->lpColorData->dwFlags & DDCOLOR_CONTRAST) {
                    pDriverData->vpp.colorCtrl.lContrast = min(pvpcd->lpColorData->lContrast * 255 / 10000, 511);
                }
                if (pvpcd->lpColorData->dwFlags & DDCOLOR_HUE) {
                    pDriverData->vpp.colorCtrl.lHue = pvpcd->lpColorData->lHue;
                    while (pDriverData->vpp.colorCtrl.lHue < 0)    pDriverData->vpp.colorCtrl.lHue += 360;
                    while (pDriverData->vpp.colorCtrl.lHue >= 360) pDriverData->vpp.colorCtrl.lHue -= 360;
                }
                if (pvpcd->lpColorData->dwFlags & DDCOLOR_SATURATION) {
                    pDriverData->vpp.colorCtrl.lSaturation = min(pvpcd->lpColorData->lSaturation * 256 / 10000, 512);
                }
                if (pvpcd->lpColorData->dwFlags & (DDCOLOR_BRIGHTNESS | DDCOLOR_CONTRAST | DDCOLOR_HUE | DDCOLOR_SATURATION)) {
                    pvpcd->ddRVal = DD_OK;
                    NvReleaseSemaphore(pDriverData);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }
            }
        }
    }

    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (DDHAL_DRIVER_NOTHANDLED);
}

//---------------------------------------------------------------------------

/*
 * GetDriverInfo32
 *
 * Initialize Extended Functionality Classes
 */
DWORD __stdcall GetDriverInfo32(LPDDHAL_GETDRIVERINFODATA lpData)
{
    DWORD dwSize;

    dbgTracePush ("GetDriverInfo32");

#ifdef WINNT
    NvAcquireSemaphore((((PPDEV) (lpData->dhpdev))->pDriverData));
    pDriverData = (CDriverContext *) ((PPDEV)(lpData->dhpdev))->pDriverData;
#else // !WINNT
    pDXShare = (DISPDRVDIRECTXCOMMON *) lpData->dwContext;
    pDriverData = (CDriverContext *) pDXShare->pDirectXData;
#endif // !WINNT

    // set up pointer to DDHALINFO
    LPDDHALINFO pHalInfo = GET_HALINFO();

    lpData->ddRVal = DDERR_CURRENTLYNOTAVAIL;

    // please keep these GUIDs alphabetized. there are too
    // many of them to otherwise keep track of.

    if (IsEqualIID_C ((lpData->guidInfo), GUID_ColorControlCallbacks) &&
       (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10 || pDriverData->vpp.regOverlayColourControlEnable)) {
        DDHAL_DDCOLORCONTROLCALLBACKS ccCB;

        dwSize = lpData->dwExpectedSize;

        lpData->dwActualSize = sizeof( DDHAL_DDCOLORCONTROLCALLBACKS );

        ccCB.dwSize = (dwSize<lpData->dwActualSize)?
                      dwSize:lpData->dwActualSize;

        ccCB.dwFlags = DDHAL_COLOR_COLORCONTROL;
        ccCB.ColorControl = ColourControl;

        memcpy(lpData->lpvData, &ccCB, ccCB.dwSize );

        lpData->ddRVal = DD_OK;
    }

#ifndef WINNT
    if (IsEqualIID_C ((lpData->guidInfo), GUID_D3DCallbacks2))
    {
        D3DHAL_CALLBACKS2 D3DCallbacks2;

        DPF_LEVEL(NVDBG_LEVEL_INFO, "D3DGetDriverInfo - Process GUID_D3DCallbacks2");

        global.dwDXRuntimeVersion = max (global.dwDXRuntimeVersion, 0x0300);

        memset(&D3DCallbacks2, 0, sizeof(D3DHAL_CALLBACKS2));
        dwSize               = min(lpData->dwExpectedSize, sizeof(D3DHAL_CALLBACKS2));
        lpData->dwActualSize = sizeof(D3DHAL_CALLBACKS2);
        D3DCallbacks2.dwSize = dwSize;

        /*
         * Always export the SetRenderTarget callback.
         */
        D3DCallbacks2.dwFlags = D3DHAL2_CB32_SETRENDERTARGET;
        D3DCallbacks2.SetRenderTarget = nvSetRenderTarget;

        /*
         * Always export the D3D Clear callback.
         */
        D3DCallbacks2.dwFlags |= D3DHAL2_CB32_CLEAR;
        D3DCallbacks2.Clear    = nvClear;

        /*
         * Always export the DrawPrimitive callbacks.
         */
        D3DCallbacks2.dwFlags |= D3DHAL2_CB32_DRAWONEPRIMITIVE
                              |  D3DHAL2_CB32_DRAWONEINDEXEDPRIMITIVE
                              |  D3DHAL2_CB32_DRAWPRIMITIVES;
        D3DCallbacks2.DrawOnePrimitive        = DrawOnePrimitive32;
        D3DCallbacks2.DrawOneIndexedPrimitive = DrawOneIndexedPrimitive32;
        D3DCallbacks2.DrawPrimitives          = DrawPrimitives32;

        /*
         * Copy as much of the data as possible up to dwExpectedSize.
         */
        memcpy(lpData->lpvData, &D3DCallbacks2, dwSize);

        /*
         * Set successful return code.
         */
        lpData->ddRVal = DD_OK;
    }
#endif  // !WINNT

    if (IsEqualIID_C((lpData->guidInfo), GUID_D3DCallbacks3))
    {
        D3DHAL_CALLBACKS3   D3DCallbacks3;

        DPF_LEVEL(NVDBG_LEVEL_INFO, "D3DGetDriverInfo - Process GUID_D3DCallbacks3");

        global.dwDXRuntimeVersion = max (global.dwDXRuntimeVersion, 0x0600);

        memset(&D3DCallbacks3, 0, sizeof(D3DHAL_CALLBACKS3));
        dwSize               = min(lpData->dwExpectedSize, sizeof(D3DHAL_CALLBACKS3));
        lpData->dwActualSize = sizeof(D3DHAL_CALLBACKS3);
        D3DCallbacks3.dwSize = dwSize;

        /*
         * Export DX6 DrawPrimitives2 DDI callback.
         */
        D3DCallbacks3.dwFlags |= D3DHAL3_CB32_DRAWPRIMITIVES2;
        D3DCallbacks3.DrawPrimitives2 = nvDrawPrimitives2;

        /*
         * Export DX6 Mult-Texture state validation callback.
         */
        D3DCallbacks3.dwFlags |= D3DHAL3_CB32_VALIDATETEXTURESTAGESTATE;
        D3DCallbacks3.ValidateTextureStageState = nvValidateTextureStageState;

        /*
         * Export DX6 callback for clear Render target, Z-Buffer and Stencil Buffer.
         */
        D3DCallbacks3.dwFlags |= D3DHAL3_CB32_CLEAR2;
        D3DCallbacks3.Clear2 = nvClear2;

        /*
         * Copy as much of the data as possible up to dwExpectedSize.
         */
        memcpy(lpData->lpvData, &D3DCallbacks3, dwSize);

        /*
         * Set successful return code.
         */
        lpData->ddRVal = DD_OK;
    }

    if (IsEqualIID_C ((lpData->guidInfo), GUID_D3DExtendedCaps))
    {
        D3DHAL_D3DEXTENDEDCAPS  D3DExtendedCaps;

        D3DExtendedCaps        = getDC()->nvD3DDevCaps.d3dExtCaps;
        dwSize                 = min (lpData->dwExpectedSize, sizeof(D3DHAL_D3DEXTENDEDCAPS));
        lpData->dwActualSize   = dwSize;
        D3DExtendedCaps.dwSize = dwSize;

#ifdef  STEREO_SUPPORT
        if (STEREO_ENABLED && pStereoData->StereoSettings.dwFlags & STEREO_DISABLETnL)
        {
            D3DExtendedCaps.dwVertexProcessingCaps  = 0;
            D3DExtendedCaps.dwMaxActiveLights       = 0;
        }
#endif  //STEREO_SUPPORT

        // Copy as much of the data as possible up to dwExpectedSize.
        memcpy(lpData->lpvData, &D3DExtendedCaps, dwSize);

        // Set successful return code.
        lpData->ddRVal = DD_OK;
    }

    if (IsEqualIID_C((lpData->guidInfo), GUID_D3DParseUnknownCommandCallback))
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "D3DGetDriverInfo - Process GUID_D3DParseUnknownCommandCallback");

        global.dwDXRuntimeVersion = max (global.dwDXRuntimeVersion, 0x0600);

        // Get address of callback function.
        fnD3DParseUnknownCommandCallback = (PFND3DPARSEUNKNOWNCOMMAND)lpData->lpvData;

        // Set successful return code.
        lpData->ddRVal = DD_OK;
    }

#if 0  // alpha blit sppears to have been removed from dx7 build 169   27may99   CRD
    if (IsEqualIID_C ((lpData->guidInfo), GUID_DDMoreCaps)) {

        DDMORECAPS ddMoreCaps;

        global.dwDXRuntimeVersion = max (global.dwDXRuntimeVersion, 0x0700);

        if (lpData->dwExpectedSize != sizeof(DDMORECAPS) ) {
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }

        lpData->dwActualSize = sizeof(DDMORECAPS);

        ddMoreCaps.dwSize = sizeof(DDMORECAPS);

        ddMoreCaps.dwAlphaCaps = 0;
                                 DDALPHACAPS_BLTALPHAPIXELS |
                                 DDALPHACAPS_BLTSATURATE    |
                                 DDALPHACAPS_BLTPREMULT     |
                                 // DDALPHACAPS_BLTNONPREMULT |
                                 DDALPHACAPS_BLTARGBSCALE1F |
                                 DDALPHACAPS_BLTARGBSCALE4F |
                                 DDALPHACAPS_BLTALPHAFILL;

        ddMoreCaps.dwSVBAlphaCaps = 0;
                                    DDALPHACAPS_BLTALPHAPIXELS |
                                    DDALPHACAPS_BLTSATURATE |
                                    DDALPHACAPS_BLTPREMULT |
                                    // DDALPHACAPS_BLTNONPREMULT |
                                    DDALPHACAPS_BLTARGBSCALE1F |
                                    DDALPHACAPS_BLTARGBSCALE4F |
                                    DDALPHACAPS_BLTALPHAFILL;

        ddMoreCaps.dwFilterCaps = 0;
                                  DDFILTCAPS_BLTQUALITYFILTER |
                                  DDFILTCAPS_BLTCANDISABLEFILTER;

        ddMoreCaps.dwSVBFilterCaps = 0;
                                     DDFILTCAPS_BLTQUALITYFILTER |
                                     DDFILTCAPS_BLTCANDISABLEFILTER;

        memcpy(lpData->lpvData, &ddMoreCaps, sizeof(DDMORECAPS));
        lpData->ddRVal = DD_OK;
    }
#endif  // 0

    if (IsEqualIID_C ((lpData->guidInfo), GUID_DDMoreSurfaceCaps)) {

        DDMORESURFACECAPS ddMoreSurfaceCaps;
        DDSCAPSEX         ddsCapsEx, ddsCapsExAlt;

        global.dwDXRuntimeVersion = max (global.dwDXRuntimeVersion, 0x0600);

        // fill in everything until expectedsize... (first heap's caps)
        memset(&ddMoreSurfaceCaps, 0, sizeof(ddMoreSurfaceCaps));

        // caps for heaps 2..n
        memset(&ddsCapsEx, 0, sizeof(ddsCapsEx));
        memset(&ddsCapsExAlt, 0, sizeof(ddsCapsEx));

        ddMoreSurfaceCaps.dwSize = lpData->dwExpectedSize;

        ddMoreSurfaceCaps.ddsCapsMore.dwCaps2 = DDSCAPS2_CUBEMAP;
        ddsCapsEx.dwCaps2 = DDSCAPS2_CUBEMAP;

        ddsCapsExAlt.dwCaps2 = DDSCAPS2_CUBEMAP;

        lpData->dwActualSize = lpData->dwExpectedSize;

        dwSize = min(sizeof(ddMoreSurfaceCaps),lpData->dwExpectedSize);
        memcpy(lpData->lpvData, &ddMoreSurfaceCaps, dwSize);

        // now fill in other heaps...
        while (dwSize < lpData->dwExpectedSize) {
            memcpy((PBYTE)lpData->lpvData+dwSize, &ddsCapsEx, sizeof(DDSCAPSEX));
            dwSize += sizeof(DDSCAPSEX);
            memcpy((PBYTE)lpData->lpvData+dwSize, &ddsCapsExAlt, sizeof(DDSCAPSEX));
            dwSize += sizeof(DDSCAPSEX);
        }

        lpData->ddRVal = DD_OK;
    }

#if (!defined(WINNT) || defined(NVPE))
    if (IsEqualIID_C ((lpData->guidInfo), GUID_KernelCallbacks) ) {
        DDHAL_DDKERNELCALLBACKS kCB;

        dwSize = lpData->dwExpectedSize;

        if ( sizeof(kCB) < dwSize )
            dwSize = sizeof(kCB);
        lpData->dwActualSize = sizeof(kCB);

        kCB.dwSize = sizeof(DDHAL_DDKERNELCALLBACKS);
        kCB.dwFlags = DDHAL_KERNEL_SYNCSURFACEDATA | DDHAL_KERNEL_SYNCVIDEOPORTDATA;
        kCB.SyncSurfaceData = SafeSyncSurfaceData;  // we're not doing anything
                                                    // on EITHER of these yet
        kCB.SyncVideoPortData = SafeSyncVideoPortData;

        memcpy(lpData->lpvData, &kCB, dwSize );
        //lpData->ddRVal = DDERR_CURRENTLYNOTAVAIL;
        lpData->ddRVal = DD_OK;
    }

    if (IsEqualIID_C ((lpData->guidInfo), GUID_KernelCaps) ) {
        DDKERNELCAPS KernelCaps;

        // these functions can be called to control the Overlay,
        // so even if VPE is not here we need to have these
        if (lpData->dwExpectedSize != sizeof(DDKERNELCAPS)) {
            dbgTracePop();
            NvReleaseSemaphore(pDriverData);
            return (DDHAL_DRIVER_HANDLED);
        }

        lpData->dwActualSize = sizeof(DDKERNELCAPS);

        KernelCaps.dwSize = sizeof(DDKERNELCAPS);
        KernelCaps.dwCaps = DDKERNELCAPS_SKIPFIELDS     |
                            DDKERNELCAPS_AUTOFLIP       |
                            DDKERNELCAPS_SETSTATE       |
                            DDKERNELCAPS_LOCK           |
                            DDKERNELCAPS_FLIPVIDEOPORT  |
                            DDKERNELCAPS_FLIPOVERLAY    |
                            DDKERNELCAPS_CAPTURE_SYSMEM |
                            // DDKERNELCAPS_CAPTURE_NONLOCALVIDMEM |
                            DDKERNELCAPS_FIELDPOLARITY  |
                            DDKERNELCAPS_CAPTURE_INVERTED;

        KernelCaps.dwIRQCaps = DDIRQ_VPORT0_VSYNC |
                               //  DDIRQ_BUSMASTER;
                               //  #define DDIRQ_BUSMASTER         0x00000002l
                               0x00000002;

        // DDIRQ_DISPLAY_VSYNC      |
        // DDIRQ_RESERVED1          |
        // DDIRQ_VPORT0_VSYNC       // this is the only IRQ we'll be supporting
        // DDIRQ_VPORT0_LINE        |
        // DDIRQ_VPORT1_VSYNC       |
        // DDIRQ_VPORT1_LINE        |


        memcpy(lpData->lpvData, &KernelCaps, sizeof(DDKERNELCAPS) );
        //lpData->ddRVal = DDERR_CURRENTLYNOTAVAIL;
        lpData->ddRVal = DD_OK;
    }
#endif // !WINNT || NVPE

    if (IsEqualIID_C ((lpData->guidInfo), GUID_MiscellaneousCallbacks) ) {
        DDHAL_DDMISCELLANEOUSCALLBACKS miscCB;

        dwSize = lpData->dwExpectedSize;

        global.dwDXRuntimeVersion = max (global.dwDXRuntimeVersion, 0x0500);

        if ( sizeof(miscCB) < dwSize )
            dwSize = sizeof(miscCB);
        lpData->dwActualSize = sizeof(miscCB);
        memset(&miscCB, 0, dwSize);
        miscCB.dwSize = dwSize;

#ifdef WINNT
        miscCB.dwFlags = DDHAL_MISCCB32_GETAVAILDRIVERMEMORY;
#else // !WINNT
        miscCB.dwFlags = DDHAL_MISCCB32_GETHEAPALIGNMENT |
                         DDHAL_MISCCB32_UPDATENONLOCALHEAP |
                         DDHAL_MISCCB32_GETAVAILDRIVERMEMORY;
        miscCB.GetHeapAlignment = GetHeapAlignment32;
        miscCB.UpdateNonLocalHeap = UpdateNonLocalHeap32;
#endif // !WINNT

        // only GetAvailDriverMemory32 is valid for WINNT
        miscCB.GetAvailDriverMemory = GetAvailDriverMemory32;

        memcpy(lpData->lpvData, &miscCB, dwSize );
        lpData->ddRVal = DD_OK;
    }

    if (IsEqualIID_C ((lpData->guidInfo), GUID_Miscellaneous2Callbacks) ) {
        DDHAL_DDMISCELLANEOUS2CALLBACKS misc2CB;

        dwSize = lpData->dwExpectedSize;

        global.dwDXRuntimeVersion = max (global.dwDXRuntimeVersion, 0x0700);

        if ( sizeof(misc2CB) < dwSize )
            dwSize = sizeof(misc2CB);
        lpData->dwActualSize = sizeof(misc2CB);
        memset(&misc2CB, 0, dwSize);
        misc2CB.dwSize = dwSize;
        misc2CB.dwFlags = 0;

#if 0 // alpha blit sppears to have been removed from dx7 build 169   27may99   CRD
        // alphablt
        misc2CB.dwFlags |= DDHAL_MISC2CB32_ALPHABLT;
        misc2CB.AlphaBlt = Blit32;  // Use common callback with Blit32 calls
#endif // 0

        // createsurfaceex
        misc2CB.dwFlags |= DDHAL_MISC2CB32_CREATESURFACEEX;
        misc2CB.CreateSurfaceEx = nvCreateSurfaceEx;

        // getdriverstate
        misc2CB.dwFlags |= DDHAL_MISC2CB32_GETDRIVERSTATE;
        misc2CB.GetDriverState = nvGetDriverState;

        // destroyddlocal
        misc2CB.dwFlags |= DDHAL_MISC2CB32_DESTROYDDLOCAL;
        misc2CB.DestroyDDLocal = nvDestroyDDLocal;

        memcpy(lpData->lpvData, &misc2CB, dwSize );
        lpData->ddRVal = DD_OK;
    }

#if (NVARCH >= 0x10)
    // Check for Motion Comp GUID
    if (IsEqualIID_C ((lpData->guidInfo), GUID_MotionCompCallbacks)) {
        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10)
            nvGetMoCompDriverInfo(lpData);
    }
#endif // NVARCH >= 0x10

    if (IsEqualGUID_C((lpData->guidInfo), GUID_NonLocalVidMemCaps ) ) {
        LPDDNONLOCALVIDMEMCAPS lpCaps;
        int i;

        /* Size validation code omitted for clarity */
        dwSize = min(lpData->dwExpectedSize, sizeof(DDNONLOCALVIDMEMCAPS));
        lpCaps = (LPDDNONLOCALVIDMEMCAPS)(lpData->lpvData);
        lpCaps->dwSize = dwSize;

        lpCaps->dwNLVBCaps     = pHalInfo->ddCaps.dwCaps;
        lpCaps->dwNLVBCaps2    = pHalInfo->ddCaps.dwCaps2;
        lpCaps->dwNLVBCKeyCaps = pHalInfo->ddCaps.dwCKeyCaps;
        lpCaps->dwNLVBFXCaps   = pHalInfo->ddCaps.dwFXCaps;

        for ( i=0; i < DD_ROP_SPACE; i++ )
            lpCaps->dwNLVBRops[i] = ropList[i];

        lpData->dwActualSize = dwSize;
        lpData->ddRVal = DD_OK;
    }

#if (!defined(WINNT) || defined(NVPE))      // BUGBUG - we will add Win2K videoport support

    if (IsEqualIID_C ((lpData->guidInfo), GUID_VideoPortCallbacks) ) {

        DDHAL_DDVIDEOPORTCALLBACKS vpCB;

        dwSize = lpData->dwExpectedSize;

        // this test prevent reporting of VPE functions so that if necessary we can turn off VPE via registry.
        if (pDriverData->bEnableVPE == 1 ) {

            if ( sizeof(vpCB) < dwSize )
                dwSize = sizeof(vpCB);
            lpData->dwActualSize = sizeof(vpCB);
            memset(&vpCB, 0, dwSize);
            vpCB.dwSize = dwSize;

            vpCB.dwFlags = DDHAL_VPORT32_CANCREATEVIDEOPORT |
                           DDHAL_VPORT32_CREATEVIDEOPORT    |
                           DDHAL_VPORT32_DESTROY            |
                           DDHAL_VPORT32_FLIP               |
                           DDHAL_VPORT32_GETBANDWIDTH       |
                           DDHAL_VPORT32_GETINPUTFORMATS    |
                           DDHAL_VPORT32_GETOUTPUTFORMATS   |
                           DDHAL_VPORT32_GETFIELD           |
                           DDHAL_VPORT32_GETCONNECT         |
                           DDHAL_VPORT32_GETFLIPSTATUS      |
                           DDHAL_VPORT32_UPDATE             |
                           DDHAL_VPORT32_WAITFORSYNC        |
                           DDHAL_VPORT32_GETSIGNALSTATUS;


            vpCB.CanCreateVideoPort         = CanCreateVideoPort32;
            vpCB.CreateVideoPort            = CreateVideoPort32;
            vpCB.DestroyVideoPort           = DestroyVideoPort32;
            vpCB.FlipVideoPort              = FlipVideoPort32;

            vpCB.GetVideoPortBandwidth      = GetVideoPortBandwidth32;
            vpCB.GetVideoPortInputFormats   = GetVideoPortInputFormat32;
            vpCB.GetVideoPortOutputFormats  = GetVideoPortOutputFormat32;
            vpCB.GetVideoPortField          = GetVideoPortField32;
            vpCB.GetVideoPortConnectInfo    = GetVideoPortConnectInfo;

            vpCB.GetVideoPortFlipStatus     = GetVideoPortFlipStatus32;
            vpCB.UpdateVideoPort            = UpdateVideoPort32;
            vpCB.WaitForVideoPortSync       = WaitForVideoPortSync32;
            vpCB.GetVideoSignalStatus       = GetVideoSignalStatus32;

            memcpy(lpData->lpvData, &vpCB, dwSize );
            lpData->ddRVal = DD_OK;
        }

    }

    if (IsEqualIID_C ((lpData->guidInfo), GUID_VideoPortCaps) ) {
        DDVIDEOPORTCAPS VideoPortCaps;
        DDVIDEOPORTCAPS *pVideoPortCapsDest = (DDVIDEOPORTCAPS*)lpData->lpvData;
        DWORD dwIndex;

        // this test prevent reporting of VPE functions so that
        // if necessary we can turn off VPE via registry.
        if (pDriverData->bEnableVPE == 1 ) {
            // expecting query for 1 video port
            if (lpData->dwExpectedSize != (sizeof(VideoPortCaps))) {
                NvReleaseSemaphore(pDriverData);
                dbgTracePop();
                return (DDHAL_DRIVER_HANDLED);
            }

            lpData->dwActualSize = (sizeof(VideoPortCaps) );

            // index changed to allow only 1 report resolution, for time being only NTSC
            // until class structure is changed to test PAL etc
            for (dwIndex = 0; dwIndex < 1; dwIndex++) {
                if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {

                  memset(&VideoPortCaps, 0, sizeof(DDVIDEOPORTCAPS));

                  VideoPortCaps.dwSize = sizeof(DDVIDEOPORTCAPS);

                  VideoPortCaps.dwFlags = DDVPD_WIDTH             |
                                          DDVPD_HEIGHT            |
                                          DDVPD_ID                |
                                          DDVPD_CAPS              |
                                          DDVPD_FX                |
                                          DDVPD_AUTOFLIP          |
                                          DDVPD_ALIGN             |
                                          DDVPD_PREFERREDAUTOFLIP |
                                          DDVPD_FILTERQUALITY;

                  VideoPortCaps.dwVideoPortID = dwIndex;
                  // for more supported video modes, place the resolutions here
                  //        VideoPortCaps.dwMaxWidth      = ST_VPE_MAX_INPUT_X;
                  //       VideoPortCaps.dwMaxVBIWidth = ST_VPE_MAX_INPUT_X;
                  //          VideoPortCaps.dwMaxHeight   = ST_VPE_MAX_INPUT_Y;
                  VideoPortCaps.dwMaxWidth    = 4096;   // must talk to joe and get
                                                        // the details on this..
                  VideoPortCaps.dwMaxVBIWidth = 4096;
                  VideoPortCaps.dwMaxHeight   = 4096;    //this value is calculated from
                                                         // 2^24 (bytes)  / 2  / 2048 pixels / line

                  // could have share even/odd, but for now keep things simple

                  VideoPortCaps.dwCaps =
                  DDVPCAPS_AUTOFLIP       |
                  DDVPCAPS_INTERLACED     |
                  DDVPCAPS_NONINTERLACED  |
                  // DDVPCAPS_SHAREABLE     |
                  DDVPCAPS_SKIPEVENFIELDS |
                  DDVPCAPS_SKIPODDFIELDS  |
                  DDVPCAPS_VBISURFACE     |
                  DDVPCAPS_OVERSAMPLEDVBI;

                  VideoPortCaps.dwFX =
                  DDVPFX_CROPTOPDATA      |
                  DDVPFX_INTERLEAVE       |
                  DDVPFX_PRESHRINKXB      |
                  DDVPFX_PRESHRINKY       | // y can accept arbitary (except 0)
                  DDVPFX_VBICONVERT       |
                  DDVPFX_VBINOSCALE       |
                  DDVPFX_VBINOINTERLEAVE  |
                  DDVPFX_IGNOREVBIXCROP;


                  VideoPortCaps.dwNumAutoFlipSurfaces = 5;


                  VideoPortCaps.dwAlignVideoPortBoundary      = pDriverData->vpp.dwOverlayByteAlignmentPad + 1;
                  VideoPortCaps.dwAlignVideoPortPrescaleWidth = 1;

                  // can't crop to an arbitary rectangle!!
                  VideoPortCaps.dwAlignVideoPortCropBoundary  = 1;
                  VideoPortCaps.dwAlignVideoPortCropWidth     = 1;

                  // not valid for PRESHRINKX/YB flag as set above
                  VideoPortCaps.dwPreshrinkXStep = 24;
                  VideoPortCaps.dwPreshrinkYStep = 0x400;


                  VideoPortCaps.dwNumVBIAutoFlipSurfaces = 5;

                  VideoPortCaps.dwNumPreferredAutoflip =3;
                  VideoPortCaps.wNumFilterTapsX = 2;
                  VideoPortCaps.wNumFilterTapsY = 1;
                  memcpy(&pVideoPortCapsDest[dwIndex], &VideoPortCaps, sizeof(VideoPortCaps) );

               } else {


                  memset(&VideoPortCaps, 0, sizeof(DDVIDEOPORTCAPS));

                  VideoPortCaps.dwSize = sizeof(DDVIDEOPORTCAPS);

                  VideoPortCaps.dwFlags = DDVPD_WIDTH             |
                                          DDVPD_HEIGHT            |
                                          DDVPD_ID                |
                                          DDVPD_CAPS              |
                                          DDVPD_FX                |
                                          DDVPD_AUTOFLIP          |
                                          DDVPD_ALIGN             |
                                          DDVPD_PREFERREDAUTOFLIP |
                                          DDVPD_FILTERQUALITY;

                  VideoPortCaps.dwVideoPortID = dwIndex;
                  // for more supported video modes, place the resolutions here
                  //        VideoPortCaps.dwMaxWidth      = ST_VPE_MAX_INPUT_X;
                  //       VideoPortCaps.dwMaxVBIWidth = ST_VPE_MAX_INPUT_X;
                  //          VideoPortCaps.dwMaxHeight   = ST_VPE_MAX_INPUT_Y;
                  VideoPortCaps.dwMaxWidth    = 4096;   // must talk to joe and get
                                                        // the details on this..
                  VideoPortCaps.dwMaxVBIWidth = 4096;
                  VideoPortCaps.dwMaxHeight   = 640;    // just arbitarily larger than
                                                        // PAL field *2 for progressive

                  // could have share even/odd, but for now keep things simple

                  VideoPortCaps.dwCaps =
                  DDVPCAPS_AUTOFLIP       |
                  DDVPCAPS_INTERLACED     |
                  DDVPCAPS_NONINTERLACED  |
                  // DDVPCAPS_SHAREABLE     |
                  DDVPCAPS_SKIPEVENFIELDS |
                  DDVPCAPS_SKIPODDFIELDS  |
                  DDVPCAPS_VBISURFACE     |
                  DDVPCAPS_OVERSAMPLEDVBI;

                  VideoPortCaps.dwFX =
                  DDVPFX_CROPTOPDATA      |
                  DDVPFX_INTERLEAVE       |
                  DDVPFX_PRESHRINKXB      |
                  DDVPFX_PRESHRINKY       | // y can accept arbitary (except 0)
                  DDVPFX_VBICONVERT       |
                  DDVPFX_VBINOSCALE       |
                  DDVPFX_VBINOINTERLEAVE  |
                  DDVPFX_IGNOREVBIXCROP;


                  VideoPortCaps.dwNumAutoFlipSurfaces = 5;


                  VideoPortCaps.dwAlignVideoPortBoundary      = pDriverData->vpp.dwOverlayByteAlignmentPad + 1;
                  VideoPortCaps.dwAlignVideoPortPrescaleWidth = 1;

                  // can't crop to an arbitary rectangle!!
                  VideoPortCaps.dwAlignVideoPortCropBoundary  = 1;
                  VideoPortCaps.dwAlignVideoPortCropWidth     = 1;

                  // not valid for PRESHRINKX/YB flag as set above
                  VideoPortCaps.dwPreshrinkXStep = 24;
                  VideoPortCaps.dwPreshrinkYStep = 0x400;


                  VideoPortCaps.dwNumVBIAutoFlipSurfaces = 5;

                  VideoPortCaps.dwNumPreferredAutoflip =3;
                  VideoPortCaps.wNumFilterTapsX = 5;
                  VideoPortCaps.wNumFilterTapsY = 1;

                  memcpy(&pVideoPortCapsDest[dwIndex], &VideoPortCaps, sizeof(VideoPortCaps) );
               }
            }
            lpData->ddRVal = DD_OK;
        }
    }
#endif // !WINNT || NVPE      // BUGBUG - we will add Win2K videoport support

    if (IsEqualIID_C((lpData->guidInfo), GUID_ZPixelFormats))
    {
        DPF_LEVEL(NVDBG_LEVEL_INFO, "D3DGetDriverInfo - Process GUID_ZPixelFormats");

        global.dwDXRuntimeVersion = max (global.dwDXRuntimeVersion, 0x0600);

        /*
         * Return a pointer to the z-buffer format data.
         */
        dwSize = min(lpData->dwExpectedSize, sizeof(NvZPixelFormats));
        memcpy(lpData->lpvData, &NvZPixelFormats, dwSize);
        lpData->dwActualSize = dwSize;

        /*
         * Don't export 24-bit z-buffer formats if the registry has disabled them.
         */
        if (!(getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_Z24ENABLE_ENABLE)) {
            ((ZPIXELFORMATS *)lpData->lpvData)->dwNumZFormats = NV_NUM_16BIT_ZBUFFER_FORMATS;
        }

        /*
         * Set successful return code.
         */
        lpData->ddRVal = DD_OK;
    }

#ifdef WINNT
    // Under Win2K/DX7 there is a GUID_ for UpdateNonLocalHeap where under Win9x
    // this function has been a callback.

    if (IsEqualIID_C((lpData->guidInfo), GUID_UpdateNonLocalHeap) && ppdev->AgpHeap)
    {
#ifdef NV_AGP
        nvAssert(0); // we should never get GUID_UpdateNonLocalHeap with NV_AGP enabled
#else // !NV_AGP
        DD_UPDATENONLOCALHEAPDATA *pHeapData;
        ULONG pAgpBase;

        pHeapData = (DD_UPDATENONLOCALHEAPDATA *) lpData->lpvData;
        pHeapData->dwHeap = AGP_HEAP;
        pDriverData->GARTPhysicalBase = pHeapData->fpGARTDev;
        pDriverData->GARTLinearHeapOffset = pHeapData->fpGARTLin;

        // get the aperture size as set in the BIOS
        NvRmConfigGet(pDriverData->dwRootHandle,
                      NV_WIN_DEVICE,
                      NV_CFG_AGP_PHYS_BASE,
                      &pAgpBase);
        NvWin2KGetAgpLimit(pDriverData, pDriverData->dwRootHandle, NV_WIN_DEVICE);

        if (ppdev->AgpPushBuffer && (ppdev->DmaPushBufTotalSize <= pDriverData->regMaxAGPLimit))
            pDriverData->regMaxAGPLimit -= ppdev->DmaPushBufTotalSize;

        NvWin2KMapAgpHeap(pDriverData);
#endif // !NV_AGP
    }

    if (IsEqualIID_C((lpData->guidInfo), GUID_GetHeapAlignment))
    {
        DD_GETHEAPALIGNMENTDATA *lpGhaData;
        lpGhaData = (DD_GETHEAPALIGNMENTDATA *) lpData->lpvData;

        if (lpGhaData->dwHeap == 0) {
            lpGhaData->Alignment.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN |
                                                  DDSCAPS_EXECUTEBUFFER  |
                                                  DDSCAPS_OVERLAY        |
                                                  DDSCAPS_TEXTURE        |
                                                  DDSCAPS_ZBUFFER        |
                                                  DDSCAPS_ALPHA          |
                                                  DDSCAPS_FLIP;

            /* Alignments in bytes */

            lpGhaData->Alignment.ExecuteBuffer.Linear.dwStartAlignment = 0;
            lpGhaData->Alignment.ExecuteBuffer.Linear.dwPitchAlignment = 0;

            lpGhaData->Alignment.Overlay.Linear.dwStartAlignment = NV_OVERLAY_BYTE_ALIGNMENT;
            lpGhaData->Alignment.Overlay.Linear.dwPitchAlignment = NV_OVERLAY_BYTE_ALIGNMENT;

            lpGhaData->Alignment.Texture.Linear.dwStartAlignment = pDriverData->dwSurfaceAlign; /* Texture surfaces, not our optimized texture alignment */
            lpGhaData->Alignment.Texture.Linear.dwPitchAlignment = pDriverData->dwSurfaceAlign;

            lpGhaData->Alignment.ZBuffer.Linear.dwStartAlignment = pDriverData->dwSurfaceAlign;
            lpGhaData->Alignment.ZBuffer.Linear.dwPitchAlignment = pDriverData->dwSurfaceAlign;

            lpGhaData->Alignment.AlphaBuffer.Linear.dwStartAlignment = pDriverData->dwSurfaceAlign;
            lpGhaData->Alignment.AlphaBuffer.Linear.dwPitchAlignment = pDriverData->dwSurfaceAlign;

            lpGhaData->Alignment.Offscreen.Linear.dwStartAlignment = pDriverData->dwSurfaceAlign;
            lpGhaData->Alignment.Offscreen.Linear.dwPitchAlignment = pDriverData->dwSurfaceAlign;

            lpGhaData->Alignment.FlipTarget.Linear.dwStartAlignment = pDriverData->dwSurfaceBitAlign;
            lpGhaData->Alignment.FlipTarget.Linear.dwPitchAlignment = pDriverData->dwSurfaceAlign;

        }
    }

    if (IsEqualIID_C((lpData->guidInfo), GUID_NTPrivateDriverCaps))
    {
#define DDHAL_PRIVATECAP_RESERVED1 0x00000004l        // WinXP - no 7 second stall on mode switch
        DD_NTPRIVATEDRIVERCAPS *pNTPrivateDriverCaps = (DD_NTPRIVATEDRIVERCAPS*)lpData->lpvData;
        pNTPrivateDriverCaps->dwPrivateCaps = DDHAL_PRIVATECAP_ATOMICSURFACECREATION
                                            | DDHAL_PRIVATECAP_NOTIFYPRIMARYCREATION
                                            | DDHAL_PRIVATECAP_RESERVED1;
        lpData->ddRVal = DD_OK;
    }
#endif // WINNT

    //watch out for stereo call GUID_DDStereoMode
    //only allow DX8 driver calls to be parsed by Celsius and Kelvin driver
    if (IsEqualIID_C((lpData->guidInfo), GUID_GetDriverInfo2) &&
        ((DD_STEREOMODE*)lpData->lpvData)->dwHeight == D3DGDI2_MAGIC &&
        (
#if (NVARCH >= 0x020)
        (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) ||
#endif // (NVARCH >= 0x020)
        (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS)
         ))
    {

        DD_GETDRIVERINFO2DATA* pGDI2 = (DD_GETDRIVERINFO2DATA*)lpData->lpvData;

        switch (pGDI2->dwType)
        {
            case D3DGDI2_TYPE_GETD3DCAPS8:
            {
                DWORD copySize = min(sizeof(getDC()->nvD3DDevCaps.dwD3DCap8), pGDI2->dwExpectedSize);

                global.dwDXRuntimeVersion = max (global.dwDXRuntimeVersion, 0x0800);

                memcpy(lpData->lpvData, &(getDC()->nvD3DDevCaps.dwD3DCap8), copySize);
                lpData->dwActualSize = copySize;
                lpData->ddRVal       = DD_OK;
            }
            break;

            case D3DGDI2_TYPE_GETFORMATCOUNT:
            {
                DD_GETFORMATCOUNTDATA * pGFCD = (DD_GETFORMATCOUNTDATA *)lpData->lpvData;

#ifdef TEXFORMAT_CRD // --------------------------------

                pGFCD->dwFormatCount = getDC()->dwPixelFormatCount;

#else // !TEXFORMAT_CRD  --------------------------------

#if (NVARCH >= 0x020)
                if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)
                {
#ifdef DXT_SUPPORT
                    if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_TEXTURECOMPRESSIONENABLE_MASK) == D3D_REG_TEXTURECOMPRESSIONENABLE_ENABLE)
                    {
                        pGFCD->dwFormatCount = sizeof(kelvinPixelFormatsDX8) / sizeof(DDPIXELFORMAT);
                    }
                    else
#endif
                    {
                        pGFCD->dwFormatCount = sizeof(kelvinPixelFormatsDX8NoDXT) / sizeof(DDPIXELFORMAT);
                    }
                }
                else
#endif
                {
#ifdef DXT_SUPPORT
                    if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_TEXTURECOMPRESSIONENABLE_MASK) == D3D_REG_TEXTURECOMPRESSIONENABLE_ENABLE)
                    {
                        pGFCD->dwFormatCount =  sizeof(celsiusPixelFormatsDX8) / sizeof(DDPIXELFORMAT);
                    }
                    else
#endif
                    {
                        pGFCD->dwFormatCount = sizeof(celsiusPixelFormatsDX8NoDXT) / sizeof(DDPIXELFORMAT);
                    }
                }

                if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN)) {
                    if ((global.dwDXRuntimeVersion < 0x0800) ||
                        ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_PALETTEENABLE_MASK) == D3D_REG_PALETTEENABLE_DISABLE))
                    {
                        pGFCD->dwFormatCount -= NV_NUM_8BIT_TEXTURE_FORMATS;
                    }
                }

#endif // !TEXFORMAT_CRD  --------------------------------

                lpData->dwActualSize = sizeof(DD_GETFORMATCOUNTDATA);
                lpData->ddRVal       = DD_OK;
            }
            break;

            case D3DGDI2_TYPE_GETFORMAT:
            {
                DD_GETFORMATDATA* pGFD = (DD_GETFORMATDATA *)lpData->lpvData;

#ifdef TEXFORMAT_CRD // --------------------------------

                pGFD->format = (getDC()->pPixelFormats)[pGFD->dwFormatIndex];

#else // !TEXFORMAT_CRD  --------------------------------

#if (NVARCH >= 0x020)
                if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)
                {
#ifdef DXT_SUPPORT
                    if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_TEXTURECOMPRESSIONENABLE_MASK) == D3D_REG_TEXTURECOMPRESSIONENABLE_ENABLE)
                    {
                        pGFD->format = kelvinPixelFormatsDX8[pGFD->dwFormatIndex];
                    }
                    else
#endif // DXT_SUPPORT
                    {
                        pGFD->format = kelvinPixelFormatsDX8NoDXT[pGFD->dwFormatIndex];
                    }
                }
                else
#endif // (NVARCH >= 0x020)
                {
#ifdef DXT_SUPPORT
                    if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_TEXTURECOMPRESSIONENABLE_MASK) == D3D_REG_TEXTURECOMPRESSIONENABLE_ENABLE)
                    {
                        pGFD->format = celsiusPixelFormatsDX8[pGFD->dwFormatIndex];
                    }
                    else
#endif // DXT_SUPPORT
                    {
                        pGFD->format = celsiusPixelFormatsDX8NoDXT[pGFD->dwFormatIndex];
                    }
                }
#endif // !TEXFORMAT_CRD  --------------------------------

                lpData->dwActualSize = sizeof(DD_GETFORMATDATA);
                lpData->ddRVal       = DD_OK;
            }
            break;

            case D3DGDI2_TYPE_DXVERSION:
            {
                DD_DXVERSION* pGFD = (DD_DXVERSION *)lpData->lpvData;
                global.dwDXRuntimeVersion = max (global.dwDXRuntimeVersion, pGFD->dwDXVersion);
                lpData->dwActualSize = sizeof(DD_DXVERSION);
                lpData->ddRVal       = DD_OK;
            }
            break;
        }
    }

    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);

} // GetDriverInfo32

//---------------------------------------------------------------------------
//
// SetExclusiveMode32 DDHAL callback
//
#ifndef WINNT
DWORD __stdcall SetExclusiveMode32 (LPDDHAL_SETEXCLUSIVEMODEDATA lpSetExclusiveMode)
{
HANDLE eventExclusive;

    lpSetExclusiveMode->ddRVal = DD_OK;

    // We need to signal quicktweak that we have entered fullscreen exclusive mode
    // for mobile hotkey disabling. This scenario is guaranteed to be in a single
    // physical adapter configuration.
    eventExclusive = OpenEvent(EVENT_MODIFY_STATE, FALSE, EVENTNAME_DXEXCLUSIVEMODE);
    if (eventExclusive) {
        if (lpSetExclusiveMode->dwEnterExcl) {
            SetEvent(eventExclusive);
        } else {
            ResetEvent(eventExclusive);
        }

        CloseHandle(eventExclusive);
    }

    return DDHAL_DRIVER_HANDLED;
}
#endif  // !WINNT

//---------------------------------------------------------------------------
//
// FlipToGDISurface32 DDHAL callback
//
// - enabling this callback causes flashing problems with MS Combat Flight Simulator 2
//
DWORD __stdcall FlipToGDISurface32 (LPDDHAL_FLIPTOGDISURFACEDATA lpFlipToGDISurface)
{
#ifndef WINNT
    lpFlipToGDISurface->ddRVal = DD_OK;
    nvSetDriverDataPtrFromDDGbl (lpFlipToGDISurface->lpDD);

    // In extended mode, the DX runtime could call us here after the push buffer has
    // been destroyed by the first call to DestroyDriver32.  Test for validity of the push buffer.
    if ((pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0097_KELVIN) ||
        (!getDC()->nvPusher.isValid()))
    {
        return DDHAL_DRIVER_NOTHANDLED;
    }
    else if ((pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_1196_CELSIUS | NVCLASS_0096_CELSIUS))
          && (lpFlipToGDISurface->dwToGDI))
    {
        // flush out all but one v-blank
        WaitForIdle(TRUE, FALSE);

        // get the current v-blank count
        NV_CFGEX_VBLANK_COUNTER_MULTI_PARAMS nvVBCounter;
        nvVBCounter.Head = GET_CURRENT_HEAD();
        NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_VBLANK_COUNTER_MULTI,
            &nvVBCounter, sizeof(nvVBCounter));

        // wait for one more v-blank (only really required in triple buffered case)
        DWORD dwFirstCount = nvVBCounter.VBlankCounter;
        do {
            NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_VBLANK_COUNTER_MULTI,
                &nvVBCounter, sizeof(nvVBCounter));
        } while (nvVBCounter.VBlankCounter == dwFirstCount);

        // tell the HW we want to start writing to the next buffer, this must stay in-sync
        nvglSetNv15CelsiusSyncIncWrite (NV_DD_CELSIUS);

        BOOL  bCloneMode = pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE;
        DWORD dwDAC      = NV_DD_VIDEO_LUT_CURSOR_DAC + (bCloneMode ? 0 : pDXShare->dwHeadNumber);

        DWORD dwNumHeads = bCloneMode ? pDriverData->dwHeads : 1;
        DWORD dwFormat   = (NV07C_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY << 31) |
                           (NV07C_SET_IMAGE_FORMAT_FLAGS_COMPLETE_ON_OBJECT_CLEANUP << 25) |
                           (((DIBENGINEHDR1 *)pDXShare->pFlatDibeng)->deDeltaScan);
        dwFormat |= (NV07C_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY << 20);
        dwFormat |= bCloneMode ? (NV07C_SET_IMAGE_FORMAT_MULTIHEAD_SYNC_ENABLED << 24) :
                                 (NV07C_SET_IMAGE_FORMAT_MULTIHEAD_SYNC_DISABLED << 24);

        PRIMARY_BUFFER_INDEX ^= 0x1;

        for (DWORD dwHead = 0; dwHead < dwNumHeads; dwHead++) {

            // calculate offset, the RM will add the pan & scan adjustment from the display driver if needed
            DWORD dwOffset = GET_PRIMARY_ADDR() - pDriverData->BaseAddress;

            // program the flip
            nvglSetObject (NV_DD_SURFACES, dwDAC + dwHead); // load the DAC object
            nvglSetNv15VideoLUTCursorDACImageData (NV_DD_SURFACES, PRIMARY_BUFFER_INDEX, dwOffset, dwFormat);
        }

        // put back the NV_DD_SURFACES_2D object
        nvglSetObject (NV_DD_SURFACES, NV_DD_SURFACES_2D);

        nvPusherStart(TRUE);

        // update frame counter
        CURRENT_FLIP ++;

        return (DDHAL_DRIVER_HANDLED);
    }

#endif // !WINNT
    return DDHAL_DRIVER_NOTHANDLED;
}

//---------------------------------------------------------------------------

/*
 * buildDDHALInfo32
 *
 * build DDHALInfo structure
 */
BOOL __stdcall buildDDHALInfo32(GLOBALDATA *pDriverData)
{
    int i;
#ifndef NVPE
    char regStr[256] = {0,0,0,0,0,0};
    HKEY hKey;
#endif // NVPE

    dbgTracePush ("buildDDHALInfo32");

    /*
     * fill out the main driver callbacks
     */
    memset(&pDriverData->DDCallbacks, 0, sizeof(DDHAL_DDCALLBACKS));
    pDriverData->DDCallbacks.dwSize                = sizeof(DDHAL_DDCALLBACKS);
//    pDriverData->DDCallbacks.SetMode               = SetMode32;   Never called by DDRAW
    pDriverData->DDCallbacks.WaitForVerticalBlank  = WaitForVerticalBlank32;
    pDriverData->DDCallbacks.GetScanLine           = GetScanLine32;
    pDriverData->DDCallbacks.CreateSurface         = CreateSurface32;
    pDriverData->DDCallbacks.CanCreateSurface      = CanCreateSurface32;
#ifndef WINNT
    pDriverData->DDCallbacks.SetExclusiveMode      = SetExclusiveMode32;
#endif

    pDriverData->DDCallbacks.dwFlags               = DDHAL_CB32_WAITFORVERTICALBLANK
#ifndef WINNT
                                                   | DDHAL_CB32_SETEXCLUSIVEMODE
#endif
//                                                 | DDHAL_CB32_SETMODE
                                                   | DDHAL_CB32_GETSCANLINE
                                                   | DDHAL_CB32_CANCREATESURFACE
                                                   | DDHAL_CB32_CREATESURFACE;

#ifndef WINNT // not needed under WINNT
    pDriverData->DDCallbacks.DestroyDriver         = (LPDDHAL_DESTROYDRIVER)DestroyDriver32;

    pDriverData->DDCallbacks.dwFlags               |= DDHAL_CB32_DESTROYDRIVER;
#endif  // !WINNT


    // fill out the palette callbacks
    memset(&pDriverData->DDPaletteCallbacks, 0, sizeof(DDHAL_DDPALETTECALLBACKS));
    pDriverData->DDPaletteCallbacks.dwSize  = sizeof(DDHAL_DDPALETTECALLBACKS);
    pDriverData->DDPaletteCallbacks.dwFlags = 0;

    // set up pointer to DDHALINFO
    LPDDHALINFO pHalInfo = GET_HALINFO();

    // fill out the HALINFO
#ifndef WINNT   // These don't exist under NT, HAL callbacks returned via DrvGetDirectDrawInfo
    memset(pHalInfo, 0, sizeof(DDHALINFO));
#endif

    pHalInfo->dwSize = sizeof(DDHALINFO);
    pHalInfo->ddCaps.dwSize = sizeof(DDCORECAPS);

#ifndef WINNT
    // callback functions
    pHalInfo->lpDDCallbacks        = &pDriverData->DDCallbacks;
    pHalInfo->lpDDSurfaceCallbacks = &pDriverData->DDSurfaceCallbacks;
    pHalInfo->lpDDPaletteCallbacks = &pDriverData->DDPaletteCallbacks;
    pHalInfo->lpDDExeBufCallbacks  = &pDriverData->DDExecuteBufferCallbacks;

    // although MS calls this an instance handle, they actually just want a unique per head/card identifier
    pHalInfo->hInstance = (DWORD)pDXShare;

    // set the physical device ptr
    DIBENGINEHDR1 *pDibeng = (DIBENGINEHDR1 *)pDXShare->pFlatDibeng;
    pHalInfo->lpPDevice = (void*)pDibeng->delpPDevice;
#endif  // !WINNT

    // ROPS supported
    for ( i=0; i < DD_ROP_SPACE; i++ )
        pHalInfo->ddCaps.dwRops[i] = ropList[i];

    // fill out the surface callbacks
    memset(&pDriverData->DDSurfaceCallbacks, 0, sizeof(DDHAL_DDSURFACECALLBACKS));
    pDriverData->DDSurfaceCallbacks.dwSize             = sizeof(DDHAL_DDSURFACECALLBACKS);
    pDriverData->DDSurfaceCallbacks.DestroySurface     = DestroySurface32;
    pDriverData->DDSurfaceCallbacks.Blt                = Blit32;
    pDriverData->DDSurfaceCallbacks.Flip               = Flip32;
    pDriverData->DDSurfaceCallbacks.Lock               = Lock32;
    pDriverData->DDSurfaceCallbacks.Unlock             = Unlock32;
    pDriverData->DDSurfaceCallbacks.GetBltStatus       = GetBltStatus32;
    pDriverData->DDSurfaceCallbacks.GetFlipStatus      = GetFlipStatus32;
    pDriverData->DDSurfaceCallbacks.SetColorKey        = SetSurfaceColorKey32;
    if (NO_OVERLAY) {
        pDriverData->DDSurfaceCallbacks.UpdateOverlay      = NULL;
        pDriverData->DDSurfaceCallbacks.SetOverlayPosition = NULL;
        pDriverData->DDSurfaceCallbacks.dwFlags            = DDHAL_SURFCB32_BLT |
                                                             DDHAL_SURFCB32_FLIP |
                                                             DDHAL_SURFCB32_LOCK |
                                                             DDHAL_SURFCB32_UNLOCK |
                                                             DDHAL_SURFCB32_SETCOLORKEY |
                                                             DDHAL_SURFCB32_GETBLTSTATUS |
                                                             DDHAL_SURFCB32_GETFLIPSTATUS |
                                                             DDHAL_SURFCB32_DESTROYSURFACE;
    } else {
        pDriverData->DDSurfaceCallbacks.UpdateOverlay      = UpdateOverlay32;
        pDriverData->DDSurfaceCallbacks.SetOverlayPosition = SetOverlayPosition32;
        pDriverData->DDSurfaceCallbacks.dwFlags            = DDHAL_SURFCB32_BLT |
                                                             DDHAL_SURFCB32_FLIP |
                                                             DDHAL_SURFCB32_LOCK |
                                                             DDHAL_SURFCB32_UNLOCK |
                                                             DDHAL_SURFCB32_SETCOLORKEY |
                                                             DDHAL_SURFCB32_GETBLTSTATUS |
                                                             DDHAL_SURFCB32_GETFLIPSTATUS |
                                                             DDHAL_SURFCB32_UPDATEOVERLAY |
                                                             DDHAL_SURFCB32_SETOVERLAYPOSITION |
                                                             DDHAL_SURFCB32_DESTROYSURFACE;
    }

#ifndef DO_NOT_SUPPORT_VERTEX_BUFFERS // see nvprecomp.h
    if (
#if (NVARCH >= 0x020)
        (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) ||
#endif // (NVARCH >= 0x020)
        (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS)
       )
    {
        /*
         * populate execute buffer callbacks, so that we can allocate vertex buffers
         */
        pDriverData->DDExecuteBufferCallbacks.dwSize                 = sizeof(pDriverData->DDExecuteBufferCallbacks);
#ifdef WINNT
        pDriverData->DDExecuteBufferCallbacks.CanCreateD3DBuffer     = D3DCanCreateExecuteBuffer32;
        pDriverData->DDExecuteBufferCallbacks.CreateD3DBuffer        = D3DCreateExecuteBuffer32;
        pDriverData->DDExecuteBufferCallbacks.DestroyD3DBuffer       = D3DDestroyExecuteBuffer32;
        pDriverData->DDExecuteBufferCallbacks.LockD3DBuffer          = D3DLockExecuteBuffer32;
        pDriverData->DDExecuteBufferCallbacks.UnlockD3DBuffer        = D3DUnlockExecuteBuffer32;
        pDriverData->DDExecuteBufferCallbacks.dwFlags                = 0x1F; //hardcoded flags aren't defined
#else
        pDriverData->DDExecuteBufferCallbacks.CanCreateExecuteBuffer = D3DCanCreateExecuteBuffer32;
        pDriverData->DDExecuteBufferCallbacks.CreateExecuteBuffer    = D3DCreateExecuteBuffer32;
        pDriverData->DDExecuteBufferCallbacks.DestroyExecuteBuffer   = D3DDestroyExecuteBuffer32;
        pDriverData->DDExecuteBufferCallbacks.LockExecuteBuffer      = D3DLockExecuteBuffer32;
        pDriverData->DDExecuteBufferCallbacks.UnlockExecuteBuffer    = D3DUnlockExecuteBuffer32;
        pDriverData->DDExecuteBufferCallbacks.dwFlags                = DDHAL_EXEBUFCB32_CANCREATEEXEBUF
                                                                     | DDHAL_EXEBUFCB32_CREATEEXEBUF
                                                                     | DDHAL_EXEBUFCB32_DESTROYEXEBUF
                                                                     | DDHAL_EXEBUFCB32_LOCKEXEBUF
                                                                     | DDHAL_EXEBUFCB32_UNLOCKEXEBUF;
#endif
    }
    else
#endif //!DO_NOT_SUPPORT_VERTEX_BUFFERS
    {
        /*
         * we are not interested in any vertex buffer allocation
         */
        memset (&pDriverData->DDExecuteBufferCallbacks,0,sizeof(pDriverData->DDExecuteBufferCallbacks));
        pDriverData->DDExecuteBufferCallbacks.dwSize = sizeof(pDriverData->DDExecuteBufferCallbacks);
    }

    /*
     * capabilities supported
     */
    if (NO_OVERLAY) {
        pHalInfo->ddCaps.dwCaps = DDCAPS_ALIGNSTRIDE |
                                  DDCAPS_ALIGNBOUNDARYDEST |
                                  DDCAPS_BLT |
                                  DDCAPS_BLTFOURCC |
                                  DDCAPS_BLTSTRETCH |
                                  DDCAPS_BLTQUEUE |
                                  DDCAPS_BLTCOLORFILL |
                                  DDCAPS_CANBLTSYSMEM |
                                  DDCAPS_ALPHA |
                                  DDCAPS_COLORKEY |
                                  DDCAPS_READSCANLINE |
                                  DDCAPS_BLTDEPTHFILL |
                                  DDCAPS_3D;
    } else {
        pHalInfo->ddCaps.dwCaps = DDCAPS_ALIGNSTRIDE |
                                  DDCAPS_ALIGNBOUNDARYDEST |
                                  DDCAPS_BLT |
                                  DDCAPS_BLTFOURCC |
                                  DDCAPS_BLTSTRETCH |
                                  DDCAPS_BLTQUEUE |
                                  DDCAPS_BLTCOLORFILL |
                                  DDCAPS_CANBLTSYSMEM |
                                  DDCAPS_ALPHA |
                                  DDCAPS_COLORKEY |
                                  DDCAPS_OVERLAY |
                                  DDCAPS_OVERLAYCANTCLIP  |
                                  DDCAPS_OVERLAYFOURCC |
                                  DDCAPS_OVERLAYSTRETCH |
                                  DDCAPS_READSCANLINE |
                                  DDCAPS_BLTDEPTHFILL |
                                  DDCAPS_3D;
    }

#ifndef WINNT
    pHalInfo->ddCaps.dwCaps |= DDCAPS_GDI;
#endif

#ifndef WINNT
    if ((pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN)) &&
        (global.dwDXRuntimeVersion >= 0x0800) &&
#ifdef TEXFORMAT_CRD
        (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_PALETTIZED))
#else   // !TEXFORMAT_CRD
        ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_PALETTEENABLE_MASK) == D3D_REG_PALETTEENABLE_ENABLE))
#endif  // !TEXFORMAT_CRD
    {
        pHalInfo->ddCaps.dwCaps |= DDCAPS_PALETTE;
    }
#endif

    pHalInfo->ddCaps.dwCaps2 |= DDCAPS2_NOPAGELOCKREQUIRED
//                             | DDCAPS2_CERTIFIED           // **** Turning this on breaks HAL enumeration ****
                             |  DDCAPS2_WIDESURFACES
                             |  DDCAPS2_PRIMARYGAMMA
                             |  DDCAPS2_CANRENDERWINDOWED
                             |  DDCAPS2_NONLOCALVIDMEMCAPS
                             |  DDCAPS2_COPYFOURCC;

    if (pDriverData->dwBusType == NV_BUS_TYPE_AGP) {
        // intially set DDCAPS2_NONLOCALVIDMEM here, it may be cleared later
        // in buildDDHalInfo16 on Win9x, or in DrvGetDirectDrawInfo on Win2K
        pHalInfo->ddCaps.dwCaps2 |= DDCAPS2_NONLOCALVIDMEM;
    }


    if (!NO_OVERLAY) {
        pHalInfo->ddCaps.dwCaps2 |= DDCAPS2_CANBOBHARDWARE
                                 |  DDCAPS2_CANBOBNONINTERLEAVED
                                 |  DDCAPS2_CANBOBINTERLEAVED
                                 |  DDCAPS2_CANBOBHARDWARE
                                 |  DDCAPS2_CANFLIPODDEVEN;
    }

#if defined(TEX_MANAGE)
    if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_TEXTUREMANAGEMENTENABLE_MASK) == D3D_REG_TEXTUREMANAGEMENTENABLE_ENABLE) {
        pHalInfo->ddCaps.dwCaps2 |= DDCAPS2_CANMANAGETEXTURE;
    }
#endif

    // set flipnovsync flag only on hardware later than NV4
    if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_0049_DAC |
                                                  NVCLASS_0067_DAC |
                                                  NVCLASS_007C_DAC)) {
        pHalInfo->ddCaps.dwCaps2 |= DDCAPS2_FLIPNOVSYNC;
    }


    if (NO_OVERLAY) {
        pHalInfo->ddCaps.dwCKeyCaps = DDCKEYCAPS_SRCBLT;

        pHalInfo->ddCaps.dwFXCaps = DDFXCAPS_BLTARITHSTRETCHY |
                                    DDFXCAPS_BLTMIRRORLEFTRIGHT |
                                    DDFXCAPS_BLTMIRRORUPDOWN |
                                    DDFXCAPS_BLTSHRINKX |
                                    DDFXCAPS_BLTSHRINKY |
                                    DDFXCAPS_BLTSTRETCHX |
                                    DDFXCAPS_BLTSTRETCHY |
                                    DDFXCAPS_BLTALPHA |
                                    DDFXCAPS_BLTFILTER;
    } else {
        if ((pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) || pDriverData->vpp.regOverlayColourControlEnable)
            pHalInfo->ddCaps.dwCaps2 |= DDCAPS2_COLORCONTROLOVERLAY;

        pHalInfo->ddCaps.dwCKeyCaps = DDCKEYCAPS_SRCBLT |
                                      DDCKEYCAPS_DESTOVERLAY |
                                      DDCKEYCAPS_DESTOVERLAYONEACTIVE;

        pHalInfo->ddCaps.dwFXCaps = DDFXCAPS_BLTARITHSTRETCHY |
                                    DDFXCAPS_BLTMIRRORLEFTRIGHT |
                                    DDFXCAPS_BLTMIRRORUPDOWN |
                                    DDFXCAPS_BLTSHRINKX |
                                    DDFXCAPS_BLTSHRINKY |
                                    DDFXCAPS_BLTSTRETCHX |
                                    DDFXCAPS_BLTSTRETCHY |
                                    DDFXCAPS_BLTALPHA |
                                    DDFXCAPS_BLTFILTER |
                                    DDFXCAPS_OVERLAYFILTER |
                                    DDFXCAPS_OVERLAYMIRRORUPDOWN |
                                    DDFXCAPS_OVERLAYSHRINKX |
                                    DDFXCAPS_OVERLAYSHRINKY |
                                    DDFXCAPS_OVERLAYSTRETCHX |
                                    DDFXCAPS_OVERLAYARITHSTRETCHY |
                                    DDFXCAPS_OVERLAYSTRETCHY;
    }

#ifndef WINNT // sigh this causes us to die HMH
    if ((pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN)) &&
        (global.dwDXRuntimeVersion >= 0x0800) &&
#ifdef TEXFORMAT_CRD
        (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_PALETTIZED))
#else   // !TEXFORMAT_CRD
        ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_PALETTEENABLE_MASK) == D3D_REG_PALETTEENABLE_ENABLE))
#endif  // !TEXFORMAT_CRD
    {
        pHalInfo->ddCaps.dwPalCaps = DDPCAPS_8BIT; // | DDPCAPS_ALLOW256;
    }
#endif

    pHalInfo->ddCaps.dwFXAlphaCaps  = 0;

    if (NO_OVERLAY) {
        pHalInfo->ddCaps.ddsCaps.dwCaps = DDSCAPS_VIDEOMEMORY |
                                          DDSCAPS_PRIMARYSURFACE |
                                          DDSCAPS_HWCODEC |
                                          DDSCAPS_OFFSCREENPLAIN |
                                          DDSCAPS_VISIBLE |
                                          DDSCAPS_FLIP |
                                          DDSCAPS_FRONTBUFFER |
                                          DDSCAPS_BACKBUFFER |
                                          DDSCAPS_ZBUFFER |
                                          DDSCAPS_3DDEVICE |
                                          DDSCAPS_ALPHA |
                                          DDSCAPS_TEXTURE |
                                          DDSCAPS_MIPMAP |
                                          DDSCAPS_EXECUTEBUFFER;
    } else {
        pHalInfo->ddCaps.ddsCaps.dwCaps = DDSCAPS_VIDEOMEMORY |
                                          DDSCAPS_PRIMARYSURFACE |
                                          DDSCAPS_HWCODEC |
                                          DDSCAPS_OFFSCREENPLAIN |
                                          DDSCAPS_VISIBLE |
                                          DDSCAPS_FLIP |
                                          DDSCAPS_FRONTBUFFER |
                                          DDSCAPS_BACKBUFFER |
                                          DDSCAPS_OVERLAY |
                                          DDSCAPS_ZBUFFER |
                                          DDSCAPS_3DDEVICE |
                                          DDSCAPS_ALPHA |
                                          DDSCAPS_TEXTURE |
                                          DDSCAPS_MIPMAP |
                                          DDSCAPS_EXECUTEBUFFER;
    }

#ifndef WINNT
    pHalInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
#endif

#ifndef WINNT
    if ((pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN)) &&
        (global.dwDXRuntimeVersion >= 0x0800) &&
#ifdef TEXFORMAT_CRD
        (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_PALETTIZED))
#else   // !TEXFORMAT_CRD
        ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_PALETTEENABLE_MASK) == D3D_REG_PALETTEENABLE_ENABLE))
#endif  // !TEXFORMAT_CRD
    {
        pHalInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_PALETTE;
    }
#endif

#ifdef WINNT
    if (global.dwDXRuntimeVersion >= 0x800)
#else // !WINNT
    if (1)
#endif // !WINNT
    {
        for ( i=0; i < DD_ROP_SPACE; i++ )
            pHalInfo->ddCaps.dwSVBRops[i] = ropList[i];
        pHalInfo->ddCaps.dwSVBCaps = pHalInfo->ddCaps.dwCaps;
        pHalInfo->ddCaps.dwSVBCaps2 = pHalInfo->ddCaps.dwCaps2;
        pHalInfo->ddCaps.dwSVBCKeyCaps = pHalInfo->ddCaps.dwCKeyCaps;
        pHalInfo->ddCaps.dwSVBFXCaps = pHalInfo->ddCaps.dwFXCaps;

        pHalInfo->ddCaps.dwVSBCaps = DDCAPS_BLT |
            DDCAPS_BLTQUEUE;
        pHalInfo->ddCaps.dwVSBCKeyCaps = 0;
        pHalInfo->ddCaps.dwVSBFXCaps = 0;
        for ( i=0; i < DD_ROP_SPACE; i++ ) {
            pHalInfo->ddCaps.dwVSBRops[i] = 0;
        }
        pHalInfo->ddCaps.dwVSBRops[6] = SRCCOPYBIT;
    }
    else
    {
        // turn off system->video blits on Win2K DX7 runtime due to MS bug (TestDrive 6)
        for ( i=0; i < DD_ROP_SPACE; i++ )
            pHalInfo->ddCaps.dwSVBRops[i] = 0;

        pHalInfo->ddCaps.dwSVBCaps = 0;
        pHalInfo->ddCaps.dwSVBCaps2 = 0;
        pHalInfo->ddCaps.dwSVBCKeyCaps = 0;
        pHalInfo->ddCaps.dwSVBFXCaps = 0;
        pHalInfo->ddCaps.dwVSBCaps = 0;
        pHalInfo->ddCaps.dwVSBCKeyCaps = 0;
        pHalInfo->ddCaps.dwVSBFXCaps = 0;

        for ( i=0; i < DD_ROP_SPACE; i++ )
            pHalInfo->ddCaps.dwVSBRops[i] = 0;
    }

    /*
     * Z buffer bit depths supported
     */
    pHalInfo->ddCaps.dwZBufferBitDepths = DDBD_16 | DDBD_24;

    /*
     * NV3 Required alignments
     */
    pHalInfo->ddCaps.dwAlignBoundaryDest = 1;
    /* All video memory surfaces must be aligned with aligned strides */
    pHalInfo->ddCaps.dwAlignStrideAlign = pDriverData->dwSurfaceAlign;

    /*
     * NV3 stretching capabilities
     */
    pHalInfo->ddCaps.dwMinOverlayStretch = 1;
    pHalInfo->ddCaps.dwMaxOverlayStretch = 20000;

    pHalInfo->ddCaps.dwMinLiveVideoStretch = 1;
    pHalInfo->ddCaps.dwMaxLiveVideoStretch = 20000;

    pHalInfo->ddCaps.dwMinHwCodecStretch = 1;
    pHalInfo->ddCaps.dwMaxHwCodecStretch = 4095000;

    /*
     *  FOURCCs supported
     *
     *  Table address MUST be set in 16 bit portion of Direct Draw Driver but
     *  can add more FOURCC codes to table here if needed.
     */

    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
        pHalInfo->ddCaps.dwNumFourCCCodes = NV_MAX_FOURCC;
    }
    else {
        pHalInfo->ddCaps.dwNumFourCCCodes = NV_MAX_FOURCC_REGULAR;
    }

    /*
     *  Maximum number of overlays supported
     */

    if (NO_OVERLAY) {
        pHalInfo->ddCaps.dwMaxVisibleOverlays = 0;
    } else {
        pHalInfo->ddCaps.dwMaxVisibleOverlays = 1;
    }

    /*
     * current video mode, the 16bit driver will fill this out for real.
     */
#ifndef WINNT   // Under WINNT, mode sets are handled by display driver
    pHalInfo->dwModeIndex = DDUNSUPPORTEDMODE;
#endif

    /*
     * required byte alignments of the scan lines for each kind of memory
     * (default is 4, NV3 needs 16, NV4 needs 32, NV10 wants 64
     */
    pHalInfo->vmiData.dwOffscreenAlign = pDriverData->dwSurfaceAlign;
    pHalInfo->vmiData.dwOverlayAlign   = NV_OVERLAY_BYTE_ALIGNMENT;
    pHalInfo->vmiData.dwTextureAlign   = pDriverData->dwSurfaceAlign; // Texture surface, not our optimized texture
    pHalInfo->vmiData.dwAlphaAlign     = pDriverData->dwSurfaceAlign;
    pHalInfo->vmiData.dwZBufferAlign   = pDriverData->dwSurfaceAlign;

#ifdef NVD3D
    pDriverData->bDirtyRenderTarget = TRUE;
    pDriverData->ThreeDRenderingOccurred = FALSE;

    // If 24-bit z-buffers are disabled, only show 16-bit formats.
    if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_Z24ENABLE_MASK) == D3D_REG_Z24ENABLE_DISABLE) {
        pHalInfo->ddCaps.dwZBufferBitDepths = DDBD_16;
    }
#endif // NVD3D

#ifdef NVPE
    pDriverData->bEnableVPE = 0;
    if (NVPIsVPEEnabled(pDriverData, 0)) {
        pDriverData->bEnableVPE = 1;
    }
#else
    // Grab the local registry path and append the DirectDraw subkey to the string
    // without using the C runtime library.
#ifndef WINNT
    MyExtEscape(NV_ESC_GET_LOCAL_REGISTRY_PATH, 0, NULL, 256, regStr);
#endif // BUGBUG WINNT

    nvStrCat(&(regStr[4]), "\\" NV4_REG_DIRECT_DRAW_SUBKEY);

    //VPE enable stuff
    pDriverData->bEnableVPE = 1;

    if (RegOpenKeyEx((HKEY)(*((LPDWORD)&regStr[0])), &regStr[4], 0, KEY_QUERY_VALUE, &hKey) != ERROR_SUCCESS) {
        hKey = 0;
    }
    if (hKey) {
        DWORD   dwSize = sizeof(long);
        DWORD   dwType = REG_DWORD;
        long    lValue;

        //check for VPE enable bit
        if (RegQueryValueEx(hKey, NV4_REG_VPE_ENABLE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS) {
            if(!lValue)
                pDriverData->bEnableVPE = 0;
        }
        RegCloseKey(hKey);
    }
#endif // NVPE

    //VPE enable stuff
    if(pDriverData->bEnableVPE == 1 && !NO_OVERLAY) {
      /*
       * Video Port Capabilities
       */
      pHalInfo->ddCaps.dwCaps2 |= DDCAPS2_VIDEOPORT               |
                                             DDCAPS2_CANBOBINTERLEAVED       |
                                             DDCAPS2_CANBOBNONINTERLEAVED    |
                                             DDCAPS2_AUTOFLIPOVERLAY;

      pHalInfo->ddCaps.dwMaxVideoPorts = 1;
      pHalInfo->ddCaps.dwCurrVideoPorts = 0;

    }
    pHalInfo->GetDriverInfo = GetDriverInfo32;
    pHalInfo->dwFlags |= DDHALINFO_GETDRIVERINFOSET;
    if (
#if (NVARCH >= 0x020)
    (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) ||
#endif // (NVARCH >= 0x020)
    (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS)
     )
    {
    pHalInfo->dwFlags |= DDHALINFO_GETDRIVERINFO2;
    }
#ifndef WINNT
    pHalInfo->dwFlags |= DDHALINFO_MODEXILLEGAL;
#endif
#ifdef  STEREO_SUPPORT
    StereoModifyDDHALInfo();
#endif  //STEREO_SUPPORT

    DPF_LEVEL (NVDBG_LEVEL_INFO, "Display: Filling in ddHALInfo.GetDriverInfo: %x", GetDriverInfo32);

    dbgTracePop();
    return (TRUE);

}  // buildDDHALInfo32

//---------------------------------------------------------------------------

/*
    GetFlatCodeSel
*/
DWORD __stdcall GetFlatCodeSel (void)
{
    unsigned long dwSel;

    dbgTracePush ("GetFlatCodeSel");

    _asm
    {
        mov     ax,cs
        movzx   eax,ax
        mov     dwSel,eax
    }

    dbgTracePop();
    return (dwSel);
}

//---------------------------------------------------------------------------

/*
    GetFlatDataSel
*/
DWORD __stdcall GetFlatDataSel (void)
{
    unsigned long dwSel;

    dbgTracePush ("GetFlatDataSel");

    _asm
    {
        mov     ax,ds
        movzx   eax,ax
        mov     dwSel,eax
    }

    dbgTracePop();
    return (dwSel);
}

//---------------------------------------------------------------------------

#ifndef WINNT   // This is Win9x specific
/*
    buildDDHALInfo16 ()

    This procedure used to be in the display driver. It was there because
    the code in this routine needs to execute just after a modeset and
    before we call the DirectX internal funciton lpSetInfo and there is
    no mechanism for getting over to the DirectX driver and back to the
    display driver in a serialized fashion.  i.e. If we do a thunk to get
    over to the 32bit DirectX driver, then the Win16 mutex gets released
    and the sequence is not serialized properly.

    However, this code is properly DirectX code so it belongs in this
    driver, not over in the display driver. The bold way to execute this
    code in sequence with the code in the display driver is to CALL it
    directly without doing a thunk or releaseing the mutex!!! This imposes
    a few serious restrictions on what can occur in this routine.

    This routine can only have straight C code in it -- DO NOT call out
    to any system functions because you are not really running in flat
    land. When this routine is executing it is running as a part of the
    16 bit display driver!!  This should not be too much of a problem,
    though, because there is no necessity for doing more than setting
    capability bits and structure fields herein.

    If you call out to a system function (like memory allocation or
    any Kernel, USER32, GDI32, etc function, you will LOCK the system!!
*/

DWORD __stdcall buildDDHALInfo16 (void)
{
    LPDDHALMODEINFO     lpMode;

    // set this flag so that all functions called herein
    // know not to make any system calls
    global.b16BitCode = TRUE;

    DIBENGINEHDR1 *pDibeng = (DIBENGINEHDR1 *)pDXShare->pFlatDibeng;

    // set up pointer to DDHALINFO
    LPDDHALINFO pHalInfo = (LPDDHALINFO)pDXShare->pHalInfo;

    // Grab the mode list and add each mode.  This is largely just to fix
    // a bug in Motocross Madness where the mode list is gotten before
    // the 32bit DirectX driver initializes and builds a mode table. The
    // mode table returned here is a shotgun-return-all-the-modes in the
    // registry approach. Except for motocross madness (as far as we know),
    // all other DX apps won't grab the modes until after DriverInit
    // is called. DriverInit calls BuildDDHalModeTable which computes
    // the real mode list (should be very close to what we return here.)
#if 0
    LPMODEENTRYANDPITCH lpM = (LPMODEENTRYANDPITCH) pDXShare->lpMasterModeList;
    LPDDHALMODEINFO pMode = pDriverData->ModeList;
    for (i = 0; lpM[i].dwXRes != 0; i++) {
        AddModeToTable (pMode++, lpM[i].dwXRes, lpM[i].dwYRes, lpM[i].dwBpp); //, lpM[i].dwPitch);
    }

    SortDDHalModeList ();
#endif

    if (pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) { // Starting with NV10, we never close this channel
        if (pDriverData->NvDevVideoFlatPio != 0) {
            pDriverData->CloseNvDevVideoFlatPio = pDriverData->NvDevVideoFlatPio;
            pDriverData->NvDevVideoFlatPio = 0;
        }
    }

    DWORD dwRootIndex = 0;
    getAdapterIndex(pDXShare, &dwRootIndex);
    if ((dwRootIndex           == -1)                // if we are head 0
     || (pDXShare->deWidth     != GET_MODE_WIDTH())  // or if the mode has really changed
     || (pDXShare->deHeight    != GET_MODE_HEIGHT())
     || (pDXShare->deBitsPixel != GET_MODE_BPP()))
    {
        nvDisable32();
        pDXShare->deWidth     = GET_MODE_WIDTH();
        pDXShare->deHeight    = GET_MODE_HEIGHT();
        pDXShare->deBitsPixel = GET_MODE_BPP();
    }

    // Set a ptr to the table
    pHalInfo->lpModeInfo = (struct _DDHALMODEINFO *) (pDriverData->dwModeListSelector << 16);

    // Find the mode number
    pDXShare->dwModeNumber = -1;

    for (int i = 0; pDriverData->ModeList[i].dwWidth != 0; i++)
    {
        if ((pDriverData->ModeList[i].dwWidth  == pDibeng->deWidth)     &&
            (pDriverData->ModeList[i].dwHeight == pDibeng->deHeight)    &&
            (pDriverData->ModeList[i].dwBPP    == pDibeng->deBitsPixel) &&
            ((pDriverData->ModeList[i].lPitch * pDriverData->ModeList[i].dwHeight) <= pDriverData->TotalVRAM))
        {
#ifdef  STEREO_SUPPORT_
            if (STEREO_ENABLED)
            {
                __asm int 3
                DWORD dwWidth = pDriverData->ModeList[i].dwWidth;
                int RealIndex = i;
                for (i=i+1; pDriverData->ModeList[i].dwWidth == dwWidth; i++)
                {
                    if (pDriverData->ModeList[i].wRefreshRate == 0x1234)
                    {
                        //Our fake entry
                        pDriverData->ModeList[i] = pDriverData->ModeList[RealIndex];
                        break;
                    }
                }
            }
#endif  //STEREO_SUPPORT

            pDXShare->dwModeNumber = i;
            break;
        }
    }

    // Overlay information
    pHalInfo->ddCaps.dwMaxVisibleOverlays = 1;
    pHalInfo->ddCaps.dwCurrVisibleOverlays = 0;

    // FOURCC code information
    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
        pHalInfo->ddCaps.dwNumFourCCCodes = NV_MAX_FOURCC;
    }
    else {
        pHalInfo->ddCaps.dwNumFourCCCodes = NV_MAX_FOURCC_REGULAR;
    }

    // lpdwFourCC must be a 16:16 pointer. It is set at FirstTimeInit
    pHalInfo->lpdwFourCC = (unsigned long *) (pDriverData->dwFourCCSelector << 16);

    // current video mode
    pHalInfo->dwModeIndex = pDXShare->dwModeNumber;
    lpMode = &(pDriverData->ModeList[pHalInfo->dwModeIndex]);

    // current primary surface attributes
    pHalInfo->vmiData.fpPrimary = VIDMEM_ADDR(GET_PRIMARY_ADDR());

    // fill in the pixel format
    pHalInfo->vmiData.ddpfDisplay.dwSize  = sizeof (DDPIXELFORMAT);
    pHalInfo->vmiData.ddpfDisplay.dwFlags = DDPF_RGB;

    if  (pDXShare->dwModeNumber != -1)
    {
        pHalInfo->vmiData.ddpfDisplay.dwRGBBitCount     = lpMode->dwBPP;
        pHalInfo->vmiData.dwDisplayWidth                = lpMode->dwWidth;
        pHalInfo->vmiData.dwDisplayHeight               = lpMode->dwHeight;
        pHalInfo->vmiData.lDisplayPitch                 = lpMode->lPitch;
        pHalInfo->vmiData.ddpfDisplay.dwRGBAlphaBitMask = lpMode->dwAlphaBitMask;
        pHalInfo->vmiData.ddpfDisplay.dwRBitMask        = lpMode->dwRBitMask;
        pHalInfo->vmiData.ddpfDisplay.dwGBitMask        = lpMode->dwGBitMask;
        pHalInfo->vmiData.ddpfDisplay.dwBBitMask        = lpMode->dwBBitMask;

        if (lpMode->wFlags & DDMODEINFO_PALETTIZED) {
            pHalInfo->vmiData.ddpfDisplay.dwFlags |= DDPF_PALETTEINDEXED8;
        }
#ifdef SPOOF_ALPHA
        if (lpMode->dwAlphaBitMask) {
            pHalInfo->vmiData.ddpfDisplay.dwFlags |= DDPF_ALPHAPIXELS;
        }
#endif
    }

#ifdef NV_AGP
    // we are managing the heaps, don't ask MS for one
    pHalInfo->vmiData.dwNumHeaps = 0;
    if (pDriverData->dwBusType == NV_BUS_TYPE_AGP) {
        pHalInfo->ddCaps.dwCaps2 |=  DDCAPS2_NONLOCALVIDMEM;
    } else {
        pHalInfo->ddCaps.dwCaps2 &= ~DDCAPS2_NONLOCALVIDMEM;
    }
#else // !NV_AGP
    // Setup the AGP heap
    DWORD dwRoot;
    getAdapterIndex(pDXShare, &dwRoot);
    if ((pDriverData->dwBusType == NV_BUS_TYPE_AGP) &&
        (pDXShare->dwModeNumber != -1) &&
        (dwRoot == -1)) // this is the second or later device on a multi-head card (no AGP heap)
    {
        pHalInfo->vmiData.dwNumHeaps = 1;
        pHalInfo->ddCaps.dwCaps2 |= DDCAPS2_NONLOCALVIDMEM;
    }
    else
    {
        pHalInfo->vmiData.dwNumHeaps = 0;
        pHalInfo->ddCaps.dwCaps2 &= ~DDCAPS2_NONLOCALVIDMEM;
    }
#endif // !NV_AGP

    // pvmList must be a 16:16 pointer. It is set at FirstTimeInit.
    pHalInfo->vmiData.pvmList = (struct _VIDMEM *) (pDriverData->dwPvmListSelector << 16);

    if (pHalInfo->vmiData.dwNumHeaps == 1)
    {
        // Describe NONLOCALVIDMEM heap
        pDriverData->vidMem[0].dwFlags = VIDMEM_ISLINEAR   |
                                         VIDMEM_ISNONLOCAL |  // AGP memory
                                         VIDMEM_ISWC;         // do write combining

        // don't place in nonlocal video memory on first pass
        // prefer not to allocate anything but
        // optimized textures and YV12 overlays
        pDriverData->vidMem[0].ddsCaps.dwCaps = DDSCAPS_OVERLAY        |
                                                DDSCAPS_OFFSCREENPLAIN |
                                                DDSCAPS_FRONTBUFFER    |
                                                DDSCAPS_BACKBUFFER     |
                                                DDSCAPS_ZBUFFER;

        // don't place in nonlocal video memory on 2nd pass
        // Even if no other memory, don't allocate anything but
        // optimized textures and YV12 overlays
        pDriverData->vidMem[0].ddsCapsAlt.dwCaps = DDSCAPS_OVERLAY        |
                                                   DDSCAPS_OFFSCREENPLAIN |
                                                   DDSCAPS_FRONTBUFFER    |
                                                   DDSCAPS_BACKBUFFER     |
                                                   DDSCAPS_ZBUFFER;

        pDriverData->vidMem[0].fpStart = 0x00000000;
        if (pDriverData->regSuper7Compat == 2) {
            // Allocate 32-sizeof(pushbuffer)-sizeof(defaultVB) megabytes of address space
            pDriverData->vidMem[0].fpEnd = pDriverData->regMaxAGPLimit - getDC()->nvPusher.getSize();
        } else {
            pDriverData->vidMem[0].fpEnd = pDriverData->regMaxAGPLimit - pDriverData->regPersistAGPSize;
        }
    }

    // The color alphas
    switch (pDibeng->deBitsPixel) {
        case 8 : pDriverData->physicalColorMask = 0xFF;     break;
        case 16: pDriverData->physicalColorMask = 0xFFFF;   break;
        case 32: pDriverData->physicalColorMask = 0xFFFFFF; break;
        default: break;
    }

    // callback functions
    pHalInfo->lpDDCallbacks        = (DDHAL_DDCALLBACKS *)        (pDriverData->dwDDCallbacksSelector << 16);
    pHalInfo->lpDDSurfaceCallbacks = (DDHAL_DDSURFACECALLBACKS *) (pDriverData->dwDDSurfaceCallbacksSelector << 16);
    pHalInfo->lpDDPaletteCallbacks = (DDHAL_DDPALETTECALLBACKS *) (pDriverData->dwDDPaletteCallbacksSelector << 16);
    pHalInfo->lpDDExeBufCallbacks  = (DDHAL_DDEXEBUFCALLBACKS *)  (pDriverData->dwDDExecuteBufferCallbackSelector << 16);

    ///////////////////////////////////////////////////////////////////
    // The 16bit side (the caller) needs 4 pieces of info back:
    // 1) A flat ptr to the HALInfo structure - assigned in FirstTimeInit
    // 2) The length of the HALInfo structure
    // 3) The HINSTANCE of this driver (MS calls this an instance handle but all they want is a unique per head/card identifier)

    pDXShare->dwHALInfoSize    = (unsigned long) sizeof(DDHALINFO);
    pDXShare->hDirectXInstance = (unsigned long) pDXShare;
    ///////////////////////////////////////////////////////////////////

#ifdef  STEREO_SUPPORT
    StereoModeSetProcessing();
#endif  //STEREO_SUPPORT

    // clear the 16-bit flag
    global.b16BitCode = FALSE;

    return (TRUE);
}

#endif // !WINNT

//---------------------------------------------------------------------------

// allocate space for major driver structures
// returns TRUE on success, FALSE on failure
#ifndef WINNT
BOOL nvAllocDriverStructures (void)
{
    dbgTracePush ("nvAllocDriverStructures");

    // allocate memory for global (one per card) data structures
    // this memory is only released when the driver dll is unloaded

    // alloc pDriverData
    pDriverData = new CDriverContext;

    if (!pDriverData) {
        // out of memory
        DPF ("nvAllocDriverStructures: out of memory allocating CDriverContext");
        dbgTracePop();
        return (FALSE);
    }

    // initialise pDriverData
    getDC()->create();

    // alloc ModeList
    void *pModeList = AllocIPM(sizeof(DDHALMODEINFO) * MAX_MODEENTRYS);
    if (!pModeList)
    {
        // out of memory - prepare to die
        DPF ("nvAllocDriverStructures: out of memory allocating DDHALMODEINFO");
        // free pDriverData
        delete pDriverData;
        pDriverData = NULL;
        // free pModeList
        FreeIPM(pModeList);
        dbgTracePop();
        return (FALSE);
    }

    // store the pointers to our newly allocated memory
    pDXShare->pDirectXData = (DWORD)pDriverData;
    pDriverData->ModeList  = (DDHALMODEINFO*)pModeList;

    dbgTracePop();
    return (TRUE);
}
#endif // !WINNT
//---------------------------------------------------------------------------

// FirstTimeInit()
// perform one-time initialization required on first call to DriverInit()

DWORD __stdcall FirstTimeInit (void)
{
    dbgTracePush ("FirstTimeInit");

    // Initialize DX state based on info obtained from the display driver
#ifdef WINNT
    pDriverData->BaseAddress       = 0;   // offset of frame buffer
    pDriverData->dwDeviceIDNum     = ppdev->ulDeviceReference;
    pDriverData->dwRootHandle      = ppdev->hClient;
    pDriverData->dwDeviceHandle    = ppdev->hDevice;
    pDriverData->NvDeviceVersion   = (unsigned short) ppdev->dwDeviceVersion;
    pDriverData->dwSurfaceAlignPad = ppdev->ulSurfaceAlign;
    pDriverData->dwSurfaceAlign    = ppdev->ulSurfaceAlign + 1;
    pDriverData->dwSurfaceBitAlign = ppdev->ulSurfaceBitAlign;
    pDriverData->NvBaseFlat   = (DWORD) ppdev->NvBaseAddr;
    pDriverData->thisDeviceID = pDriverData->dwDeviceHandle;
#else // !WINNT
    pDriverData->BaseAddress       = pDXShare->dwScreenLinearBase;  // linear base address of frame buffer
    pDriverData->dwDeviceIDNum     = pDXShare->dwNVDeviceID;
    pDriverData->dwRootHandle      = pDXShare->dwRootHandle;
    pDriverData->dwDeviceHandle    = pDXShare->dwDeviceHandle;
    pDriverData->NvDeviceVersion   = (unsigned short) pDXShare->dwDeviceVersion;
    pDriverData->dwSurfaceAlignPad = NV_BYTE_ALIGNMENT_PAD;
    pDriverData->dwSurfaceAlign    = NV_BYTE_ALIGNMENT;
    pDriverData->dwSurfaceBitAlign = NV_BIT_ALIGNMENT;
    pDriverData->NvBaseFlat        = pDXShare->dwDeviceLinearBase;
    pDriverData->flatSelector      = (unsigned short) GetFlatCodeSel();
    pDriverData->thisDeviceID      = pDXShare->dwNVDeviceID;
    // Setup an initial default of 32MB - under Win2k we've already computed the limit
    pDriverData->regMaxAGPLimit = NV_MAX_AGP_MEMORY_LIMIT;

    DWORD dwRoot;
    if (getAdapterIndex (pDXShare, &dwRoot) == 0) {
        SetSharedFSDOSBoxPtr ((U032 *)(&(pDriverData->dwFullScreenDOSStatus)));
    }
#endif // !WINNT

    NvRmConfigGet (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_CFG_RAM_SIZE_MB, &(pDriverData->TotalVRAM));
    pDriverData->TotalVRAM       <<= 20;
    pDriverData->dwDeviceClass     = pDriverData->dwDeviceIDNum + (NV01_DEVICE_0 - 1);

#if (NVARCH < 0x010)
    if (pDriverData->NvDeviceVersion > NV_DEVICE_VERSION_5) {
        pDriverData->NvDeviceVersion = NV_DEVICE_VERSION_5;
    }
#endif // !NV10

    pDriverData->dwVersion = DDMINI_VERSION;

    NvRmConfigGet (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_CFG_BUS_TYPE, &(pDriverData->dwBusType));

#ifdef WINNT
    {
        // Ask miniport if AGP should be enabled.
        DWORD ulReturn = 0;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SHOULD_AGP_BE_ENABLED,
                               NULL, 0, NULL, 0, &ulReturn))
        {
            pDriverData->dwBusType = 1; // Force it to be PCI if miniport thinks otherwise.
        }
    }
#endif

    pDriverData->pCurrentChannelID = 0;

    // get the number of heads (DACs) on this device
    NvRmConfigGet (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_CFG_NUMBER_OF_HEADS, &pDriverData->dwHeads);

    if (pDriverData->thisDeviceID <= 1) {
        pDriverData->thisDeviceID = 0;
    }

    pDriverData->dwDrvRefCount = 0;

#ifndef TEXFORMAT_CRD
    DWORD dwNum = 0;

    // A few other random things that never change
    pDriverData->fourCC[dwNum++] = FOURCC_UYVY;
    pDriverData->fourCC[dwNum++] = FOURCC_UYNV;
    pDriverData->fourCC[dwNum++] = FOURCC_YUY2;
    pDriverData->fourCC[dwNum++] = FOURCC_YUNV;
    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10)
    pDriverData->fourCC[dwNum++] = FOURCC_NVDS;
    pDriverData->fourCC[dwNum++] = FOURCC_YV12;
    pDriverData->fourCC[dwNum++] = FOURCC_YVU9;
    pDriverData->fourCC[dwNum++] = FOURCC_IF09;
    pDriverData->fourCC[dwNum++] = FOURCC_IV32;
    pDriverData->fourCC[dwNum++] = FOURCC_IV31;
    pDriverData->fourCC[dwNum++] = FOURCC_RAW8;
    pDriverData->fourCC[dwNum++] = FOURCC_NVT0;
    pDriverData->fourCC[dwNum++] = FOURCC_NVT1;
    pDriverData->fourCC[dwNum++] = FOURCC_NVT2;
    pDriverData->fourCC[dwNum++] = FOURCC_NVT3;
    pDriverData->fourCC[dwNum++] = FOURCC_NVT4;
    pDriverData->fourCC[dwNum++] = FOURCC_NVT5;
    pDriverData->fourCC[dwNum++] = FOURCC_NVS0;
    pDriverData->fourCC[dwNum++] = FOURCC_NVS1;
    pDriverData->fourCC[dwNum++] = FOURCC_NVS2;
    pDriverData->fourCC[dwNum++] = FOURCC_NVS3;
    pDriverData->fourCC[dwNum++] = FOURCC_NVS4;
    pDriverData->fourCC[dwNum++] = FOURCC_NVS5;

#ifdef DXT_SUPPORT
    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
        pDriverData->fourCC[dwNum++] = FOURCC_DXT1;
        pDriverData->fourCC[dwNum++] = FOURCC_DXT2;
        pDriverData->fourCC[dwNum++] = FOURCC_DXT3;
        pDriverData->fourCC[dwNum++] = FOURCC_DXT4;
        pDriverData->fourCC[dwNum++] = FOURCC_DXT5;
    }
#endif
#if defined(HILO_SUPPORT_DX7) || defined(HILO_SUPPORT_DX8)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        pDriverData->fourCC[dwNum++] = FOURCC_NVHS;
        pDriverData->fourCC[dwNum++] = FOURCC_NVHU;
    }
#endif

#endif // !TEXFORMAT_CRD

    dbgTracePop();
    return  (TRUE);
}

//---------------------------------------------------------------------------
// ResetTwinViewState
//      Reset anything that has been destroyed by a change to the TwinView state
//

BOOL ResetTwinViewState (GLOBALDATA *pDriverData)
{
    dbgTracePush ("ResetTwinViewState");

    pDriverData->dwFullScreenDOSStatus &= ~FSDOSSTATUS_TWINVIEW_STATE_CHANGE;

#ifdef WINNT
    pDriverData->dwDesktopState = ppdev->TwinView_State;
#else

    // refresh the adapter table
    nvFillAdapterTable();

    // reinstantiate desktop state and reconnect DX in case TwinView state has changed
    NVTWINVIEWDATA twinViewData;
    DWORD dwOldDesktopState = pDriverData->dwDesktopState;
    memset(&twinViewData, 0, sizeof(twinViewData));
    twinViewData.dwFlag   = NVTWINVIEW_FLAG_GET;
    twinViewData.dwAction = NVTWINVIEW_ACTION_SETGET_STATE;
    MyExtEscape(pDXShare->dwHeadNumber, NV_ESC_SETGET_TWINVIEW_DATA, 0, NULL, sizeof(twinViewData), (char*)&twinViewData);
    nvAssert(twinViewData.dwSuccess);
    pDriverData->dwDesktopState = twinViewData.dwState;

    // reenable primary flip objects
    for (DWORD dwHead = 0; dwHead < pDriverData->dwHeads; dwHead ++) {
        NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_VIDEO_LUT_CURSOR_DAC + dwHead);
    }

    if (!nvCreateDACObjects (NV_DD_DEV_DMA, NV_DD_VIDEO_LUT_CURSOR_DAC)) {
        dbgTracePop();
        return (FALSE);
    }

    for (dwHead = 0; dwHead < pDriverData->dwHeads; dwHead ++) {
        // initialize LUT-cursor-DAC object
        nvPushData (0,dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
        nvPushData (1,NV_DD_VIDEO_LUT_CURSOR_DAC + dwHead);
        nvPushData (2,dDrawSubchannelOffset(NV_DD_SPARE) + NV067_SET_CONTEXT_DMA_NOTIFIES | 0x1C0000);
        nvPushData (3,NV_DD_DMA_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY + dwHead);
        nvPushData (4,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // image a
        nvPushData (5,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // image b
        nvPushData (6,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // LUT a
        nvPushData (7,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // LUT b
        nvPushData (8,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // cursor a
        nvPushData (9,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // cursor b
        nvPushData (10,dDrawSubchannelOffset(NV_DD_SPARE) + NV067_SET_DAC(0) | 0x40000);
        nvPushData (11,asmMergeCoords(GET_MODE_WIDTH(), GET_MODE_HEIGHT()));
        nvPusherAdjust (12);
    }

#endif

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

#ifndef WINNT

// The Dll is about to be loaded.  Do whatever you want ...

DWORD __stdcall AboutToBeLoaded (void)
{
    dbgTracePush ("AboutToBeLoaded");
    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

// The Dll is about to be unloaded.  Do whatever you want ...
// Unfortunately, we do not have a context ptr. Assume whatever
// was the last one although this could be wrong.

DWORD __stdcall AboutToBeUnloaded (void)
{
    dbgTracePush ("AboutToBeUnloaded");

    // clear the display driver's pointers to our global data structures
    for (int i = 0; i < MAX_ADAPTERS; i++) {

        pDriverData = (CDriverContext *)g_adapterData[i].pDriverData;
        pDXShare    = g_adapterData[i].pDXShare;

        // this memory will be released when the IPM heap is destroyed
        if (pDXShare) {
            pDXShare->pHalInfo       = NULL;
            pDXShare->pNvPrimarySurf = NULL;
        }

        if (pDriverData) {

            VppDisable(&pDriverData->vpp);   // Free objects...
            VppDestructor(&pDriverData->vpp);

#ifdef STEREO_SUPPORT
            DestroyStereo();
#endif // STEREO_SUPPORT

            // Destroy Item Arrays
            DestroyItemArrays();

            // Set this to NULL, so we won't try to call from the display driver
            // and GPF.
            pDXShare->pfnInterfaceFunc = (unsigned long) NULL;

            // Free the 16bit selectors we got from the display driver.
            FreeSelectorsFromDisplayDriver ();

            // Purge the heap of all DirectX allocations
            NVHEAP_PURGE ();

            // clear this entry in the table
            memset(&g_adapterData[i], 0, sizeof(NV_ADAPTER_TYPE));
        }
    }

    // destroy the heap
    DestroyIPM();

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

/*
    if nGet is TRUE then, selectors are allocated (unless they are
    already allocated.) if nGet = FALSE, they are freed (unless they
    are already freed.)
*/
DWORD __stdcall GetSelectorsFromDisplayDriver (void)
{
    DWORD dwEsc[2];

    dbgTracePush ("GetSelectorsFromDisplayDriver");

    if (!pDriverData->dwFourCCSelector) {

        // Allocate some selectors from the display driver. We need
        // these to fill in the HALInfo table correctly later.
        dwEsc[0] = (DWORD) &(pDriverData->fourCC[0]);
        dwEsc[1] = NV_MAX_FOURCC*4;
        if (!MyExtEscape(pDXShare->dwHeadNumber, GN_ESC_ALLOC_SELECTOR_AND_MAP, 8,
            (const char *) &(dwEsc[0]), 4, (char *) &pDriverData->dwFourCCSelector)) {
            dbgTracePop();
            return FALSE;
        }

        // Allocate some selectors from the display driver. We need
        // these to fill in the HALInfo table correctly later.
        dwEsc[0] = (DWORD) pDriverData->ModeList;
        dwEsc[1] = sizeof(DDHALMODEINFO) * MAX_MODEENTRYS;
        if (!MyExtEscape(pDXShare->dwHeadNumber, GN_ESC_ALLOC_SELECTOR_AND_MAP, 8,
            (const char *) &(dwEsc[0]), 4, (char *) &pDriverData->dwModeListSelector)) {
            dbgTracePop();
            return FALSE;
        }

        dwEsc[0] = (DWORD) &(pDriverData->vidMem);
        dwEsc[1] = sizeof(VIDMEM) * 2;
        if (!MyExtEscape(pDXShare->dwHeadNumber, GN_ESC_ALLOC_SELECTOR_AND_MAP, 8,
            (const char *) &(dwEsc[0]), 4, (char *) &pDriverData->dwPvmListSelector)) {
            dbgTracePop();
            return FALSE;
        }

        dwEsc[0] = (DWORD) &(pDriverData->DDCallbacks);
        dwEsc[1] = sizeof(pDriverData->DDCallbacks);
        if (!MyExtEscape(pDXShare->dwHeadNumber, GN_ESC_ALLOC_SELECTOR_AND_MAP, 8,
            (const char *) &(dwEsc[0]), 4, (char *) &pDriverData->dwDDCallbacksSelector)) {
            dbgTracePop();
            return FALSE;
        }

        dwEsc[0] = (DWORD) &(pDriverData->DDSurfaceCallbacks);
        dwEsc[1] = sizeof(pDriverData->DDSurfaceCallbacks);
        if (!MyExtEscape(pDXShare->dwHeadNumber, GN_ESC_ALLOC_SELECTOR_AND_MAP, 8,
            (const char *) &(dwEsc[0]), 4, (char *) &pDriverData->dwDDSurfaceCallbacksSelector)) {
            dbgTracePop();
            return FALSE;
        }

        dwEsc[0] = (DWORD) &(pDriverData->DDPaletteCallbacks);
        dwEsc[1] = sizeof(pDriverData->DDPaletteCallbacks);
        if (!MyExtEscape(pDXShare->dwHeadNumber, GN_ESC_ALLOC_SELECTOR_AND_MAP, 8,
            (const char *) &(dwEsc[0]), 4, (char *) &pDriverData->dwDDPaletteCallbacksSelector)) {
            dbgTracePop();
            return FALSE;
        }

        dwEsc[0] = (DWORD) &(pDriverData->DDExecuteBufferCallbacks);
        dwEsc[1] = sizeof(pDriverData->DDExecuteBufferCallbacks);
        if (!MyExtEscape(pDXShare->dwHeadNumber, GN_ESC_ALLOC_SELECTOR_AND_MAP, 8,
            (const char *) &(dwEsc[0]), 4, (char *) &pDriverData->dwDDExecuteBufferCallbackSelector)) {
            dbgTracePop();
            return FALSE;
        }
    }

    dbgTracePop();
    return(1);
}

DWORD __stdcall FreeSelectorsFromDisplayDriver (void)
{
    dbgTracePush ("FreeSelectorsFromDisplayDriver");

    if (pDriverData->dwFourCCSelector) {
        MyExtEscape(pDXShare->dwHeadNumber, GN_ESC_UNMAP_AND_FREE_SELECTOR, 4,
            (const char *) &pDriverData->dwFourCCSelector, 0, 0);
        pDriverData->dwFourCCSelector = 0;
    }

    if (pDriverData->dwModeListSelector) {
        MyExtEscape(pDXShare->dwHeadNumber, GN_ESC_UNMAP_AND_FREE_SELECTOR, 4,
            (const char *) &pDriverData->dwModeListSelector, 0, 0);
        pDriverData->dwModeListSelector = 0;
    }

    if (pDriverData->dwPvmListSelector) {
        MyExtEscape(pDXShare->dwHeadNumber, GN_ESC_UNMAP_AND_FREE_SELECTOR, 4,
            (const char *) &pDriverData->dwPvmListSelector, 0, 0);
        pDriverData->dwPvmListSelector = 0;
    }

    if (pDriverData->dwDDCallbacksSelector) {
        MyExtEscape(pDXShare->dwHeadNumber, GN_ESC_UNMAP_AND_FREE_SELECTOR, 4,
            (const char *) &pDriverData->dwDDCallbacksSelector, 0, 0);
        pDriverData->dwDDCallbacksSelector = 0;
    }

    if (pDriverData->dwDDSurfaceCallbacksSelector) {
        MyExtEscape(pDXShare->dwHeadNumber, GN_ESC_UNMAP_AND_FREE_SELECTOR, 4,
            (const char *) &pDriverData->dwDDSurfaceCallbacksSelector, 0, 0);
        pDriverData->dwDDSurfaceCallbacksSelector = 0;
    }

    if (pDriverData->dwDDPaletteCallbacksSelector) {
        MyExtEscape(pDXShare->dwHeadNumber, GN_ESC_UNMAP_AND_FREE_SELECTOR, 4,
            (const char *) &pDriverData->dwDDPaletteCallbacksSelector, 0, 0);
        pDriverData->dwDDPaletteCallbacksSelector = 0;
    }

    if (pDriverData->dwDDExecuteBufferCallbackSelector) {
        MyExtEscape(pDXShare->dwHeadNumber, GN_ESC_UNMAP_AND_FREE_SELECTOR, 4,
            (const char *) &pDriverData->dwDDExecuteBufferCallbackSelector, 0, 0);
        pDriverData->dwDDExecuteBufferCallbackSelector = 0;
    }

    dbgTracePop();
    return 1;
}

//---------------------------------------------------------------------------

/*
    DrvInterfaceFuncC (DWORD dwInterfaceID)

    This routine is called by the display driver directly from 16bit
    land. Do not call any system functions or you will hang. But you can
    set variables and just do normal C code.
*/

void __stdcall DrvInterfaceFuncC(DWORD dwInterfaceID, DWORD dwExtraData)
{
    global.b16BitCode = TRUE;

    // pDXShare has been set to the correct context data just before
    // DrvInterfaceFuncC is called, but pDriverData has not. Set it now.
    pDriverData = (CDriverContext *)pDXShare->pDirectXData;

    switch (dwInterfaceID)
    {
        case GDIDX_PRE_SETINFOINIT:
            buildDDHALInfo16 ();
            break;

        case GDIDX_PRE_MODESET_NOTIFY:
            nvModeSetPrepare16();
            break;

        case GDIDX_POST_MODESET_NOTIFY:
            nvModeSetCleanup16();
            break;

        case GDIDX_DIRECTX_OS_VERSION:
            // dwExtraData is the system DirectX runtime version.
            global.dwDXRuntimeVersion = dwExtraData;
            break;

        case GDIDX_DRIVER_UNLOADING:
        {
            DWORD dwRootIndex;
            int dwIndex = getAdapterIndex(pDXShare, &dwRootIndex);
            if (dwIndex != -1) {
                g_adapterData[dwIndex].pDXShare = NULL;
            }
            break;
        }

        case GDIDX_EARLY_DX_CONNECT:
            pDriverData->dwFullScreenDOSStatus |= FSDOSSTATUS_TWINVIEW_STATE_CHANGE;
            // if we were in video mirror mode, then context data is no longer valid
            pDriverData->vpp.dwOverlayFSTwinData.nvtwPhysicalModeImmediate.pHWCrtcCX = 0;
            pDriverData->vpp.dwOverlayFSTwinData.nvtwPhysicalModeImmediate.pGNLogdevCX = 0;
            pDriverData->vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.pHWCrtcCX = 0;
            pDriverData->vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.pGNLogdevCX = 0;
            break;
    }

    global.b16BitCode = FALSE;
    return;
}

//---------------------------------------------------------------------------

/*
    This call is used as a direct thunk from the 2D display driver to
    the 3D DirectX driver. The Win16 Mutex is not released. You can't
    make system calls from within this call.  However, there are certain
    important events that need to be sent over here as notifications,
    that are particularly important, so this interface was created.

    Arguments:  eax         flat 32 pDXShare
                ebx         purpose of call.
                            One of the GDIDX_XXX equates in dxshare.h
                ecx         Other context data which depends upon ebx.
*/

void __declspec(naked) __stdcall DrvInterfaceFunc(void)
{
    __asm
    {
    mov     pDXShare,eax
    push    ecx
    push    ebx
    call    DrvInterfaceFuncC
    retf
    }
}

/*
    This call is used as an interface back to the display driver
    from DirectX. However!! It should only be used to call back to
    the display driver, if we are in the DirectX driver because the
    display driver called it though the DrvInterfaceFunc function
    above. Basically you can only use this if you are running
    under the 16bit display driver context.

    Arguments:
    I set this function up to have parameters similar to the
    Display Driver escape call. There is a function select
    parameter which tells what the specific callback is. Then
    there is an lpIn ptr giving input parameters to the callback
    and an lpOut ptr to return things in.

    Returns:
    This routine returns TRUE if the dwFunction was recognized. The
    return values for specific functions are given in the structure
    pointed to by lpOut.
    This routine returns FALSE if the dwFunction was not recognized.

    The callbacks supported are given in drivers\common\win9x\inc\dxshare.h
*/
int DrvCallbackFunc(DWORD dwFunction, void *pIn, void *pOut)
{
    int     iRetVal;
    DWORD   dwCallSelector, dwCallOffset, pDispDriverHWLogDevCX;

    dwCallOffset          = pDXShare->dwDrvCallbackOffset;
    dwCallSelector        = pDXShare->dwDrvCallbackSelector;
    pDispDriverHWLogDevCX = pDXShare->pDispDriverHWLogDevCX;

    __asm
    {
        push    esi
        push    edi
        push    ebx

        // Flip the order of the parameters around since the
        // display driver uses PASCAL calling conventions.
        push    pDispDriverHWLogDevCX
        push    dwFunction
        push    pIn
        push    pOut

        ; push the return address
        mov     ax,cs
        and     eax,0FFFFH
        push    eax
        lea     eax,ComeBack
        push    eax

        ; Push the call address
        push    dwCallSelector
        push    dwCallOffset

        ; "Call" the 16bit side by doing a retf
        retf

ComeBack:
        mov iRetVal,eax

        ; The caller already popped the parameters
        ; Just pop the saved registers
        pop ebx
        pop edi
        pop esi
    }

    return  (iRetVal);
}

//---------------------------------------------------------------------------

/*
    GetModePitch ()

    This routine figurs out the pitch of a given mode. Since there might
    be tiling, the RM may have to get involved.
*/

DWORD __stdcall GetModePitch (int nXRes, int nYRes, int nBitsPerPixel)
{
    DWORD   dwPrimaryDisplayPitchInBytes, dwRoundValue;
    NV_CFGEX_GET_SURFACE_PITCH_PARAMS params;

    dbgTracePush ("GetModePitch");

    params.Width = nXRes;
    params.Depth = nBitsPerPixel;

    // Get the pitch from the RM for a given width/bpp
    if (NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE,
                        NV_CFGEX_GET_SURFACE_PITCH,
                        &params, sizeof(params)) == NVOS_CGE_STATUS_SUCCESS) {
        dbgTracePop();
        return params.Pitch;
    }

    //
    // Couldn't get the value from the RM, so we'll make a best effort
    // attempt at determining what the pitch likely should be.
    //
    dwPrimaryDisplayPitchInBytes = (nXRes * nBitsPerPixel) >> 3;
    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
        dwRoundValue = 0x3F;
    }
    else {
        dwRoundValue = 0x1F;
    }

    dwPrimaryDisplayPitchInBytes += dwRoundValue;
    dwPrimaryDisplayPitchInBytes &= (~dwRoundValue);

    dbgTracePop();
    return (dwPrimaryDisplayPitchInBytes);
}

//---------------------------------------------------------------------------

/*
    SortDDHalModeList ()

    This routine sorts the DDHalMode list so that modes are sorted
    first by color depth and then by XResolution. It returns the
    number of modes in the table.
*/
int __stdcall SortDDHalModeList ()
{
    DDHALMODEINFO   *p1, *p2, sTempMode;
    int             nSwap;

    dbgTracePush ("SortDDHalModeList");

    // OK, let's bubble sort the mode list
    for (p1 = pDriverData->ModeList; p1[1].dwWidth != 0; p1++)
    {
        for (p2 = p1 + 1; p2->dwWidth != 0; p2++)
        {
            // Assume correct order
            nSwap = 0;

            // Primary sort is on pixel depth
            if  (p1->dwBPP > p2->dwBPP)
                nSwap = 1;
            else
            {
                // Check if pixel depths equal
                if  (p1->dwBPP == p2->dwBPP)
                {
                    // pixel depths are equal -- sort on width
                    if  (p1->dwWidth > p2->dwWidth)
                        nSwap = 1;
                    else
                    {
                        // check if widths are equal
                        if  (p1->dwWidth == p2->dwWidth)
                        {
                            // widths equal -- sort on height
                            if  (p1->dwHeight > p2->dwHeight)
                                nSwap = 1;
                        }
                    }

                }
            }

            if  (nSwap)
            {
                sTempMode = *p1;
                *p1 = *p2;
                *p2 = sTempMode;
            }
        }
    }

    dbgTracePop();
    return ((p1 - pDriverData->ModeList) + 1);
}

//---------------------------------------------------------------------------

/*
    AddModeToTable ()

    This routine adds the mode to the mode table.
*/
void __stdcall AddModeToTable (DDHALMODEINFO *pMode, int nXRes, int nYRes, int nBitsPerPixel, int refresh)
{
    dbgTracePush ("AddModeToTable");

    // Add an entry to the ModeList
    // Special case to add a termination mode.
    if  (nXRes == 0)
    {
        pMode->dwWidth          = 0;
        pMode->dwHeight         = 0;
        pMode->lPitch           = 0;
        pMode->dwBPP            = 0;
        pMode->wRefreshRate     = 0;
        pMode->wFlags           = 0;
        pMode->dwRBitMask       = 0;
        pMode->dwGBitMask       = 0;
        pMode->dwBBitMask       = 0;
        pMode->dwAlphaBitMask   = 0;
        dbgTracePop();
        return;
    }

    pMode->dwWidth  = (DWORD) nXRes;
    pMode->dwHeight = (DWORD) nYRes;
    pMode->lPitch   = (LONG) GetModePitch(nXRes, nYRes, nBitsPerPixel);
    pMode->dwBPP    = (DWORD) nBitsPerPixel;
    pMode->wRefreshRate = refresh;

    if  (nBitsPerPixel == 8)
    {
        pMode->wFlags           = DDMODEINFO_PALETTIZED;
        pMode->dwRBitMask       = 0;
        pMode->dwGBitMask       = 0;
        pMode->dwBBitMask       = 0;
        pMode->dwAlphaBitMask   = 0;
    }

    if  (nBitsPerPixel == 16)
    {
        pMode->wFlags           = 0;
        pMode->dwRBitMask       = 0x0000F800;
        pMode->dwGBitMask       = 0x000007E0;
        pMode->dwBBitMask       = 0x0000001F;
        pMode->dwAlphaBitMask   = 0x00000000;
    }

    if  (nBitsPerPixel == 32)
    {
        pMode->wFlags           = 0;
        pMode->dwRBitMask       = 0x00FF0000;
        pMode->dwGBitMask       = 0x0000FF00;
        pMode->dwBBitMask       = 0x000000FF;
#ifdef SPOOF_ALPHA
        pMode->dwAlphaBitMask   = 0xFF000000;
#else
        pMode->dwAlphaBitMask   = 0x00000000;
#endif
    }

    dbgTracePop();
    return;
}

//---------------------------------------------------------------------------

/*
    BuildDefaultDDHalModeTable ()

    This routine builds a default table.
*/
void __stdcall BuildDefaultDDHalModeTable ()
{
    DDHALMODEINFO *pMode;

    dbgTracePush ("BuildDefaultDDHalModeTable");

    // Start out with a mode ptr
    pMode = pDriverData->ModeList;

    // These modes MUST be valid modes!
    AddModeToTable (pMode++, 640, 480, 8, 0);
    AddModeToTable (pMode++, 640, 480, 16, 0);
    AddModeToTable (pMode++, 640, 480, 32, 0);
    AddModeToTable (pMode++, 800, 600, 8, 0);
    AddModeToTable (pMode++, 800, 600, 16, 0);
    AddModeToTable (pMode++, 800, 600, 32, 0);
    AddModeToTable (pMode++, 1024, 768, 8, 0);
    AddModeToTable (pMode++, 1024, 768, 16, 0);
    AddModeToTable (pMode++, 1024, 768, 32, 0);

    // Sort the list
    SortDDHalModeList();

    // Record the number of modes in the table
    GET_HALINFO()->dwNumModes = pMode - pDriverData->ModeList;

    dbgTracePop();
    return;
}
#endif  // !WINNT

//---------------------------------------------------------------------------

/*
    BuildDDHalModeTable ()

    This routine calls the display driver to get the list of destop
    modes and also adds in a bunch of DDraw specific modes. It filters
    each mode based upon:
    1) The amount of free contiguous video memory starting from offset 0
       and the pitch of a mode determining the maximum number of bytes
       that can be consumed by the primary surface.
    2) The DAC speed (determining maximum pixel rate)
    3) The display type (NTSC, PAL, FLATPANEL 800,1024,1280, VGA MONITOR)
*/
void __stdcall BuildDDHalModeTable ()
{
#ifndef WINNT   // WINNT BUG Is there a SetMode callback under NT?
    DDHALMODEINFO   *pMode;
    MODEENTRY       sModeDesc[MAX_MODEENTRYS];
    int             i;
    DWORD           dwModeEntryType;
    BOOL            doRestrictTVModes;

    dbgTracePush ("BuildDDHalModeTable");

    // Call back to display driver to get the mode list from the registry
    // - zero out the mode list so that we have at least one record at the end
    //   of the list with dwXRes == 0. this allows the for loop that adds the
    //   basic mode table to terminate properly.
    memset (sModeDesc,0,sizeof(sModeDesc)); // zero out
    dwModeEntryType = MODETYPE_MODEENTRY;
    if  (!MyExtEscape(pDXShare->dwHeadNumber, NV_ESC_GET_REGISTRY_MODE_LIST, sizeof(DWORD), (LPCSTR)&dwModeEntryType,
                MAX_MODEENTRYS * sizeof(MODEENTRY), (char *) sModeDesc))
    {
        BuildDefaultDDHalModeTable ();
        dbgTracePop();
        return;
    }

    // Start off pointing to the ModeList
    pMode = pDriverData->ModeList;
    memset(pMode, 0, MAX_MODEENTRYS * sizeof(DDHALMODEINFO));

    // Make sure TwinView state is current
    ResetTwinViewState (pDriverData);

    // find out whether we need to restrict the modes to ones which will work on a TV
    doRestrictTVModes = FALSE;
    for (i = 0; i < (int)pDriverData->dwHeads; i++) {
        NVTWINVIEWDATA twinData = {0};
        DWORD          retVal;
        DWORD          dwCrtcNumber;
        DWORD          dwCompare;
        DWORD          dwHead;

        switch (pDriverData->dwDesktopState) {
        case NVTWINVIEW_STATE_DUALVIEW:
            dwCrtcNumber = 0;       // need to use logical head numbers in multimon mode
            dwHead = i;
            dwCompare = pDXShare->dwHeadNumber;
            break;
        case NVTWINVIEW_STATE_CLONE:
            dwCrtcNumber = i;
            dwHead = pDXShare->dwHeadNumber;
            dwCompare = i;
            break;
        default:
            // single mode
            dwCrtcNumber = 0;
            dwHead = pDXShare->dwHeadNumber;
            dwCompare = 0;
            break;
        }

        twinData.dwFlag   = NVTWINVIEW_FLAG_GET;
        twinData.dwAction = NVTWINVIEW_ACTION_SETGET_DEVICE_TYPE;
        twinData.dwCrtc   = dwCrtcNumber;

        retVal = MyExtEscape(dwHead, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPCSTR) &twinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &twinData);
        if (twinData.dwSuccess && retVal &&
           (twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceType == MONITOR_TYPE_NTSC ||
            twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceType == MONITOR_TYPE_PAL)) {
            if (i == (int)dwCompare) {
                doRestrictTVModes = TRUE;
            }
        }
    }

    // Now we need to take the basic mode list we got back from the
    // display driver, convert it, and stick those modes in the Ddraw
    // table.
    if (doRestrictTVModes) {
        DWORD dwEncoderType;
        BOOL allow720, allow800, allow1024, allow800orHigher;
        // determine on a case by case basis which modes are allowed
        NvRmConfigGet (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                       NV_CFG_VIDEO_ENCODER_TYPE, &dwEncoderType);

        switch (dwEncoderType) {
        case NV_ENCODER_BROOKTREE_868:
        case NV_ENCODER_BROOKTREE_869:
            allow720 = TRUE;
            allow800 = TRUE;
            allow1024 = FALSE;
            break;
            
        case NV_ENCODER_CHRONTEL_7007:
        case NV_ENCODER_CHRONTEL_7008:
            allow720 = TRUE;
            allow800 = TRUE;
            allow1024 = FALSE;
            break;

        case NV_ENCODER_CHRONTEL_7003:
        case NV_ENCODER_CHRONTEL_7004:
        case NV_ENCODER_CHRONTEL_7005:
        case NV_ENCODER_CHRONTEL_7006:
        case NV_ENCODER_PHILIPS_7102:
        case NV_ENCODER_PHILIPS_7103:
        case NV_ENCODER_PHILIPS_7108:
        case NV_ENCODER_PHILIPS_7109:
        case NV_ENCODER_PHILIPS_7108B:
            allow720 = FALSE;
            allow800 = TRUE;
            allow1024 = FALSE;
            break;

        case NV_ENCODER_BROOKTREE_871:
            allow720 = FALSE;
            allow800 = TRUE;
            allow1024 = TRUE;
            break;

        default:
            allow720 = FALSE;
            allow800 = TRUE;
            allow1024 = TRUE;
            break;
        }

        allow800orHigher = TRUE;    // Toshiba special request

        // no refresh rate enumeration for TV modes
        for (i = 0; sModeDesc[i].dwXRes != 0; i++) {
            if (sModeDesc[i].dwRefreshRate == 60 &&
               (sModeDesc[i].dwXRes == 320 ||
                sModeDesc[i].dwXRes == 640 ||
               (sModeDesc[i].dwXRes == 720 && allow720) ||
               (sModeDesc[i].dwXRes == 800 && allow800) ||
               (sModeDesc[i].dwXRes >= 800 && allow800orHigher) ||  // for Toshiba
               (sModeDesc[i].dwXRes == 1024 && allow1024) ||
               (sModeDesc[i].dwXRes >= 800 && pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE))) {
                AddModeToTable (pMode++, sModeDesc[i].dwXRes, sModeDesc[i].dwYRes, sModeDesc[i].dwBpp, 0);
            }
        }
    } else {
        DWORD dwLastXRes = 0, dwLastYRes = 0;
        if (pDriverData->regEnumDDRefresh == NV4_REG_ENUM_REFRESH_DISABLE) {
            for (i = 0; sModeDesc[i].dwXRes != 0; i++) {
                if (sModeDesc[i].dwXRes != dwLastXRes || sModeDesc[i].dwYRes != dwLastYRes) {
                    AddModeToTable (pMode++, sModeDesc[i].dwXRes, sModeDesc[i].dwYRes, sModeDesc[i].dwBpp, 0);
                    dwLastXRes = sModeDesc[i].dwXRes;
                    dwLastYRes = sModeDesc[i].dwYRes;
                }
            }
        } else if (pDriverData->regEnumDDRefresh == NV4_REG_ENUM_REFRESH_ENABLEBIG) {
            for (i = 0; sModeDesc[i].dwXRes != 0; i++) {
                if (sModeDesc[i].dwXRes >= 640 && sModeDesc[i].dwYRes >= 480) {
                    AddModeToTable (pMode++, sModeDesc[i].dwXRes, sModeDesc[i].dwYRes, sModeDesc[i].dwBpp, sModeDesc[i].dwRefreshRate);
                } else {
                    if (sModeDesc[i].dwXRes != dwLastXRes || sModeDesc[i].dwYRes != dwLastYRes) {
                        AddModeToTable (pMode++, sModeDesc[i].dwXRes, sModeDesc[i].dwYRes, sModeDesc[i].dwBpp, 0);
                        dwLastXRes = sModeDesc[i].dwXRes;
                        dwLastYRes = sModeDesc[i].dwYRes;
                    }
                }
            }
        } else if (pDriverData->regEnumDDRefresh == NV4_REG_ENUM_REFRESH_ENABLEALL) {
            for (i = 0; sModeDesc[i].dwXRes != 0; i++) {
                AddModeToTable (pMode++, sModeDesc[i].dwXRes, sModeDesc[i].dwYRes, sModeDesc[i].dwBpp, sModeDesc[i].dwRefreshRate);
            }
        }
    }

#ifdef  STEREO_SUPPORT_
    // For ASUS type of stereo connection we want to fool the DX and force it to reset a video mode
    // even if it matches the current desktop one. It has to be done because ASUS stereo requires
    // all stereo surfaces pairs (left/right eyes) to be adjasent in memory. And we don't want to waste
    // video memory when we're in 2D (aka desktop or GDI). Here is how we handle this. First we let
    // resman know that we enter "adjasent stereo surface allocation mode". Then we fool DX by building
    // a dummy mode entry that matches the current desktop. Basically for the current desktop mode we
    // will have 2 identical entries but the dummy one will be located behind the real one so DX will
    // never see it. By returning the dummy index in the dwModeIndex we will force DX to reset the video
    // mode. Bingo!!! Then resman will take care of the rest and create an adjacent stereo surface.
    if (STEREO_ENABLED)
    {
        DIBENGINEHDR1 *pDibeng = (DIBENGINEHDR1 *)pDXShare->pFlatDibeng;
        AddModeToTable (pMode++, pDibeng->deWidth, pDibeng->deHeight, pDibeng->deBitsPixel, 0x1234);
    }
#endif  //STEREO_SUPPORT

    // set up pointer to DDHALINFO
    LPDDHALINFO pHalInfo = (LPDDHALINFO)pDXShare->pHalInfo;

    // Setup the number of modes counter
    pHalInfo->dwNumModes = pMode - pDriverData->ModeList;

    // Sanity check
    if  (pHalInfo->dwNumModes == 0)
    {
        BuildDefaultDDHalModeTable ();
        dbgTracePop();
        return;
    }

    // Sort the mode list appropriately
    SortDDHalModeList ();

    dbgTracePop();
#endif // !WINNT
    return;
}

//---------------------------------------------------------------------------

#ifndef WINNT
int getRootIndex(DWORD dwAdapterIndex)
{
    dbgTracePush ("getRootIndex");

    nvAssert(dwAdapterIndex < MAX_ADAPTERS);

    DISPDRVDIRECTXCOMMON *pDXShare = g_adapterData[dwAdapterIndex].pDXShare;
    if (!pDXShare) {
        // not a valid index
        dbgTracePop();
        return -1;
    }

    DWORD dwRootHandle = pDXShare->dwRootHandle;

    for (DWORD i = 0; i < dwAdapterIndex; i++) {

        if (NULL == g_adapterData[i].pDXShare)
            continue;
        if (g_adapterData[i].pDXShare->dwRootHandle == dwRootHandle) {
            // found the root device for this adapter
            dbgTracePop();
            return i;
        }

    }

    dbgTracePop();
    return -1;
}

//---------------------------------------------------------------------------

DISPDRVDIRECTXCOMMON* getDXShare(DWORD dwRootHandle, DWORD dwHeadNumber)
{
   dbgTracePush ("getDXShareForHead");

   for (DWORD i = 0; i < MAX_ADAPTERS; i++) {

        DISPDRVDIRECTXCOMMON* pDXShare = g_adapterData[i].pDXShare;
        if (pDXShare
         && (pDXShare->dwRootHandle == dwRootHandle)
         && (pDXShare->dwHeadNumber == dwHeadNumber)) {
            // found the root device for this adapter
            dbgTracePop();
            return pDXShare;
        }

    }

    dbgTracePop();
    return NULL;
}

//---------------------------------------------------------------------------

int getAdapterIndex(DISPDRVDIRECTXCOMMON *pNewDXShare, DWORD *pdwRootIndex)
{
    dbgTracePush ("getAdapterIndex");

    nvAssert(pNewDXShare);

    for(DWORD i = 0; i < MAX_ADAPTERS; i++) {

        DISPDRVDIRECTXCOMMON *pDXShare = g_adapterData[i].pDXShare;

        if (pDXShare == pNewDXShare) {
            // found an entry, get the root index
            *pdwRootIndex = getRootIndex(i);
            dbgTracePop();
            return i;
        }

    }

    // the adapter table is full
    nvAssert(0);

    *pdwRootIndex = -1;
    dbgTracePop();
    return -1;
}
#endif

//---------------------------------------------------------------------------

/*
 * DriverInit
 *
 * this is the entry point called by DirectDraw to
 * initialize the 32-bit driver.
 *
 */
DWORD __stdcall DriverInit(DWORD dwDriverData)
{
    char regStr[256];
    HKEY  hKey;

    dbgResetTraceLevel ();
    dbgTracePush ("DriverInit");

#ifdef WINNT

    NvAcquireSemaphore((CDriverContext *) ((PDEV*)dwDriverData)->pDriverData);
    ppdev = (PDEV*)dwDriverData;
    pDriverData = (CDriverContext *)ppdev->pDriverData;
    DWORD dwAdapterIndex = ppdev->ulDeviceReference;

    BOOL bFirstTime = TRUE;

#else // !WINNT

    // The context data is always the PDevice
    pDXShare = (DISPDRVDIRECTXCOMMON *) dwDriverData;

    // get an hDC if we don't already have one
    if (!nvFillAdapterTable()) {
        // return if device is disabled
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return 0;
    }

    // add a new entry, or get an existing entry from the adapter table
    DWORD dwAdapterIndex, dwRootIndex;
    dwAdapterIndex = getAdapterIndex(pDXShare, &dwRootIndex);

    if (dwRootIndex == -1) {
        pDriverData = (CDriverContext *)g_adapterData[dwAdapterIndex].pDriverData;
    } else {
        // this is a secondary (or later) unit on a mult-unit card
        pDriverData = (CDriverContext *)g_adapterData[dwRootIndex].pDriverData;
    }

    // Give the HW-specific portion of the PDevice the flat selectors.
    pDXShare->dwFlatCodeSel = (unsigned long) GetFlatCodeSel();
    pDXShare->dwFlatDataSel = (unsigned long) GetFlatDataSel();
    pDXShare->pDirectXData  = (DWORD)pDriverData;

    if (!pDXShare->pHalInfo) {
        // allocate a DDHALINFO structure for this unit
        pDXShare->pHalInfo = (unsigned long)AllocIPM(sizeof(DDHALINFO));
        if (!pDXShare->pHalInfo) {
            // out of memory
            DPF("DriverInit: out of memory allocating DDHALINFO");
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return 0;
        }
    }

    BOOL bFirstTime = FALSE;

    // Allocate a DriverData structure if there isn't already one
    if (!pDriverData) {
        bFirstTime = TRUE;
        if (!nvAllocDriverStructures()) {
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return 0;
        }
    }

#endif // !WINNT

#ifdef NVSTATDRIVER
    AttachNVStat();
#endif

    if (bFirstTime)
    {
        if (!FirstTimeInit()) {
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return 0;
        }
        // add the pDriverData entry for this device to the global adapter table
        // always associate the pDriverData with the the first entry for this card
#ifdef WINNT
        g_adapterData[dwAdapterIndex].pDriverData = pDriverData;
#else
        if (dwRootIndex == -1) {
            g_adapterData[dwAdapterIndex].pDriverData = pDriverData;
        } else {
            g_adapterData[dwRootIndex].pDriverData = pDriverData;
        }
#endif
    }

    // Get the current registry settings from the hardware specific routine.
    D3DReadRegistry (pDriverData);

#ifdef TEXFORMAT_CRD
#ifndef WINNT
    // Attempt to get the RM derived AGP limit from the RM
    NvRmConfigGet (pDriverData->dwRootHandle,
                   NV_WIN_DEVICE,
                   NV_CFG_AGP_LIMIT,
                   &pDriverData->regMaxAGPLimit);

    // detect installed HW and determine how we are going to operate
    // Under WINNT, we need this info much earlier in the DX initialization
    // sequence (at DrvGetDirectDrawInfo time). So we have already called
    // nvDeterminePerformanceStrategy from the GDI driver at DrvEnablePDEV time.
    nvDeterminePerformanceStrategy (pDriverData);
#endif // !WINNT
#endif // TEXFORMAT_CRD

    // start capture stuff
#ifdef CAPTURE
    if (bFirstTime) {
        captureStartup (getDC()->nvD3DRegistryData.regszCaptureRecordPath,
                        getDC()->nvD3DRegistryData.regszCaptureRecordFilename,
                        getDC()->nvD3DRegistryData.regCaptureRecordFilenum);
        capturePlayStartup (getDC()->nvD3DRegistryData.regszCapturePlayPath,
                            getDC()->nvD3DRegistryData.regszCapturePlayFilename,
                            getDC()->nvD3DRegistryData.regCapturePlayFilenum);
    }
    else {
        captureSetParams (getDC()->nvD3DRegistryData.regszCaptureRecordPath,
                          getDC()->nvD3DRegistryData.regszCaptureRecordFilename,
                          getDC()->nvD3DRegistryData.regCaptureRecordFilenum);
        capturePlaySetParams (getDC()->nvD3DRegistryData.regszCapturePlayPath,
                              getDC()->nvD3DRegistryData.regszCapturePlayFilename,
                              getDC()->nvD3DRegistryData.regCapturePlayFilenum);
    }
#endif  // CAPTURE

    if (bFirstTime)
    {
#ifdef TEXFORMAT_CRD
        if (!nvEnumerateFourCCs()) {
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return 0;
        }
        if (!nvEnumerateSurfaceFormats()) {
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return 0;
        }
#endif  // TEXFORMAT_CRD
    }

#ifdef WINNT
    //***************************************************************
    // Shared variable for active channel id is stored in NT display
    // driver state.
    //***************************************************************
    pDriverData->pCurrentChannelID = (ULONG) &(ppdev->oglLastChannel);
#else // !WINNT

    // Have to get the DC first before we can isue this call. Hence,
    // I can't do it in FirstTimeInit.
    MyExtEscape(pDXShare->dwHeadNumber, NV_ESC_GETACTIVECHANNELPTR, 0, 0, 4, (char *) &(pDriverData->pCurrentChannelID));
    // Allocate 16 bit selectors we will need and assign them if it hasn't
    // already been done (the routine protects itself from doing twice.)
    if (!GetSelectorsFromDisplayDriver()) {
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return 0;
    }

    // Do this every time we come into DriverInit -- just in case
    // KillHelp is run. DllMain will clear out the ptr when the DirectX
    // driver is punted out of memory. Here we need to re-establish it.
    pDXShare->pfnInterfaceFunc = (unsigned long) DrvInterfaceFunc;

    {
        DCICMD sMyDciCmd;

        // Adding new escape to display driver to tell them that a DX
        // app is being started.
        sMyDciCmd.dwVersion = DD_VERSION;
        sMyDciCmd.dwCommand = DDNVCREATEDRIVEROBJECT;
        MyExtEscape(pDXShare->dwHeadNumber, DCICOMMAND, sizeof(DCICMD), (const char *)&sMyDciCmd, 0, 0);
    }
#endif // !WINNT

    // set up pointer to DDHALINFO
    LPDDHALINFO pHalInfo = GET_HALINFO();

    // if this is the second driverinit for the second head, kick out
    if (pDriverData->dwDrvRefCount++ > 0) {

        buildDDHALInfo32(pDriverData);
        nvSetHardwareCaps();

#ifdef WINNT
        pHalInfo->lpD3DGlobalDriverData = (LPVOID)&(getDC()->D3DGlobalDriverData);
        D3DHALCreateDriver((LPD3DHAL_GLOBALDRIVERDATA) pHalInfo->lpD3DGlobalDriverData,
                           (LPD3DHAL_CALLBACKS*)&pHalInfo->lpD3DHALCallbacks,
                           (LPDDHAL_DDEXEBUFCALLBACKS *)&pHalInfo->lpD3DBufCallbacks,
                           pDriverData);
#else
        pHalInfo->lpD3DGlobalDriverData = (ULONG_PTR)&(getDC()->D3DGlobalDriverData);
        //they just HAD to rename the structure members didn't they....
        D3DHALCreateDriver((LPD3DHAL_GLOBALDRIVERDATA) pHalInfo->lpD3DGlobalDriverData,
                           (LPD3DHAL_CALLBACKS*)&pHalInfo->lpD3DHALCallbacks,
                           (LPDDHAL_DDEXEBUFCALLBACKS *)&pHalInfo->lpDDExeBufCallbacks,
                           pDriverData);
#endif // !WINNT

        BuildDDHalModeTable ();
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DWORD)dwDriverData;

    }

#ifndef WINNT
    // grab north bridge ID
    DWORD nbID;
    _asm {
            mov edx, 0cf8h
            mov eax, 80000000h
            out dx,eax
            mov edx, 0cfch
            in  eax, dx
            mov nbID, eax
    }
    pDriverData->northBridgeID = nbID;
#else
    pDriverData->northBridgeID = 0;
#endif

    pDriverData->dwCurrentBlit   = 0;
    CURRENT_FLIP   = 0;
    COMPLETED_FLIP = 0;

    getDC()->dwAAContextCount = 0;
    pDriverData->dwRingZeroMutex = FALSE;

    pDriverData->blitCalled = FALSE;

#ifndef WINNT
    pDriverData->HALCallbacks.lpSetInfo = 0;
#endif // !WINNT

#ifndef TEXFORMAT_CRD  // moved up
#ifndef WINNT
    // Attempt to get the RM derived AGP limit from the RM
    NvRmConfigGet (pDriverData->dwRootHandle,
                   NV_WIN_DEVICE,
                   NV_CFG_AGP_LIMIT,
                   &pDriverData->regMaxAGPLimit);

    // detect installed HW and determine how we are going to operate
    // this effects the following test for pushbuffer size
    // Under WINNT, we need this info much earlier in the DX initialization
    // sequence (at DrvGetDirectDrawInfo time). So we have already
    // called nvDeterminePerformanceStrategy from the GDI driver
    // at DrvEnablePDEV time.
    nvDeterminePerformanceStrategy(pDriverData);
#endif // !WINNT
#endif // !TEXFORMAT_CRD

    // Construct the VPP object (must be after nvDeterminePerformanceStrategy)
    //   There must be NO references to vpp data prior to this point
    //
#ifdef WINNT
    if (!VppConstructor(ppdev, &(pDriverData->vpp), &pDriverData->nvD3DPerfData))
#else
    if (!VppConstructor(pDriverData, &(pDriverData->vpp), &pDriverData->nvD3DPerfData))
#endif
    {
        VppDestructor(&(pDriverData->vpp)); // Release anything we might have allocated thus far
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return 0;
    }
#if IS_WINNT5
    VppReadRegistry(&pDriverData->vpp, ppdev->hDriver, ppdev->ulDeviceDisplay[0]);
#else
    VppReadRegistry(&pDriverData->vpp, 0             , pDXShare->dwHeadNumber);
#endif

    // Reset in case of a mode switch which unloaded the driver
    pHalInfo->ddCaps.dwCurrVisibleOverlays = 0;

    // Reset motion comp control
    pDriverData->dwMCNVMCSurface = 0;
    pDriverData->dwMCNVDSSurfaceBase = 0;
    pDriverData->bMCOverlaySrcIsSingleField1080i = FALSE;
    pDriverData->bMCHorizontallyDownscale1080i = FALSE;

    pDriverData->dwVideoPortsAvailable = 1;

    bltInit();

    pDriverData->DDrawVideoSurfaceCount = 0;

    #ifdef NVPE
    // set VPE initial state
    NVPInitialState(pDriverData);
    #else
    pDriverData->nvpeState.bVPEInitialized = 0;
    pDriverData->nvpeState.bFsMirrorEnabled = 0;
    #endif

    // Can't reinitialize NV here because mode change may not have happened yet.

    // Append DirectDraw subkey to the global registry base path without using C runtime lib
    nvStrCpy(regStr, NV4_REG_GLOBAL_BASE_PATH "\\" NV4_REG_DIRECT_DRAW_SUBKEY);

    // Controls how much persistent AGP is reserved (i.e. not included in DDraw's heap)
    // We keep at least 8MB and no more than 1/8th the total amount of AGP memory
    pDriverData->regPersistAGPSize = max (((pDriverData->regMaxAGPLimit + 1) >> 3), 0x800000);

    // Let any registry entries override our values; lookup happens under the Global\DirectDraw key
    if (RegOpenKeyEx(NV4_REG_GLOBAL_BASE_KEY, regStr, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS) {
        DWORD   dwSize = sizeof(long);
        DWORD   dwType = REG_DWORD;
        long    lValue;

        if (RegQueryValueEx(hKey, PERSISTENT_AGP_SIZE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS) {
            pDriverData->regPersistAGPSize = lValue;
        }
        if (RegQueryValueEx(hKey, NV_MAX_AGP_SIZE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS) {
            pDriverData->regMaxAGPLimit = lValue - 1;   // appears we can setup 128M and alloc at least 80M

        }
        RegCloseKey(hKey);
    }

    pDriverData->dwTVTunerFlipCount = 0;
    pDriverData->dwTVTunerTimer = 0;
    pDriverData->regEnumDDRefresh = 0;
    pDriverData->regTVTunerHack = NV4_REG_VBMM_NOHACK;

    //VPE enable stuff
#ifndef NVPE
    pDriverData->bEnableVPE = 1;
#endif // NVPE

    // Append System subkey to the global registry base path without using C runtime lib
    nvStrCpy(regStr, NV4_REG_GLOBAL_BASE_PATH "\\" NV4_REG_RESOURCE_MANAGER_SUBKEY);

#ifndef WINNT
    // controls whether dma push buffer should be forced into PCI memory
    // 1 = force DMA push buffer to be created in PCI memory
    // 2 = same as '1', but also reduce AGP heap size by an amount equal to the size of the push buffer
    if (IS_VIA_MVP3_NB_ID(pDriverData->northBridgeID)) {
        // default case for the VIA 598 is to put push buffer in system memory
        pDriverData->regSuper7Compat = 1;
    } else {
        pDriverData->regSuper7Compat = 0;
    }
#else
    pDriverData->regSuper7Compat = 0;
#endif

    if (RegOpenKeyEx(NV4_REG_GLOBAL_BASE_KEY, regStr, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
    {
        hKey = 0;
    }
    if (hKey) {
        DWORD   dwSize = sizeof(long);
        DWORD   dwType = REG_DWORD;
        long    lValue;

        if (RegQueryValueEx(hKey, NV_REG_SYS_SUPER7_COMPATIBILITY, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS) {
            pDriverData->regSuper7Compat = lValue;
        }
        RegCloseKey(hKey);
    }

#ifndef WINNT
    // Grab the local registry path and append the System subkey to the string
    // without using the C runtime library.
    MyExtEscape (pDXShare->dwHeadNumber, NV_ESC_GET_LOCAL_REGISTRY_PATH, 0, NULL, 256, regStr);
    nvStrCat (&(regStr[4]), "\\" NV4_REG_RESOURCE_MANAGER_SUBKEY);
#endif // !WINNT

    // Controls the push buffer location
    if (pDriverData->regSuper7Compat) {
        pDriverData->regPBLocale = NV_REG_SYS_PB_LOCATION_SYSTEM;
    } else {
        pDriverData->regPBLocale = NV_REG_SYS_PB_LOCATION_DEFAULT;
    }
    if (RegOpenKeyEx((HKEY)(*((LPDWORD)&regStr[0])), &regStr[4], 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS) {
        DWORD   dwSize = sizeof(long);
        DWORD   dwType = REG_DWORD;
        long    lValue;

        if (RegQueryValueEx(hKey, NV_REG_SYS_PB_LOCATION, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS) {
            pDriverData->regPBLocale = lValue;
        }
        RegCloseKey(hKey);
    }

// Used for texture profiling (counting the # of texture DL's)
#ifdef CNT_TEX
    for (int iFrmCnt = 0; iFrmCnt<MAX_FRAME_CNT; iFrmCnt++) {
        g_dwVidTexDL[iFrmCnt] = 0;
        g_dwAgpTexDL[iFrmCnt] = 0;
    }
    g_dwFrames = 0;
#endif

    // the desktopstate value needs to be processed before calling buildddhalinfo32
#ifdef WINNT
    pDriverData->dwDesktopState = ppdev->TwinView_State;
#else
    NVTWINVIEWDATA twinViewData;
    memset(&twinViewData, 0, sizeof(twinViewData));
    twinViewData.dwFlag   = NVTWINVIEW_FLAG_GET;
    twinViewData.dwAction = NVTWINVIEW_ACTION_SETGET_STATE;
    MyExtEscape(pDXShare->dwHeadNumber, NV_ESC_SETGET_TWINVIEW_DATA, 0, NULL, sizeof(twinViewData), (char*)&twinViewData);
    nvAssert(twinViewData.dwSuccess);
    pDriverData->dwDesktopState = twinViewData.dwState;
#endif

    buildDDHALInfo32(pDriverData);
    BuildDDHalModeTable();
    nvSetHardwareCaps();

#ifdef WINNT
    pHalInfo->lpD3DGlobalDriverData = (LPVOID)&(getDC()->D3DGlobalDriverData);
    D3DHALCreateDriver((LPD3DHAL_GLOBALDRIVERDATA) pHalInfo->lpD3DGlobalDriverData,
                       (LPD3DHAL_CALLBACKS*)&pHalInfo->lpD3DHALCallbacks,
                       (LPDDHAL_DDEXEBUFCALLBACKS *)&pHalInfo->lpD3DBufCallbacks,
                       pDriverData);
#else
    pHalInfo->lpD3DGlobalDriverData = (ULONG_PTR)&(getDC()->D3DGlobalDriverData);
    //they just HAD to rename the structure members didn't they....
    D3DHALCreateDriver((LPD3DHAL_GLOBALDRIVERDATA) pHalInfo->lpD3DGlobalDriverData,
                       (LPD3DHAL_CALLBACKS*)&pHalInfo->lpD3DHALCallbacks,
                       (LPDDHAL_DDEXEBUFCALLBACKS *)&pHalInfo->lpDDExeBufCallbacks,
                       pDriverData);
#endif // !WINNT

    // process manager initialization
    pDriverData->lpProcessInfoHead = 0;

#ifdef ENABLE_VPP_DISPATCH_CODE
#ifndef WINNT
    vppInitDispatcher(&(pDriverData->vpp));
#endif // !WINNT
#endif


#ifdef KPFS
#if (NVARCH >= 0x20)
    pDriverData->nvKelvinPM.create(128);
#endif
#endif


#ifndef WINNT   // Win9x Hackery
#ifndef NVPE
    // this call is for VPE/KMVT stuff, to hook up with and initialize their storage
    if ( !HookUpVxdStorage() ) {
        // couldn't get VXD... what do we do?
        // return zero indicating that we can't do it!
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return 0;
    }
#endif // !NVPE
#endif // !WINNT

    pDriverData->bRing0FlippingFlag = FALSE;

    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (DWORD)dwDriverData;
} // DriverInit


//---------------------------------------------------------------------------

/*
 * Here's where we redirect all DDHAL32_VidMemAlloc/DDHAL32_VidMemFree calls to the RM.
 * We also keep a AGP_TABLE that keeps a mapping of allocations to dynamically created
 * memory handles.
 *
 */
#ifndef WINNT
#undef DDHAL32_VidMemAlloc
#undef DDHAL32_VidMemFree
FLATPTR EXTERN_DDAPI DDHAL32_VidMemAlloc (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, DWORD dwXDim, DWORD dwYDim);
void    EXTERN_DDAPI DDHAL32_VidMemFree  (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, FLATPTR ptr);
#endif

typedef struct _AGP_TABLE
{
    FLATPTR             addr;
    FLATPTR             physaddr;
    DWORD               offset;
    DWORD               limit;
    DWORD               handle;
    struct _AGP_TABLE   *next;
} AGP_TABLE;

static AGP_TABLE *lpAGPTable = NULL;
static AGP_TABLE *lastOffset = NULL;

#ifndef WINNT

U032 __stdcall SetSharedFSDOSBoxPtr (U032 *pData)
{
    HANDLE  dwVXDHandle;
    U032    dwError;
    U032    outputSize = 0;

    dbgTracePush ("SetSharedFSDOSBoxPtr");

    if (pDriverData->thisDeviceID > 1) {
        // There is never a DOS box on the secondary device
        dbgTracePop();
        return (FALSE);
    }

    dwVXDHandle = NvCreateFile(NVX_PRIMARY_MINIVDD, 0,0,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);

    if ((dwVXDHandle == NULL) || (dwVXDHandle == INVALID_HANDLE_VALUE)) {
        DPF("\r\nCan't get Vxd handle   :-(");
        dwError = GetLastError();
        DPF("The error was %d (0x%x)", dwError, dwError);
        if (dwError == 50) {
            DPF("Which means most likely that you don't have a version of NVMINI.VXD which supports IOCTL");
        }
        dbgTracePop();
        return (FALSE);
    }

    DeviceIoControl(dwVXDHandle,
                    0x20000700,
                    pData,
                    4,
                    NULL,
                    0,
                    &outputSize,
                    NULL);

    NvCloseHandle(dwVXDHandle);

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

BOOL WINAPI DllMain(HINSTANCE hModule, DWORD dwReason, LPVOID lpvReserved)
{
    static DWORD dwAttachCount = 0;

    dbgTracePush ("DllMain");

    switch ( dwReason ) {

        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls( hModule );
#ifdef  NVD3D
            if (dwAttachCount == 0) {
                init_globals();
            }
#endif  // NVD3D
            dwAttachCount++;
            InitIPM();
            AboutToBeLoaded();
            break;

        case DLL_PROCESS_DETACH:
            dwAttachCount--;
#ifdef  NVD3D
            if (dwAttachCount == 0) {
                SetSharedFSDOSBoxPtr (NULL);
                AboutToBeUnloaded();
            }
#endif  // NVD3D
            break;

        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        default:
            break;
    }

    dbgTracePop();
    return (TRUE);

} // DllMain

//---------------------------------------------------------------------------

// these old entry points never were defined on NT and never will be

/*
 * D3D DX5 Draw Primitive entry points
 */
DWORD __stdcall DrawOnePrimitive32 (LPD3DHAL_DRAWONEPRIMITIVEDATA pdopd)
{
    dbgTracePush ("DrawOnePrimitive32");

    nvAssert (global.dwDXRuntimeVersion < 0x0700);

    // get the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pdopd);

    nvSetDriverDataPtrFromContext (pContext);

    nvSetD3DSurfaceState (pContext);

    if (global.dwDXRuntimeVersion < 0x700) {
        nvPusherSignalWaitForFlip (pContext->pRenderTarget->getfpVidMem(), DDSCAPS_PRIMARYSURFACE);
    }

    DWORD dwRV = nvDrawOnePrimitive(pdopd);

    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return(dwRV);
}

//---------------------------------------------------------------------------

DWORD __stdcall DrawOneIndexedPrimitive32 (LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA pdoipd)
{
    dbgTracePush ("DrawOneIndexedPrimitive32");

    nvAssert (global.dwDXRuntimeVersion < 0x0700);

    // get the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pdoipd);

    nvSetDriverDataPtrFromContext (pContext);

    nvSetD3DSurfaceState (pContext);

    if (global.dwDXRuntimeVersion < 0x700) {
        nvPusherSignalWaitForFlip (pContext->pRenderTarget->getfpVidMem(), DDSCAPS_PRIMARYSURFACE);
    }

    DWORD dwRV = nvDrawOneIndexedPrimitive(pdoipd);

    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return(dwRV);
}

//---------------------------------------------------------------------------

DWORD __stdcall DrawPrimitives32 (LPD3DHAL_DRAWPRIMITIVESDATA pdpd)
{
    dbgTracePush ("DrawPrimitives32");

    nvAssert (global.dwDXRuntimeVersion < 0x0700);

    // get the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pdpd);

    nvSetDriverDataPtrFromContext (pContext);

    nvSetD3DSurfaceState (pContext);

    if (global.dwDXRuntimeVersion < 0x700) {
        nvPusherSignalWaitForFlip (pContext->pRenderTarget->getfpVidMem(), DDSCAPS_PRIMARYSURFACE);
    }

    DWORD dwRV = nvDrawPrimitives(pdpd);

    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return(dwRV);
}

#endif // !WINNT

//---------------------------------------------------------------------------

// prepare for an impending mode switch under win9x.
// note this is 16-bit code. system calls and stuff are disallowed!

DWORD __stdcall nvModeSetPrepare16 (void)
{
#ifdef TEX_MANAGE
    nvTexManageEvictAll (NULL);
#endif
    return (DD_OK);
}

//---------------------------------------------------------------------------

// cleanup subsequent to a mode switch under win9x.
// note this is 16-bit code. system calls and stuff are disallowed!

DWORD __stdcall nvModeSetCleanup16 (void)
{
    // empty for now.
    return (DD_OK);
}

//---------------------------------------------------------------------------

#ifdef WINNT

//
// Win2K D3DHALCreateDriver entry point
//
BOOL __stdcall NvWin2KD3DHALCreateDriver(DD_HALINFO* pHalInfo, PDEV* ppdev)
{
    GLOBALDATA* pDriverData = ppdev->pDriverData;
    pHalInfo->lpD3DGlobalDriverData = (void*)&(getDC()->D3DGlobalDriverData);
    return D3DHALCreateDriver((LPD3DHAL_GLOBALDRIVERDATA)pHalInfo->lpD3DGlobalDriverData,
                              (LPD3DHAL_CALLBACKS *)&pHalInfo->lpD3DHALCallbacks,
                              (PDD_D3DBUFCALLBACKS *)&pHalInfo->lpD3DBufCallbacks,
                              pDriverData);
}

//---------------------------------------------------------------------------

BOOL __stdcall NvWin2KAllocDriverData(PDEV* ppdev)
{
    nvAssert(ppdev);

    CDriverContext *pDriverContext = (CDriverContext*)g_adapterData[ppdev->ulDeviceReference].pDriverData;

    if (pDriverContext) {

        // return the pDriverData we already have
        ppdev->pDriverData = pDriverContext;

        return FALSE;
    }

    // set up local context
    //   this context has the same scope as pDriverData but it only defined for nvdd32.dll
    //   we also make certain it is aligned to a 32 byte boundary (rm gives us page aligned)
    //   rm requires size to be a page-size multiple

    // new operator is used to init it properly
    pDriverContext = new CDriverContext;

    if (!pDriverContext)
    {
        nvAssert(FALSE);
        return TRUE;
    }

    pDriverContext->create();

    //
    // Associate the DX GLOBALDATA with the GDI PDEV.
    //
    ppdev->pDriverData = pDriverContext;

    return FALSE;
}

//---------------------------------------------------------------------------

//
// Win2K routine to initialize all DX related global data structures.
//
void __stdcall NvWin2KInitDXGlobals()
{
    init_globals();
    InitIPM();
    return;
}

//---------------------------------------------------------------------------

DWORD __stdcall NvWin2KGetAgpLimit(PDEV *ppdev, DWORD dwRootHandle, DWORD dwDevID)
{
    DWORD dwAgpLimit, dwValue;

    if (!nvReadRegistryDWORD(ppdev, "MAXAGPHEAPSIZE", &dwValue))
    {
#ifdef NV_AGP
        dwValue = 128; // default heap size is 128MB
#else // !NV_AGP
        dwValue = 32; // default heap size is 32MB
#endif // !NV_AGP
    }

#ifndef NV_AGP
    // the heap size may not be more than 1/8 of the system memory size (win2k kernel issue)
    dwValue = min(ppdev->pDriverData->nvD3DPerfData.dwSystemMemory / 8, dwValue);
#else    
    // fix for any system that sets an AGP aperature TOO large
    {
        DWORD dwMem = ppdev->pDriverData->nvD3DPerfData.dwSystemMemory / 2;
        dwValue = min(dwValue, dwMem);
    }
#endif // !NV_AGP

    // convert to MB
    ppdev->pDriverData->regMaxAGPLimit = dwValue * 1024 * 1024 - 1;

#ifdef NV_AGP
    // the heap size may not be more than the aperture size
    NvRmConfigGet(dwRootHandle, dwDevID, NV_CFG_AGP_LIMIT, &dwAgpLimit);

    // GDI may be using an AGP push buffer so adjust for it
    if (ppdev->AgpPushBuffer)
        dwAgpLimit -= ppdev->DmaPushBufTotalSize;

    ppdev->pDriverData->regMaxAGPLimit = min(dwAgpLimit, ppdev->pDriverData->regMaxAGPLimit);

#else // !NV_AGP

    // the heap size may not be more than half the aperture size
    NvRmConfigGet(dwRootHandle, dwDevID, NV_CFG_AGP_LIMIT, &dwAgpLimit);

    // GDI AGP push buffer adjustment is done in NvWin2KpvmConfig for !NV_AGP case

    ppdev->pDriverData->regMaxAGPLimit = min(((dwAgpLimit + 1) / 2) - 1, ppdev->pDriverData->regMaxAGPLimit);

    if (ppdev->AgpHeap) {
        DWORD dwLimit = ppdev->AgpHeap->fpEnd - ppdev->AgpHeap->fpStart;
        if (ppdev->pDriverData->regMaxAGPLimit > dwLimit) {
            ppdev->pDriverData->regMaxAGPLimit = dwLimit;
            DPF("AGP Heap size adjusted to %d MB", (dwLimit + 1) / 1024 / 1024);
        }
    }
#endif // !NV_AGP

    return TRUE;
}

//---------------------------------------------------------------------------

#ifdef NV_AGP

//
// Win2K routine to fill in the pvmList data structure
//
void __stdcall NvWin2KpvmConfig(PDEV *ppdev, VIDEOMEMORY *pvmList)
{
    memset(pvmList, 0, sizeof(VIDEOMEMORY));
}

#else // !NV_AGP

//
// Win2K routine to fill in the pvmList data structure
//
void __stdcall NvWin2KpvmConfig(PDEV *ppdev, VIDEOMEMORY *pvmList)
{
    // Tell ddraw that this heap is not to be used for any
    // type of surface.
    pvmList->dwFlags = VIDMEM_ISLINEAR | VIDMEM_ISNONLOCAL | VIDMEM_ISWC;
    pvmList->fpStart = 0;
    pvmList->fpEnd   = pvmList->fpStart + ppdev->pDriverData->regMaxAGPLimit;

    // If GDI pushbuf is in AGP mem, need to adjust the AGP heap
    // size request.
    if (ppdev->AgpPushBuffer && (ppdev->DmaPushBufTotalSize <= pvmList->fpEnd))
        pvmList->fpEnd -= ppdev->DmaPushBufTotalSize;

    // Only use AGP mem for offscreenplain, or textures if first
    // pass allocation failed.
    pvmList->ddsCaps.dwCaps    = ~(DDSCAPS_OFFSCREENPLAIN | DDSCAPS_TEXTURE | DDSCAPS_NONLOCALVIDMEM);
    pvmList->ddsCapsAlt.dwCaps = ~(DDSCAPS_OFFSCREENPLAIN | DDSCAPS_TEXTURE | DDSCAPS_NONLOCALVIDMEM);
}

//
// Win2K routine to map the AGP heap into kernel mode address space.
//
DWORD __stdcall NvWin2KMapAgpHeap(PDEV *ppdev)
{
    NV_SYSMEM_SHARE_MEMORY      AgpHeapIn, AgpHeapOut;
    DWORD                       dwReturnedDataLength;

    AgpHeapIn.byteLength = ppdev->pDriverData->regMaxAGPLimit + 1;
    AgpHeapIn.physicalAddress = (ULONG) ppdev->pDriverData->GARTPhysicalBase;
    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_MAP_PHYS_ADDR,
                           &AgpHeapIn,  sizeof(NV_SYSMEM_SHARE_MEMORY),
                           &AgpHeapOut, sizeof(NV_SYSMEM_SHARE_MEMORY),
                           &dwReturnedDataLength))
    {
        // could not map AGP heap
        nvAssert(0);
        return FALSE;
    }

    ppdev->pDriverData->GARTLinearBase = (ULONG) AgpHeapOut.ddVirtualAddress;

    return TRUE;
}

//---------------------------------------------------------------------------

//
// Win2K routine to unmap the kernel mode address of the AGP heap.
//
DWORD __stdcall NvWin2KUnmapAgpHeap(PDEV *ppdev)
{
    NV_SYSMEM_SHARE_MEMORY      AgpHeapIn;
    DWORD                       dwReturnedDataLength;

    AgpHeapIn.byteLength = ppdev->pDriverData->regMaxAGPLimit + 1;
    AgpHeapIn.ddVirtualAddress = (PVOID) ppdev->pDriverData->GARTLinearBase;
    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_UNMAP_PHYS_ADDR,
                           &AgpHeapIn, sizeof(NV_SYSMEM_SHARE_MEMORY),
                           &AgpHeapIn, sizeof(NV_SYSMEM_SHARE_MEMORY),
                           &dwReturnedDataLength))
    {
        // could not unmap AGP heap
        nvAssert(0);
        return FALSE;
    }

    // Indicate that there is no longer an active AGP heap.
    ppdev->pDriverData->GARTLinearBase = 0;
    return TRUE;
}

//---------------------------------------------------------------------------

FLATPTR NvWin2kDxAllocMem(GLOBALDATA *pDriverData, ULONG ulHeapId, ULONG ulSize)
{
    FLATPTR fpOffset;

    if (ulHeapId == AGP_HEAP)
    {
        fpOffset = HeapVidMemAllocAligned(ppdev->AgpHeap, ulSize, 1,
            &(ppdev->AgpHeapAlignment), &(ppdev->AgpDummyPitch));
        if (fpOffset) {
            fpOffset -= pDriverData->GARTLinearHeapOffset;
        }
        else {
            // AGP memory allocation request failed
            fpOffset = ERR_DXALLOC_FAILED;
        }
    }
    else {
        nvAssert(0);
        fpOffset = ERR_DXALLOC_FAILED;
    }
    return(fpOffset);
}

//---------------------------------------------------------------------------

void NvWin2kDxFreeMem(GLOBALDATA *pDriverData, ULONG ulHeapId, FLATPTR fpOffset)
{
    if ((ulHeapId == AGP_HEAP) && pDriverData->GARTLinearBase)
    {
        fpOffset += pDriverData->GARTLinearHeapOffset;
        VidMemFree(ppdev->AgpHeap->lpHeap,
            fpOffset);
    }
}
#endif // !NV_AGP
#endif // WINNT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\Global.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: Global.cpp                                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History: ?                                                                *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

#include "x86.h"
void ILCCompile_move (DWORD,DWORD,DWORD);

//#pragma data_seg("GLOBAL")
#pragma pack(push,1) // we control alignment

global_struc global={{0}};
DWORD dwDXRuntimeVersion; // version of DirectX runtime installed (inferred from GUIDs)

#pragma pack(pop)

void __stdcall init_globals (void) {

    memset (&g_adapterData, 0, sizeof(g_adapterData));
    memset (&global,        0, sizeof(global));

    // init aligned KNI state
    global.pKNI             = (KATMAI_STATE*)((((DWORD)&global.kni) + 15) & ~15);
    global.pKNI->fFogC1[0]  = global.pKNI->fFogC1[1]
                            = global.pKNI->fFogC1[2]
                            = global.pKNI->fFogC1[3]
                            = 2.0f;
    global.pKNI->fFogC2[0]  = global.pKNI->fFogC2[1]
                            = global.pKNI->fFogC2[2]
                            = global.pKNI->fFogC2[3]
                            = -1.44269504f * (float)0x800000;
    global.pKNI->fZero[0]   = global.pKNI->fZero[1]
                            = global.pKNI->fZero[2]
                            = global.pKNI->fZero[3]
                            = 0.0f;
    global.pKNI->fOne[0]    = global.pKNI->fOne[1]
                            = global.pKNI->fOne[2]
                            = global.pKNI->fOne[3]
                            = 1.0f;
    global.pKNI->f255[0]    = global.pKNI->f255[1]
                            = global.pKNI->f255[2]
                            = global.pKNI->f255[3]
                            = 255.0f;
    global.pKNI->fRHW[3]    = 1.0f;

    global.fCTC1      = 0.5f;

    global.dwILCData  = NULL;
    global.dwILCCount = 0;
    global.dwILCMax   = 0;

#if (NVARCH >= 0x010)
    global.celsius.qwBegin3 = ((unsigned __int64)NV056_SET_BEGIN_END3_OP_TRIANGLES << 32)
                            | (((sizeSetNv10CelsiusBeginEnd3MthdCnt << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_SET_BEGIN_END3);
    global.celsius.qwEnd3   = ((unsigned __int64)NV056_SET_BEGIN_END3_OP_END << 32)
                            | (((sizeSetNv10CelsiusBeginEnd3MthdCnt << 2) << 16) | ((NV_DD_CELSIUS) << 13) | NV056_SET_BEGIN_END3);
#endif  // NVARCH >= 0x010
#if (NVARCH >= 0x020)
    global.kelvin.qwBegin = ((unsigned __int64)NV097_SET_BEGIN_END_OP_TRIANGLES << 32)
                            | (((sizeSetNv20KelvinBeginEndMthdCnt << 2) << 16) | ((NV_DD_KELVIN) << 13) | NV097_SET_BEGIN_END);
    global.kelvin.qwEnd   = ((unsigned __int64)NV097_SET_BEGIN_END_OP_END << 32)
                            | (((sizeSetNv20KelvinBeginEndMthdCnt << 2) << 16) | ((NV_DD_KELVIN) << 13) | NV097_SET_BEGIN_END);
#endif  // NVARCH >= 0x010

    global.pKNI->dwTriDispatch[0] = ((((3) << 2) << 16) | ((NV_DD_CELSIUS) << 13) | (NVPUSHER_NOINC(NV056_ARRAY_ELEMENT32(0))));

#if (NVARCH >= 0x020)
    global.pKNI->dwKelvinTriDispatch[0] = ((((3) << 2) << 16) | ((NV_DD_KELVIN) << 13) | (NVPUSHER_NOINC(NV097_ARRAY_ELEMENT32)));
#endif
    // init delay loop until we get calibrate it properlty
    global.dwDelayCount = 400;

    global.b16BitCode = FALSE;

#ifndef WINNT
    // get and cache pointer to the device enumeration function
    // we used to do this on demand, but calls to LoadLibrary were sporadically hanging. lovely.
    HMODULE hModule = LoadLibrary("user32");
#ifdef UNICODE
    global.pfEnumDisplayDevices = (BOOL (WINAPI*)(LPCSTR, DWORD, PDISPLAY_DEVICE, DWORD)) GetProcAddress(hModule, "EnumDisplayDevicesW");
#else
    global.pfEnumDisplayDevices = (BOOL (WINAPI*)(LPCSTR, DWORD, PDISPLAY_DEVICE, DWORD)) GetProcAddress(hModule, "EnumDisplayDevicesA");
#endif // !UNICODE

    hModule = LoadLibrary("kernel32.dll");
    global.pfOpenVxDHandle = (HANDLE (WINAPI *)(HANDLE))GetProcAddress(hModule, "OpenVxDHandle");
#endif // !WINNT

#ifdef WINNT
    // force runtime version to be at least 7.00 for Win2K
    //check for existence of DX8:
    {
        HANDLE temp;
        CHAR name[9] = "D3D8.DLL";
        WCHAR uniname[9];
        ULONG outStrLen;

        //grr.... convert to Unicode.
        EngMultiByteToUnicodeN((LPWSTR)uniname, 9*sizeof(WCHAR), &outStrLen,
                       (char *)name, (9)*sizeof(CHAR));


        temp = EngLoadModule( uniname );
        if (temp)
        {
            EngFreeModule(temp);
            global.dwDXRuntimeVersion = 0x0800;
        }
        else
        {
            global.dwDXRuntimeVersion = 0x0700;
        }
    }
#else // WINNT
    // force runtime version to be at least 3.00 for Win9x
    global.dwDXRuntimeVersion = 0x0300;
#endif // !WINNT
}

//////////////////////////////////////////////////////////////////////////////
// registry (encrypted as a post-build step)
// keep this in sync with the defintion of reg_struc in global.h!

reg_struc reg =
{
    // signature
    {
        0x0badbeef,0x0badcafe,0xdeadbeef,0x420352ec,
        0x420352ec,0xdeadbeef,0x0badcafe,0x0badbeef,
    },
    // size
    sizeof(reg_struc) - 4 * (8 + 1),
    // to be encrypted registry key strings.
    // booleans
    D3D_REG_ANTIALIASENABLE_STRING,
    D3D_REG_ANTIALIASFORCEENABLE_STRING,
    D3D_REG_ANTIALIASDYNAMICENABLE_STRING,
    D3D_REG_ANTIALIASCONVOLUTIONFASTMODE_STRING,
    D3D_REG_CKCOMPATABILITYENABLE_STRING,
    D3D_REG_DIRECTMAPENABLE_STRING,
    D3D_REG_ENFORCESTRICTTRILINEAR_STRING,
    D3D_REG_FLUSHAFTERBLITENABLE_STRING,
    D3D_REG_FOGTABLEENABLE_STRING,
    D3D_REG_FORCEBLITWAITFLAGENABLE_STRING,
    D3D_REG_LIMITQUEUEDFBBLITSENABLE_STRING,
    D3D_REG_LOGOENABLE_STRING,
#ifndef TEXFORMAT_CRD
    D3D_REG_PALETTEENABLE_STRING,
#endif  // !TEXFORMAT_CRD
    D3D_REG_SQUASHW_STRING,
    D3D_REG_SSYNCENABLE_STRING,
#ifndef TEXFORMAT_CRD
    D3D_REG_TEXTURECOMPRESSIONENABLE_STRING,
#endif  // !TEXFORMAT_CRD
    D3D_REG_TEXTUREMANAGEMENTENABLE_STRING,
    D3D_REG_TILINGENABLE_STRING,
    D3D_REG_ZCULLENABLE_STRING,
    D3D_REG_USERMIPMAPENABLE_STRING,
    D3D_REG_VIDEOTEXTUREENABLE_STRING,
    D3D_REG_VS_HOS_EMULATION_STRING,
    D3D_REG_WBUFFERENABLE_STRING,
    D3D_REG_Z24ENABLE_STRING,
    D3D_REG_ZCOMPRESSENABLE_STRING,
    0xdeadbeef,
    // non-boolean enumerated types
    D3D_REG_ANTIALIASQUALITY_STRING,
    D3D_REG_ANTIALIASDYNAMICFPS_STRING,
    D3D_REG_CAPTURECONFIG_STRING,
    D3D_REG_CAPTUREENABLE_STRING,
    D3D_REG_CKREF_STRING,
    D3D_REG_ANISOTROPICLEVEL_STRING,
    D3D_REG_MIPMAPDITHERMODE_STRING,
#ifdef TEXFORMAT_CRD
    D3D_REG_SURFACEFORMATSDX7_STRING,
    D3D_REG_SURFACEFORMATSDX8_STRING,
#endif  // TEXFORMAT_CRD
    D3D_REG_TEXELALIGNMENT_STRING,
    D3D_REG_TEXTUREMANAGESTRATEGY_STRING,
    D3D_REG_VALIDATEZMETHOD_STRING,
    D3D_REG_VSYNCMODE_STRING,
    D3D_REG_WFORMAT16_STRING,
    D3D_REG_WFORMAT32_STRING,
    0xdeadbeef,
    // non-boolean non-enumerated types
    D3D_REG_AACOMPATIBILITYBITS_STRING,
    D3D_REG_AAREADCOMPATIBILITYFILE_STRING,
    D3D_REG_AGPTEXCUTOFF_STRING,
    D3D_REG_CAPTUREPLAYFILENUM_STRING,
    D3D_REG_CAPTURERECORDFILENUM_STRING,
    D3D_REG_D3DCONTEXTMAX_STRING,
    D3D_REG_D3DTEXTUREMAX_STRING,
    D3D_REG_DEBUGLEVEL_STRING,
    D3D_REG_LODBIAS_STRING,
    D3D_REG_MINVIDTEXSIZE_STRING,
    D3D_REG_PCITEXHEAPSIZE_STRING,
    D3D_REG_PERFSTRATEGYOR_STRING,
    D3D_REG_PERFSTRATEGYAND_STRING,
    D3D_REG_PRERENDERLIMIT_STRING,
    D3D_REG_PUSHBUFFERSIZEMAX_STRING,
    D3D_REG_WSCALE16_STRING,
    D3D_REG_WSCALE24_STRING,
    D3D_REG_ZBIAS_STRING,
    0xdeadbeef,
    // strings
    D3D_REG_CAPTUREPLAYFILENAME_STRING,
    D3D_REG_CAPTUREPLAYPATH_STRING,
    D3D_REG_CAPTURERECORDFILENAME_STRING,
    D3D_REG_CAPTURERECORDPATH_STRING,
    0xdeadbeef
};

void decryptRegistryKeys
(
    void
)
{
    if (reg.dwSize == ~0) // encrypted?
    {
        DWORD i;
        BYTE  *p = ((BYTE*)&reg.dwSize) + 4; // 1st entry
        for (i = 0; i < sizeof(reg_struc) - 4 * (8 + 1); i++,p++)
        {
            *p ^= 0x42 ^ (BYTE)i;
        }

        reg.dwSize = 0; // tag as decrypted
    }
#ifdef DEBUG
//    else
//    {
//        if (reg.dwSize)
//        {
            /*
             * not encrypted - warn
             */
//            DPF ("Registry not encrypted!!!!!");
///        }
//    }
#endif
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\MoCompEx.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*==========================================================================;
 *
 *  Copyright (C) 2000 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       MoCompEx.cpp
 *  Content:    Windows98 DirectDraw 32 bit driver
 *
 ***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

#include "dxshare.h"

extern NVMOCOMPPARAMS           nvMoCompParams;

#ifndef WINNT
    extern DISPDRVDIRECTXCOMMON    *pDXShare;
#endif // WINNT

extern DWORD __stdcall nvInitCelsiusForMoComp(void);
extern DWORD __stdcall nvInitCelsiusForMoCompPrediction(void);
extern DWORD __stdcall nvInitCelsiusForMoCompCorrection();
extern void __stdcall nvDoCelsiusBidirectionalDVDFieldPrediction(BOOL);
extern void __stdcall nvDoTwoCelsiusBidirectionalDVDFieldPredictions(BOOL);
extern void __stdcall nvDoCelsiusForwardDVDFieldPrediction(BOOL);
extern void __stdcall nvDoTwoCelsiusForwardDVDFieldPredictions(BOOL);
extern void __stdcall nvDoCelsiusBackwardDVDFieldPrediction(BOOL);
extern void __stdcall nvDoTwoCelsiusBackwardDVDFieldPredictions(BOOL);
extern void __stdcall nvDoCelsiusBidirectionalHDFieldPrediction(BOOL);
extern void __stdcall nvDoCelsiusForwardHDFieldPrediction(BOOL);
extern void __stdcall nvDoCelsiusBackwardHDFieldPrediction(BOOL);
extern void __stdcall nvDoAllCelsiusIntraDVDFieldCorrections(long correctionYIncr, long numBlocks);
extern void __stdcall nvDoAllCelsiusDVDFieldCorrections(long correctionYIncr, long numBlocks);
extern void __stdcall nvDoCelsiusIntraDVDFieldCorrection(void);
extern void __stdcall nvDoOptimizedCelsiusIntraDVDFieldCorrection(void);
extern void __stdcall nvDoCelsiusDVDFieldCorrection(void);
extern void __stdcall nvDoAllCelsiusIntraHDFieldCorrections(long correctionYIncr, long numBlocks);
extern void __stdcall nvDoAllCelsiusHDFieldCorrections(long correctionYIncr, long numBlocks);
extern void __stdcall nvDoCelsiusIntraHDFieldCorrection(void);
extern void __stdcall nvDoOptimizedCelsiusIntraHDFieldCorrection(void);
extern void __stdcall nvDoCelsiusHDFieldCorrection(void);
extern void __stdcall nvDoAllCelsiusIntraFrameCorrections(void);
extern void __stdcall nvDoAllCelsiusFrameCorrections(void);
extern void __stdcall nvDoCelsiusIntraFrameCorrection(void);
extern void __stdcall nvDoCelsiusFrameCorrection(void);
extern DWORD __stdcall nvPredictCelsiusFrameLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks);
extern DWORD __stdcall nvPredictCelsiusFieldLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks);
extern DWORD __stdcall nvPredictCelsiusFrameChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks);
extern DWORD __stdcall nvPredictCelsiusFieldChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks);
extern void __stdcall nvCorrectCelsiusIntraFrame(LPNVDECODEMACROBLOCK pMacroblock, long macroblockCount);
extern void __stdcall nvCorrectCelsiusFrameLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType);
extern void __stdcall nvCorrectCelsiusFullFrameLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType);
extern void __stdcall nvCorrectCelsiusFrameChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType);
extern void __stdcall nvCorrectCelsiusFullFrameChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType);
extern void __stdcall nvCorrectCelsiusIntraField(LPNVDECODEMACROBLOCK pMacroblock, long macroblockCount);
extern void __stdcall nvCorrectCelsiusFieldMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType);

extern PNVMCPREDFUNC nvDoBidirectionalFieldPrediction;
extern PNVMCPREDFUNC nvDoTwoBidirectionalFieldPredictions;
extern PNVMCPREDFUNC nvDoForwardFieldPrediction;
extern PNVMCPREDFUNC nvDoTwoForwardFieldPredictions;
extern PNVMCPREDFUNC nvDoBackwardFieldPrediction;
extern PNVMCPREDFUNC nvDoTwoBackwardFieldPredictions;

extern PNVMCPREDFUNC2 nvPredictFrameLumaMacroblock;
extern PNVMCPREDFUNC2 nvPredictFieldLumaMacroblock;
extern PNVMCPREDFUNC2 nvPredictFrameChromaMacroblock;
extern PNVMCPREDFUNC2 nvPredictFieldChromaMacroblock;

extern PNVMCCORRFUNC2 nvDoAllIntraFieldCorrections;
extern PNVMCCORRFUNC2 nvDoAllFieldCorrections;
extern PNVMCCORRFUNC nvDoAllIntraFrameCorrections;
extern PNVMCCORRFUNC nvDoAllFrameCorrections;
extern PNVMCCORRFUNC nvDoIntraFieldCorrection;
extern PNVMCCORRFUNC nvDoOptimizedIntraFieldCorrection;
extern PNVMCCORRFUNC nvDoFieldCorrection;
extern PNVMCCORRFUNC nvDoIntraFrameCorrection;
extern PNVMCCORRFUNC nvDoFrameCorrection;



/*
 * nvMoCompCheckFieldPredictionEqual
 *
 * Tests whether the field predictions are equal on 2 macroblocks.
 *
 *
 * Note that pDriverData must be set before calling this function
 *
 */
BOOL __fastcall nvMoCompCheckFieldPredictionEqual(LPNVDECODEMACROBLOCK pMacroblock0,
                                                  LPNVDECODEMACROBLOCK pMacroblock1, BYTE macroblockType)
{
    if (macroblockType & MB_MOTION_FORWARD) {
        if ((pMacroblock0->fieldSelect[0][0] != pMacroblock1->fieldSelect[0][0]) ||
            (pMacroblock0->fieldSelect[1][0] != pMacroblock1->fieldSelect[1][0]) ||
            (*(long *)&pMacroblock0->PMV[0][0][0] != *(long *)&pMacroblock1->PMV[0][0][0]) ||
            (*(long *)&pMacroblock0->PMV[1][0][0] != *(long *)&pMacroblock1->PMV[1][0][0]))
            return FALSE;
    }
    if (macroblockType & MB_MOTION_BACKWARD) {
        if ((pMacroblock0->fieldSelect[0][1] != pMacroblock1->fieldSelect[0][1]) ||
            (pMacroblock0->fieldSelect[1][1] != pMacroblock1->fieldSelect[1][1]) ||
            (*(long *)&pMacroblock0->PMV[0][1][0] != *(long *)&pMacroblock1->PMV[0][1][0]) ||
            (*(long *)&pMacroblock0->PMV[1][1][0] != *(long *)&pMacroblock1->PMV[1][1][0]))
            return FALSE;
    }
    return TRUE;

} /* nvMoCompCheckFieldPredictionEqual */


/*
 * nvMoCompProcessCelsiusFrameMacroblocks
 *
 * Parses the current macroblock command stream and performs the necessary operations on
 * each macroblock.
 *
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvMoCompProcessCelsiusFrameMacroblocks(LPNVDECODEMACROBLOCK pMacroblocks,
                                                       DWORD numMacroblocks, BYTE formatConversionStatus)
{
    LPDDRAWI_DDRAWSURFACE_LCL   dstx = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   dst = dstx->lpGbl;
    LPNVDECODEMACROBLOCK        pMacroblock;
    LPNVDECODEMACROBLOCK        pLastMacroblock;
    LPNVDECODEMACROBLOCK        pMacroblock1;
    unsigned long               dwFirstAlignedIDCTOffset;
    unsigned long               dwSurfaceOffset;
    unsigned long               surfacePitch;
    unsigned long               moCompCorrectionICW;
    unsigned long               moCompNonPrebiasedCorrectionICW;
    long                        macroblockLimit;
    long                        n,i;
    long                        macroblockIndex;
    BYTE                        surfaceDecodeStatus = 0;
    BYTE                        numCombinedMacroblocks[256];
    short                       maxHeight = (short)dst->wHeight - 16;
    short                       maxWidth = (short)dst->wWidth - 16;
    BOOL                        hasFieldPredictions = FALSE;
    int                         index;
    int                         firstAlignedIDCTIndex;

    nvMoCompParams.vertexMode = 0; // Initialize vertexMode to an invalid value
    nvMoCompParams.surfaceLumaPitch = dst->lPitch;
    nvMoCompParams.surfaceLumaHeight = (dst->wHeight + 1) & ~1;
    nvMoCompParams.surfaceOffset = VIDMEM_OFFSET(dst->fpVidMem);
    nvMoCompParams.surfaceChromaOffset = nvMoCompParams.surfaceLumaPitch * nvMoCompParams.surfaceLumaHeight;
    nvMoCompParams.surfaceBiasedIntraBlockOffset =
        (dst->lPitch * dst->wHeight) + (dst->lPitch * (dst->wHeight >> 1) + (8 * dst->lPitch));
    if (pDriverData->bMCHorizontallyDownscale1080i) {
        nvMoCompParams.celsiusDestinationViewportXOffset = SCALED_CELSIUS_DESTINATION_VIEWPORT_XOFFSET;
        if (nvMoCompParams.surfaceLumaPitch > 1280)
            nvMoCompParams.celsiusFieldXOffset = 10240; // (1920 / 0.75) << 2, MUST CHANGE IF IN TILED MEMORY
        else
            nvMoCompParams.celsiusFieldXOffset = 6827; // (1280 / 0.75) << 2; MUST CHANGE IF IN TILED MEMORY
    } else {
        nvMoCompParams.celsiusDestinationViewportXOffset = CELSIUS_DESTINATION_VIEWPORT_XOFFSET;
        nvMoCompParams.celsiusFieldXOffset = (short)nvMoCompParams.surfaceLumaPitch << 2;
    }
    
    if (pDriverData->bMCPictureCodingType != PICTURE_TYPE_I) {

        if (!(nvInitCelsiusForMoCompPrediction()))
            return FALSE;

        if (nvMoCompParams.surfaceLumaPitch >= 1024) {
            nvDoBidirectionalFieldPrediction = nvDoCelsiusBidirectionalHDFieldPrediction;
            nvDoForwardFieldPrediction = nvDoCelsiusForwardHDFieldPrediction;
            nvDoBackwardFieldPrediction = nvDoCelsiusBackwardHDFieldPrediction;
        } else {
            nvDoBidirectionalFieldPrediction = nvDoCelsiusBidirectionalDVDFieldPrediction;
            nvDoTwoBidirectionalFieldPredictions = nvDoTwoCelsiusBidirectionalDVDFieldPredictions;
            nvDoForwardFieldPrediction = nvDoCelsiusForwardDVDFieldPrediction;
            nvDoTwoForwardFieldPredictions = nvDoTwoCelsiusForwardDVDFieldPredictions;
            nvDoBackwardFieldPrediction = nvDoCelsiusBackwardDVDFieldPrediction;
            nvDoTwoBackwardFieldPredictions = nvDoTwoCelsiusBackwardDVDFieldPredictions;
        }

        nvPredictFrameLumaMacroblock = nvPredictCelsiusFrameLumaMacroblock;
        nvPredictFrameChromaMacroblock = nvPredictCelsiusFrameChromaMacroblock;
        nvPredictFieldLumaMacroblock = nvPredictCelsiusFieldLumaMacroblock;
        nvPredictFieldChromaMacroblock = nvPredictCelsiusFieldChromaMacroblock;

        nvMoCompParams.currentForwardField = 0;
        nvMoCompParams.currentBackwardField = 0;
        nvMoCompParams.currentDestinationField = 0;

        pMacroblock = pMacroblocks;
        n = numMacroblocks;
        macroblockIndex = 0;

        surfacePitch = (nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch;

        // Must temporarily set destination surface pitch back to it's normal frame pitch
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_PITCH | 0x40000);
        nvPushData(3, surfacePitch);

        // Must also change texture pitches back to normal frame pitch so that quarter pel addressing works correctly
        nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
        nvPushData(5, surfacePitch << 16);
        nvPushData(6, surfacePitch << 16);

        nvPusherAdjust(7);

        // Perform luma prediction pass
        while (n > 0) {
            numCombinedMacroblocks[macroblockIndex] = 1;
			if (pMacroblock->macroblockType == MB_MOTION_FORWARD) {
				if(n > 1){
					pMacroblock1 = pMacroblock + 1;
					if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME){
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_FORWARD) &&
								(pMacroblock1->motionType == FRAME_STRUCTURE_MOTION_FRAME) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(*(long *)&pMacroblock->PMV[0][0][0] == *(long *)&pMacroblock1->PMV[0][0][0])) {
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
							if(n <= i+1)
								break;	//no more macroblck left
							pMacroblock1++;	

						}
					}
					else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD){
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_FORWARD) &&
								(pMacroblock1->motionType == FRAME_STRUCTURE_MOTION_FIELD) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(nvMoCompCheckFieldPredictionEqual(pMacroblock, pMacroblock1, pMacroblock->macroblockType))){
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
	
							if(n <= i+1)
								break;
							pMacroblock1++;							
						}
					}
				}
				if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME)
					 nvPredictFrameLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
				 else
					 hasFieldPredictions = TRUE;

				pMacroblock += numCombinedMacroblocks[macroblockIndex];
				n -= numCombinedMacroblocks[macroblockIndex];
			 } else if (pMacroblock->macroblockType == MB_MOTION_BACKWARD) {
				if(n > 1){
					pMacroblock1 = pMacroblock + 1;
					if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME){
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_BACKWARD) &&
								(pMacroblock1->motionType == FRAME_STRUCTURE_MOTION_FRAME) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(*(long *)&pMacroblock->PMV[0][1][0] == *(long *)&pMacroblock1->PMV[0][1][0])) {
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
							if(n <= i+1)
								break;
							pMacroblock1++;
						}
					}
					else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD){
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_BACKWARD) &&
								(pMacroblock1->motionType == FRAME_STRUCTURE_MOTION_FIELD) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(nvMoCompCheckFieldPredictionEqual(pMacroblock, pMacroblock1, pMacroblock->macroblockType))){
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
							if(n <= i+1)
								break;
							pMacroblock1 ++;
						}
					}
				}
				if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME)
					nvPredictFrameLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
				else
					hasFieldPredictions = TRUE;
	
				pMacroblock += numCombinedMacroblocks[macroblockIndex];
				n -= numCombinedMacroblocks[macroblockIndex];

			 } else if (pMacroblock->macroblockType == (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) {
				 if(n > 1){
					 pMacroblock1 = pMacroblock + 1;
					 if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME){
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) &&
								(pMacroblock1->motionType == FRAME_STRUCTURE_MOTION_FRAME) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(*(long *)&pMacroblock->PMV[0][0][0] == *(long *)&pMacroblock1->PMV[0][0][0]) &&
								(*(long *)&pMacroblock->PMV[0][1][0] == *(long *)&pMacroblock1->PMV[0][1][0])) {
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
							if(n <= i+1)
								break;
							pMacroblock1 ++;
						}
					}
					else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD){
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) &&
								(pMacroblock1->motionType == FRAME_STRUCTURE_MOTION_FIELD) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(nvMoCompCheckFieldPredictionEqual(pMacroblock, pMacroblock1, pMacroblock->macroblockType))){
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
							if(n <= i+1)
								break;
							pMacroblock1 ++;
						}
					}
				}
			  
				if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME)
					nvPredictFrameLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
				else
					hasFieldPredictions = TRUE;
	
				pMacroblock += numCombinedMacroblocks[macroblockIndex];
				n -= numCombinedMacroblocks[macroblockIndex];
			} else {
				if (pMacroblock->macroblockType != MB_INTRA) {

					if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME)
						nvPredictFrameLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
					else
						hasFieldPredictions = TRUE;

				}
				pMacroblock++;
				n--;
			}
            macroblockIndex++;
        }

        nvPusherStart(TRUE);

        pMacroblock = pMacroblocks;
        n = numMacroblocks;
        macroblockIndex = 0;

        // Change surface offsets to chroma portion of surface
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(3, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceChromaOffset);

        nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_OFFSET(0) | 0x40000);
        nvPushData(5, pDriverData->dwMCForwardSurfaceOffset + nvMoCompParams.surfaceChromaOffset);

        nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
        nvPushData(7, pDriverData->dwMCBackwardSurfaceOffset + nvMoCompParams.surfaceChromaOffset);

        nvPusherAdjust(8);

        nvMoCompParams.currentForwardField = 0;
        nvMoCompParams.currentBackwardField = 0;
        nvMoCompParams.currentDestinationField = 0;

        // Perform chroma prediction pass
        while (n > 0) {
            if (pMacroblock->macroblockType != MB_INTRA) {

                if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME)
                    nvPredictFrameChromaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);

            }
            pMacroblock += numCombinedMacroblocks[macroblockIndex];
            n -= numCombinedMacroblocks[macroblockIndex];
            macroblockIndex++;
        }

        nvPusherStart(TRUE);

        // Now do non-frame structured predictions if any are necessary
        if (hasFieldPredictions) {

            // Restore offsets and pitches to field based pitches
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_NO_OPERATION | 0x40000);
            nvPushData(1, 0);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
            nvPushData(3, nvMoCompParams.surfaceOffset);

            nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_TEXTURE_OFFSET(0) | 0x40000);
            nvPushData(5, pDriverData->dwMCForwardSurfaceOffset);

            nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(7, pDriverData->dwMCBackwardSurfaceOffset);

            nvPusherAdjust(8);

            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_SURFACE_PITCH | 0x40000);
            nvPushData(1, (surfacePitch << 1));

            nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                           NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
            nvPushData(3, surfacePitch << 17);
            nvPushData(4, surfacePitch << 17);

            nvPusherAdjust(5);

            pMacroblock = pMacroblocks;
            n = numMacroblocks;
            macroblockIndex = 0;

            nvMoCompParams.currentForwardField = 0;
            nvMoCompParams.currentBackwardField = 0;
            nvMoCompParams.currentDestinationField = 0;
            nvMoCompParams.destinationFieldIs0 = TRUE; // First process all destination field 0 updates

            // Perform luma prediction pass
            while (n > 0) {
                if (pMacroblock->macroblockType != MB_INTRA) {

                    if (pMacroblock->motionType != FRAME_STRUCTURE_MOTION_FRAME)
                        nvPredictFrameLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);

                }
                pMacroblock += numCombinedMacroblocks[macroblockIndex];
                n -= numCombinedMacroblocks[macroblockIndex];
                macroblockIndex++;
            }

            nvPusherStart(TRUE);

            // Change surface offsets to chroma portion of surface
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_NO_OPERATION | 0x40000);
            nvPushData(1, 0);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
            nvPushData(3, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceChromaOffset);

            nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_TEXTURE_OFFSET(0) | 0x40000);
            nvPushData(5, pDriverData->dwMCForwardSurfaceOffset + nvMoCompParams.surfaceChromaOffset);

            nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(7, pDriverData->dwMCBackwardSurfaceOffset + nvMoCompParams.surfaceChromaOffset);

            nvPusherAdjust(8);

            pMacroblock = pMacroblocks;
            n = numMacroblocks;
            macroblockIndex = 0;

            nvMoCompParams.currentForwardField = 0;
            nvMoCompParams.currentBackwardField = 0;
            nvMoCompParams.currentDestinationField = 0;
            nvMoCompParams.destinationFieldIs0 = TRUE; // First process all destination field 0 updates

            // Perform chroma prediction pass
            while (n > 0) {
                if (pMacroblock->macroblockType != MB_INTRA) {

                    if (pMacroblock->motionType != FRAME_STRUCTURE_MOTION_FRAME)
                        nvPredictFrameChromaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);

                }
                pMacroblock += numCombinedMacroblocks[macroblockIndex];
                n -= numCombinedMacroblocks[macroblockIndex];
                macroblockIndex++;
            }

            nvPusherStart(TRUE);

            if (nvMoCompParams.surfaceLumaPitch >= 1024) {

                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_NO_OPERATION | 0x40000);
                nvPushData(1, 0);

                nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
                nvPushData(3, nvMoCompParams.surfaceOffset);

                nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_TEXTURE_OFFSET(0) | 0x40000);
                nvPushData(5, pDriverData->dwMCForwardSurfaceOffset);

                nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(7, pDriverData->dwMCBackwardSurfaceOffset);

                nvPusherAdjust(8);

                pMacroblock = pMacroblocks;
                n = numMacroblocks;
                macroblockIndex = 0;

                nvMoCompParams.currentForwardField = 0;
                nvMoCompParams.currentBackwardField = 0;
                nvMoCompParams.currentDestinationField = 0;
                nvMoCompParams.destinationFieldIs0 = FALSE; // Then process all destination field 1 updates

                // Perform luma prediction pass
                while (n > 0) {
                    if (pMacroblock->macroblockType != MB_INTRA) {

                        if (pMacroblock->motionType != FRAME_STRUCTURE_MOTION_FRAME)
                            nvPredictFrameLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);

                    }
                    pMacroblock += numCombinedMacroblocks[macroblockIndex];
                    n -= numCombinedMacroblocks[macroblockIndex];
                    macroblockIndex++;
                }

                nvPusherStart(TRUE);

                // Change surface offsets to chroma portion of surface
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_NO_OPERATION | 0x40000);
                nvPushData(1, 0);

                nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
                nvPushData(3, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceChromaOffset);

                nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_TEXTURE_OFFSET(0) | 0x40000);
                nvPushData(5, pDriverData->dwMCForwardSurfaceOffset + nvMoCompParams.surfaceChromaOffset);

                nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(7, pDriverData->dwMCBackwardSurfaceOffset + nvMoCompParams.surfaceChromaOffset);

                nvPusherAdjust(8);

                pMacroblock = pMacroblocks;
                n = numMacroblocks;
                macroblockIndex = 0;

                nvMoCompParams.currentForwardField = 0;
                nvMoCompParams.currentBackwardField = 0;
                nvMoCompParams.currentDestinationField = 0;

                // Perform chroma prediction pass
                while (n > 0) {
                    if (pMacroblock->macroblockType != MB_INTRA) {

                        if (pMacroblock->motionType != FRAME_STRUCTURE_MOTION_FRAME)
                            nvPredictFrameChromaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);

                    }
                    pMacroblock += numCombinedMacroblocks[macroblockIndex];
                    n -= numCombinedMacroblocks[macroblockIndex];
                    macroblockIndex++;
                }

                nvPusherStart(TRUE);
            }
        }
    }

    if (!(nvInitCelsiusForMoCompCorrection()))
        return FALSE;

    SET_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

    if (nvMoCompParams.surfaceLumaPitch >= 1024) {
        nvDoAllIntraFieldCorrections = nvDoAllCelsiusIntraHDFieldCorrections;
        nvDoAllFieldCorrections = nvDoAllCelsiusHDFieldCorrections;
        nvDoIntraFieldCorrection = nvDoCelsiusIntraHDFieldCorrection;
        nvDoOptimizedIntraFieldCorrection = nvDoOptimizedCelsiusIntraHDFieldCorrection;
        nvDoFieldCorrection = nvDoCelsiusHDFieldCorrection;
    } else {
        nvDoAllIntraFieldCorrections = nvDoAllCelsiusIntraDVDFieldCorrections;
        nvDoAllFieldCorrections = nvDoAllCelsiusDVDFieldCorrections;
        nvDoIntraFieldCorrection = nvDoCelsiusIntraDVDFieldCorrection;
        nvDoOptimizedIntraFieldCorrection = nvDoOptimizedCelsiusIntraDVDFieldCorrection;
        nvDoFieldCorrection = nvDoCelsiusDVDFieldCorrection;
    }

    nvDoAllIntraFrameCorrections = nvDoAllCelsiusIntraFrameCorrections;
    nvDoAllFrameCorrections = nvDoAllCelsiusFrameCorrections;
    nvDoIntraFrameCorrection = nvDoCelsiusIntraFrameCorrection;
    nvDoFrameCorrection = nvDoCelsiusFrameCorrection;

    // Default motion comp correction ICW
    moCompCorrectionICW = (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                          (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                          (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                          (NV056_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NORMAL << 21) |
                          (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                          (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                          (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                          (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                          (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1 << 8) |

                          (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                          (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                           NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    // Non-prebiased motion comp correction ICW
    moCompNonPrebiasedCorrectionICW = (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                                      (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                                      (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                                      (NV056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                                      (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                                      (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                                      (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                                      (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                                      (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0 << 8) |

                                      (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                                      (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                                       NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0;
 
    nvMoCompParams.currentDestinationField = 0;
    nvMoCompParams.destinationField = 0;

    pMacroblock = pMacroblocks;
    n = numMacroblocks;

    // This assumes that the first IDCT index of the first macroblock in the command stream is the
    // lowest index in the entire command stream for this call.

    dwSurfaceOffset = pDriverData->dwMCDestinationSurfaceOffset;

    macroblockIndex = 0;
    index = 0;

    while (n > 0) {

        macroblockLimit = n;

        if (macroblockLimit > 24)
            macroblockLimit = 24;

        pDriverData->dwMCFirstAlignedIDCTIndex = pMacroblock->firstIDCTIndex & ~1;

        // Attempt to sanity check index
        if ((pDriverData->dwMCFirstAlignedIDCTIndex << 6) > pDriverData->dwMCIDCTAGPCtxDmaSize[0])
            pDriverData->dwMCFirstAlignedIDCTIndex = 0;

        dwFirstAlignedIDCTOffset = pDriverData->dwMCFirstAlignedIDCTIndex * 64; // 64 bytes per IDCT block

        // Force both texture caches to flush
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(3, dwSurfaceOffset);

        nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
        nvPushData(5, dwFirstAlignedIDCTOffset);
        nvPushData(6, dwSurfaceOffset);

        nvPusherAdjust(7);

        nvMoCompParams.destinationField = 0;
        nvMoCompParams.currentDestinationField = nvMoCompParams.destinationField;
        nvMoCompParams.destinationFieldIs0 = TRUE;

        if (pDriverData->bMCCurrentExecuteFunction ==
            EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
            // Modify combiners to perform non-prebiased intrablock correction
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_COMBINER_COLOR_ICW(0) | 0x40000);
            nvPushData(1, moCompNonPrebiasedCorrectionICW);

            nvPusherAdjust(2);

            SET_UNBIASED_CORRECTION_DATA_FORMAT();
        } else {
            SET_CORRECTION_DATA_FORMAT();
        }    

        if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_I) &&
            (pMacroblock->codedBlockPattern == 0xFF)) {
            nvCorrectCelsiusIntraFrame(pMacroblock, macroblockLimit);
            pMacroblock += macroblockLimit;
            n -= macroblockLimit;
        } else {
            long saveMacroblockLimit = macroblockLimit;
            long fieldTypeCount = 0;
            BOOL hasPartialCorrections = FALSE;

            pMacroblock1 = pMacroblock;

            nvMoCompParams.destinationFieldIs0 = TRUE;

             // Change texture1 surface offset to point to block of half bias values (0x80)
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

            // Change texture0 pitch to 16 bytes
            nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                           NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
            nvPushData(3, 16 << 16);
            nvPushData(4, 16 << 16); // half bias Intra block pitch

            nvPusherAdjust(5);

            // Perform first correction pass
            while (--macroblockLimit >= 0) {
                if ((pMacroblock->overflowCodedBlockPattern != 0) && (pMacroblock->macroblockType != MB_INTRA))
                    numCombinedMacroblocks[macroblockIndex++] = (BYTE) index;
                index++;
                if ((pMacroblock->DCTType != DCT_FIELD) && (pMacroblock->macroblockType == MB_INTRA)) {
                    if (pMacroblock->codedBlockPattern >= 0xFC) {
                        nvCorrectCelsiusFullFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                    } else if (pMacroblock->codedBlockPattern != 0) {
                        // Change texture0 pitch to it's default value of 8 bytes
                        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                       NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                        nvPushData(1, 8 << 16);

                        nvPusherAdjust(2);

                        nvCorrectCelsiusFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);

                        // Change texture0 pitch to 16 bytes
                        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                       NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                        nvPushData(1, 16 << 16);

                        nvPusherAdjust(2);

                    }
               } else
                    fieldTypeCount++;

                pMacroblock++;
                --n;
            }

            nvPusherStart(TRUE);

            if (pDriverData->bMCCurrentExecuteFunction == EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
                SET_UNBIASED_CHROMA_CORRECTION_DATA_FORMAT();
            } else {
                SET_CHROMA_CORRECTION_DATA_FORMAT();
            }    

            pMacroblock = pMacroblock1;
            macroblockLimit = saveMacroblockLimit;

            while (--macroblockLimit >= 0) {
                if (pMacroblock->macroblockType == MB_INTRA) {
                    if (pMacroblock->codedBlockPattern == 0xFF) {
                        nvCorrectCelsiusFullFrameChromaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                    } else if (pMacroblock->codedBlockPattern != 0) {
                        nvCorrectCelsiusFrameChromaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                    }
                }
                pMacroblock++;
            }

            nvPusherStart(TRUE);

            // Force both texture caches to flush
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_NO_OPERATION | 0x40000);
            nvPushData(1, 0);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(3, dwSurfaceOffset);

            nvPusherAdjust(4);

            // Change texture0 pitch to 16 bytes
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                           NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
            nvPushData(1, 16 << 16);
            nvPushData(2, nvMoCompParams.surfaceLumaPitch << 16);

            nvPusherAdjust(3);

            if (pDriverData->bMCCurrentExecuteFunction ==
                EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
                // Modify combiners to perform interblock correction
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_COMBINER_COLOR_ICW(0) | 0x40000);
                nvPushData(1, moCompCorrectionICW);

                nvPusherAdjust(2);
            }    

            SET_CORRECTION_DATA_FORMAT();

            nvMoCompParams.destinationFieldIs0 = TRUE;

            pMacroblock = pMacroblock1;
            macroblockLimit = saveMacroblockLimit;

            // Perform first correction pass
            while (--macroblockLimit >= 0) {
                if ((pMacroblock->DCTType != DCT_FIELD) && (pMacroblock->macroblockType != MB_INTRA)) {
                    if (pMacroblock->codedBlockPattern >= 0xFC) {
                        nvCorrectCelsiusFullFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                    } else if (pMacroblock->codedBlockPattern != 0) {
                        // Change texture0 pitch to it's default value of 8 bytes
                        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                       NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                        nvPushData(1, 8 << 16);

                        nvPusherAdjust(2);

                        nvCorrectCelsiusFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);

                        // Change texture0 pitch to 16 bytes
                        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                       NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                        nvPushData(1, 16 << 16);

                        nvPusherAdjust(2);
                    }
                }
                pMacroblock++;
            }

            nvPusherStart(TRUE);

            SET_CHROMA_CORRECTION_DATA_FORMAT();

            pMacroblock = pMacroblock1;
            macroblockLimit = saveMacroblockLimit;

            while (--macroblockLimit >= 0) {
                if (pMacroblock->macroblockType != MB_INTRA) {
                    if (pMacroblock->codedBlockPattern == 0xFF) {
                        nvCorrectCelsiusFullFrameChromaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                    } else if (pMacroblock->codedBlockPattern != 0) {
                        nvCorrectCelsiusFrameChromaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                    }
                }
                pMacroblock++;
            }

            nvPusherStart(TRUE);

            if (fieldTypeCount > 0) {

                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_NO_OPERATION | 0x40000);
                nvPushData(1, 0);

                // Change destination pitch to field pitch
                nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_SURFACE_PITCH | 0x40000);
                nvPushData(3, ((nvMoCompParams.surfaceLumaPitch << 17) | (nvMoCompParams.surfaceLumaPitch << 1)));

                // Change texture1 surface offset to point to block of half bias values (0x80)
                nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(5, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

                // Change texture0 pitch to 16 bytes
                nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
                nvPushData(7, 16 << 16);
                nvPushData(8, 16 << 16); // half bias Intra block pitch

                nvPusherAdjust(9);

                if (pDriverData->bMCCurrentExecuteFunction ==
                    EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
                    // Modify combiners to perform non-prebiased intrablock correction
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_SET_COMBINER_COLOR_ICW(0) | 0x40000);
                    nvPushData(1, moCompNonPrebiasedCorrectionICW);

                    nvPusherAdjust(2);

                    SET_UNBIASED_CORRECTION_DATA_FORMAT();
                } else {
                    SET_CORRECTION_DATA_FORMAT();
                }    

                pMacroblock = pMacroblock1;
                macroblockLimit = saveMacroblockLimit;

                while (--macroblockLimit >= 0) {
                    if ((pMacroblock->DCTType == DCT_FIELD) && (pMacroblock->macroblockType == MB_INTRA)) {
                        if (pMacroblock->codedBlockPattern >= 0xFC) {
                            nvCorrectCelsiusFullFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                        } else if (pMacroblock->codedBlockPattern != 0) {
                            // Change texture0 pitch to it's default value of 8 bytes
                            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                           NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                            nvPushData(1, 8 << 16);

                            nvPusherAdjust(2);

                            hasPartialCorrections = TRUE;

                            nvCorrectCelsiusFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);

                            // Change texture0 pitch to 16 bytes
                            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                           NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                            nvPushData(1, 16 << 16);

                            nvPusherAdjust(2);
                        }
                    }
                    pMacroblock++;
                }

                if ((nvMoCompParams.surfaceLumaPitch >= 1024) && (hasPartialCorrections)) {

                    nvMoCompParams.destinationFieldIs0 = FALSE;

                    pMacroblock = pMacroblock1;
                    macroblockLimit = saveMacroblockLimit;

                    while (--macroblockLimit >= 0) {
                        if ((pMacroblock->DCTType == DCT_FIELD) && (pMacroblock->macroblockType == MB_INTRA)) {
                             if ((pMacroblock->codedBlockPattern < 0xFC) &&
                                (pMacroblock->codedBlockPattern != 0)) {
                                // Change texture0 pitch to it's default value of 8 bytes
                                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                               NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                                nvPushData(1, 8 << 16);

                                nvPusherAdjust(2);

                                nvCorrectCelsiusFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);

                                // Change texture0 pitch to 16 bytes
                                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                               NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                                nvPushData(1, 16 << 16);

                                nvPusherAdjust(2);
                            }
                        }
                        pMacroblock++;
                    }

                    // Restore frame offsets
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_NO_OPERATION | 0x40000);
                    nvPushData(1, 0);

                    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
                    nvPushData(3, nvMoCompParams.surfaceOffset);

                    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                    nvPushData(5, nvMoCompParams.surfaceOffset);

                    nvPusherAdjust(6);

                    nvMoCompParams.destinationField = 0;
                    nvMoCompParams.currentDestinationField = nvMoCompParams.destinationField;
                }

                // Force both texture caches to flush
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_NO_OPERATION | 0x40000);
                nvPushData(1, 0);

                nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
                nvPushData(3, dwFirstAlignedIDCTOffset);
                nvPushData(4, dwSurfaceOffset);

                nvPusherAdjust(5);

                // Change texture0 pitch to 16 bytes
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
                nvPushData(1, 16 << 16);
                nvPushData(2, nvMoCompParams.surfaceLumaPitch << 16);

                nvPusherAdjust(3);

                if (pDriverData->bMCCurrentExecuteFunction ==
                    EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
                    // Modify combiners to perform interblock correction
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_SET_COMBINER_COLOR_ICW(0) | 0x40000);
                    nvPushData(1, moCompCorrectionICW);

                    nvPusherAdjust(2);
                }    

                SET_CORRECTION_DATA_FORMAT();

                nvMoCompParams.destinationFieldIs0 = TRUE;

                pMacroblock = pMacroblock1;
                macroblockLimit = saveMacroblockLimit;

                while (--macroblockLimit >= 0) {
                    if ((pMacroblock->DCTType == DCT_FIELD) && (pMacroblock->macroblockType != MB_INTRA)) {
                        if (pMacroblock->codedBlockPattern >= 0xFC) {
                            nvCorrectCelsiusFullFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                        } else if (pMacroblock->codedBlockPattern != 0) {
                            // Change texture0 pitch to it's default value of 8 bytes
                            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                           NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                            nvPushData(1, 8 << 16);

                            nvPusherAdjust(2);

                            hasPartialCorrections = TRUE;

                            nvCorrectCelsiusFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);

                            // Change texture0 pitch to 16 bytes
                            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                           NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                            nvPushData(1, 16 << 16);

                            nvPusherAdjust(2);
                        }
                    }
                    pMacroblock++;
                }

                if ((nvMoCompParams.surfaceLumaPitch >= 1024) && (hasPartialCorrections)) {

                    nvMoCompParams.destinationFieldIs0 = FALSE;

                    pMacroblock = pMacroblock1;
                    macroblockLimit = saveMacroblockLimit;

                    while (--macroblockLimit >= 0) {
                        if ((pMacroblock->DCTType == DCT_FIELD) && (pMacroblock->macroblockType != MB_INTRA)) {
                            if ((pMacroblock->codedBlockPattern < 0xFC) &&
                                (pMacroblock->codedBlockPattern != 0)) {
                                // Change texture0 pitch to it's default value of 8 bytes
                                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                               NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                                nvPushData(1, 8 << 16);

                                nvPusherAdjust(2);

                                nvCorrectCelsiusFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);

                                // Change texture0 pitch to 16 bytes
                                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                               NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                                nvPushData(1, 16 << 16);

                                nvPusherAdjust(2);
                            }
                        }
                        pMacroblock++;
                    }

                    // Restore frame offsets
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_NO_OPERATION | 0x40000);
                    nvPushData(1, 0);

                    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
                    nvPushData(3, nvMoCompParams.surfaceOffset);

                    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                    nvPushData(5, nvMoCompParams.surfaceOffset);

                    nvPusherAdjust(6);

                    nvMoCompParams.destinationField = 0;
                    nvMoCompParams.currentDestinationField = nvMoCompParams.destinationField;
                }

                // Restore surface pitch
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_SURFACE_PITCH | 0x40000);
                nvPushData(1, ((nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch));

                nvPusherAdjust(2);
            }
        }
        nvPusherStart(TRUE);
    }

    pLastMacroblock = pMacroblock - 1;

    if ((pDriverData->bMCPictureCodingType != PICTURE_TYPE_I) && (macroblockIndex > 0)) {
        long saveN = macroblockIndex;

        n = macroblockIndex;
        macroblockIndex = 0;
        pMacroblock1 = pMacroblocks;
        index = -24;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        // DO NOT REMOVE: This is necessary to work around an NV10 texture cache bug
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(3, dwSurfaceOffset);

        nvPusherAdjust(4);

        nvMoCompParams.currentDestinationField = 0;
        nvMoCompParams.destinationField = 0;

        // Change destination pitch back to frame pitch
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_PITCH | 0x40000);
        nvPushData(1, ((nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch));

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
        nvPushData(3, nvMoCompParams.surfaceOffset);

        // Change texture0 pitch to 16 bytes
        nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
        nvPushData(5, 16 << 16);
        nvPushData(6, nvMoCompParams.surfaceLumaPitch << 16);

        nvPusherAdjust(7);

        if (pDriverData->bMCCurrentExecuteFunction ==
            EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
            // Modify combiners to perform interblock correction
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_COMBINER_COLOR_ICW(0) | 0x40000);
            nvPushData(1, moCompCorrectionICW);

            nvPusherAdjust(2);
        }    

        SET_CHROMA_CORRECTION_DATA_FORMAT();

        while (--n >= 0) {

            pMacroblock = &pMacroblock1[numCombinedMacroblocks[macroblockIndex]];

            firstAlignedIDCTIndex = pMacroblock->firstIDCTIndex & ~1;

            if (firstAlignedIDCTIndex - index >= 24) {
                pDriverData->dwMCFirstAlignedIDCTIndex = firstAlignedIDCTIndex;

                index = firstAlignedIDCTIndex;

                // Attempt to sanity check index
                if ((pDriverData->dwMCFirstAlignedIDCTIndex << 6) > pDriverData->dwMCIDCTAGPCtxDmaSize[0])
                    pDriverData->dwMCFirstAlignedIDCTIndex = 0;

                dwFirstAlignedIDCTOffset = pDriverData->dwMCFirstAlignedIDCTIndex * 64; // 64 bytes per IDCT block

                // Force both texture caches to flush
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
                nvPushData(1, dwFirstAlignedIDCTOffset);
                nvPushData(2, dwSurfaceOffset);

                nvPusherAdjust(3);

                nvMoCompParams.currentDestinationField = 0;
                nvMoCompParams.destinationField = 0;
            }

            // Perform chroma overflow correction pass
            nvCorrectCelsiusFrameChromaMacroblock(pMacroblock, CORRECTION_OVERFLOW_PASS);

            macroblockIndex++;
        }

        nvPusherStart(TRUE);

        n = saveN;
        macroblockIndex = 0;
        index = -24;

        // Change texture0 pitch to it's default value of 8 bytes
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
        nvPushData(1, 8 << 16);
        nvPushData(2, nvMoCompParams.surfaceLumaPitch << 16);

        nvPusherAdjust(3);

        SET_CORRECTION_DATA_FORMAT();

        while (--n >= 0) {

            pMacroblock = &pMacroblock1[numCombinedMacroblocks[macroblockIndex]];

            firstAlignedIDCTIndex = pMacroblock->firstIDCTIndex & ~1;

            if (firstAlignedIDCTIndex - index >= 24) {
                pDriverData->dwMCFirstAlignedIDCTIndex = firstAlignedIDCTIndex;

                index = firstAlignedIDCTIndex;

                // Attempt to sanity check index
                if ((pDriverData->dwMCFirstAlignedIDCTIndex << 6) > pDriverData->dwMCIDCTAGPCtxDmaSize[0])
                    pDriverData->dwMCFirstAlignedIDCTIndex = 0;

                dwFirstAlignedIDCTOffset = pDriverData->dwMCFirstAlignedIDCTIndex * 64; // 64 bytes per IDCT block

                // Force both texture caches to flush
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
                nvPushData(1, dwFirstAlignedIDCTOffset);
                nvPushData(2, dwSurfaceOffset);

                nvPusherAdjust(3);

                nvMoCompParams.currentDestinationField = 0;
                nvMoCompParams.destinationField = 0;

                // For 1080I, reset offset.
                if (nvMoCompParams.surfaceLumaPitch >= 1024) {
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
                    nvPushData(1, nvMoCompParams.surfaceOffset);
                    nvPusherAdjust(2);
                }
            }


            // Perform luma overflow correction pass
            if (pMacroblock->DCTType == DCT_FIELD) {

                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_NO_OPERATION | 0x40000);
                nvPushData(1, 0);

                nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_SURFACE_PITCH | 0x40000);
                nvPushData(3, ((nvMoCompParams.surfaceLumaPitch << 17) | (nvMoCompParams.surfaceLumaPitch << 1)));

                // Change texture0 pitch to default value of 8 bytes
                nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
                nvPushData(5, 8 << 16);
                nvPushData(6, nvMoCompParams.surfaceLumaPitch << 17);

                nvPusherAdjust(7);

                nvCorrectCelsiusFrameLumaMacroblock(pMacroblock, CORRECTION_OVERFLOW_PASS);

                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_NO_OPERATION | 0x40000);
                nvPushData(1, 0);

                // Restore surface pitch
                nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_SURFACE_PITCH | 0x40000);
                nvPushData(3, ((nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch));

                // Change texture0 pitch to default value of 8 bytes
                nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
                nvPushData(5, 8 << 16);
                nvPushData(6, nvMoCompParams.surfaceLumaPitch << 16);

                nvPusherAdjust(7);

            } else
                nvCorrectCelsiusFrameLumaMacroblock(pMacroblock, CORRECTION_OVERFLOW_PASS);

            macroblockIndex++;
        }

        nvPusherStart(TRUE);
    }

    if ((pLastMacroblock->vOffset >= maxHeight) && (pLastMacroblock->hOffset >= maxWidth))
        surfaceDecodeStatus = 15;
    else if ((unsigned long)pLastMacroblock->vOffset > (nvMoCompParams.surfaceLumaHeight - (nvMoCompParams.surfaceLumaHeight >> 2)))
        surfaceDecodeStatus = 7;
    else if ((unsigned long)pLastMacroblock->vOffset > (nvMoCompParams.surfaceLumaHeight >> 1))
        surfaceDecodeStatus = 3;
    else if ((unsigned long)pLastMacroblock->vOffset > (nvMoCompParams.surfaceLumaHeight >> 2))
        surfaceDecodeStatus = 1;

    if (surfaceDecodeStatus > formatConversionStatus) {
        LPNVMCSURFACEFLAGS lpSurfaceFlags;

        nvMoCompConvertSurfaceFormat(dst->fpVidMem, TRUE, (DWORD)surfaceDecodeStatus);

        lpSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

        while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
               (lpSurfaceFlags->dwMCSurfaceBase != dst->fpVidMem))
            lpSurfaceFlags++;

            if ((lpSurfaceFlags->bMCFrameAlreadyFormatConverted == 15) &&
                (lpSurfaceFlags->bMCFrameIsFiltered == FALSE) &&
                (pDriverData->bMCTemporalFilterDisabled == FALSE))
                nvMoCompTemporalFilter(dst->fpVidMem, pDriverData->bMCPercentCurrentField);
    }

    return TRUE;

} /* nvMoCompProcessCelsiusFrameMacroblocks */


/*
 * nvMoCompProcessCelsiusFieldMacroblocks
 *
 * Parses the current macroblock command stream and performs the necessary operations on
 * each macroblock.
 *
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvMoCompProcessCelsiusFieldMacroblocks(LPNVDECODEMACROBLOCK pMacroblocks,
                                                       DWORD numMacroblocks, BYTE formatConversionStatus)
{
    LPDDRAWI_DDRAWSURFACE_LCL   dstx = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   dst = dstx->lpGbl;
    LPNVDECODEMACROBLOCK        pMacroblock;
    LPNVDECODEMACROBLOCK        pLastMacroblock;
    LPNVDECODEMACROBLOCK        pMacroblock1;
    unsigned long               dwFirstAlignedIDCTOffset;
    unsigned long               dwSurfaceOffset;
    unsigned long               moCompCorrectionICW;
    unsigned long               moCompNonPrebiasedCorrectionICW;
    long                        macroblockLimit;
    long                        n,i;
    long                        macroblockIndex;
    BYTE                        surfaceDecodeStatus = 0;
    BYTE                        numCombinedMacroblocks[256];
    short                       maxHeight = (short)(dst->wHeight >> 1) - 16;
    short                       maxWidth = (short)dst->wWidth - 16;
    int                         index;
    int                         firstAlignedIDCTIndex;

    nvMoCompParams.vertexMode = 0; // Initialize vertexMode to an invalid value
    nvMoCompParams.surfaceLumaPitch = dst->lPitch;
    nvMoCompParams.surfaceLumaHeight = (dst->wHeight + 1) & ~1;
    nvMoCompParams.surfaceOffset = VIDMEM_OFFSET(dst->fpVidMem);
    nvMoCompParams.surfaceChromaOffset = nvMoCompParams.surfaceLumaPitch * nvMoCompParams.surfaceLumaHeight;
    nvMoCompParams.surfaceBiasedIntraBlockOffset =
        (dst->lPitch * dst->wHeight) + (dst->lPitch * (dst->wHeight >> 1) + (8 * dst->lPitch));
    nvMoCompParams.celsiusDestinationViewportXOffset = CELSIUS_DESTINATION_VIEWPORT_XOFFSET;
    nvMoCompParams.celsiusFieldXOffset = (short)nvMoCompParams.surfaceLumaPitch << 2;

    if (pDriverData->bMCPictureCodingType != PICTURE_TYPE_I) {

        if (!(nvInitCelsiusForMoCompPrediction()))
            return FALSE;

        if (nvMoCompParams.surfaceLumaPitch >= 1024) {
            nvDoBidirectionalFieldPrediction = nvDoCelsiusBidirectionalHDFieldPrediction;
            nvDoForwardFieldPrediction = nvDoCelsiusForwardHDFieldPrediction;
            nvDoBackwardFieldPrediction = nvDoCelsiusBackwardHDFieldPrediction;
        } else {
            nvDoBidirectionalFieldPrediction = nvDoCelsiusBidirectionalDVDFieldPrediction;
            nvDoTwoBidirectionalFieldPredictions = nvDoTwoCelsiusBidirectionalDVDFieldPredictions;
            nvDoForwardFieldPrediction = nvDoCelsiusForwardDVDFieldPrediction;
            nvDoTwoForwardFieldPredictions = nvDoTwoCelsiusForwardDVDFieldPredictions;
            nvDoBackwardFieldPrediction = nvDoCelsiusBackwardDVDFieldPrediction;
            nvDoTwoBackwardFieldPredictions = nvDoTwoCelsiusBackwardDVDFieldPredictions;
        }

        nvPredictFrameLumaMacroblock = nvPredictCelsiusFrameLumaMacroblock;
        nvPredictFrameChromaMacroblock = nvPredictCelsiusFrameChromaMacroblock;
        nvPredictFieldLumaMacroblock = nvPredictCelsiusFieldLumaMacroblock;
        nvPredictFieldChromaMacroblock = nvPredictCelsiusFieldChromaMacroblock;

        nvMoCompParams.currentForwardField = 0;
        nvMoCompParams.currentBackwardField = 0;
        nvMoCompParams.currentDestinationField = 0;

        if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_BOTTOM_FIELD) {

            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_NO_OPERATION | 0x40000);
            nvPushData(1, 0);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
            nvPushData(3, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceLumaPitch);

            nvPusherAdjust(4);

            nvMoCompParams.currentDestinationField = 1;
        }

        pMacroblock = pMacroblocks;
        n = numMacroblocks;
        macroblockIndex = 0;

        // Perform luma prediction pass
        while (n > 0) {
            numCombinedMacroblocks[macroblockIndex] = 1;
            if (pMacroblock->macroblockType == MB_MOTION_FORWARD) {
                if (n > 1) {
					pMacroblock1 = pMacroblock + 1;
					if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD){
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_FORWARD) &&
								(pMacroblock1->motionType == FIELD_STRUCTURE_MOTION_FIELD) &&
                                ((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
                                (pMacroblock->fieldSelect[0][0] == pMacroblock1->fieldSelect[0][0]) &&
								(*(long *)&pMacroblock->PMV[0][0][0] == *(long *)&pMacroblock1->PMV[0][0][0])) {
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
							if(n <= i+1)
								break;		//no more macroblock left
							pMacroblock1++;
						}
					}
					else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8){
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_FORWARD) &&
								(pMacroblock1->motionType == FIELD_STRUCTURE_MOTION_16X8) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(nvMoCompCheckFieldPredictionEqual(pMacroblock, pMacroblock1, pMacroblock->macroblockType))){
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
							if(n <= i+1)
								break;
							pMacroblock1++;
						}
					}
				}
                    
                nvPredictFieldLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
                pMacroblock += numCombinedMacroblocks[macroblockIndex];
                n -= numCombinedMacroblocks[macroblockIndex];
            } else if (pMacroblock->macroblockType == MB_MOTION_BACKWARD) {
                if (n > 1) {
					pMacroblock1 = pMacroblock + 1;
					if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD){
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_BACKWARD) &&
								(pMacroblock1->motionType == FIELD_STRUCTURE_MOTION_FIELD) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(pMacroblock->fieldSelect[0][1] == pMacroblock1->fieldSelect[0][1]) &&
								(*(long *)&pMacroblock->PMV[0][1][0] == *(long *)&pMacroblock1->PMV[0][1][0])) {
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
	
							if(n <= i+1)
								break;
							pMacroblock1++;
						}
					}
					else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8){
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_BACKWARD) &&
								(pMacroblock1->motionType == FIELD_STRUCTURE_MOTION_16X8) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(nvMoCompCheckFieldPredictionEqual(pMacroblock, pMacroblock1, pMacroblock->macroblockType))){
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
	
							if(n <= i+1)
								break;
							pMacroblock1++;
						}
					}
				}
                nvPredictFieldLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
                pMacroblock += numCombinedMacroblocks[macroblockIndex];
                n -= numCombinedMacroblocks[macroblockIndex];
            } else if (pMacroblock->macroblockType == (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) {
                if (n > 1) {
					pMacroblock1 = pMacroblock + 1;
					if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD){
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) &&
								(pMacroblock1->motionType == FIELD_STRUCTURE_MOTION_FIELD) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(nvMoCompCheckFieldPredictionEqual(pMacroblock, pMacroblock1, pMacroblock->macroblockType))) {
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
	
							if(n <= i+1)
								break;
							pMacroblock1++;
						}
					}
					else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8){
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) &&
								(pMacroblock1->motionType == FIELD_STRUCTURE_MOTION_16X8) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(nvMoCompCheckFieldPredictionEqual(pMacroblock, pMacroblock1, pMacroblock->macroblockType))){
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
	
							if(n <= i+1)
								break;
							pMacroblock1++;
						}
					}
				}

                nvPredictFieldLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
                pMacroblock += numCombinedMacroblocks[macroblockIndex];
                n -= numCombinedMacroblocks[macroblockIndex];
            } else {
                if (pMacroblock->macroblockType != MB_INTRA)
                    nvPredictFieldLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
                pMacroblock++;
                n--;
            }
            macroblockIndex++;
        }

        nvPusherStart(TRUE);

        pMacroblock = pMacroblocks;
        n = numMacroblocks;
        macroblockIndex = 0;

        // Change surface offsets to chroma portion of surface
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);

        if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_BOTTOM_FIELD) {
            nvMoCompParams.currentDestinationField = 1;
            nvPushData(3, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceChromaOffset + nvMoCompParams.surfaceLumaPitch);
        } else {
            nvMoCompParams.currentDestinationField = 0;
            nvPushData(3, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceChromaOffset);
        }

        nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_OFFSET(0) | 0x40000);
        nvPushData(5, pDriverData->dwMCForwardSurfaceOffset + nvMoCompParams.surfaceChromaOffset);

        nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
        nvPushData(7, pDriverData->dwMCBackwardSurfaceOffset + nvMoCompParams.surfaceChromaOffset);

        nvPusherAdjust(8);

        nvMoCompParams.currentForwardField = 0;
        nvMoCompParams.currentBackwardField = 0;

        // Perform chroma prediction pass
        while (n > 0) {
            if (pMacroblock->macroblockType != MB_INTRA)
                nvPredictFieldChromaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
            pMacroblock += numCombinedMacroblocks[macroblockIndex];
            n -= numCombinedMacroblocks[macroblockIndex];
            macroblockIndex++;
        }

        nvPusherStart(TRUE);
    }

    if (!(nvInitCelsiusForMoCompCorrection()))
        return FALSE;

    SET_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

    if (nvMoCompParams.surfaceLumaPitch >= 1024) {
        nvDoAllIntraFieldCorrections = nvDoAllCelsiusIntraHDFieldCorrections;
        nvDoAllFieldCorrections = nvDoAllCelsiusHDFieldCorrections;
        nvDoIntraFieldCorrection = nvDoCelsiusIntraHDFieldCorrection;
        nvDoOptimizedIntraFieldCorrection = nvDoOptimizedCelsiusIntraHDFieldCorrection;
        nvDoFieldCorrection = nvDoCelsiusHDFieldCorrection;
    } else {
        nvDoAllIntraFieldCorrections = nvDoAllCelsiusIntraDVDFieldCorrections;
        nvDoAllFieldCorrections = nvDoAllCelsiusDVDFieldCorrections;
        nvDoIntraFieldCorrection = nvDoCelsiusIntraDVDFieldCorrection;
        nvDoOptimizedIntraFieldCorrection = nvDoOptimizedCelsiusIntraDVDFieldCorrection;
        nvDoFieldCorrection = nvDoCelsiusDVDFieldCorrection;
    }

    nvDoAllIntraFrameCorrections = nvDoAllCelsiusIntraFrameCorrections;
    nvDoAllFrameCorrections = nvDoAllCelsiusFrameCorrections;
    nvDoIntraFrameCorrection = nvDoCelsiusIntraFrameCorrection;
    nvDoFrameCorrection = nvDoCelsiusFrameCorrection;

    // Default motion comp correction ICW
    moCompCorrectionICW = (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                          (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                          (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                          (NV056_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NORMAL << 21) |
                          (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                          (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                          (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                          (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                          (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1 << 8) |

                          (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                          (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                           NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    // Non-prebiased motion comp correction ICW
    moCompNonPrebiasedCorrectionICW = (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                                      (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                                      (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                                      (NV056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                                      (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                                      (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                                      (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                                      (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                                      (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0 << 8) |

                                      (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                                      (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                                       NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0;

    nvMoCompParams.currentDestinationField = 0;

    pMacroblock = pMacroblocks;
    n = numMacroblocks;

    // This assumes that the first IDCT index of the first macroblock in the command stream is the
    // lowest index in the entire command stream for this call.

    dwSurfaceOffset = pDriverData->dwMCDestinationSurfaceOffset;

    macroblockIndex = 0;

    index = 0;

    while (n > 0) {

        macroblockLimit = n;

        if (macroblockLimit > 24)
            macroblockLimit = 24;

        pDriverData->dwMCFirstAlignedIDCTIndex = pMacroblock->firstIDCTIndex & ~1;

        dwFirstAlignedIDCTOffset = pDriverData->dwMCFirstAlignedIDCTIndex * 64; // 64 bytes per IDCT block

        // Force both texture caches to flush
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
        nvPushData(1, dwFirstAlignedIDCTOffset);
        nvPushData(2, dwSurfaceOffset);

        nvPusherAdjust(3);

        if (pDriverData->bMCCurrentExecuteFunction ==
            EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
            // Modify combiners to perform non-prebiased intrablock correction
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_COMBINER_COLOR_ICW(0) | 0x40000);
            nvPushData(1, moCompNonPrebiasedCorrectionICW);

            nvPusherAdjust(2);

            SET_UNBIASED_CORRECTION_DATA_FORMAT();
        } else {
            SET_CORRECTION_DATA_FORMAT();
        }    

        // Perform first correction pass
        if (pDriverData->bMCPictureCodingType == PICTURE_TYPE_I) {
            nvCorrectCelsiusIntraField(pMacroblock, macroblockLimit);
            pMacroblock += macroblockLimit;
            n -= macroblockLimit;
        } else {
            long saveMacroblockLimit = macroblockLimit;

            pMacroblock1 = pMacroblock;

            // Change texture1 surface offset to point to block of half bias values (0x80)
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

            // Change texture0 pitch to 16 bytes
            nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                           NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
            nvPushData(3, 16 << 16);
            nvPushData(4, 16 << 16); // half bias Intra block pitch

            nvPusherAdjust(5);

            while (--macroblockLimit >= 0) {
                if ((pMacroblock->overflowCodedBlockPattern != 0) && (pMacroblock->macroblockType != MB_INTRA))
                    numCombinedMacroblocks[macroblockIndex++] = (BYTE) index;
                index++;
                if ((pMacroblock->codedBlockPattern != 0) && (pMacroblock->macroblockType == MB_INTRA))
                     nvCorrectCelsiusFieldMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                pMacroblock++;
                --n;
            }

            nvPusherStart(TRUE);

            // Force both texture caches to flush
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_NO_OPERATION | 0x40000);
            nvPushData(1, 0);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
            nvPushData(3, dwFirstAlignedIDCTOffset);
            nvPushData(4, dwSurfaceOffset);

            nvPusherAdjust(5);

            // Change texture0 pitch to 16 bytes
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                           NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
            nvPushData(1, 16 << 16);
            nvPushData(2, nvMoCompParams.surfaceLumaPitch << 17);

            nvPusherAdjust(3);

            if (pDriverData->bMCCurrentExecuteFunction ==
                EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
                // Modify combiners to perform interblock correction
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_COMBINER_COLOR_ICW(0) | 0x40000);
                nvPushData(1, moCompCorrectionICW);

                nvPusherAdjust(2);
            }    

            SET_CORRECTION_DATA_FORMAT();

            nvMoCompParams.currentDestinationField = 0;

            pMacroblock = pMacroblock1;
            macroblockLimit = saveMacroblockLimit;

            while (--macroblockLimit >= 0) {
                if ((pMacroblock->codedBlockPattern != 0) && (pMacroblock->macroblockType != MB_INTRA))
                     nvCorrectCelsiusFieldMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                pMacroblock++;
            }
        }

        nvPusherStart(TRUE);
    }

    pLastMacroblock = pMacroblock - 1;

    if ((pDriverData->bMCPictureCodingType != PICTURE_TYPE_I) && (macroblockIndex > 0)) {

        pMacroblock = pMacroblocks;
        n = macroblockIndex;
        macroblockIndex = 0;
        index = -24;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        // DO NOT REMOVE: This is necessary to work around an NV10 texture cache bug
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(3, dwSurfaceOffset);

        nvPusherAdjust(4);

        if (pDriverData->bMCCurrentExecuteFunction ==
            EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
            // Modify combiners to perform interblock correction
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_COMBINER_COLOR_ICW(0) | 0x40000);
            nvPushData(1, moCompCorrectionICW);

            nvPusherAdjust(2);
        }    

        SET_CORRECTION_DATA_FORMAT();

        while (--n >= 0) {

            firstAlignedIDCTIndex = (&pMacroblock[numCombinedMacroblocks[macroblockIndex]])->firstIDCTIndex & ~1;

            if (firstAlignedIDCTIndex - index >= 24) {
                pDriverData->dwMCFirstAlignedIDCTIndex = firstAlignedIDCTIndex;

                index = firstAlignedIDCTIndex;

                // Attempt to sanity check index
                if ((pDriverData->dwMCFirstAlignedIDCTIndex << 6) > pDriverData->dwMCIDCTAGPCtxDmaSize[0])
                    pDriverData->dwMCFirstAlignedIDCTIndex = 0;

                dwFirstAlignedIDCTOffset = pDriverData->dwMCFirstAlignedIDCTIndex * 64; // 64 bytes per IDCT block

                // Force both texture caches to flush
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
                nvPushData(1, dwFirstAlignedIDCTOffset);
                nvPushData(2, dwSurfaceOffset);

                nvPusherAdjust(3);

                nvMoCompParams.currentDestinationField = 0;
            }

            // Perform overflow correction pass
            nvCorrectCelsiusFieldMacroblock((&pMacroblock[numCombinedMacroblocks[macroblockIndex]]), CORRECTION_OVERFLOW_PASS);

            macroblockIndex++;
        }

        nvPusherStart(TRUE);
    }

    if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD) {
        if ((pLastMacroblock->vOffset >= maxHeight) && (pLastMacroblock->hOffset >= maxWidth))
            surfaceDecodeStatus = 3;
        else if ((unsigned long)pLastMacroblock->vOffset > (nvMoCompParams.surfaceLumaHeight >> 2))
            surfaceDecodeStatus = 1;
    } else {
        if ((pLastMacroblock->vOffset >= maxHeight) && (pLastMacroblock->hOffset >= maxWidth))
            surfaceDecodeStatus = 12;
        else if ((unsigned long)pLastMacroblock->vOffset > (nvMoCompParams.surfaceLumaHeight >> 2))
            surfaceDecodeStatus = 4;
    }

    if (surfaceDecodeStatus > formatConversionStatus) {
        LPNVMCSURFACEFLAGS lpSurfaceFlags;

        nvMoCompConvertSurfaceFormat(dst->fpVidMem, TRUE, (DWORD)surfaceDecodeStatus);

        lpSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

        while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
               (lpSurfaceFlags->dwMCSurfaceBase != dst->fpVidMem))
            lpSurfaceFlags++;

            if ((lpSurfaceFlags->bMCFrameAlreadyFormatConverted == 15) &&
                (lpSurfaceFlags->bMCFrameIsFiltered == FALSE) &&
                (pDriverData->bMCTemporalFilterDisabled == FALSE))
                nvMoCompTemporalFilter(dst->fpVidMem, pDriverData->bMCPercentCurrentField);
    }

    return TRUE;

} /* nvMoCompProcessCelsiusFieldMacroblocks */


#endif  // NVARCH >= 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\ddnvstat.cpp ===
//======================================================================
// Module:		ddnvstat.cpp
// Description:	NVidia statistics driver routines, for NV3/NV4
// 
//  Copyright (C) 1999 NVidia Corporation.  All Rights Reserved.
//======================================================================
// NB: This file is 'opted out' of using pre-compiled headers
#include <windows.h>
#include <tchar.h>

#define STAT_INSTANIATE_TABLE
#include "statdef.h"			// has to be included before nvprecomp.

#include "nvprecomp.h"


#ifndef WINNT

#undef NVSTATNT_IOCTL
#define NVSTATNT_IOCTL(x) x

#endif

NVSTATLOCKINDEX nvStatLockIndex = NVSTAT_LOCK_UNKNOWN;
STATINDEX *gNVStatIndex;

HANDLE OpenDriver (TCHAR *pDeviceName);
BOOL CloseDriver(HANDLE hDriver);
DWORD GetDriverVersion(HANDLE hDriver);

HANDLE gDriverHandle = INVALID_HANDLE_VALUE;
NVSTATCNF statCfg;
NVDXTICK *DXStatTickPtr = NULL;

//======================================================================
// Function:	nvStatLookupIndex
// Description	Lookup and Index and fill in StatIndex structure
//				log/capture timings for d3d/ddraw functions.
// Parameters:	.
// Returns:		.
//======================================================================
void __cdecl nvStatLookupIndex(char *fmt, ...)
{
	DWORD nParms;
	DWORD sLen;
	DWORD ID;

	if (gNVStatIndex)
	{
		if (gNVStatIndex->index != INVALID_INDEX)
		{
			// log parameters 
			if (DXStatTickPtr && (DXStatTickPtr->logFormat & LOG_MEDIUM_BIT))
			{
				nParms = gNVStatIndex->nParms;
				if (nParms > 0)
				{
					ID = gNVStatIndex->index | D3D_LOG_PARAMETERS;
					nvStatWriteLogOpCode(nParms+1, ID);
					nvStatWriteLogData(nParms, (DWORD *)(&fmt+1));
				}
			}
			return;
		}

		__asm {
			push eax
			push ebx
			push ecx
			push edx
			push esi
			push edi

			mov	esi, fmt
			sub	esi, 1
			mov	ecx, STAT_HASH_TABLE_SIZE+1
			xor	eax,eax
			xor edx,edx
			mov bl, '%'
	loopSize:
			add	esi, 1
			dec	ecx
			je	done
			cmp	byte ptr [esi],al
			je	done
			cmp	[esi], bl
			jne	loopSize
			inc	edx
			jmp	loopSize
	done:
			neg	ecx
			add	ecx, STAT_HASH_TABLE_SIZE
			mov	sLen, ecx
			mov nParms, edx

			mov	ebx,ecx
			shl	ebx,3			// multiply by size of LENHASH structure
			add	ebx, OFFSET statDefHash
			mov	eax, dword ptr ([ebx]statDefHash.numEntries)
			mov	edx,[ebx]statDefHash.offset
			add	edx, OFFSET statDefList
	strLoop:
			mov	esi, edx
			mov edi, fmt
			mov	ecx, sLen
			add	edx, ecx
			repe	cmpsb
			je	foundName
			add	edx, 1			// + \0
			add	eax, (1 SHL 16)	// update ID in high word of eax
			dec	ax
			jne	strLoop
			mov	eax,-1
	foundName:
			shr		eax, 16
			cwde
			mov	ID, eax

			pop	edi
			pop	esi
			pop	edx
			pop	ecx
			pop	ebx
			pop	eax
		};

		gNVStatIndex->index = ID;
		gNVStatIndex->nParms = nParms;

		if (DXStatTickPtr)
		{
			if (ID != INVALID_INDEX)
			{
				nvStatWriteLogOpCode(1, ID);
				if (DXStatTickPtr->logFormat & LOG_MEDIUM_BIT)
				{
					NVStatLogMedium(0, ID);
				}
				else if (DXStatTickPtr->logFormat & LOG_MAXIMUM_BIT)
				{
					NVStatLogMaximum(0, ID);
				}
			}
		}
	}
}

//======================================================================
// Function:	AttachNVStat
// Description	Attaches to statistics Driver, so we can
//				log/capture timings for d3d/ddraw functions.
// Parameters:	.
// Returns:		.
//======================================================================
void __stdcall AttachNVStat()
{
	DWORD bytesReturned;

	gDriverHandle = OpenDriver(_T("nvstat"));

	if (gDriverHandle != INVALID_HANDLE_VALUE)
	{
		if (NvDeviceIoControl(gDriverHandle, NVSTATNT_IOCTL(GETCONFIGURATION), NULL, 0, &statCfg, sizeof(NVSTATCNF), 
			&bytesReturned, NULL) != 0)
		{
			// make sure configuration size is matches..
			if (bytesReturned == sizeof(NVSTATCNF))
			{
				// make sure at least the structure sizes match.
				if (statCfg.captureSize == sizeof(NVDXTICK))
					DXStatTickPtr = (NVDXTICK *)statCfg.captureMem;
			}
		}
	}
}

//======================================================================
// Function:	DetachNVStat
// Description	Detach statistics Driver (nvstat.Driver), freeing up resources
// Parameters:	.
// Returns:		.
//======================================================================
void __stdcall DetachNVStat()
{
	DXStatTickPtr = NULL;

	CloseDriver(gDriverHandle);	

	gDriverHandle = INVALID_HANDLE_VALUE;

}


//======================================================================
// Function:	OpenDriver
// Description:	opens the Driver for communication between ring 3 and 
//				ring 0
// Parameters:	pDeviceName = name of Driver
// returns:		HANDLE = opened file handle
//======================================================================
HANDLE OpenDriver (TCHAR *pDeviceName)
{

    HANDLE hDriver = 0;
    TCHAR device[64];

#ifdef WINNT
    nvSprintf( device, _T("%s"), pDeviceName);
#else
    PCHAR pExt = _tcsrchr( pDeviceName, '.');
    if (pExt && _tcsicmp( pExt, _T(".vxd")) == 0)
       *pExt = 0;

    nvSprintf( device, _T("\\\\.\\%s"), pDeviceName);
#endif

    hDriver = NvCreateFile( device, GENERIC_EXECUTE | GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);
    if (hDriver == INVALID_HANDLE_VALUE)
    {
#ifdef WINNT
        nvStrCat( device, _T(".sys"));
#else
        nvStrCat( device, _T(".vxd"));
#endif

	    hDriver = CreateFile( device, GENERIC_EXECUTE | GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);

    }
    return hDriver;
}


//======================================================================
// Function:	CloseDriver
// Description:	closes the Driver for freeing up resources
// Parameters:	HANDLE = opened file handle
// Returns:		!0 = success
//======================================================================
BOOL CloseDriver(HANDLE hDriver)
{
   BOOL retval;

   if (hDriver == INVALID_HANDLE_VALUE)
      return 0;

#ifdef WINNT
   retval = NvCloseHandle(hDriver);
#else
   retval = CLOSE_HANDLE( hDriver);
#endif

   return retval;
}

//======================================================================
// Function:	GetDriverVersion
// Description:	Retreives the Driver Version through an IOCTL
// Parameters:	HANDLE = opened file handle
// Returns:		packed version information
//======================================================================
DWORD GetDriverVersion(HANDLE hDriver)
{
    DWORD  cbBytesReturned;
    struct { BYTE minor; BYTE major; WORD product; } verinfo = {0,0,0};

    if (hDriver == INVALID_HANDLE_VALUE)
       return 0;

    if (!NvDeviceIoControl( hDriver,NVSTATNT_IOCTL(GETVERSION),0,0,&verinfo,sizeof(verinfo),&cbBytesReturned,NULL))
       return 0;

    return ( (verinfo.major << 8) | verinfo.minor);
}

//=====================================================================
// Function:	nvStatCheckLogSpace
// Description:	check for space in log file memory area
// Parameters:	nDWords = number of DWORDS we are going to write
// Returns:		TRUE if space in log memory area
//=====================================================================
BOOL nvStatCheckLogSpace(DWORD nDWords)
{
	DWORD freeSize;
	DWORD kLogSize;

	if (DXStatTickPtr->logFull)
		return TRUE;

	kLogSize = (DXStatTickPtr->logSize << 10);
	if (DXStatTickPtr->logHead > DXStatTickPtr->logTail)
	{
		// this really shouldn't happen, as the log file
		// stops when logTail reaches the end of the buffer, this is no longer
		// a circular buffer...But just in case figure something out.
		DPF("For some reason logging head pointer passed logging tail pointer????");
		freeSize = (DXStatTickPtr->logHead - DXStatTickPtr->logTail);
	}
	else
	{
		freeSize = kLogSize - (DXStatTickPtr->logTail - DXStatTickPtr->logHead);
	}

	if (freeSize >= (nDWords << 2))
		return TRUE;

	return FALSE;

}

//=====================================================================
// Function:	nvStatWriteLogOpCode
// Description:	write an opcode for upcoming log entries
// Parameters:	nDWords = number of DWORDS we are going to write
//							including opCode itself
//				opCode = the opcode to write to log memory
// Returns:		.
//=====================================================================
void nvStatWriteLogOpCode(DWORD nDWords, DWORD opCode)
{
	DWORD *tPtr;
	DWORD logSize;

	if (DXStatTickPtr == NULL)
		return;

	if (DXStatTickPtr->captureOn == 0)
		return;

	if (!(DXStatTickPtr->logFormat & (LOG_MINIMUM_BIT | LOG_MEDIUM_BIT | LOG_MAXIMUM_BIT)))
		return;

	if (DXStatTickPtr->logFull)
		return;

	if (nvStatCheckLogSpace(nDWords))
	{
		tPtr = (DWORD *)((BYTE *)DXStatTickPtr->logMem + DXStatTickPtr->logTail);
		*tPtr = (opCode << 16) | (nDWords & 0xffff);

		logSize = DXStatTickPtr->logSize << 10;

		// we only wrote out one of the words 
		DXStatTickPtr->logTail = DXStatTickPtr->logTail + (1 << 2);

		if (DXStatTickPtr->logTail >= logSize)
		{
			// stop logging when buffer is full
			DXStatTickPtr->logFull = TRUE;
		}
	}
	else
	{
		// stop logging when buffer is full
		DXStatTickPtr->logFull = TRUE;
		DXStatTickPtr->logMissed += 1;
	}


}

//=====================================================================
// Function:	nvStatWriteLogOpData
// Description:	write data for log entries
// Parameters:	nDWords = number of DWORDS we are going to write
//							including opCode itself
//				theData = pointer to dword data
// Returns:		.
//=====================================================================
void nvStatWriteLogData(DWORD nDWords, DWORD *theData)
{
	DWORD *tPtr;
	DWORD kLogSize;
	DWORD dwCount;

	if (DXStatTickPtr == NULL)
		return;

	if (DXStatTickPtr->captureOn == 0)
		return;

	if (DXStatTickPtr->logFull)
		return;

	if (!(DXStatTickPtr->logFormat & (LOG_MINIMUM_BIT | LOG_MEDIUM_BIT | LOG_MAXIMUM_BIT)))
		return;

	if (nvStatCheckLogSpace(nDWords))
	{
		tPtr = (DWORD *)((BYTE *)DXStatTickPtr->logMem + DXStatTickPtr->logTail);
		dwCount = nDWords;
		while (dwCount)
		{
			*tPtr++ = *theData++;
			dwCount--;
		}

		kLogSize = DXStatTickPtr->logSize << 10;

		DXStatTickPtr->logTail = DXStatTickPtr->logTail + (nDWords << 2);

		if (DXStatTickPtr->logTail == DXStatTickPtr->logHead)
		{
			// stop logging when buffer is full
			DXStatTickPtr->logFull = TRUE;
		}
	}
	else
	{
		// stop logging when buffer is full
		DXStatTickPtr->logFull = TRUE;
		DXStatTickPtr->logMissed += nDWords;
	}
}

//======================================================================
// Function:	nvStatLogError
// Description:	Log an error to the log file
// Parameters:	.
// Returns:		.
//======================================================================
void __cdecl nvStatLogError(DWORD dwLevel, LPSTR szFormat, ...)
{
	TCHAR tBuff[256];
	DWORD sLen;

	if (DXStatTickPtr == NULL)
		return;

	if (!(DXStatTickPtr->logFormat & (LOG_MINIMUM_BIT | LOG_MEDIUM_BIT | LOG_MAXIMUM_BIT)))
		return;

	if (!(dwLevel & (NVDBG_LEVEL_ERROR | NVDBG_LEVEL_PERFORMANCE)))
		return;

	nvSprintf(tBuff, szFormat, (va_list)(&szFormat+1));

	// include ending 0
	sLen = nvStrLen(tBuff)+1;

	// turn into # of double words
	sLen = (sLen + 3) >> 2;

	if (dwLevel & NVDBG_LEVEL_ERROR)
	{
		nvStatWriteLogOpCode(sLen+1, D3D_LOG_ERROR);
		nvStatWriteLogData(sLen, (LPDWORD)tBuff);
	}
	else if (DXStatTickPtr->logFormat & LOG_PERFORMANCE_BIT)
	{
		nvStatWriteLogOpCode(sLen+1, D3D_LOG_PERFORMANCE);
		nvStatWriteLogData(sLen, (LPDWORD)tBuff);
	}


}

//======================================================================
// Function:	nvStatLogState
// Description:	Log state change to log file
// Parameters:	state = which state has changed
//				context = which context changed the state
// Returns:		.
//======================================================================
void nvStatLogState(DWORD state, PNVD3DCONTEXT context)
{
}

//======================================================================
// Function:	nvStatLogPrimitives
// Description:	Log primitve information to log file
// Parameters:	command = primitive command to log
//				commandCount = # commands of this type
// Returns:		.
//======================================================================
void nvStatLogPrimitives(BYTE command,WORD commandCount)
{

}

//======================================================================
// Function:	nvStatLogLight
// Description:	log light parameters which come from DX7
// Parameters:	pLight7 pointer ot light structure
// Returns:		.
//======================================================================
void nvStatLogLight(LPD3DLIGHT7 pLight7)
{
}


//======================================================================
// Function:	nvStatLogDwordData
// Description:	log some dword data to the log file
// Parameters:	parmEnum = enumeration for parameter type
//				count = number of dwords to write
//				... = dword parameters
// Returns:		.
//======================================================================
void nvStatLogDwordData(DWORD parmEnum, int count, ...)
{
	va_list marker;
	DWORD curDW;

	if (DXStatTickPtr == NULL)
		return;

	if (!(DXStatTickPtr->logFormat & (LOG_MEDIUM_BIT | LOG_MAXIMUM_BIT)))
		return;

	if (DXStatTickPtr->logFull)
		return;


	nvStatWriteLogOpCode(count+1, parmEnum);

	va_start(marker, count);

	while (count)
	{
		curDW = va_arg(marker, DWORD);
		nvStatWriteLogData(1, &curDW);
		count--;
	}

	va_end(marker);

}

void __stdcall nvCelsiusDispatchPrintVertex (PNVD3DCONTEXT pContext,DWORD dwPutAddress)
{
#if 0
	DWORD *pdwData;
	DWORD flags;
	DWORD nUserUVS;
	DWORD nDWORDS;

	if (DXStatTickPtr == NULL)
		return;

	if (!(DXStatTickPtr->logFormat & LOG_MAXIMUM_BIT))
		return;

	pdwData = ((DWORD*)dwPutAddress) + 1;

	nDWORDS = 0;
	flags = 0;
	nUserUVS = 0;

	if (fvfData.dwBMask)
	{
		flags |= VERTSBMASK;
		nDWORDS++;
	}

	if (fvfData.dwNormalMask)
	{
		flags |= VERTSNORMALMASK;
		nDWORDS += 3;
	}

	if (pContext->celsiusState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(1))
	{
		DWORD dwD3DStage = pContext->celsiusState.dwTexUnitToTexStageMapping[1];
        DWORD dwTCIndex  = (pContext->celsiusState.dwTexCoordIndices >> 16) & 0xffff;
        DWORD dwCount    = (pContext->celsiusState.dwStateFlags & (CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(1) | CELSIUS_FLAG_TEXMATRIXSWFIX(1))) ?
                           4 : fvfData.dwUVCount[dwTCIndex];
		flags |= VERTSUSERUV1;
		nDWORDS += dwCount;
		nUserUVS = dwCount << 16;
	}

	if (pContext->celsiusState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(0))
	{
		DWORD dwD3DStage = pContext->celsiusState.dwTexUnitToTexStageMapping[0];
        DWORD dwTCIndex  = (pContext->celsiusState.dwTexCoordIndices >>  0) & 0xffff;
        DWORD dwCount    = (pContext->celsiusState.dwStateFlags & (CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(0) | CELSIUS_FLAG_TEXMATRIXSWFIX(0))) ?
                           4 : fvfData.dwUVCount[dwTCIndex];
		flags |= VERTSUSERUV0;
		nDWORDS += dwCount;
		nUserUVS |= dwCount;
	}

	if (fvfData.dwSpecularMask)
	{
		flags |= VERTSSPECULAR;
		nDWORDS++;

	}

	if (fvfData.dwDiffuseMask)
	{
		flags |= VERTSDIFFUSE;
		nDWORDS++;
	}

	if (fvfData.dwXYZMask)
	{
		flags |= VERTSXYZ;
		nDWORDS += 3;
	}

	if (fvfData.dwRHWMask)
	{
		if (pdwData[nDWORDS] == 0.0f)
		{
			nvStatLogError(NVDBG_LEVEL_ERROR, "RHW = 0.0f, it should equal 1.0f");
		}
		flags |= VERTSRHW;
		nDWORDS++;
	}

	nvStatWriteLogOpCode(nDWORDS+3, D3D_LOG_DX7_PRIMITIVES);
	nvStatWriteLogData(1, &flags);
	nvStatWriteLogData(1, &nUserUVS);
	nvStatWriteLogData(nDWORDS, pdwData);
#endif
}

void __stdcall nvKelvinDispatchPrintVertex (PNVD3DCONTEXT pContext,DWORD dwPutAddress)
{
#if 0
    static DWORD  dwVertexCount = 0;
           DWORD *pdwData       = ((DWORD*)dwPutAddress) + 1;

	if (DXStatTickPtr == NULL)
		return;

	if (!(DXStatTickPtr->logFormat & (LOG_MEDIUM_BIT | LOG_MAXIMUM_BIT)))
		return;

    if (DXStatTickPtr->logFormat & LOG_MEDIUM_BIT)
    {
        dwVertexCount ++;

        DPF ("Vertex %d",dwVertexCount);

        if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_BLENDWEIGHT])) {
            DPF ("         B = %08x",pdwData[0]);
            pdwData += 1;
        }

        if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_NORMAL])) {
            DPF ("    Normal = %f, %f, %f", FLOAT_FROM_DWORD(pdwData[0]),FLOAT_FROM_DWORD(pdwData[1]),FLOAT_FROM_DWORD(pdwData[2]));
            DPF ("           = [%08x, %08x, %08x]", pdwData[0],pdwData[1],pdwData[2]);
            pdwData += 3;
        }

        if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(1)) {
            DWORD dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[1];
            DWORD dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> 8) & 0xff;
            DWORD dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
            DWORD dwCount    = (pContext->hwState.pVertexShader->getVASize(dwVAIndex) >> 2);
            for (DWORD i = 0; i < dwCount; i++)
            {
                DPF ("   UV1[%d] = %f [%08x]", i,FLOAT_FROM_DWORD(pdwData[0]),pdwData[0]);
                pdwData += 1;
            }
        }

        if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(0)) {
            DWORD dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[0];
            DWORD dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> 0) & 0xff;
            DWORD dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
            DWORD dwCount    = (pContext->hwState.pVertexShader->getVASize(dwVAIndex) >> 2);
            for (DWORD i = 0; i < dwCount; i++)
            {
                DPF ("   UV0[%d] = %f [%08x]", i,FLOAT_FROM_DWORD(pdwData[0]),pdwData[0]);
                pdwData += 1;
            }
        }

        if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])){
            DPF ("  Specular = %08x",pdwData[0]);
            pdwData += 1;
        }

        if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE])) {
            DPF ("   Diffuse = %08x",pdwData[0]);
            pdwData += 1;
        }

        nvAssert (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]));
        DPF ("       XYZ = %f, %f, %f", FLOAT_FROM_DWORD(pdwData[0]),FLOAT_FROM_DWORD(pdwData[1]),FLOAT_FROM_DWORD(pdwData[2]));
        DPF ("           = [%08x, %08x, %08x]", pdwData[0],pdwData[1],pdwData[2]);
        pdwData += 3;

        if (pContext->hwState.pVertexShader->getVASize(defaultInputRegMap[D3DVSDE_POSITION]) == 4*sizeof(DWORD)) {
            DPF ("       RHW = %f [%08x]", FLOAT_FROM_DWORD(pdwData[0]),pdwData[0]);
            pdwData += 1;
        }
        DPF ("");
    }
#endif
}

//======================================================================
// Function:	nvStatLogVertexData
// Description:	Log an error to the log file
// Parameters:	dx6 = flag indicating dx6 or not
//				pVertex = pointer to vertex data to dump to log file
// Returns:		.
//======================================================================
void nvStatLogVertexData(BOOL dx6, DWORD *pVertex)
{
	if (DXStatTickPtr == NULL)
		return;

	if (!(DXStatTickPtr->logFormat & LOG_MAXIMUM_BIT))
		return;

	if (DXStatTickPtr->logFull)
		return;

	if (dx6)
	{
		nvStatWriteLogOpCode(11, D3D_LOG_DX6_PRIMITIVES);
		nvStatWriteLogData(10, pVertex);
	}
	else
	{
		nvStatWriteLogOpCode(9, D3D_LOG_DX5_PRIMITIVES);
		nvStatWriteLogData(8, pVertex);
	}
}

//======================================================================
// Function:	NVStatLogMedium
// Description:	Log medium amount of data depending on log opcode
// Parameters:	pContext = pointer to context for this DX module
//				DXFunction = enumeration number of function
// Returns:		.
//======================================================================
void NVStatLogMedium(DWORD DXFunction, DWORD value)
{
	DWORD opCode;


	if ((DXFunction >= START_RENDER_STATE) && (DXFunction <= END_RENDER_STATE))
	{
		opCode = DXFunction|D3D_LOG_PARAMETERS;
		nvStatWriteLogOpCode(2, opCode);
		nvStatWriteLogData(1, &value);
	}

	if (nvStatLockIndex != NVSTAT_LOCK_UNKNOWN)
	{
		opCode = D3D_LOG_LOCK_INDEX|D3D_LOG_PARAMETERS;
		nvStatWriteLogOpCode (2, opCode);
		nvStatWriteLogData(1, (DWORD *)&nvStatLockIndex);
		nvStatLockIndex = NVSTAT_LOCK_UNKNOWN;
	}
}

//======================================================================
// Function:	NVStatLogMaximum
// Description:	Log maximum amount of data depending on log opcode
// Parameters:	pContext = pointer to context for this DX module
//				DXFunction = enumeration number of function
// Returns:		.
//======================================================================
void NVStatLogMaximum(DWORD DXFunction, DWORD value)
{
	NVStatLogMedium(DXFunction, value);

	// add more dumping here...???
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\ddVideo.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *  Portions Copyright (C) 1997, 1999, 2000 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       ddVideo.cpp
 *  Content:    NVidia Direct Video/Active Movie Direct Draw support
 *              32 bit DirectDraw part.
 *
 ***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

#if 0
DWORD __stdcall HandleVideoPortOverlayUpdate(LPDDHAL_UPDATEOVERLAYDATA lpUOData);
#endif

extern BOOL ResetTwinViewState(GLOBALDATA *pDriverData);


// --------------------------------------------------------------------------------------
// TimerProc
//      Timer callback
void CALLBACK TimerProc(HWND hWnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{
    LPDDRAWI_DDRAWSURFACE_LCL lpSurfLcl = (LPDDRAWI_DDRAWSURFACE_LCL) pDriverData->vpp.dwOverlayLastVisibleSurfaceLCL;
    LPDDRAWI_DDRAWSURFACE_GBL lpSurfGbl;

    if (lpSurfLcl == NULL) {
        return;
    }

    if ((pDriverData->dwTVTunerFlipCount > 15) ||
        (pDriverData->regTVTunerHack == NV4_REG_VBMM_SINGLEOVL) ||
        (pDriverData->regTVTunerHack == NV4_REG_VBMM_FORCE)) {
        DWORD dwVPPFlags;

        lpSurfGbl = lpSurfLcl->lpGbl;
        if (lpSurfGbl == NULL) {
            return;
        }

        dwVPPFlags = VPP_ALL | VPP_WAIT;

        if (lpSurfLcl->lpSurfMore) {
            if (lpSurfLcl->lpSurfMore->dwOverlayFlags & DDOVER_INTERLEAVED) {
                dwVPPFlags |= VPP_INTERLEAVED | VPP_ODD;
            }
            if (lpSurfLcl->lpSurfMore->dwOverlayFlags & DDOVER_BOB) {
                dwVPPFlags |= VPP_BOB | VPP_ODD;
            }
        }
        if (lpSurfLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT) {
            dwVPPFlags |= VPP_VIDEOPORT;
        }

        VppDoFlip(&(pDriverData->vpp),
                      lpSurfGbl->fpVidMem - pDriverData->BaseAddress,
                      lpSurfGbl->lPitch,
                      lpSurfGbl->wWidth,
                      lpSurfGbl->wHeight,
                      lpSurfGbl->ddpfSurface.dwFourCC,
                      dwVPPFlags);

        pDriverData->dwTVTunerFlipCount = 16;
    } else {
        pDriverData->dwTVTunerFlipCount++;
    }
}

// --------------------------------------------------------------------------------------
// TVTunerTimerHack
//      Hack used for bus mastering TV tuners which never call flip.  When detected,
//      install a timer to autoflip
#define TV_TUNER_HACK_FRAME_PERIOD 33

BOOL __stdcall TVTunerTimerHack()
{
#ifdef WINNT
    return FALSE;
#else   // Win9x
    if ((pDriverData->dwTVTunerTimer != NULL) ||
        (pDriverData->regTVTunerHack == NV4_REG_VBMM_NOHACK) ||
        (pDriverData->regTVTunerHack == NV4_REG_VBMM_DETECT && pDriverData->vpp.dwOverlaySurfaces != 1) ||
        (pDriverData->regTVTunerHack == NV4_REG_VBMM_SINGLEOVL && pDriverData->vpp.dwOverlaySurfaces != 1)){
        return FALSE;
    }

    pDriverData->dwTVTunerFlipCount = 0;
    pDriverData->dwTVTunerTimer = SetTimer(NULL, NULL, TV_TUNER_HACK_FRAME_PERIOD, TimerProc);
    return TRUE;
#endif  // WINNT
}


/*
 * UpdateOverlay32
 *
 *
 * NOTES:
 *
 * This callback is invoked to update an overlay surface.
 * This is where the src/destination is specified, any effects, and
 * it is shown or hidden
 *
 * For overlay surfaces NOT associated with a video port the surface will
 * be shown (DDOVER_SHOW) according to the following criteria.
 *
 *     DDOVER_INTERLEAVED   DDOVER_BOB      DISPLAYED
 *
 *             1                1           Even field
 *             1                0           Full surface (no special processing)
 *             0                X           Full surface (no special processing)
 *
 */

DWORD __stdcall
UpdateOverlay32( LPDDHAL_UPDATEOVERLAYDATA lpUOData )
{
    NvNotification              *pPioFlipOverlayNotifier;
    DWORD                       index = 0;
    DWORD                       match = 0;
#ifndef WINNT
    DWORD                       dwSavedNBData = 0;
#endif
    long                        srcDeltaX;
    long                        srcDeltaY;
    long                        dwSrcWidth;
    long                        dwSrcHeight;
    long                        dwDstWidth;
    long                        dwDstHeight;
    U032                        bMediaPortControl = FALSE;
    DWORD                       dwOverlayFormat = 0;
    DWORD                       dwVPPFlags;

    LPDDRAWI_DDRAWSURFACE_LCL   srcx = lpUOData->lpDDSrcSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   src = srcx->lpGbl;
    LPDDRAWI_DDRAWSURFACE_LCL   pLastVisibleSurfLcl;

    dbgTracePush ("UpdateOverlay32");

    nvSetDriverDataPtrFromDDGbl (lpUOData->lpDD);

    // set up pointer to DDHALINFO
    LPDDHALINFO pHalInfo = GET_HALINFO();

    pLastVisibleSurfLcl = (LPDDRAWI_DDRAWSURFACE_LCL) pDriverData->vpp.dwOverlayLastVisibleSurfaceLCL;

    pPioFlipOverlayNotifier = pDriverData->pPioFlipOverlayNotifierFlat;

    // subrectangle size may change, reset temporal filter.
    pDriverData->vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_NOTFIRST;

    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_DDRAW) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvDDrawRecover();
        } else {
            lpUOData->ddRVal = DDERR_SURFACEBUSY;
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    }

    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_TWINVIEW_STATE_CHANGE) {
        VppDestroyFSMirror(&pDriverData->vpp);
        VppDestroyOverlay(&pDriverData->vpp);
        ResetTwinViewState(pDriverData);
        VppCreateOverlay(&pDriverData->vpp);
        VppCreateFSMirror(&pDriverData->vpp, pDriverData->vpp.dwOverlayFSSrcWidth, pDriverData->vpp.dwOverlayFSSrcHeight);
    }

#if 0
        // This code will eventually be used to specially opt out of overlay stuff when video port is in use
    if( srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT)  {

        lpUOData->ddRVal = HandleVideoPortOverlayUpdate( lpUOData);
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return DDHAL_DRIVER_HANDLED;

    }
#endif //

#ifdef NVPE
    // VPE takes care of overlay !
    if ((srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT) || (pDriverData->bRing0FlippingFlag))
    {
        bMediaPortControl = TRUE;
    }

    else
        bMediaPortControl = FALSE;

    // Workaround for 640x480 Panel overlay flip notifier problem.
    // If mode is 480 lines and overlay ends at line 480, reduce it to line 479.
    if ((GET_MODE_HEIGHT() == 480)      &&
        (lpUOData->rDest.bottom == 480) &&
        (lpUOData->rDest.top < 477)     &&
        (pDriverData->vpp.dwNVOverlayFlags & OVERLAY_FLAG_ON_PANEL)) {

        lpUOData->rDest.bottom = 479;
    }

#endif // NVPE

    if ((src->ddpfSurface.dwFourCC != FOURCC_UYVY) &&
        (src->ddpfSurface.dwFourCC != FOURCC_UYNV) &&
        (src->ddpfSurface.dwFourCC != FOURCC_YUY2) &&
        (src->ddpfSurface.dwFourCC != FOURCC_YUNV) &&
        (src->ddpfSurface.dwFourCC != FOURCC_YV12) &&
        (src->ddpfSurface.dwFourCC != FOURCC_NV12) &&
        (src->ddpfSurface.dwFourCC != FOURCC_NVMC) &&
        (src->ddpfSurface.dwFourCC != FOURCC_NVDS) &&
        (src->ddpfSurface.dwFourCC != FOURCC_420i) &&
        (src->ddpfSurface.dwFourCC != FOURCC_IF09) &&
        (src->ddpfSurface.dwFourCC != FOURCC_YVU9) &&
        (src->ddpfSurface.dwFourCC != FOURCC_IV32) &&
        (src->ddpfSurface.dwFourCC != FOURCC_IV31)) {
            NvReleaseSemaphore(pDriverData);
            lpUOData->ddRVal = DDERR_INVALIDSURFACETYPE;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
    }

    if (!(srcx->ddsCaps.dwCaps & DDSCAPS_OVERLAY)) {
            NvReleaseSemaphore(pDriverData);
            lpUOData->ddRVal = DDERR_NOTAOVERLAYSURFACE;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
    }

    while ((index < NV_VPP_MAX_OVERLAY_SURFACES) && (!match))
        if ((DWORD)srcx == pDriverData->vpp.dwOverlaySurfaceLCL[index++])
            match = 1;

    if (!match) {
        // Do some DirectShow compatibility stuff
        if ((src->ddpfSurface.dwFourCC == FOURCC_NVMC) || (src->ddpfSurface.dwFourCC == FOURCC_NVDS)) {
#if (NVARCH >= 0x10)
            BYTE dstSurfaceIndex;
            LPNVMCFRAMEDATA lpNvMCFrameData = (LPNVMCFRAMEDATA) VIDMEM_ADDR(src->fpVidMem);
            dstSurfaceIndex = lpNvMCFrameData->bMCDestinationSurfaceIndex & 0x0F;
            if (pDriverData->dwMCNVMCSurface != 0) {
                if (dstSurfaceIndex >= 8)
                    dstSurfaceIndex = 0;
                srcx = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNV12Surface[dstSurfaceIndex];
                if (srcx != NULL)
                    src = srcx->lpGbl;
            } else
                pLastVisibleSurfLcl = NULL;
#endif  // NVARCH >= 0x10
        } else {
            dbgError("VPP: Could not locate overlay in private list of surfaces");
            NvReleaseSemaphore(pDriverData);
            lpUOData->ddRVal = DDERR_OUTOFCAPS;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    }

    getDC()->nvPusher.waitForOtherChannels();

    if ((getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) ||   // Mode switches might occur without warning
        (pDriverData->vpp.dwOverlayFSOvlHead == 0xFFFFFFFF) ||                    // overlay surface has been destroyed
        (pDriverData->vpp.dwOverlayFSOvlLost)) {                                  // not overlay capable any more

        nvDDrawRecover();
        lpUOData->ddRVal = DDERR_SURFACELOST;
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return DDHAL_DRIVER_HANDLED;
    }

    pDriverData->dwRingZeroMutex = TRUE;

#ifndef WINNT
    // check for VIA 82C598 north bridge
    if (IS_VIA_MVP3_NB_ID(pDriverData->northBridgeID)) {
        // turn off write posting
        _asm {
                mov edx, 0cf8h
                mov eax, 80000840h
                out dx, eax
                mov edx, 0cfch
                mov eax, 0
                in  al, dx
                mov dwSavedNBData, eax
                and eax, 0FFFFFF7Fh
                out dx, al
        }
    }
#endif

//#ifndef WINNT
#if (!defined(WINNT) && !defined(NVPE))
    // check and possibly allocate overlay events for Ring0 functioning
    // note these will only be actually CALLED if write_then_awaken is used
    // so we're safe since ONLY ring0 should be calling that... hopefully heh heh...
    if(!pDriverData->vpp.dwOverlayEventsAllocated ){
      if(( ((vpSurfaces*)(pDriverData->dwMySurfacesPtr))->pNotifyOverlay0NotifyProc != 0 ) &&
           (((vpSurfaces*)(pDriverData->dwMySurfacesPtr))->pNotifyOverlay1NotifyProc != 0 )  ){
        U032 status = 0;
        status = NvRmAllocEvent (   pDriverData->dwRootHandle,
                              NV_VIDEO_OVERLAY,
                              MY_OVERLAY0_BUFFER_EVENT,
                              NV01_EVENT_KERNEL_CALLBACK,
                              NV07A_NOTIFIERS_SET_OVERLAY(0),
                              (void*)(((vpSurfaces*)(pDriverData->dwMySurfacesPtr))->pNotifyOverlay0NotifyProc));
        if( status !=  0x0 /* meaning sucess */ ) {
          DPF("Bad status returned from nvRmAllocEvent. status = %d",status);
        }
        status = NvRmAllocEvent (   pDriverData->dwRootHandle,
                              NV_VIDEO_OVERLAY,
                              MY_OVERLAY1_BUFFER_EVENT,
                              NV01_EVENT_KERNEL_CALLBACK,
                              NV07A_NOTIFIERS_SET_OVERLAY(1),
                              (void*)(((vpSurfaces*)(pDriverData->dwMySurfacesPtr))->pNotifyOverlay1NotifyProc));
        if( status !=  0x0 /* meaning sucess */ ) {
          DPF("Bad status returned from nvRmAllocEvent. status = %d",status);
        }
        pDriverData->vpp.dwOverlayEventsAllocated = TRUE;
      }
    }
#endif  // (!defined(WINNT) && !defined(NVPE))

    index = pDriverData->vpp.overlayBufferIndex;

    dwSrcWidth  = lpUOData->rSrc.right - lpUOData->rSrc.left;
    dwSrcHeight = lpUOData->rSrc.bottom - lpUOData->rSrc.top;
    dwDstWidth  = lpUOData->rDest.right - lpUOData->rDest.left;
    dwDstHeight = lpUOData->rDest.bottom - lpUOData->rDest.top;

    // if hide/show state, field state, size, and colour key state are the same, then we can do a
    // SetOverlayPosition instead
    if (pDriverData->vpp.dwOverlayFlipCount > 2 &&
        pLastVisibleSurfLcl != NULL &&
        pLastVisibleSurfLcl->lpGbl != NULL &&
        src->fpVidMem == pDriverData->vpp.dwOverlayLastVisibleFpVidMem &&
        (DWORD) src->lPitch == pDriverData->vpp.dwOverlayLastVisiblePitch &&
        src->ddpfSurface.dwFourCC == pDriverData->vpp.dwOverlayLastVisiblePixelFormat &&
        lpUOData->dwFlags == pDriverData->vpp.dwOverlayCachedFlags &&
        lpUOData->overlayFX.dckDestColorkey.dwColorSpaceLowValue == pDriverData->vpp.dwOverlayColorKey &&
        (DWORD)dwSrcWidth == pDriverData->vpp.dwOverlaySrcWidth &&
        (DWORD)dwSrcHeight == pDriverData->vpp.dwOverlaySrcHeight &&
        (DWORD)dwDstWidth == pDriverData->vpp.dwOverlayDstWidth &&

        (DWORD)dwDstHeight == pDriverData->vpp.dwOverlayDstHeight &&
#ifndef NVPE
        !(srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT)) {
#else
        !(bMediaPortControl)) {
#endif // !NVPE
        pDriverData->dwRingZeroMutex = TRUE;
        pDriverData->vpp.dwOverlayDstX = (short)lpUOData->rDest.left;
        pDriverData->vpp.dwOverlayDstY = (short)lpUOData->rDest.top;

        // Direct Access to a VPP object - should not! -@mjl@
        nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
        nvPushData(1, NV_VPP_OVERLAY_IID);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | NV07A_SET_OVERLAY_POINT_OUT_A | 0x40000);
        nvPushData(3, asmMergeCoords(lpUOData->rDest.left, lpUOData->rDest.top));  // SetOverlayPointOutA
        nvPusherAdjust(4);
        nvPusherStart(TRUE);

        pDriverData->dwRingZeroMutex = FALSE;
        pDriverData->dDrawSpareSubchannelObject = 0;
#ifndef WINNT
        // check for VIA 82C598 north bridge
        if (IS_VIA_MVP3_NB_ID(pDriverData->northBridgeID)) {
            // restore write posting value
            _asm {
                    mov edx, 0cf8h
                    mov eax, 80000840h
                    out dx, eax
                    mov edx, 0cfch
                    mov eax, dwSavedNBData
                    out dx, al
            }
        }
#endif

        NvReleaseSemaphore(pDriverData);
        lpUOData->ddRVal = DD_OK;
        dbgTracePop();
        return DDHAL_DRIVER_HANDLED;
    } else {
        // reset the overlay flip count
        // both overlay buffers must be set with correct paramters before using the setoverlyposition optimization
        pDriverData->vpp.dwOverlayFlipCount = 0;
    }

    pDriverData->vpp.dwOverlayCachedFlags = lpUOData->dwFlags;

    if ((lpUOData->dwFlags & DDOVER_HIDE ) || dwDstWidth <= 1 || dwDstHeight <= 1) {
        LPPROCESSINFO lpProcInfo = pmGetProcess(pDriverData, GetCurrentProcessId());

        DPF("UPDATE OVERLAY - DDOVER_HIDE");

#ifdef WINNT
        // WIN2K HACK: DX7 under win2k presents incorrect flags, so manually fix them
        if (pLastVisibleSurfLcl) {
            pLastVisibleSurfLcl->ddsCaps.dwCaps &= ~(DDSCAPS_VISIBLE | DDSCAPS_FRONTBUFFER);
            pLastVisibleSurfLcl->ddsCaps.dwCaps |= DDSCAPS_BACKBUFFER;
        }
#endif  // WINNT
        pDriverData->vpp.dwOverlayLastVisibleSurfaceLCL = 0;

        pDriverData->vpp.dwOverlaySrcWidth = 0;
        pDriverData->vpp.dwOverlayDstWidth = 0;
        pDriverData->vpp.dwOverlaySrcHeight = 0;
        pDriverData->vpp.dwOverlayDstHeight = 0;

#ifdef NVPE

        // H.AZAR: (10/20/99) tell VPE kernel to stop autoflip !
        if (bMediaPortControl)
            NVPUpdateOverlay(pDriverData, lpUOData->lpDD);
        else
        {
            Sleep(VPP_TIMEOUT_TIME * 3);

            // Direct Access to VPP object! -@mjl@
            nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
            nvPushData(1, NV_VPP_OVERLAY_IID);
            nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | NV07A_STOP_OVERLAY(0) | 0x80000);
            nvPushData(3, NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE);  // StopOverlay[0]
            nvPushData(4, NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE);  // StopOverlay[1]
            nvPusherAdjust(5);
            nvPusherStart(TRUE);

            pPioFlipOverlayNotifier[1].status = 0;      /* clear notifiers */
            pPioFlipOverlayNotifier[2].status = 0;
        }
#else
        Sleep(VPP_TIMEOUT_TIME * 3);

        nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
        nvPushData(1, NV_DD_DMA_OVERLAY);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | NV07A_STOP_OVERLAY(0) | 0x80000);
        nvPushData(3, NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE);  // StopOverlay[0]
        nvPushData(4, NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE);  // StopOverlay[1]
        nvPusherAdjust(5);
        nvPusherStart(TRUE);

        pPioFlipOverlayNotifier[1].status = 0;      /* clear notifiers */
        pPioFlipOverlayNotifier[2].status = 0;

#endif  // #ifdef NVPE

          //pDriverData->dwRingZeroMutex = FALSE;

        pDriverData->dDrawSpareSubchannelObject = 0;
        pDriverData->vpp.dwOverlayFormat = 0;     // This should hide things, since we'll stop flipping

        /* Let DDraw know how many visible overlays are active */
        pHalInfo->ddCaps.dwCurrVisibleOverlays = 0;

    } else {

        DPF("UPDATE OVERLAY - DDOVER_SHOW OR MOVE/RESIZE ");
        DPF( "Source Rect = (%d,%d), (%d,%d)",
             lpUOData->rSrc.left, lpUOData->rSrc.top,
             lpUOData->rSrc.right, lpUOData->rSrc.bottom );

        DPF( "Dest Rect = (%d,%d), (%d,%d)",
             lpUOData->rDest.left, lpUOData->rDest.top,
             lpUOData->rDest.right, lpUOData->rDest.bottom );

#ifdef WINNT
        // WIN2K HACK: DX7 under win2k presents incorrect flags, so manually fix them
        if (pLastVisibleSurfLcl) {
            pLastVisibleSurfLcl->ddsCaps.dwCaps &= ~(DDSCAPS_VISIBLE | DDSCAPS_FRONTBUFFER);
            pLastVisibleSurfLcl->ddsCaps.dwCaps |= DDSCAPS_BACKBUFFER;
        }
        srcx->ddsCaps.dwCaps |= DDSCAPS_VISIBLE | DDSCAPS_FRONTBUFFER;
        srcx->ddsCaps.dwCaps &= ~DDSCAPS_BACKBUFFER;
#endif  // WINNT
        pDriverData->vpp.dwOverlayLastVisibleSurfaceLCL = (DWORD) srcx;
        pDriverData->vpp.dwOverlayLastVisibleFpVidMem = src->fpVidMem;
        pDriverData->vpp.dwOverlayLastVisiblePitch = src->lPitch;
        pDriverData->vpp.dwOverlayLastVisiblePixelFormat = src->ddpfSurface.dwFourCC;

        if ((lpUOData->rDest.left < 0) || (lpUOData->rDest.top < 0)) {
            pDriverData->dwRingZeroMutex = FALSE;

#ifndef WINNT
            // check for VIA 82C598 north bridge
            if (IS_VIA_MVP3_NB_ID(pDriverData->northBridgeID)) {
                // restore write posting value
                _asm {
                        mov edx, 0cf8h
                        mov eax, 80000840h
                        out dx, eax
                        mov edx, 0cfch
                        mov eax, dwSavedNBData
                        out dx, al
                }
            }
#endif
            NvReleaseSemaphore(pDriverData);
            lpUOData->ddRVal = DDERR_INVALIDPOSITION;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }

        // For bus mastering TV tuners that never flip
        TVTunerTimerHack();

        /* Remember sizes so Flip32 knows what to do */
        pDriverData->vpp.dwOverlaySrcWidth = dwSrcWidth;
        pDriverData->vpp.dwOverlayDstWidth = dwDstWidth;
        pDriverData->vpp.dwOverlaySrcHeight = dwSrcHeight;
        pDriverData->vpp.dwOverlayDstHeight = dwDstHeight;


#ifndef NVPE
        // cheehoi. Need driver to flip (bMediaPortControl=TRUE) for nv4/5 when
        // media port is used. Only applies to nv4/5????
        if (pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10){
            if (srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT) {
                //if (lpUOData->dwFlags & DDOVER_AUTOFLIP  ||
                //  pDriverData->vpp.dwOverlaySurfaces==1){ //autoflip or 1 ovl.surf.
                    bMediaPortControl = TRUE;
                //}
            }
        }else{
            //nv10. This was leftover from Chris. May not be needed.
            if (srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT) {
                if (lpUOData->dwFlags & DDOVER_AUTOFLIP){
                    bMediaPortControl = TRUE;
                }
            }
        }

        if(pDriverData != 0) {
          if (pDriverData->bRing0FlippingFlag  )  {
            bMediaPortControl = TRUE;
          }
        }

#endif // !NVPE

        if (dwDstWidth <= 1) {
            srcDeltaX = 0x100000;
        } else {
            srcDeltaX = ((dwSrcWidth - 1) << 20) / (dwDstWidth - 1);
        }

        // Align to 2 pixel boundary + 1 for video scaler
//        dwDstWidth = (dwDstWidth + 2) & ~1L;
//        dwDstHeight = (dwDstHeight + 1) & ~1L;

        if (dwDstHeight <= 1) {
            srcDeltaY = 0x100000;
        } else {
            srcDeltaY = ((dwSrcHeight - 1) << 20) / (dwDstHeight - 1);
        }

        // Let the world know what the overlay src info is
        pDriverData->vpp.dwOverlaySrcX = (short)(lpUOData->rSrc.left & ~1);
        pDriverData->vpp.dwOverlaySrcY = (short)lpUOData->rSrc.top;

        // Do 1080i single field fixups if necessary
        if ((pDriverData->bMCOverlaySrcIsSingleField1080i) && (src->ddpfSurface.dwFourCC == FOURCC_NV12)) {
            if (pDriverData->bMCHorizontallyDownscale1080i) {
                dwSrcWidth = (dwSrcWidth * 10) / 18;
                srcDeltaX = ((dwSrcWidth - 1) << 20) / (dwDstWidth - 1);
                pDriverData->vpp.dwOverlaySrcX = (pDriverData->vpp.dwOverlaySrcX * 10) / 18;
            }
            dwSrcHeight >>= 1;
            srcDeltaY = ((dwSrcHeight - 1) << 20) / (dwDstHeight - 1);
            pDriverData->vpp.dwOverlaySrcHeight = dwSrcHeight;
        }

        pDriverData->vpp.dwOverlaySrcSize = asmMergeCoords(dwSrcWidth, dwSrcHeight);

        // Get the video mirror source dimensions
        if (pDriverData->vpp.dwOverlayFSSrcWidth < (DWORD) dwSrcWidth) {
            pDriverData->vpp.dwOverlayFSSrcWidth = dwSrcWidth;
        }
        if (pDriverData->vpp.dwOverlayFSSrcHeight < (DWORD) dwSrcHeight) {
            pDriverData->vpp.dwOverlayFSSrcHeight = dwSrcHeight;
        }
        if (pDriverData->vpp.dwOverlayFSSrcMinX > (DWORD) pDriverData->vpp.dwOverlaySrcX) {
            pDriverData->vpp.dwOverlayFSSrcMinX = pDriverData->vpp.dwOverlaySrcX;
        }
        if (pDriverData->vpp.dwOverlayFSSrcMinY > (DWORD) pDriverData->vpp.dwOverlaySrcY) {
            pDriverData->vpp.dwOverlayFSSrcMinY = pDriverData->vpp.dwOverlaySrcY;
        }

        /* Let the world know what the current overlay destination offset is */
        pDriverData->vpp.dwOverlayDstX = (short)lpUOData->rDest.left;
        pDriverData->vpp.dwOverlayDstY = (short)lpUOData->rDest.top;

        if (pDriverData->vpp.extraNumSurfaces == 0) {
            // VPP pipe is disable, only overlay scaling will be used
            if (dwSrcWidth > (dwDstWidth * (long)pDriverData->vpp.dwOverlayMaxDownScale)) {
                srcDeltaX = 0x100000 * pDriverData->vpp.dwOverlayMaxDownScale;
            }

            if (dwSrcHeight > (dwDstHeight * (long)pDriverData->vpp.dwOverlayMaxDownScale)) {
                srcDeltaY = 0x100000 * pDriverData->vpp.dwOverlayMaxDownScale;
            }
        } else {
            if (!bMediaPortControl)
            {
                if (pDriverData->vpp.dwOverlayMaxDownScaleX <= 1) {
                    // prescaler will be doing all the downscaling
                    if (dwSrcWidth > dwDstWidth) {
                        srcDeltaX = 0x100000;
                    }
                } else {
                    // predict what the cascading downscaler will produce for the overlay scale factor
                    long dwNewSrcWidth = dwSrcWidth;
                    while (dwNewSrcWidth > (dwDstWidth * (long)pDriverData->vpp.dwOverlayMaxDownScaleX)) {
                        dwNewSrcWidth /= 2;
                        srcDeltaX = ((dwNewSrcWidth - 1) << 20) / dwDstWidth;
                    }
                }
                if (pDriverData->vpp.dwOverlayMaxDownScaleY <= 1) {
                    // prescaler will be doing all the downscaling
                    if (dwSrcHeight > dwDstHeight) {
                        srcDeltaY = 0x100000;
                    }
                } else {
                    // predict what the cascading downscaler will produce for the overlay scale factor
                    long dwNewSrcHeight = dwSrcHeight;
                    while (dwNewSrcHeight > (dwDstHeight * (long)pDriverData->vpp.dwOverlayMaxDownScaleY)) {
                        dwNewSrcHeight /= 2;
                        srcDeltaY = ((dwNewSrcHeight - 1) << 20) / dwDstHeight;
                    }
                }
            }
            else
            {
                if (dwSrcWidth > (dwDstWidth * (long)pDriverData->vpp.dwOverlayMaxDownScale))
                {
                    srcDeltaX = 0x100000;
                }

                if (dwSrcHeight > (dwDstHeight * (long)pDriverData->vpp.dwOverlayMaxDownScale))
                {
                    srcDeltaY = 0x100000;
                }
            }

            if (pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) {
                // if HQVUp is enabled, the prescaler will do vertical upscale too
                if ((pDriverData->vpp.regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE) ||
                    (lpUOData->dwFlags & (DDOVER_INTERLEAVED | DDOVER_BOB))) {
                    srcDeltaY = 0x100000;
                }
            }
        }



#define NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_0 (0x04000000)
#define NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_1 (0x02000000)
#define NV_VFM_FORMAT_BOBFROMINTERLEAVE           (0x08000000)

        // color key?
        if (lpUOData->dwFlags & DDOVER_KEYDESTOVERRIDE) {
            DPF( "Dest ColorKey = %08x,%08x",
                lpUOData->overlayFX.dckDestColorkey.dwColorSpaceLowValue,
                lpUOData->overlayFX.dckDestColorkey.dwColorSpaceHighValue );

            // Save this for later reference
            pDriverData->vpp.dwOverlayColorKey =
                lpUOData->overlayFX.dckDestColorkey.dwColorSpaceLowValue;

            dwOverlayFormat |= (NV07A_SET_OVERLAY_FORMAT_COLOR_KEY_MISMATCH_SHOW_IMAGE << 20);

        } else if (lpUOData->dwFlags & DDOVER_KEYDEST) {
            DPF( "Dest ColorKey = %08x,%08x",
                lpUOData->lpDDDestSurface->ddckCKDestOverlay.dwColorSpaceLowValue,
                lpUOData->lpDDDestSurface->ddckCKDestOverlay.dwColorSpaceHighValue );

            // Save this for later reference
            pDriverData->vpp.dwOverlayColorKey =
                lpUOData->lpDDDestSurface->ddckCKDestOverlay.dwColorSpaceLowValue;

            dwOverlayFormat |= (NV07A_SET_OVERLAY_FORMAT_COLOR_KEY_MISMATCH_SHOW_IMAGE << 20);

        } else {    // disable color key
            dwOverlayFormat |= (NV07A_SET_OVERLAY_FORMAT_COLOR_KEY_MISMATCH_SHOW_OVERLAY << 20);
        }

/*
        if(!bMediaPortControl) {
          nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
          nvPushData(1, NV_DD_DMA_OVERLAY);
          nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | NV07A_SET_OVERLAY_COLORKEY(index) | 0x40000);
          nvPushData(3, pDriverData->vpp.dwOverlayColorKey);                                // SetOverlayColorKey
          nvPushData(4, dDrawSubchannelOffset(NV_DD_SPARE) | NV07A_SET_OVERLAY_DU_DX(index) | 0x100000);
          nvPushData(5, srcDeltaX);                                                   // SetOverlayDuDx
          nvPushData(6, srcDeltaY);                                                   // SetOverlayDvDy
          nvPushData(7, asmMergeCoords(lpUOData->rDest.left, lpUOData->rDest.top));   // SetOverlayPointOut
          nvPushData(8, asmMergeCoords((dwDstWidth & ~1), dwDstHeight));              // SetOverlaySizeOut
          nvPusherAdjust(9);
          nvPusherStart(TRUE);
        }
*/
        if (lpUOData->dwFlags & DDOVER_AUTOFLIP)
            index = 0; // overide index for mediaport/overlay autoflip

        if ((src->ddpfSurface.dwFourCC == FOURCC_UYVY) ||
            (src->ddpfSurface.dwFourCC == FOURCC_UYNV)) {

            // we need to know if we're bobbing
          if((srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT)
              && (lpUOData->dwFlags & DDOVER_BOB)
              && (lpUOData->dwFlags & DDOVER_INTERLEAVED) ){
              pDriverData->vpp.dwOverlayMode =  NV_VFM_FORMAT_BOBFROMINTERLEAVE | NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_1;
              DPF( "Video Port Overlay control - Interleaved - BOB");
          } else if((srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT)
              && (lpUOData->dwFlags & DDOVER_BOB)
              ){
              pDriverData->vpp.dwOverlayMode =  NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_1;
              DPF( "Video Port Overlay control - Separate - BOB");
          } else if((srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT)
              ){
              pDriverData->vpp.dwOverlayMode =  NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_1;
              DPF( "Video Port Overlay control - weave or odd or even");
          } else {
              pDriverData->vpp.dwOverlayMode = 0;

          }

          dwOverlayFormat |= (NV07A_SET_OVERLAY_FORMAT_COLOR_LE_YB8CR8YA8CB8 << 16);

        } else {
            dwOverlayFormat |= (NV07A_SET_OVERLAY_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16);
        }

        dwOverlayFormat |= (NV07A_SET_OVERLAY_FORMAT_MATRIX_ITURBT601 << 24);
        // don't know the source pitch yet, let vppFlip update it
//        dwOverlayFormat |= dwSrcPitch;
        dwOverlayFormat |= (NV07A_SET_OVERLAY_FORMAT_NOTIFY_WRITE_ONLY << 31);

        // Let the world know what the overlay format info is
        pDriverData->vpp.dwOverlayFormat = dwOverlayFormat;

        pDriverData->vpp.dwOverlayDeltaX = (DWORD)srcDeltaX;
        pDriverData->vpp.dwOverlayDeltaY = (DWORD)srcDeltaY;

        // all the overlay source information is set in vppFlip
        // no way to convey odd or even field, assume odd if bobbed
        dwVPPFlags = VPP_STATIC | VPP_WAIT;
        if (lpUOData->dwFlags & DDOVER_BOB) {
            dwVPPFlags |= VPP_BOB | VPP_ODD;
        }
        if (lpUOData->dwFlags & DDOVER_INTERLEAVED) {
            dwVPPFlags |= VPP_INTERLEAVED | VPP_ODD;
        }
        if (bMediaPortControl) {
            dwVPPFlags |= VPP_VIDEOPORT;
            pDriverData->vpp.dwOverlaySrcPitch = src->lPitch;

        }  else {
#if (NVARCH >= 0x10)
            if (src->ddpfSurface.dwFourCC == FOURCC_NV12) {
                LPNVMCSURFACEFLAGS lpSurfaceFlags =
                    (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

                while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
                       (lpSurfaceFlags->dwMCSurfaceBase != src->fpVidMem))
                        lpSurfaceFlags++;

                // Make sure the surface has been format converted
                if ((lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) &&
                    (lpSurfaceFlags->bMCFrameAlreadyFormatConverted < 15))
                    nvMoCompConvertSurfaceFormat(src->fpVidMem, TRUE, 15);
                else if ((lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD) &&
                    ((lpSurfaceFlags->bMCFrameAlreadyFormatConverted & 3) < 3))
                    nvMoCompConvertSurfaceFormat(src->fpVidMem, TRUE, 3);
                else if ((lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_BOTTOM_FIELD) &&
                    (lpSurfaceFlags->bMCFrameAlreadyFormatConverted < 12))
                    nvMoCompConvertSurfaceFormat(src->fpVidMem, TRUE, 12);

                if ((lpSurfaceFlags->bMCFrameAlreadyFormatConverted == 15) &&
                    (lpSurfaceFlags->bMCFrameIsFiltered == FALSE) &&
                    (pDriverData->bMCTemporalFilterDisabled == FALSE) &&
                    IS_FIELD(dwVPPFlags))
                    nvMoCompTemporalFilter(src->fpVidMem, pDriverData->bMCPercentCurrentField);

                // Check if filtering is disabled on this surface for this display call only
                if (lpSurfaceFlags->bMCFrameType & TEMPORAL_FILTER_DISABLE_ON_SINGLE_SURFACE) {
                    lpSurfaceFlags->bMCFrameIsFiltered = FALSE;
                    lpSurfaceFlags->bMCFrameType &= ~TEMPORAL_FILTER_DISABLE_ON_SINGLE_SURFACE;
                }

                // Always display non-filtered portion of non-interleaved frames
                if (lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_FRAME)
                    lpSurfaceFlags->bMCFrameIsFiltered = FALSE;

            }
#endif  // (NVARCH >= 0x10)

#ifdef  DEBUG
#if (NVARCH >= 0x010)
            if ((moCompDebugLevel > 0) && (src->ddpfSurface.dwFourCC == FOURCC_NV12)) {
                if (overlaySurfaceBase == 0)
                    overlaySurfaceBase = src->fpVidMem;

                dwVPPFlags &= ~VPP_BOB;
                dwVPPFlags &= ~VPP_ODD;

                VppDoFlip(
                    &(pDriverData->vpp),
                    overlaySurfaceBase - pDriverData->BaseAddress,
                    src->lPitch,
                    src->wWidth,
                    src->wHeight,
                    src->ddpfSurface.dwFourCC,
                    dwVPPFlags);
            }
            else
#endif  // NVARCH >= 0x010
#endif  // DEBUG
            {
                VppDoFlip(&(pDriverData->vpp),
                              src->fpVidMem - pDriverData->BaseAddress,
                              src->lPitch,
                              src->wWidth,
                              src->wHeight,
                              src->ddpfSurface.dwFourCC,
                              dwVPPFlags);
            }
        }

        /* Let DDraw know how many visible overlays are active */
        if (pHalInfo->ddCaps.dwCurrVisibleOverlays == 0) {
            pHalInfo->ddCaps.dwCurrVisibleOverlays = 1;
        }
    }

    pDriverData->dwRingZeroMutex = FALSE;

#ifndef WINNT
    // check for VIA 82C598 north bridge
    if (IS_VIA_MVP3_NB_ID(pDriverData->northBridgeID)) {
        // restore write posting value
        _asm {
                mov edx, 0cf8h
                mov eax, 80000840h
                out dx, eax
                mov edx, 0cfch
                mov eax, dwSavedNBData
                out dx, al
        }
    }
#endif

#ifdef NVPE

    ///// H.AZAR: (10/20/1999): notify VPE kernel of overlay changes !
    if (bMediaPortControl)
        NVPUpdateOverlay(pDriverData, lpUOData->lpDD);
#endif  // #ifdef NVPE

    // We make this call here simply to ensure that the color control
    // values are reset to the values we're holding in pDriverData.
    //
    // There is an outstanding issue which causes zeros to be written
    // sometimes on a modeswitch.  By forcing this here, we update the
    // value very near the 'end' of the overlay rebuild process (just before
    // show) so we're likely to overwrite the zeros.
    //
    // The proper fix of course is to determine what part of the system is
    // writing the zeros.  Refer to BUG #20000807-184148
    //
    if (!bMediaPortControl) {
    VppSetOverlayColourControl(&(pDriverData->vpp));
    }

    NvReleaseSemaphore(pDriverData);
    lpUOData->ddRVal = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;

} /* UpdateOverlay32 */


/*
 * SetOverlayPosition32
 */
DWORD __stdcall
SetOverlayPosition32( LPDDHAL_SETOVERLAYPOSITIONDATA lpSOPData )
{
    NvNotification              *pPioFlipOverlayNotifier;
    DWORD                       index = 0;
    DWORD                       match = 0;
    LPDDRAWI_DDRAWSURFACE_LCL   srcx = lpSOPData->lpDDSrcSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   src = srcx->lpGbl;
    BOOL                        bMediaPortControl = FALSE;

    dbgTracePush ("SetOverlayPosition32");

    nvSetDriverDataPtrFromDDGbl (lpSOPData->lpDD);

    pPioFlipOverlayNotifier = pDriverData->pPioFlipOverlayNotifierFlat;

    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_TWINVIEW_STATE_CHANGE) {
        VppDestroyFSMirror(&pDriverData->vpp);
        VppDestroyOverlay(&pDriverData->vpp);
        ResetTwinViewState(pDriverData);
        VppCreateOverlay(&pDriverData->vpp);
        VppCreateFSMirror(&pDriverData->vpp, pDriverData->vpp.dwOverlayFSSrcWidth, pDriverData->vpp.dwOverlayFSSrcHeight);
    }

    if (!(srcx->ddsCaps.dwCaps & DDSCAPS_OVERLAY)) {
            NvReleaseSemaphore(pDriverData);
            lpSOPData->ddRVal = DDERR_NOTAOVERLAYSURFACE;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
    }

    if ((lpSOPData->lXPos < 0) || (lpSOPData->lYPos < 0)) {
            NvReleaseSemaphore(pDriverData);
            lpSOPData->ddRVal = DDERR_INVALIDPOSITION;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
    }

    while ((index < NV_VPP_MAX_OVERLAY_SURFACES) && (!match))
        if ((DWORD)srcx == pDriverData->vpp.dwOverlaySurfaceLCL[index++])
            match = 1;

    if (!match) {
        // Do some DirectShow compatibility stuff
        if ((src->ddpfSurface.dwFourCC == FOURCC_NVMC) || (src->ddpfSurface.dwFourCC == FOURCC_NVDS)) {
#if (NVARCH >= 0x10)
            LPNVMCFRAMEDATA lpNvMCFrameData = (LPNVMCFRAMEDATA) VIDMEM_ADDR(src->fpVidMem);
            DWORD dwIndex = lpNvMCFrameData->bMCDestinationSurfaceIndex;
            nvAssert (dwIndex < 8);
            srcx = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNV12Surface[dwIndex];
            nvAssert (srcx);
            src = srcx->lpGbl;
#endif  // NVARCH >= 0x10
        } else {
            NvReleaseSemaphore(pDriverData);
            lpSOPData->ddRVal = DDERR_OUTOFCAPS;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    }

#if 0
    // This code will eventually be used to specially opt out of overlay stuff when video port is in use
    if( srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT)  {

        lpUOData->ddRVal = HandleVideoPortOverlayPosition( lpSOPData);
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return DDHAL_DRIVER_HANDLED;

    }
#endif //

    if (srcx->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT)  {
        bMediaPortControl = TRUE;
    }

    if (pDriverData != 0) {
        if (pDriverData->bRing0FlippingFlag)  {
            bMediaPortControl = TRUE;
        }
    }

    getDC()->nvPusher.waitForOtherChannels();

    if ((getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) ||     /* Mode switches might occur without warning */
        pDriverData->vpp.dwOverlayFSOvlLost) {

        NvReleaseSemaphore(pDriverData);
        lpSOPData->ddRVal = DDERR_SURFACELOST;
        dbgTracePop();
        return DDHAL_DRIVER_HANDLED;
    }

    /*
     * NOTES:
     * This callback is invoked to set an overlay position
     */
    DPF( "SET OVERLAY POSITION" );
    DPF( "Overlay surface = %08x", lpSOPData->lpDDSrcSurface );
    DPF( "(%d,%d)", lpSOPData->lXPos, lpSOPData->lYPos );

    pDriverData->dwRingZeroMutex = TRUE;

    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_DDRAW) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvDDrawRecover();
        } else {
            lpSOPData->ddRVal = DDERR_SURFACEBUSY;
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    }

    /* Let the world know what the current overlay destination offset is */
    pDriverData->vpp.dwOverlayDstX = (short)lpSOPData->lXPos;
    pDriverData->vpp.dwOverlayDstY = (short)lpSOPData->lYPos;

    // Direct Access to VPP object! -@mjl@
    nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
    nvPushData(1, NV_VPP_OVERLAY_IID);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | NV07A_SET_OVERLAY_POINT_OUT_A | 0x40000);
    nvPushData(3, asmMergeCoords(lpSOPData->lXPos, lpSOPData->lYPos));  // SetOverlayPointOutA
    nvPusherAdjust(4);
    nvPusherStart(TRUE);

    pDriverData->dwRingZeroMutex = FALSE;

    pDriverData->dDrawSpareSubchannelObject = 0;

    NvReleaseSemaphore(pDriverData);
    lpSOPData->ddRVal = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;

} /* SetOverlayPosition32 */


//---------------------------------------------------------------------------
#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\ddSurf.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//  Content:    DirectDraw HAL surface management
//
//  History:
//        schaefer           7/6/99
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

#include "nvOverlaySurf.h"  // For creation of FOURCC and overlay surfaces
#ifdef VPEFSMIRROR
#include "nvpkrnl.h" // for VPE FS Mirror
#endif

#ifdef WINNT
#include "nvMultiMon.h"
#endif

#ifdef WINNT
extern "C"
{
    extern void __cdecl NV_OglDDrawSurfaceCreated(PDEV *ppdev);
    extern void __cdecl NV_OglDDrawSurfaceDestroyed(PDEV *ppdev);
}
#define NV_OGLDDRAWSURFACECREATED(PDEV) NV_OglDDrawSurfaceCreated((PDEV))
#define NV_OGLDDRAWSURFACEDESTROYED(PDEV) NV_OglDDrawSurfaceDestroyed((PDEV))
#else
#define NV_OGLDDRAWSURFACECREATED(PDEV)
#define NV_OGLDDRAWSURFACEDESTROYED(PDEV)
#endif

#ifdef DEBUG_SURFACE_PLACEMENT
extern CSurfaceDebug csd;
#endif

// getDisplayDuration
//
// get the length (in ticks) of a refresh cycle
void getDisplayDuration( void )
{
#ifdef WINNT
    DWORD dwHead;
    NV_CFGEX_GET_REFRESH_INFO_PARAMS refreshInfo;
    __int64 timeFrequency;

    dbgTracePush ("getDisplayDuration");

    // for the most part inactive for win2k
    getDC()->flipPrimaryRecord.fpFlipFrom = 0xDEADBEEF;

    // we need this stuff for the back door CRTC synchronized blits

    // determine which head is the default
    dwHead = GET_CURRENT_HEAD();

    // get and save CRTC params
    getDC()->flipPrimaryRecord.nvTimingInfo[dwHead].Head = dwHead;
    getDC()->flipPrimaryRecord.nvTimingInfo[dwHead].Reg = NV_CFGEX_CRTC_TIMING_REGISTER;
    if (NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE,
                        NV_CFGEX_CRTC_TIMING_MULTI,
                        &getDC()->flipPrimaryRecord.nvTimingInfo[dwHead],
                        sizeof(NV_CFGEX_CRTC_TIMING_PARAMS)) != NVOS_CGE_STATUS_SUCCESS) {
        // error, this structure is invalid
        getDC()->flipPrimaryRecord.nvTimingInfo[dwHead].Head = 0xFFFFFFFF;
    }

    // get refresh rate
    refreshInfo.Head = dwHead;
    refreshInfo.ulState = 0;
    if (NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE,
                        NV_CFGEX_GET_REFRESH_INFO,
                        &refreshInfo,
                        sizeof(NV_CFGEX_GET_REFRESH_INFO_PARAMS)) != NVOS_CGE_STATUS_SUCCESS) {
        // error can find refresh rate
        getDC()->flipPrimaryRecord.llFlipDurationNs[dwHead] = 0;
    } else {
        if (refreshInfo.ulRefreshRate) {
            getDC()->flipPrimaryRecord.llFlipDurationNs[dwHead] = (LONGLONG)1000000000 / (LONGLONG)refreshInfo.ulRefreshRate;
        } else {
            getDC()->flipPrimaryRecord.llFlipDurationNs[dwHead] = 0;
        }
    }

    // calculate flip duration in units of ticks
    EngQueryPerformanceFrequency(&timeFrequency);
    getDC()->flipPrimaryRecord.dwFlipDuration = (unsigned long)(timeFrequency * getDC()->flipPrimaryRecord.llFlipDurationNs[dwHead] / 1000000000);

    // get and save CRTC params for the other head
    if ((ppdev->ulDesktopMode & NV_TWO_DACS) &&
       ((ppdev->ulDesktopMode & NV_CLONE_DESKTOP) ||
        (ppdev->ulDesktopMode & NV_SPANNING_MODE))) {
        // we are in a TwinView mode, get the CRTC params for the other head too
        dwHead ^= 1;
        getDC()->flipPrimaryRecord.nvTimingInfo[dwHead].Head = dwHead;
        getDC()->flipPrimaryRecord.nvTimingInfo[dwHead].Reg = NV_CFGEX_CRTC_TIMING_REGISTER;
        if (NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE,
                            NV_CFGEX_CRTC_TIMING_MULTI,
                            &getDC()->flipPrimaryRecord.nvTimingInfo[dwHead],
                            sizeof(NV_CFGEX_CRTC_TIMING_PARAMS)) != NVOS_CGE_STATUS_SUCCESS) {
            // error, this structure is invalid
            getDC()->flipPrimaryRecord.nvTimingInfo[dwHead].Head = 0xFFFFFFFF;
        }

        // get refresh rate
        refreshInfo.Head = dwHead;
        refreshInfo.ulState = 0;
        if (NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE,
                            NV_CFGEX_GET_REFRESH_INFO,
                            &refreshInfo,
                            sizeof(NV_CFGEX_GET_REFRESH_INFO_PARAMS)) != NVOS_CGE_STATUS_SUCCESS) {
            // error can find refresh rate
            getDC()->flipPrimaryRecord.llFlipDurationNs[dwHead] = 0;
        } else {
            if (refreshInfo.ulRefreshRate) {
                getDC()->flipPrimaryRecord.llFlipDurationNs[dwHead] = (LONGLONG)1000000000 / (LONGLONG)refreshInfo.ulRefreshRate;
            } else {
                getDC()->flipPrimaryRecord.llFlipDurationNs[dwHead] = 0;
            }
        }

    } else {
        getDC()->flipPrimaryRecord.nvTimingInfo[dwHead ^ 1].Head = 0xFFFFFFFF;
        getDC()->flipPrimaryRecord.llFlipDurationNs[dwHead ^ 1] = 0;
    }
#else
#define IS_IN_VBLANK(a) ((a)==0 || (a)>=GET_MODE_PHYSICAL_HEIGHT(cfgParams.Head))
    int         i;
    __int64     start, end;
    DWORD       oldclass;
    HANDLE      hprocess;
    NV_CFGEX_CURRENT_SCANLINE_MULTI_PARAMS cfgParams;
    BOOL timeOut;

    dbgTracePush ("getDisplayDuration");

    memset( &getDC()->flipPrimaryRecord, 0, sizeof( getDC()->flipPrimaryRecord ) );
    memset( &getDC()->flipOverlayRecord, 0, sizeof( getDC()->flipOverlayRecord ) );

    NVTWINVIEWDATA twinData;
    LONGLONG timeFrequency;
    // RM needs physical head, map logical to physical
    twinData.dwFlag   = NVTWINVIEW_FLAG_GET;
    twinData.dwAction = NVTWINVIEW_ACTION_MAP_LOG_TO_PHYS_HEAD;
    twinData.dwCrtc   = pDXShare->dwHeadNumber;
    MyExtEscape(pDXShare->dwHeadNumber, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPCSTR) &twinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &twinData);
    cfgParams.Head    = twinData.dwCrtc;
    // get start time for timeouts (display may be disabled)
    QueryPerformanceFrequency((LARGE_INTEGER *)&timeFrequency);

    // get and save CRTC params
    getDC()->flipPrimaryRecord.nvTimingInfo[cfgParams.Head].Head = cfgParams.Head;
    getDC()->flipPrimaryRecord.nvTimingInfo[cfgParams.Head].Reg = NV_CFGEX_CRTC_TIMING_REGISTER;
    if (NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE,
                        NV_CFGEX_CRTC_TIMING_MULTI,
                        &getDC()->flipPrimaryRecord.nvTimingInfo[cfgParams.Head],
                        sizeof(NV_CFGEX_CRTC_TIMING_PARAMS)) != NVOS_CGE_STATUS_SUCCESS) {
        // error, this structure is invalid
        getDC()->flipPrimaryRecord.nvTimingInfo[cfgParams.Head].Head = 0xFFFFFFFF;
    }

    hprocess = GetCurrentProcess();
    oldclass = GetPriorityClass( hprocess );
//    SetPriorityClass( hprocess, REALTIME_PRIORITY_CLASS ); Can't do this due to Electronic Arts bug in Triple Play 97
    SetPriorityClass( hprocess, HIGH_PRIORITY_CLASS );

    NvRmConfigGetEx (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                     NV_CFGEX_CURRENT_SCANLINE_MULTI, &cfgParams, sizeof(cfgParams));
    timeOut = FALSE;
    QueryPerformanceCounter((LARGE_INTEGER*)&start);
    while (!IS_IN_VBLANK(cfgParams.RasterPosition) && !timeOut) {
        NvRmConfigGetEx (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                         NV_CFGEX_CURRENT_SCANLINE_MULTI, &cfgParams, sizeof(cfgParams));
        LONGLONG timeNow;
        QueryPerformanceCounter((LARGE_INTEGER*)&timeNow);
        if ((timeNow - start) >= (timeFrequency / 20)) timeOut = TRUE;  // timout of 1/20th of a second
    }

    QueryPerformanceCounter((LARGE_INTEGER*)&start);
    #define LOOP_CNT    20
    for ( i=0;i<LOOP_CNT;i++ ) {
        NvRmConfigGetEx (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                         NV_CFGEX_CURRENT_SCANLINE_MULTI, &cfgParams, sizeof(cfgParams));
        while (IS_IN_VBLANK(cfgParams.RasterPosition) && !timeOut) {
            NvRmConfigGetEx (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                             NV_CFGEX_CURRENT_SCANLINE_MULTI, &cfgParams, sizeof(cfgParams));
            LONGLONG timeNow;
            QueryPerformanceCounter((LARGE_INTEGER*)&timeNow);
            if ((timeNow - start) >= timeFrequency) timeOut = TRUE;  // timout of 1/20th of a second
        }
        while (!IS_IN_VBLANK(cfgParams.RasterPosition) && !timeOut) {
            NvRmConfigGetEx (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                             NV_CFGEX_CURRENT_SCANLINE_MULTI, &cfgParams, sizeof(cfgParams));
            LONGLONG timeNow;
            QueryPerformanceCounter((LARGE_INTEGER*)&timeNow);
            if ((timeNow - start) >= timeFrequency) timeOut = TRUE;  // timout of 1/20th of a second
        }
    }
    QueryPerformanceCounter((LARGE_INTEGER*)&end);

    SetPriorityClass( hprocess, oldclass );
    getDC()->flipPrimaryRecord.dwFlipDuration = ((DWORD)(end-start) + LOOP_CNT/2)/LOOP_CNT;

    GET_HALINFO()->dwMonitorFrequency = (DWORD)start / getDC()->flipPrimaryRecord.dwFlipDuration;

    getDC()->flipPrimaryRecord.llFlipDurationNs[cfgParams.Head] = (LONGLONG)getDC()->flipPrimaryRecord.dwFlipDuration * 1000000000 / timeFrequency;

    // get and save CRTC params for the other head
    if (pDriverData->dwHeads > 1 &&
       (pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE ||
        pDriverData->dwDesktopState == NVTWINVIEW_STATE_DUALVIEW)) {
        // we are in a TwinView mode, get the CRTC params for the other head too
        cfgParams.Head ^= 1;
        getDC()->flipPrimaryRecord.nvTimingInfo[cfgParams.Head].Head = cfgParams.Head;
        getDC()->flipPrimaryRecord.nvTimingInfo[cfgParams.Head].Reg = NV_CFGEX_CRTC_TIMING_REGISTER;
        if (NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE,
                            NV_CFGEX_CRTC_TIMING_MULTI,
                            &getDC()->flipPrimaryRecord.nvTimingInfo[cfgParams.Head],
                            sizeof(NV_CFGEX_CRTC_TIMING_PARAMS)) != NVOS_CGE_STATUS_SUCCESS) {
            // error, this structure is invalid
            getDC()->flipPrimaryRecord.nvTimingInfo[cfgParams.Head].Head = 0xFFFFFFFF;
        }

        // need to do all the timing for the other head
        SetPriorityClass( hprocess, HIGH_PRIORITY_CLASS );

        NvRmConfigGetEx (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                         NV_CFGEX_CURRENT_SCANLINE_MULTI, &cfgParams, sizeof(cfgParams));
        timeOut = FALSE;
        QueryPerformanceCounter((LARGE_INTEGER*)&start);
        while (!IS_IN_VBLANK(cfgParams.RasterPosition) && !timeOut) {
            NvRmConfigGetEx (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                             NV_CFGEX_CURRENT_SCANLINE_MULTI, &cfgParams, sizeof(cfgParams));
            LONGLONG timeNow;
            QueryPerformanceCounter((LARGE_INTEGER*)&timeNow);
            if ((timeNow - start) >= (timeFrequency / 20)) timeOut = TRUE;  // timout of 1/20th of a second
        }

        QueryPerformanceCounter((LARGE_INTEGER*)&start);
        for ( i=0;i<LOOP_CNT;i++ ) {
            NvRmConfigGetEx (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                             NV_CFGEX_CURRENT_SCANLINE_MULTI, &cfgParams, sizeof(cfgParams));
            while (IS_IN_VBLANK(cfgParams.RasterPosition) && !timeOut) {
                NvRmConfigGetEx (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                                 NV_CFGEX_CURRENT_SCANLINE_MULTI, &cfgParams, sizeof(cfgParams));
                LONGLONG timeNow;
                QueryPerformanceCounter((LARGE_INTEGER*)&timeNow);
                if ((timeNow - start) >= timeFrequency) timeOut = TRUE;  // timout of 1/20th of a second
            }
            while (!IS_IN_VBLANK(cfgParams.RasterPosition) && !timeOut) {
                NvRmConfigGetEx (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                                 NV_CFGEX_CURRENT_SCANLINE_MULTI, &cfgParams, sizeof(cfgParams));
                LONGLONG timeNow;
                QueryPerformanceCounter((LARGE_INTEGER*)&timeNow);
                if ((timeNow - start) >= timeFrequency) timeOut = TRUE;  // timout of 1/20th of a second
            }
        }
        QueryPerformanceCounter((LARGE_INTEGER*)&end);

        SetPriorityClass( hprocess, oldclass );
        getDC()->flipPrimaryRecord.llFlipDurationNs[cfgParams.Head] = (LONGLONG)(((DWORD)(end-start) + LOOP_CNT/2)/LOOP_CNT) * 1000000000 / timeFrequency;

    } else {
        getDC()->flipPrimaryRecord.nvTimingInfo[cfgParams.Head ^ 1].Head = 0xFFFFFFFF;
        getDC()->flipPrimaryRecord.llFlipDurationNs[cfgParams.Head ^ 1] = 0;
    }

#ifdef DEBUG
    QueryPerformanceFrequency((LARGE_INTEGER*)&start);

    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "Duration = %d ticks, %dms, %dHz",
         getDC()->flipPrimaryRecord.dwFlipDuration,
         getDC()->flipPrimaryRecord.dwFlipDuration * 1000 / (DWORD)start,
         (DWORD)start / getDC()->flipPrimaryRecord.dwFlipDuration);
#endif // DEBUG

#endif // !WINNT

    dbgTracePop();

} // getDisplayDuration

//---------------------------------------------------------------------------
//
//  CreateSurface helper routines
//
//---------------------------------------------------------------------------

BOOL nvCalculateColorKey (DWORD *pColorKey, LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl, DWORD dwFormat)
{
    dbgTracePush ("nvCalculateColorKey");

    if (pDDSLcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT)
    {
        switch (dwFormat)
        {
            case NV_SURFACE_FORMAT_Y8:
            case NV_SURFACE_FORMAT_A1R5G5B5:
            case NV_SURFACE_FORMAT_A4R4G4B4:
            case NV_SURFACE_FORMAT_R5G6B5:
                // Must assume the application does the right thing here and passes
                // in the exact color key value as is in the texture map. If the alpha
                // bits are masked here, WHQL will fail.
                *pColorKey = pDDSLcl->ddckCKSrcBlt.dwColorSpaceHighValue & 0x0000FFFF;
                break;
            case NV_SURFACE_FORMAT_X1R5G5B5:
            case NV_SURFACE_FORMAT_DXT1_A1R5G5B5:
                *pColorKey = pDDSLcl->ddckCKSrcBlt.dwColorSpaceHighValue & 0x00007FFF;
                break;
            case NV_SURFACE_FORMAT_A8R8G8B8:
            case NV_SURFACE_FORMAT_X8R8G8B8:
            case NV_SURFACE_FORMAT_DXT23_A8R8G8B8:
            case NV_SURFACE_FORMAT_DXT45_A8R8G8B8:
                *pColorKey = pDDSLcl->ddckCKSrcBlt.dwColorSpaceHighValue;
                break;
            case NV_SURFACE_FORMAT_I8_A8R8G8B8:
                if ((GET_PNVOBJ(pDDSLcl))
                 && (GET_PNVOBJ(pDDSLcl)->getTexture())
                 && (GET_PNVOBJ(pDDSLcl)->getTexture()->hasAutoPalette())
                 && (GET_PNVOBJ(pDDSLcl)->getTexture()->getOriginalFormat() == NV_SURFACE_FORMAT_X8R8G8B8))
                {
                    *pColorKey = pDDSLcl->ddckCKSrcBlt.dwColorSpaceHighValue | 0xFF000000; // fix colour-key alpha
                } else {
                    *pColorKey = pDDSLcl->ddckCKSrcBlt.dwColorSpaceHighValue;
                }
                break;
            default:
                DPF ("unhandled texture format %d in nvCalculateColorKey", dwFormat);
                nvAssert(0);
                dbgTracePop();
                return FALSE;
                break;
        }  // switch

        dbgTracePop();
        return TRUE;
    }

    dbgTracePop();
    return FALSE;
}

//---------------------------------------------------------------------------

DWORD nvCalculateZBufferParams (LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl,
                                DWORD *pFormat, DWORD *pWidth, DWORD *pHeight, DWORD *pMultiSampleBits,
                                DWORD *pBPPRequested, DWORD *pBPPGranted, DWORD *pPitch)
{
    DWORD dwRenderDepth, dwZDepth;

    dbgTracePush ("nvCalculateZBufferParams");

#ifndef WINNT
    // on WIN2K this flag is undefined at this point
    nvAssert (pDDSLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT);
#endif

    // i contend that this will always be set. please let me know
    // if this assertion ever fails... CRD
    // (CRD note to self: if no failure, consolidate with other calc routine,
    // add param to (dis)allow BPP munging. FALSE for sys, true for vid)
    nvAssert (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_ZBUFFER);

    dwRenderDepth = GET_MODE_BPP();

    if (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_ZBUFFER) {
        dwZDepth = pDDSLcl->lpGbl->ddpfSurface.dwZBufferBitDepth;
    }
    else {
        dwZDepth = dwRenderDepth;
    }

    // treat 24 and 32 bits as synonymous
    if (dwZDepth == 24) dwZDepth = 32;

    // we only allow 16- and 32-bit z-buffers
    if ((dwZDepth != 16) &&
        (dwZDepth != 32)) {
        DPF ("unsupported zeta depth in nvCalculateZBufferParams");
        dbgTracePop();
        return (DDERR_INVALIDPIXELFORMAT);
    }

    // ideally we want to always be strict if this is a DX7 app, but we have
    // no way of telling what kind of app this is in this context
    if ((getDC()->nvD3DRegistryData.regValidateZMethod == D3D_REG_VALIDATEZMETHOD_STRICT) &&
        (dwRenderDepth != dwZDepth)) {
        dbgTracePop();
        return (DDERR_INVALIDPIXELFORMAT);
    }

    *pBPPRequested = dwZDepth >> 3;

    if ((*pBPPRequested == 4)
     || (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)
     || (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_1196_CELSIUS)) {
        // if they requested 32 bits or we have kelvin or an nv11, they get what they want
        *pBPPGranted = *pBPPRequested;
    }
    else {
        // on non-mixed buffer hardware, grant a z buffer compatible with the render target
        *pBPPGranted = (dwRenderDepth > 16) ? 4 : 2;
    }

    *pWidth  = pDDSLcl->lpGbl->wWidth;
    *pHeight = pDDSLcl->lpGbl->wHeight;

    *pPitch  = *pBPPGranted * *pWidth;
    *pPitch = (*pPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;

    if (*pBPPGranted == 2) {
        *pFormat = NV_SURFACE_FORMAT_Z16;
    }
    else {  // *pBPPGranted = 4
        if (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_STENCILBUFFER) {
            *pFormat = NV_SURFACE_FORMAT_Z24S8;
        }
        else {
            *pFormat = NV_SURFACE_FORMAT_Z24X8;
        }
    }

    // Multisampling surfaces
    *pMultiSampleBits = pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps3 & DDSCAPS3_MULTISAMPLE_MASK;

    dbgTracePop();
    return (DD_OK);
}

//---------------------------------------------------------------------------

DWORD nvCalculateSurfaceParams (LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl,
                                DWORD *pFormat, BOOL *bFourCC,
                                DWORD *pWidth, DWORD *pHeight, DWORD *pDepth,
                                DWORD *pMultiSampleBits,
                                DWORD *pBPPRequested, DWORD *pBPPGranted,
                                DWORD *pPitch, DWORD *pSlicePitch, BOOL bComputePitch /* rather than extracting it */)
{
    DWORD dwBitCount, dwAlphaMask, dwRedMask, dwLumMask;
    BOOL  bIsDXT = FALSE;

    dbgTracePush ("nvCalculateSurfaceParams");

    // take care of execute buffers first
    if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER) {
        *pFormat       = 0;
        *bFourCC       = FALSE;
        *pWidth        = pDDSLcl->lpGbl->dwLinearSize;
        *pHeight       = 1;
        *pDepth        = 1;
        *pMultiSampleBits = 0;
        *pBPPRequested = 0;
        *pBPPGranted   = 0;
        *pPitch        = *pWidth;
        dbgTracePop();
        return (DD_OK);
    }

    // error message setup
#ifdef DEBUG
    const char *pErrMsg = NULL;
    #define ERRMSG(str) (pErrMsg = str)
#else
    #define ERRMSG(str) //no-op
#endif

    // determine surface format, BPP, and fourCC'ness according to surface type

#ifdef WINNT
    // under WIN2K the DDRAWISURF_HASPIXELFORMAT flag is undefined and implied to be set
    // use the display bit depth when getting a request for an 8 bit surface,
    // this allows the 8 bit DCT AGP Blit tests to run
    if (!((pDDSLcl->lpGbl->ddpfSurface.dwRGBBitCount == 8) && (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_RGB) && !(pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_PALETTEINDEXED8))) {
#else
    if (pDDSLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) {
#endif

        // if we have a pixel format, we must be either RGB, fourCC, or a zbuffer

        if ((pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_RGB) ||
            (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_FOURCC) && (pDDSLcl->lpGbl->ddpfSurface.dwFourCC == FOURCC_RGB0)) {

            // find the bit count, the alpha mask, and the red mask.
            // these are sufficient to infer the surface format

            dwBitCount  = pDDSLcl->lpGbl->ddpfSurface.dwRGBBitCount;
            dwAlphaMask = (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_ALPHAPIXELS) ?
                           pDDSLcl->lpGbl->ddpfSurface.dwRGBAlphaBitMask : 0;
            dwRedMask   = pDDSLcl->lpGbl->ddpfSurface.dwRBitMask;

            // derive an nv format from the bit count and masks

            if ((dwBitCount == 32) || (dwBitCount == 24)) {
                switch (dwAlphaMask) {
                    case 0x00000000:
#ifdef SPOOF_ALPHA
                        if ((pDDSLcl->ddsCaps.dwCaps & DDSCAPS_3DDEVICE) && !(pDDSLcl->ddsCaps.dwCaps & (DDSCAPS_TEXTURE | DDSCAPS_OFFSCREENPLAIN))) {
                            *pFormat = NV_SURFACE_FORMAT_A8R8G8B8;
                        } else {
                            *pFormat = NV_SURFACE_FORMAT_X8R8G8B8;
                        }

#else
                        *pFormat = NV_SURFACE_FORMAT_X8R8G8B8;
#endif
                        break;
                    case 0x7F000000:
                        *pFormat = NV_SURFACE_FORMAT_X1A7R8G8B8;
                        break;
                    case 0xFF000000:
                        *pFormat = NV_SURFACE_FORMAT_A8R8G8B8;
                        break;
                    default:
                        ERRMSG( "invalid %02ld bpp surface format!! [RGB]" );
                        goto bad_fmt_exit;
                }
                *pBPPRequested = *pBPPGranted = 4;
            }

            else if (dwBitCount == 16) {
                switch (dwAlphaMask) {
                    case 0x00000000:
                        if (dwRedMask == 0x7C00) {
                            *pFormat = NV_SURFACE_FORMAT_X1R5G5B5;
                        }
                        else {
                            // dwRedMask == 0xF800
                            *pFormat = NV_SURFACE_FORMAT_R5G6B5;
                        }
                        break;
                    case 0x00008000:
                        *pFormat = NV_SURFACE_FORMAT_A1R5G5B5;
                        break;
                    case 0x0000F000:
                        *pFormat = NV_SURFACE_FORMAT_A4R4G4B4;
                        break;
                    default:
                        ERRMSG( "invalid 16 bpp surface format!! [RGB]" );
                        goto bad_fmt_exit;
                }
                *pBPPRequested = *pBPPGranted = 2;
            }

            else if ((dwBitCount == 8) && (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_PALETTEINDEXED8)) {
                *pFormat = NV_SURFACE_FORMAT_I8_A8R8G8B8;  // Indexed format
                *pBPPRequested = *pBPPGranted = 1;
            }

            else {
                ERRMSG( "invalid %02ld bpp surface format!! [fallthru]" );
                goto bad_fmt_exit;
            }

            *bFourCC = FALSE;

        }

        else if (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_BUMPDUDV) {

            dwBitCount = pDDSLcl->lpGbl->ddpfSurface.dwBumpBitCount;
            dwLumMask  = (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_BUMPLUMINANCE) ?
                         pDDSLcl->lpGbl->ddpfSurface.dwBumpLuminanceBitMask : 0;

            if (dwBitCount == 16) {
                *pFormat = (dwLumMask == 0) ? NV_SURFACE_FORMAT_DV8DU8 : NV_SURFACE_FORMAT_L6DV5DU5;
                *pBPPRequested = *pBPPGranted = 2;
            }
//            else if (dwBitCount == 24) {
//                *pFormat = NV_SURFACE_FORMAT_X8L8DV8DU8;
//                *pBPPRequested = *pBPPGranted = 3;
//            }
            else if (dwBitCount == 32) {
                *pFormat = NV_SURFACE_FORMAT_X8L8DV8DU8;
                *pBPPRequested = *pBPPGranted = 4;
            } else {
                // Invalid bitdepth
                ERRMSG( "nvCalculateSurfaceParams - invalid Bump map dUdV format!" );
                goto bad_fmt_exit;
            }

            *bFourCC = FALSE;

        }

        else if (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_FOURCC) {

            // query the fourcc list
            switch (pDDSLcl->lpGbl->ddpfSurface.dwFourCC) {
                case FOURCC_RGB0:
                    // we should handle this case with regular rgb surfaces
                    nvAssert (0);
                    break;
                case FOURCC_NVT0:
                case FOURCC_NVS0:
                    *pFormat = NV_SURFACE_FORMAT_X1R5G5B5;
                    *pBPPRequested = 2;
                    SET_GBL_SURFACE_DATA (pDDSLcl,DDPF_RGB,16,0x7C00,0x03E0,0x001F,0x0000);
                    break;
                case FOURCC_NVT1:
                case FOURCC_NVS1:
                    *pFormat = NV_SURFACE_FORMAT_A1R5G5B5;
                    *pBPPRequested = 2;
                    SET_GBL_SURFACE_DATA (pDDSLcl,(DDPF_RGB|DDPF_ALPHAPIXELS),16,0x7C00,0x03E0,0x001F,0x8000);
                    break;
                case FOURCC_NVT2:
                case FOURCC_NVS2:
                    *pFormat = NV_SURFACE_FORMAT_A4R4G4B4;
                    *pBPPRequested = 2;
                    SET_GBL_SURFACE_DATA (pDDSLcl,(DDPF_RGB|DDPF_ALPHAPIXELS),16,0x0F00,0x00F0,0x000F,0xF000);
                    break;
                case FOURCC_NVT3:
                case FOURCC_NVS3:
                    *pFormat = NV_SURFACE_FORMAT_R5G6B5;
                    *pBPPRequested = 2;
                    SET_GBL_SURFACE_DATA (pDDSLcl,DDPF_RGB,16,0xF800,0x07E0,0x001F,0x0000);
                    break;
                case FOURCC_NVT4:
                case FOURCC_NVS4:
                    *pFormat = NV_SURFACE_FORMAT_X8R8G8B8;
                    *pBPPRequested = 4;
                    SET_GBL_SURFACE_DATA (pDDSLcl,DDPF_RGB,32,0x00FF0000,0x0000FF00,0x000000FF,0x00000000);
                    break;
                case FOURCC_NVT5:
                case FOURCC_NVS5:
                    *pFormat = NV_SURFACE_FORMAT_A8R8G8B8;
                    *pBPPRequested = 4;
                    SET_GBL_SURFACE_DATA (pDDSLcl,(DDPF_RGB|DDPF_ALPHAPIXELS),32,0x00FF0000,0x0000FF00,0x000000FF,0xFF000000);
                    break;
#ifdef TEXFORMAT_CRD // --------------------------------
                case FOURCC_NVHU:
                    *pFormat = NV_SURFACE_FORMAT_HILO_1_V16U16;
                    *pBPPRequested = 4;
                    break;
                case FOURCC_NVHS:
                    *pFormat = NV_SURFACE_FORMAT_HILO_HEMI_V16U16;
                    *pBPPRequested = 4;
                    break;
#else // !TEXFORMAT_CRD  --------------------------------
#if defined(HILO_SUPPORT_DX7) || defined(HILO_SUPPORT_DX8)
                case FOURCC_NVHU:
                    *pFormat = NV_SURFACE_FORMAT_HILO_1_V16U16;
                    *pBPPRequested = 4;
                    break;
                case FOURCC_NVHS:
                    *pFormat = NV_SURFACE_FORMAT_HILO_HEMI_V16U16;
                    *pBPPRequested = 4;
                    break;
#endif
#endif // !TEXFORMAT_CRD  --------------------------------
                case D3DFMT_Q8W8V8U8:
                    *pFormat = NV_SURFACE_FORMAT_A8B8G8R8;
                    *pBPPRequested = 4;
                    break;
                case FOURCC_DXT1:
                    *pFormat = NV_SURFACE_FORMAT_DXT1_A1R5G5B5;
                    *pBPPRequested = 8;
                    bIsDXT = TRUE;
                    break;
                case FOURCC_DXT2:
                case FOURCC_DXT3:
                    *pFormat = NV_SURFACE_FORMAT_DXT23_A8R8G8B8;
                    *pBPPRequested = 16;
                    bIsDXT = TRUE;
                    break;
                case FOURCC_DXT4:
                case FOURCC_DXT5:
                    *pFormat = NV_SURFACE_FORMAT_DXT45_A8R8G8B8;
                    *pBPPRequested = 16;
                    bIsDXT = TRUE;
                    break;
                default:
                    // Invalid pixel format. Return the error.
                    ERRMSG( "nvCalculateSurfaceParams - invalid 4cc format!" );
                    goto bad_fmt_exit;
            }  // switch

            *pBPPGranted = *pBPPRequested;
            *bFourCC = TRUE;

        }

        else if (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_ZBUFFER) {

            DWORD dwRetVal = nvCalculateZBufferParams (pDDSLcl, pFormat, pWidth, pHeight,
                                                       pMultiSampleBits, pBPPRequested, pBPPGranted, pPitch);
            *pDepth  = 1;
            *bFourCC = FALSE;
            dbgTracePop();
            return (dwRetVal);

        }

        else {

            // we were told we had a pixel format but this is neither fourCC nor RGB nor a zbuffer
            ERRMSG( "formatted surface is neither fourCC nor RGB" );
            goto bad_fmt_exit;
        }

    }

    else {  // !(pDDSLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT)

        // we weren't given any pixel format
        dwBitCount  = GET_MODE_BPP();

        switch (dwBitCount)
        {
            case 8:
                *pFormat = NV_SURFACE_FORMAT_Y8;
                *pBPPRequested = 1;
                break;
            case 16:
                *pFormat = NV_SURFACE_FORMAT_R5G6B5;
                *pBPPRequested = 2;
                break;
            case 24:
            case 32:  // we treat these as synonymous
#ifdef SPOOF_ALPHA
                if ((pDDSLcl->ddsCaps.dwCaps & DDSCAPS_3DDEVICE) && !(pDDSLcl->ddsCaps.dwCaps & (DDSCAPS_TEXTURE | DDSCAPS_OFFSCREENPLAIN))) {
                    *pFormat = NV_SURFACE_FORMAT_A8R8G8B8;
                } else {
                    *pFormat = NV_SURFACE_FORMAT_X8R8G8B8;
                }
#else
                *pFormat = NV_SURFACE_FORMAT_X8R8G8B8;
#endif
                *pBPPRequested = 4;
                break;
            default:
                ERRMSG( "illegal bit depth" );  // maybe do INT3 here?
                goto bad_fmt_exit;
        }

        *pBPPGranted = *pBPPRequested;
        *bFourCC = FALSE;

    }

    // get the width and height

    if (pDDSLcl->ddsCaps.dwCaps & (DDSCAPS_FRONTBUFFER | DDSCAPS_PRIMARYSURFACE | DDSCAPS_VISIBLE)) {
        *pWidth  = GET_MODE_WIDTH();
        *pHeight = GET_MODE_HEIGHT();
        *pDepth  = 1;
    }
    else {
        *pWidth  = bIsDXT ? max (1, (pDDSLcl->lpGbl->wWidth  >> 2))
                          : pDDSLcl->lpGbl->wWidth;
        *pHeight = bIsDXT ? max (1, (pDDSLcl->lpGbl->wHeight >> 2))
                          : pDDSLcl->lpGbl->wHeight;
        // stored in the lower WORD of the dwCaps4
        *pDepth  = bIsDXT ? max (1, ((pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps4 & 0xffff) >> 2))
                          : max (1, pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps4 & 0xffff);
    }

    // calculate pitch
    if (bComputePitch)
    {
        *pPitch = *pBPPGranted * *pWidth;

        // align the pitch if this isn't a system memory surface or a texture
        if (!(pDDSLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
         && !(pDDSLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE))
        {
            *pPitch = (*pPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
        }

        *pSlicePitch = (*pPitch) * (*pHeight);
    }
    else
    {
        if (bIsDXT) {
            // linear size is given - we recompute pitch here
            *pPitch = (*pWidth) * (*pBPPGranted);
            *pSlicePitch = (*pPitch) * (*pHeight);
        }
        else {
            *pPitch = pDDSLcl->lpGbl->lPitch;
            *pSlicePitch = pDDSLcl->lpGbl->lSlicePitch;
        }
    }

    // Multisampling surfaces
    *pMultiSampleBits = pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps3 & DDSCAPS3_MULTISAMPLE_MASK;

    dbgTracePop();
    return (DD_OK);

// jump to here for bad pixel format
bad_fmt_exit:
#ifdef DEBUG
    nvAssert( pErrMsg != NULL );
    DPF_LEVEL(NVDBG_LEVEL_ERROR, (char*)pErrMsg, dwBitCount);
    // dbgD3DError(); -- let the calling program decide if it wants to throw an INT3
    dbgTracePop();
#endif
    return DDERR_INVALIDPIXELFORMAT;
}

//---------------------------------------------------------------------------

DWORD nvCreateZBuffer (LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl)
{
    DWORD dwFormat, dwWidth, dwHeight, dwMultiSampleBits, dwBPPRequested, dwBPPGranted, dwPitch;

    dbgTracePush ("nvCreateZBuffer");

#ifndef WINNT
    CNvObject         *pNvObj = new CNvObject (pDDSLcl->dwProcessId);
#else
    CNvObject         *pNvObj = new CNvObject (0);
#endif // WINNT
    CSimpleSurface    *pSurf  = new CSimpleSurface;

    if (!pNvObj || !pSurf) {
        if (pNvObj) pNvObj->release();
        if (pSurf ) delete pSurf;
        pDDSLcl->lpGbl->fpVidMem = NULL;
        SET_PNVOBJ (pDDSLcl, NULL);
        dbgTracePop();
        return (DDERR_OUTOFMEMORY);
    }

    pNvObj->setObject (CNvObject::NVOBJ_SIMPLESURFACE, pSurf);

    DWORD dwRV = nvCalculateZBufferParams (pDDSLcl, &dwFormat, &dwWidth, &dwHeight, &dwMultiSampleBits, &dwBPPRequested, &dwBPPGranted, &dwPitch);
    if (dwRV != DD_OK) {
        if (pNvObj) pNvObj->release();
        dbgTracePop();
        return (dwRV);
    }

#ifdef CAPTURE
    if ((getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) &&
        (getDC()->nvD3DRegistryData.regCaptureConfig & D3D_REG_CAPTURECONFIG_ALLOC4X)) {

        CAPTURE_ANNOTATION anno;
        anno.dwJmpCommand         = CAPTURE_JMP_COMMAND;
        anno.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
        anno.dwExtensionID        = CAPTURE_XID_ANNOTATION;
        anno.dwValue              = CAPTURE_ANNOTATION_ALLOC4X;
        captureLog (&anno, sizeof(anno));

        dwWidth  <<= 1;
        dwHeight <<= 1;
        dwPitch  <<= 1;
    }
#endif

    DWORD dwAllocFlags = (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN))        ?
                         (CSimpleSurface::ALLOCATE_TILED | CSimpleSurface::ALLOCATE_AS_ZBUFFER_UNC) :
                         (CSimpleSurface::ALLOCATE_TILED | CSimpleSurface::ALLOCATE_AS_ZBUFFER_CMP);
#ifdef  STEREO_SUPPORT
    if (pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_STEREOSURFACELEFT
        && STEREO_ENABLED)
    {
		dwAllocFlags |= CSimpleSurface::ALLOCATE_AS_STEREO;
	}
#endif  //STEREO_SUPPORT

    if (pSurf->create (pNvObj, dwFormat, dwWidth, dwHeight, 1,
                       dwMultiSampleBits, dwBPPRequested, dwBPPGranted, dwPitch,
                       CSimpleSurface::HEAP_VID, CSimpleSurface::HEAP_VID,
                       dwAllocFlags

#ifdef CAPTURE
                      ,CAPTURE_SURFACE_KIND_ZETA
#endif
                       ))
    {
        // successful allocation
        SET_PNVOBJ (pDDSLcl, pNvObj);  // BUGBUG does this really work for z buffers?
        pDDSLcl->lpGbl->fpVidMem                      = pSurf->getfpVidMem();
        pDDSLcl->lpGbl->lPitch                        = pSurf->getPitch();
        pDDSLcl->lpGbl->lSlicePitch                   = pSurf->getSlicePitch();
        pDDSLcl->lpGbl->ddpfSurface.dwZBufferBitDepth = dwBPPGranted << 3;
        pDDSLcl->lpGbl->ddpfSurface.dwZBitMask        = (dwBPPGranted==2) ? 0x0000ffff : 0xffffff00;
        pDDSLcl->lpGbl->dwReserved1                   = 0;
        pDDSLcl->ddsCaps.dwCaps                      |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
        pDDSLcl->ddsCaps.dwCaps                      &= ~DDSCAPS_SYSTEMMEMORY;
        pSurf->tagAsOwner();
    }

    else {
        DPF_LEVEL (NVDBG_LEVEL_SURFACE, "Video memory Z buffer surface allocation failed" );
        if (pNvObj) pNvObj->release();
        dbgTracePop();
        return (DDERR_OUTOFVIDEOMEMORY);
    }
#ifdef DEBUG_SURFACE_PLACEMENT
        csd.SetZBuffer(pSurf);
#endif

    dbgTracePop();
    return(DD_OK);

}  // nvCreateZBuffer()

//---------------------------------------------------------------------------

// returns an error code that CreateSurface should return via ->ddRVal

DWORD nvCreateSurfaceWithFormat (LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl,
                                 LPDDRAWI_DIRECTDRAW_GBL pDDGbl, DWORD dwExtraSize, DWORD dwExtraNumSurfaces, DWORD dwBlockHeight)
{
    DWORD dwPitch, dwSlicePitch, dwMultiSampleBits;

    dbgTracePush ("nvCreateSurfaceWithFormat");

    DWORD dwModeBPP = GET_MODE_BPP() >> 3;

    if (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_ALPHAPREMULT) {

        // BUGBUG needs to be G.U.D.ified someday
        DPF_LEVEL(NVDBG_LEVEL_SURFACE,  "  ALPHA_PREMULT surface requested" );
        dwPitch = pDDSLcl->lpGbl->wWidth * dwModeBPP;
        dwPitch = (dwPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
        dwSlicePitch = dwPitch * pDDSLcl->lpGbl->wHeight;

        DWORD dwBlockSize = (dwPitch * ((DWORD)pDDSLcl->lpGbl->wHeight));
        pDDSLcl->lpGbl->ddpfSurface.dwRGBBitCount = dwModeBPP << 3;
        pDDSLcl->lpGbl->ddpfSurface.dwRGBAlphaBitMask = 0xFF000000;
        pDDSLcl->lpGbl->ddpfSurface.dwRBitMask = 0x00FF0000;
        pDDSLcl->lpGbl->ddpfSurface.dwGBitMask = 0x0000FF00;
        pDDSLcl->lpGbl->ddpfSurface.dwBBitMask = 0x000000FF;
        pDDSLcl->lpGbl->lPitch = dwPitch;
        pDDSLcl->lpGbl->lSlicePitch = dwSlicePitch;
        pDDSLcl->lpGbl->fpVidMem = 0;
        pDDSLcl->lpGbl->dwReserved1 = 0;

        if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {

            DWORD dwStatus;
            NVHEAP_ALLOC (dwStatus, pDDSLcl->lpGbl->fpVidMem, dwBlockSize, TYPE_IMAGE);
            if (dwStatus == 0) {
                pDriverData->DDrawVideoSurfaceCount++;
                pDDSLcl->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
                pDDSLcl->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;
            }

        }

        else {
            dbgTracePop();
            return (DDERR_OUTOFMEMORY);
        }

        // if one of these fails, then this code was and is totally broken.
        // it used to just continue on from this if block. i've added the return.
        // as best i can tell. there was nothing preventing us from allocating this
        // surface twice. why would we want to do that?
        assert (!(pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_FOURCC));
        assert (!(pDDSLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE));
        assert (!(pDDSLcl->ddsCaps.dwCaps & DDSCAPS_ZBUFFER));
        dbgTracePop();
        return (DD_OK);

    }

    if (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_FOURCC) {

        // BUGBUG needs to be G.U.D.ified someday
        DWORD dwRV = VppCreateFourCCSurface(&(pDriverData->vpp),pDDSLcl, pDDGbl,dwExtraSize, dwExtraNumSurfaces, dwBlockHeight);
        dbgTracePop();
        return (dwRV);

    }

    if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN) {

        DWORD dwFormat, dwWidth, dwHeight, dwDepth, dwBPPRequested, dwBPPGranted, dwPitch;
        BOOL bFourCC;

#ifndef WINNT
        CNvObject      *pNvObj = new CNvObject (pDDSLcl->dwProcessId);
#else
        CNvObject      *pNvObj = new CNvObject (0);
#endif // WINNT

        CSimpleSurface *pSurf  = new CSimpleSurface;

        if (!pNvObj || !pSurf) {
            if (pNvObj) pNvObj->release();
            if (pSurf ) delete pSurf;
            pDDSLcl->lpGbl->fpVidMem = NULL;
            SET_PNVOBJ (pDDSLcl, NULL);
            dbgTracePop();
            return (DDERR_OUTOFMEMORY);
        }

        pNvObj->setObject (CNvObject::NVOBJ_SIMPLESURFACE, pSurf);

        DWORD dwRV = nvCalculateSurfaceParams (pDDSLcl, &dwFormat, &bFourCC, &dwWidth, &dwHeight, &dwDepth, &dwMultiSampleBits,
                                               &dwBPPRequested, &dwBPPGranted, &dwPitch, &dwSlicePitch, TRUE);
        if (dwRV != DD_OK) {
            dbgD3DError();  // ?? can we get here for legit reasons?
            if (pNvObj) pNvObj->release();
            dbgTracePop();
            return (dwRV);
        }

        // figure out where to stick it
        DWORD dwPreferredHeap, dwAllowedHeaps, dwAllocFlags;

        if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) {
            dwPreferredHeap = (pDriverData->GARTLinearBase > 0) ?
                              CSimpleSurface::HEAP_AGP :
                              CSimpleSurface::HEAP_PCI;
            dwAllowedHeaps  = dwPreferredHeap;
            dwAllocFlags    = CSimpleSurface::ALLOCATE_SIMPLE;
        }
        else {
            dwPreferredHeap = CSimpleSurface::HEAP_VID;
            dwAllowedHeaps  = dwPreferredHeap;

            if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_3DDEVICE) {
                dwAllocFlags = CSimpleSurface::ALLOCATE_TILED;
            }
            else {
                dwAllocFlags = CSimpleSurface::ALLOCATE_SIMPLE;
            }
            // if they haven't demanded video memory, allow fallback to system
            if (!(pDDSLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)) {
                dwAllowedHeaps |= CSimpleSurface::HEAP_SYS;
            }
        }

        if (pSurf->create (pNvObj, dwFormat, dwWidth, dwHeight, dwDepth,
                           dwMultiSampleBits, dwBPPRequested, dwBPPGranted, dwPitch,
                           dwAllowedHeaps, dwPreferredHeap, dwAllocFlags
#ifdef CAPTURE
                          ,CAPTURE_SURFACE_KIND_UNKNOWN
#endif
                           ))
        {
            // allocation succeeded. set stuff in MS-land
            if (pSurf->getHeapLocation() == CSimpleSurface::HEAP_SYS) {
                pDDSLcl->lpGbl->fpVidMem    = (FLATPTR)pSurf->getfpVidMem();
                pDDSLcl->lpGbl->dwReserved1 = (DWORD)pSurf->getfpVidMem();
            }
#ifdef WINNT
            // MS-suggested Hack to make AGP surfaces whose mem was
            // allocated through HeapVidMemAllocAligned work properly
            else if (pSurf->getHeapLocation() == CSimpleSurface::HEAP_AGP) {
#ifdef NV_AGP
                pDDSLcl->lpGbl->fpVidMem = nvAGPGetUserAddr(pSurf->getAddress());
#else
                pDDSLcl->lpGbl->lpVidMemHeap = ppdev->AgpHeap;
                pDDSLcl->lpGbl->fpHeapOffset = pSurf->getfpVidMem() + pDriverData->GARTLinearHeapOffset;
#endif
                pDDSLcl->lpGbl->dwReserved1  = 0;
            }
#endif // WINNT
            else {
                pDDSLcl->lpGbl->fpVidMem    = pSurf->getfpVidMem();
                pDDSLcl->lpGbl->dwReserved1 = 0;
            }
            SET_PNVOBJ (pDDSLcl, pNvObj);
            pDDSLcl->lpGbl->lPitch      = pSurf->getPitch();  // may be different than dwPitch!
            pDDSLcl->lpGbl->lSlicePitch = pSurf->getSlicePitch();
            pDDSLcl->ddsCaps.dwCaps     = pSurf->modifyDDCaps (pDDSLcl->ddsCaps.dwCaps);
            pSurf->tagAsOwner();
        }

        else {
            // surface creation failed
            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "Offscreen surface allocation failed" );
            if (pNvObj) pNvObj->release();
            pDDSLcl->lpGbl->dwReserved1 = 0;
            dbgTracePop();
            return (DDERR_OUTOFVIDEOMEMORY);
        }

        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "Offscreen surface granted" );
        return (DD_OK);
    }

    if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_ZBUFFER) {

        DWORD dwRV = nvCreateZBuffer (pDDSLcl);
        dbgTracePop();
        return (dwRV);

    }

    DPF ("unknown surface type in nvCreateSurfaceWithFormat");
    dbgD3DError();

    dbgTracePop();
    return (DDERR_UNSUPPORTEDFORMAT);

}  // nvCreateSurfaceWithFormat()

//---------------------------------------------------------------------------
// nvApplicationCheck
//      Does application specific things
//      ***** DO NOT ADD ANY ENTRIES WITHOUT A COMPLETE DESCRIPTION OF THE BUG *****
//      ***** SYMPTOMS AND THE SOLUTION.  THIS MEANS YOU                       *****
void nvApplicationCheck(void)
{
#if 0
#ifndef WINNT
LPTSTR pCmdLine, pExe, pStr;

    // get command line
    pCmdLine = GetCommandLine();

    // strip path and leave the raw executable name
    for (pExe = pCmdLine; *pCmdLine != '\0'; pCmdLine++) {
        if (*pCmdLine == '\\' || *pCmdLine == ':') {
            pExe = pCmdLine + 1;
        }
    }

    // early string termination if quote, space, or control character is detected
    for (pStr = pExe; *pStr != '\0'; pStr++) {
        if (*pStr == '\"' || *pStr < ' ') {
            *pStr = '\0';
        }
    }

    // ------------------------
    // Rainbow Six: Rogue Spear
    //      This app thrashes blit context DMAs, so blit code wants to fall back to old
    //      blit code for performance reasons.  However, old blit code has a bug in it
    //      (if you want to fix it, you obviously have not seen the old fallback code)
    //      and text is corrupted.  The end of each scan line is not correctly fed into
    //      the image_from_cpu class.  The fix is to detect this app, and let it thrash.
    //      It will be slower, but at least it will work.  See code in nvBlit.cpp.
    //      --- slum
    if (nvStrCmp(pExe, "RogueSpear.exe")==0) {
        pDriverData->bltData.dwLetItThrash = TRUE;
    }
#endif
#endif
}

//---------------------------------------------------------------------------
//
// returns an error code that CreateSurface should return via ->ddRVal
//
// called only from one place in CreateSurface32()

DWORD nvCreateSurfaceWithoutFormat (LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl,
                                    LPDDRAWI_DIRECTDRAW_GBL pDDGbl)
{
    dbgTracePush ("nvCreateSurfaceWithoutFormat");

    DWORD dwModeBPP = GET_MODE_BPP() >> 3;

    // create the basic objects
#ifdef WINNT
    CNvObject      *pNvObj = new CNvObject (0);
#else // !WINNT
    CNvObject      *pNvObj = new CNvObject (pDDSLcl->dwProcessId);
#endif // !WINNT

    CSimpleSurface *pSurf  = new CSimpleSurface;

    if (!pNvObj || !pSurf) {
        if (pNvObj) pNvObj->release();
        if (pSurf ) delete pSurf;
        pDDSLcl->lpGbl->fpVidMem = NULL;
        SET_PNVOBJ (pDDSLcl, NULL);
        dbgTracePop();
        return (DDERR_OUTOFMEMORY);
    }

    pNvObj->setObject (CNvObject::NVOBJ_SIMPLESURFACE, pSurf);

    // determine common surface parameters
    DWORD dwFormat, dwWidth, dwHeight, dwDepth, dwBPPRequested, dwBPPGranted, dwPitch, dwSlicePitch, dwMultiSampleBits;
    BOOL  bFourCC;

    DWORD dwRV = nvCalculateSurfaceParams (pDDSLcl, &dwFormat, &bFourCC, &dwWidth, &dwHeight, &dwDepth, &dwMultiSampleBits,
                                           &dwBPPRequested, &dwBPPGranted, &dwPitch, &dwSlicePitch, TRUE);

    if (dwRV != DD_OK) {
        dbgD3DError();  // ?? can we get here for legit reasons?
        if (pNvObj) pNvObj->release();
        dbgTracePop();
        return (dwRV);
    }

    // handle surface specifics according to type
    if (pDDSLcl->ddsCaps.dwCaps & (DDSCAPS_FRONTBUFFER | DDSCAPS_PRIMARYSURFACE | DDSCAPS_VISIBLE)) {

        nvApplicationCheck();

        // Must allow primary surface access even if not correct pixel depth for 3D
        // Fixes Jedi Knight bug
        if ((pDDSLcl->ddsCaps.dwCaps & DDSCAPS_3DDEVICE) &&
            (!(pDDSLcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE))) {
            if (dwModeBPP == 1) {
                pNvObj->release();
                dbgTracePop();
                return (DDERR_INVALIDPIXELFORMAT);
            }
        }

#ifdef WINNT
        ppdev->bD3DappIsRunning = TRUE;
        dwPitch = ppdev->lDelta;
#else // !WINNT
        // override pitch determined above with the pitch that's
        // been rounded up to account for tiling
        dwPitch = ((DIBENGINEHDR1 *)pDXShare->pFlatDibeng)->deDeltaScan;
#endif // !WINNT

#ifdef DEBUG
        dbgPrimaryPitch  = dwPitch;
        dbgPrimaryHeight = dwHeight;
        dbgPrimaryBPP    = dwBPPGranted;
#endif

#ifndef WINNT
        if (pDXShare->pNvPrimarySurf) {
            // some other context has already created an NvObject for this primary
            // delete the new objects we just created
            pNvObj->release();

            // assign pointers to the old objects
            pNvObj = (CNvObject*)pDXShare->pNvPrimarySurf;
            pSurf = pNvObj->getSimpleSurface();
        } else {
            // use the new pNvObject
            pDXShare->pNvPrimarySurf = (DWORD)pNvObj;
        }
#endif // !WINNT

#ifdef  STEREO_SUPPORT
        pSurf->destroyStereo();
#endif  //STEREO_SUPPORT

        pSurf->own (VIDMEM_ADDR(GET_PRIMARY_ADDR()), dwPitch, dwHeight, CSimpleSurface::HEAP_VID, FALSE);
        pSurf->setWrapper (pNvObj);
        pSurf->setFormat (dwFormat);
        pSurf->setWidth (dwWidth);
        pSurf->setBPP (dwBPPGranted);
        pSurf->setBPPRequested (dwBPPRequested);
        pSurf->setDepth(dwDepth);

#ifdef DEBUG_SURFACE_PLACEMENT
        csd.SetFrontBuffer(pSurf);
#endif
        // set stuff back in MS-land as well
        SET_PNVOBJ (pDDSLcl, pNvObj);
        pDDSLcl->lpGbl->fpVidMem    = GET_PRIMARY_ADDR();
        pDDSLcl->lpGbl->lPitch      = dwPitch;
        pDDSLcl->lpGbl->lSlicePitch = dwSlicePitch;
        pDDSLcl->lpGbl->dwReserved1 = 0;
        pDDSLcl->ddsCaps.dwCaps    |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);

#ifdef  STEREO_SUPPORT
		if (STEREO_ENABLED)
		{				
			CreateLockSubstitute(pDDSLcl);
			if (!pSurf->createStereo ())
			{
				LOG("Can't create a stereo rendering surface");
			}
		}
#endif  //STEREO_SUPPORT

        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "front buffer granted" );

        // we need to tell displaydriver that a PRIMARY surface was acquired
        NV_OGLDDRAWSURFACECREATED( ppdev );

    }

    else if (pDDSLcl->ddsCaps.dwCaps & (DDSCAPS_BACKBUFFER | DDSCAPS_FLIP)) {

        // make sure we come up with the same value we used to...
        nvAssert (dwWidth  == (DWORD)GET_MODE_WIDTH());
        nvAssert (dwHeight == (DWORD)GET_MODE_HEIGHT());
        nvAssert (dwBPPRequested == dwModeBPP);

#ifdef CAPTURE
        if ((getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) &&
            (getDC()->nvD3DRegistryData.regCaptureConfig & D3D_REG_CAPTURECONFIG_ALLOC4X)) {

            CAPTURE_ANNOTATION anno;
            anno.dwJmpCommand         = CAPTURE_JMP_COMMAND;
            anno.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
            anno.dwExtensionID        = CAPTURE_XID_ANNOTATION;
            anno.dwValue              = CAPTURE_ANNOTATION_ALLOC4X;
            captureLog (&anno, sizeof(anno));

            dwWidth  <<= 1;
            dwHeight <<= 1;
            dwPitch  <<= 1;
        }
#endif

		DWORD	dwAllocFlags = CSimpleSurface::ALLOCATE_TILED;
#ifdef  STEREO_SUPPORT
		if (pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_STEREOSURFACELEFT
			&& STEREO_ENABLED)
		{
			dwAllocFlags |= CSimpleSurface::ALLOCATE_AS_STEREO;
		}
#endif  //STEREO_SUPPORT
        if (pSurf->create (pNvObj, dwFormat, dwWidth, dwHeight, dwDepth,
                           dwMultiSampleBits, dwBPPRequested, dwBPPGranted, dwPitch,
                           CSimpleSurface::HEAP_VID, CSimpleSurface::HEAP_VID,
                           dwAllocFlags
#ifdef CAPTURE
                          ,CAPTURE_SURFACE_KIND_TARGET
#endif
                           ))
        {
            // set stuff in MS-land
            SET_PNVOBJ (pDDSLcl, pNvObj);
            pDDSLcl->lpGbl->fpVidMem = pSurf->getfpVidMem();
            pDDSLcl->lpGbl->lPitch   = pSurf->getPitch();
            pDDSLcl->lpGbl->lSlicePitch   = pSurf->getSlicePitch();
            pDDSLcl->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM);
            pDDSLcl->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
            pSurf->tagAsOwner();
        }

        else {
            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "Backbuffer or flippable video memory surface allocation failed" );
            if(pNvObj) pNvObj->release();
            dbgTracePop();
            return (DDERR_OUTOFVIDEOMEMORY);
        }

#ifdef DEBUG_SURFACE_PLACEMENT
        csd.SetBackBuffer(pSurf);
#endif
        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "Back buffer or flip surface granted" );

    }

    else if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN) {

        putInOffscreen:

        // make sure we come up with the same value we used to...
        nvAssert (dwWidth == (DWORD)pDDSLcl->lpGbl->wWidth);
        nvAssert (dwHeight == (DWORD)pDDSLcl->lpGbl->wHeight);
        nvAssert (dwBPPRequested == dwModeBPP);

        // figure out where to stick it

        DWORD dwPreferredHeap, dwAllowedHeaps, dwAllocFlags;

        if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) {
            dwPreferredHeap = (pDriverData->GARTLinearBase > 0) ?
                              CSimpleSurface::HEAP_AGP :
                              CSimpleSurface::HEAP_PCI;
            dwAllowedHeaps  = dwPreferredHeap;
            dwAllocFlags    = CSimpleSurface::ALLOCATE_SIMPLE;
        }

        else {
            dwPreferredHeap = CSimpleSurface::HEAP_VID;
            dwAllowedHeaps  = dwPreferredHeap;

            if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_3DDEVICE) {
                dwAllocFlags = CSimpleSurface::ALLOCATE_TILED;
            }
            else {
                dwAllocFlags = CSimpleSurface::ALLOCATE_SIMPLE;
            }
            // if they haven't demanded video memory, allow fallback to system
            if (!(pDDSLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)) {
                dwAllowedHeaps |= CSimpleSurface::HEAP_SYS;
            }
        }

        if (pSurf->create (pNvObj, dwFormat, dwWidth, dwHeight, dwDepth,
                           dwMultiSampleBits, dwBPPRequested, dwBPPGranted, dwPitch,
                           dwAllowedHeaps, dwPreferredHeap, dwAllocFlags
#ifdef CAPTURE
                          ,CAPTURE_SURFACE_KIND_UNKNOWN
#endif
                           ))
        {
            // allocation succeeded. set stuff in MS-land
            if (pSurf->getHeapLocation() == CSimpleSurface::HEAP_SYS) {
                pDDSLcl->lpGbl->fpVidMem    = (FLATPTR)pSurf->getfpVidMem();
                pDDSLcl->lpGbl->dwReserved1 = (DWORD)pSurf->getfpVidMem();
            }
#ifdef WINNT
            // MS-suggested Hack to make AGP surfaces whose mem was
            // allocated through HeapVidMemAllocAligned work properly
            else if (pSurf->getHeapLocation() == CSimpleSurface::HEAP_AGP) {
#ifdef NV_AGP
                pDDSLcl->lpGbl->fpVidMem     = nvAGPGetUserAddr(pSurf->getAddress());
#else
                pDDSLcl->lpGbl->lpVidMemHeap = ppdev->AgpHeap;
                pDDSLcl->lpGbl->fpHeapOffset = pSurf->getfpVidMem() + pDriverData->GARTLinearHeapOffset;
#endif
                pDDSLcl->lpGbl->dwReserved1 = 0;
            }
#endif // WINNT
            else {
                pDDSLcl->lpGbl->fpVidMem    = pSurf->getfpVidMem();
                pDDSLcl->lpGbl->dwReserved1 = 0;
            }
            SET_PNVOBJ (pDDSLcl, pNvObj);
            pDDSLcl->lpGbl->lPitch  = pSurf->getPitch();  // may be different than dwPitch!
            pDDSLcl->lpGbl->lSlicePitch = pSurf->getSlicePitch();  // may be different than dwPitch!
            pDDSLcl->ddsCaps.dwCaps = pSurf->modifyDDCaps (pDDSLcl->ddsCaps.dwCaps);
            pSurf->tagAsOwner();
        }

        else {
            // surface creation failed
            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "Offscreen surface allocation failed" );
            pDDSLcl->lpGbl->dwReserved1 = 0;
            if (pNvObj) pNvObj->release();
            dbgTracePop();
            return (DDERR_OUTOFVIDEOMEMORY);
        }

        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "Offscreen surface granted" );

    }

    else if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) {

        // make sure we come up with the same value we used to...
        nvAssert (dwWidth == (DWORD)pDDSLcl->lpGbl->wWidth);
        nvAssert (dwHeight == (DWORD)pDDSLcl->lpGbl->wHeight);
        nvAssert (dwBPPRequested == dwModeBPP);

        if (pSurf->create (pNvObj, dwFormat, dwWidth, dwHeight, dwDepth,
                           dwMultiSampleBits, dwBPPRequested, dwBPPGranted, dwPitch,
                           CSimpleSurface::HEAP_SYS, CSimpleSurface::HEAP_SYS,
                           CSimpleSurface::ALLOCATE_SIMPLE
#ifdef CAPTURE
                          ,CAPTURE_SURFACE_KIND_UNKNOWN
#endif
                           ))
        {
            // set stuff in MS-land
            SET_PNVOBJ (pDDSLcl, pNvObj);
            pDDSLcl->lpGbl->fpVidMem    = (FLATPTR)pSurf->getfpVidMem();
            pDDSLcl->lpGbl->dwReserved1 = (DWORD)pSurf->getfpVidMem();
            pDDSLcl->lpGbl->lPitch      = pSurf->getPitch();
            pDDSLcl->lpGbl->lSlicePitch      = pSurf->getSlicePitch();
            pSurf->tagAsOwner();
        }

        else {
            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "System memory surface allocation failed" );
            if(pNvObj) pNvObj->release();
            dbgTracePop();
            return (DDERR_OUTOFMEMORY);
        }

        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "System memory surface granted" );

    }

    else if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {

        goto putInOffscreen;

    }

    dbgTracePop();
    return (DD_OK);

}  // nvCreateSurfaceWithoutFormat ()

#ifdef  NEW_FRONT_RENDER
//This mechanism doesn't work for triple buffering and is intended for debugging only.
FLATPTR BackVidMem;
CNvObject *pBackNvObj;
#endif  //NEW_FRONT_RENDER

//---------------------------------------------------------------------------

// CreateSurface32
// Create a Direct Draw surface.

DWORD __stdcall CreateSurface32 (LPDDHAL_CREATESURFACEDATA lpCSData)
{
    dbgTracePush ("CreateSurface32");
    if (lpCSData->lplpSList[0]->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
    {
        //silly hack for screwed up kernel calls
        DWORD dwRetVal;
        dwRetVal = D3DCreateExecuteBuffer32(lpCSData);
        dbgTracePop();
        return dwRetVal;
    }

    DDSTARTTICK(SURF4_CREATESURFACE);

    LPDDRAWI_DIRECTDRAW_GBL pDDGbl = lpCSData->lpDD;
    nvSetDriverDataPtrFromDDGbl (pDDGbl);

    if (pDriverData->dwFullScreenDOSStatus & (FSDOSSTATUS_RECOVERYNEEDED_D3D | FSDOSSTATUS_RECOVERYNEEDED_DDRAW)) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
                nvD3DRecover();
            }
            if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_DDRAW) {
                nvDDrawRecover();
            }
        }
    }
    
    // Reset NV and get the monitor frequency after a mode reset
    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        if (!nvEnable32 (lpCSData->lpDD)) {
            DDENDTICK(SURF4_CREATESURFACE);
            NvReleaseSemaphore(pDriverData);
            lpCSData->ddRVal = DDERR_OUTOFMEMORY;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    }

    // NOTES:
    // This callback is invoked once the surface objects have been created.
    // You can:
    //   - compute the size of the block, by returning
    //     DDHAL_PLEASEALLOC_BLOCKSIZE in fpVidMem, and putting the size
    //     in dwBlockSizeX and dwBlockSizeY
    //   - override some fields in the surface structure, like the pitch.
    //     (you must specify the pitch if you are computing the size)

    DPF_LEVEL (NVDBG_LEVEL_SURFACE_ACTIVITY,
               "CreateSurface: lpCSData->lplpSList = %08x, lpCSData->dwSCnt = %d",
               lpCSData->lplpSList, lpCSData->dwSCnt);

    // see if any of these surfaces are FOURCC codes...
//    pmAddProcess(pDriverData, GetCurrentProcessId());

    // get first surface
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl = lpCSData->lplpSList[0];

    // can overlay be created in this mode?  Need to call this before nvCSCalcExtraSpace
    if (IS_OVERLAY(pDDSLcl->ddsCaps.dwCaps, pDDSLcl->lpGbl->ddpfSurface.dwFourCC)) {

        // Disable dual view for video overlay
#ifdef WINNT
        if ((ppdev->ulDesktopMode & NV_TWO_DACS) &&
           !(ppdev->TwinView_State == NVTWINVIEW_STATE_CLONE &&
            (pDriverData->vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSDEVICEMASK)) &&
           !(pDriverData->vpp.regOverlayMode3 & NV4_REG_OVL_MODE3_ALLOWOVL))
#else
        if (pDriverData->dwHeads > 1 &&
            pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE &&
           (pDriverData->vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSDEVICEMASK) == 0 &&
          !(pDriverData->vpp.regOverlayMode3 & NV4_REG_OVL_MODE3_ALLOWOVL))
#endif
        {
            lpCSData->ddRVal = DDERR_NOOVERLAYHW;
            DDENDTICK(SURF4_CREATESURFACE);
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }

        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_DDRAW) {
            if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
                nvDDrawRecover();
            }
            else {
                // deny overlay creation if we are in a full screen DOS box (because we need the draw engine)
                lpCSData->ddRVal = DDERR_NOOVERLAYHW;
                DDENDTICK(SURF4_CREATESURFACE);
                NvReleaseSemaphore(pDriverData);
                dbgTracePop();
                return (DDHAL_DRIVER_HANDLED);
            }
        }

        if (VppGetVideoScalerBandwidthStatus(&pDriverData->vpp,pDDSLcl->lpGbl->wWidth) == FALSE) {
            // deny overlay creation if not enough video memory bandwidth
            lpCSData->ddRVal = DDERR_NOOVERLAYHW;
            DDENDTICK(SURF4_CREATESURFACE);
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }

        // Reset flag indicating whether overlay has ever been in Bob mode.
        pDriverData->dwDXVAFlags &= ~DXVA_OVERLAY_WAS_BOBBED;

        // If this create is for an NV12 surface, limit the number of buffers
        // depending on frame buffer size and TwinView state, to leave room
        // for Video Mirror.
        if (pDDSLcl->lpGbl->ddpfSurface.dwFourCC == FOURCC_NV12) {
            DWORD   dwMaxAllowed;

            // For 16MB frame buffers...
            if (pDriverData->TotalVRAM < 0x2000000) {

                if((pDriverData->dwDesktopState == NVTWINVIEW_STATE_DUALVIEW) ||
                    (pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE))
                    dwMaxAllowed = 4;
                else
                    dwMaxAllowed = 6;
            }

            // For 32MB frame buffers...
            else {

                if((pDriverData->dwDesktopState == NVTWINVIEW_STATE_DUALVIEW) ||
                    (pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE))
                    dwMaxAllowed = 7;
                else
                    dwMaxAllowed = 8;
            }

            // If number of buffers requested is more than this, return error.
            if (lpCSData->dwSCnt > dwMaxAllowed) {
                lpCSData->ddRVal = DDERR_OUTOFMEMORY;
                DDENDTICK(SURF4_CREATESURFACE);
                NvReleaseSemaphore(pDriverData);
                dbgTracePop();
                return (DDHAL_DRIVER_HANDLED);
            }
        }
    }

    // check to see if the set of surfaces being created is the primary flip chain
    BOOL bPrimaryFlipChain = lpCSData->dwSCnt
                          && (lpCSData->lplpSList[0]->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
                          && (lpCSData->lplpSList[0]->ddsCaps.dwCaps & DDSCAPS_FLIP);

#if (NVARCH >= 0x04) && defined(HWFLIP)

    // set up HW support for flipping
    if (bPrimaryFlipChain) {
        if (lpCSData->dwSCnt > 2) {
            // in the triple buffered case, we may still have a v-blank outstanding, which causes a race
            // condition between the increment read (on processing the v-blank) and the SetRWM below.
            // wait for the last v-blank here to prevent this

            // flush out all but one v-blank
            WaitForIdle(TRUE, FALSE);

            // get the current v-blank count
            NV_CFGEX_VBLANK_COUNTER_MULTI_PARAMS nvVBCounter;
            nvVBCounter.Head = GET_CURRENT_HEAD();
            NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_VBLANK_COUNTER_MULTI,
                &nvVBCounter, sizeof(nvVBCounter));

            // wait for one more v-blank
            DWORD dwFirstCount = nvVBCounter.VBlankCounter;
            do {
                NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_VBLANK_COUNTER_MULTI,
                    &nvVBCounter, sizeof(nvVBCounter));
            } while (nvVBCounter.VBlankCounter == dwFirstCount);
        }
#if (NVARCH >= 0x020) && defined(KELVIN_SEMAPHORES)
        if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
            (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
            (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
        {
            getDC()->nvFlipper.init (lpCSData->dwSCnt);
        }
        else if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_1196_CELSIUS | NVCLASS_0096_CELSIUS)) {
            DPF_LEVEL (NVDBG_LEVEL_SURFACE, "Setting number of surfaces in primary flip chain to %d", lpCSData->dwSCnt);
            nvglSetNv15CelsiusSyncSetRWM (NV_DD_CELSIUS, 0, 1, lpCSData->dwSCnt)
        }
#elif (NVARCH >= 0x020)
        if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_1196_CELSIUS | NVCLASS_0096_CELSIUS | NVCLASS_FAMILY_KELVIN)) {
            DPF_LEVEL (NVDBG_LEVEL_SURFACE, "Setting number of surfaces in primary flip chain to %d", lpCSData->dwSCnt);
            nvglSetNv15CelsiusSyncSetRWM (NV_DD_CELSIUS, 0, 1, lpCSData->dwSCnt)
        }
#elif (NVARCH >= 0x010)
        if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_1196_CELSIUS | NVCLASS_0096_CELSIUS)) {
            DPF_LEVEL (NVDBG_LEVEL_SURFACE, "Setting number of surfaces in primary flip chain to %d", lpCSData->dwSCnt);
            nvglSetNv15CelsiusSyncSetRWM (NV_DD_CELSIUS, 0, 1, lpCSData->dwSCnt)
        }
#endif
    }

#endif  // HWFLIP

    // figure out how much extra space is required for video post processing
    // dwExtraSize is the size of one workspace surface, for NV4/5 we need 4,
    // for NV10 we need 3
    DWORD dwExtraSize, dwExtraNumSurfaces, dwBlockHeight;
    LPDDHALINFO pHalInfo = GET_HALINFO();
    VppCalcExtraSurfaceSpace(&(pDriverData->vpp), pDDSLcl, pHalInfo->vmiData.dwDisplayHeight, lpCSData->dwSCnt, &dwExtraSize, &dwExtraNumSurfaces, &dwBlockHeight);

    for (int i = 0; i < int(lpCSData->dwSCnt); i++) {

        BOOL bRealSurface = FALSE;

        // traversing SList in the reverse order ensures that we use one of the two faster
        // memory banks in triple buffer, render to front buffer only tests
        pDDSLcl = lpCSData->lplpSList[bPrimaryFlipChain ? (lpCSData->dwSCnt - i - 1) : i];

#ifdef  STEREO_SUPPORT
        nvAssert((pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_STEREOSURFACELEFT) == 0);
        pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 &= ~DDSCAPS2_STEREOSURFACELEFT;
        if (STEREO_ENABLED)
        {
            if (bPrimaryFlipChain || pDDSLcl->ddsCaps.dwCaps &
               (DDSCAPS_BACKBUFFER | DDSCAPS_PRIMARYSURFACE | DDSCAPS_ZBUFFER))
            {
                //We will emulate the stereo bit for internal use. Will clear it on exit.
                pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 |= DDSCAPS2_STEREOSURFACELEFT;
            }
        }
#endif  //STEREO_SUPPORT

        if (global.dwDXRuntimeVersion < 0x0700) {
            DPF_LEVEL(NVDBG_LEVEL_SURFACE_ACTIVITY, "CreateSurface: pDDGbl = %08x, pDDSLcl = %08x", pDDGbl, pDDSLcl);
        } else {
            DPF_LEVEL(NVDBG_LEVEL_SURFACE_ACTIVITY, "CreateSurface: pDDGbl = %08x, pDDSLcl = %08x, handle = %02x",
                      pDDGbl, pDDSLcl, pDDSLcl->lpSurfMore->dwSurfaceHandle);
        }

        if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE) {
            DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"Texture Create:");
            lpCSData->ddRVal = nvTextureCreateSurface (pDDSLcl, pDDGbl, lpCSData->lpDDSurfaceDesc);
        }

        else if (pDDSLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) {
            DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"Surface With Format:");
            lpCSData->ddRVal = nvCreateSurfaceWithFormat (pDDSLcl, pDDGbl, dwExtraSize, dwExtraNumSurfaces, dwBlockHeight);
            bRealSurface     = TRUE;
        }

        else {
            DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"Surface Without Format:");
            lpCSData->ddRVal = nvCreateSurfaceWithoutFormat (pDDSLcl, pDDGbl);
            bRealSurface     = TRUE;
        }

#if (NVARCH >= 0x010)
        if (bRealSurface && (global.dwDXRuntimeVersion >= 0x0700)) {
            // If we have forced aa on, then dont return error here.  Simply continue without aa
            if (!nvCelsiusAACanCreate(pDDSLcl) && !(pDriverData->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASFORCEENABLE_MASK))
            {
                lpCSData->ddRVal = DDERR_OUTOFVIDEOMEMORY;
                DPF("CreateSurface32: cannot create AA buffers");
            }
        }
#endif  // NVARCH >= 0x010

        if (global.dwDXRuntimeVersion < 0x0700)
        {
            // For DX6 runtime we're going to have to keep a pointer to a Local structure.
            // We will reuse the Object->Handle which isn't used in DX6.
            CNvObject *pNvObj = GET_PNVOBJ (pDDSLcl);
            // if this a surface that hasn't yet been G.U.D.ified, we won't have an NvObject for it
            if (IS_VALID_PNVOBJ(pNvObj)) {
                pNvObj->setHandle ((DWORD)pDDSLcl);
            }
        }

#ifdef  STEREO_SUPPORT
        pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 &= ~DDSCAPS2_STEREOSURFACELEFT;
#endif  //STEREO_SUPPORT

        if (IS_OVERLAY(pDDSLcl->ddsCaps.dwCaps, pDDSLcl->lpGbl->ddpfSurface.dwFourCC)) {
            // overlay has succeeded, enable VPP
            if (i == 0 && !VppCreateOverlay(&pDriverData->vpp)) {
                lpCSData->ddRVal = DDERR_GENERIC;
            }
        }

        if (lpCSData->ddRVal != DD_OK) {
            if (IS_OVERLAY(pDDSLcl->ddsCaps.dwCaps, pDDSLcl->lpGbl->ddpfSurface.dwFourCC)) {
                VppDestroyOverlay(&pDriverData->vpp);
            }
#ifdef DEBUG
            switch (lpCSData->ddRVal) {
                case DDERR_OUTOFMEMORY:
                    DPF("CreateSurface32: Out of memory");
                    break;
                case DDERR_OUTOFVIDEOMEMORY:
                    DPF("CreateSurface32: Out of video memory");
                    break;
                default:
                    DPF("CreateSurface32: Encountered error %x", lpCSData->ddRVal);
                    break;
            }
#endif

            // roll back the allocations that succeeded
            DDHAL_DESTROYSURFACEDATA ddDSData;
            ddDSData.lpDD = lpCSData->lpDD;
            for (i=i-1; i>=0; i--) {
                ddDSData.lpDDSurface = lpCSData->lplpSList[bPrimaryFlipChain ? (lpCSData->dwSCnt - i - 1) : i];
                DestroySurface32 (&ddDSData);
            }

            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
    }

#ifdef CAPTURE
    if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
        if (bPrimaryFlipChain) {
            CAPTURE_FLIP_CHAIN chain;
            chain.dwJmpCommand         = CAPTURE_JMP_COMMAND;
            chain.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
            chain.dwExtensionID        = CAPTURE_XID_FLIP_CHAIN;
            chain.dwCount              = lpCSData->dwSCnt;
            captureLog (&chain, sizeof(chain));
            for (DWORD ii=0; ii<lpCSData->dwSCnt; ii++) {
                pDDSLcl = lpCSData->lplpSList[lpCSData->dwSCnt - ii - 1];
                DWORD dwSurfOffset = (GET_PNVOBJ(pDDSLcl))->getSimpleSurface()->getOffset();
                captureLog (&dwSurfOffset, sizeof(DWORD));
            }
        }
    }
#endif

#ifdef  NEW_FRONT_RENDER
    if (bPrimaryFlipChain) {
        if (lpCSData->dwSCnt == 2) {
            BackVidMem = lpCSData->lplpSList[1]->lpGbl->fpVidMem;
            pBackNvObj = GET_PNVOBJ (lpCSData->lplpSList[1]);
            lpCSData->lplpSList[1]->lpGbl->fpVidMem = lpCSData->lplpSList[0]->lpGbl->fpVidMem;
            SET_PNVOBJ(lpCSData->lplpSList[1], GET_PNVOBJ (lpCSData->lplpSList[0]));
        }
    }
#endif  //NEW_FRONT_RENDER

    if (IS_OVERLAY(pDDSLcl->ddsCaps.dwCaps, pDDSLcl->lpGbl->ddpfSurface.dwFourCC)) {
        if (pDDSLcl->lpGbl->wWidth < 640 && pDDSLcl->lpGbl->wHeight < 480) {
            // media player, quicktime, or realplayer
            pDriverData->vpp.dwOverlayFSSrcWidth = pDDSLcl->lpGbl->wWidth;
            pDriverData->vpp.dwOverlayFSSrcHeight = pDDSLcl->lpGbl->wHeight;
            pDriverData->vpp.dwOverlayFSSrcMinX = 0;
            pDriverData->vpp.dwOverlayFSSrcMinY = 0;
        } else {
            // DVD player, figure out the source bounding box dimensions later
            pDriverData->vpp.dwOverlayFSSrcWidth = 0;
            pDriverData->vpp.dwOverlayFSSrcHeight = 0;
            pDriverData->vpp.dwOverlayFSSrcMinX = 0xFFFFFFFF;
            pDriverData->vpp.dwOverlayFSSrcMinY = 0xFFFFFFFF;
        }

#ifdef VPEFSMIRROR
        VppCreateFSMirror(&(pDriverData->vpp), pDDSLcl->lpGbl->wWidth, pDDSLcl->lpGbl->wHeight);
        if (pDriverData->nvpeState.bVPEInitialized && (pDriverData->vpp.dwOverlayFSNumSurfaces > 0)) {
            NVPFsMirrorEnable(pDriverData);
        }
#else
        if(!(pDriverData->nvpeState.bVPEInitialized)) {
            VppCreateFSMirror(&(pDriverData->vpp), pDDSLcl->lpGbl->wWidth, pDDSLcl->lpGbl->wHeight);
        }
#endif
    }

    NvReleaseSemaphore(pDriverData);
    DDENDTICK(SURF4_CREATESURFACE);

    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);

} // CreateSurface32

//---------------------------------------------------------------------------

// CanCreateSurface32
//
// Determine whether we support creation of a particular surface type in our HAL driver
//
// NOTES:
// This entry point is called after parameter validation but before
// any object creation.   You can decide here if it is possible for
// you to create this surface.  For example, if the person is trying
// to create an overlay, and you already have the maximum number of
// overlays created, this is the place to fail the call.
//
// You also need to check if the pixel format specified can be supported.
//
// lpCanCreateSurface->bIsDifferentPixelFormat tells us if the pixel format of the
// surface being created matches that of the primary surface.  It can be
// true for Z buffer and alpha buffers, so don't just reject it out of
// hand...

DWORD __stdcall CanCreateSurface32 (LPDDHAL_CANCREATESURFACEDATA lpCanCreateSurface)
{
    dbgTracePush ("CanCreateSurface32");

    if (lpCanCreateSurface->lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER) {
        // silly hack for screwed up kernel calls
        DWORD dwRetVal;
        dwRetVal = D3DCanCreateExecuteBuffer32(lpCanCreateSurface);
        dbgTracePop();
        return dwRetVal;
    }


    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface, lpCanCreateSurface->lpDD=%08x", lpCanCreateSurface->lpDD );
    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "    lpCanCreateSurface->lpDDSurfaceDesc=%08x", lpCanCreateSurface->lpDDSurfaceDesc );

    DDSTARTTICK(SURF4_CANCREATESURFACE);
    nvSetDriverDataPtrFromDDGbl (lpCanCreateSurface->lpDD);

    LPDDSURFACEDESC lpDDSurface = lpCanCreateSurface->lpDDSurfaceDesc;
    DWORD caps         = lpDDSurface->ddsCaps.dwCaps;
    DWORD dwModeWidth  = GET_MODE_WIDTH();
    DWORD dwModeHeight = GET_MODE_HEIGHT();
    DWORD dwModeBPP    = GET_MODE_BPP() >> 3;

    // Reset NV and get the monitor frequency after a mode reset
    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {

        if (!nvEnable32 (lpCanCreateSurface->lpDD)) {
            DDENDTICK(SURF4_CREATESURFACE);
            NvReleaseSemaphore(pDriverData);
            lpCanCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }

    }

    if (caps & (DDSCAPS_MODEX | DDSCAPS_PALETTE)) {

        NvReleaseSemaphore(pDriverData);
        DDENDTICK(SURF4_CANCREATESURFACE);
        dbgTracePop();
        return (DDHAL_DRIVER_NOTHANDLED);

    }

    if ((dwModeBPP == 1) && (caps & DDSCAPS_ALPHA)) {

        NvReleaseSemaphore(pDriverData);
        DDENDTICK(SURF4_CANCREATESURFACE);
        dbgTracePop();
        return (DDHAL_DRIVER_NOTHANDLED);

    }

    if (caps & DDSCAPS_3DDEVICE) {

        if ((lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 16) && (lpDDSurface->ddpfPixelFormat.dwFlags & DDPF_ALPHAPIXELS)) {
            NvReleaseSemaphore(pDriverData);
            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - no 16bit alpha 3d render target");
            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            DDENDTICK(SURF4_CANCREATESURFACE);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
          }
    }

    if (caps & DDSCAPS_TEXTURE) {

        // Don't allow textures in 8bpp
        if (dwModeBPP == 1) {
            NvReleaseSemaphore(pDriverData);
            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 130");
            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            DDENDTICK(SURF4_CANCREATESURFACE);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }

        // ??BOGUS??  Do we really want to accept all other textures?  What about bogus
        // FOURCC formats?  What about contradictory flags in 'caps'?
        // Partial answer: CreateSurface() does these checks, which fills the functional
        // need and probably keeps code simpler for now.

        NvReleaseSemaphore(pDriverData);
        lpDDSurface->ddsCaps.dwCaps &= ~DDSCAPS_VIDEOMEMORY;
        lpDDSurface->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
        lpCanCreateSurface->ddRVal = DD_OK;
        DDENDTICK(SURF4_CANCREATESURFACE);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    // check pixel format.   Don't allow pixel formats that aren't
    // the same, unless we have a valid fourcc code, an overlay,
    // an alpha surface, or z buffer.

    if (lpCanCreateSurface->bIsDifferentPixelFormat) {

        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "    different pixel format!" );

        if ( lpDDSurface->ddpfPixelFormat.dwFlags & DDPF_ALPHAPREMULT ) {

            if ((dwModeBPP == 1) || (dwModeBPP == 2)) {
                // We don't support alpha surfaces in 8bpp mode
                NvReleaseSemaphore(pDriverData);
                DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - no alpha surf in 8bpp");
                lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                DDENDTICK(SURF4_CANCREATESURFACE);
                dbgTracePop();
                return (DDHAL_DRIVER_HANDLED);
            }

            if (dwModeBPP == 4) {
                if ((lpDDSurface->ddpfPixelFormat.dwRGBAlphaBitMask != 0xFF000000) ||
                    (lpDDSurface->ddpfPixelFormat.dwRBitMask != 0x00FF0000) ||
                    (lpDDSurface->ddpfPixelFormat.dwGBitMask != 0x0000FF00) ||
                    (lpDDSurface->ddpfPixelFormat.dwBBitMask != 0x000000FF)) {
                    NvReleaseSemaphore(pDriverData);
                    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - unsupported format 10");
                    lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }
                else {
                    NvReleaseSemaphore(pDriverData);
                    lpCanCreateSurface->ddRVal = DD_OK;
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }
            }
        }

        if ( lpDDSurface->ddpfPixelFormat.dwFlags & DDPF_FOURCC ) {

#ifdef WINNT
            // Don't allow NVDS surfaces to be created under NT or Win2K, since the
            // proprietary motion comp interface doesn't work there.
            if (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVDS) {
                NvReleaseSemaphore(pDriverData);
                lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                DDENDTICK(SURF4_CANCREATESURFACE);
                dbgTracePop();
                return (DDHAL_DRIVER_HANDLED);
            }
#endif

            if (dwModeBPP == 1) {
                // We don't support RGB FOURCCs in 8bpp mode
                if (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_RGB0) {
                    NvReleaseSemaphore(pDriverData);
                    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 10");
                    lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }
            }

            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "    FourCC requested (%4.4s, 0x%08x)",
                 (LPSTR) &lpDDSurface->ddpfPixelFormat.dwFourCC,
                 lpDDSurface->ddpfPixelFormat.dwFourCC );

            for (DWORD i=0; i < NV_MAX_FOURCC; i++) {

                if ( lpDDSurface->ddpfPixelFormat.dwFourCC == pDriverData->fourCC[i] ) {

                    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "    FOURCC=%4.4s", (LPSTR) &pDriverData->fourCC[i] );

                    // ??BOGUS??  Won't this test always fail?  The same test higher up seems
                    // to catch all cases.
                    if (caps & DDSCAPS_TEXTURE) {

#ifdef TEXFORMAT_CRD // --------------------------------

                        lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;

                        if ((pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)
                            &&
                            ((getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_NVXN) ||
                             (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_NVXN))
                            &&
                            ((lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVT0) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVT1) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVT2) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVT3) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVT4) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVT5) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVS0) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVS1) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVS2) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVS3) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVS4) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVS5))
                           )
                        {
                            // accept
                            lpCanCreateSurface->ddRVal = DD_OK;
                        }

                        if (((getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_HILO) ||
                             (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_HILO))
                            &&
                            ((lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVHS) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVHU))
                           )
                        {
                            // accept
                            lpCanCreateSurface->ddRVal = DD_OK;
                        }

                        if (((getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_DXT) ||
                             (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_DXT))
                            &&
                            ((lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_DXT1) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_DXT2) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_DXT3) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_DXT4) ||
                             (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_DXT5))
                           )
                        {
                            // accept
                            lpCanCreateSurface->ddRVal = DD_OK;
                        }

                        if (lpCanCreateSurface->ddRVal != DD_OK) {
                            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - unsupported texture format (via FOURCC)");
                        }

#else // !TEXFORMAT_CRD  --------------------------------

                        // allow only known texture fourcc formats
                        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                            if ((lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVT0)
                             || (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVT1)
                             || (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVT2)
                             || (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVT3)
                             || (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVT4)
                             || (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVT5)
                             || (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVS0)
                             || (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVS1)
                             || (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVS2)
                             || (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVS3)
                             || (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVS4)
                             || (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVS5)
#if defined(HILO_SUPPORT_DX7) || defined(HILO_SUPPORT_DX8)
                             || (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVHS)
                             || (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVHU)
#endif
                             )
                            {
                                // accept
                                lpCanCreateSurface->ddRVal = DD_OK;
                            }
                        }
#ifdef DXT_SUPPORT
                        if (((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_TEXTURECOMPRESSIONENABLE_MASK) ==
                               D3D_REG_TEXTURECOMPRESSIONENABLE_ENABLE)
                              &&
                              ((lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_DXT1) ||
                               (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_DXT2) ||
                               (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_DXT3) ||
                               (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_DXT4) ||
                               (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_DXT5))
                            )
                        {
                            // accept
                            lpCanCreateSurface->ddRVal = DD_OK;
                        } else
#endif
                        {
                            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - unsupported texture format (via FOURCC)");
                            lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                        }

#endif // !TEXFORMAT_CRD  --------------------------------

                        NvReleaseSemaphore(pDriverData);
                        DDENDTICK(SURF4_CANCREATESURFACE);
                        dbgTracePop();
                        return (DDHAL_DRIVER_HANDLED);
                    }

                    else if (caps & DDSCAPS_OVERLAY) {

                        if ((lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_UYVY) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_UYNV) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YUY2) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YUNV) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YV12) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_NV12) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_NVDS) &&
//                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_420i) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_IF09) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YVU9) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_IV32) &&
                            (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_IV31)) {
                            NvReleaseSemaphore(pDriverData);
                            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - unsupported format 20");
                            lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                            DDENDTICK(SURF4_CANCREATESURFACE);
                            dbgTracePop();
                            return (DDHAL_DRIVER_HANDLED);
                        }

                        if ((caps & (DDSCAPS_VIDEOPORT | DDSCAPS_FLIP)) == (DDSCAPS_VIDEOPORT | DDSCAPS_FLIP)) {
                            // Surface is for overlay with flip associated with video port
                            // check number of buffers, can't have more than 5 surfaces
                            // This will probably change when we have kernel mode flipping support
                            if ((lpDDSurface->dwFlags & DDSD_BACKBUFFERCOUNT) &&
                                (lpDDSurface->dwBackBufferCount > 4)) {
                                NvReleaseSemaphore(pDriverData);
                                DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid parameters 10");
                                lpCanCreateSurface->ddRVal = DDERR_INVALIDPARAMS;
                                DDENDTICK(SURF4_CANCREATESURFACE);
                                dbgTracePop();
                                return (DDHAL_DRIVER_HANDLED);
                            }
                        }
                        else {
                            // Workaround for Microsoft DirectVideo Cinepak decoding bug
                            // The reason for the existence of FOURCC_UYNV and FOURCC_YUNV
//                                              if ((lpDDSurface->dwFlags & DDSD_BACKBUFFERCOUNT) &&
//                                (lpDDSurface->dwBackBufferCount > 1) &&
//                                ((lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_UYVY) ||
//                                 (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_YUY2))) {
//                                                      lpCanCreateSurface->ddRVal = DDERR_INVALIDPARAMS;
//                                dbgTracePop();
//                                return DDHAL_DRIVER_HANDLED;
//                                          }

                            // We must limit number of YV12 overlay surfaces to the maximum number we can manage reformatting
                            if ((lpDDSurface->dwFlags & DDSD_BACKBUFFERCOUNT) &&
                                (lpDDSurface->dwBackBufferCount > 3) &&
                                (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_YV12)) {
                                NvReleaseSemaphore(pDriverData);
                                DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - out of caps 10");
                                lpCanCreateSurface->ddRVal = DDERR_OUTOFCAPS;
                                DDENDTICK(SURF4_CANCREATESURFACE);
                                dbgTracePop();
                                return (DDHAL_DRIVER_HANDLED);
                            }
                        }

                        if (VppIsOverlayActive(&pDriverData->vpp))
                        {
                            NvReleaseSemaphore(pDriverData);
                            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - out of caps 20");
                            lpCanCreateSurface->ddRVal = DDERR_OUTOFCAPS;
                            DDENDTICK(SURF4_CANCREATESURFACE);
                            dbgTracePop();
                            return (DDHAL_DRIVER_HANDLED);
                        }

                        // NB: Do not call VppGetVideoScalerBandwidthStatus() in CanCreateSurface() because
                        //     on some modesets (etc) Ddraw will re-create surfaces by ONLY calling CreateSurface().
                    }

                    else if (caps & (DDSCAPS_VIDEOMEMORY | DDSCAPS_OFFSCREENPLAIN)) {

                        // only support certain FOURCC formats
                        switch ( lpDDSurface->ddpfPixelFormat.dwFourCC )
                        {
                        // These are the formats we like.  They're supported in VppCreateFourCCSurface(),
                        // which seems to be the only routine that allocs a non-texture FOURCC surface.
                        //
                        // I've commented out a few for the following reasons (from previous check-ins):
                        //     Front end YUV support cannot reformat data so Indeo is not supported
                        //     Currently also disallowing front end YUV420 since YUYV or UYVY
                        //     should do ok when not enough backend bandwidth is available.
                        case FOURCC_RGB0:
                        case FOURCC_RAW8:
                      //case FOURCC_IF09:
                      //case FOURCC_YVU9:
                      //case FOURCC_IV32:
                      //case FOURCC_IV31:
#if IS_WINNT5 || IS_WIN9X
                        case FOURCC_NV12: // Our motion comp surface format
                        case FOURCC_NVMC: // Our motion comp control surface, NV10 or greater
                        case FOURCC_NVDS:
                        case FOURCC_NVSP: // A subpicture surface (overlay)
                        case FOURCC_NVID:
#endif
                        case FOURCC_YUY2:
                        case FOURCC_YUNV:
                        case FOURCC_UYVY:
                        case FOURCC_UYNV:
                      //case FOURCC_YV12:
                      //case FOURCC_420i:
                            // no-op -- we're happy if we get here
                            //--?? Why not return here?
                            break;

                        default:
                            // we can't/won't support anything but what's listed above
                            NvReleaseSemaphore(pDriverData);
                            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - unsupported format 30");
                            lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                            DDENDTICK(SURF4_CANCREATESURFACE);
                            dbgTracePop();
                            return (DDHAL_DRIVER_HANDLED);
                        }

                        if (caps & DDSCAPS_VIDEOPORT) {
                            // Nonoverlay FOURCC video surfaces are only supported for YUV422
                            // formats and only when associated with the video port
                            if ((lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YUY2) &&
                                (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_YUNV) &&
                                (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_UYVY) &&
                                (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_UYNV) &&
                                (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_RAW8)
                               ) {
                                NvReleaseSemaphore(pDriverData);
                                DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - unsupported format 40");
                                lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                                DDENDTICK(SURF4_CANCREATESURFACE);
                                dbgTracePop();
                                return (DDHAL_DRIVER_HANDLED);
                            }
                            // Front end YUV support not available in 8bit indexed mode
                        }
                        else if (dwModeBPP == 1) {
                            if (lpDDSurface->ddpfPixelFormat.dwFourCC != FOURCC_RAW8) {
                                NvReleaseSemaphore(pDriverData);
                                DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - unsupported format 50");
                                lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                                DDENDTICK(SURF4_CANCREATESURFACE);
                                dbgTracePop();
                                return (DDHAL_DRIVER_HANDLED);
                            }
                        }
                    }

                    if (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_RGB0) {
                        if (((dwModeBPP == 2) && (lpDDSurface->ddpfPixelFormat.dwRGBBitCount != DDBD_16)) ||
                            ((dwModeBPP == 4) && (lpDDSurface->ddpfPixelFormat.dwRGBBitCount != DDBD_32))) {
                            NvReleaseSemaphore(pDriverData);
                            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 20");
                            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                            DDENDTICK(SURF4_CANCREATESURFACE);
                            dbgTracePop();
                            return (DDHAL_DRIVER_HANDLED);
                        }
                    }

                    NvReleaseSemaphore(pDriverData);
                    lpCanCreateSurface->ddRVal = DD_OK;
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }

                else { // Check for known "hidden" FOURCC formats
                    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
                        if ((lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVMC) ||
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVDS) ||
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NV12) ||
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVID) ||
                            (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVSP)) {

                            if (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NVMC) {
                                if (pDriverData->vpp.dwOverlaySurfaces > 0) {
                                    NvReleaseSemaphore(pDriverData);
                                    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - out of caps 21");
                                    lpCanCreateSurface->ddRVal = DDERR_OUTOFCAPS;
                                    DDENDTICK(SURF4_CANCREATESURFACE);
                                    dbgTracePop();
                                    return (DDHAL_DRIVER_HANDLED);
                                }
                            }

                            if (lpDDSurface->ddpfPixelFormat.dwFourCC == FOURCC_NV12) {
                                if (VppGetVideoScalerBandwidthStatus(&pDriverData->vpp, lpCanCreateSurface->lpDDSurfaceDesc->dwWidth) == FALSE) {
                                    NvReleaseSemaphore(pDriverData);
                                    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - no overlay hardware 10");
                                    lpCanCreateSurface->ddRVal = DDERR_NOOVERLAYHW;
                                    DDENDTICK(SURF4_CANCREATESURFACE);
                                    dbgTracePop();
                                    return (DDHAL_DRIVER_HANDLED);
                                }
                            }

                            NvReleaseSemaphore(pDriverData);
                            lpCanCreateSurface->ddRVal = DD_OK;
                            DDENDTICK(SURF4_CANCREATESURFACE);
                            dbgTracePop();
                            return (DDHAL_DRIVER_HANDLED);
                        }
                    }
                }
            }
        }

        else if ( lpDDSurface->ddpfPixelFormat.dwFlags & DDPF_RGB ) {

            // Don't allow 3D devices in 8bpp
            if (caps & DDSCAPS_3DDEVICE) {
                if (lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 8) {
                    NvReleaseSemaphore(pDriverData);
                    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 30");
                    lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }
            }

            // ??BOGUS??  Won't the texture bit always be zero?  It appears that all texture
            // cases are handled higher up.
            if (caps & DDSCAPS_TEXTURE || caps & DDSCAPS_OFFSCREENPLAIN) {

                // Don't allow textures in 8bpp.
                if (dwModeBPP == 1) {
                    NvReleaseSemaphore(pDriverData);
                    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 40");
                    lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    dbgTracePop();
                    return (DDHAL_DRIVER_NOTHANDLED);
                }

                // accept 8 bit palettized textures
                // do I need to be more specific like DDPF_RGB also???
                // supposedly palette creation should be allowed here
                // when I set the Palette to Surface I need to check
                // matching bit depths there.
                if ((lpDDSurface->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8)
#ifdef TEXFORMAT_CRD
                    &&
                    ((getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_PALETTIZED) ||
                     (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_PALETTIZED))
                   )
#else   // !TEXFORMAT_CRD
                 && ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_PALETTEENABLE_MASK) == D3D_REG_PALETTEENABLE_ENABLE))
#endif  // !TEXFORMAT_CRD
                {
                    lpCanCreateSurface->ddRVal = DD_OK;
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    NvReleaseSemaphore(pDriverData);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }

                // accept all 16 and 32 bpp texture formats
                if ((lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 16) ||
                    (lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 32)) {
                    NvReleaseSemaphore(pDriverData);
                    lpCanCreateSurface->ddRVal = DD_OK;
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }
            }

            if (caps & DDSCAPS_ZBUFFER) {
                if (getDC()->nvD3DRegistryData.regValidateZMethod == D3D_REG_VALIDATEZMETHOD_STRICT) {
                    // For now, support z buffers in video memory only when our primary rendering depth is 16 bpp
                    if ((lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 16) && (dwModeBPP == 2)) {
                        // accept all 16 bpp z buffer formats when in 16 bpp disply mode
                        NvReleaseSemaphore(pDriverData);
                        lpCanCreateSurface->ddRVal = DD_OK;
                        DDENDTICK(SURF4_CANCREATESURFACE);
                        dbgTracePop();
                        return (DDHAL_DRIVER_HANDLED);
                    }
                    if ((lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 32) && (dwModeBPP == 4)) {
                        // accept all 32 bpp z buffer formats when in 32 bpp disply mode
                        NvReleaseSemaphore(pDriverData);
                        lpCanCreateSurface->ddRVal = DD_OK;
                        DDENDTICK(SURF4_CANCREATESURFACE);
                        dbgTracePop();
                        return (DDHAL_DRIVER_HANDLED);
                    }
                    // Any other z buffer depth or combination of z/display surface depths
                    // are invalid.
                    NvReleaseSemaphore(pDriverData);
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    dbgTracePop();
                    return (DDHAL_DRIVER_NOTHANDLED);
                }
                else {
                    // Allocate the z-buffer with the proper padding based on the bit depth of the primary surface
                    // accept all 16, 24, 32 bpp z buffer formats when in 16 bpp disply mode
                    if ((lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 16)
                        || (lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 24)
                        || (lpDDSurface->ddpfPixelFormat.dwRGBBitCount == 32)) {
                        NvReleaseSemaphore(pDriverData);
                        lpCanCreateSurface->ddRVal = DD_OK;
                        DDENDTICK(SURF4_CANCREATESURFACE);
                        dbgTracePop();
                        return (DDHAL_DRIVER_HANDLED);
                    }
                    // Any other z buffer depth or combination of z/display surface depths
                    // are invalid.
                    NvReleaseSemaphore(pDriverData);
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    dbgTracePop();
                    return (DDHAL_DRIVER_NOTHANDLED);
                }
            }

            // We don't support any other RGB surfaces not in our native format
            NvReleaseSemaphore(pDriverData);
            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 50");
            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            DDENDTICK(SURF4_CANCREATESURFACE);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);

        }

        else if ( lpDDSurface->ddpfPixelFormat.dwFlags & DDPF_ZBUFFER ) {

            // Don't allow z-buffer surfaces in 8bpp
            if (caps & DDSCAPS_ZBUFFER) {
                if (dwModeBPP == 1) {
                    NvReleaseSemaphore(pDriverData);
                    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 60");
                    lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    dbgTracePop();
                    return (DDHAL_DRIVER_NOTHANDLED);
                }
                if (getDC()->nvD3DRegistryData.regValidateZMethod == D3D_REG_VALIDATEZMETHOD_STRICT) {
                    if ((lpDDSurface->ddpfPixelFormat.dwZBufferBitDepth != (dwModeBPP << 3))) {
                        NvReleaseSemaphore(pDriverData);
                        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 70");
                        lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                        DDENDTICK(SURF4_CANCREATESURFACE);
                        dbgTracePop();
                        return (DDHAL_DRIVER_NOTHANDLED);
                    }
                }
                else {
                    if ((lpDDSurface->ddpfPixelFormat.dwZBufferBitDepth != 16)
                        && (lpDDSurface->ddpfPixelFormat.dwZBufferBitDepth != 24)
                        && (lpDDSurface->ddpfPixelFormat.dwZBufferBitDepth != 32)) {
                        NvReleaseSemaphore(pDriverData);
                        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 80");
                        lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                        DDENDTICK(SURF4_CANCREATESURFACE);
                        dbgTracePop();
                        return (DDHAL_DRIVER_NOTHANDLED);
                    }
                }
            }

            NvReleaseSemaphore(pDriverData);
            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "Z BUFFER OK!" );
            lpCanCreateSurface->ddRVal = DD_OK;
            DDENDTICK(SURF4_CANCREATESURFACE);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);

        }

        // can't handle any other kinds of different fourcc or RGB overlays
        NvReleaseSemaphore(pDriverData);
        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 90");
        lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
        DDENDTICK(SURF4_CANCREATESURFACE);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);

    }

    if (caps & DDSCAPS_MODEX) {

        NvReleaseSemaphore(pDriverData);
        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "    Mode X requested" );
        lpCanCreateSurface->ddRVal = DDERR_UNSUPPORTEDMODE;
        DDENDTICK(SURF4_CANCREATESURFACE);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);

    }

    // Don't allow 3D devices in 8bpp (except for primary surface access, fixes Jedi Knight)
    if ((caps & DDSCAPS_3DDEVICE) && (!(caps & DDSCAPS_PRIMARYSURFACE))) {

        if (dwModeBPP == 1) {
            NvReleaseSemaphore(pDriverData);
            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 100");
            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            DDENDTICK(SURF4_CANCREATESURFACE);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }

    }

    // Although the DD API passes DWORD height and width, the internal structures
    // of DDRAW only hold 16 bits.  So we refuse all surfaces that exceed that limit.
    if ((lpDDSurface->dwFlags & DDSD_HEIGHT) && (lpDDSurface->dwHeight > 0xFFFF))
    {
        NvReleaseSemaphore(pDriverData);
        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - height too big 105");
        lpCanCreateSurface->ddRVal = DDERR_TOOBIGHEIGHT;
        DDENDTICK(SURF4_CANCREATESURFACE);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    if ((lpDDSurface->dwFlags & DDSD_WIDTH) && (lpDDSurface->dwWidth > 0xFFFF))
    {
        NvReleaseSemaphore(pDriverData);
        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - width too big 105");
        lpCanCreateSurface->ddRVal = DDERR_TOOBIGWIDTH;
        DDENDTICK(SURF4_CANCREATESURFACE);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    if (caps & (DDSCAPS_FRONTBUFFER | DDSCAPS_PRIMARYSURFACE | DDSCAPS_VISIBLE)) {

        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "    Frontbuffer requested" );

        if (caps & DDSCAPS_OVERLAY) {
            NvReleaseSemaphore(pDriverData);
            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 110");
            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            DDENDTICK(SURF4_CANCREATESURFACE);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }

        if (caps & DDSCAPS_FLIP) {
            if (lpDDSurface->dwHeight > (unsigned long)dwModeHeight) {
                if (lpDDSurface->dwFlags & DDSD_HEIGHT) {
                    NvReleaseSemaphore(pDriverData);
                    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - height too big 10");
                    lpCanCreateSurface->ddRVal = DDERR_TOOBIGHEIGHT;
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }
                else {
                    lpDDSurface->dwHeight = (unsigned long)dwModeHeight;
                }

            }
            if (lpDDSurface->dwWidth > (unsigned long)dwModeWidth) {
                if (lpDDSurface->dwFlags & DDSD_WIDTH) {
                    NvReleaseSemaphore(pDriverData);
                    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - width too big 10");
                    lpCanCreateSurface->ddRVal = DDERR_TOOBIGWIDTH;
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }
                else {
                    lpDDSurface->dwWidth = (unsigned long)dwModeWidth;
                }
            }
        }
        NvReleaseSemaphore(pDriverData);
        lpCanCreateSurface->ddRVal = DD_OK;
        DDENDTICK(SURF4_CANCREATESURFACE);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);

    }

    else if (caps & DDSCAPS_BACKBUFFER) {

        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "    Backbuffer requested" );
        if (caps & DDSCAPS_OVERLAY) {
            NvReleaseSemaphore(pDriverData);
            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 120");
            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            DDENDTICK(SURF4_CANCREATESURFACE);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }

        if (caps & DDSCAPS_FLIP) {
            if (lpDDSurface->dwHeight > (unsigned long)dwModeHeight) {
                if (lpDDSurface->dwFlags & DDSD_HEIGHT) {
                    NvReleaseSemaphore(pDriverData);
                    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - height too big 20");
                    lpCanCreateSurface->ddRVal = DDERR_TOOBIGHEIGHT;
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }
                else {
                    lpDDSurface->dwHeight = (unsigned long)dwModeHeight;
                }

            }
            if (lpDDSurface->dwWidth > (unsigned long)dwModeWidth) {
                if (lpDDSurface->dwFlags & DDSD_WIDTH) {
                    NvReleaseSemaphore(pDriverData);
                    DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - width too big 20");
                    lpCanCreateSurface->ddRVal = DDERR_TOOBIGWIDTH;
                    DDENDTICK(SURF4_CANCREATESURFACE);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }
                else {
                    lpDDSurface->dwWidth = (unsigned long)dwModeWidth;
                }
            }
        }
        NvReleaseSemaphore(pDriverData);
        lpCanCreateSurface->ddRVal = DD_OK;
        DDENDTICK(SURF4_CANCREATESURFACE);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);

    }

    else if (caps & DDSCAPS_OFFSCREENPLAIN) {

        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "    Can create offscreen requested" );

        if (caps & DDSCAPS_VIDEOMEMORY) {
            if (caps & DDSCAPS_OVERLAY) {
                NvReleaseSemaphore(pDriverData);
                DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 140");
                lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                DDENDTICK(SURF4_CANCREATESURFACE);
                dbgTracePop();
                return (DDHAL_DRIVER_HANDLED);
            }

            if (caps & DDSCAPS_FLIP) {
                if (lpDDSurface->dwHeight > (unsigned long)dwModeHeight) {
                    if (lpDDSurface->dwFlags & DDSD_HEIGHT) {
                        NvReleaseSemaphore(pDriverData);
                        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - height too big 30");
                        lpCanCreateSurface->ddRVal = DDERR_TOOBIGHEIGHT;
                        DDENDTICK(SURF4_CANCREATESURFACE);
                        dbgTracePop();
                        return (DDHAL_DRIVER_HANDLED);
                    }
                    else {
                        lpDDSurface->dwHeight = (unsigned long)dwModeHeight;
                    }
                }
                if (lpDDSurface->dwWidth > (unsigned long)dwModeWidth) {
                    if (lpDDSurface->dwFlags & DDSD_WIDTH) {
                        NvReleaseSemaphore(pDriverData);
                        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - width too big 30");
                        lpCanCreateSurface->ddRVal = DDERR_TOOBIGWIDTH;
                        DDENDTICK(SURF4_CANCREATESURFACE);
                        dbgTracePop();
                        return (DDHAL_DRIVER_HANDLED);
                    }
                    else {
                        lpDDSurface->dwWidth = (unsigned long)dwModeWidth;
                    }

                }
            }
        }
        NvReleaseSemaphore(pDriverData);
        lpCanCreateSurface->ddRVal = DD_OK;
        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "    Can create offscreen granted" );
        DDENDTICK(SURF4_CANCREATESURFACE);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);

    }

    else if (caps & (DDSCAPS_FLIP | DDSCAPS_VIDEOMEMORY | DDSCAPS_ZBUFFER)) {

        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "    Can create flipping surface requested" );

        if (caps & DDSCAPS_OVERLAY) {
            NvReleaseSemaphore(pDriverData);
            DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 150");
            lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
            DDENDTICK(SURF4_CANCREATESURFACE);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
        if (caps & DDSCAPS_ZBUFFER) {
            if ((dwModeBPP != 2) && (dwModeBPP != 4)) {
                NvReleaseSemaphore(pDriverData);
                DPF_LEVEL(NVDBG_LEVEL_SURFACE, "CanCreateSurface32 - invalid pixel format 160");
                lpCanCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                DDENDTICK(SURF4_CANCREATESURFACE);
                dbgTracePop();
                return (DDHAL_DRIVER_HANDLED);
            }
        }
        NvReleaseSemaphore(pDriverData);
        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "    Can create flipping surface available" );
        lpCanCreateSurface->ddRVal = DD_OK;
        DDENDTICK(SURF4_CANCREATESURFACE);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);

    }

    else if (caps & DDSCAPS_SYSTEMMEMORY) {

        NvReleaseSemaphore(pDriverData);
        lpCanCreateSurface->ddRVal = DD_OK;
        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "    Can create system memory requested" );
        DDENDTICK(SURF4_CANCREATESURFACE);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);

    }

    NvReleaseSemaphore(pDriverData);
    DDENDTICK(SURF4_CANCREATESURFACE);
    dbgTracePop();
    return (DDHAL_DRIVER_NOTHANDLED);

} // CanCreateSurface32

//---------------------------------------------------------------------------

// DestroySurface32

DWORD __stdcall DestroySurface32 (LPDDHAL_DESTROYSURFACEDATA lpDestroySurface)
{
    dbgTracePush ("DestroySurface32");

    if (lpDestroySurface->lpDDSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
    {
        //silly hack for screwed up kernel calls
        DWORD dwRetVal;
        dwRetVal = D3DDestroyExecuteBuffer32(lpDestroySurface);
        dbgTracePop();
        return dwRetVal;
    }

    DDSTARTTICK(SURF4_DESTROYSURFACE);
    nvSetDriverDataPtrFromDDGbl (lpDestroySurface->lpDD);

    LPDDRAWI_DIRECTDRAW_GBL   pDDGbl  = lpDestroySurface->lpDD;
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl = lpDestroySurface->lpDDSurface;
    LPDDRAWI_DDRAWSURFACE_GBL pDDSGbl = pDDSLcl->lpGbl;

    DWORD dwIndex;


#ifdef  NEW_FRONT_RENDER
    if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_BACKBUFFER)
    {
        pDDSLcl->lpGbl->fpVidMem = BackVidMem;
        SET_PNVOBJ(pDDSLcl, pBackNvObj);
    }
#endif  //NEW_FRONT_RENDER
    if (global.dwDXRuntimeVersion < 0x700) {
        DPF_LEVEL(NVDBG_LEVEL_SURFACE_ACTIVITY, "DestroySurface: pDDGbl = %08x, pDDSLcl = %08x", pDDGbl, pDDSLcl);
    } else {
        DPF_LEVEL(NVDBG_LEVEL_SURFACE_ACTIVITY, "DestroySurface: pDDGbl = %08x, pDDSLcl = %08x, handle = %02x",
            pDDGbl, pDDSLcl, pDDSLcl->lpSurfMore->dwSurfaceHandle);
    }

    // textures do not want to wait for idle. check for them here
    if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE) {
        // Call the D3D driver to destroy the texture surface.
        nvTextureDestroySurface (lpDestroySurface, pDDSLcl);
        NvReleaseSemaphore(pDriverData);
        DDENDTICK(SURF4_DESTROYSURFACE);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }


    if(!pDriverData->vpp.dwOverlaySurfaces &&
        (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_DDRAW) &&
        (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE)) {
        //clear FSDOSSSTATUS_RECOVERYNEEDED_DDRAW flag if not overlay surface exists
        pDriverData->dwFullScreenDOSStatus &=  ~FSDOSSTATUS_RECOVERYNEEDED_DDRAW;

    }


    if ((pDriverData->lpProcessInfoHead) && (getDC()->nvPusher.isValid())) {
        WaitForIdle(TRUE, TRUE);
    }

    // clear ring0 flipping flag to make sure new surfaces aren't tagged for ring0 flipping
    if (IS_OVERLAY(pDDSLcl->ddsCaps.dwCaps, pDDSLcl->lpGbl->ddpfSurface.dwFourCC))
    {

        if((pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) &&
           (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE)) {
            //clear FSDOSSSTATUS_RECOVERYNEEDED_D3D flag
            nvD3DRecover();
        }
        // Should check if YUV surface is an active VPE surface and make sure
        // to stop VPE hardware before destroying VPE surface somewhere in YUV
        // surface code in this function.

        if (VppIsOverlayActive(&pDriverData->vpp))
        {
            NvNotification *pPioFlipOverlayNotifier = pDriverData->pPioFlipOverlayNotifierFlat;
            LPPROCESSINFO lpProcInfo = pmGetProcess(pDriverData, GetCurrentProcessId());

            if (!(pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_DDRAW)) {
                // make sure we sync with other channels before writing put
                getDC()->nvPusher.setSyncChannelFlag();

                pDriverData->dwRingZeroMutex = TRUE;

                if (getDC()->nvPusher.isValid()) {
                    Sleep(VPP_TIMEOUT_TIME * 3);
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
                    nvPushData(1, NV_VPP_OVERLAY_IID);
                    nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | NV07A_STOP_OVERLAY(0) | 0x80000);
                    nvPushData(3, NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE);  // StopOverlay[0]
                    nvPushData(4, NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE);  // StopOverlay[1]
                    nvPusherAdjust(5);
                    nvPusherStart(TRUE);
                }
            }

            pDriverData->dwRingZeroMutex = FALSE;
            pDriverData->dDrawSpareSubchannelObject = 0;

            // Only do recover if a DOS full screen switch has completed.
            if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_DDRAW) {
                if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
                nvDDrawRecover();
                }
            }
        }

#ifdef NVPE
        NVPCleanUp(pDriverData, pDDGbl);
#else
        pDriverData->bRing0FlippingFlag = FALSE;
#endif // NVPE

        pDriverData->vpp.dwOverlayLastVisibleSurfaceLCL = NULL;

        if (pDriverData->vpp.dwOverlayFSNumSurfaces){
            VppDestroyFSMirror(&(pDriverData->vpp));
#ifdef VPEFSMIRROR
            if (pDriverData->nvpeState.bFsMirrorEnabled) {
                NVPFsMirrorDisable(pDriverData);
            }
#endif
        }

        //destroy overlay only when it is active and for the last overly
        //surface.
        if (VppIsOverlayActive(&pDriverData->vpp)
            && (pDriverData->vpp.dwOverlaySurfaces <= 1)){
            VppDestroyOverlay(&(pDriverData->vpp));
        }
    }

    // if there's an NvObject associated with this DDSLcl, remove its entry from
    // our list of handles. (this is because assinine apps will later reference
    // handles to surfaces they've previously destroyed)
    CNvObject *pObj = GET_PNVOBJ (pDDSLcl);

    if ((((DWORD)pObj) & MASK_FLOATING_CONTEXT_DMA_ID) == FLOATING_CONTEXT_DMA_ID) {
        // DX7 doesn't always call CreateSurfaceEx, in these cases we may be storing
        // a floating system memory DMA context at this location
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, ((DWORD)pObj));
        SET_PNVOBJ(pDDSLcl, NULL);
        pObj = NULL;
    }

    // Don't exit early for Primary surfaces on surfaces that aren't really Primary.
    // In Win2K fpVidMem and GET_PRIMARY_ADDR() may both be zero if an Overlay
    // or other FourCC surface create fails.
    if (!((pDDSLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
        (pDDSGbl->ddpfSurface.dwFlags & DDPF_FOURCC))) {

        if (pDDSGbl->fpVidMem == GET_PRIMARY_ADDR()) {
#ifdef WINNT
            ppdev->bD3DappIsRunning = FALSE;
#endif
            lpDestroySurface->ddRVal = DD_OK;
           // Need to tell NT displaydriver that we destroyed a PRIMARY surface
            NV_OGLDDRAWSURFACEDESTROYED(ppdev);
            goto Handled_Exit;
        }
    }

    // Mode switches might occur without warning
    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED)
    {
        if (!nvEnable32 (lpDestroySurface->lpDD)) {
            lpDestroySurface->ddRVal = DDERR_OUTOFMEMORY;
            goto Handled_Exit;
        }
    }

    if ((pDDSLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
        (pDDSGbl->ddpfSurface.dwFlags & DDPF_FOURCC)) {

        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "  FOURCC surface" );

        // destroy shared system workspace
        if (IS_OVERLAY(pDDSLcl->ddsCaps.dwCaps, pDDSLcl->lpGbl->ddpfSurface.dwFourCC) &&
            (pDriverData->vpp.dwOverlaySurfaces <= 1))
        {
            // tells the ring0 code to not run any more!
            pDriverData->vpp.regRing0ColourCtlInterlockFlags = pDriverData->vpp.regRing0ColourCtlInterlockFlags & 0xFFFFFFFE;
            {
                DWORD aCount = 16;
                while((pDriverData->vpp.regRing0ColourCtlInterlockFlags & 0x02) && aCount-- ) {
                    Sleep(1);  // waits 1 millisecond
                }
            }
            if (pDriverData->vpp.fpOverlayShadow)
            {
                NvRmFree(pDriverData->dwRootHandle, pDriverData->vpp.hChannel,
                         NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_OVERLAY_SHADOW);
                FreeIPM((void*)pDriverData->vpp.fpOverlayShadow);
                pDriverData->vpp.fpOverlayShadow = 0;
            }

            pDriverData->dDrawSpareSubchannelObject = 0;
        }

        switch ( pDDSLcl->lpGbl->ddpfSurface.dwFourCC ) {
            case FOURCC_RGB0:
            case FOURCC_RAW8:
                if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {
                    if (pDDSGbl->fpVidMem > 0) {
                        NVHEAP_FREE (pDDSGbl->fpVidMem);
                        pDDSGbl->fpVidMem = 0;
                        if (pDriverData->DDrawVideoSurfaceCount > 0)
                            pDriverData->DDrawVideoSurfaceCount--;
                    }
                }
                else {
                    HGLOBAL hMem = (HGLOBAL)pDDSGbl->dwReserved1;
                    GlobalFree(hMem);
                    pDDSGbl->dwReserved1 = 0;
                }
                lpDestroySurface->ddRVal = DD_OK;
                goto Handled_Exit;
                break;

            case FOURCC_NVMC: // Our Win9x motion comp control surface, only on NV10 or greater
                if (pDDSGbl->fpVidMem > 0) {
                    NVHEAP_FREE (pDDSGbl->fpVidMem);
                    pDDSGbl->fpVidMem = 0;
                    if (pDriverData->DDrawVideoSurfaceCount > 0)
                        pDriverData->DDrawVideoSurfaceCount--;
                }

                pDDSGbl->dwReserved1 = 0;

                pDriverData->dwMCNVMCSurface = 0;

                lpDestroySurface->ddRVal = DD_OK;
                goto Handled_Exit;
                break;

            case FOURCC_NVDS: // Our Win9x Direct Show dummy motion comp surface, only on NV10 or greater
                if ((pDriverData->dwMCNVDSSurfaceBase != 0) && (pDDSGbl->fpVidMem > 0)) {
                    pDriverData->dwMCNVDSSurfaceBase = 0;
                    NVHEAP_FREE (pDDSGbl->fpVidMem);
                }

                pDDSGbl->fpVidMem = 0;

                if (pDriverData->DDrawVideoSurfaceCount > 0)
                    pDriverData->DDrawVideoSurfaceCount--;

                pDDSGbl->dwReserved1 = 0;

                lpDestroySurface->ddRVal = DD_OK;
                goto Handled_Exit;
                break;

            case FOURCC_NVSP: // a subpicture surface (overlay)
                if (pDDSGbl->fpVidMem > 0) {
                    NVHEAP_FREE (pDDSGbl->fpVidMem);
                    pDDSGbl->fpVidMem = 0;
                    if (pDriverData->DDrawVideoSurfaceCount > 0)
                        pDriverData->DDrawVideoSurfaceCount--;
                }

                pDDSGbl->dwReserved1 = 0;

                lpDestroySurface->ddRVal = DD_OK;
                goto Handled_Exit;
                break;

            case FOURCC_NVID: // These surfaces can exist only on NV10 or greater
                // Send a sync to make sure we are done with it

                if (!(pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_DDRAW)) {
                    // Let D3D code know that we have touched NV
                    pDriverData->TwoDRenderingOccurred = 1;

                    getDC()->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);

                    // Make sure celsius class isn't currently referencing an IDCT context Dma
                    if (getDC()->nvPusher.isValid()) {
                        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                          NV097_SET_CONTEXT_DMA_B | 0x40000);
                            nvPushData(1, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY); // Reset to what D3D expects to see
                            nvPusherAdjust(2);
                            nvPusherStart(TRUE);
                        } else {
                            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                          NV056_SET_CONTEXT_DMA_B | 0x40000);
                            nvPushData(1, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY); // Reset to what D3D expects to see
                            nvPusherAdjust(2);
                            nvPusherStart(TRUE);
                        }
                        pDriverData->dwMostRecentHWUser = MODULE_ID_DDRAW;
                    }
                    // wait for HW to catch up
                    getDC()->pRefCount->wait (CReferenceCount::WAIT_PREEMPTIVE);
                }

                // Clear current IDCT context Dma
                pDriverData->dwMCCurrentCelsiusIDCTCtxDma = 0;

                for (dwIndex=0; dwIndex<4; dwIndex++) {
                    if (pDDSGbl->fpVidMem == pDriverData->dwMCIDCTAGPSurfaceBase[dwIndex]) {
                        pDriverData->dwMCIDCTAGPSurfaceBase[dwIndex] = 0;
                        if (pDriverData->dwMCIDCTAGPCtxDmaSize[dwIndex] != 0) {
                            NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                                     NV_DD_DMA_FLOATING_MC_IDCT0_CONTEXT_DMA_FROM_MEMORY+dwIndex);
                            pDriverData->dwMCIDCTAGPCtxDmaSize[dwIndex] = 0;
                            pDriverData->dwMCCurrentCelsiusIDCTCtxDma = 0;
                        }
                    }
                }

                // First check if surface is in video memory
                if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_LOCALVIDMEM) {
                    if (pDDSGbl->fpVidMem > 0) {
                        // free memory using initial unadjusted pointer
                        NVHEAP_FREE (pDDSGbl->dwReserved1);
                        pDDSGbl->fpVidMem = 0;
                        if (pDriverData->DDrawVideoSurfaceCount > 0)
                            pDriverData->DDrawVideoSurfaceCount--;
                    }
                } else {
                    // this should never happen
                    nvAssert(0);
                }

                pDDSGbl->dwReserved1 = 0;

                lpDestroySurface->ddRVal = DD_OK;
                goto Handled_Exit;
                break;

            case FOURCC_IF09:
            case FOURCC_YVU9:
            case FOURCC_IV32:
            case FOURCC_IV31:
            case FOURCC_YUY2:
            case FOURCC_YUNV:
            case FOURCC_UYVY:
            case FOURCC_UYNV:
            case FOURCC_NV12:
            case FOURCC_YV12:
                if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                    DWORD dwIndex = 0;
                    if (pDriverData->vpp.dwOverlaySurfaces > 0)
                        pDriverData->vpp.dwOverlaySurfaces--;
                    if (pDriverData->vpp.dwOverlaySurfaces == 0) {
                        pDriverData->vpp.dwOverlayOwner = 0;
                        for (DWORD i = 0; i < NV_VPP_MAX_EXTRA_SURFACES; i++) {
                            pDriverData->vpp.extraOverlayOffset[i] = 0;
                        }
                        pDriverData->vpp.extraNumSurfaces = 0;
                        pDriverData->bMCOverlaySrcIsSingleField1080i = FALSE;
                        pDriverData->bMCHorizontallyDownscale1080i = FALSE;
                    }
                    while (dwIndex < NV_VPP_MAX_OVERLAY_SURFACES) {
                        if ((DWORD)pDDSLcl == pDriverData->vpp.dwOverlaySurfaceLCL[dwIndex]) {
                            pDriverData->vpp.dwOverlaySurfaceLCL[dwIndex] = 0;
                        }
                        dwIndex++;
                    }
                }

                if ((pDDSLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
                    ((pDDSLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) == 0)) {
                    if (pDDSGbl->fpVidMem > 0) {
                        if (pDDSGbl->fpVidMem + pDDSGbl->dwReserved1 - pDriverData->BaseAddress ==
                            pDriverData->vpp.extraOverlayOffset[0]) {
                            for (DWORD i = 0; i < NV_VPP_MAX_EXTRA_SURFACES; i++) {
                                pDriverData->vpp.extraOverlayOffset[i] = 0;
                            }
                            pDriverData->vpp.extraNumSurfaces = 0;
                        }
                        NVHEAP_FREE (pDDSGbl->fpVidMem);
                        pDDSGbl->fpVidMem = 0;
                        if (pDriverData->DDrawVideoSurfaceCount > 0)
                            pDriverData->DDrawVideoSurfaceCount--;
                    }
                }
                else {
                    HGLOBAL hMem = (HGLOBAL)pDDSGbl->dwReserved1;
                    GlobalFree(hMem);
                }
                pDDSGbl->dwReserved1 = 0;
                lpDestroySurface->ddRVal = DD_OK;
                goto Handled_Exit;
                break;
            case FOURCC_420i:
                if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY) {
                    DWORD dwIndex = 0;
                    while (dwIndex < NV_VPP_MAX_OVERLAY_SURFACES) {
                        if ((DWORD)pDDSLcl == pDriverData->vpp.dwOverlaySurfaceLCL[dwIndex]) {
                            pDriverData->vpp.dwOverlaySurfaceLCL[dwIndex] = 0;
                            if (pDriverData->vpp.dwOverlaySurfaces > 0)
                                pDriverData->vpp.dwOverlaySurfaces--;
                            if (pDriverData->vpp.dwOverlaySurfaces == 0) {
                                pDriverData->vpp.dwOverlayOwner = 0;
                            }
                        }
                        dwIndex++;
                    }
                }

                if ((pDDSLcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
                    (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)) {
#ifdef OLD_BLIT_CODE
                    if (pDDSGbl->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0]) {

                        if (pDriverData->NvYUY2Surface0Mem > 0) {
                            NVHEAP_FREE (pDriverData->NvYUY2Surface0Mem);
                            pDriverData->NvYUY2Surface0Mem = 0;
                            if (pDriverData->DDrawVideoSurfaceCount > 0)
                                pDriverData->DDrawVideoSurfaceCount--;
                        }

                        if (!(pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_DDRAW) &&
                            (getDV()->nvPusher.isValid())) {
                            // make sure we sync with other channels before writing put
                            getDC()->nvPusher.setSyncChannelFlag();
                        }

                        if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {  // Mode switches might occur without warning
                            NvReleaseSemaphore(pDriverData);
                            lpDestroySurface->ddRVal = DDERR_SURFACELOST;
                            DDENDTICK(SURF4_DESTROYSURFACE);
                            dbgTracePop();
                            return (DDHAL_DRIVER_HANDLED);
                        }

                        // If AGP memory then send a sync rectangle to make sure we are done with it
                        if ((pDDSLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) &&
                           !(pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_DDRAW)) {

                            NvNotification *pDmaSyncNotifier = (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;

                            // Let D3D code know that we have touched NV
                            pDriverData->TwoDRenderingOccurred = 1;

                            // MUST wait for any pending notification to prevent possible loss of notification serialization
                            while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP;
#ifdef CAPTURE
                            if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                                CAPTURE_SYNC3 sync;
                                sync.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                                sync.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                                sync.dwExtensionID        = CAPTURE_XID_SYNC3;
                                sync.dwType               = CAPTURE_SYNC_TYPE_NOTIFIER;
                                sync.dwCtxDMAHandle       = NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
                                sync.dwOffset             = 0;
                                sync.dwValue              = 0;
                                captureLog (&sync,sizeof(sync));
                            }
#endif // CAPTURE
                            pDmaSyncNotifier->status = NV_IN_PROGRESS;

                            nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000);
                            nvPushData (1,0);
                            nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000);
                            nvPushData (3,0);
                            nvPusherAdjust (4);
                            nvPusherStart  (TRUE);

                            while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification
#ifdef CAPTURE
                            if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                                CAPTURE_SYNC3 sync;
                                sync.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                                sync.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                                sync.dwExtensionID        = CAPTURE_XID_SYNC3;
                                sync.dwType               = CAPTURE_SYNC_TYPE_NOTIFIER;
                                sync.dwCtxDMAHandle       = NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
                                sync.dwOffset             = 0;
                                sync.dwValue              = 0;
                                captureLog (&sync,sizeof(sync));
                            }
#endif // CAPTURE
                        }

#ifdef OLD_BLIT_CODE
                        if ((pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] <
                             pDriverData->BaseAddress) || // If system memory
                            (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] >
                             (unsigned long)pDriverData->VideoHeapEnd)) {
                            NvNotification *pDmaSyncNotifier =
                            (NvNotification *)pDriverData->NvDmaSyncNotifierFlat;

                            if (!(pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_DDRAW)) {
                                // Let D3D code know that we have touched NV
                                pDriverData->TwoDRenderingOccurred = 1;

                                // MUST wait for any pending notification to prevent possible loss of notification serialization
                                while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP;

                                pDriverData->dDrawSpareSubchannelObject = 0;

                                pDmaSyncNotifier->status = NV_IN_PROGRESS;

                                // Trash spare subchannel
                                nvPushData (0,dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
                                nvPushData (1,NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT);
                                nvPushData (2,dDrawSubchannelOffset(NV_DD_SPARE) +
                                                         MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000);
                                nvPushData (3,NV1_NULL_OBJECT);
                                nvPushData (4,dDrawSubchannelOffset(NV_DD_SPARE) +
                                                         MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000);
                                nvPushData (5,NV1_NULL_OBJECT);
                                nvPushData (6,dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
                                nvPushData (7,NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT);
                                nvPushData (8,dDrawSubchannelOffset(NV_DD_SPARE) +
                                                         MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000);
                                nvPushData (9,NV1_NULL_OBJECT);
                                nvPushData (10,dDrawSubchannelOffset(NV_DD_SPARE) +
                                                          MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000);
                                nvPushData (11,NV1_NULL_OBJECT);
                                nvPushData (12,dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
                                nvPushData (13,NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT);
                                nvPushData (14,dDrawSubchannelOffset(NV_DD_SPARE) +
                                                          MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000);
                                nvPushData (15,NV1_NULL_OBJECT);
                                nvPushData (16,dDrawSubchannelOffset(NV_DD_SPARE) +
                                                          MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000);
                                nvPushData (17,NV1_NULL_OBJECT);
                                nvPushData (18,dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
                                nvPushData (19,NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT);
                                nvPushData (20,dDrawSubchannelOffset(NV_DD_SPARE) +
                                                          MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET | 0x40000);
                                nvPushData (21,NV1_NULL_OBJECT);
                                nvPushData (22,dDrawSubchannelOffset(NV_DD_SPARE) +
                                                          MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x40000);
                                nvPushData (23,NV1_NULL_OBJECT);
                                nvPushData (24,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                                                          RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000);
                                nvPushData (25,0);
                                nvPushData (26,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) +
                                                          RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000);
                                nvPushData (27,0);

                                nvPusherAdjust (28);
                                nvPusherStart  (TRUE);

                                while ((volatile)pDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification
                            }

                            NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                                     NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY);
                        }
#endif  // OLD_BLIT_CODE

                        // If in AGP memory then deallocate it from there
                        if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) {
                            // this should never happen
                            nvAssert(0);
                        }
                        else {
#ifdef OLD_BLIT_CODE
                            if ((pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] <
                                 pDriverData->BaseAddress) || // If system memory
                                (pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] >
                                 (unsigned long)pDriverData->VideoHeapEnd)) {
                                GlobalFree((HGLOBAL)pDriverData->NvFloatingMem2MemFormatMemoryHandle);
                            }
                            else {
#endif
                                NVHEAP_FREE (pDDSGbl->fpVidMem);
                                if (pDriverData->DDrawVideoSurfaceCount > 0)
                                    pDriverData->DDrawVideoSurfaceCount--;
#ifdef OLD_BLIT_CODE
                            }
#endif
                        }

#ifdef OLD_BLIT_CODE
                        pDriverData->NvFloatingMem2MemFormatMemoryHandle = 0;

                        pDriverData->NvFloatingMem2MemFormatSurfaceAddress[0] = 0;
                        pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1] = 0;
                        pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2] = 0;
                        pDriverData->NvFloatingMem2MemFormatSurfaceAddress[3] = 0;
#endif  // OLD_BLIT_CODE
                    }
                    else {
#ifdef OLD_BLIT_CODE
                        if (pDDSGbl->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1]) {
                            pDriverData->NvFloatingMem2MemFormatSurfaceAddress[1] = 0;
                            if (pDriverData->NvYUY2Surface1Mem > 0) {
                                NVHEAP_FREE (pDriverData->NvYUY2Surface1Mem);
                                pDriverData->NvYUY2Surface1Mem = 0;
                                if (pDriverData->DDrawVideoSurfaceCount > 0)
                                    pDriverData->DDrawVideoSurfaceCount--;
                            }
                        }
                        else if (pDDSGbl->fpVidMem == pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2]) {
                            pDriverData->NvFloatingMem2MemFormatSurfaceAddress[2] = 0;
                            if (pDriverData->NvYUY2Surface2Mem > 0) {
                                NVHEAP_FREE (pDriverData->NvYUY2Surface2Mem);
                                pDriverData->NvYUY2Surface2Mem = 0;
                                if (pDriverData->DDrawVideoSurfaceCount > 0)
                                    pDriverData->DDrawVideoSurfaceCount--;
                            }
                        }
                        else {
                            if (pDriverData->NvYUY2Surface3Mem > 0) {
                                NVHEAP_FREE (pDriverData->NvYUY2Surface3Mem);
                                pDriverData->NvYUY2Surface3Mem = 0;
                                if (pDriverData->DDrawVideoSurfaceCount > 0)
                                    pDriverData->DDrawVideoSurfaceCount--;
                            }
                        }
#endif  // OLD_BLIT_CODE
                    }
#endif  // OLD_BLIT_CODE
                    pDDSGbl->fpVidMem = 0;
                }
                else if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {
                    if (pDDSGbl->fpVidMem > 0) {
                        NVHEAP_FREE (pDDSGbl->fpVidMem);
                        pDDSGbl->fpVidMem = 0;
                        if (pDriverData->DDrawVideoSurfaceCount > 0)
                            pDriverData->DDrawVideoSurfaceCount--;
                    }
                }
                else {
                    HGLOBAL hMem = (HGLOBAL)pDDSGbl->dwReserved1;
                    GlobalFree(hMem);
                }
                NvReleaseSemaphore(pDriverData);
                pDDSGbl->dwReserved1 = 0;
                lpDestroySurface->ddRVal = DD_OK;
                DDENDTICK(SURF4_DESTROYSURFACE);
                dbgTracePop();
                return (DDHAL_DRIVER_HANDLED);
                break;
        }
    }

    else if ((pDDSLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)) {
        // surfaces in this branch must have an NVObject
        if (global.dwDXRuntimeVersion < 0x0700) {
            // make sure that DX6 render targets still point at the right memory
            CSimpleSurface* pSurf = pObj ? pObj->getSimpleSurface() : NULL;
            if (pSurf) {
                // undo damage caused by nvRefreshSurfaceInfo
                pSurf->setAddress(pDDSGbl->fpVidMem);
            }
        }

        if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_ZBUFFER){
            //walk the pcontext lists to remove any dangling references to this zbuffer
            //our nvCelsiusAACreate will touch this pointer later and cause problems.
            //ideally zbuffer/destroys are not frequent so this should be low impact.
            PNVD3DCONTEXT pContext;
            pContext = (PNVD3DCONTEXT)getDC()->dwContextListHead;
            while(pContext){
                if(pObj && pContext->pZetaBuffer == pObj->getSimpleSurface()) pContext->pZetaBuffer = NULL;
                // update cached pointer
                pContext->kelvinAA.UpdateZBuffer();
                pContext = pContext->pContextNext;
            }
        }

        // the surface, surface object and NVObject will all be deallocated when the NVObject is released below
        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "    Offscreen deallocated" );
        pDDSGbl->fpVidMem = 0;
        pDDSGbl->dwReserved1 = 0;
        lpDestroySurface->ddRVal = DD_OK;
        goto Handled_Exit;
    }

    else if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) {
        DPF_LEVEL(NVDBG_LEVEL_SURFACE, "    System memory deallocated" );
        HGLOBAL hMem = (HGLOBAL)pDDSGbl->dwReserved1;
        GlobalFree(hMem);
        pDDSGbl->dwReserved1 = 0;
        lpDestroySurface->ddRVal = DD_OK;
        goto Handled_Exit;
    }

    NvReleaseSemaphore(pDriverData);
    DDENDTICK(SURF4_DESTROYSURFACE);
    dbgTracePop();
    return (DDHAL_DRIVER_NOTHANDLED);

Handled_Exit:
    if (pObj) {
        nvClearObjectListEntry (pObj, &global.pNvSurfaceLists);
#ifndef WINNT
        if (pObj == (CNvObject*)pDXShare->pNvPrimarySurf)
        {
            DPF("DestroySurface32 called for primary surface, freeing back buffers instead");
            // normally we don't get calls to free the primary surface on Win9X, but sometimes the runtime
            // gets mixed up and sends us a destroy call for the primary surface but not for the back buffer.
            // in this case we should release the backbuffer to prevent a memory leak
            pObj = pObj->getAttachedA();
            if (pObj) {
                pObj->release();
            }
        } else {
            pObj->release();
        }
#else
        pObj->release();
#endif
        // clear the dwReseved field (pointer to the NvObject). on NT we must check for this when
        // traversing the surface chain in CreateSurfaceEx and ignore surfaces with deleted NvObjects
        // this corresponds with the explicit attachment concept under win9x
        SET_PNVOBJ(pDDSLcl, NULL);
    }

    NvReleaseSemaphore(pDriverData);
    DDENDTICK(SURF4_DESTROYSURFACE);
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
} // DestroySurface32

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\MoComp.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*==========================================================================;
 *
 *  Copyright (C) 2000 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       MoComp.cpp
 *  Content:    Windows98 DirectDraw 32 bit driver
 *
 ***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

#include "dxshare.h"

// For DirectX VA definitions.
// Note: Initguid.h causes Guids defined in Dxvadefs.h to be created as global data.
#include "initguid.h"
#include "dxvadefs.h"


extern NVMOCOMPPARAMS           nvMoCompParams;

#ifndef WINNT
    extern DISPDRVDIRECTXCOMMON    *pDXShare;
#endif // WINNT

extern DWORD __stdcall nvInitCelsiusForMoComp(void);
extern DWORD __stdcall nvInitCelsiusForMoCompPrediction(void);
extern DWORD __stdcall nvInitCelsiusForMoCompCorrection();
extern DWORD __stdcall nvInitCelsiusForMoCompConversion(void);
extern DWORD __stdcall nvInitCelsiusForMoCompTemporalFilter(void);
extern DWORD __stdcall nvMoCompProcessCelsiusFrameMacroblocks(LPNVDECODEMACROBLOCK pMacroblocks,
                                                              DWORD numMacroblocks, BYTE formatConversionStatus);
extern DWORD __stdcall nvMoCompProcessCelsiusFieldMacroblocks(LPNVDECODEMACROBLOCK pMacroblocks,
                                                              DWORD numMacroblocks, BYTE formatConversionStatus);
extern DWORD __stdcall nvInitKelvinForMoComp(void);
extern DWORD __stdcall nvInitKelvinForMoCompPrediction(void);
extern DWORD __stdcall nvInitKelvinForMoCompCorrection();
extern DWORD __stdcall nvInitKelvinForMoCompConversion(void);
extern DWORD __stdcall nvInitKelvinForMoCompTemporalFilter(void);
extern DWORD __stdcall nvMoCompProcessKelvinFrameMacroblocks(LPNVDECODEMACROBLOCK pMacroblocks,
                                                              DWORD numMacroblocks, BYTE formatConversionStatus);
extern DWORD __stdcall nvMoCompProcessKelvinFieldMacroblocks(LPNVDECODEMACROBLOCK pMacroblocks,
                                                              DWORD numMacroblocks, BYTE formatConversionStatus);

PNVMCPREDFUNC nvDoBidirectionalFieldPrediction;
PNVMCPREDFUNC nvDoTwoBidirectionalFieldPredictions;
PNVMCPREDFUNC nvDoForwardFieldPrediction;
PNVMCPREDFUNC nvDoTwoForwardFieldPredictions;
PNVMCPREDFUNC nvDoBackwardFieldPrediction;
PNVMCPREDFUNC nvDoTwoBackwardFieldPredictions;

PNVMCPREDFUNC2 nvPredictFrameLumaMacroblock;
PNVMCPREDFUNC2 nvPredictFieldLumaMacroblock;
PNVMCPREDFUNC2 nvPredictFrameChromaMacroblock;
PNVMCPREDFUNC2 nvPredictFieldChromaMacroblock;

PNVMCCORRFUNC2 nvDoAllIntraFieldCorrections;
PNVMCCORRFUNC2 nvDoAllFieldCorrections;
PNVMCCORRFUNC nvDoAllIntraFrameCorrections;
PNVMCCORRFUNC nvDoAllFrameCorrections;
PNVMCCORRFUNC nvDoIntraFieldCorrection;
PNVMCCORRFUNC nvDoOptimizedIntraFieldCorrection;
PNVMCCORRFUNC nvDoFieldCorrection;
PNVMCCORRFUNC nvDoIntraFrameCorrection;
PNVMCCORRFUNC nvDoFrameCorrection;

#ifdef  DEBUG
unsigned long overlaySurfaceBase = 0;
unsigned long moCompDebugLevel = 0;
#endif  // DEBUG

/*
 * nvMoCompCelsiusConvertSurfaceFormat
 *
 * Performs format conversion from our motion comp surface format to an overlay
 * compatible surface format.
 *
 * Note: Destination surface coordinates are referenced in quarter pel units.
 *       Texture coordinates are referenced in pel units.
 *
 * Note that pDriverData must be set before calling this function.
 *
 */
DWORD __stdcall nvMoCompCelsiusConvertSurfaceFormat(DWORD fpVidMem, BOOL filterChroma, DWORD dwHowMuchToConvert)
{
    LPDDRAWI_DDRAWSURFACE_LCL   dstx = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   dst = dstx->lpGbl;
    LPNVMCSURFACEFLAGS          lpDstSurfaceFlags;
    unsigned long               surfaceWidth = dst->wWidth;
    unsigned long               surfaceHeight = dst->wHeight;
    unsigned long               surfacePitch = dst->lPitch;
    unsigned long               dwDstSurfaceOffset;
    unsigned long               tmpVal;
    unsigned long               Y0 = 0;
    unsigned long               Y1 = surfaceHeight;
    long                        dstX0;
    long                        dstX1;
    BYTE                        updateReferenceCount = FALSE;
    BYTE                        frameType;

    if (pDriverData->dwMostRecentHWUser != MODULE_ID_DDRAW) {
        if (!(nvInitCelsiusForMoComp()))
            return FALSE;
    }

    // Let the display code know how to display this surface
    lpDstSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

    while ((lpDstSurfaceFlags->dwMCSurfaceBase != 0) &&
           (lpDstSurfaceFlags->dwMCSurfaceBase != fpVidMem))
        lpDstSurfaceFlags++;

    if (!(nvInitCelsiusForMoCompConversion()))
        return FALSE;

    frameType = lpDstSurfaceFlags->bMCPictureStructure;

    tmpVal = (NV056_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR << 28) |
             (NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR << 24);

    if (pDriverData->bMCOverlaySrcIsSingleField1080i) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_TEXTURE_FILTER(0) | 0x40000);
        nvPushData(1, tmpVal);

        nvPusherAdjust(2);
    }

    if (filterChroma) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_TEXTURE_FILTER(1) | 0x40000);
        nvPushData(1, tmpVal);

        nvPusherAdjust(2);
    }

    // 420 LUMA portion of this surface starts at fpVidMem
    dwDstSurfaceOffset = VIDMEM_OFFSET(fpVidMem);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
    if (frameType == PICTURE_STRUCTURE_BOTTOM_FIELD)
        nvPushData(1, (dwDstSurfaceOffset + surfacePitch));
    else
        nvPushData(1, dwDstSurfaceOffset);

    // 420 CHROMA portion of this surface starts here
    dwDstSurfaceOffset += (surfacePitch * dst->wHeight);

    if (frameType == PICTURE_STRUCTURE_BOTTOM_FIELD)
        nvPushData(2, (dwDstSurfaceOffset + surfacePitch));
    else
        nvPushData(2, dwDstSurfaceOffset);

    nvPusherAdjust(3);

    // 422 portion of this surface starts here
    dwDstSurfaceOffset = lpDstSurfaceFlags->dwMCSurface422Offset;

    if (frameType == PICTURE_STRUCTURE_FRAME) {

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(3, dwDstSurfaceOffset);

        nvPusherAdjust(4);

        if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted == 7)
            Y0 = (surfaceHeight >> 1) + (surfaceHeight >> 2);
        else if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted == 3)
            Y0 = (surfaceHeight >> 1);
        else if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted == 1)
            Y0 = (surfaceHeight >> 2);

        if (dwHowMuchToConvert == 7)
            Y1 = (surfaceHeight >> 1) + (surfaceHeight >> 2);
        else if (dwHowMuchToConvert == 3)
            Y1 = (surfaceHeight >> 1);
        else if (dwHowMuchToConvert == 1)
            Y1 = (surfaceHeight >> 2);

        if (dwHowMuchToConvert == 15)
            updateReferenceCount = TRUE;

    } else {

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
        nvPushData(1, surfacePitch << 17);
        nvPushData(2, surfacePitch << 17);

        surfacePitch = ((surfaceWidth + 3) & ~3);

        // Determine pitch of 422 pixel block
        surfacePitch = ((surfacePitch << 1) + 127) & ~127; // YUY2 destination is twice the surface width

        nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_NO_OPERATION | 0x40000);
        nvPushData(4, 0);

        nvPushData(5, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);

        if (frameType == PICTURE_STRUCTURE_BOTTOM_FIELD)
            nvPushData(6, (dwDstSurfaceOffset + surfacePitch));
        else
            nvPushData(6, dwDstSurfaceOffset);

        surfacePitch |= (surfacePitch << 16);
        surfacePitch <<= 1;

        nvPushData(7, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_PITCH | 0x40000);
        nvPushData(8, surfacePitch);

        nvPusherAdjust(9);

        if (frameType == PICTURE_STRUCTURE_TOP_FIELD) {
            if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted & 1)
                Y0 = (surfaceHeight >> 1);

            if ((dwHowMuchToConvert & 3) != 3)
                Y1 = (surfaceHeight >> 1);
        } else {
            if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted & 4)
                Y0 = (surfaceHeight >> 1);

            if ((dwHowMuchToConvert & 12) != 12)
                Y1 = (surfaceHeight >> 1);
        }

        if ((frameType == PICTURE_STRUCTURE_TOP_FIELD) &&
            (dwHowMuchToConvert == 3))
            updateReferenceCount = TRUE;
        else if ((frameType == PICTURE_STRUCTURE_BOTTOM_FIELD) &&
            (dwHowMuchToConvert == 12))
            updateReferenceCount = TRUE;
    }

    SET_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

    if (pDriverData->bMCHorizontallyDownscale1080i) {
        dstX0 = (0 - SCALED_CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF;
        dstX1 = ((surfaceWidth << 1) - SCALED_CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF;
    } else {
        dstX0 = (0 - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF;
        dstX1 = ((surfaceWidth << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF;
    }

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) | NV056_SET_SURFACE_CLIP_HORIZONTAL | 0x40000);
    nvPushData(1, ((surfacePitch << 17) | 0));
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) | NV056_SET_SURFACE_CLIP_VERTICAL | 0x40000);
    nvPushData(3, ((surfaceHeight << 17) | 0));
    nvPusherAdjust(4);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x300000);

    if (frameType == PICTURE_STRUCTURE_FRAME) {
        DWORD dstYScale = 18;
        
        if (pDriverData->bMCOverlaySrcIsSingleField1080i)
            dstYScale = 17;

        nvPushData(3, ((Y0 >> 1) << 16) | 0);
        nvPushData(4, (Y0 << 16) | 0);
        nvPushData(5, (Y0 << dstYScale) | dstX0);

        nvPushData(6, ((Y1 >> 1) << 16) | 0); // CHROMA texture is in pel units and is only half the surface height
        nvPushData(7, (Y1 << 16) | 0); // LUMA texture is in pel units
        nvPushData(8, (Y1 << dstYScale) | dstX0); // destination is in quarter pel units

        nvPushData(9, ((Y1 >> 1) << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(10, (Y1 << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(11, (Y1 << dstYScale) | dstX1); // each 32 bit write contains data for 2 422 pixels

        nvPushData(12, ((Y0 >> 1) << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(13, (Y0 << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(14, (Y0 << dstYScale) | dstX1);
    } else {
        nvPushData(3, ((Y0 >> 2) << 16) | 0);
        nvPushData(4, ((Y0 >> 1) << 16) | 0);
        nvPushData(5, (Y0 << 17) | dstX0);

        nvPushData(6, ((Y1 >> 2) << 16) | 0); // CHROMA texture is in pel units and is only half the surface height
        nvPushData(7, ((Y1 >> 1) << 16) | 0); // LUMA texture is in pel units
        nvPushData(8, (Y1 << 17) | dstX0); // destination is in quarter pel units

        nvPushData(9, ((Y1 >> 2) << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(10, ((Y1 >> 1) << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(11, (Y1 << 17) | dstX1); // each 32 bit write contains data for 2 422 pixels

        nvPushData(12, ((Y0 >> 2) << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(13, ((Y0 >> 1) << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(14, (Y0 << 17) | dstX1);
    }

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

    if (updateReferenceCount) {
        // Update reference count so we know when we can display this surface
        lpDstSurfaceFlags->dwMCFormatCnvReferenceCount = getDC()->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);
    }

    nvPusherStart(TRUE);

    lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted |= dwHowMuchToConvert;

    return TRUE;

} /* nvMoCompCelsiusConvertSurfaceFormat */


/*
 * nvMoCompCelsiusTemporalFilter
 *
 * Performs intra frame temporal filtering between the fields of a post format converted overlay surface
 *
 * Note: Destination surface coordinates are referenced in quarter pel units.
 *       Texture coordinates are referenced in quarter pel units.
 *       The combination factor should be in the range of 0 (0%) - 100 (100%)
 *
 * Note that pDriverData must be set before calling this function.
 *
 */
DWORD __stdcall nvMoCompCelsiusTemporalFilter(DWORD fpVidMem, BYTE combinationFactor)
{
    LPDDRAWI_DDRAWSURFACE_LCL   dstx = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   dst = dstx->lpGbl;
    unsigned long               surfaceWidth = dst->wWidth;
    unsigned long               surfaceHeight = dst->wHeight;
    unsigned long               surfacePitch = dst->lPitch;
    unsigned long               dwSrcOffset;
    unsigned long               dwDstOffset;
    unsigned long               pitch422;
    unsigned long               topFieldCombinationFactor;
    unsigned long               bottomFieldCombinationFactor;
    LPNVMCSURFACEFLAGS          lpDstSurfaceFlags;
    long                        dstX0;
    long                        dstX1;

    // We currently don't allocate filtering memory for large surfaces so we don't allow filtering on them
    if (dst->wWidth > 1024)
        return DDERR_GENERIC;

    lpDstSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

    while ((lpDstSurfaceFlags->dwMCSurfaceBase != 0) &&
           (lpDstSurfaceFlags->dwMCSurfaceBase != fpVidMem))
        lpDstSurfaceFlags++;

    // 422 portion of this surface starts here
    dwSrcOffset = lpDstSurfaceFlags->dwMCSurface422Offset;

    // 422 filtering portion of this surface starts here
    pitch422 = (dst->wWidth + 3) & ~3;
    pitch422 = ((pitch422 << 1) + 127) & ~127;
    dwDstOffset = dwSrcOffset + (pitch422 * (DWORD)dst->wHeight);   // 422 filtering portion

    // Make sure surface has been format converted
    if ((lpDstSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) &&
        (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted < 15))
        nvMoCompConvertSurfaceFormat(fpVidMem, TRUE, 15);
    else {
        if ((lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted & 3) < 3)
            nvMoCompConvertSurfaceFormat(fpVidMem, TRUE, 3);
        if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted < 12)
            nvMoCompConvertSurfaceFormat(fpVidMem, TRUE, 12);
    }

    // If this surface has already been filtered then just return
    if (lpDstSurfaceFlags->bMCFrameIsFiltered == TRUE)
        return DD_OK;

    if (pDriverData->dwMostRecentHWUser != MODULE_ID_DDRAW) {
        if (!(nvInitCelsiusForMoComp()))
            return DDERR_GENERIC;
    }

    if (!(nvInitCelsiusForMoCompTemporalFilter()))
        return DDERR_GENERIC;

    if (combinationFactor > 100)
        return DDERR_INVALIDPARAMS;

    topFieldCombinationFactor = (combinationFactor * 256) / 100;
    if (topFieldCombinationFactor > 255)
        topFieldCombinationFactor = 255;
    topFieldCombinationFactor |= topFieldCombinationFactor << 8;
    topFieldCombinationFactor |= topFieldCombinationFactor << 16;

    bottomFieldCombinationFactor = 255 - topFieldCombinationFactor;
    bottomFieldCombinationFactor |= bottomFieldCombinationFactor << 8;
    bottomFieldCombinationFactor |= bottomFieldCombinationFactor << 16;

    // Load combination factors
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINE_FACTOR(0) | 0x80000);
    nvPushData(1, topFieldCombinationFactor); // % of top field
    nvPushData(2, bottomFieldCombinationFactor); // % of bottom field

    nvPusherAdjust(3);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_OFFSET(0) | 0x80000);

    nvPushData(1, dwSrcOffset);
    nvPushData(2, (dwSrcOffset + pitch422));

    lpDstSurfaceFlags->bMCFrameIsFiltered = TRUE;

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_NO_OPERATION | 0x40000);
    nvPushData(4, 0);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);

    nvPushData(6, dwDstOffset);

    nvPusherAdjust(7);

    SET_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

    // Filter Top Field

    if (pDriverData->bMCHorizontallyDownscale1080i) {
        dstX0 = (0 - SCALED_CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF;
        dstX1 = ((surfaceWidth << 1) - SCALED_CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF;
    } else {
        dstX0 = (0 - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF;
        dstX1 = ((surfaceWidth << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF;
    }

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x300000);

    nvPushData(3, (0 << 16) | 0); // Odd field
    nvPushData(4, (0 << 16) | 0);
    nvPushData(5, (0 << 16) | dstX0);

    nvPushData(6, (surfaceHeight << 17) | 0);
    nvPushData(7, (surfaceHeight << 17) | 0);
    nvPushData(8, (surfaceHeight << 17) | dstX0);

    nvPushData(9, (surfaceHeight << 17) | (surfaceWidth << 1));
    nvPushData(10, (surfaceHeight << 17) | (surfaceWidth << 1));
    nvPushData(11, (surfaceHeight << 17) | dstX1); // each 32 bit write contains data 2 422 pixels

    nvPushData(12, (0 << 16) | (surfaceWidth << 1));
    nvPushData(13, (0 << 16) | (surfaceWidth << 1));
    nvPushData(14, (0 << 16) | dstX1);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

    // Now reverse combination factors
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINE_FACTOR(0) | 0x80000);
    nvPushData(1, bottomFieldCombinationFactor); // % of top field
    nvPushData(2, topFieldCombinationFactor); // % of bottom field

    // Filter Bottom Field

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_NO_OPERATION | 0x40000);
    nvPushData(4, 0);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);

    nvPushData(6, dwDstOffset + pitch422);

    nvPusherAdjust(7);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x300000);

    nvPushData(3, (0 << 16) | 0); // Odd field
    nvPushData(4, (0 << 16) | 0);
    nvPushData(5, (0 << 16) | dstX0);

    nvPushData(6, (surfaceHeight << 17) | 0);
    nvPushData(7, (surfaceHeight << 17) | 0);
    nvPushData(8, (surfaceHeight << 17) | dstX0);

    nvPushData(9, (surfaceHeight << 17) | (surfaceWidth << 1));
    nvPushData(10, (surfaceHeight << 17) | (surfaceWidth << 1));
    nvPushData(11, (surfaceHeight << 17) | dstX1); // each 32 bit write contains data 2 422 pixels

    nvPushData(12, (0 << 16) | (surfaceWidth << 1));
    nvPushData(13, (0 << 16) | (surfaceWidth << 1));
    nvPushData(14, (0 << 16) | dstX1);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

    // Update reference count so we know when we can display this surface
    lpDstSurfaceFlags->dwMCTemporalFilterReferenceCount = getDC()->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);

    nvPusherStart(TRUE);

    return DD_OK;

} /* nvMoCompCelsiusTemporalFilter */


/*
 * nvMoCompKelvinConvertSurfaceFormat
 *
 * Performs format conversion from our motion comp surface format to an overlay
 * compatible surface format.
 *
 * Note: Destination surface coordinates are referenced in quarter pel units.
 *       Texture coordinates are referenced in pel units.
 *
 * Note that pDriverData must be set before calling this function.
 *
 */
DWORD __stdcall nvMoCompKelvinConvertSurfaceFormat(DWORD fpVidMem, BOOL filterChroma, DWORD dwHowMuchToConvert)
{
    LPDDRAWI_DDRAWSURFACE_LCL   dstx = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   dst = dstx->lpGbl;
    LPNVMCSURFACEFLAGS          lpDstSurfaceFlags;
    unsigned long               surfaceWidth = dst->wWidth;
    unsigned long               surfaceHeight = dst->wHeight;
    unsigned long               surfacePitch = dst->lPitch;
    unsigned long               dwDstSurfaceOffset;
    unsigned long               tmpVal;
    unsigned long               Y0 = 0;
    unsigned long               Y1 = surfaceHeight;
    BYTE                        updateReferenceCount = FALSE;
    BYTE                        frameType;

    if (pDriverData->dwMostRecentHWUser != MODULE_ID_DDRAW) {
        if (!(nvInitKelvinForMoComp()))
            return FALSE;
    }

    // Let the display code know how to display this surface
    lpDstSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

    while ((lpDstSurfaceFlags->dwMCSurfaceBase != 0) &&
           (lpDstSurfaceFlags->dwMCSurfaceBase != fpVidMem))
        lpDstSurfaceFlags++;

    if (!(nvInitKelvinForMoCompConversion()))
        return FALSE;

    frameType = lpDstSurfaceFlags->bMCPictureStructure;

    tmpVal = (NV097_SET_TEXTURE_FILTER_BSIGNED_BIT_DISABLED << 31) |
             (NV097_SET_TEXTURE_FILTER_GSIGNED_BIT_DISABLED << 30) |
             (NV097_SET_TEXTURE_FILTER_RSIGNED_BIT_DISABLED << 29) |
             (NV097_SET_TEXTURE_FILTER_ASIGNED_BIT_DISABLED << 28) |
             (NV097_SET_TEXTURE_FILTER_MAG_TENT_LOD0 << 24) |
             (NV097_SET_TEXTURE_FILTER_MIN_TENT_LOD0 << 16) |
             (NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_QUINCUNX << 13);

    if (pDriverData->bMCOverlaySrcIsSingleField1080i) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                       NV097_SET_TEXTURE_FILTER(0) | 0x40000);
        nvPushData(1, tmpVal);

        nvPusherAdjust(2);
    }

    if (filterChroma) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                       NV097_SET_TEXTURE_FILTER(1) | 0x40000);
        nvPushData(1, tmpVal);

        nvPusherAdjust(2);
    }

    // 420 LUMA portion of this surface starts at fpVidMem
    dwDstSurfaceOffset = VIDMEM_OFFSET(fpVidMem);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
    if (frameType == PICTURE_STRUCTURE_BOTTOM_FIELD)
        nvPushData(1, (dwDstSurfaceOffset + surfacePitch));
    else
        nvPushData(1, dwDstSurfaceOffset);

    // 420 CHROMA portion of this surface starts here
    dwDstSurfaceOffset += (surfacePitch * dst->wHeight);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
    if (frameType == PICTURE_STRUCTURE_BOTTOM_FIELD)
        nvPushData(3, (dwDstSurfaceOffset + surfacePitch));
    else
        nvPushData(3, dwDstSurfaceOffset);

    nvPusherAdjust(4);

#ifdef  DEBUG
    if ((moCompDebugLevel > 0) && (overlaySurfaceBase != 0)) {
        dwDstSurfaceOffset = VIDMEM_OFFSET(overlaySurfaceBase);
        dwDstSurfaceOffset += (surfacePitch * dst->wHeight);
        lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted = 0;
    }
#endif  // DEBUG

    // 422 portion of this surface starts here
    dwDstSurfaceOffset = lpDstSurfaceFlags->dwMCSurface422Offset;

    if (frameType == PICTURE_STRUCTURE_FRAME) {

        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(3, dwDstSurfaceOffset);

        nvPusherAdjust(4);

        if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted == 7)
            Y0 = (surfaceHeight >> 1) + (surfaceHeight >> 2);
        else if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted == 3)
            Y0 = (surfaceHeight >> 1);
        else if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted == 1)
            Y0 = (surfaceHeight >> 2);

        if (dwHowMuchToConvert == 7)
            Y1 = (surfaceHeight >> 1) + (surfaceHeight >> 2);
        else if (dwHowMuchToConvert == 3)
            Y1 = (surfaceHeight >> 1);
        else if (dwHowMuchToConvert == 1)
            Y1 = (surfaceHeight >> 2);

        if (dwHowMuchToConvert == 15)
            updateReferenceCount = TRUE;

    } else {

        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
        nvPushData(1, surfacePitch << 17);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
        nvPushData(3, surfacePitch << 17);

        surfacePitch = ((surfaceWidth + 3) & ~3);

        // Determine pitch of 422 pixel block
        surfacePitch = ((surfacePitch << 1) + 127) & ~127; // YUY2 destination is twice the surface width

        nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_NO_OPERATION | 0x40000);
        nvPushData(5, 0);

        nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);

        if (frameType == PICTURE_STRUCTURE_BOTTOM_FIELD)
            nvPushData(7, (dwDstSurfaceOffset + surfacePitch));
        else
            nvPushData(7, dwDstSurfaceOffset);

        surfacePitch |= (surfacePitch << 16);
        surfacePitch <<= 1;

        nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_SURFACE_PITCH | 0x40000);
        nvPushData(9, surfacePitch);

        nvPusherAdjust(10);

        if (frameType == PICTURE_STRUCTURE_TOP_FIELD) {
            if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted & 1)
                Y0 = (surfaceHeight >> 1);

            if ((dwHowMuchToConvert & 3) != 3)
                Y1 = (surfaceHeight >> 1);
        } else {
            if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted & 4)
                Y0 = (surfaceHeight >> 1);

            if ((dwHowMuchToConvert & 12) != 12)
                Y1 = (surfaceHeight >> 1);
        }

        if ((frameType == PICTURE_STRUCTURE_TOP_FIELD) &&
            (dwHowMuchToConvert == 3))
            updateReferenceCount = TRUE;
        else if ((frameType == PICTURE_STRUCTURE_BOTTOM_FIELD) &&
            (dwHowMuchToConvert == 12))
            updateReferenceCount = TRUE;
    }

    SET_KELVIN_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40300000);

    if (frameType == PICTURE_STRUCTURE_FRAME) {
        DWORD dstYScale = 18;

        if (pDriverData->bMCOverlaySrcIsSingleField1080i)
            dstYScale = 17;

        nvPushData(3, (Y0 << dstYScale) | 0);
        nvPushData(4, (Y0 << 16) | 0);
        nvPushData(5, ((Y0 >> 1) << 16) | 0);

        nvPushData(6, (Y1 << dstYScale) | 0); // destination is in quarter pel units
        nvPushData(7, (Y1 << 16) | 0); // LUMA texture is in pel units
        nvPushData(8, ((Y1 >> 1) << 16) | 0); // CHROMA texture is in pel units and is only half the surface height

        nvPushData(9, (Y1 << dstYScale) | (surfaceWidth << 1)); // each 32 bit write contains data for 2 422 pixels
        nvPushData(10, (Y1 << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(11, ((Y1 >> 1) << 16) | ((surfaceWidth + 1) >> 1));

        nvPushData(12, (Y0 << dstYScale) | (surfaceWidth << 1));
        nvPushData(13, (Y0 << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(14, ((Y0 >> 1) << 16) | ((surfaceWidth + 1) >> 1));
    } else {
        nvPushData(3, (Y0 << 17) | 0);
        nvPushData(4, ((Y0 >> 1) << 16) | 0);
        nvPushData(5, ((Y0 >> 2) << 16) | 0);

        nvPushData(6, (Y1 << 17) | 0); // destination is in quarter pel units
        nvPushData(7, ((Y1 >> 1) << 16) | 0); // LUMA texture is in pel units
        nvPushData(8, ((Y1 >> 2) << 16) | 0); // CHROMA texture is in pel units and is only half the surface height

        nvPushData(9, (Y1 << 17) | (surfaceWidth << 1)); // each 32 bit write contains data for 2 422 pixels
        nvPushData(10, ((Y1 >> 1) << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(11, ((Y1 >> 2) << 16) | ((surfaceWidth + 1) >> 1));

        nvPushData(12, (Y0 << 17) | (surfaceWidth << 1));
        nvPushData(13, ((Y0 >> 1) << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(14, ((Y0 >> 2) << 16) | ((surfaceWidth + 1) >> 1));
    }

    nvPushData(15, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

    if (updateReferenceCount) {
        // Update reference count so we know when we can display this surface
#ifdef  DEBUG
        if (moCompDebugLevel > 0) {
            lpDstSurfaceFlags->dwMCFormatCnvReferenceCount = getDC()->pRefCount->readShadow();
            getDC()->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);
        } else {
            lpDstSurfaceFlags->dwMCFormatCnvReferenceCount = getDC()->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);
        }
#else   // DEBUG
        lpDstSurfaceFlags->dwMCFormatCnvReferenceCount = getDC()->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);
#endif  // DEBUG
    }

    nvPusherStart(TRUE);

    lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted |= dwHowMuchToConvert;

    return TRUE;

} /* nvMoCompKelvinConvertSurfaceFormat */


/*
 * nvMoCompKelvinTemporalFilter
 *
 * Performs intra frame temporal filtering between the fields of a post format converted overlay surface
 *
 * Note: Destination surface coordinates are referenced in quarter pel units.
 *       Texture coordinates are referenced in quarter pel units.
 *       The combination factor should be in the range of 0 (0%) - 100 (100%)
 *
 * Note that pDriverData must be set before calling this function.
 *
 */
DWORD __stdcall nvMoCompKelvinTemporalFilter(DWORD fpVidMem, BYTE combinationFactor)
{
    LPDDRAWI_DDRAWSURFACE_LCL   dstx = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   dst = dstx->lpGbl;
    unsigned long               surfaceWidth = dst->wWidth;
    unsigned long               surfaceHeight = dst->wHeight;
    unsigned long               surfacePitch = dst->lPitch;
    unsigned long               dwSrcOffset;
    unsigned long               dwDstOffset;
    unsigned long               pitch422;
    unsigned long               topFieldCombinationFactor;
    unsigned long               bottomFieldCombinationFactor;
    LPNVMCSURFACEFLAGS          lpDstSurfaceFlags;

    // We currently don't allocate filtering memory for large surfaces so we don't allow filtering on them
    if (dst->wWidth > 1024)
        return DDERR_GENERIC;

#ifdef  DEBUG
    return DD_OK;
#endif  // DEBUG

    lpDstSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

    while ((lpDstSurfaceFlags->dwMCSurfaceBase != 0) &&
           (lpDstSurfaceFlags->dwMCSurfaceBase != fpVidMem))
        lpDstSurfaceFlags++;

    // 422 portion of this surface starts here
    dwSrcOffset = lpDstSurfaceFlags->dwMCSurface422Offset;

    // 422 filtering portion of this surface starts here
    pitch422 = (dst->wWidth + 3) & ~3;
    pitch422 = ((pitch422 << 1) + 127) & ~127;
    dwDstOffset = dwSrcOffset + (pitch422 * (DWORD)dst->wHeight);   // 422 filtering portion

    // Make sure surface has been format converted
    if ((lpDstSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) &&
        (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted < 15))
        nvMoCompConvertSurfaceFormat(fpVidMem, TRUE, 15);
    else {
        if ((lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted & 3) < 3)
            nvMoCompConvertSurfaceFormat(fpVidMem, TRUE, 3);
        if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted < 12)
            nvMoCompConvertSurfaceFormat(fpVidMem, TRUE, 12);
    }

    // If this surface has already been filtered then just return
    if (lpDstSurfaceFlags->bMCFrameIsFiltered == TRUE)
        return DD_OK;

    if (pDriverData->dwMostRecentHWUser != MODULE_ID_DDRAW) {
        if (!(nvInitKelvinForMoComp()))
            return DDERR_GENERIC;
    }

    if (!(nvInitKelvinForMoCompTemporalFilter()))
        return DDERR_GENERIC;

    if (combinationFactor > 100)
        return DDERR_INVALIDPARAMS;

    topFieldCombinationFactor = (combinationFactor * 256) / 100;
    if (topFieldCombinationFactor > 255)
        topFieldCombinationFactor = 255;
    topFieldCombinationFactor |= topFieldCombinationFactor << 8;
    topFieldCombinationFactor |= topFieldCombinationFactor << 16;

    bottomFieldCombinationFactor = 255 - topFieldCombinationFactor;
    bottomFieldCombinationFactor |= bottomFieldCombinationFactor << 8;
    bottomFieldCombinationFactor |= bottomFieldCombinationFactor << 16;

    // Load combination factors
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_FACTOR0(0) | 0x40000);
    nvPushData(1, topFieldCombinationFactor); // % of top field
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_FACTOR1(0) | 0x40000);
    nvPushData(3, bottomFieldCombinationFactor); // % of bottom field

    nvPusherAdjust(4);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
    nvPushData(1, dwSrcOffset);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(3, (dwSrcOffset + pitch422));

    lpDstSurfaceFlags->bMCFrameIsFiltered = TRUE;

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_NO_OPERATION | 0x40000);
    nvPushData(5, 0);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
    nvPushData(7, dwDstOffset);

    nvPusherAdjust(8);

    SET_KELVIN_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

    // Filter Top Field

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40300000);

    nvPushData(3, (0 << 16) | 0); // Odd field
    nvPushData(4, (0 << 16) | 0);
    nvPushData(5, (0 << 16) | 0);

    nvPushData(6, (surfaceHeight << 17) | 0);
    nvPushData(7, (surfaceHeight << 17) | 0);
    nvPushData(8, (surfaceHeight << 17) | 0);

    nvPushData(9, (surfaceHeight << 17) | (surfaceWidth << 1));
    nvPushData(10, (surfaceHeight << 17) | (surfaceWidth << 1));
    nvPushData(11, (surfaceHeight << 17) | (surfaceWidth << 1)); // each 32 bit write contains data 2 422 pixels

    nvPushData(12, (0 << 16) | (surfaceWidth << 1));
    nvPushData(13, (0 << 16) | (surfaceWidth << 1));
    nvPushData(14, (0 << 16) | (surfaceWidth << 1));

    nvPushData(15, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

    // Now reverse combination factors
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_FACTOR0(0) | 0x40000);
    nvPushData(1, bottomFieldCombinationFactor); // % of top field
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_FACTOR1(0) | 0x40000);
    nvPushData(3, topFieldCombinationFactor); // % of bottom field

    // Filter Bottom Field

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_NO_OPERATION | 0x40000);
    nvPushData(5, 0);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);

    nvPushData(7, dwDstOffset + pitch422);

    nvPusherAdjust(8);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40300000);

    nvPushData(3, (0 << 16) | 0); // Odd field
    nvPushData(4, (0 << 16) | 0);
    nvPushData(5, (0 << 16) | 0);

    nvPushData(6, (surfaceHeight << 17) | 0);
    nvPushData(7, (surfaceHeight << 17) | 0);
    nvPushData(8, (surfaceHeight << 17) | 0);

    nvPushData(9, (surfaceHeight << 17) | (surfaceWidth << 1));
    nvPushData(10, (surfaceHeight << 17) | (surfaceWidth << 1));
    nvPushData(11, (surfaceHeight << 17) | (surfaceWidth << 1)); // each 32 bit write contains data 2 422 pixels

    nvPushData(12, (0 << 16) | (surfaceWidth << 1));
    nvPushData(13, (0 << 16) | (surfaceWidth << 1));
    nvPushData(14, (0 << 16) | (surfaceWidth << 1));

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

    // Update reference count so we know when we can display this surface
    lpDstSurfaceFlags->dwMCTemporalFilterReferenceCount = getDC()->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);

    nvPusherStart(TRUE);

    return DD_OK;

} /* nvMoCompKelvinTemporalFilter */


/*
 * nvMoCompConvertSurfaceFormat
 *
 * Performs format conversion from our motion comp surface format to an overlay
 * compatible surface format.
 *
 * Note: Destination surface coordinates are referenced in quarter pel units.
 *       Texture coordinates are referenced in pel units.
 *
 * Note that pDriverData must be set before calling this function.
 *
 */
DWORD __stdcall nvMoCompConvertSurfaceFormat(DWORD fpVidMem, BOOL filterChroma, DWORD dwHowMuchToConvert)
{
    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        if (!nvEnable32(NULL)) {
            return FALSE;
        }
    }

    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        return nvMoCompKelvinConvertSurfaceFormat(fpVidMem, filterChroma, dwHowMuchToConvert);
    } else {
        return nvMoCompCelsiusConvertSurfaceFormat(fpVidMem, filterChroma, dwHowMuchToConvert);
    }
} /* nvMoCompConvertSurfaceFormat */


/*
 * nvMoCompTemporalFilter
 *
 * Performs intra frame temporal filtering between the fields of a post format converted overlay surface
 *
 * Note: Destination surface coordinates are referenced in quarter pel units.
 *       Texture coordinates are referenced in quarter pel units.
 *       The combination factor should be in the range of 0 (0%) - 100 (100%)
 *
 * Note that pDriverData must be set before calling this function.
 *
 */
DWORD __stdcall nvMoCompTemporalFilter(DWORD fpVidMem, BYTE combinationFactor)
{
    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        if (!nvEnable32(NULL)) {
            return DDERR_SURFACELOST;
        }
    }

    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        return nvMoCompKelvinTemporalFilter(fpVidMem, combinationFactor);
    } else {
        return nvMoCompCelsiusTemporalFilter(fpVidMem, combinationFactor);
    }

} /* nvMoCompTemporalFilter */


/*
 * nvMoCompDecompressSubpicture
 *
 * Performs full or partial decompression of a subpicture surface to a DVD_SUBPICTURE compatible format.
 *
 * Note that pDriverData must be set before calling this function.
 *
 */
DWORD __stdcall nvMoCompDecompressSubpicture(LPVOID lpInputData, DWORD dwSurfaceIndex)
{
    LPNVSPDECOMPRESSDATA lpNvSPDecompressData = (LPNVSPDECOMPRESSDATA)lpInputData;
    LPDDRAWI_DDRAWSURFACE_LCL pSurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL pSurf_gbl;
    DWORD dwBlockSize;
    unsigned long dwLUTOffset;
    unsigned long dwDstOffset;
    unsigned long ulColor;
    float fRed;
    float fGreen;
    float fBlue;
    float fY;
    float fCb;
    float fCr;
    unsigned long dwCrCbY;
    unsigned char *LUTable;
    long n;
    unsigned long temp;
    long srcScanLength;
    long nxtSrcScan;
    FAST short pxlCount;
    unsigned long dwSrcOffset;
    unsigned char *pSrcInitBits;

    DWORD dwModeBPP = GET_MODE_BPP();
    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVSPSurface;
    pSurf_gbl = pSurf_lcl->lpGbl;

    if (pSurf_gbl->ddpfSurface.dwFourCC != FOURCC_NVSP)
        return (DDERR_INVALIDPARAMS);

    if ((lpNvSPDecompressData->wSPHOffset < 0) ||
        (lpNvSPDecompressData->wSPVOffset < 0) ||
        (lpNvSPDecompressData->wSPWidth <= 0) ||
        (lpNvSPDecompressData->wSPHeight <= 0))
        return (DDERR_INVALIDPARAMS);


    dwBlockSize = pSurf_gbl->lPitch * pSurf_gbl->wHeight; // calculate size of 8 bit index per pixel plane
    dwBlockSize <<= 1;  // double size to skip over 8 bit alpha per pixel plane
    dwBlockSize += (dwBlockSize << 1); // increase to skip over fully decompressed 32 bit per pixel plane

    dwLUTOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

    // offset to base of look up table in video memory
    dwLUTOffset += dwBlockSize;

    // Update color conversion table if necessary
    if (lpNvSPDecompressData->bSPUpdateLookUpTable) {

        nvPushData (0, dDrawSubchannelOffset(NV_DD_SURFACES) +
            NV042_SET_COLOR_FORMAT | 0x40000);
        nvPushData (1, NV042_SET_COLOR_FORMAT_LE_R5G6B5);
        nvPushData (2, dDrawSubchannelOffset(NV_DD_SURFACES) +
            NV042_SET_PITCH | 0xC0000);
        nvPushData (3, (1024 << 16) | 1024);
        nvPushData (4, 0);
        nvPushData (5, dwLUTOffset);
        nvPusherAdjust (6);
        pDriverData->bltData.dwLastColourFormat = NV042_SET_COLOR_FORMAT_LE_R5G6B5;
        pDriverData->bltData.dwLastCombinedPitch = (1024 << 16) | 1024;
        pDriverData->bltData.dwLastSrcOffset = 0;
        pDriverData->bltData.dwLastDstOffset = dwLUTOffset;

        nvPushData (0, dDrawSubchannelOffset(NV_DD_ROP) +
            SET_ROP_OFFSET | 0x40000);
        nvPushData (1, SRCCOPYINDEX);
        pDriverData->bltData.dwLastRop = SRCCOPYINDEX;

        nvPushData (2, dDrawSubchannelOffset(NV_DD_IMAGE) +
            NV061_SET_COLOR_FORMAT | 0x40000);
        nvPushData (3, NV061_SET_COLOR_FORMAT_LE_R5G6B5);

        nvPushData (4, dDrawSubchannelOffset(NV_DD_IMAGE) +
            IMAGE_FROM_CPU_POINT_OFFSET | 0xC0000);
        nvPushData (5, 0);

        if (lpNvSPDecompressData->bSPNumberOfActiveTableEntries == 0) {
            n = 256;
            nvPushData (6, asmMergeCoords(512, 1));
            nvPushData (7, asmMergeCoords(512, 1));
        } else {
            n = lpNvSPDecompressData->bSPNumberOfActiveTableEntries;
            nvPushData (6, asmMergeCoords((lpNvSPDecompressData->bSPNumberOfActiveTableEntries << 1), 1));
            nvPushData (7, asmMergeCoords((lpNvSPDecompressData->bSPNumberOfActiveTableEntries << 1), 1));
        }

        nvPusherAdjust (8);

        getDC()->nvPusher.makeSpace (1 + n); // > 128 word xfer
        nvPushData (0, dDrawSubchannelOffset(NV_DD_IMAGE) +
                       IMAGE_FROM_CPU_COLOR_OFFSET | (n << 18));
        getDC()->nvPusher.inc (1);

        LUTable = (unsigned char *)&lpNvSPDecompressData->dwSPLookUpTable[0];

        while (--n >= 0) {

            if (lpNvSPDecompressData->bSPFormat == 1) { // RGB look up table values
                ulColor = LUTable[0];
                fBlue = (float)ulColor;
                ulColor = LUTable[1];
                fGreen = (float)ulColor;
                ulColor = LUTable[2];
                fRed = (float)ulColor;

                // ITU-R BT.601 RGB conversion to YCbCr assuming gamma corrected RGB values ranging from 0 - 255
                //
                // Cr = 0.439R - 0.368G - 0.071B + 128
                // Cb = -0.148R - 0.291G + 0.439B + 128
                // Y = 0.257R + 0.504G + 0.98B + 16

                fCr = (float)((0.439 * fRed) - (0.368 * fGreen) - (0.071 * fBlue) + 128.0);
                if (fCr < 0.0)
                    fCr = 0.0;
                else if (fCr > 255.0)
                    fCr = 255.0;
                dwCrCbY = (unsigned long)fCr;
                dwCrCbY <<= 8;
                fCb = (float)((-0.148 * fRed) - (0.291 * fGreen) + (0.439 * fBlue) + 128.0);
                if (fCb < 0.0)
                    fCb = 0.0;
                else if (fCb > 255.0)
                    fCb = 255.0;
                dwCrCbY |= (unsigned long)fCb;
                dwCrCbY <<= 8;
                fY = (float)((0.257 * fRed) + (0.504 * fGreen) + (0.98 * fBlue) + 16.0);
                if (fY > 255.0)
                    dwCrCbY |= 255;
                else dwCrCbY |= (unsigned long)fY;
            } else { // YUV look up table values
                dwCrCbY = LUTable[0];
                dwCrCbY = (dwCrCbY << 8) | LUTable[1];
                dwCrCbY = (dwCrCbY << 8) | LUTable[2];
            }

            LUTable += 4;

            nvPushData (0, dwCrCbY);

            getDC()->nvPusher.inc (1);
        }

        // Restore IMAGE_FROM_CPU color format
        nvPushData (0, dDrawSubchannelOffset(NV_DD_IMAGE) +
            NV061_SET_OPERATION | 0x40000);
        nvPushData (1, NV061_SET_COLOR_FORMAT);

        if (dwModeBPP == 8)
            nvPushData (2, NV061_SET_COLOR_FORMAT_LE_X8R8G8B8);
        else if (dwModeBPP == 16)
            nvPushData (2, NV061_SET_COLOR_FORMAT_LE_R5G6B5);
        else
            nvPushData (2, NV061_SET_COLOR_FORMAT_LE_X8R8G8B8);

        nvPusherAdjust (3);

        nvPusherStart (TRUE);
    }

    // Now decompress index plane to X8Y8U8V8
    dwBlockSize = pSurf_gbl->lPitch * pSurf_gbl->wHeight; // calculate size of 8 bit index per pixel plane
    dwBlockSize <<= 1;  // double size to skip over 8 bit alpha per pixel plane

    dwDstOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

    // offset to base of fully decompressed pixel plane in video memory
    dwDstOffset += dwBlockSize;

    nvPushData (0, dDrawSubchannelOffset(NV_DD_SURFACES) +
        NV042_SET_COLOR_FORMAT | 0x40000);
    nvPushData (1, NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8);
    nvPushData (2, dDrawSubchannelOffset(NV_DD_SURFACES) +
        NV042_SET_PITCH | 0xC0000);
    nvPushData (3, (pSurf_gbl->lPitch << 18) | (pSurf_gbl->lPitch << 2)); // output is 32 bpp
    nvPushData (4, 0);
    nvPushData (5, dwDstOffset);
    nvPusherAdjust (6);
    pDriverData->bltData.dwLastColourFormat = NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;
    pDriverData->bltData.dwLastCombinedPitch = (pSurf_gbl->lPitch << 18) | (pSurf_gbl->lPitch << 2);
    pDriverData->bltData.dwLastSrcOffset = 0;
    pDriverData->bltData.dwLastDstOffset = dwDstOffset;

    srcScanLength = pSurf_gbl->lPitch;

    pSrcInitBits = (unsigned char *) VIDMEM_ADDR(pSurf_gbl->fpVidMem);

    pSrcInitBits += (lpNvSPDecompressData->wSPVOffset * srcScanLength);

    pSrcInitBits += (lpNvSPDecompressData->wSPHOffset & 0xFFFC);

    dwSrcOffset = lpNvSPDecompressData->wSPHOffset & 3;

    temp = ((lpNvSPDecompressData->wSPWidth + dwSrcOffset + 3) & 0xFFFC);

    nxtSrcScan = srcScanLength - temp;

    n = lpNvSPDecompressData->wSPHeight;

    nvPushData (0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
    nvPushData (1, NV_DD_IMAGE_BLACK_RECTANGLE);

    // Let others know that we changed the clip
    pDriverData->dwSharedClipChangeCount++;

    pDriverData->dwDDMostRecentClipChangeCount = pDriverData->dwSharedClipChangeCount;

    // changing canvas clip avoids manually aligning 8-bit source
    nvPushData (2, dDrawSubchannelOffset(NV_DD_SPARE) +
        IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000);
    nvPushData (3, 0);
    nvPushData (4, asmMergeCoords(NV_MAX_X_CLIP, NV_MAX_Y_CLIP));

    nvPushData (5, dDrawSubchannelOffset(NV_DD_ROP) +
        SET_ROP_OFFSET | 0x40000);
    nvPushData (6, SRCCOPYINDEX);
    pDriverData->bltData.dwLastRop = SRCCOPYINDEX;

    nvPusherAdjust (7);

    nvPushData (0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
    nvPushData (1, NV_DD_INDEXED_IMAGE_FROM_CPU);

    nvPushData (2, dDrawSubchannelOffset(NV_DD_SPARE) +
        NV064_INDEX_FORMAT | 0x40000);
    nvPushData (3, NV064_INDEX_FORMAT_LE_I8);

    nvPushData (4, dDrawSubchannelOffset(NV_DD_SPARE) +
        NV064_LUT_OFFSET | 0x40000);
    nvPushData (5, dwLUTOffset);

    /* compiler screws up this expression when it goes negative in following macro */
    temp = lpNvSPDecompressData->wSPHOffset - dwSrcOffset;

    nvPushData (6, dDrawSubchannelOffset(NV_DD_SPARE) +
        NV064_POINT | 0xC0000);
    nvPushData (7, asmMergeCoords(temp, lpNvSPDecompressData->wSPVOffset));
    nvPushData (8,
        asmMergeCoords(lpNvSPDecompressData->wSPWidth + dwSrcOffset, lpNvSPDecompressData->wSPHeight));

    temp = ((lpNvSPDecompressData->wSPWidth + dwSrcOffset + 3) & 0xFFFC);

    nvPushData (9, asmMergeCoords(temp, lpNvSPDecompressData->wSPHeight));

    nvPusherAdjust (10);

    {
       FAST unsigned char *pSrcBits = pSrcInitBits;
       FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

       while (--n >= 0) {

           pxlCount = (short)temp;

           getDC()->nvPusher.makeSpace (1 + temp / 2); // > 128 word xfer
           nvPushData (0,dDrawSubchannelOffset(NV_DD_SPARE) +
               NV064_INDICES(0) | (temp << 16));
           getDC()->nvPusher.inc (1);

           while (pxlCount >= 32) {
               pxlCount -= 32;

               tmpPxls0 = *(unsigned long *)&pSrcBits[0];
               tmpPxls1 = *(unsigned long *)&pSrcBits[4];
               nvPushData (0,tmpPxls0);
               tmpPxls2 = *(unsigned long *)&pSrcBits[8];
               nvPushData (1,tmpPxls1);
               tmpPxls0 = *(unsigned long *)&pSrcBits[12];
               tmpPxls1 = *(unsigned long *)&pSrcBits[16];
               nvPushData (2,tmpPxls2);
               nvPushData (3,tmpPxls0);
               tmpPxls2 = *(unsigned long *)&pSrcBits[20];
               tmpPxls0 = *(unsigned long *)&pSrcBits[24];
               nvPushData (4,tmpPxls1);
               nvPushData (5,tmpPxls2);
               tmpPxls1 = *(unsigned long *)&pSrcBits[28];
               nvPushData (6,tmpPxls0);
               pSrcBits += 32;
               nvPushData (7,tmpPxls1);

               getDC()->nvPusher.inc (8);
           }

           if (pxlCount > 0) {

               while (pxlCount >= 8) {
                   pxlCount -= 8;
                   tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                   tmpPxls1 = *(unsigned long *)&pSrcBits[4];
                   pSrcBits += 8;
                   nvPushData (0,tmpPxls0);
                   nvPushData (1,tmpPxls1);
                   getDC()->nvPusher.inc (2);
               }

               if (pxlCount > 0) {
                   pxlCount -= 4;
                   tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                   pSrcBits += 4;
                   nvPushData (0,tmpPxls0);

                   getDC()->nvPusher.inc (1);

                   if (pxlCount > 0) {
                       tmpPxls1 = *(unsigned long *)&pSrcBits[0];
                       pSrcBits += 4;
                       nvPushData (0,tmpPxls1);
                       getDC()->nvPusher.inc (1);
                   }
               }
           }
           pSrcBits += nxtSrcScan;

           nvPusherStart (TRUE);
        }
    }

    // Restore surface color format
    nvPushData (0, dDrawSubchannelOffset(NV_DD_SURFACES) +
        NV042_SET_COLOR_FORMAT | 0x40000);

    if (dwModeBPP == 8) {
        nvPushData (1, NV042_SET_COLOR_FORMAT_LE_Y8);
        pDriverData->bltData.dwLastColourFormat = NV042_SET_COLOR_FORMAT_LE_Y8;
    } else if (dwModeBPP == 16) {
        nvPushData (1, NV042_SET_COLOR_FORMAT_LE_R5G6B5);
        pDriverData->bltData.dwLastColourFormat = NV042_SET_COLOR_FORMAT_LE_R5G6B5;
    } else {
        nvPushData (1, NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8);
        pDriverData->bltData.dwLastColourFormat = NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;
    }

    nvPusherAdjust (2);

    // Now copy the corresponding alpha values into the freshly decompressed X8Y8U8V8 pixels
    dwSrcOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

    dwSrcOffset += pSurf_gbl->lPitch * pSurf_gbl->wHeight; // offset over the 8 bit index per pixel plane

    dwSrcOffset += (lpNvSPDecompressData->wSPVOffset * srcScanLength);

    dwSrcOffset += lpNvSPDecompressData->wSPHOffset;

    // Destination is 32 bits per pixel
    dwDstOffset += (lpNvSPDecompressData->wSPVOffset * (srcScanLength << 2));

    dwDstOffset += (lpNvSPDecompressData->wSPHOffset << 2);

    dwDstOffset += 3; // first alpha value is 4 byte of first X8Y8U8V8 dword

    n = lpNvSPDecompressData->wSPHeight;

    nvPushData (0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
    nvPushData (1, NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT);
    nvPushData (2, dDrawSubchannelOffset(NV_DD_SPARE) +
            MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
    nvPushData (3, dwSrcOffset);
    nvPushData (4, dwDstOffset);
    nvPushData (5, srcScanLength);
    nvPushData (6, (srcScanLength << 2));
    nvPushData (7, (DWORD)lpNvSPDecompressData->wSPWidth);
    nvPushData (8, (DWORD)lpNvSPDecompressData->wSPHeight);
    nvPushData (9, (4 << 8) | 1);
    nvPushData (10, 0);

    nvPusherAdjust (11);

    nvPusherStart (TRUE);

    pDriverData->dDrawSpareSubchannelObject = NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;

    return DD_OK;

} /* nvMoCompDecompressSubpicture */



/*
 * nvMoCompCompositeSubpicture
 *
 * Performs full or partial compositing of a decompressed subpicture surface to the destination overlay
 * surface with scaling.
 *
 * Note that pDriverData must be set before calling this function.
 *
 */
DWORD __stdcall nvMoCompCompositeSubpicture(LPVOID lpInputData, DWORD dwSurfaceIndex)
{
    LPNVSPCOMPOSITEDATA lpNvSPCompositeData = (LPNVSPCOMPOSITEDATA)lpInputData;
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl;
    LPDDRAWI_DDRAWSURFACE_LCL   pSPSurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   pSPSurf_gbl;
    LPNVMCSURFACEFLAGS          lpDstSurfaceFlags;
    DWORD                       dwBlockSize;
    unsigned long               dwSrcOffset;
    unsigned long               dw422Offset;
    unsigned long               dwDstOffset;
    unsigned long               pitch422;
    unsigned long               dwSubPictureSurfaceWidth;
    unsigned long               dwSubPictureSurfaceHeight;
    unsigned long               dwCompositeSurfaceWidth;
    unsigned long               dwCompositeSurfaceHeight;
    BYTE                        revertRegion = FALSE;


    if ((lpNvSPCompositeData->wSPHOffset < 0) ||
        (lpNvSPCompositeData->wSPVOffset < 0) ||
        (lpNvSPCompositeData->wSPWidth < 0) ||
        (lpNvSPCompositeData->wSPHeight < 0))
        return (DDERR_INVALIDPARAMS);

    if ((lpNvSPCompositeData->wMCHOffset < 0) ||
        (lpNvSPCompositeData->wMCVOffset < 0) ||
        (lpNvSPCompositeData->wMCWidth < 0) ||
        (lpNvSPCompositeData->wMCHeight < 0))
        return (DDERR_INVALIDPARAMS);

    // Is this a request to revert to an uncomposited destination ?
    if ((lpNvSPCompositeData->wSPHOffset == 0) &&
        (lpNvSPCompositeData->wSPVOffset == 0) &&
        (lpNvSPCompositeData->wSPWidth == 0) &&
        (lpNvSPCompositeData->wSPHeight == 0))
        revertRegion = TRUE;

    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    pSurf_gbl = pSurf_lcl->lpGbl;

    pitch422 = (pSurf_gbl->wWidth + 3) & ~3;
    pitch422 = ((pitch422 << 1) + 127) & ~127;

    dwCompositeSurfaceWidth = pSurf_gbl->wWidth;
    dwCompositeSurfaceHeight = pSurf_gbl->wHeight;

    pSPSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVSPSurface;
    pSPSurf_gbl = pSPSurf_lcl->lpGbl;
    
    if(!pSPSurf_gbl->fpVidMem)
        return (DDERR_SURFACELOST);

    dwSubPictureSurfaceWidth = pSurf_gbl->wWidth;
    dwSubPictureSurfaceHeight = pSurf_gbl->wHeight;

    if (pSPSurf_gbl->ddpfSurface.dwFourCC != FOURCC_NVSP) {
        return (DDERR_INVALIDPARAMS);
    }

    lpDstSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

    while ((lpDstSurfaceFlags->dwMCSurfaceBase != 0) &&
           (lpDstSurfaceFlags->dwMCSurfaceBase != pSurf_gbl->fpVidMem))
        lpDstSurfaceFlags++;

    // First make sure destination surface has been format converted
    if ((lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_FRAME) &&
        (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted < 15))
        nvMoCompConvertSurfaceFormat(pSurf_gbl->fpVidMem, TRUE, 15);
    else if ((lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_TOP_FIELD) &&
        ((lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted & 3) < 3))
        nvMoCompConvertSurfaceFormat(pSurf_gbl->fpVidMem, TRUE, 3);
    else if ((lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_BOTTOM_FIELD) &&
        (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted < 12))
        nvMoCompConvertSurfaceFormat(pSurf_gbl->fpVidMem, TRUE, 12);

    if ((revertRegion) || (lpNvSPCompositeData->bSPRestoreImageBeforeCompositing)) {
        unsigned long X0, Y0, X1, Y1;
        unsigned long tmpVal;

        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {

            if (!(nvInitKelvinForMoCompConversion()))
                return DDERR_GENERIC;

            tmpVal = (NV097_SET_TEXTURE_FILTER_BSIGNED_BIT_DISABLED << 31) |
                     (NV097_SET_TEXTURE_FILTER_GSIGNED_BIT_DISABLED << 30) |
                     (NV097_SET_TEXTURE_FILTER_RSIGNED_BIT_DISABLED << 29) |
                     (NV097_SET_TEXTURE_FILTER_ASIGNED_BIT_DISABLED << 28) |
                     (NV097_SET_TEXTURE_FILTER_MAG_TENT_LOD0 << 24) |
                     (NV097_SET_TEXTURE_FILTER_MIN_TENT_LOD0 << 16) |
                     (NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_QUINCUNX << 13);

            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_TEXTURE_FILTER(1) | 0x40000);
            nvPushData(1, tmpVal);

            nvPusherAdjust(2);

            // 420 LUMA portion of this surface starts at fpVidMem
            dwDstOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
            nvPushData(1, dwDstOffset);

            // 420 CHROMA portion of this surface starts here
            dwDstOffset += (pSurf_gbl->lPitch * pSurf_gbl->wHeight);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(3, dwDstOffset);
            nvPusherAdjust(4);
        } else {

            if (!(nvInitCelsiusForMoCompConversion()))
                return DDERR_GENERIC;

            tmpVal = (NV056_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR << 28) |
                     (NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR << 24);

            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                           NV056_SET_TEXTURE_FILTER(1) | 0x40000);
            nvPushData(1, tmpVal);

            nvPusherAdjust(2);

            // 420 LUMA portion of this surface starts at fpVidMem
            dwDstOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
            nvPushData(1, dwDstOffset);

            // 420 CHROMA portion of this surface starts here
            dwDstOffset += (pSurf_gbl->lPitch * pSurf_gbl->wHeight);
            nvPushData(2, dwDstOffset);
            nvPusherAdjust(3);
        }

        if (revertRegion) {
            dw422Offset = lpDstSurfaceFlags->dwMCSurface422Offset;

            // Offset to NV12 surface filtered pixel area if necessary
            if (lpDstSurfaceFlags->bMCFrameIsFiltered) {
                if ((lpDstSurfaceFlags->bMCPictureStructure != PICTURE_STRUCTURE_FRAME) ||
                    (lpNvSPCompositeData->bSPCompositeWith != PICTURE_STRUCTURE_FRAME)) {
                    dw422Offset += (pitch422 * (DWORD)pSurf_gbl->wHeight);  // 422 portion
                }
            }
        } else {
            dw422Offset = VIDMEM_OFFSET(pSPSurf_gbl->fpVidMem);
            dwBlockSize = pSPSurf_gbl->lPitch * pSPSurf_gbl->wHeight; // calculate size of subpicture 8 bit index per pixel plane
            dwBlockSize <<= 1;                  // double size to skip over 8 bit alpha per pixel plane
            dw422Offset += dwBlockSize;         // offset to base of fully decompressed pixel plane in video memory
            dw422Offset += (dwBlockSize << 1);  // increase to skip fully decompressed 32 bit per pixel plane
            dw422Offset += 1024;                // also skip indexed image look up table
        }

        X0 = lpNvSPCompositeData->wMCHOffset;
        X1 = X0 + lpNvSPCompositeData->wMCWidth;
        Y0 = lpNvSPCompositeData->wMCVOffset;
        Y1 = Y0 + lpNvSPCompositeData->wMCHeight;

        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {

            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_NO_OPERATION | 0x40000);
            nvPushData(1, 0);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
            nvPushData(3, dw422Offset);

            nvPusherAdjust(4);

            SET_KELVIN_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_BEGIN_END | 0x40000);
            nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_INLINE_ARRAY | 0x40300000);

            nvPushData(3, (Y0 << 18) | (X0 << 1));
            nvPushData(4, (Y0 << 16) | (X0 >> 1));
            nvPushData(5, (Y0 << 15) | (X0 >> 1));

            nvPushData(6, ((Y1 << 2) << 16) | (X0 << 1)); // destination is in quarter pel units
            nvPushData(7, (Y1 << 16) | (X0 >> 1)); // LUMA texture is in pel units
            if (lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_FRAME)
                nvPushData(8, ((Y1 >> 1) << 16) | (X0 >> 1)); // CHROMA texture is in pel units and is only half the surface height
            else
                nvPushData(8, ((Y1 >> 2) << 16) | (X0 >> 1)); // CHROMA texture is in pel units and is only half the surface height

            nvPushData(9, ((Y1 << 2) << 16) | (X1 << 1)); // each 32 bit write contains data for 2 422 pixels
            nvPushData(10, (Y1 << 16) | (X1 >> 1));
            if (lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_FRAME)
                nvPushData(11, ((Y1 >> 1) << 16) | (X1 >> 1));
            else
                nvPushData(11, ((Y1 >> 2) << 16) | (X1 >> 1));

            nvPushData(12, (Y0 << 18) | (X1 << 1));
            nvPushData(13, (Y0 << 16) | (X1 >> 1));
            nvPushData(14, (Y0 << 15) | (X1 >> 1));

            nvPushData(15, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_BEGIN_END | 0x40000);
            nvPushData(16, NV097_SET_BEGIN_END_OP_END);
            nvPusherAdjust(17);
        } else {

            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_NO_OPERATION | 0x40000);
            nvPushData(1, 0);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
            nvPushData(3, dw422Offset);

            nvPusherAdjust(4);

            SET_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_BEGIN_END | 0x40000);
            nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_INLINE_ARRAY(0) | 0x300000);

            // No HD scaled version because subpicture compositing is not used for HD 
            nvPushData(3, (Y0 << 15) | (X0 >> 1));
            nvPushData(4, (Y0 << 16) | (X0 >> 1));
            nvPushData(5, (Y0 << 18) | (((X0 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF));

            if (lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_FRAME)
                nvPushData(6, ((Y1 >> 1) << 16) | (X0 >> 1)); // CHROMA texture is in pel units and is only half the surface height
            else
                nvPushData(6, ((Y1 >> 2) << 16) | (X0 >> 1)); // CHROMA texture is in pel units and is only half the surface height
            nvPushData(7, (Y1 << 16) | (X0 >> 1)); // LUMA texture is in pel units
            nvPushData(8, ((Y1 << 2) << 16) | (((X0 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF)); // destination is in quarter pel units

            if (lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_FRAME)
                nvPushData(9, ((Y1 >> 1) << 16) | (X1 >> 1));
            else
                nvPushData(9, ((Y1 >> 2) << 16) | (X1 >> 1));
            nvPushData(10, (Y1 << 16) | (X1 >> 1));
            nvPushData(11, ((Y1 << 2) << 16) | (((X1 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF)); // each 32 bit write contains data for 2 422 pixels

            nvPushData(12, (Y0 << 15) | (X1 >> 1));
            nvPushData(13, (Y0 << 16) | (X1 >> 1));
            nvPushData(14, (Y0 << 18) | (((X1 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF));

            nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                           NV056_SET_BEGIN_END | 0x40000);
            nvPushData(16, NV056_SET_BEGIN_END_OP_END);
            nvPusherAdjust(17);
        }

        nvPusherStart(TRUE);
    }

    if (!revertRegion) {
        long subPictureScaleDeltaX;
        long subPictureScaleDeltaY;

        dwDstOffset = lpDstSurfaceFlags->dwMCSurface422Offset;

        if (lpNvSPCompositeData->bSPRestoreImageBeforeCompositing == 0)
            dw422Offset = dwDstOffset;

        if (lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_FRAME)
            lpDstSurfaceFlags->bMCFrameIsComposited = PICTURE_STRUCTURE_FRAME;
        else if (lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_TOP_FIELD)
            lpDstSurfaceFlags->bMCFrameIsComposited |= PICTURE_STRUCTURE_TOP_FIELD;
        else
            lpDstSurfaceFlags->bMCFrameIsComposited |= PICTURE_STRUCTURE_BOTTOM_FIELD;

        dwSrcOffset = VIDMEM_OFFSET(pSPSurf_gbl->fpVidMem);

        dwBlockSize = pSPSurf_gbl->lPitch * pSPSurf_gbl->wHeight;   // calculate size of subpicture 8 bit index per pixel plane
        dwBlockSize <<= 1;                                          // double size to skip over 8 bit alpha per pixel plane

        dwSrcOffset += dwBlockSize;                                 // offset to base of fully decompressed pixel plane in video memory

        subPictureScaleDeltaX = lpNvSPCompositeData->wSPWidth;
        subPictureScaleDeltaX = (subPictureScaleDeltaX << 20) / lpNvSPCompositeData->wMCWidth;
        if ((subPictureScaleDeltaX < 0x10000) || (subPictureScaleDeltaX > 0x1000000))
            subPictureScaleDeltaX = 0x100000;

        subPictureScaleDeltaY = lpNvSPCompositeData->wSPHeight;
        subPictureScaleDeltaY = (subPictureScaleDeltaY << 20) / lpNvSPCompositeData->wMCHeight;
        if ((subPictureScaleDeltaY < 0x10000) || (subPictureScaleDeltaY > 0x1000000))
            subPictureScaleDeltaY = 0x100000;

        if (lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_FRAME) {

            nvPushData (0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
            nvPushData (1, NV_VPP_DVD_SUBPICTURE_IID);
            nvPushData (2, dDrawSubchannelOffset(NV_DD_SPARE) +
                    NV088_IMAGE_OUT_POINT | 0x400000);
            nvPushData (3, asmMergeCoords(lpNvSPCompositeData->wMCHOffset, lpNvSPCompositeData->wMCVOffset));
            nvPushData (4, asmMergeCoords(lpNvSPCompositeData->wMCWidth, lpNvSPCompositeData->wMCHeight));
            nvPushData (5, (NV088_IMAGE_OUT_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | pitch422);
            nvPushData (6, dwDstOffset);                                            // 422 destination pixel area
            nvPushData (7, 0x100000);
            nvPushData (8, 0x100000);
            nvPushData (9, asmMergeCoords(dwCompositeSurfaceWidth, dwCompositeSurfaceHeight));
            nvPushData (10, (NV088_IMAGE_IN_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | pitch422);

            nvPushData (11, dw422Offset);                                           // 422 source pixel area
            nvPushData (12, ((asmMergeCoords(lpNvSPCompositeData->wMCHOffset, lpNvSPCompositeData->wMCVOffset)) << 4));
            nvPushData (13, subPictureScaleDeltaX);
            nvPushData (14, subPictureScaleDeltaY);
            nvPushData (15, asmMergeCoords(dwSubPictureSurfaceWidth, dwSubPictureSurfaceHeight));
            nvPushData (16, (NV088_OVERLAY_FORMAT_COLOR_LE_A8CR8CB8Y8 << 16) | (pSurf_gbl->lPitch << 2));
            nvPushData (17, dwSrcOffset);
            nvPushData (18, ((asmMergeCoords(lpNvSPCompositeData->wSPHOffset, lpNvSPCompositeData->wSPVOffset)) << 4));

            nvPusherAdjust (19);

            if (lpDstSurfaceFlags->bMCFrameIsFiltered) {
                dwDstOffset += (pitch422 * (DWORD)pSurf_gbl->wHeight);  // 422 filtered portion

                if (lpNvSPCompositeData->bSPRestoreImageBeforeCompositing == 0)
                dw422Offset = dwDstOffset;

                nvPushData (0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
                nvPushData (1, NV_VPP_DVD_SUBPICTURE_IID);
                nvPushData (2, dDrawSubchannelOffset(NV_DD_SPARE) +
                        NV088_IMAGE_OUT_POINT | 0x400000);
                nvPushData (3, asmMergeCoords(lpNvSPCompositeData->wMCHOffset, lpNvSPCompositeData->wMCVOffset));
                nvPushData (4, asmMergeCoords(lpNvSPCompositeData->wMCWidth, lpNvSPCompositeData->wMCHeight));
                nvPushData (5, (NV088_IMAGE_OUT_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | pitch422);
                nvPushData (6, dwDstOffset);                                            // 422 destination pixel area
                nvPushData (7, 0x100000);
                nvPushData (8, 0x100000);
                nvPushData (9, asmMergeCoords(dwCompositeSurfaceWidth, dwCompositeSurfaceHeight));
                nvPushData (10, (NV088_IMAGE_IN_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | pitch422);

                nvPushData (11, dw422Offset);                                           // 422 source pixel area
                nvPushData (12, ((asmMergeCoords(lpNvSPCompositeData->wMCHOffset, lpNvSPCompositeData->wMCVOffset)) << 4));
                nvPushData (13, subPictureScaleDeltaX);
                nvPushData (14, subPictureScaleDeltaY);
                nvPushData (15, asmMergeCoords(dwSubPictureSurfaceWidth, dwSubPictureSurfaceHeight));
                nvPushData (16, (NV088_OVERLAY_FORMAT_COLOR_LE_A8CR8CB8Y8 << 16) | (pSurf_gbl->lPitch << 2));
                nvPushData (17, dwSrcOffset);
                nvPushData (18, ((asmMergeCoords(lpNvSPCompositeData->wSPHOffset, lpNvSPCompositeData->wSPVOffset)) << 4));

                nvPusherAdjust (19);
            }
        } else if (lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_TOP_FIELD) {

            nvPushData (0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
            nvPushData (1, NV_VPP_DVD_SUBPICTURE_IID);
            nvPushData (2, dDrawSubchannelOffset(NV_DD_SPARE) +
                    NV088_IMAGE_OUT_POINT | 0x400000);
            nvPushData (3, asmMergeCoords(lpNvSPCompositeData->wMCHOffset, lpNvSPCompositeData->wMCVOffset));
            nvPushData (4, asmMergeCoords(lpNvSPCompositeData->wMCWidth, lpNvSPCompositeData->wMCHeight));
            nvPushData (5, (NV088_IMAGE_OUT_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | (pitch422 << 1));
            nvPushData (6, dwDstOffset);                                            // 422 destination pixel area
            nvPushData (7, 0x100000);
            nvPushData (8, 0x100000);
            nvPushData (9, asmMergeCoords(dwCompositeSurfaceWidth, dwCompositeSurfaceHeight));
            nvPushData (10, (NV088_IMAGE_IN_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | (pitch422 << 1));

            nvPushData (11, dw422Offset);                                           // 422 source pixel area
            nvPushData (12, ((asmMergeCoords(lpNvSPCompositeData->wMCHOffset, lpNvSPCompositeData->wMCVOffset)) << 4));
            nvPushData (13, subPictureScaleDeltaX);
            nvPushData (14, subPictureScaleDeltaY);
            nvPushData (15, asmMergeCoords(dwSubPictureSurfaceWidth, dwSubPictureSurfaceHeight));
            nvPushData (16, (NV088_OVERLAY_FORMAT_COLOR_LE_A8CR8CB8Y8 << 16) | (pSurf_gbl->lPitch << 3));
            nvPushData (17, dwSrcOffset);
            nvPushData (18, ((asmMergeCoords(lpNvSPCompositeData->wSPHOffset, lpNvSPCompositeData->wSPVOffset)) << 4));

            nvPusherAdjust (19);

            if (lpDstSurfaceFlags->bMCFrameIsFiltered) {
                dwDstOffset += (pitch422 * (DWORD)pSurf_gbl->wHeight);  // 422 filtered portion

                if (lpNvSPCompositeData->bSPRestoreImageBeforeCompositing == 0)
                dw422Offset = dwDstOffset;

                nvPushData (0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
                nvPushData (1, NV_VPP_DVD_SUBPICTURE_IID);
                nvPushData (2, dDrawSubchannelOffset(NV_DD_SPARE) +
                        NV088_IMAGE_OUT_POINT | 0x400000);
                nvPushData (3, asmMergeCoords(lpNvSPCompositeData->wMCHOffset, lpNvSPCompositeData->wMCVOffset));
                nvPushData (4, asmMergeCoords(lpNvSPCompositeData->wMCWidth, lpNvSPCompositeData->wMCHeight));
                nvPushData (5, (NV088_IMAGE_OUT_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | (pitch422 << 1));
                nvPushData (6, dwDstOffset);                                            // 422 destination pixel area
                nvPushData (7, 0x100000);
                nvPushData (8, 0x100000);
                nvPushData (9, asmMergeCoords(dwCompositeSurfaceWidth, dwCompositeSurfaceHeight));
                nvPushData (10, (NV088_IMAGE_IN_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | (pitch422 << 1));

                nvPushData (11, dw422Offset);                                           // 422 source pixel area
                nvPushData (12, ((asmMergeCoords(lpNvSPCompositeData->wMCHOffset, lpNvSPCompositeData->wMCVOffset)) << 4));
                nvPushData (13, subPictureScaleDeltaX);
                nvPushData (14, subPictureScaleDeltaY);
                nvPushData (15, asmMergeCoords(dwSubPictureSurfaceWidth, dwSubPictureSurfaceHeight));
                nvPushData (16, (NV088_OVERLAY_FORMAT_COLOR_LE_A8CR8CB8Y8 << 16) | (pSurf_gbl->lPitch << 3));
                nvPushData (17, dwSrcOffset);
                nvPushData (18, ((asmMergeCoords(lpNvSPCompositeData->wSPHOffset, lpNvSPCompositeData->wSPVOffset)) << 4));

                nvPusherAdjust (19);
            }
        } else {

            nvPushData (0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
            nvPushData (1, NV_VPP_DVD_SUBPICTURE_IID);
            nvPushData (2, dDrawSubchannelOffset(NV_DD_SPARE) +
                    NV088_IMAGE_OUT_POINT | 0x400000);
            nvPushData (3, asmMergeCoords(lpNvSPCompositeData->wMCHOffset, lpNvSPCompositeData->wMCVOffset));
            nvPushData (4, asmMergeCoords(lpNvSPCompositeData->wMCWidth, lpNvSPCompositeData->wMCHeight));
            nvPushData (5, (NV088_IMAGE_OUT_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | (pitch422 << 1));
            nvPushData (6, (dwDstOffset + pitch422));                               // 422 destination pixel area
            nvPushData (7, 0x100000);
            nvPushData (8, 0x100000);
            nvPushData (9, asmMergeCoords(dwCompositeSurfaceWidth, dwCompositeSurfaceHeight));
            nvPushData (10, (NV088_IMAGE_IN_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | (pitch422 << 1));

            nvPushData (11, (dw422Offset + pitch422));                              // 422 source pixel area
            nvPushData (12, ((asmMergeCoords(lpNvSPCompositeData->wMCHOffset, lpNvSPCompositeData->wMCVOffset)) << 4));
            nvPushData (13, subPictureScaleDeltaX);
            nvPushData (14, subPictureScaleDeltaY);
            nvPushData (15, asmMergeCoords(dwSubPictureSurfaceWidth, dwSubPictureSurfaceHeight));
            nvPushData (16, (NV088_OVERLAY_FORMAT_COLOR_LE_A8CR8CB8Y8 << 16) | (pSurf_gbl->lPitch << 3));
            nvPushData (17, (dwSrcOffset + (pSurf_gbl->lPitch << 2)));
            nvPushData (18, ((asmMergeCoords(lpNvSPCompositeData->wSPHOffset, lpNvSPCompositeData->wSPVOffset)) << 4));

            nvPusherAdjust (19);

            if (lpDstSurfaceFlags->bMCFrameIsFiltered) {
                dwDstOffset += (pitch422 * (DWORD)pSurf_gbl->wHeight);  // 422 filtered portion

                if (lpNvSPCompositeData->bSPRestoreImageBeforeCompositing == 0)
                dw422Offset = dwDstOffset;

                nvPushData (0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
                nvPushData (1, NV_VPP_DVD_SUBPICTURE_IID);
                nvPushData (2, dDrawSubchannelOffset(NV_DD_SPARE) +
                        NV088_IMAGE_OUT_POINT | 0x400000);
                nvPushData (3, asmMergeCoords(lpNvSPCompositeData->wMCHOffset, lpNvSPCompositeData->wMCVOffset));
                nvPushData (4, asmMergeCoords(lpNvSPCompositeData->wMCWidth, lpNvSPCompositeData->wMCHeight));
                nvPushData (5, (NV088_IMAGE_OUT_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | (pitch422 << 1));
                nvPushData (6, (dwDstOffset + pitch422));                               // 422 destination pixel area
                nvPushData (7, 0x100000);
                nvPushData (8, 0x100000);
                nvPushData (9, asmMergeCoords(dwCompositeSurfaceWidth, dwCompositeSurfaceHeight));
                nvPushData (10, (NV088_IMAGE_IN_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | (pitch422 << 1));

                nvPushData (11, (dw422Offset + pitch422));                              // 422 source pixel area
                nvPushData (12, ((asmMergeCoords(lpNvSPCompositeData->wMCHOffset, lpNvSPCompositeData->wMCVOffset)) << 4));
                nvPushData (13, subPictureScaleDeltaX);
                nvPushData (14, subPictureScaleDeltaY);
                nvPushData (15, asmMergeCoords(dwSubPictureSurfaceWidth, dwSubPictureSurfaceHeight));
                nvPushData (16, (NV088_OVERLAY_FORMAT_COLOR_LE_A8CR8CB8Y8 << 16) | (pSurf_gbl->lPitch << 3));
                nvPushData (17, (dwSrcOffset + (pSurf_gbl->lPitch << 2)));
                nvPushData (18, ((asmMergeCoords(lpNvSPCompositeData->wSPHOffset, lpNvSPCompositeData->wSPVOffset)) << 4));

                nvPusherAdjust (19);
            }
        }
    }

    // Update reference count in case we get a status query
    lpDstSurfaceFlags->dwMCCompositeReferenceCount = getDC()->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);

    nvPusherStart(TRUE);

    pDriverData->dDrawSpareSubchannelObject = NV_VPP_DVD_SUBPICTURE_IID;

    return DD_OK;

} /* nvMoCompCompositeSubpicture */


#if 0

// This is a test function to demonstrate NV12 subpicture compositing using Celsius in NV17.
// It would need some modification to actually be used in the driver.

extern DWORD __stdcall nvInitCelsiusForMoCompNV12LumaSubpictureCompositing(void);
extern DWORD __stdcall nvInitCelsiusForMoCompNV12ChromaSubpictureCompositing(void);

/*
 * nvMoCompCompositeNV12Subpicture
 *
 * Performs full or partial compositing of a decompressed subpicture surface to the destination NV12
 * surface with scaling.  Currently works in frame mode only.
 *
 * Note that pDriverData must be set before calling this function.
 *
 */
DWORD __stdcall nvMoCompCompositeNV12Subpicture(LPVOID lpInputData, DWORD dwSurfaceIndex)
{
    LPNVSPCOMPOSITEDATA lpNvSPCompositeData = (LPNVSPCOMPOSITEDATA)lpInputData;
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl;
    LPDDRAWI_DDRAWSURFACE_LCL   pSPSurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   pSPSurf_gbl;
    LPNVMCSURFACEFLAGS          lpDstSurfaceFlags;
    DWORD                       dwBlockSize;
    unsigned long               dwSrcOffset;
    unsigned long               dw422Offset;
    unsigned long               dwDstOffset;
    unsigned long               pitch422;
    unsigned long               dwSubPictureSurfaceWidth;
    unsigned long               dwSubPictureSurfaceHeight;
    unsigned long               dwCompositeSurfaceWidth;
    unsigned long               dwCompositeSurfaceHeight;
    unsigned long               X0, Y0, X1, Y1;
    unsigned long               SPX0, SPY0, SPX1, SPY1;
    BYTE                        revertRegion = FALSE;

    if ((lpNvSPCompositeData->wSPHOffset < 0) ||
        (lpNvSPCompositeData->wSPVOffset < 0) ||
        (lpNvSPCompositeData->wSPWidth < 0) ||
        (lpNvSPCompositeData->wSPHeight < 0))
        return (DDERR_INVALIDPARAMS);

    if ((lpNvSPCompositeData->wMCHOffset < 0) ||
        (lpNvSPCompositeData->wMCVOffset < 0) ||
        (lpNvSPCompositeData->wMCWidth < 0) ||
        (lpNvSPCompositeData->wMCHeight < 0))
        return (DDERR_INVALIDPARAMS);

    // Is this a request to revert to an uncomposited destination ?
    if ((lpNvSPCompositeData->wSPHOffset == 0) &&
        (lpNvSPCompositeData->wSPVOffset == 0) &&
        (lpNvSPCompositeData->wSPWidth == 0) &&
        (lpNvSPCompositeData->wSPHeight == 0))
        revertRegion = TRUE;

    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    pSurf_gbl = pSurf_lcl->lpGbl;

    pitch422 = (pSurf_gbl->wWidth + 3) & ~3;
    pitch422 = ((pitch422 << 1) + 127) & ~127;

    dwCompositeSurfaceWidth = pSurf_gbl->wWidth;
    dwCompositeSurfaceHeight = pSurf_gbl->wHeight;

    pSPSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVSPSurface;
    pSPSurf_gbl = pSPSurf_lcl->lpGbl;

    dwSubPictureSurfaceWidth = pSurf_gbl->wWidth;
    dwSubPictureSurfaceHeight = pSurf_gbl->wHeight;

    if (pSPSurf_gbl->ddpfSurface.dwFourCC != FOURCC_NVSP) {
        return (DDERR_INVALIDPARAMS);
    }

    lpDstSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

    while ((lpDstSurfaceFlags->dwMCSurfaceBase != 0) &&
           (lpDstSurfaceFlags->dwMCSurfaceBase != pSurf_gbl->fpVidMem))
        lpDstSurfaceFlags++;

    // First make sure destination surface has been format converted
    if ((lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_FRAME) &&
        (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted < 15))
        nvMoCompConvertSurfaceFormat(pSurf_gbl->fpVidMem, TRUE, 15);
    else if ((lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_TOP_FIELD) &&
        ((lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted & 3) < 3))
        nvMoCompConvertSurfaceFormat(pSurf_gbl->fpVidMem, TRUE, 3);
    else if ((lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_BOTTOM_FIELD) &&
        (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted < 12))
        nvMoCompConvertSurfaceFormat(pSurf_gbl->fpVidMem, TRUE, 12);

    X0 = lpNvSPCompositeData->wMCHOffset;
    X1 = X0 + lpNvSPCompositeData->wMCWidth;
    Y0 = lpNvSPCompositeData->wMCVOffset;
    Y1 = Y0 + lpNvSPCompositeData->wMCHeight;

    SPX0 = lpNvSPCompositeData->wSPHOffset;
    SPX1 = SPX0 + lpNvSPCompositeData->wSPWidth;
    SPY0 = lpNvSPCompositeData->wSPVOffset;
    SPY1 = SPY0 + lpNvSPCompositeData->wSPHeight;

    if ((revertRegion) || (lpNvSPCompositeData->bSPRestoreImageBeforeCompositing)) {
        unsigned long tmpVal;

        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {

            if (!(nvInitKelvinForMoCompConversion()))
                return DDERR_GENERIC;

            tmpVal = (NV097_SET_TEXTURE_FILTER_BSIGNED_BIT_DISABLED << 31) |
                     (NV097_SET_TEXTURE_FILTER_GSIGNED_BIT_DISABLED << 30) |
                     (NV097_SET_TEXTURE_FILTER_RSIGNED_BIT_DISABLED << 29) |
                     (NV097_SET_TEXTURE_FILTER_ASIGNED_BIT_DISABLED << 28) |
                     (NV097_SET_TEXTURE_FILTER_MAG_TENT_LOD0 << 24) |
                     (NV097_SET_TEXTURE_FILTER_MIN_TENT_LOD0 << 16) |
                     (NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_QUINCUNX << 13);

            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_TEXTURE_FILTER(1) | 0x40000);
            nvPushData(1, tmpVal);

            nvPusherAdjust(2);

            // 420 LUMA portion of this surface starts at fpVidMem
            dwDstOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
            nvPushData(1, dwDstOffset);

            // 420 CHROMA portion of this surface starts here
            dwDstOffset += (pSurf_gbl->lPitch * pSurf_gbl->wHeight);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(3, dwDstOffset);
            nvPusherAdjust(4);
        } else {

            if (!(nvInitCelsiusForMoCompConversion()))
                return DDERR_GENERIC;

            tmpVal = (NV056_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR << 28) |
                     (NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR << 24);

            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                           NV056_SET_TEXTURE_FILTER(1) | 0x40000);
            nvPushData(1, tmpVal);

            nvPusherAdjust(2);

            // 420 LUMA portion of this surface starts at fpVidMem
            dwDstOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
            nvPushData(1, dwDstOffset);

            // 420 CHROMA portion of this surface starts here
            dwDstOffset += (pSurf_gbl->lPitch * pSurf_gbl->wHeight);
            nvPushData(2, dwDstOffset);
            nvPusherAdjust(3);
        }

        if (revertRegion) {
            dw422Offset = lpDstSurfaceFlags->dwMCSurface422Offset;

            // Offset to NV12 surface filtered pixel area if necessary
            if (lpDstSurfaceFlags->bMCFrameIsFiltered) {
                if ((lpDstSurfaceFlags->bMCPictureStructure != PICTURE_STRUCTURE_FRAME) ||
                    (lpNvSPCompositeData->bSPCompositeWith != PICTURE_STRUCTURE_FRAME)) {
                    dw422Offset += (pitch422 * (DWORD)pSurf_gbl->wHeight);  // 422 portion
                }
            }
        } else {
            dw422Offset = VIDMEM_OFFSET(pSPSurf_gbl->fpVidMem);
            dwBlockSize = pSPSurf_gbl->lPitch * pSPSurf_gbl->wHeight; // calculate size of subpicture 8 bit index per pixel plane
            dwBlockSize <<= 1;                  // double size to skip over 8 bit alpha per pixel plane
            dw422Offset += dwBlockSize;         // offset to base of fully decompressed pixel plane in video memory
            dw422Offset += (dwBlockSize << 1);  // increase to skip fully decompressed 32 bit per pixel plane
            dw422Offset += 1024;                // also skip indexed image look up table
        }


        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {

            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_NO_OPERATION | 0x40000);
            nvPushData(1, 0);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
            nvPushData(3, dw422Offset);

            nvPusherAdjust(4);

            SET_KELVIN_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_BEGIN_END | 0x40000);
            nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_INLINE_ARRAY | 0x40300000);

            nvPushData(3, (Y0 << 18) | (X0 << 1));
            nvPushData(4, (Y0 << 16) | (X0 >> 1));
            nvPushData(5, (Y0 << 15) | (X0 >> 1));

            nvPushData(6, ((Y1 << 2) << 16) | (X0 << 1)); // destination is in quarter pel units
            nvPushData(7, (Y1 << 16) | (X0 >> 1)); // LUMA texture is in pel units
            if (lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_FRAME)
                nvPushData(8, ((Y1 >> 1) << 16) | (X0 >> 1)); // CHROMA texture is in pel units and is only half the surface height
            else
                nvPushData(8, ((Y1 >> 2) << 16) | (X0 >> 1)); // CHROMA texture is in pel units and is only half the surface height

            nvPushData(9, ((Y1 << 2) << 16) | (X1 << 1)); // each 32 bit write contains data for 2 422 pixels
            nvPushData(10, (Y1 << 16) | (X1 >> 1));
            if (lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_FRAME)
                nvPushData(11, ((Y1 >> 1) << 16) | (X1 >> 1));
            else
                nvPushData(11, ((Y1 >> 2) << 16) | (X1 >> 1));

            nvPushData(12, (Y0 << 18) | (X1 << 1));
            nvPushData(13, (Y0 << 16) | (X1 >> 1));
            nvPushData(14, (Y0 << 15) | (X1 >> 1));

            nvPushData(15, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_BEGIN_END | 0x40000);
            nvPushData(16, NV097_SET_BEGIN_END_OP_END);
            nvPusherAdjust(17);
        } else {

            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_NO_OPERATION | 0x40000);
            nvPushData(1, 0);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
            nvPushData(3, dw422Offset);

            nvPusherAdjust(4);

            SET_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_BEGIN_END | 0x40000);
            nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_INLINE_ARRAY(0) | 0x300000);

            // No HD scaled version because subpicture compositing is not used for HD 
            nvPushData(3, (Y0 << 15) | (X0 >> 1));
            nvPushData(4, (Y0 << 16) | (X0 >> 1));
            nvPushData(5, (Y0 << 18) | (((X0 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF));

            if (lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_FRAME)
                nvPushData(6, ((Y1 >> 1) << 16) | (X0 >> 1)); // CHROMA texture is in pel units and is only half the surface height
            else
                nvPushData(6, ((Y1 >> 2) << 16) | (X0 >> 1)); // CHROMA texture is in pel units and is only half the surface height
            nvPushData(7, (Y1 << 16) | (X0 >> 1)); // LUMA texture is in pel units
            nvPushData(8, ((Y1 << 2) << 16) | (((X0 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF)); // destination is in quarter pel units

            if (lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_FRAME)
                nvPushData(9, ((Y1 >> 1) << 16) | (X1 >> 1));
            else
                nvPushData(9, ((Y1 >> 2) << 16) | (X1 >> 1));
            nvPushData(10, (Y1 << 16) | (X1 >> 1));
            nvPushData(11, ((Y1 << 2) << 16) | (((X1 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF)); // each 32 bit write contains data for 2 422 pixels

            nvPushData(12, (Y0 << 15) | (X1 >> 1));
            nvPushData(13, (Y0 << 16) | (X1 >> 1));
            nvPushData(14, (Y0 << 18) | (((X1 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF));

            nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                           NV056_SET_BEGIN_END | 0x40000);
            nvPushData(16, NV056_SET_BEGIN_END_OP_END);
            nvPusherAdjust(17);
        }

        nvPusherStart(TRUE);
    }

    if (!revertRegion) {
        unsigned long dwSPSrcOffset;
        unsigned long dwSurfacePitch;
        unsigned long surfaceWidth;
        unsigned long tmpVal;
        
        dwSrcOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

        // compositing portion of this surface starts here (overwrites filtered portion)
        dwDstOffset = lpDstSurfaceFlags->dwMCSurface422Offset + (pitch422 * (DWORD)pSurf_gbl->wHeight);   // 420 compositing and 422 filtering portion

        if (lpNvSPCompositeData->bSPRestoreImageBeforeCompositing == 0)
            dw422Offset = dwDstOffset;

        if (lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_FRAME)
            lpDstSurfaceFlags->bMCFrameIsComposited = PICTURE_STRUCTURE_FRAME;
        else if (lpNvSPCompositeData->bSPCompositeWith == PICTURE_STRUCTURE_TOP_FIELD)
            lpDstSurfaceFlags->bMCFrameIsComposited |= PICTURE_STRUCTURE_TOP_FIELD;
        else
            lpDstSurfaceFlags->bMCFrameIsComposited |= PICTURE_STRUCTURE_BOTTOM_FIELD;

        dwSPSrcOffset = VIDMEM_OFFSET(pSPSurf_gbl->fpVidMem);

        dwBlockSize = pSPSurf_gbl->lPitch * pSPSurf_gbl->wHeight;   // calculate size of subpicture 8 bit index per pixel plane
        dwBlockSize <<= 1;                                          // double size to skip over 8 bit alpha per pixel plane

        dwSPSrcOffset += dwBlockSize;                               // offset to base of fully decompressed pixel plane in video memory

        if (pDriverData->dwMostRecentHWUser != MODULE_ID_DDRAW) {
            if (!(nvInitCelsiusForMoComp()))
                return DDERR_GENERIC;
        }

        // Now blend subpicture rectangle with NV12 luma plane

        if (!(nvInitCelsiusForMoCompNV12LumaSubpictureCompositing()))
            return DDERR_GENERIC;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(3, dwDstOffset);

        nvPusherAdjust(4);

        dwSurfacePitch = pSurf_gbl->lPitch;
        dwSurfacePitch |= (dwSurfacePitch << 16);
        
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_PITCH | 0x40000);
        nvPushData(1, dwSurfacePitch);

        nvPusherAdjust(2);
        
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
        nvPushData(1, dwSPSrcOffset);
        nvPushData(2, dwSrcOffset);

        nvPusherAdjust(3);

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
        nvPushData(1, pSPSurf_gbl->lPitch << 18); // pitch << 2
        nvPushData(2, dwSurfacePitch << 16);

        nvPusherAdjust(3);

        SET_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_BEGIN_END | 0x40000);
        nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0x300000);

        // No HD scaled version because subpicture compositing is not used for HD 
        nvPushData(3, (Y0 << 16) | (X0)); // source NV12 luma in pel units
        nvPushData(4, (SPY0 << 16) | (SPX0)); // AVUY subpicture in pel units
        nvPushData(5, (Y0 << 18) | (((X0 << 2) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF)); // destination NV12 luma in quarter pel units

        nvPushData(6, (Y1 << 16) | (X0));
        nvPushData(7, (SPY1 << 16) | (SPX0));
        nvPushData(8, (Y1 << 18) | (((X0 << 2) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF));

        nvPushData(9, (Y1 << 16) | (X1));
        nvPushData(10, (SPY1 << 16) | (SPX1));
        nvPushData(11, (Y1 << 18) | (((X1 << 2) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF));

        nvPushData(12, (Y0 << 16) | (X1));
        nvPushData(13, (SPY0 << 16) | (SPX1));
        nvPushData(14, (Y0 << 18) | (((X1 << 2) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF));

        nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_BEGIN_END | 0x40000);
        nvPushData(16, NV056_SET_BEGIN_END_OP_END);

        nvPusherAdjust(17);

        // Now blend subpicture rectangle with NV12 chroma plane
        
        if (!(nvInitCelsiusForMoCompNV12ChromaSubpictureCompositing()))
            return DDERR_GENERIC;

        dwDstOffset += pSurf_gbl->lPitch * (DWORD)pSurf_gbl->wHeight; // Change offset to destination chroma plane

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(3, dwDstOffset);

        nvPusherAdjust(4);

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_PITCH | 0x40000);
        nvPushData(1, dwSurfacePitch);

        nvPusherAdjust(2);
        
        dwSrcOffset += pSurf_gbl->lPitch * (DWORD)pSurf_gbl->wHeight; // Change offset to source chroma plane

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
        nvPushData(1, dwSPSrcOffset);
        nvPushData(2, dwSrcOffset);

        nvPusherAdjust(3);

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
        nvPushData(1, pSPSurf_gbl->lPitch << 18); // pitch << 2
        nvPushData(2, dwSurfacePitch << 16);

        nvPusherAdjust(3);

        SET_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_BEGIN_END | 0x40000);
        nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0x300000);

        // No HD scaled version because subpicture compositing is not used for HD 
        nvPushData(3, ((Y0 >> 1) << 16) | (X0 >> 1)); // source NV12 chroma in pel units
        nvPushData(4, (SPY0 << 16) | (SPX0)); // AVUY subpicture in pel units
        nvPushData(5, (Y0 << 17) | (((X0 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF)); // destination NV12 chroma in quarter pel units

        nvPushData(6, ((Y1 >> 1) << 16) | (X0 >> 1));
        nvPushData(7, (SPY1 << 16) | (SPX0));
        nvPushData(8, (Y1 << 17) | (((X0 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF));

        nvPushData(9, ((Y1 >> 1) << 16) | (X1 >> 1));
        nvPushData(10, (SPY1 << 16) | (SPX1));
        nvPushData(11, (Y1 << 17) | (((X1 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF));

        nvPushData(12, ((Y0 >> 1) << 16) | (X1 >> 1));
        nvPushData(13, (SPY0 << 16) | (SPX1));
        nvPushData(14, (Y0 << 17) | (((X1 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF));

        nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_BEGIN_END | 0x40000);
        nvPushData(16, NV056_SET_BEGIN_END_OP_END);

        nvPusherAdjust(17);

        // Update reference count in case we get a status query
        lpDstSurfaceFlags->dwMCCompositeReferenceCount = getDC()->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);

        nvPusherStart(TRUE);

        // Now format convert final NV12 blended rectangle to 422 overwriting current 422 pixels

        if (!(nvInitCelsiusForMoCompConversion()))
            return FALSE;

        tmpVal = (NV056_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR << 28) |
                 (NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR << 24);

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_TEXTURE_FILTER(1) | 0x40000);
        nvPushData(1, tmpVal);

        nvPusherAdjust(2);

        // 420 LUMA portion of this surface starts at fpVidMem
        dwDstOffset -= pSurf_gbl->lPitch * (DWORD)pSurf_gbl->wHeight; // Change offset back to destination luma plane
        
        dwSurfacePitch = pSurf_gbl->lPitch;
        
        surfaceWidth = pSurf_gbl->wWidth;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
        nvPushData(1, dwDstOffset);

        // 420 CHROMA portion of this surface starts here
        dwDstOffset += (dwSurfacePitch * pSurf_gbl->wHeight);

        nvPushData(2, dwDstOffset);

        nvPusherAdjust(3);

        // 422 portion of this surface starts here
        dwDstOffset = lpDstSurfaceFlags->dwMCSurface422Offset;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(3, dwDstOffset);

        nvPusherAdjust(4);

        // Align surface pitch and set surface format and pitch
        dwSurfacePitch = ((surfaceWidth << 1) + 127) & ~127; // YUY2 destination is twice the surface width
        dwSurfacePitch |= (dwSurfacePitch << 16);
        
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_PITCH | 0x40000);
        nvPushData(1, dwSurfacePitch);

        nvPusherAdjust(2);

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
        nvPushData(1, pSurf_gbl->lPitch << 16);
        nvPushData(2, pSurf_gbl->lPitch << 16);

        nvPusherAdjust(3);

        SET_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_BEGIN_END | 0x40000);
        nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0x300000);

        // No HD scaled version because subpicture compositing is not used for HD 
        nvPushData(3, ((Y0 >> 1) << 16) | 0);
        nvPushData(4, (Y0 << 16) | 0);
        nvPushData(5, (Y0 << 18) | ((0 - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF));

        nvPushData(6, ((Y1 >> 1) << 16) | 0); // CHROMA texture is in pel units and is only half the surface height
        nvPushData(7, (Y1 << 16) | 0); // LUMA texture is in pel units
        nvPushData(8, (Y1 << 18) | ((0 - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF)); // destination is in quarter pel units

        nvPushData(9, ((Y1 >> 1) << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(10, (Y1 << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(11, (Y1 << 18) | (((surfaceWidth << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF)); // each 32 bit write contains data for 2 422 pixels

        nvPushData(12, ((Y0 >> 1) << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(13, (Y0 << 16) | ((surfaceWidth + 1) >> 1));
        nvPushData(14, (Y0 << 18) | (((surfaceWidth << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF));

        nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_BEGIN_END | 0x40000);
        nvPushData(16, NV056_SET_BEGIN_END_OP_END);

        nvPusherAdjust(17);

        // Update reference count so we know when we can display this surface
        lpDstSurfaceFlags->dwMCFormatCnvReferenceCount = getDC()->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);

        nvPusherStart(TRUE);

        lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted |= 15;
    }

    nvPusherStart(TRUE);

    return DD_OK;

} /* nvMoCompCompositeNV12Subpicture */

#endif


/*
 * nvMoCompDisplaySurface
 *
 * Displays the current destination FOURCC_NV12 overlay surface
 *
 * Note that pDriverData must be set before calling this function.
 *
 */
DWORD __stdcall nvMoCompDisplaySurface(LPVOID lpInputData, DWORD dwSurfaceIndex)
{
    LPNVMCDISPLAYOVERLAYDATA    lpNvMCDisplayOverlayData = (LPNVMCDISPLAYOVERLAYDATA)lpInputData;
    NvNotification              *pPioFlipOverlayNotifier;
    HRESULT                     ddrval;
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl;
#ifndef WINNT
    DWORD                       dwSavedNBData;
#endif
    DWORD                       dwVPPFlags;
    LPNVMCSURFACEFLAGS          lpSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];
    unsigned long               returnVal;

    dbgTracePush ("nvMoCompDisplaySurface");

    DDSTARTTICK(SURF4_FLIP);
    DDFLIPTICKS(FEFLIP);

    pPioFlipOverlayNotifier = pDriverData->pPioFlipOverlayNotifierFlat;

    if (dwSurfaceIndex >= 8) {
        DDENDTICK(SURF4_FLIP);
        dbgTracePop();
        return (DDERR_INVALIDPARAMS);
    }

    pSurf = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNV12Surface[dwSurfaceIndex];

    if (pSurf == 0) {
        DDENDTICK(SURF4_FLIP);
        dbgTracePop();
        return (DDERR_NOTFOUND);
    }

    pDriverData->dwMCDestinationSurface = (DWORD)pSurf;
    pSurf_gbl = pSurf->lpGbl;

    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        DDENDTICK(SURF4_FLIP);
        dbgTracePop();
        return (DDERR_SURFACELOST);
    }

    // If UpdateOverlay hasn't been called yet then just return success
    if (GET_HALINFO()->ddCaps.dwCurrVisibleOverlays == 0) {
        DDENDTICK(SURF4_FLIP);
        dbgTracePop();
        return DD_OK;
    }

    if ((pDriverData->bMCOverlaySrcIsSingleField1080i) &&
        (lpNvMCDisplayOverlayData->dwMCFlipFlags & DDFLIP_ODD)) {
        DDENDTICK(SURF4_FLIP);
        dbgTracePop();
        return DD_OK;
    }

    while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
           (lpSurfaceFlags->dwMCSurfaceBase != pSurf_gbl->fpVidMem))
        lpSurfaceFlags++;

    // Make sure the surface has been format converted
    if ((lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) &&
        (lpSurfaceFlags->bMCFrameAlreadyFormatConverted < 15))
        nvMoCompConvertSurfaceFormat(pSurf_gbl->fpVidMem, TRUE, 15);
    else if ((lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD) &&
        ((lpSurfaceFlags->bMCFrameAlreadyFormatConverted & 3) < 3))
        nvMoCompConvertSurfaceFormat(pSurf_gbl->fpVidMem, TRUE, 3);
    else if ((lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_BOTTOM_FIELD) &&
        (lpSurfaceFlags->bMCFrameAlreadyFormatConverted < 12))
        nvMoCompConvertSurfaceFormat(pSurf_gbl->fpVidMem, TRUE, 12);

    // Has this surface finished format conversion yet ?
    if (!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                   lpSurfaceFlags->dwMCFormatCnvReferenceCount,
                                   1)) {
        DDENDTICK(SURF4_FLIP);
        dbgTracePop();
        return (DDERR_WASSTILLDRAWING);
    }

    // If this is a composited surface, is it done compositing yet ?
    if (lpSurfaceFlags->bMCFrameIsComposited) {
        if (!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                       lpSurfaceFlags->dwMCCompositeReferenceCount,
                                       1)) {
            DDENDTICK(SURF4_FLIP);
            dbgTracePop();
            return (DDERR_WASSTILLDRAWING);
        }
    }

    // If this is a filtered surface, is it done filtering yet ?
    if (lpSurfaceFlags->bMCFrameIsFiltered) {
        if (!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                       lpSurfaceFlags->dwMCTemporalFilterReferenceCount,
                                       1)) {
            DDENDTICK(SURF4_FLIP);
            dbgTracePop();
            return (DDERR_WASSTILLDRAWING);
        }
    }

    // Check if filtering is disabled on this surface for this display call only
    if (lpSurfaceFlags->bMCFrameType & TEMPORAL_FILTER_DISABLE_ON_SINGLE_SURFACE) {
        lpSurfaceFlags->bMCFrameIsFiltered = FALSE;
        lpSurfaceFlags->bMCFrameType &= ~TEMPORAL_FILTER_DISABLE_ON_SINGLE_SURFACE;
    }

    // Always display non-filtered portion of non-interleaved frames
    if ((lpNvMCDisplayOverlayData->dwMCFlipFlags & (DDFLIP_ODD | DDFLIP_EVEN)) == 0) {
        if (lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_FRAME)
            lpSurfaceFlags->bMCFrameIsFiltered = FALSE;
    }

    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        DDENDTICK(SURF4_FLIP);
        dbgTracePop();
        return (DDERR_SURFACELOST);
    }

    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_DDRAW) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvDDrawRecover();
        }
        else {
            DDENDTICK(SURF4_FLIP);
            dbgTracePop();
            return (DDERR_SURFACELOST);
        }
    }

#ifndef WINNT
    // check for VIA 82C598 north bridge
    if (IS_VIA_MVP3_NB_ID(pDriverData->northBridgeID)) {
        // turn off write posting
        _asm {
                mov edx, 0cf8h
                mov eax, 80000840h
                out dx, eax
                mov edx, 0cfch
                mov eax, 0
                in  al, dx
                mov dwSavedNBData, eax
                and eax, 0FFFFFF7Fh
                out dx, al
        }
    }
#endif

    /* Limit flips to 1 at a time to work around NV4 RM limitation */
    ddrval = nvMoCompFrameStatus (pSurf_gbl->fpVidMem);

    /* Only reject flip requests when flipping frames (but allow fields to proceed) */
    if ((lpNvMCDisplayOverlayData->dwMCFlipFlags & (DDFLIP_ODD | DDFLIP_EVEN)) == 0) {
        if (ddrval != DD_OK) {
            if (lpNvMCDisplayOverlayData->dwMCFlipFlags & DDFLIP_WAIT) {
                while (ddrval != DD_OK) {
                    ddrval = nvMoCompFrameStatus (pSurf_gbl->fpVidMem);
                    if (ddrval != DD_OK) {
                        NV_SLEEPFLIP;
                    }
                }
            }
            else {
#ifndef WINNT
                // check for VIA 82C598 north bridge
                if (IS_VIA_MVP3_NB_ID(pDriverData->northBridgeID)) {
                    // restore write posting value
                    _asm {
                            mov edx, 0cf8h
                            mov eax, 80000840h
                            out dx, eax
                            mov edx, 0cfch
                            mov eax, dwSavedNBData
                            out dx, al
                    }
                }
#endif
                DDENDTICK(SURF4_FLIP);
                dbgTracePop();
                return (DDERR_WASSTILLDRAWING);
            }
        }
    } else {
        if (ddrval != DD_OK) {
            NV_SLEEPFLIP;
            DDENDTICK(SURF4_FLIP);
            dbgTracePop();
            return (DDERR_WASSTILLDRAWING);
        }
    }

    /*
     * make sure we sync with other channels before writing put
     */
    getDC()->nvPusher.setSyncChannelFlag();

    getDC()->flipOverlayRecord.llPreviousFlipTime = getDC()->flipOverlayRecord.llFlipTime;
    QueryPerformanceCounter((LARGE_INTEGER *) &getDC()->flipOverlayRecord.llFlipTime);
    getDC()->flipOverlayRecord.fpPreviousFlipFrom = getDC()->flipOverlayRecord.fpFlipFrom;
    getDC()->flipOverlayRecord.fpFlipFrom = getDC()->flipOverlayRecord.fpFlipTo;
    getDC()->flipOverlayRecord.fpFlipTo = pSurf_gbl->fpVidMem;

    getDC()->flipOverlayRecord.bFlipFlag = TRUE;

//    dwVPPFlags = VPP_OPTIMIZE | VPP_PRESCALE; // only when rescaling already visible surface
    dwVPPFlags = VPP_MOCOMP;
    if (lpNvMCDisplayOverlayData->dwMCOverlayFlags & DDOVER_INTERLEAVED) {
        dwVPPFlags |= VPP_INTERLEAVED;
    }
    if (lpNvMCDisplayOverlayData->dwMCOverlayFlags & DDOVER_BOB) {
        dwVPPFlags |= VPP_BOB;
    }
    if (lpNvMCDisplayOverlayData->dwMCFlipFlags & DDFLIP_ODD) {
        dwVPPFlags |= VPP_ODD;
    } else if (lpNvMCDisplayOverlayData->dwMCFlipFlags & DDFLIP_EVEN) {
        dwVPPFlags |= VPP_EVEN;
    }

    returnVal = VppDoFlip(&(pDriverData->vpp),
                          VIDMEM_OFFSET(pSurf_gbl->fpVidMem),
                          pSurf_gbl->lPitch,
                          pSurf_gbl->wWidth,
                          pSurf_gbl->wHeight,
                          pSurf_gbl->ddpfSurface.dwFourCC,
                          dwVPPFlags);

#ifndef WINNT
    // check for VIA 82C598 north bridge
    if (IS_VIA_MVP3_NB_ID(pDriverData->northBridgeID)) {
        // restore write posting value
        _asm {
                mov edx, 0cf8h
                mov eax, 80000840h
                out dx, eax
                mov edx, 0cfch
                mov eax, dwSavedNBData
                out dx, al
        }
    }
#endif

    DDENDTICK(SURF4_FLIP);
    dbgTracePop();
    return (returnVal ? DD_OK : DDERR_WASSTILLDRAWING);

} /* nvMoCompDisplaySurface */


/*
 * nvGetMoCompGuids
 *
 * Returns our motion comp GUID
 *
 */
DWORD __stdcall nvGetMoCompGuids( LPDDHAL_GETMOCOMPGUIDSDATA lpGMCGData)
{
    nvSetDriverDataPtrFromDDGbl(lpGMCGData->lpDD->lpGbl);

    if (pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) {
        lpGMCGData->ddRVal = DDERR_UNSUPPORTED;
        NvReleaseSemaphore(pDriverData);
        return (DDHAL_DRIVER_HANDLED);
    }

    lpGMCGData->dwNumGuids = 4;

    // Return DX VA Guids for MPEG2 Type A and B restricted profiles.
    if (lpGMCGData->lpGuids != NULL) {
        memcpy(lpGMCGData->lpGuids,     (GUID *)&DXVA_ModeMPEG2_A, sizeof(GUID));
        memcpy(lpGMCGData->lpGuids + 1, (GUID *)&DXVA_ModeMPEG2_B, sizeof(GUID));
        memcpy(lpGMCGData->lpGuids + 2, (GUID *)&DXVA_ModeMPEG2_C, sizeof(GUID));
        memcpy(lpGMCGData->lpGuids + 3, (GUID *)&DXVA_ModeMPEG2_D, sizeof(GUID));
    }

    NvReleaseSemaphore(pDriverData);
    lpGMCGData->ddRVal = DD_OK;

    return (DDHAL_DRIVER_HANDLED);

} /* nvGetMoCompGuids */



/*
 * nvGetMoCompFormats
 *
 * Returns our motion comp uncompressed surface format
 *
 */
DWORD __stdcall nvGetMoCompFormats( LPDDHAL_GETMOCOMPFORMATSDATA lpGMCFData)
{
    nvSetDriverDataPtrFromDDGbl(lpGMCFData->lpDD->lpGbl);

    // Assume we will succeed
    lpGMCFData->ddRVal = DD_OK;

    // If either MPEG2 A, B, C, or D guid is provided, return the
    // uncompressed overlay format we support.
    if (IsEqualIID_C(*(lpGMCFData->lpGuid), DXVA_ModeMPEG2_A) ||
        IsEqualIID_C(*(lpGMCFData->lpGuid), DXVA_ModeMPEG2_B) ||
        IsEqualIID_C(*(lpGMCFData->lpGuid), DXVA_ModeMPEG2_C) ||
        IsEqualIID_C(*(lpGMCFData->lpGuid), DXVA_ModeMPEG2_D)) {
        lpGMCFData->dwNumFormats = 1;

        if (lpGMCFData->lpFormats != NULL) {
            lpGMCFData->lpFormats[0].dwFlags = DDPF_FOURCC;
            lpGMCFData->lpFormats[0].dwFourCC = FOURCC_NV12;
            lpGMCFData->lpFormats[0].dwYUVBitCount = 12;
            lpGMCFData->lpFormats[0].dwYBitMask = 0;
            lpGMCFData->lpFormats[0].dwUBitMask = 0;
            lpGMCFData->lpFormats[0].dwVBitMask = 0;
            lpGMCFData->lpFormats[0].dwYUVAlphaBitMask = 0;
        }

    } else {
        lpGMCFData->ddRVal = DDERR_UNSUPPORTEDFORMAT;
    }

    NvReleaseSemaphore(pDriverData);
    return (DDHAL_DRIVER_HANDLED);

} /* nvGetMoCompFormats */


/*
 * nvCreateMoComp
 *
 * Returns whether we can support a motion comp uncompressed surface of
 * the requested format and size
 *
 */
DWORD __stdcall nvCreateMoComp( LPDDHAL_CREATEMOCOMPDATA lpCMCData)
{
    BYTE                        bIndex;
    LPDXVA_ConnectMode          lpConnectMode;
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    LPNVMCFRAMEDATA             lpNvMCFrameData;

    nvSetDriverDataPtrFromDDGbl(lpCMCData->lpDD->lpGbl);

    // Assume we will succeed
    lpCMCData->ddRVal = DD_OK;

    if (pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) {
        lpCMCData->ddRVal = DDERR_UNSUPPORTED;
    } else {
        if (IsEqualIID_C(*(lpCMCData->lpGuid), DXVA_ModeMPEG2_A) ||
            IsEqualIID_C(*(lpCMCData->lpGuid), DXVA_ModeMPEG2_B) ||
            IsEqualIID_C(*(lpCMCData->lpGuid), DXVA_ModeMPEG2_C) ||
            IsEqualIID_C(*(lpCMCData->lpGuid), DXVA_ModeMPEG2_D)) {

            if (lpCMCData->ddUncompPixelFormat.dwFourCC == FOURCC_NV12) {
                // Maximum NV10 motion comp texture width/height is 2046
                if (lpCMCData->dwUncompWidth > 2046)
                    lpCMCData->ddRVal = DDERR_TOOBIGWIDTH;

                if (lpCMCData->dwUncompHeight > 2046)
                    lpCMCData->ddRVal = DDERR_TOOBIGHEIGHT;
            } else {
                lpCMCData->ddRVal = DDERR_UNSUPPORTEDFORMAT;
            }
        } else {
            lpCMCData->ddRVal = DDERR_UNSUPPORTEDFORMAT;
        }
    }

    // Check connect mode data and make sure it matches what we want.
    lpConnectMode = (LPDXVA_ConnectMode)lpCMCData->lpData;

    if (IsEqualIID_C(*(lpCMCData->lpGuid), DXVA_ModeMPEG2_A)) {
        if ((lpConnectMode->guidMode        != DXVA_ModeMPEG2_A) ||
            (lpConnectMode->wRestrictedMode != DXVA_RESTRICTED_MODE_MPEG2_A))
            lpCMCData->ddRVal = DDERR_UNSUPPORTEDFORMAT;
    }
    else if (IsEqualIID_C(*(lpCMCData->lpGuid), DXVA_ModeMPEG2_B)) {
        if ((lpConnectMode->guidMode        != DXVA_ModeMPEG2_B) ||
            (lpConnectMode->wRestrictedMode != DXVA_RESTRICTED_MODE_MPEG2_B))
            lpCMCData->ddRVal = DDERR_UNSUPPORTEDFORMAT;
    }
    else if (IsEqualIID_C(*(lpCMCData->lpGuid), DXVA_ModeMPEG2_C)) {
        if ((lpConnectMode->guidMode        != DXVA_ModeMPEG2_C) ||
            (lpConnectMode->wRestrictedMode != DXVA_RESTRICTED_MODE_MPEG2_C))
            lpCMCData->ddRVal = DDERR_UNSUPPORTEDFORMAT;
    }
    else if (IsEqualIID_C(*(lpCMCData->lpGuid), DXVA_ModeMPEG2_D)) {
        if ((lpConnectMode->guidMode        != DXVA_ModeMPEG2_D) ||
            (lpConnectMode->wRestrictedMode != DXVA_RESTRICTED_MODE_MPEG2_D))
            lpCMCData->ddRVal = DDERR_UNSUPPORTEDFORMAT;
    }

    // If everything's okay, allocate a system memory buffer for
    // processing Macroblock control headers in Render.
    if (lpCMCData->ddRVal == DD_OK)
        pDriverData->dwDXVAConvertBuffer = (DWORD)GlobalAlloc(GMEM_FIXED, CONVERT_BUFFER_SIZE);

    // Initialize some things in pDriverData.
    pDriverData->dwDXVAFlags |= DXVA_MO_COMP_IN_PROGRESS;

    if (pDriverData->vpp.regOverlayMode3 & NV4_REG_OVL_MODE3_DXVA_BACK_END_ALPHA_PREFERRED) {
        pDriverData->dwDXVAFlags |= DXVA_BACK_END_ALPHA_SELECTED;
    } else {
        pDriverData->dwDXVAFlags &= ~DXVA_BACK_END_ALPHA_SELECTED;
    }

    // Initialize some things in our NVMC surface.
    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVMCSurface;
    lpNvMCFrameData = (LPNVMCFRAMEDATA)VIDMEM_ADDR(pSurf_lcl->lpGbl->fpVidMem);
    lpNvMCFrameData->dwDXVASubpicBuffer = 0;
    lpNvMCFrameData->dwDXVASubpicStride = 0;

    // In case the decoder doesn't call BeginFrame for a surface before using the
    // surface, we try to initialize our surface index arrays to reasonable values.
    // These should be overrwritten by BeginFrame later.
    for (bIndex = 0; bIndex < 8; bIndex++) {
        if (pDriverData->dwMCNV12Surface[bIndex]) {
            pDriverData->bDXVAIndexToNVIndex[bIndex] = bIndex;
            pDriverData->dwDXVAIndexToVidMem[bIndex] =
                ((LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNV12Surface[bIndex])->lpGbl->fpVidMem;
        }
        else {
            pDriverData->bDXVAIndexToNVIndex[bIndex] = 0;
            pDriverData->dwDXVAIndexToVidMem[bIndex] = 0;
        }
    }

    NvReleaseSemaphore(pDriverData);
    return (DDHAL_DRIVER_HANDLED);

} /* nvCreateMoComp */


/*
 * nvGetMoCompBuffInfo
 *
 * Returns our required motion comp buffer info
 *
 */
DWORD __stdcall nvGetMoCompBuffInfo( LPDDHAL_GETMOCOMPCOMPBUFFDATA lpGMCBData)
{
    nvSetDriverDataPtrFromDDGbl(lpGMCBData->lpDD->lpGbl);

    // Assume we will succeed
    lpGMCBData->ddRVal = DD_OK;

    if (IsEqualIID_C(*(lpGMCBData->lpGuid), DXVA_ModeMPEG2_A) ||
        IsEqualIID_C(*(lpGMCBData->lpGuid), DXVA_ModeMPEG2_B) ||
        IsEqualIID_C(*(lpGMCBData->lpGuid), DXVA_ModeMPEG2_C) ||
        IsEqualIID_C(*(lpGMCBData->lpGuid), DXVA_ModeMPEG2_D)) {
        if (lpGMCBData->ddPixelFormat.dwFourCC == FOURCC_NV12) {
            if (lpGMCBData->lpCompBuffInfo == NULL) {
                lpGMCBData->dwNumTypesCompBuffs = 16;
            }
            else if (lpGMCBData->dwNumTypesCompBuffs < 16) {
                lpGMCBData->ddRVal = DDERR_UNSUPPORTEDFORMAT;
            }
            else {

                DWORD   dwPadWidth, dwPadHeight;
                DWORD   dwFlags, dwRGBBitCount, dwBytesPerPixel;
                DWORD   dwRBitMask, dwGBitMask, dwBBitMask;
                DWORD   dwScreenWidth;

                // We always fill in exactly 16 buffers structures for DXVA.
                lpGMCBData->dwNumTypesCompBuffs = 16;

                // Calculate RGB parameters for the first two types of surfaces.
                dwScreenWidth = GET_MODE_WIDTH();
                dwRGBBitCount = GET_MODE_BPP();
                dwBytesPerPixel = dwRGBBitCount / 8;
                switch (dwRGBBitCount)
                {
                case 8:
                    dwFlags = DDPF_RGB | DDPF_PALETTEINDEXED8;
                    dwRBitMask = dwGBitMask = dwBBitMask = 0;
                    break;

                case 16:
                    dwFlags = DDPF_RGB;
                    dwRBitMask = 0xf800;
                    dwGBitMask = 0x07e0;
                    dwBBitMask = 0x001f;
                    break;

                case 32:
                    dwFlags = DDPF_RGB;
                    dwRBitMask = 0x00ff0000;
                    dwGBitMask = 0x0000ff00;
                    dwBBitMask = 0x000000ff;
                    break;
                }

                // Initialize unused CompBuffInfo structure members to zero.
                memset(lpGMCBData->lpCompBuffInfo, 0, 16 * sizeof(DDMCBUFFERINFO));

                // The #0 CompBuffInfo structure isn't used by DXVA.
                // We'll use it to create an NVMC surface to assist our motion comp decoding.
                // The width and height are ignored by our driver.  Creating this surface
                // causes our CreateSurface32 function to initialize certain index arrays
                // related to the NV12 and NVID surfaces.
                lpGMCBData->lpCompBuffInfo[0].dwNumCompBuffers = 1;
                lpGMCBData->lpCompBuffInfo[0].dwWidthToCreate = 16;
                lpGMCBData->lpCompBuffInfo[0].dwHeightToCreate = 16;
                lpGMCBData->lpCompBuffInfo[0].dwBytesToAllocate = 256;
                lpGMCBData->lpCompBuffInfo[0].ddCompCaps.dwCaps = DDSCAPS_VIDEOMEMORY |
                                                                   DDSCAPS_LOCALVIDMEM |
                                                                   DDSCAPS_OVERLAY;
                lpGMCBData->lpCompBuffInfo[0].ddPixelFormat.dwFlags = DDPF_FOURCC;
                lpGMCBData->lpCompBuffInfo[0].ddPixelFormat.dwFourCC = FOURCC_NVMC;
                lpGMCBData->lpCompBuffInfo[0].ddPixelFormat.dwYUVBitCount = 16;

                // The #1 CompBuffInfo structure must be for a picture parameter buffer,
                // large enough to hold a DXVA_PictureParameters structure.  Here we create
                // it as an RGB surface, but the exact format doesn't matter.  We put it in
                // local video memory so Lock32 will wait until all previous decoding is done.
                dwPadWidth = (sizeof(DXVA_PictureParameters) + 7) & 0xFFFFFFF8L;
                dwPadHeight = 1;
                lpGMCBData->lpCompBuffInfo[1].dwNumCompBuffers = 1;
                lpGMCBData->lpCompBuffInfo[1].dwWidthToCreate = dwPadWidth / dwBytesPerPixel;
                lpGMCBData->lpCompBuffInfo[1].dwHeightToCreate = dwPadHeight;
                lpGMCBData->lpCompBuffInfo[1].dwBytesToAllocate = dwPadWidth * dwPadHeight;
                lpGMCBData->lpCompBuffInfo[1].ddCompCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN |
                                                                  DDSCAPS_SYSTEMMEMORY;
                lpGMCBData->lpCompBuffInfo[1].ddPixelFormat.dwFlags = dwFlags;
                lpGMCBData->lpCompBuffInfo[1].ddPixelFormat.dwFourCC = 0;
                lpGMCBData->lpCompBuffInfo[1].ddPixelFormat.dwRGBBitCount = dwRGBBitCount;
                lpGMCBData->lpCompBuffInfo[1].ddPixelFormat.dwRBitMask = dwRBitMask;
                lpGMCBData->lpCompBuffInfo[1].ddPixelFormat.dwGBitMask = dwGBitMask;
                lpGMCBData->lpCompBuffInfo[1].ddPixelFormat.dwBBitMask = dwBBitMask;
                lpGMCBData->lpCompBuffInfo[1].ddPixelFormat.dwRGBAlphaBitMask = 0;

                // The #2 CompBuffInfo structure must be for a macroblock control command buffer.
                // We want three of these, to match the three NVID buffers requested below.
                // Again we create them as RGB buffers but they're just a plain memory buffers.
                dwPadWidth = 1800;                                      // Enough for PAL DVD frame, plus padding.
                dwPadHeight = sizeof(DXVA_MBctrl_P_HostResidDiff_1);    // Max size of each macroblock structure.
                lpGMCBData->lpCompBuffInfo[2].dwNumCompBuffers = 3;
                lpGMCBData->lpCompBuffInfo[2].dwWidthToCreate = dwPadWidth / dwBytesPerPixel;
                lpGMCBData->lpCompBuffInfo[2].dwHeightToCreate = dwPadHeight;
                lpGMCBData->lpCompBuffInfo[2].dwBytesToAllocate = dwPadWidth * dwPadHeight;
                lpGMCBData->lpCompBuffInfo[2].ddCompCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN |
                                                                  DDSCAPS_SYSTEMMEMORY;
                lpGMCBData->lpCompBuffInfo[2].ddPixelFormat.dwFlags = dwFlags;
                lpGMCBData->lpCompBuffInfo[2].ddPixelFormat.dwFourCC = 0;
                lpGMCBData->lpCompBuffInfo[2].ddPixelFormat.dwRGBBitCount = dwRGBBitCount;
                lpGMCBData->lpCompBuffInfo[2].ddPixelFormat.dwRBitMask = dwRBitMask;
                lpGMCBData->lpCompBuffInfo[2].ddPixelFormat.dwGBitMask = dwGBitMask;
                lpGMCBData->lpCompBuffInfo[2].ddPixelFormat.dwBBitMask = dwBBitMask;
                lpGMCBData->lpCompBuffInfo[2].ddPixelFormat.dwRGBAlphaBitMask = 0;

                // The #3 CompBuffInfo structure must be for a residual difference buffer,
                // to hold host-based IDCT data.  They're allocated in local video memory.
                // If frame buffer is 32MB or greater, we want 3 buffers 1MB each, unless
                // TwinView is enabled, then only use 2 to leave room for Video Mirror.
                if (pDriverData->TotalVRAM >= 0x2000000) {

                    if ((pDriverData->dwDesktopState == NVTWINVIEW_STATE_DUALVIEW) ||
                        (pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE)) {

                        lpGMCBData->lpCompBuffInfo[3].dwNumCompBuffers = 2;
                        lpGMCBData->lpCompBuffInfo[3].dwWidthToCreate = 1024;
                        lpGMCBData->lpCompBuffInfo[3].dwHeightToCreate = 1024;
                        lpGMCBData->lpCompBuffInfo[3].dwBytesToAllocate = 1024L * 1024L;
                    }
                    else {
                        lpGMCBData->lpCompBuffInfo[3].dwNumCompBuffers = 3;
                        lpGMCBData->lpCompBuffInfo[3].dwWidthToCreate = 1024;
                        lpGMCBData->lpCompBuffInfo[3].dwHeightToCreate = 1024;
                        lpGMCBData->lpCompBuffInfo[3].dwBytesToAllocate = 1024L * 1024L;
                    }
                }

                // Else for 16MB NTSC-size DVD playback...
                else if (lpGMCBData->dwHeight <= 480) {

                    // For the special case of TwinView 1024x768x32, we allocate
                    // the minimum amount to allow Video Mirror to work OK.
                    if (((pDriverData->dwDesktopState == NVTWINVIEW_STATE_DUALVIEW) ||
                        (pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE)) &&
                        (dwScreenWidth == 1024) && (dwRGBBitCount == 32)) {

                        lpGMCBData->lpCompBuffInfo[3].dwNumCompBuffers = 1;
                        lpGMCBData->lpCompBuffInfo[3].dwWidthToCreate = 1024;
                        lpGMCBData->lpCompBuffInfo[3].dwHeightToCreate = 600;
                        lpGMCBData->lpCompBuffInfo[3].dwBytesToAllocate = 1024L * 600L;
                    }
                    else  if (dwScreenWidth == 800){
                        //DCT test mode.  DCT requires at least 6 NV12 surfaces
                        // allocate less memory for NVID surfaces.
                        lpGMCBData->lpCompBuffInfo[3].dwNumCompBuffers = 3;
                        lpGMCBData->lpCompBuffInfo[3].dwWidthToCreate = 1024;
                        lpGMCBData->lpCompBuffInfo[3].dwHeightToCreate = 600;
                        lpGMCBData->lpCompBuffInfo[3].dwBytesToAllocate = 3L*1024L * 600L;

                    }
                    else {
                        DWORD dwTotalMem, dwFreeMem, dwNumBuffer, dwBufferHeight,dwBufferWidth;
                        //FOURCC_NVSP surface 
                        dwTotalMem =(768 * 576 * 2) + (768 * 576 * 4) + 1024 +(768 * 576 * 2);
                        //add  4 NV12 and one extra (size based on Steven's DXVA Memory Layout SpreadSheets)
                        dwTotalMem += 1296640 * 5;
                        //buffer width
                        dwBufferWidth = 512;
                        if(pDriverData->VideoHeapFree >(int)dwTotalMem)
                        {
                            // Find out total free memory
                            dwFreeMem = pDriverData->VideoHeapFree - dwTotalMem;
                            //choose 512X2048 first
                            dwBufferHeight = 2048;
                            dwNumBuffer = dwFreeMem / (dwBufferWidth * dwBufferHeight);
                            if( dwNumBuffer < 2)
                            {
                                 dwNumBuffer = 2;                        //may be no memory to support DXVA
                                 dwBufferHeight = 1200;
                            }
                            else if(dwNumBuffer > 3)
                            {
                                //increas buffer size
                                dwNumBuffer = 3;
                                dwBufferHeight = dwFreeMem / ( dwBufferWidth * 3);
                                if(dwBufferHeight > 6144 )
                                    dwBufferHeight = 6144;
                                else
                                    dwBufferHeight &= ~511;

                            }

                        }
                        else
                        {
                            dwNumBuffer = 2;                        //no memory to support DXVA
                            dwBufferHeight = 1200;
                        }

                        lpGMCBData->lpCompBuffInfo[3].dwNumCompBuffers  = dwNumBuffer;
                        lpGMCBData->lpCompBuffInfo[3].dwWidthToCreate	= dwBufferWidth;
                        lpGMCBData->lpCompBuffInfo[3].dwHeightToCreate	= dwBufferHeight;
                        lpGMCBData->lpCompBuffInfo[3].dwBytesToAllocate = dwBufferWidth * dwBufferHeight * dwNumBuffer;
                    }		
                }
                // Else for 16MB PAL-size DVD playback, do the same thing but with
                // PAL-size buffers.
                else {
                    lpGMCBData->lpCompBuffInfo[3].dwNumCompBuffers = 2;
                    lpGMCBData->lpCompBuffInfo[3].dwWidthToCreate = 1024;
                    lpGMCBData->lpCompBuffInfo[3].dwHeightToCreate = 700;
                    lpGMCBData->lpCompBuffInfo[3].dwBytesToAllocate = 1024L * 700L;
                }

                lpGMCBData->lpCompBuffInfo[3].ddCompCaps.dwCaps = DDSCAPS_VIDEOMEMORY;
                lpGMCBData->lpCompBuffInfo[3].ddPixelFormat.dwFlags = DDPF_FOURCC;
                lpGMCBData->lpCompBuffInfo[3].ddPixelFormat.dwFourCC = FOURCC_NVID;
                lpGMCBData->lpCompBuffInfo[3].ddPixelFormat.dwYUVBitCount = 8;
                lpGMCBData->lpCompBuffInfo[3].ddPixelFormat.dwYBitMask = 0;
                lpGMCBData->lpCompBuffInfo[3].ddPixelFormat.dwUBitMask = 0;
                lpGMCBData->lpCompBuffInfo[3].ddPixelFormat.dwVBitMask = 0;
                lpGMCBData->lpCompBuffInfo[3].ddPixelFormat.dwYUVAlphaBitMask = 0;

                // The #4 CompBuffInfo structure must be for a Deblocking Filter Control buffer.
                // We don't use this one.

                // The #5 CompBuffInfo structure must be for a Inverse Quantization Matrix buffer.
                // We don't use this one.

                // The #6 CompBuffInfo structure must be for a Slice Control buffer.
                // We don't use this one.

                // The #7 CompBuffInfo structure must be for a Bitstream Data buffer.
                // We don't use this one.

                // The #8 CompBuffInfo structure must be for a YUV Palette buffer.
                // We can put this one in system memory.
                dwPadWidth = 64;
                lpGMCBData->lpCompBuffInfo[8].dwNumCompBuffers = 2;
                lpGMCBData->lpCompBuffInfo[8].dwWidthToCreate = dwPadWidth / dwBytesPerPixel;
                lpGMCBData->lpCompBuffInfo[8].dwHeightToCreate = 1;
                lpGMCBData->lpCompBuffInfo[8].dwBytesToAllocate = dwPadWidth;
                lpGMCBData->lpCompBuffInfo[8].ddCompCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN |
                                                                  DDSCAPS_SYSTEMMEMORY;
                lpGMCBData->lpCompBuffInfo[8].ddPixelFormat.dwFlags = dwFlags;
                lpGMCBData->lpCompBuffInfo[8].ddPixelFormat.dwFourCC = 0;
                lpGMCBData->lpCompBuffInfo[8].ddPixelFormat.dwRGBBitCount = dwRGBBitCount;
                lpGMCBData->lpCompBuffInfo[8].ddPixelFormat.dwRBitMask = dwRBitMask;
                lpGMCBData->lpCompBuffInfo[8].ddPixelFormat.dwGBitMask = dwGBitMask;
                lpGMCBData->lpCompBuffInfo[8].ddPixelFormat.dwBBitMask = dwBBitMask;
                lpGMCBData->lpCompBuffInfo[8].ddPixelFormat.dwRGBAlphaBitMask = 0;

                // The #9 CompBuffInfo structure must be for an IA44 Alpha Blending buffer.
                // We can put this one in system memory.  Always make it 720x576, since
                // subpicture size may be independent of DVD video size.
                dwPadWidth  = 720;
                dwPadHeight = 576;
                lpGMCBData->lpCompBuffInfo[9].dwNumCompBuffers = 2;
                lpGMCBData->lpCompBuffInfo[9].dwWidthToCreate = dwPadWidth / dwBytesPerPixel;
                lpGMCBData->lpCompBuffInfo[9].dwHeightToCreate = dwPadHeight;
                lpGMCBData->lpCompBuffInfo[9].dwBytesToAllocate = dwPadWidth * dwPadHeight;
                lpGMCBData->lpCompBuffInfo[9].ddCompCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN |
                                                                  DDSCAPS_SYSTEMMEMORY;
                lpGMCBData->lpCompBuffInfo[9].ddPixelFormat.dwFlags = dwFlags;
                lpGMCBData->lpCompBuffInfo[9].ddPixelFormat.dwFourCC = 0;
                lpGMCBData->lpCompBuffInfo[9].ddPixelFormat.dwRGBBitCount = dwRGBBitCount;
                lpGMCBData->lpCompBuffInfo[9].ddPixelFormat.dwRBitMask = dwRBitMask;
                lpGMCBData->lpCompBuffInfo[9].ddPixelFormat.dwGBitMask = dwGBitMask;
                lpGMCBData->lpCompBuffInfo[9].ddPixelFormat.dwBBitMask = dwBBitMask;
                lpGMCBData->lpCompBuffInfo[9].ddPixelFormat.dwRGBAlphaBitMask = 0;

                // The #10 CompBuffInfo structure is for a DPXD Alpha Blending buffer.
                // We don't support DPXD, but we'll use this structure to create a
                // private NVSP surface that we need for subpicture blending.
                // The NVSP surface contains the following buffers:
                //   720x576x2  Compressed subpicture (currently not used for DXVA)
                //   720x576x4  Uncompressed subpicture in YUV32 format
                //   256x4      Lookup table buffer (currently no used for DXVA)
                //   720x576x2  Mixer buffer for subpicture blending
                // Note that the 720 width is padded to a 768 stride for dwBytesToAllocate.
                lpGMCBData->lpCompBuffInfo[10].dwNumCompBuffers = 1;
                lpGMCBData->lpCompBuffInfo[10].dwWidthToCreate = 720;
                lpGMCBData->lpCompBuffInfo[10].dwHeightToCreate = 576;
                lpGMCBData->lpCompBuffInfo[10].dwBytesToAllocate = (768L * 576 * 2) +
                                                                   (768L * 576 * 4) +
                                                                   1024L +
                                                                   (768L * 576 * 2);
                lpGMCBData->lpCompBuffInfo[10].ddCompCaps.dwCaps = DDSCAPS_VIDEOMEMORY |
                                                                   DDSCAPS_LOCALVIDMEM;
                lpGMCBData->lpCompBuffInfo[10].ddPixelFormat.dwFlags = DDPF_FOURCC;
                lpGMCBData->lpCompBuffInfo[10].ddPixelFormat.dwFourCC = FOURCC_NVSP;
                lpGMCBData->lpCompBuffInfo[10].ddPixelFormat.dwRGBBitCount = 8;
                lpGMCBData->lpCompBuffInfo[10].ddPixelFormat.dwRBitMask = 0;
                lpGMCBData->lpCompBuffInfo[10].ddPixelFormat.dwGBitMask = 0;
                lpGMCBData->lpCompBuffInfo[10].ddPixelFormat.dwBBitMask = 0;
                lpGMCBData->lpCompBuffInfo[10].ddPixelFormat.dwRGBAlphaBitMask = 0;

                // The #11 CompBuffInfo structure must be for a Highlight Data buffer.
                // We don't use this one.

                // The #12 CompBuffInfo structure must be for a DCCMD Data buffer.
                // We don't use this one.

                // The #13 CompBuffInfo structure must be for an Alpha Blending Combination buffer.
                // We can put this one in system memory.
                dwPadWidth = (sizeof(DXVA_BlendCombination) + 7) & 0xFFFFFFF8L;
                lpGMCBData->lpCompBuffInfo[13].dwNumCompBuffers = 2;
                lpGMCBData->lpCompBuffInfo[13].dwWidthToCreate = dwPadWidth / dwBytesPerPixel;
                lpGMCBData->lpCompBuffInfo[13].dwHeightToCreate = 1;
                lpGMCBData->lpCompBuffInfo[13].dwBytesToAllocate = dwPadWidth;
                lpGMCBData->lpCompBuffInfo[13].ddCompCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN |
                                                                  DDSCAPS_SYSTEMMEMORY;
                lpGMCBData->lpCompBuffInfo[13].ddPixelFormat.dwFlags = dwFlags;
                lpGMCBData->lpCompBuffInfo[13].ddPixelFormat.dwFourCC = 0;
                lpGMCBData->lpCompBuffInfo[13].ddPixelFormat.dwRGBBitCount = dwRGBBitCount;
                lpGMCBData->lpCompBuffInfo[13].ddPixelFormat.dwRBitMask = dwRBitMask;
                lpGMCBData->lpCompBuffInfo[13].ddPixelFormat.dwGBitMask = dwGBitMask;
                lpGMCBData->lpCompBuffInfo[13].ddPixelFormat.dwBBitMask = dwBBitMask;
                lpGMCBData->lpCompBuffInfo[13].ddPixelFormat.dwRGBAlphaBitMask = 0;

                // The #14 CompBuffInfo structure must be for a Picture Resampling Control buffer.
                // We don't use this one.

                // The #15 CompBuffInfo structure must be for a Read-Back buffer.
                // We don't use this one.
            }
        } else {
            lpGMCBData->ddRVal = DDERR_UNSUPPORTEDFORMAT;
        }
    } else {
        lpGMCBData->ddRVal = DDERR_UNSUPPORTEDFORMAT;
    }

    NvReleaseSemaphore(pDriverData);
    return (DDHAL_DRIVER_HANDLED);

} /* nvGetMoCompBuffInfo */


/*
 * nvGetInternalMoCompInfo
 *
 * Returns our internal motion comp video memory requirements
 *
 */
DWORD __stdcall nvGetInternalMoCompInfo( LPDDHAL_GETINTERNALMOCOMPDATA lpGIMCData)
{
    nvSetDriverDataPtrFromDDGbl(lpGIMCData->lpDD->lpGbl);

    // Assume we will succeed
    lpGIMCData->ddRVal = DD_OK;

    if (IsEqualIID_C(*(lpGIMCData->lpGuid), DXVA_ModeMPEG2_A) ||
        IsEqualIID_C(*(lpGIMCData->lpGuid), DXVA_ModeMPEG2_B) ||
        IsEqualIID_C(*(lpGIMCData->lpGuid), DXVA_ModeMPEG2_C) ||
        IsEqualIID_C(*(lpGIMCData->lpGuid), DXVA_ModeMPEG2_D)) {
        if (lpGIMCData->ddPixelFormat.dwFourCC == FOURCC_NV12) {
            lpGIMCData->dwScratchMemAlloc = 0;
        } else {
            lpGIMCData->ddRVal = DDERR_UNSUPPORTEDFORMAT;
        }
    } else {
        lpGIMCData->ddRVal = DDERR_UNSUPPORTEDFORMAT;
    }

    NvReleaseSemaphore(pDriverData);
    return (DDHAL_DRIVER_HANDLED);

} /* nvGetInternalMoCompInfo */



/*
 * nvBeginMoCompFrame
 *
 * Prepares to perform motion compensation on a new frame
 *
 */
DWORD __stdcall nvBeginMoCompFrame( LPDDHAL_BEGINMOCOMPFRAMEDATA lpBMCFData)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    LPNVMCFRAMEDATA             lpNvMCFrameData;

    // Get pDriverData pointer.
    nvSetDriverDataPtrFromDDGbl(lpBMCFData->lpDD->lpGbl);

    // If the NVMC or NV12 surface has been destroyed, return Surface Lost error.
    if (!pDriverData->dwMCNVMCSurface    ||
        !pDriverData->dwMCNV12Surface[0] ||
        !lpBMCFData->lpDestSurface)
    {
        NvReleaseSemaphore(pDriverData);
        lpBMCFData->ddRVal = DDERR_SURFACELOST;
        return (DDHAL_DRIVER_HANDLED);
    }

    // Check to see if the destination surface is still being displayed by the overlay.
    // If so, return an error code to force the decoder to try again later.
    lpBMCFData->ddRVal = DD_OK;
    if ( getFlipStatusOverlay(lpBMCFData->lpDestSurface->lpGbl->fpVidMem) != DD_OK) {

        NvReleaseSemaphore(pDriverData);
        lpBMCFData->ddRVal = DDERR_WASSTILLDRAWING;
        return (DDHAL_DRIVER_HANDLED);
    }

    // In the DX-VA spec, decoders need to call BeginFrame at least
    // once for each uncompressed buffer they plan to use, to associate
    // a buffer index with the uncompressed buffer DDraw surface handle.
    // We need to record these assocations to use later in Render.
    if (lpBMCFData->dwInputDataSize >= 2) {
        WORD    wDXVAIndex;

        // Extract index from lpInputData.
        wDXVAIndex = *((LPWORD)(lpBMCFData->lpInputData));

        // Save corresponding fpVidMem in our array.
        pDriverData->dwDXVAIndexToVidMem[wDXVAIndex]
            = (DWORD)lpBMCFData->lpDestSurface->lpGbl->fpVidMem;
    }

    // Calculate a linear pointer to the NVMC surface created by DShow.
    // We use this surface to store the NVMCFRAMEDATA structure.
    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVMCSurface;
    lpNvMCFrameData = (LPNVMCFRAMEDATA)VIDMEM_ADDR(pSurf_lcl->lpGbl->fpVidMem);

    // Initialize some things for the new frame.
    lpNvMCFrameData->bMCEndOfPicture = FALSE;
    pDriverData->bMCNewFrame         = TRUE;

    NvReleaseSemaphore(pDriverData);
    lpBMCFData->ddRVal = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
} /* nvBeginMoCompFrame */


/*
 * nvEndMoCompFrame
 *
 * Finishes motion compensation on current frame.
 *
 */
DWORD __stdcall nvEndMoCompFrame( LPDDHAL_ENDMOCOMPFRAMEDATA lpEMCFData)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    LPNVMCFRAMEDATA             lpNvMCFrameData;
    LPNVMCSURFACEFLAGS          lpSurfaceFlags;

    // Get pDriverData pointer.
    nvSetDriverDataPtrFromDDGbl(lpEMCFData->lpDD->lpGbl);

    // If the NVMC or NV12 surface has been destroyed, return Surface Lost error.
    if (!pDriverData->dwMCNVMCSurface ||
        !pDriverData->dwMCNV12Surface[0])
    {
        NvReleaseSemaphore(pDriverData);
        lpEMCFData->ddRVal = DDERR_SURFACELOST;
        return (DDHAL_DRIVER_HANDLED);
    }

    // If EndFrame is beging called after some macroblocks have been
    // decoded, we need to finish up a few things.  (This might be skipped
    // if BeginFrame/EndFrame have been called around an Alpha Blend
    // operation.)
    if (pDriverData->dwDXVAFlags & DXVA_PICTURE_IN_PROGRESS) {
        // Calculate a linear pointer to the NVMC surface created by DShow.
        // We use this surface to store the NVMCFRAMEDATA structure.
        pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVMCSurface;
        lpNvMCFrameData = (LPNVMCFRAMEDATA)VIDMEM_ADDR(pSurf_lcl->lpGbl->fpVidMem);

        // If End of Picture flag wasn't already set by someone...
        // set End of Picture flag and make a call to Execute with no macroblocks
        // to finish up this frame.
        if (!lpNvMCFrameData->bMCEndOfPicture) {
            lpNvMCFrameData->bMCEndOfPicture = 1;
            nvMoCompExecute(lpNvMCFrameData->dwMCMultiMonID,
                            EXECUTE_NON_PREBIASED_MOTION_COMPENSATION,
                            (LPVOID)(pDriverData->dwDXVAConvertBuffer + MACROBLOCKS_OFFSET),
                            0,
                            0);
        }

        // Clean up.  Make sure surface has been format converted
        lpSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];
        while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
               (lpSurfaceFlags->dwMCSurfaceBase != pDriverData->dwMCMostRecentlyDecodedSurfaceBase)) {
            lpSurfaceFlags++;
        }
        if (lpSurfaceFlags->dwMCSurfaceBase != 0) {
            if ((lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) &&
                (lpSurfaceFlags->bMCFrameAlreadyFormatConverted < 15))
                nvMoCompConvertSurfaceFormat(lpSurfaceFlags->dwMCSurfaceBase, TRUE, 15);
            else if (lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD) {
                if ((lpSurfaceFlags->bMCFrameAlreadyFormatConverted & 3) < 3)
                    nvMoCompConvertSurfaceFormat(lpSurfaceFlags->dwMCSurfaceBase, TRUE, 3);
            } else if (lpSurfaceFlags->bMCPictureStructure == PICTURE_STRUCTURE_BOTTOM_FIELD) {
                if (lpSurfaceFlags->bMCFrameAlreadyFormatConverted < 12)
                    nvMoCompConvertSurfaceFormat(lpSurfaceFlags->dwMCSurfaceBase, TRUE, 12);
            }
            if ((lpSurfaceFlags->bMCFrameAlreadyFormatConverted == 15) &&
                (lpSurfaceFlags->bMCFrameIsFiltered == FALSE) &&
                (pDriverData->bMCTemporalFilterDisabled == FALSE))
                nvMoCompTemporalFilter(lpSurfaceFlags->dwMCSurfaceBase, pDriverData->bMCPercentCurrentField);
        }
    }

    // Reset flag to say this picture is done.
    pDriverData->dwDXVAFlags &= ~DXVA_PICTURE_IN_PROGRESS;

    lpEMCFData->ddRVal = DD_OK;
    NvReleaseSemaphore(pDriverData);
    return (DDHAL_DRIVER_HANDLED);
} /* nvEndMoCompFrame */


/*
 * nvRenderMoComp
 *
 * Performs motion compensation on a portion of a new frame.
 * Several buffers may be passed to this function at one time,
 * of the following types:
 *
 * 1 - Picture Parameter Buffer
 * 2 - Macroblock Control Command Buffer
 * 3 - Residual Difference Block Data Buffer (contains post-IDCT data)
 * 7 - DVD Subpicture Control Buffer
 *
 */
DWORD __stdcall nvRenderMoComp(LPDDHAL_RENDERMOCOMPDATA lpRMCData)
{
    DWORD                       dwRenderIndex;
    DWORD                       dwRetValue;
    LPDDMCBUFFERINFO            lpBufferInfo;
    LPBYTE                      lpBufferLinear;
    LPDXVA_BufferDescription    lpBufferHeader;
    DWORD                       dwMacroblockIndex = 255;
    DWORD                       dwDifferenceIndex = 255;
    DWORD                       dwFunction;
    DWORD                       dwDXVA_Func;
    DWORD                       dwQueryOrReplyFlag;
    DWORD                       dwReturn;

    // Get pDriverData pointer.
    nvSetDriverDataPtrFromDDGbl(lpRMCData->lpDD->lpGbl);

    // If the NVMC, NV12 or NVID surface has been destroyed, return Surface Lost error.
    if (!pDriverData->dwMCNVMCSurface    ||
        !pDriverData->dwMCNV12Surface[0] ||
        !pDriverData->dwMCNVIDSurface[0])
    {
        NvReleaseSemaphore(pDriverData);
        lpRMCData->ddRVal = DDERR_SURFACELOST;
        return (DDHAL_DRIVER_HANDLED);
    }

    // Use the dwFunction value to decide what to do with the buffers
    // passed to us.
    dwFunction = lpRMCData->dwFunction;

    // First check to see if dwFunction contains a QueryOrReply function.
    dwDXVA_Func = readDXVA_QueryOrReplyFuncFunc(&dwFunction);
    dwQueryOrReplyFlag = readDXVA_QueryOrReplyFuncFlag(&dwFunction);
    if ((dwQueryOrReplyFlag == DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY) ||
        (dwQueryOrReplyFlag == DXVA_QUERYORREPLYFUNCFLAG_DECODER_LOCK_QUERY)) {
        switch (dwDXVA_Func) {
        case DXVA_PICTURE_DECODING_FUNCTION:
            dwReturn = nvRenderCheckDecodeConfig(lpRMCData);
            break;

        case DXVA_ALPHA_BLEND_DATA_LOAD_FUNCTION:
            dwReturn = nvRenderCheckAlphaLoadConfig(lpRMCData);
            break;

        case DXVA_ALPHA_BLEND_COMBINATION_FUNCTION:
            dwReturn = nvRenderCheckAlphaCombineConfig(lpRMCData);
            break;
        }

        // Return QueryOrReply response.
        NvReleaseSemaphore(pDriverData);
        return (DDHAL_DRIVER_HANDLED);
    }

    // For other functions, we may need to use our DXVA-To-NV index
    // translation tables.  Make sure they're up to date, since a
    // DDFlip call may swap info between the surface structures.
    nvUpdateDXVAIndexTable(pDriverData);

    // If dwFunction doesn't contain a QueryOrReply function, check it for
    // other functions.  Note that dwFunction can contain up to four 1-byte
    // commands, so they have to be checked one by one, starting with the
    // most significant byte.  (If dwFunction only has one function byte
    // in it, shift it into the top byte so we don't waste too much time.)
    if (dwFunction < 256)
        dwFunction <<= 24;
    while (dwFunction) {
        // Note: if dwFunction starts with FF, we'll fall through to the default
        // case, and it will be treated as a multi-byte command.
        dwDXVA_Func = (dwFunction >> 24);
        dwFunction <<= 8;

        switch (dwDXVA_Func) {

        case 0:     // Unused
            break;

        case DXVA_PICTURE_DECODING_FUNCTION:

            // We need to go through each of the buffers we've been passed and
            // process it according to the buffer type.  For Macroblock and
            // Residual buffers, record their buffer index at this point until
            // we have a match set - we need both to do the motion comp operation.
            lpBufferHeader   = (LPDXVA_BufferDescription)lpRMCData->lpInputData;
            lpBufferInfo = (LPDDMCBUFFERINFO)(lpRMCData->lpBufferInfo);
            for (dwRenderIndex = 0; dwRenderIndex < lpRMCData->dwNumBuffers; dwRenderIndex++) {
                lpBufferLinear   = nvGetLinearAddress(lpBufferInfo->lpCompSurface)
                                   + lpBufferInfo->dwDataOffset;

                switch (lpBufferHeader->dwTypeIndex) {

                case DXVA_PICTURE_DECODE_BUFFER:
                    // Extract the picture parameters for the next frame from
                    // the buffer we were sent.
                    dwRetValue = nvRenderGetPictureParams(lpRMCData, lpBufferInfo);
                    if (dwRetValue != DD_OK) {
                        lpRMCData->ddRVal = dwRetValue;
                        NvReleaseSemaphore(pDriverData);
                        return (DDHAL_DRIVER_HANDLED);
                    }
                    break;

                case DXVA_MACROBLOCK_CONTROL_BUFFER:
                    // Just record the pointer to the Macroblock buffer info for later.
                    dwMacroblockIndex = dwRenderIndex;
                    break;

                case DXVA_RESIDUAL_DIFFERENCE_BUFFER:
                    // Just record the pointer to the Difference buffer info for later.
                    dwDifferenceIndex = dwRenderIndex;
                    break;
                }

                // If we got both a Macroblock and a Difference buffer, we can perform the
                // motion compensation operation for this Render call.
                if ((dwMacroblockIndex != 255) && (dwDifferenceIndex != 255)) {
                    dwRetValue = nvRenderDoMotionComp(lpRMCData,
                                                      dwMacroblockIndex,
                                                      dwDifferenceIndex);
                    dwMacroblockIndex = 255;
                    dwDifferenceIndex = 255;
                }

                lpBufferInfo++;
                lpBufferHeader++;
            }
            break;


        case DXVA_ALPHA_BLEND_DATA_LOAD_FUNCTION:

            // We only check for YUV Palette and IA44 Surface buffers here.
            lpBufferHeader   = (LPDXVA_BufferDescription)lpRMCData->lpInputData;
            lpBufferInfo = (LPDDMCBUFFERINFO)(lpRMCData->lpBufferInfo);
            for (dwRenderIndex = 0; dwRenderIndex < lpRMCData->dwNumBuffers; dwRenderIndex++) {
                lpBufferLinear   = nvGetLinearAddress(lpBufferInfo->lpCompSurface)
                                   + lpBufferInfo->dwDataOffset;

                switch (lpBufferHeader->dwTypeIndex) {

                case DXVA_AYUV_BUFFER:
                    // Process the new YUV palette.
                    nvRenderGetYUVPalette(lpRMCData, dwRenderIndex);
                    break;

                case DXVA_IA44_SURFACE_BUFFER:
                    // Process the new subpicture bitmap.
                    nvRenderGetIA44Surface(lpRMCData, dwRenderIndex);
                    break;
                }

                lpBufferInfo++;
                lpBufferHeader++;
            }
            break;


        case DXVA_ALPHA_BLEND_COMBINATION_FUNCTION:

            // We only check for Alpha Blend Combination buffers here.
            // The Alpha Blend data should have been provided in earlier Render calls.
            lpBufferHeader   = (LPDXVA_BufferDescription)lpRMCData->lpInputData;
            lpBufferInfo = (LPDDMCBUFFERINFO)(lpRMCData->lpBufferInfo);
            for (dwRenderIndex = 0; dwRenderIndex < lpRMCData->dwNumBuffers; dwRenderIndex++) {
                lpBufferLinear   = nvGetLinearAddress(lpBufferInfo->lpCompSurface)
                                   + lpBufferInfo->dwDataOffset;

                switch (lpBufferHeader->dwTypeIndex) {

                case DXVA_ALPHA_BLEND_COMBINATION_BUFFER:
                    // Blend the subpicture bitmap into a video frame.
                    nvRenderAlphaBlendCombination(lpRMCData, dwRenderIndex);
                    break;
                }

                lpBufferInfo++;
                lpBufferHeader++;
            }
            break;
        }
    }

    // For non-Query functions, we are normally supposed to return a status
    // code in the lpPrivateOutputData area as a DWord.  Default to OK.
    if (lpRMCData->lpOutputData && (lpRMCData->dwOutputDataSize >= 4)) {
        *((LPDWORD)lpRMCData->lpOutputData) = 0;
    }

    // Return success code.
    lpRMCData->ddRVal = DD_OK;
    NvReleaseSemaphore(pDriverData);
    return (DDHAL_DRIVER_HANDLED);
} /* nvRenderMoComp */


/*
 * nvRenderCheckDecodeConfig
 *
 * Private function called by nvRenderMoComp.
 * Checks picture decoding configuration given by the decoder
 * to see if it's a configuration we support.
 *
 */
DWORD __stdcall nvRenderCheckDecodeConfig(LPDDHAL_RENDERMOCOMPDATA lpRMCData)
{
    LPDXVA_ConfigPictureDecode  lpConnectConfigInput;
    LPDXVA_ConfigPictureDecode  lpConnectConfigOutput;
    DXVA_ConfigPictureDecode    NVConnectConfig = {0};
    DWORD                   dwReturn;
    DWORD                   dwFunction;
    DWORD                   dwDXVA_Func;
    DWORD                   dwQueryOrReplyFlag;

    // Get QueryOrReply details.
    dwFunction = lpRMCData->dwFunction;
    dwDXVA_Func = readDXVA_QueryOrReplyFuncFunc(&dwFunction);
    dwQueryOrReplyFlag = readDXVA_QueryOrReplyFuncFlag(&dwFunction);

    // Set up pointers to input and output structures.
    lpConnectConfigInput  = (LPDXVA_ConfigPictureDecode)lpRMCData->lpInputData;
    lpConnectConfigOutput = (LPDXVA_ConfigPictureDecode)lpRMCData->lpOutputData;

    // Check input structure against our preferred structure.
    // Note that we don't care about bConfigMBcontrolRasterOrder
    // and bConfigIntraResidUnsigned, we'll accept either value.
    if ((lpConnectConfigInput->dwFunction                     != dwFunction)     ||
        (lpConnectConfigInput->guidConfigBitstreamEncryption  != DXVA_NoEncrypt) ||
        (lpConnectConfigInput->guidConfigMBcontrolEncryption  != DXVA_NoEncrypt) ||
        (lpConnectConfigInput->guidConfigResidDiffEncryption  != DXVA_NoEncrypt) ||
        (lpConnectConfigInput->bConfigBitstreamRaw            != 0)              ||
        (lpConnectConfigInput->bConfigResidDiffHost           != 1)              ||
        (lpConnectConfigInput->bConfigSpatialResid8           != 1)              ||
        (lpConnectConfigInput->bConfigResid8Subtraction       != 0)              ||
        (lpConnectConfigInput->bConfigSpatialHost8or9Clipping != 0)              ||
        (lpConnectConfigInput->bConfigSpatialResidInterleaved != 1)              ||
        (lpConnectConfigInput->bConfigResidDiffAccelerator    != 0)              ||
        (lpConnectConfigInput->bConfigHostInverseScan         != 0)              ||
        (lpConnectConfigInput->bConfigSpecificIDCT            != 0)              ||
        (lpConnectConfigInput->bConfig4GroupedCoefs           != 0)) {

        // Make the output a duplicate of our preferred structure.
        NVConnectConfig.dwFunction = dwFunction;
        memcpy((GUID *)&NVConnectConfig.guidConfigBitstreamEncryption,
               (GUID *)&DXVA_NoEncrypt,
               sizeof(GUID));
        memcpy((GUID *)&NVConnectConfig.guidConfigMBcontrolEncryption,
               (GUID *)&DXVA_NoEncrypt,
               sizeof(GUID));
        memcpy((GUID *)&NVConnectConfig.guidConfigResidDiffEncryption,
               (GUID *)&DXVA_NoEncrypt,
               sizeof(GUID));
        NVConnectConfig.bConfigResidDiffHost = 1;
        NVConnectConfig.bConfigSpatialResid8 = 1;
        NVConnectConfig.bConfigSpatialResidInterleaved = 1;
        NVConnectConfig.bConfigIntraResidUnsigned = 0;

        memcpy(lpRMCData->lpOutputData,
               (LPVOID)&NVConnectConfig,
               sizeof(DXVA_ConfigPictureDecode));

        lpRMCData->ddRVal = S_FALSE;
        if (dwQueryOrReplyFlag == DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY)
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_FALSE_PLUS;
        else
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_FALSE_PLUS;
    }
    else {
        // Make the output a duplicate of the input structure.
        memcpy(lpRMCData->lpOutputData,
               lpRMCData->lpInputData,
               sizeof(DXVA_ConfigPictureDecode));

        // Record the setting of the Intra IDCT Unsigned flag.
        if (lpConnectConfigInput->bConfigIntraResidUnsigned)
            pDriverData->dwDXVAFlags |= DXVA_INTRA_IDCT_UNSIGNED;
        else
            pDriverData->dwDXVAFlags &= ~DXVA_INTRA_IDCT_UNSIGNED;

        lpRMCData->ddRVal = S_OK;
        if (dwQueryOrReplyFlag == DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY)
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_COPY;
        else
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_OK_COPY;
    }

    writeDXVA_QueryOrReplyFunc(&lpConnectConfigOutput->dwFunction, dwReturn, dwDXVA_Func);
    return dwReturn;
}  // nvRenderCheckDecodeConfig


/*
 * nvRenderCheckAlphaLoadConfig
 *
 * Private function called by nvRenderMoComp.
 * Checks alpha blend load configuration given by the decoder
 * to see if it's a configuration we support.
 *
 */
DWORD __stdcall nvRenderCheckAlphaLoadConfig(LPDDHAL_RENDERMOCOMPDATA lpRMCData)
{
    LPDXVA_ConfigAlphaLoad  lpConfigAlphaLoadInput;
    LPDXVA_ConfigAlphaLoad  lpConfigAlphaLoadOutput;
    DXVA_ConfigAlphaLoad    NVConfigAlphaLoad = {0};
    DWORD                   dwFunction;
    DWORD                   dwReturn;
    DWORD                   dwDXVA_Func;
    DWORD                   dwQueryOrReplyFlag;

    // Get QueryOrReply details.
    dwFunction = lpRMCData->dwFunction;
    dwDXVA_Func = readDXVA_QueryOrReplyFuncFunc(&dwFunction);
    dwQueryOrReplyFlag = readDXVA_QueryOrReplyFuncFlag(&dwFunction);

    // Set up pointers to input and output structures.
    lpConfigAlphaLoadInput  = (LPDXVA_ConfigAlphaLoad)lpRMCData->lpInputData;
    lpConfigAlphaLoadOutput = (LPDXVA_ConfigAlphaLoad)lpRMCData->lpOutputData;

    // Check input structure against our preferred structure.
    if ((lpConfigAlphaLoadInput->dwFunction      != dwFunction) ||
        (lpConfigAlphaLoadInput->bConfigDataType != DXVA_CONFIG_DATA_TYPE_IA44)) {

        // Make the output a duplicate of our preferred structure.
        NVConfigAlphaLoad.dwFunction = dwFunction;
        NVConfigAlphaLoad.bConfigDataType = DXVA_CONFIG_DATA_TYPE_IA44;     // AYUV Palette & IA44 Surface.
        memcpy(lpRMCData->lpOutputData,
               (LPVOID)&NVConfigAlphaLoad,
               sizeof(DXVA_ConfigAlphaLoad));

        lpRMCData->ddRVal = S_FALSE;
        if (dwQueryOrReplyFlag == DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY)
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_FALSE_PLUS;
        else
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_FALSE_PLUS;
    }
    else {
        // Make the output a duplicate the input structure.
        memcpy(lpRMCData->lpOutputData,
               lpRMCData->lpInputData,
               sizeof(DXVA_ConfigAlphaLoad));

        lpRMCData->ddRVal = S_OK;
        if (dwQueryOrReplyFlag == DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY)
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_COPY;
        else
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_OK_COPY;
    }

    writeDXVA_QueryOrReplyFunc(&lpConfigAlphaLoadOutput->dwFunction, dwReturn, dwDXVA_Func);
    return dwReturn;
}  // nvRenderCheckAlphaLoadConfig


/*
 * nvRenderCheckAlphaCombineConfig
 *
 * Private function called by nvRenderMoComp.
 * Checks alpha blend combination configuration given by the decoder
 * to see if it's a configuration we support.
 *
 */
DWORD __stdcall nvRenderCheckAlphaCombineConfig(LPDDHAL_RENDERMOCOMPDATA lpRMCData)
{
    LPDXVA_ConfigAlphaCombine   lpConfigAlphaCombineInput;
    LPDXVA_ConfigAlphaCombine   lpConfigAlphaCombineOutput;
    DXVA_ConfigAlphaCombine     NVConfigAlphaCombine = {0};
    DWORD                       dwFunction;
    DWORD                       dwReturn;
    DWORD                       dwDXVA_Func;
    DWORD                       dwQueryOrReplyFlag;

    // Get QueryOrReply details.
    dwFunction = lpRMCData->dwFunction;
    dwDXVA_Func = readDXVA_QueryOrReplyFuncFunc(&dwFunction);
    dwQueryOrReplyFlag = readDXVA_QueryOrReplyFuncFlag(&dwFunction);

    // Set up pointers to input and output structures.
    lpConfigAlphaCombineInput  = (LPDXVA_ConfigAlphaCombine)lpRMCData->lpInputData;
    lpConfigAlphaCombineOutput = (LPDXVA_ConfigAlphaCombine)lpRMCData->lpOutputData;

    // Check to see if this is a valid Front End Alpha Blend configuration.
    // We only allow this configuration if video memory size is 32K or above,
    // because front end blending requires extra NV12 surfaces.
    if ((pDriverData->TotalVRAM >= 0x2000000) &&
        (lpConfigAlphaCombineInput->bConfigBlendType == DXVA_CONFIG_BLEND_TYPE_FRONT_BUFFER) &&
        (lpConfigAlphaCombineInput->bConfigOnlyUsePicDestRectArea == 1) &&
        (lpConfigAlphaCombineInput->bConfigWholePlaneAlpha == 0)) {

        // Make the output a duplicate of the input structure.
        memcpy(lpRMCData->lpOutputData,
               lpRMCData->lpInputData,
               sizeof(DXVA_ConfigAlphaCombine));

        // Reset flag to say we're going to use Front End blending.
        pDriverData->dwDXVAFlags &= ~DXVA_BACK_END_ALPHA_SELECTED;
        pDriverData->dwDXVAFlags &= ~DXVA_BACK_END_ALPHA_ENABLED;
        pDriverData->vpp.regOverlayMode3 &= ~NV4_REG_OVL_MODE3_DXVA_BACK_END_ALPHA_PREFERRED;

        lpRMCData->ddRVal = S_OK;
        if (dwQueryOrReplyFlag == DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY)
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_COPY;
        else
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_OK_COPY;
    }

    // Else check to see if this is a valid Back End Alpha Blend configuration.
    // We allow this configuration for all memory sizes.
    // Check input structure against our preferred structure
    // (we can accept either value of GraphicResizing.)
    else if ((lpConfigAlphaCombineInput->bConfigBlendType == DXVA_CONFIG_BLEND_TYPE_BACK_HARDWARE) &&
        (lpConfigAlphaCombineInput->bConfigPictureResizing        == 0) &&
        (lpConfigAlphaCombineInput->bConfigOnlyUsePicDestRectArea == 1) &&
        (lpConfigAlphaCombineInput->bConfigWholePlaneAlpha        == 0)) {

        // Make the output a duplicate of the input structure.
        memcpy(lpRMCData->lpOutputData,
               lpRMCData->lpInputData,
               sizeof(DXVA_ConfigAlphaCombine));

        // Set flag to say we're going to use Back End blending, initially disabled.
        pDriverData->dwDXVAFlags |= DXVA_BACK_END_ALPHA_SELECTED;
        pDriverData->dwDXVAFlags &= ~DXVA_BACK_END_ALPHA_ENABLED;
        pDriverData->vpp.regOverlayMode3 |= NV4_REG_OVL_MODE3_DXVA_BACK_END_ALPHA_PREFERRED;

        lpRMCData->ddRVal = S_OK;
        if (dwQueryOrReplyFlag == DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY)
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_COPY;
        else
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_OK_COPY;
    }

    // Otherwise return an error code and preferred configuration based on video
    // memory size.
    else if (pDriverData->TotalVRAM >= 0x2000000) {

        // Make the output a duplicate of our preferred structure for Front End blending.
        NVConfigAlphaCombine.dwFunction = dwFunction;
        NVConfigAlphaCombine.bConfigBlendType = DXVA_CONFIG_BLEND_TYPE_FRONT_BUFFER;
        NVConfigAlphaCombine.bConfigPictureResizing        = 1; // Support picture resize.
        NVConfigAlphaCombine.bConfigOnlyUsePicDestRectArea = 1; // Restrict destination rectangle.
        NVConfigAlphaCombine.bConfigGraphicResizing        = 1; // Support subpicture resizing.
        NVConfigAlphaCombine.bConfigWholePlaneAlpha        = 0; // No alpha override.
        NVConfigAlphaCombine.dwFunction = dwFunction;
        memcpy(lpRMCData->lpOutputData,
               (LPVOID)&NVConfigAlphaCombine,
               sizeof(DXVA_ConfigAlphaCombine));

        lpRMCData->ddRVal = S_FALSE;
        if (dwQueryOrReplyFlag == DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY)
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_FALSE_PLUS;
        else
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_FALSE_PLUS;
    }

    else {

        // Make the output a duplicate of our preferred structure for Back End blending.
        NVConfigAlphaCombine.dwFunction = dwFunction;
        NVConfigAlphaCombine.bConfigBlendType = DXVA_CONFIG_BLEND_TYPE_BACK_HARDWARE;
        NVConfigAlphaCombine.bConfigPictureResizing        = 0; // Don't support picture resize.
        NVConfigAlphaCombine.bConfigOnlyUsePicDestRectArea = 1; // Restrict destination rectangle.
        NVConfigAlphaCombine.bConfigGraphicResizing        = 1; // Support subpicture resizing.
        NVConfigAlphaCombine.bConfigWholePlaneAlpha        = 0; // No alpha override.
        NVConfigAlphaCombine.dwFunction = dwFunction;
        memcpy(lpRMCData->lpOutputData,
               (LPVOID)&NVConfigAlphaCombine,
               sizeof(DXVA_ConfigAlphaCombine));

        lpRMCData->ddRVal = S_FALSE;
        if (dwQueryOrReplyFlag == DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY)
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_FALSE_PLUS;
        else
            dwReturn = DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_FALSE_PLUS;
    }

    writeDXVA_QueryOrReplyFunc(&lpConfigAlphaCombineOutput->dwFunction, dwReturn, dwDXVA_Func);
    return dwReturn;
}  // nvRenderCheckAlphaLoadConfig


/*
 * nvRenderGetPictureParams
 *
 * Private function called by nvRenderMoComp.
 * Extracts information for decoding a new frame from a
 * Picture Parameter structure passed to RenderMoComp.
 *
 */
DWORD __stdcall nvRenderGetPictureParams(LPDDHAL_RENDERMOCOMPDATA lpRMCData,
                                         LPDDMCBUFFERINFO lpPictureBuffer)
{
    LPBYTE                      lpBufferLinear;
    LPDXVA_PictureParameters    lpPictureParams;
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    LPNVMCFRAMEDATA             lpNvMCFrameData;

    // Get pDriverData pointer.
    nvSetDriverDataPtrFromDDGbl(lpRMCData->lpDD->lpGbl);

    // Because our Picture Parameter buffer is in System memory,
    // decoder doesn't call our Lock32 before using it.  The
    // following may be required for some DVD decoders.
    getDC()->nvPusher.flush(TRUE, CPushBuffer::FLUSH_WITH_DELAY);

    // Calculate a pointer to the Picture Parameters structure in the buffer.
    lpBufferLinear   = nvGetLinearAddress(lpPictureBuffer->lpCompSurface)
                       + lpPictureBuffer->dwDataOffset;
    lpPictureParams  = (LPDXVA_PictureParameters)lpBufferLinear;

    // Calculate a linear pointer to the NVMC surface created by DShow.
    // We use this surface to store the NVMCFRAMEDATA structure.
    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVMCSurface;
    lpNvMCFrameData = (LPNVMCFRAMEDATA)VIDMEM_ADDR(pSurf_lcl->lpGbl->fpVidMem);

    // Make a copy of some Picture Parameters we need later.
    lpNvMCFrameData->wDXVAPicWidthInMB  = lpPictureParams->wPicWidthInMBminus1 + 1;
    lpNvMCFrameData->wDXVAPicHeightInMB = lpPictureParams->wPicHeightInMBminus1 + 1;

    // Extract the Picture Parameter values and use them to fill in our
    // NVMCFRAMEDATA structure, which is used by MoCompExecute.
    lpNvMCFrameData->dwMCNvExecute = 0;

#ifdef WINNT
    // For Win2K, return lpDD as the MultiMon parameter, since pDXShare is NULL.
    lpNvMCFrameData->dwMCMultiMonID = (DWORD)lpRMCData->lpDD;
#else
    // For Win98, return pDXShare as the MultiMon parameter for compatibility
    // with the nVidia proprietary motion comp interface.
    lpNvMCFrameData->dwMCMultiMonID = (DWORD)pDXShare;
#endif

    // Store the "raw" DXVA buffer indexes in the NVMC surface for now.
    // We'll convert them later to NV buffer indexes in RenderDoMotionComp.
    // Note: unused indexes may be set to 0xFFFF according to the DXVA spec.
    lpNvMCFrameData->wDXVADecodedPictureIndex     = min(lpPictureParams->wDecodedPictureIndex, 7);
    lpNvMCFrameData->wDXVAForwardRefPictureIndex  = min(lpPictureParams->wForwardRefPictureIndex, 7);
    lpNvMCFrameData->wDXVABackwardRefPictureIndex = min(lpPictureParams->wBackwardRefPictureIndex, 7);

    lpNvMCFrameData->bMCPictureStructure
        = lpPictureParams->bPicStructure;

    if (lpPictureParams->bPicIntra)
        lpNvMCFrameData->bMCPictureCodingType = PICTURE_TYPE_I;
    else if (lpPictureParams->bPicBackwardPrediction)
        lpNvMCFrameData->bMCPictureCodingType = PICTURE_TYPE_B;
    else
        lpNvMCFrameData->bMCPictureCodingType = PICTURE_TYPE_P;

    lpNvMCFrameData->bMCTopFieldFirst = 1;
    lpNvMCFrameData->bMCSecondField   = lpPictureParams->bSecondField;

    if (lpPictureParams->bPicStructure == PICTURE_STRUCTURE_FRAME)
        lpNvMCFrameData->bMCFrameType = 0;
    else
        lpNvMCFrameData->bMCFrameType = 1;

    lpNvMCFrameData->bMCEndOfPicture  = 0;

    NvReleaseSemaphore(pDriverData);
    return DD_OK;
}  // nvRenderGetPictureParams


/*
 * nvRenderDoMotionComp
 *
 * Private function called by nvRenderMoComp.
 * Does motion comp operation with data passed to Render.
 *
 */

DWORD __stdcall nvRenderDoMotionComp(LPDDHAL_RENDERMOCOMPDATA lpRMCData,
                                     DWORD dwMacroblockIndex,
                                     DWORD dwDifferenceIndex)
{
    LPBYTE                          lpDXVAMacroblockLinear;
    LPBYTE                          lpDXVAMacroblockPtr;
    LPDXVA_MBctrl_P_HostResidDiff_1 lpDXVAType;
    LPNVDECODEMACROBLOCK            lpNVMacroblockPtr;
    DWORD                           dwNumSrcMacroblocks, dwNumDstMacroblocks;
    DWORD                           dwIndex;
    LPDDRAWI_DDRAWSURFACE_LCL       pSurf_lcl;
    LPNVMCFRAMEDATA                 lpNvMCFrameData;
    LPBYTE                          lpIDCTLinear;
    WORD                            wNVIndex;
    DWORD                           dwIDCTOffset;
    DWORD                           dwIDCTIndex;
    WORD                            wDXVAPicWidthInMB;
    WORD                            wDXVAPicHeightInMB;
    BYTE                            bEndOfPicture = 0;
    LPDXVA_BufferDescription        lpDXVAMacroblockHeader;
    LPDXVA_BufferDescription        lpDXVADifferenceHeader;
    LPDXVA_BufferDescription        lpDataHeaders;
    LPDDMCBUFFERINFO                lpMacroblockBuffer;
    LPDDMCBUFFERINFO                lpDifferenceBuffer;
    DWORD                           dwCommand;
    DWORD                           dwStructureSize;

    // Get pDriverData pointer.
    nvSetDriverDataPtrFromDDGbl(lpRMCData->lpDD->lpGbl);

    // Set flag to say we're doing a picture decode.
    pDriverData->dwDXVAFlags |= DXVA_PICTURE_IN_PROGRESS;

    // Get pointers to the Macroblock and Difference buffer headers from lpInputData.
    lpDataHeaders = (LPDXVA_BufferDescription)lpRMCData->lpInputData;
    lpDXVAMacroblockHeader = lpDataHeaders + dwMacroblockIndex;
    lpDXVADifferenceHeader = lpDataHeaders + dwDifferenceIndex;

    // Calculate a pointer to the Macroblock data buffers.
    lpMacroblockBuffer = lpRMCData->lpBufferInfo + dwMacroblockIndex;
    lpDXVAMacroblockLinear = nvGetLinearAddress(lpMacroblockBuffer->lpCompSurface)
                             + lpMacroblockBuffer->dwDataOffset;
    lpDXVAMacroblockPtr    = lpDXVAMacroblockLinear;

    // Calculate the index of the Difference buffer.  This is normally used when we call
    // nvMoCompExecute.
    lpDifferenceBuffer = lpRMCData->lpBufferInfo + dwDifferenceIndex;
    for (wNVIndex = 0; wNVIndex < 4; wNVIndex++) {
        if ((DWORD)lpDifferenceBuffer->lpCompSurface == pDriverData->dwMCNVIDSurface[wNVIndex])
            break;
    }
    if (wNVIndex > 3)
        wNVIndex = 0;


    // Set up a pointer to the IDCT buffer we're going to use.
    lpDifferenceBuffer = lpRMCData->lpBufferInfo + dwDifferenceIndex;
    lpIDCTLinear = (LPBYTE)VIDMEM_ADDR(lpDifferenceBuffer->lpCompSurface->lpGbl->fpVidMem);

    // Calculate an offset to the beginning of the IDCT data in the surface.
    // This is needed for the 0.9.2 version of DXVA, not for 0.9.3.
    dwIDCTOffset = lpDifferenceBuffer->dwDataOffset;

    // Calculate a linear pointer to the NVMC surface created by DShow.
    // We use this surface to store the NVMCFRAMEDATA structure.
    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVMCSurface;
    lpNvMCFrameData = (LPNVMCFRAMEDATA)VIDMEM_ADDR(pSurf_lcl->lpGbl->fpVidMem);

    // Convert DXVA indexes we were given earlier into NV surface indexes
    // using our translation table.
    lpNvMCFrameData->bMCDestinationSurfaceIndex
        = pDriverData->bDXVAIndexToNVIndex[lpNvMCFrameData->wDXVADecodedPictureIndex];
    lpNvMCFrameData->bMCForwardSurfaceIndex
        = pDriverData->bDXVAIndexToNVIndex[lpNvMCFrameData->wDXVAForwardRefPictureIndex];
    lpNvMCFrameData->bMCBackwardSurfaceIndex
        = pDriverData->bDXVAIndexToNVIndex[lpNvMCFrameData->wDXVABackwardRefPictureIndex];

    // Set up a pointer to the beginning our Conversion buffer, where we'll
    // create NV-style macroblock headers from the DXVA-style headers we've
    // been given.
    lpNVMacroblockPtr = (LPNVDECODEMACROBLOCK)(pDriverData->dwDXVAConvertBuffer
                                               + MACROBLOCKS_OFFSET);

    // Convert Macroblock Buffer into the nVidia Macroblock format,
    // so we can pass it and the IDCT data surface to nvMoCompExecute.
    wDXVAPicWidthInMB  = lpNvMCFrameData->wDXVAPicWidthInMB;
    wDXVAPicHeightInMB = lpNvMCFrameData->wDXVAPicHeightInMB;

    // Calculate number of input macroblocks based on the data buffer size,
    // since skipped macroblocks may make dwNumMBsInBuffer unreliable.
    if (lpNvMCFrameData->bMCPictureCodingType == PICTURE_TYPE_I)
        dwStructureSize = sizeof(DXVA_MBctrl_I_HostResidDiff_1);
    else
        dwStructureSize = sizeof(DXVA_MBctrl_P_HostResidDiff_1);
    dwNumSrcMacroblocks = lpDXVAMacroblockHeader->dwDataSize / dwStructureSize;
    dwNumDstMacroblocks = 0;

    for (dwIndex = 0; dwIndex < dwNumSrcMacroblocks; dwIndex++) {

        // First take care of fields that are common for Intra and non-Intra
        // macroblocks.
        lpDXVAType = (LPDXVA_MBctrl_P_HostResidDiff_1)lpDXVAMacroblockPtr;

        lpNVMacroblockPtr->hOffset
            = (lpDXVAType->wMBaddress % wDXVAPicWidthInMB) * 16;
        lpNVMacroblockPtr->vOffset
            = (lpDXVAType->wMBaddress / wDXVAPicWidthInMB) * 16;

        // If this is the last macroblock in the frame, set a flag so we
        // know we should set the NV End of Picture byte.
        if (lpDXVAType->wMBaddress == wDXVAPicWidthInMB * wDXVAPicHeightInMB - 1)
            bEndOfPicture = 1;

        dwIDCTIndex = readDXVA_MBdataLocation(lpDXVAType);
        dwIDCTIndex >>= 4;
        lpNVMacroblockPtr->firstIDCTIndex = (WORD)dwIDCTIndex;

        if (readDXVA_FieldResidual(lpDXVAType))
            lpNVMacroblockPtr->DCTType = DCT_FIELD;
        else
            lpNVMacroblockPtr->DCTType = DCT_FRAME;

        lpNVMacroblockPtr->codedBlockPattern
            = lpDXVAType->wPatternCode >> 6;

        lpNVMacroblockPtr->overflowCodedBlockPattern
            = lpDXVAType->wPC_Overflow >> 6;

        // For Intra macroblocks, set motion entries to zero.
        if (readDXVA_IntraMacroblock(lpDXVAType)) {
            // No motion.
            lpNVMacroblockPtr->motionType = 0;

            lpNVMacroblockPtr->macroblockType = MB_INTRA;
        }

        // For Non-Intra macroblocks, set up the motion fields.
        else {

            // Get field selects.
            lpNVMacroblockPtr->fieldSelect[0][0] = readDXVA_MvertFieldSel_0(lpDXVAType);
            lpNVMacroblockPtr->fieldSelect[0][1] = readDXVA_MvertFieldSel_1(lpDXVAType);
            lpNVMacroblockPtr->fieldSelect[1][0] = readDXVA_MvertFieldSel_2(lpDXVAType);
            lpNVMacroblockPtr->fieldSelect[1][1] = readDXVA_MvertFieldSel_3(lpDXVAType);

            // Set up macroblock type.
            lpNVMacroblockPtr->macroblockType = 0;
            if (readDXVA_MotionForward(lpDXVAType))
                lpNVMacroblockPtr->macroblockType |= MB_MOTION_FORWARD;
            if (readDXVA_MotionBackward(lpDXVAType))
                lpNVMacroblockPtr->macroblockType |= MB_MOTION_BACKWARD;

            // Progressive frame cases.
            if (lpNvMCFrameData->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) {
                switch(readDXVA_MotionType(lpDXVAType)) {
                case 0:
                case 1:
                    lpNVMacroblockPtr->motionType = FRAME_STRUCTURE_MOTION_FIELD;
                    if(lpNVMacroblockPtr->macroblockType == MB_MOTION_FORWARD)
                    {
                        memcpy(lpNVMacroblockPtr->PMV, lpDXVAType->MVector, 4);
                        memcpy(lpNVMacroblockPtr->PMV[1][0], &lpDXVAType->MVector[2], 4);
                    }
                    else if(lpNVMacroblockPtr->macroblockType == MB_MOTION_BACKWARD)
                    {
                        memcpy(lpNVMacroblockPtr->PMV[0][1], &lpDXVAType->MVector[1], 4);
                        memcpy(lpNVMacroblockPtr->PMV[1][1], &lpDXVAType->MVector[3], 4);
                    }
                    else if(lpNVMacroblockPtr->macroblockType)
                    {
                        memcpy(lpNVMacroblockPtr->PMV, lpDXVAType->MVector, 16);
                    }
                    break;
                case 2:
                    lpNVMacroblockPtr->motionType = FRAME_STRUCTURE_MOTION_FRAME;

                    if(lpNVMacroblockPtr->macroblockType == MB_MOTION_FORWARD)
                    {
                        memcpy(lpNVMacroblockPtr->PMV, lpDXVAType->MVector, 4);
                    }
                    else if(lpNVMacroblockPtr->macroblockType == MB_MOTION_BACKWARD)
                    {
                        memcpy(lpNVMacroblockPtr->PMV[0][1], &lpDXVAType->MVector[1], 4);
                    }
                    else if(lpNVMacroblockPtr->macroblockType)
                    {
                        memcpy(lpNVMacroblockPtr->PMV, lpDXVAType->MVector, 8);
                    }

                    break;
                case 3:
                    lpNVMacroblockPtr->motionType = FRAME_STRUCTURE_MOTION_DP;
                    memcpy(lpNVMacroblockPtr->PMV, lpDXVAType->MVector, 16);

                    // Copy derived motion vectors for dual-prime.
                    lpNVMacroblockPtr->PMV[1][0][0] = lpNVMacroblockPtr->PMV[0][1][0];
                    lpNVMacroblockPtr->PMV[1][0][1] = lpNVMacroblockPtr->PMV[0][1][1];

                    // Zero out unused motion vectors and field selects.
                    lpNVMacroblockPtr->PMV[0][1][0] = 0;
                    lpNVMacroblockPtr->PMV[0][1][1] = 0;
                    memset(lpNVMacroblockPtr->fieldSelect, 0, 4);
                    break;
                }

           }

            // Interlaced frame cases.
            else {
                switch(readDXVA_MotionType(lpDXVAType)) {
                case 0:
                case 1:
                    lpNVMacroblockPtr->motionType = FIELD_STRUCTURE_MOTION_FIELD;
                    if(lpNVMacroblockPtr->macroblockType == MB_MOTION_FORWARD)
                    {
                        memcpy(lpNVMacroblockPtr->PMV, lpDXVAType->MVector, 4);
                    }
                    else if(lpNVMacroblockPtr->macroblockType == MB_MOTION_BACKWARD)
                    {
                        memcpy(lpNVMacroblockPtr->PMV[0][1], &lpDXVAType->MVector[1], 4);
                    }
                    else if(lpNVMacroblockPtr->macroblockType)
                    {
                        memcpy(lpNVMacroblockPtr->PMV, lpDXVAType->MVector, 8);
                    }
                    break;
                case 2:
                    lpNVMacroblockPtr->motionType = FIELD_STRUCTURE_MOTION_16X8;
                    if(lpNVMacroblockPtr->macroblockType == MB_MOTION_FORWARD)
                    {
                        memcpy(lpNVMacroblockPtr->PMV, lpDXVAType->MVector, 4);
                        memcpy(lpNVMacroblockPtr->PMV[1][0], &lpDXVAType->MVector[2], 4);
                    }
                    else if(lpNVMacroblockPtr->macroblockType == MB_MOTION_BACKWARD)
                    {
                        memcpy(lpNVMacroblockPtr->PMV[0][1], &lpDXVAType->MVector[1], 4);
                        memcpy(lpNVMacroblockPtr->PMV[1][1], &lpDXVAType->MVector[3], 4);

                    }
                    else if(lpNVMacroblockPtr->macroblockType)
                    {
                        memcpy(lpNVMacroblockPtr->PMV, lpDXVAType->MVector, 16);
                    }
                    break;
                case 3:
                    lpNVMacroblockPtr->motionType = FIELD_STRUCTURE_MOTION_DP;

                    memcpy(lpNVMacroblockPtr->PMV, lpDXVAType->MVector, 8);

                    // Copy derived motion vectors for dual-prime.
                    lpNVMacroblockPtr->PMV[1][0][0] = lpNVMacroblockPtr->PMV[0][1][0];
                    lpNVMacroblockPtr->PMV[1][0][1] = lpNVMacroblockPtr->PMV[0][1][1];

                    // Zero out unused motion vectors and field selects.
                    lpNVMacroblockPtr->PMV[0][1][0] = 0;
                    lpNVMacroblockPtr->PMV[0][1][1] = 0;
                    memset(lpNVMacroblockPtr->fieldSelect, 0, 4);
                    break;
                }

            }

            // If this is a No Motion case, convert it into a forward prediction
            // with null motion vectors.
            if (!lpNVMacroblockPtr->macroblockType) {
                lpNVMacroblockPtr->macroblockType = MB_MOTION_FORWARD;
                memset(lpNVMacroblockPtr->PMV, 0, 12);
            }
        }

        // Move to next NV macroblock header position in the Conversion buffer.
        lpNVMacroblockPtr++;
        dwNumDstMacroblocks++;

        // If there were any skipped macroblocks following this block, we
        // need to generate new macroblocks headers for them.  Each of
        // these new headers should have the same type as the real header
        // we were given, but with zero motion vectors and IDCT data.
        // Note: I frames should never have skipped macroblocks.
        if (readDXVA_MBskipsFollowing(lpDXVAType))
        {
            WORD    wSkipIndex;

            for (wSkipIndex = 0; wSkipIndex < readDXVA_MBskipsFollowing(lpDXVAType); wSkipIndex++)
            {
                // Generate each new header from the previous header.
                *lpNVMacroblockPtr = *(lpNVMacroblockPtr - 1);
                lpNVMacroblockPtr->hOffset += 0x10;
                lpNVMacroblockPtr->codedBlockPattern = 0;
                lpNVMacroblockPtr->overflowCodedBlockPattern = 0;
                lpNVMacroblockPtr++;
                dwNumDstMacroblocks++;
            }
        }

        // Move to next DXVA macroblock header.
        lpDXVAMacroblockPtr += dwStructureSize;
    }

    // If this frame contained the last macroblock of the picture, set the
    // End of Picture flag.
    lpNvMCFrameData->bMCEndOfPicture = bEndOfPicture;

    // Send the Conversion buffer to nvMoCompExecute, along with the NVID
    // surface containing the IDCT data.
    if (pDriverData->dwDXVAFlags & DXVA_INTRA_IDCT_UNSIGNED)
        dwCommand = EXECUTE_NON_PREBIASED_MOTION_COMPENSATION;
    else
        dwCommand = EXECUTE_MOTION_COMPENSATION;
    nvMoCompExecute(lpNvMCFrameData->dwMCMultiMonID,
                    dwCommand,
                    (LPVOID)(pDriverData->dwDXVAConvertBuffer + MACROBLOCKS_OFFSET),
                    dwNumDstMacroblocks * sizeof(NVDECODEMACROBLOCK),
                    wNVIndex);

    NvReleaseSemaphore(pDriverData);
    return DD_OK;
}  // nvRenderDoMotionComp


/*
 * nvRenderGetYUVPalette
 *
 * Private function called by nvRenderMoComp.
 * Takes the YUV subpicture palette provided by the decoder and uses it to generate
 * a new subpicture pixel lookup table, then use the lookup table to update the
 * current subpicture bitmap.
 *
 */
DWORD __stdcall nvRenderGetYUVPalette(LPDDHAL_RENDERMOCOMPDATA lpRMCData, DWORD dwRenderIndex)
{
    LPDDMCBUFFERINFO            lpPaletteBuffer;
    LPDXVA_BufferDescription    lpPaletteHeader;
    LPBYTE                      lpPaletteLinear;
    DWORD                       dwIndex, dwPaletteIndex;
    DWORD                       dwX, dwY;
    LPDDRAWI_DDRAWSURFACE_LCL   lpDstSurface;
    LPDWORD                     lpDst;
    DWORD                       dwDstStride;
    DWORD                       dwDstWidth, dwDstHeight;
    DWORD                       dwSrcOffset, dwDstOffset;
    DWORD                       dwAlpha;
    DWORD                       dwYUVArray[16];
    LPBYTE                      lpTemp;
    LPBYTE                      lpSrc;
    LPDWORD                     lpIA44toAYUVLookup;
    LPDXVA_AYUVsample           lpPaletteAYUV;
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    LPNVMCFRAMEDATA             lpNvMCFrameData;
    DWORD                       dwSubpicBuffer, dwSubpicStride;

    // Get pDriverData pointer.
    nvSetDriverDataPtrFromDDGbl(lpRMCData->lpDD->lpGbl);

    // Calculate pointer to decompressed section of our NVSP surface.
    lpDstSurface = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVSPSurface;
    dwDstWidth   = (DWORD)lpDstSurface->lpGbl->wWidth;
    dwDstHeight  = (DWORD)lpDstSurface->lpGbl->wHeight;
    dwDstStride  = (DWORD)lpDstSurface->lpGbl->lPitch;
    lpDst        = (LPDWORD)(nvGetLinearAddress(lpDstSurface)
                             + 2 * dwDstStride * dwDstHeight);

    // Get pointer to the YUV Palette buffer header from lpInputData.
    lpPaletteHeader = (LPDXVA_BufferDescription)lpRMCData->lpInputData;
    lpPaletteHeader += dwRenderIndex;

    // Get pointer to the YUV Palette surface data.
    lpPaletteBuffer = lpRMCData->lpBufferInfo + dwRenderIndex;
    lpPaletteLinear = nvGetLinearAddress(lpPaletteBuffer->lpCompSurface)
                      + lpPaletteBuffer->dwDataOffset;
    lpPaletteAYUV   = (LPDXVA_AYUVsample)lpPaletteLinear;

    // Get pointer to our IA44 to AYUV lookup table.
    lpIA44toAYUVLookup = (LPDWORD)(pDriverData->dwDXVAConvertBuffer + LOOKUP_TABLE_OFFSET);

    // First convert the YUV palette into a YUV array in the correct order for us.
    lpTemp = (LPBYTE)dwYUVArray;
    for (dwIndex = 0; dwIndex < 16; dwIndex++) {
        *lpTemp++ = lpPaletteAYUV->bY_Value;
        *lpTemp++ = lpPaletteAYUV->bCbValue;
        *lpTemp++ = lpPaletteAYUV->bCrValue;
        *lpTemp++ = 0;
        lpPaletteAYUV++;
    }

    // Now use the YUV palette values to fill up the IA44 to AYUV lookup table.
    for (dwIndex = 0; dwIndex < 256; dwIndex++) {
        dwPaletteIndex = readDXVA_IA44index(&dwIndex);
        dwAlpha        = readDXVA_IA44alpha(&dwIndex);

        // Rescale dwAlpha from 0-15 to 0-255 range and shift into right position.
        dwAlpha        = ((dwAlpha * 255) / 15) << 24;
        *(lpIA44toAYUVLookup + dwIndex) = dwYUVArray[dwPaletteIndex] + dwAlpha;
    }

    // Calculate a linear pointer to the NVMC surface created by DShow.
    // We use this surface to store the NVMCFRAMEDATA structure.
    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVMCSurface;
    lpNvMCFrameData = (LPNVMCFRAMEDATA)VIDMEM_ADDR(pSurf_lcl->lpGbl->fpVidMem);
    dwSubpicBuffer = lpNvMCFrameData->dwDXVASubpicBuffer;
    dwSubpicStride = lpNvMCFrameData->dwDXVASubpicStride;

    // Finally, use this new lookup table to re-convert the last IA44 bitmap
    // to AYUV format and copy it into the decompressed section of our NVSP
    // surface.  (Note that dwDstStride is in DWord units, not Byte units.)
    if (dwSubpicBuffer) {
        lpSrc = (LPBYTE)dwSubpicBuffer;
        for (dwY = 0; dwY < dwDstHeight; dwY++) {
            dwSrcOffset = dwY * dwSubpicStride;
            dwDstOffset = dwY * dwDstStride;
            for (dwX = 0; dwX < dwDstWidth; dwX++) {
                *(lpDst + dwDstOffset)
                    = *(lpIA44toAYUVLookup + *(lpSrc + dwSrcOffset));
                dwSrcOffset++;
                dwDstOffset++;
            }
        }
    }

    NvReleaseSemaphore(pDriverData);
    return DD_OK;
}  // nvRenderGetYUVPalette


/*
 * nvRenderGetIA44Surface
 *
 * Private function called by nvRenderMoComp.
 * Takes the IA44 subpicture bitmap provided by the decoder and uses it to generate
 * a new subpicture bitmap in NV AYUV format.
 *
 */
DWORD __stdcall nvRenderGetIA44Surface(LPDDHAL_RENDERMOCOMPDATA lpRMCData, DWORD dwRenderIndex)
{
    LPDXVA_BufferDescription    lpIA44Header;
    LPDDMCBUFFERINFO            lpIA44Buffer;
    LPBYTE                      lpIA44Linear;
    DWORD   dwX, dwY;
    LPDDRAWI_DDRAWSURFACE_LCL   lpDstSurface;
    LPDWORD                     lpDst;
    DWORD                       dwDstStride;
    DWORD                       dwDstWidth, dwDstHeight;
    DWORD                       dwSrcOffset, dwDstOffset;
    LPBYTE                      lpSrc;
    LPDWORD                     lpIA44toAYUVLookup;
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    LPNVMCFRAMEDATA             lpNvMCFrameData;
    DWORD                       dwSubpicBuffer, dwSubpicStride;

    // Get pDriverData pointer.
    nvSetDriverDataPtrFromDDGbl(lpRMCData->lpDD->lpGbl);

    // Calculate pointer to decompressed section of our NVSP surface.
    lpDstSurface = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVSPSurface;
    dwDstWidth   = (DWORD)lpDstSurface->lpGbl->wWidth;
    dwDstHeight  = (DWORD)lpDstSurface->lpGbl->wHeight;
    dwDstStride  = (DWORD)lpDstSurface->lpGbl->lPitch;
    lpDst        = (LPDWORD)(nvGetLinearAddress(lpDstSurface)
                             + 2 * dwDstStride * dwDstHeight);
    memset(lpDst, 0, dwDstHeight * dwDstStride * 4);

    // Get pointer to the IA44 buffer header from lpInputData.
    lpIA44Header = (LPDXVA_BufferDescription)lpRMCData->lpInputData;
    lpIA44Header += dwRenderIndex;

    // Get pointer to the IA44 surface data.
    lpIA44Buffer = lpRMCData->lpBufferInfo + dwRenderIndex;
    lpIA44Linear = (LPBYTE)nvGetLinearAddress(lpIA44Buffer->lpCompSurface)
                       + lpIA44Buffer->dwDataOffset;

    // Get pointer to our IA44 to AYUV lookup table.
    lpIA44toAYUVLookup = (LPDWORD)(pDriverData->dwDXVAConvertBuffer + LOOKUP_TABLE_OFFSET);

    // Calculate a linear pointer to the NVMC surface created by DShow.
    // We use this surface to store the NVMCFRAMEDATA structure.
    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVMCSurface;
    lpNvMCFrameData = (LPNVMCFRAMEDATA)VIDMEM_ADDR(pSurf_lcl->lpGbl->fpVidMem);

    // Record subpicture linear address and stride for other functions.
    lpNvMCFrameData->dwDXVASubpicBuffer = (DWORD)lpIA44Linear;
    lpNvMCFrameData->dwDXVASubpicStride = lpIA44Header->dwStride;
    dwSubpicBuffer = lpNvMCFrameData->dwDXVASubpicBuffer;
    dwSubpicStride = lpNvMCFrameData->dwDXVASubpicStride;

    // Finally, use our lookup table to convert this IA44 bitmap to AYUV format
    // and copy it into the decompressed section of our NVSP surface.  (Note
    // that dwDstStride is in DWord units, not Byte units.)
    lpSrc = (LPBYTE)dwSubpicBuffer;
    for (dwY = 0; dwY < dwDstHeight; dwY++) {
        dwSrcOffset = dwY * dwSubpicStride;
        dwDstOffset = dwY * dwDstStride;
        for (dwX = 0; dwX < dwDstWidth; dwX++) {
            *(lpDst + dwDstOffset)
                = *(lpIA44toAYUVLookup + *(lpSrc + dwSrcOffset));
            dwSrcOffset++;
            dwDstOffset++;
        }
    }

    // If back-end alpha blending  enabled, merge this graphic with the frame
    // currently being displayed.
    if (pDriverData->dwDXVAFlags & DXVA_BACK_END_ALPHA_ENABLED)
        nvDXVABackEndAlphaBlend(getDC()->flipOverlayRecord.fpFlipTo);

    NvReleaseSemaphore(pDriverData);
    return DD_OK;
}  // nvRenderGetIA44Surface


/*
 * nvRenderAlphaBlendCombination
 *
 * Private function called by nvRenderMoComp.
 * Alpha blends subpicture bitmap into a decoded video frame.
 *
 */
DWORD __stdcall nvRenderAlphaBlendCombination(LPDDHAL_RENDERMOCOMPDATA lpRMCData, DWORD dwRenderIndex)
{
    LPDXVA_BufferDescription    lpAlphaHeader;
    LPDDMCBUFFERINFO            lpAlphaBuffer;
    LPBYTE                      lpAlphaLinear;
    LPDXVA_BlendCombination     lpDXVABlend;
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    LPNVMCFRAMEDATA             lpNvMCFrameData;

    // Get pDriverData pointer.
    nvSetDriverDataPtrFromDDGbl(lpRMCData->lpDD->lpGbl);

    // Get pointer to NVMC surface with FrameData info.
    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVMCSurface;
    lpNvMCFrameData = (LPNVMCFRAMEDATA) VIDMEM_ADDR(pSurf_lcl->lpGbl->fpVidMem);

    // Get pointer to the Alpha Blend Combination buffer header from lpInputData.
    lpAlphaHeader = (LPDXVA_BufferDescription)lpRMCData->lpInputData;
    lpAlphaHeader += dwRenderIndex;

    // Get pointer to the Alpha Blend Combination surface data.
    lpAlphaBuffer = lpRMCData->lpBufferInfo + dwRenderIndex;
    lpAlphaLinear = nvGetLinearAddress(lpAlphaBuffer->lpCompSurface)
                       + lpAlphaBuffer->dwDataOffset;
    lpDXVABlend = (LPDXVA_BlendCombination)lpAlphaLinear;

    // If Back End alpha blending is selected, we just store the information
    // from the DXVABlendCombination structure for later when we decode or Flip.
    if (pDriverData->dwDXVAFlags & DXVA_BACK_END_ALPHA_SELECTED) {

        // Store new back-end blend parameters in our NVMC structure.
        lpNvMCFrameData->rcGraphicSourceRect      = lpDXVABlend->GraphicSourceRect;
        lpNvMCFrameData->rcGraphicDestinationRect = lpDXVABlend->GraphicDestinationRect;
        lpNvMCFrameData->bBlendOn                 = lpDXVABlend->bBlendOn;

        // If bBlendOn, set blend enabled flag and blend graphic into the current frame.
        if (lpDXVABlend->bBlendOn) {
            nvDXVABackEndAlphaBlend(getDC()->flipOverlayRecord.fpFlipTo);
            pDriverData->dwDXVAFlags |= DXVA_BACK_END_ALPHA_ENABLED;
        }
        else {
            pDriverData->dwDXVAFlags &= ~DXVA_BACK_END_ALPHA_ENABLED;
        }
    }

    // Else Front End alpha blending is selected, and we use the Execute
    // function to perform it on the selected frame.
    else {
        // We use the newer EXECUTE_DXVA_ALPHA_BLENDING function to do the
        // blending from the source buffer to the destination.
        nvMoCompExecute(lpNvMCFrameData->dwMCMultiMonID,
                        EXECUTE_DXVA_ALPHA_BLENDING,
                        (LPVOID)lpDXVABlend,
                        sizeof(DDHAL_RENDERMOCOMPDATA),
                        dwRenderIndex);
    }

    NvReleaseSemaphore(pDriverData);
    return DD_OK;
}  // nvRenderAlphaBlendCombination


/*
 * nvMoCompExecute
 *
 * Performs motion compensation on a portion of a new frame
 * (same functionality as nvRenderMoComp() but called directly by decoder as an
 *  interim Win9x interface solution until the HVA interface becomes available on Win9x)
 *
 * Functions supported: 0 = perform motion compensation operation
 *                      1 = temporally filter fields in destination frame
 *                      2 = decompress subpicture surface
 *                      3 = composite decompressed subpicture surface with destination surface
 *                      4 = display overlay surface
 *                      5 = format convert overlay surface
 *                      6 = perform non-prebiased motion compensation operation
 *
 */
DWORD __stdcall nvMoCompExecute(DWORD dwMCMultiMonID, DWORD dwFunction, LPVOID lpInputData, DWORD dwInputDataSize, DWORD dwSurfaceIndex)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl;
    DWORD                       status, dwIndex;
    DWORD                       dwBlockSize;
    LPNVMCFRAMEDATA             lpNvMCFrameData;
    LPNVMCSURFACEFLAGS          lpDstSurfaceFlags;
    LPNVMCSURFACEFLAGS          lpSurfaceFlags;

    // Set up our multimon environment
#ifdef WINNT
    // For Win2K, get pDriverData from lpDD passed as the MultiMon parameter.
    nvSetDriverDataPtrFromDDGbl(((LPDDRAWI_DIRECTDRAW_LCL)dwMCMultiMonID)->lpGbl);
#else
    pDXShare = (DISPDRVDIRECTXCOMMON *)(dwMCMultiMonID);
    NvAcquireSemaphore((GLOBALDATA *) (pDXShare->pDirectXData));
    pDriverData = (CDriverContext *) (pDXShare->pDirectXData);
#endif

    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        if (!nvEnable32(NULL)) {
            NvReleaseSemaphore(pDriverData);
            return (DDERR_SURFACELOST);
        }
        pDriverData->dwMostRecentHWUser = MODULE_ID_NONE;
    }

    // Let D3D code know that we have touched NV
    pDriverData->TwoDRenderingOccurred = 1;

    if (pDriverData->dwMostRecentHWUser != MODULE_ID_DDRAW) {
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            if (!(nvInitKelvinForMoComp())) {
                NvReleaseSemaphore(pDriverData);
                return (DDERR_GENERIC);
            }
        }
        else {
            if (!(nvInitCelsiusForMoComp())) {
                NvReleaseSemaphore(pDriverData);
                return (DDERR_GENERIC);
            }
        }
    }

    // Check if this is the first call on a new frame/field
    if (pDriverData->bMCNewFrame) {

        pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVMCSurface;
        lpNvMCFrameData = (LPNVMCFRAMEDATA) VIDMEM_ADDR(pSurf_lcl->lpGbl->fpVidMem);

        // Check if decoder updated it's data in the surface
        if (lpNvMCFrameData->bMCDestinationSurfaceIndex == 255) {
            NvReleaseSemaphore(pDriverData);
            return(DDERR_INVALIDPARAMS);
        }

        pDriverData->bMCNewFrame = FALSE;

        pDriverData->bMCPictureStructure = lpNvMCFrameData->bMCPictureStructure;
        pDriverData->bMCPictureCodingType = lpNvMCFrameData->bMCPictureCodingType;
        pDriverData->bMCTopFieldFirst = lpNvMCFrameData->bMCTopFieldFirst;
        pDriverData->bMCSecondField = lpNvMCFrameData->bMCSecondField;

        if (lpNvMCFrameData->bMCDestinationSurfaceIndex < 8)
            pDriverData->dwMCDestinationSurface = pDriverData->dwMCNV12Surface[lpNvMCFrameData->bMCDestinationSurfaceIndex];
        else
            pDriverData->dwMCDestinationSurface = pDriverData->dwMCNV12Surface[0];

        // Check for mode switches and full screen DOS interruptions
        if (pDriverData->dwMCDestinationSurface == 0) {
            NvReleaseSemaphore(pDriverData);
            return (DDERR_SURFACELOST);
        }

        if (lpNvMCFrameData->bMCForwardSurfaceIndex < 8)
            pDriverData->dwMCForwardSurface = pDriverData->dwMCNV12Surface[lpNvMCFrameData->bMCForwardSurfaceIndex];
        else
            pDriverData->dwMCForwardSurface = pDriverData->dwMCNV12Surface[0];

        if (pDriverData->bMCPictureCodingType == PICTURE_TYPE_B) {
            if (lpNvMCFrameData->bMCBackwardSurfaceIndex < 8)
                pDriverData->dwMCBackwardSurface = pDriverData->dwMCNV12Surface[lpNvMCFrameData->bMCBackwardSurfaceIndex];
            else
                pDriverData->dwMCBackwardSurface = pDriverData->dwMCNV12Surface[0];
            pDriverData->dwMCDualPrimeSurface = pDriverData->dwMCForwardSurface; // necessary for broken HDTV tuner
        } else {
            // For self referencing field structured P fields
            pDriverData->dwMCBackwardSurface = pDriverData->dwMCDestinationSurface;
            pDriverData->dwMCDualPrimeSurface = pDriverData->dwMCForwardSurface;
        }

        // Make sure none of the surface indexes were for surfaces that were never created.
        if (!pDriverData->dwMCDestinationSurface)
            pDriverData->dwMCDestinationSurface  = pDriverData->dwMCNV12Surface[0];
        if (!pDriverData->dwMCForwardSurface)
            pDriverData->dwMCForwardSurface      = pDriverData->dwMCNV12Surface[0];
        if (!pDriverData->dwMCBackwardSurface)
                pDriverData->dwMCBackwardSurface = pDriverData->dwMCNV12Surface[0];
        if (!pDriverData->dwMCDualPrimeSurface)
            pDriverData->dwMCDualPrimeSurface    = pDriverData->dwMCNV12Surface[0];

        pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
        pSurf_gbl = pSurf_lcl->lpGbl;

        pDriverData->dwMCDestinationSurfaceOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) + NV097_NO_OPERATION | 0x40000);
            nvPushData(1, 0);
            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) + NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
            nvPushData(3, pDriverData->dwMCDestinationSurfaceOffset);
            nvPusherAdjust(4);

            nvPusherStart(TRUE);
        } else {
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) + NV056_NO_OPERATION | 0x40000);
            nvPushData(1, 0);
            nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) + NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
            nvPushData(3, pDriverData->dwMCDestinationSurfaceOffset);
            nvPusherAdjust(4);

            nvPusherStart(TRUE);
        }

        // Initialize frame specific data if this is indeed a new frame
        if ((dwFunction == EXECUTE_MOTION_COMPENSATION) ||
            (dwFunction == EXECUTE_NON_PREBIASED_MOTION_COMPENSATION)) {

            lpDstSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

            while ((lpDstSurfaceFlags->dwMCSurfaceBase != 0) &&
                   (lpDstSurfaceFlags->dwMCSurfaceBase != pSurf_gbl->fpVidMem))
                lpDstSurfaceFlags++;

            if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) {
                if (pDriverData->dwMCMostRecentlyDecodedSurfaceBase != pSurf_gbl->fpVidMem)
                    lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted = 0;
                else if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted == 15)
                    lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted = 0;
            } else if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD) {
                if ((pDriverData->dwMCMostRecentlyDecodedSurfaceBase != pSurf_gbl->fpVidMem) ||
                    (lpDstSurfaceFlags->bMCPictureStructure != pDriverData->bMCPictureStructure))
                    lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted &= ~3;
                else if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted == 3)
                    lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted &= ~3;
            } else {
                if ((pDriverData->dwMCMostRecentlyDecodedSurfaceBase != pSurf_gbl->fpVidMem) ||
                    (lpDstSurfaceFlags->bMCPictureStructure != pDriverData->bMCPictureStructure))
                    lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted &= ~12;
                else if (lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted == 12)
                    lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted &= ~12;
            }

            // Initialize surface flags in video memory
            lpDstSurfaceFlags->bMCPictureStructure = pDriverData->bMCPictureStructure;
            lpDstSurfaceFlags->bMCPictureCodingType = pDriverData->bMCPictureCodingType;
            lpDstSurfaceFlags->bMCTopFieldFirst = pDriverData->bMCTopFieldFirst;
            lpDstSurfaceFlags->bMCSecondField = pDriverData->bMCSecondField;
            lpDstSurfaceFlags->bMCFrameType = 0;
            lpDstSurfaceFlags->bMCFrameIsFiltered = FALSE;
            lpDstSurfaceFlags->bMCFrameIsComposited = FALSE;

            pDriverData->dwMCMostRecentlyDecodedSurfaceBase = pSurf_gbl->fpVidMem;
            pDriverData->bMCMostRecentlyDecodedPictureStructure = pDriverData->bMCPictureStructure;

            // Make sure this surface is not currently visible
            if (pSurf_lcl->lpGbl->wWidth < 1024) { // If DVD
                while (nvMoCompFrameStatus (pSurf_lcl->lpGbl->fpVidMem) != DD_OK)
                    NV_SLEEP1; // Don't change (bmac)
            } // else { // If HDTV (don't even check, especially on NV11)
//                while (nvMoCompFlipStatus(pSurf_lcl->lpGbl->fpVidMem) != DD_OK)
//                    NV_SLEEP; // Don't change (bmac)
//            }
            
            if (pDriverData->bMCPictureCodingType != PICTURE_TYPE_I) {
                pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCForwardSurface;

                lpSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

                while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
                       (lpSurfaceFlags->dwMCSurfaceBase != pSurf_lcl->lpGbl->fpVidMem))
                    lpSurfaceFlags++;

                pDriverData->bMCForwardPictureStructure = lpSurfaceFlags->bMCPictureStructure;

                pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface;

                lpSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

                while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
                       (lpSurfaceFlags->dwMCSurfaceBase != pSurf_lcl->lpGbl->fpVidMem))
                    lpSurfaceFlags++;

                pDriverData->bMCBackwardPictureStructure = lpSurfaceFlags->bMCPictureStructure;
            }
        }

    } else {

        pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVMCSurface;
        lpNvMCFrameData = (LPNVMCFRAMEDATA) VIDMEM_ADDR(pSurf_lcl->lpGbl->fpVidMem);

        // Check if decoder updated it's data in the surface
        if (lpNvMCFrameData->bMCDestinationSurfaceIndex == 255) {
            NvReleaseSemaphore(pDriverData);
            return(DDERR_INVALIDPARAMS);
            }

        pDriverData->bMCPictureStructure = lpNvMCFrameData->bMCPictureStructure;
        pDriverData->bMCPictureCodingType = lpNvMCFrameData->bMCPictureCodingType;
        pDriverData->bMCTopFieldFirst = lpNvMCFrameData->bMCTopFieldFirst;
        pDriverData->bMCSecondField = lpNvMCFrameData->bMCSecondField;

        if (lpNvMCFrameData->bMCDestinationSurfaceIndex < 8)
            pDriverData->dwMCDestinationSurface = pDriverData->dwMCNV12Surface[lpNvMCFrameData->bMCDestinationSurfaceIndex];
        else
            pDriverData->dwMCDestinationSurface = pDriverData->dwMCNV12Surface[0];

        // Check for mode switches and full screen DOS interruptions
        if (pDriverData->dwMCDestinationSurface == 0) {
            NvReleaseSemaphore(pDriverData);
            return (DDERR_SURFACELOST);
        }
    }

    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    pSurf_gbl = pSurf_lcl->lpGbl;

    pDriverData->dwMCDestinationSurfaceOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

    lpDstSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

    while ((lpDstSurfaceFlags->dwMCSurfaceBase != 0) &&
           (lpDstSurfaceFlags->dwMCSurfaceBase != pSurf_gbl->fpVidMem))
        lpDstSurfaceFlags++;

    pDriverData->bMCCurrentExecuteFunction = (BYTE)dwFunction;

    if ((dwFunction == EXECUTE_MOTION_COMPENSATION) ||
        (dwFunction == EXECUTE_NON_PREBIASED_MOTION_COMPENSATION)) {
        LPNVDECODEMACROBLOCK pMacroblocks = (LPNVDECODEMACROBLOCK)lpInputData;
        long dwNumMacroblocks;
        long macroblockIncr = 256;

        // Update reference count on previous IDCT surface to indicate we have switched away from it
        if (pDriverData->dwMCIDCTSurface != 0) {
            for (dwIndex=0; dwIndex<4; dwIndex++) {
                if (pDriverData->dwMCIDCTSurface == pDriverData->dwMCNVIDSurface[dwIndex]) {
                    break;
                }
            }

            if (dwIndex >= 4)
                dwIndex = 0;

            if ((dwIndex < 4) && (dwSurfaceIndex != dwIndex)) {
                pDriverData->dwMCNVIDSurfaceReferenceCount[dwIndex] = getDC()->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);
                nvPusherStart(TRUE);
            }
        }

        if (dwSurfaceIndex < 4)
            pDriverData->dwMCIDCTSurface = pDriverData->dwMCNVIDSurface[dwSurfaceIndex];
        else
            pDriverData->dwMCIDCTSurface = pDriverData->dwMCNVIDSurface[0];

        pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCForwardSurface;
        pSurf_gbl = pSurf_lcl->lpGbl;

        pDriverData->dwMCForwardSurfaceOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

        pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface;
        pSurf_gbl = pSurf_lcl->lpGbl;

        pDriverData->dwMCBackwardSurfaceOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

        pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCIDCTSurface;
        pSurf_gbl = pSurf_lcl->lpGbl;

        if (pSurf_gbl->ddpfSurface.dwFourCC != FOURCC_NVID) {
            NvReleaseSemaphore(pDriverData);
            return (DDERR_INVALIDPARAMS);
        }

        dwBlockSize = pSurf_gbl->lPitch * pSurf_gbl->wHeight;
        dwBlockSize |= 0xFF; // Context DMA must end on 256 byte boundary (enough extra memory was allocated for this correction)


        for (dwIndex=0; dwIndex<4; dwIndex++) {
            if (pSurf_gbl->fpVidMem == pDriverData->dwMCIDCTAGPSurfaceBase[dwIndex]) {
                break;
            }
        }

        if (dwIndex >= 4)
            dwIndex = 0;

        if (pDriverData->dwMCIDCTAGPCtxDmaSize[dwIndex] == 0) {
            pDriverData->dwMCCurrentCelsiusIDCTCtxDma = 0;
            status = NvRmAllocContextDma(pDriverData->dwRootHandle,
                                         NV_DD_DMA_FLOATING_MC_IDCT0_CONTEXT_DMA_FROM_MEMORY+dwIndex,
                                         NV01_CONTEXT_DMA,
                                         DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_ONLY) |
                                         DRF_DEF(OS03, _FLAGS, _LOCKED, _ALWAYS) |
                                         DRF_DEF(OS03, _FLAGS, _COHERENCY, _CACHED),
                                         (PVOID) VIDMEM_ADDR(pSurf_gbl->fpVidMem),
                                         dwBlockSize);
            if (status != NVOS03_STATUS_SUCCESS) {
                NvReleaseSemaphore(pDriverData);
                return (DDERR_SURFACELOST);
            }

            pDriverData->dwMCIDCTAGPCtxDmaSize[dwIndex] = dwBlockSize;
        }
        // Update IDCT context Dma
        if (pDriverData->dwMCCurrentCelsiusIDCTCtxDma != (NV_DD_DMA_FLOATING_MC_IDCT0_CONTEXT_DMA_FROM_MEMORY+dwIndex)) {
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) + NV097_SET_CONTEXT_DMA_B | 0x40000);
                nvPushData(1, NV_DD_DMA_FLOATING_MC_IDCT0_CONTEXT_DMA_FROM_MEMORY+dwIndex);
                nvPusherAdjust(2);
                nvPusherStart(TRUE);
            } else {
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) + NV056_SET_CONTEXT_DMA_B | 0x40000);
                nvPushData(1, NV_DD_DMA_FLOATING_MC_IDCT0_CONTEXT_DMA_FROM_MEMORY+dwIndex);
                nvPusherAdjust(2);
                nvPusherStart(TRUE);
            }
            pDriverData->dwMCCurrentCelsiusIDCTCtxDma = NV_DD_DMA_FLOATING_MC_IDCT0_CONTEXT_DMA_FROM_MEMORY+dwIndex;
        }

        dwNumMacroblocks = dwInputDataSize / sizeof(NVDECODEMACROBLOCK);

        if ((dwNumMacroblocks * sizeof(NVDECODEMACROBLOCK)) != dwInputDataSize) {
            NvReleaseSemaphore(pDriverData);
            return (DDERR_INVALIDPARAMS);
        }

        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) {
                while (dwNumMacroblocks > 0) {
                    if (dwNumMacroblocks > macroblockIncr) {
                        if (!(nvMoCompProcessKelvinFrameMacroblocks(pMacroblocks,
                                                                    macroblockIncr,
                                                                    lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted))) {
                            NvReleaseSemaphore(pDriverData);
                            return (DDERR_GENERIC);
                        }
                    } else {
                        if (!(nvMoCompProcessKelvinFrameMacroblocks(pMacroblocks,
                                                                    dwNumMacroblocks,
                                                                    lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted))) {
                            NvReleaseSemaphore(pDriverData);
                            return (DDERR_GENERIC);
                        }
                    }
                    pMacroblocks += macroblockIncr;
                    dwNumMacroblocks -= macroblockIncr;
                }
            } else {
                while (dwNumMacroblocks > 0) {
                    if (dwNumMacroblocks > macroblockIncr) {
                        if (!(nvMoCompProcessKelvinFieldMacroblocks(pMacroblocks,
                                                                    macroblockIncr,
                                                                    lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted))) {
                            NvReleaseSemaphore(pDriverData);
                            return (DDERR_GENERIC);
                        }
                    } else {
                        if (!(nvMoCompProcessKelvinFieldMacroblocks(pMacroblocks,
                                                                    dwNumMacroblocks,
                                                                    lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted))) {
                            NvReleaseSemaphore(pDriverData);
                            return (DDERR_GENERIC);
                        }
                    }
                    pMacroblocks += macroblockIncr;
                    dwNumMacroblocks -= macroblockIncr;
                }
            }
        } else {
            if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) {
                while (dwNumMacroblocks > 0) {
                    if (dwNumMacroblocks > macroblockIncr) {
                        if (!(nvMoCompProcessCelsiusFrameMacroblocks(pMacroblocks,
                                                                     macroblockIncr,
                                                                     lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted))) {
                            NvReleaseSemaphore(pDriverData);
                            return (DDERR_GENERIC);
                        }
                    } else {
                        if (!(nvMoCompProcessCelsiusFrameMacroblocks(pMacroblocks,
                                                                     dwNumMacroblocks,
                                                                     lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted))) {
                            NvReleaseSemaphore(pDriverData);
                            return (DDERR_GENERIC);
                        }
                    }
                    pMacroblocks += macroblockIncr;
                    dwNumMacroblocks -= macroblockIncr;
                }
            } else {
                while (dwNumMacroblocks > 0) {
                    if (dwNumMacroblocks > macroblockIncr) {
                        if (!(nvMoCompProcessCelsiusFieldMacroblocks(pMacroblocks,
                                                                     macroblockIncr,
                                                                     lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted))) {
                            NvReleaseSemaphore(pDriverData);
                            return (DDERR_GENERIC);
                        }
                    } else {
                        if (!(nvMoCompProcessCelsiusFieldMacroblocks(pMacroblocks,
                                                                     dwNumMacroblocks,
                                                                     lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted))) {
                            NvReleaseSemaphore(pDriverData);
                            return (DDERR_GENERIC);
                        }
                    }
                    pMacroblocks += macroblockIncr;
                    dwNumMacroblocks -= macroblockIncr;
                }
            }
        }

        // Update reference count in case we get a status query
        lpDstSurfaceFlags->dwMCMotionCompReferenceCount = getDC()->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);
        nvPusherStart(TRUE);

    } else if (dwFunction == EXECUTE_TEMPORAL_FILTER) { // function 1 = temporally filter destination surface
        LPNVMCFILTERDATA lpNvMCFilterData = (LPNVMCFILTERDATA)lpInputData;

        // Only allow temporal filter changes if temporal filtering is allowed.
        // Not allowed if bMCTemporalFilterDisabled == 2 (no temporal filter area in NV12 buffers.)
        if (pDriverData->bMCTemporalFilterDisabled < 2) {
            if (lpNvMCFilterData->bMCFilterOptions & TEMPORAL_FILTER_DISABLE_ON_ALL_SURFACES)
                pDriverData->bMCTemporalFilterDisabled = TRUE;
            else
                pDriverData->bMCTemporalFilterDisabled = FALSE;

            if (lpNvMCFilterData->bMCFilterOptions & TEMPORAL_FILTER_DISABLE_ON_SINGLE_SURFACE)
                pDriverData->nvMCSurfaceFlags[dwSurfaceIndex].bMCFrameType |= TEMPORAL_FILTER_DISABLE_ON_SINGLE_SURFACE;

            pDriverData->bMCPercentCurrentField = lpNvMCFilterData->bMCCurrentFieldCombinationFactor;
        }

        NvReleaseSemaphore(pDriverData);
        return (DD_OK);

    } else if (dwFunction == EXECUTE_SUBPICTURE_DECOMPRESSION) { // function 2 = decompress subpicture surface
        DWORD status = nvMoCompDecompressSubpicture(lpInputData, dwSurfaceIndex);
        NvReleaseSemaphore(pDriverData);
        return (status);

    } else if (dwFunction == EXECUTE_SUBPICTURE_COMPOSITING) { // function 3 = composite subpicture

        DWORD status = nvMoCompCompositeSubpicture(lpInputData, dwSurfaceIndex);
        NvReleaseSemaphore(pDriverData);
        return (status);

    } else if (dwFunction == EXECUTE_DISPLAY_OVERLAY_SURFACE) { // function 4 = display overlay surface

        DWORD status = nvMoCompDisplaySurface(lpInputData, dwSurfaceIndex);
        NvReleaseSemaphore(pDriverData);
        return (status);

    } else if (dwFunction == EXECUTE_FORMAT_CONVERT_OVERLAY_SURFACE) {  // function 5 = format convert overlay surface

        pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
        pSurf_gbl = pSurf_lcl->lpGbl;

        lpDstSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

        while ((lpDstSurfaceFlags->dwMCSurfaceBase != 0) &&
               (lpDstSurfaceFlags->dwMCSurfaceBase != pSurf_gbl->fpVidMem))
            lpDstSurfaceFlags++;

        lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted = 0;
        lpDstSurfaceFlags->bMCPictureStructure = pDriverData->bMCPictureStructure;
        pDriverData->dwMCMostRecentlyDecodedSurfaceBase = pSurf_gbl->fpVidMem;
        pDriverData->bMCMostRecentlyDecodedPictureStructure = pDriverData->bMCPictureStructure;

        nvMoCompConvertSurfaceFormat(pDriverData->dwMCMostRecentlyDecodedSurfaceBase, TRUE, 15);
    }

    else if (dwFunction == EXECUTE_DXVA_ALPHA_BLENDING) {
        DWORD status = nvDXVACompositeSubpicture(lpInputData, dwSurfaceIndex);
        NvReleaseSemaphore(pDriverData);
        return (status);
    }



    NvReleaseSemaphore(pDriverData);
    return (DD_OK);

} /* nvMoCompExecute */


/*
 * nvQueryMoCompStatus
 *
 * Returns current motion comp status.  Does not currently associate status with
 * a particular surface.
 *
 */
DWORD __stdcall nvQueryMoCompStatus( LPDDHAL_QUERYMOCOMPSTATUSDATA lpQMCSData)
{
    LPNVMCSURFACEFLAGS          lpSurfaceFlags;
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;

    nvSetDriverDataPtrFromDDGbl (lpQMCSData->lpDD->lpGbl);

    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        if (!nvEnable32(lpQMCSData->lpDD->lpGbl)) {
            NvReleaseSemaphore(pDriverData);
            lpQMCSData->ddRVal = DDERR_SURFACELOST;
            return (DDHAL_DRIVER_HANDLED);
        }
        if (pDriverData->dwMostRecentHWUser != MODULE_ID_DDRAW) {
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                if (!(nvInitKelvinForMoComp())) {
                    NvReleaseSemaphore(pDriverData);
                    lpQMCSData->ddRVal = DDERR_CURRENTLYNOTAVAIL;
                    return(DDHAL_DRIVER_HANDLED);
                }
            }
            else {
                if (!(nvInitCelsiusForMoComp())) {
                    NvReleaseSemaphore(pDriverData);
                    lpQMCSData->ddRVal = DDERR_CURRENTLYNOTAVAIL;
                    return(DDHAL_DRIVER_HANDLED);
                }
            }
        }
    }

    // Assume return state is OK unless we find out otherwise
    lpQMCSData->ddRVal = DD_OK;

    // Do different status checks depending on surface FourCC type.
    switch (lpQMCSData->lpSurface->lpGbl->ddpfSurface.dwFourCC) {

    case FOURCC_NV12:

        // Get flags for this NV12 surface.
        lpSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];
        while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
               (lpSurfaceFlags->dwMCSurfaceBase != lpQMCSData->lpSurface->lpGbl->fpVidMem)) {
            lpSurfaceFlags++;
        }

        // If this NV12 surface is the last surface decoded into, check to see if the motion comp
        // operation is done before you allow it to be written or read.
        if (lpQMCSData->lpSurface == (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface) {
            if (lpQMCSData->dwFlags & DDMCQUERY_READ) {
                if (!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                               lpSurfaceFlags->dwMCMotionCompReferenceCount,
                                               0)) {
                    lpQMCSData->ddRVal = DDERR_WASSTILLDRAWING;
                }
            }
            else {
                if ((!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                                lpSurfaceFlags->dwMCMotionCompReferenceCount,
                                                0))
                    ||
                    (!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                                lpSurfaceFlags->dwMCFormatCnvReferenceCount,
                                                0))) {
                    lpQMCSData->ddRVal = DDERR_WASSTILLDRAWING;
                }
            }
        }

        // Else if this NV12 surface is being used as a reference frame, check to see if the motion comp
        // operation is done before you allow it to be written to.
        else if ((lpQMCSData->lpSurface == (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCForwardSurface) ||
                 (lpQMCSData->lpSurface == (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface)) {
            if (!(lpQMCSData->dwFlags & DDMCQUERY_READ)) {
                if (!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                               lpSurfaceFlags->dwMCMotionCompReferenceCount,
                                               0)) {
                    lpQMCSData->ddRVal = DDERR_WASSTILLDRAWING;
                }
            }
        }
        // Else  check the surface is in the middle of compositing sub-picture
        else  if (lpSurfaceFlags->bMCFrameIsComposited) {
            if(!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                lpSurfaceFlags->dwMCCompositeReferenceCount, 0))
            {
           
               lpQMCSData->ddRVal = DDERR_WASSTILLDRAWING;
 

            }

        }
 
        break;

    case FOURCC_NVID:

        // If this NVID surface is the one last used for a motion comp operation, check to see
        // if the motion comp operation is done before you allow it to be reused.
        if ((DWORD)lpQMCSData->lpSurface == pDriverData->dwMCIDCTSurface) {

            // Get flags for the corresponding NV12 surface.
            pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
            lpSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];
            while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
                   (lpSurfaceFlags->dwMCSurfaceBase != pSurf_lcl->lpGbl->fpVidMem)) {
                lpSurfaceFlags++;
            }

            if (!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                           lpSurfaceFlags->dwMCMotionCompReferenceCount,
                                           0)) {
                lpQMCSData->ddRVal = DDERR_WASSTILLDRAWING;
            }
        }
        break;
    }

    NvReleaseSemaphore(pDriverData);
    return (DDHAL_DRIVER_HANDLED);

} /* nvQueryMoCompStatus */


/*
 * nvDestroyMoComp
 *
 * Destroys anything temporarily created for motion comp operations.
 *
 */
DWORD __stdcall nvDestroyMoComp( LPDDHAL_DESTROYMOCOMPDATA lpDMCData)
{
    nvSetDriverDataPtrFromDDGbl(lpDMCData->lpDD->lpGbl);

    // If a conversion buffer was created by nvCreateMoComp, free it now.
    if (pDriverData->dwDXVAConvertBuffer) {
        GlobalFree((HGLOBAL)pDriverData->dwDXVAConvertBuffer);
        pDriverData->dwDXVAConvertBuffer = 0;
    }

    // Reset some variables.
    pDriverData->dwDXVAFlags &= DXVA_BACK_END_ALPHA_ENABLED;    // don't reset this flag, we may be going through a mode switch

    lpDMCData->ddRVal = DD_OK;
    NvReleaseSemaphore(pDriverData);
    return (DDHAL_DRIVER_HANDLED);

} /* nvDestroyMoComp */


/*
 * nvGetMoCompDriverInfo
 *
 * Initialize Motion Comp Functionality HAL Callbacks
 *
 */
void __stdcall nvGetMoCompDriverInfo(LPDDHAL_GETDRIVERINFODATA lpData)
{
    DDHAL_DDMOTIONCOMPCALLBACKS moCompCB;
    DWORD dwSize = lpData->dwExpectedSize;

    // Check to see whether DXVAEnable was set in the registry.
    // If not, return an error and don't fill in the function table.
    // Note: dwDXVAFlags is set by D3DReadRegistry.
    if (!(pDriverData->dwDXVAFlags & DXVA_ENABLED_IN_REGISTRY)) {
        lpData->ddRVal = DDERR_CURRENTLYNOTAVAIL;
        return;
    }

    global.dwDXRuntimeVersion = max (global.dwDXRuntimeVersion, 0x0600);

    if ( sizeof(moCompCB) < dwSize )
        dwSize = sizeof(moCompCB);

    lpData->dwActualSize = sizeof(moCompCB);
    memset(&moCompCB, 0, dwSize);

    moCompCB.dwSize = dwSize;

    moCompCB.dwFlags = DDHAL_MOCOMP32_GETGUIDS |
                       DDHAL_MOCOMP32_GETFORMATS |
                       DDHAL_MOCOMP32_CREATE |
                       DDHAL_MOCOMP32_GETCOMPBUFFINFO |
                       DDHAL_MOCOMP32_GETINTERNALINFO |
                       DDHAL_MOCOMP32_BEGINFRAME |
                       DDHAL_MOCOMP32_ENDFRAME |
                       DDHAL_MOCOMP32_RENDER |
                       DDHAL_MOCOMP32_QUERYSTATUS |
                       DDHAL_MOCOMP32_DESTROY;

    moCompCB.GetMoCompGuids = nvGetMoCompGuids;
    moCompCB.GetMoCompFormats = nvGetMoCompFormats;
    moCompCB.CreateMoComp = nvCreateMoComp;
    moCompCB.GetMoCompBuffInfo = nvGetMoCompBuffInfo;
    moCompCB.GetInternalMoCompInfo = nvGetInternalMoCompInfo;
    moCompCB.BeginMoCompFrame = nvBeginMoCompFrame;
    moCompCB.EndMoCompFrame = nvEndMoCompFrame;
    moCompCB.RenderMoComp = nvRenderMoComp;
    moCompCB.QueryMoCompStatus = nvQueryMoCompStatus;
    moCompCB.DestroyMoComp = nvDestroyMoComp;

    memcpy(lpData->lpvData, &moCompCB, dwSize );

    lpData->ddRVal = DD_OK;

} /* nvGetMoCompDriverInfo */


/*
 * nvGetLinearAddress
 *
 * Return the linear address of a DDraw surface, depending on whether
 * it's in Local, NonLocal, or System memory.
 *
 */
LPBYTE __stdcall nvGetLinearAddress(LPDDRAWI_DDRAWSURFACE_LCL lpSurf)
{
    if (lpSurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) {
        if (lpSurf->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
            return (LPBYTE)AGPMEM_ADDR(lpSurf->lpGbl->fpVidMem);
        else
            return (LPBYTE)VIDMEM_ADDR(lpSurf->lpGbl->fpVidMem);
    }
    else
        return (LPBYTE)lpSurf->lpGbl->fpVidMem;
}  // nvGetLinearAddress


/*
 * nvDXVACompositeSubpicture
 *
 * Performs full or partial compositing of a decompressed subpicture surface to the destination overlay
 * surface with scaling.  This function does subpicture blending DXVA-style, blending from one NV12
 * surface to another, and allowing for scaling of the video image before the subpicture is blended in.
 *
 * Note that pDriverData must be set before calling this function.
 *
 */
DWORD __stdcall nvDXVACompositeSubpicture(LPVOID lpInputData, DWORD dwIndex)
{
    LPDXVA_BlendCombination     lpDXVABlend;
    LPDDRAWI_DDRAWSURFACE_LCL   pSrcSurf_lcl, pDstSurf_lcl, pSPSurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   pSrcSurf_gbl, pDstSurf_gbl, pSPSurf_gbl;
    LPNVMCSURFACEFLAGS          lpSrcSurfaceFlags, lpDstSurfaceFlags;
    DWORD                       dwBlockSize;
    DWORD                       dwSrcOffset, dwDstOffset, dwSPOffset;
    DWORD                       dwMixOffset;
    DWORD                       dwPitch422;
    DWORD                       dwSPSurfaceWidth, dwSPSurfaceHeight;
    DWORD                       dwDstSurfaceWidth, dwDstSurfaceHeight;
    int                         nPicSrcX, nPicSrcY, nPicSrcW, nPicSrcH;
    int                         nPicDstX, nPicDstY, nPicDstW, nPicDstH;
    int                         nSubSrcX, nSubSrcY, nSubSrcW, nSubSrcH;
    int                         nSubDstX, nSubDstY, nSubDstW, nSubDstH;
    WORD                        wDXVASrcIndex, wDXVADstIndex;
    BYTE                        bNVSrcIndex, bNVDstIndex;
    DDHAL_BLTDATA               BltData;
    RECTL                       SrcRect, DstRect;
    DWORD                       X0, Y0, X1, Y1;
    DWORD                       tmpVal;
    DWORD                       dwLumaOffset, dwChromaOffset;
    DWORD                       dwScaleX, dwScaleY;
    RECT                        rcPictureSourceRect;
    BYTE                        bScaled;

    // Get pointer to DXVA BlendCombination structure from lpInputData.
    lpDXVABlend = (LPDXVA_BlendCombination)lpInputData;

    // Pick up parameters from DXVA Blend structure.
    wDXVASrcIndex = lpDXVABlend->wPictureSourceIndex;
    wDXVADstIndex = lpDXVABlend->wBlendedDestinationIndex;

    rcPictureSourceRect.left   = lpDXVABlend->PictureSourceRect16thPel.left   >> 4;
    rcPictureSourceRect.top    = lpDXVABlend->PictureSourceRect16thPel.top    >> 4;
    rcPictureSourceRect.right  = lpDXVABlend->PictureSourceRect16thPel.right  >> 4;
    rcPictureSourceRect.bottom = lpDXVABlend->PictureSourceRect16thPel.bottom >> 4;

    nPicSrcX = rcPictureSourceRect.left;
    nPicSrcY = rcPictureSourceRect.top;
    nPicSrcW = rcPictureSourceRect.right  - rcPictureSourceRect.left;
    nPicSrcH = rcPictureSourceRect.bottom - rcPictureSourceRect.top;

    nPicDstX = lpDXVABlend->PictureDestinationRect.left;
    nPicDstY = lpDXVABlend->PictureDestinationRect.top;
    nPicDstW = lpDXVABlend->PictureDestinationRect.right
             - lpDXVABlend->PictureDestinationRect.left;
    nPicDstH = lpDXVABlend->PictureDestinationRect.bottom
             - lpDXVABlend->PictureDestinationRect.top;

    nSubSrcX = lpDXVABlend->GraphicSourceRect.left;
    nSubSrcY = lpDXVABlend->GraphicSourceRect.top;
    nSubSrcW = lpDXVABlend->GraphicSourceRect.right
             - lpDXVABlend->GraphicSourceRect.left;
    nSubSrcH = lpDXVABlend->GraphicSourceRect.bottom
             - lpDXVABlend->GraphicSourceRect.top;

    nSubDstX = lpDXVABlend->GraphicDestinationRect.left;
    nSubDstY = lpDXVABlend->GraphicDestinationRect.top;
    nSubDstW = lpDXVABlend->GraphicDestinationRect.right
             - lpDXVABlend->GraphicDestinationRect.left;
    nSubDstH = lpDXVABlend->GraphicDestinationRect.bottom
             - lpDXVABlend->GraphicDestinationRect.top;

    // Check parameters.
    if ((nSubSrcX <  0) ||
        (nSubSrcY <  0) ||
        (nSubSrcW <  0) ||
        (nSubSrcH <  0))
        return (DDERR_INVALIDPARAMS);

    if ((nPicDstX <  0) ||
        (nPicDstY <  0) ||
        (nPicDstW <= 0) ||
        (nPicDstH <= 0))
        return (DDERR_INVALIDPARAMS);

    // Convert DXVA buffer indexes into NV indexes.
    bNVSrcIndex = pDriverData->bDXVAIndexToNVIndex[wDXVASrcIndex];
    bNVDstIndex = pDriverData->bDXVAIndexToNVIndex[wDXVADstIndex];

    // Get pointers to source and dest NV12 surfaces and the subpicture NVSP surface.
    pSrcSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNV12Surface[bNVSrcIndex];
    pSrcSurf_gbl = pSrcSurf_lcl->lpGbl;
    pDstSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNV12Surface[bNVDstIndex];
    pDstSurf_gbl = pDstSurf_lcl->lpGbl;
    pSPSurf_lcl  = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVSPSurface;
    pSPSurf_gbl  = pSPSurf_lcl->lpGbl;

    // Get surface flags for source and dest.
    lpSrcSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];
    while ((lpSrcSurfaceFlags->dwMCSurfaceBase != 0) &&
           (lpSrcSurfaceFlags->dwMCSurfaceBase != pSrcSurf_gbl->fpVidMem))
        lpSrcSurfaceFlags++;
    lpDstSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];
    while ((lpDstSurfaceFlags->dwMCSurfaceBase != 0) &&
           (lpDstSurfaceFlags->dwMCSurfaceBase != pDstSurf_gbl->fpVidMem))
        lpDstSurfaceFlags++;

    // Calculate some things for the surfaces.
    dwPitch422 = (pDstSurf_gbl->wWidth + 3) & ~3;
    dwPitch422 = ((dwPitch422 << 1) + 127) & ~127;

    dwDstSurfaceWidth  = pDstSurf_gbl->wWidth;
    dwDstSurfaceHeight = pDstSurf_gbl->wHeight;

    dwSPSurfaceWidth  = pSPSurf_gbl->wWidth;
    dwSPSurfaceHeight = pSPSurf_gbl->wHeight;

    dwSrcOffset = lpSrcSurfaceFlags->dwMCSurface422Offset;
    dwDstOffset = lpDstSurfaceFlags->dwMCSurface422Offset;

    // Check for rectangles too large for their respective surface.
    if (((DWORD)(nPicSrcX + nPicSrcW) > dwDstSurfaceWidth) ||
        ((DWORD)(nPicSrcY + nPicSrcH) > dwDstSurfaceHeight))
        return (DDERR_INVALIDPARAMS);
    
    if (((DWORD)(nPicDstX + nPicDstW) > dwDstSurfaceWidth) ||
        ((DWORD)(nPicDstY + nPicDstH) > dwDstSurfaceHeight))
        return (DDERR_INVALIDPARAMS);
    
    if (((DWORD)(nSubSrcX + nSubSrcW) > dwSPSurfaceWidth) ||
        ((DWORD)(nSubSrcY + nSubSrcH) > dwSPSurfaceHeight))
        return (DDERR_INVALIDPARAMS);
    
    if (((DWORD)(nSubDstX + nSubDstW) > dwDstSurfaceWidth) ||
        ((DWORD)(nSubDstY + nSubDstH) > dwDstSurfaceHeight))
        return (DDERR_INVALIDPARAMS);
    
    // Calculate offsets in the NVSP subpicture surface.
    // dwSPOffset points to the YUV32 subpicture bitmap.
    dwSPOffset  = VIDMEM_OFFSET(pSPSurf_gbl->fpVidMem);
    dwBlockSize = pSPSurf_gbl->lPitch * pSPSurf_gbl->wHeight;
    dwBlockSize <<= 1;
    dwSPOffset += dwBlockSize;

    // dwMixOffset points to the Mixer buffer used temporarily for alpha blending.
    dwMixOffset = VIDMEM_OFFSET(pSPSurf_gbl->fpVidMem);
    dwBlockSize = pSPSurf_gbl->lPitch * pSPSurf_gbl->wHeight;
    dwBlockSize <<= 1;
    dwMixOffset += dwBlockSize;
    dwMixOffset += (dwBlockSize << 1);
    dwMixOffset += 1024;

    // If the picture source and dest buffers are the same (usually only when
    // back-end alpha blending is enabled) we use the Mix buffer for blending.
    // Else if the picture source and dest rects are the same, we don't need to scale
    // or crop, and we can do our subpicture blending in the destination buffer.
    // But if the rectangles don't match, we need to use the Mix buffer to hold
    // the YUY2 image temporarily until we can scale it into the Dst buffer, and
    // then blend the subpicture into the Dst buffer.
    if (bNVSrcIndex == bNVDstIndex) {
        bScaled = 0;
    }
    else if (memcmp(&(rcPictureSourceRect), &(lpDXVABlend->PictureDestinationRect), sizeof(RECT))) {
        bScaled = 1;
    }
    else {
        bScaled = 0;
        dwMixOffset = dwDstOffset;
    }


    // If the DXVA source and destination indexes are different, use DDBlt
    // to copy the image from the NV12 source to the NV12 destination before
    // we blend.  Note that this only copies the NV12-format portion of the
    // surface, not the YUY2 converted portion.
    if (bNVSrcIndex != bNVDstIndex) {
        memset(&BltData, 0, sizeof(BltData));
        BltData.lpDD            = (LPDDRAWI_DIRECTDRAW_GBL)pDriverData->dwDDGlobal;
        BltData.dwFlags         = DDBLT_ROP;
        BltData.lpDDSrcSurface  = pSrcSurf_lcl;
        BltData.lpDDDestSurface = pDstSurf_lcl;
        SrcRect.top             = 0;
        SrcRect.left            = 0;
        SrcRect.bottom          = (LONG)dwDstSurfaceWidth;
        SrcRect.right           = (LONG)dwDstSurfaceHeight;
        BltData.rSrc            = SrcRect;
        DstRect.top             = 0;
        DstRect.left            = 0;
        DstRect.bottom          = (LONG)dwDstSurfaceWidth;
        DstRect.right           = (LONG)dwDstSurfaceHeight;
        BltData.rDest           = DstRect;
        BltData.bltFX.dwSize    = sizeof(DDBLTFX);
        BltData.bltFX.dwROP     = SRCCOPY;
        Blit32(&BltData);
    }

    // We need to generate a fresh YUY2 copy from the NV12 source in case
    // a subpicture was blended in already.  We do this into the Mix buffer
    // hidden in the NVSP surface.
    dwLumaOffset = VIDMEM_OFFSET(pSrcSurf_gbl->fpVidMem);
    dwChromaOffset = dwLumaOffset + (pSrcSurf_gbl->lPitch * pSrcSurf_gbl->wHeight);

    X0 = 0;
    X1 = dwDstSurfaceWidth;
    Y0 = 0;
    Y1 = dwDstSurfaceHeight;

    // If Kelvin class...
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {

        if (!(nvInitKelvinForMoCompConversion()))
            return DDERR_GENERIC;

        tmpVal = (NV097_SET_TEXTURE_FILTER_BSIGNED_BIT_DISABLED << 31) |
                 (NV097_SET_TEXTURE_FILTER_GSIGNED_BIT_DISABLED << 30) |
                 (NV097_SET_TEXTURE_FILTER_RSIGNED_BIT_DISABLED << 29) |
                 (NV097_SET_TEXTURE_FILTER_ASIGNED_BIT_DISABLED << 28) |
                 (NV097_SET_TEXTURE_FILTER_MAG_TENT_LOD0 << 24) |
                 (NV097_SET_TEXTURE_FILTER_MIN_TENT_LOD0 << 16) |
                 (NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_QUINCUNX << 13);

        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) + NV097_SET_TEXTURE_FILTER(1) | 0x40000);
        nvPushData(1, tmpVal);
        nvPusherAdjust(2);

        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) + NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
        nvPushData(1, dwLumaOffset);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) + NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
        nvPushData(3, dwChromaOffset);
        nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) + NV097_NO_OPERATION | 0x40000);
        nvPushData(5, 0);
        nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) + NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(7, dwMixOffset);
        nvPusherAdjust(8);

        SET_KELVIN_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) + NV097_SET_BEGIN_END | 0x40000);
        nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) + NV097_INLINE_ARRAY | 0x40300000);
        nvPushData(3, (Y0 << 18) | (X0 << 1));
        nvPushData(4, (Y0 << 16) | (X0 >> 1));
        nvPushData(5, (Y0 << 15) | (X0 >> 1));
        nvPushData(6, ((Y1 << 2) << 16) | (X0 << 1)); // destination is in quarter pel units
        nvPushData(7, (Y1 << 16) | (X0 >> 1));        // LUMA texture is in pel units
        nvPushData(8, ((Y1 >> 1) << 16) | (X0 >> 1)); // CHROMA texture is in pel units and is only half the surface height
        nvPushData(9, ((Y1 << 2) << 16) | (X1 << 1)); // each 32 bit write contains data for 2 422 pixels
        nvPushData(10, (Y1 << 16) | (X1 >> 1));
        nvPushData(11, ((Y1 >> 1) << 16) | (X1 >> 1));
        nvPushData(12, (Y0 << 18) | (X1 << 1));
        nvPushData(13, (Y0 << 16) | (X1 >> 1));
        nvPushData(14, (Y0 << 15) | (X1 >> 1));
        nvPushData(15, dDrawSubchannelOffset(NV_DD_KELVIN) + NV097_SET_BEGIN_END | 0x40000);
        nvPushData(16, NV097_SET_BEGIN_END_OP_END);
        nvPusherAdjust(17);
        nvPusherStart(TRUE);
    }

    // Else if Celsius class...
    else {

        if (!(nvInitCelsiusForMoCompConversion()))
            return DDERR_GENERIC;

        tmpVal = (NV056_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR << 28) |
                 (NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR << 24);

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) + NV056_SET_TEXTURE_FILTER(1) | 0x40000);
        nvPushData(1, tmpVal);
        nvPusherAdjust(2);

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) + NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
        nvPushData(1, dwLumaOffset);
        nvPushData(2, dwChromaOffset);
        nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) + NV056_NO_OPERATION | 0x40000);
        nvPushData(4, 0);
        nvPushData(5, dDrawSubchannelOffset(NV_DD_CELSIUS) + NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(6, dwMixOffset);
        nvPusherAdjust(7);

        SET_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

        // No HD scaled version because subpicture compositing is not used for HD 
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) + NV056_SET_BEGIN_END | 0x40000);
        nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) + NV056_INLINE_ARRAY(0) | 0x300000);
        nvPushData(3, (Y0 << 15) | (X0 >> 1));
        nvPushData(4, (Y0 << 16) | (X0 >> 1));
        nvPushData(5, (Y0 << 18) | (((X0 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF));
        nvPushData(6, ((Y1 >> 1) << 16) | (X0 >> 1)); // CHROMA texture is in pel units and is only half the surface height
        nvPushData(7, (Y1 << 16) | (X0 >> 1));        // LUMA texture is in pel units
        nvPushData(8, ((Y1 << 2) << 16) | (((X0 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF)); // destination is in quarter pel units
        nvPushData(9, ((Y1 >> 1) << 16) | (X1 >> 1));
        nvPushData(10, (Y1 << 16) | (X1 >> 1));
        nvPushData(11, ((Y1 << 2) << 16) | (((X1 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF)); // each 32 bit write contains data for 2 422 pixels
        nvPushData(12, (Y0 << 15) | (X1 >> 1));
        nvPushData(13, (Y0 << 16) | (X1 >> 1));
        nvPushData(14, (Y0 << 18) | (((X1 << 1) - CELSIUS_DESTINATION_VIEWPORT_XOFFSET) & 0x0000FFFF));
        nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) + NV056_SET_BEGIN_END | 0x40000);
        nvPushData(16, NV056_SET_BEGIN_END_OP_END);
        nvPusherAdjust(17);
        nvPusherStart(TRUE);
    }

    // If picture scaling is required, we scale the image from the Mix buffer to
    // the Dst buffer.  No subpicture blending is done at this stage.
    if (bScaled) {
        dwScaleX = (nPicSrcW << 20) / nPicDstW;
        if ((dwScaleX < 0x10000) || (dwScaleX > 0x1000000))
            dwScaleX = 0x100000;
        dwScaleY = (nPicSrcH << 20) / nPicDstH;
        if ((dwScaleY < 0x10000) || (dwScaleY > 0x1000000))
            dwScaleY = 0x100000;

        nvPushData (0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
        nvPushData (1, NV_VPP_DVD_SUBPICTURE_IID);
        nvPushData (2, dDrawSubchannelOffset(NV_DD_SPARE) + NV088_IMAGE_OUT_POINT | 0x400000);
        nvPushData (3, asmMergeCoords(nPicDstX, nPicDstY));
        nvPushData (4, asmMergeCoords(nPicDstW, nPicDstH));
        nvPushData (5, (NV088_IMAGE_OUT_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | dwPitch422);
        nvPushData (6, dwDstOffset);                                            // 422 destination pixel area
        nvPushData (7, dwScaleX);
        nvPushData (8, dwScaleY);
        nvPushData (9, asmMergeCoords(dwDstSurfaceWidth, dwDstSurfaceHeight));
        nvPushData (10, (NV088_IMAGE_IN_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | dwPitch422);
        nvPushData (11, dwMixOffset);                                           // 422 source pixel area
        nvPushData (12, ((asmMergeCoords(nPicSrcX, nPicSrcY)) << 4));
        nvPushData (13, 0x100000);
        nvPushData (14, 0x100000);
        nvPushData (15, asmMergeCoords(dwSPSurfaceWidth, dwSPSurfaceHeight));
        nvPushData (16, (NV088_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT << 16) | (pSPSurf_gbl->lPitch << 2));
        nvPushData (17, dwSPOffset);                                            // AYUV source pixel area
        nvPushData (18, ((asmMergeCoords(nSubSrcX, nSubSrcY)) << 4));
        nvPusherAdjust (19);
        nvPusherStart(TRUE);

        // Further operations should be done in the Dst buffer.
        dwMixOffset = dwDstOffset;
    }

    // Next we use the DVD Subpicture class to blend the subpicture into the Dst buffer.
    if ((nSubSrcW > 0) && (nSubSrcH > 0)) {
        dwScaleX = (nSubSrcW << 20) / nSubDstW;
        if ((dwScaleX < 0x10000) || (dwScaleX > 0x1000000))
            dwScaleX = 0x100000;
        dwScaleY = (nSubSrcH << 20) / nSubDstH;
        if ((dwScaleY < 0x10000) || (dwScaleY > 0x1000000))
            dwScaleY = 0x100000;
        nvPushData (0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
        nvPushData (1, NV_VPP_DVD_SUBPICTURE_IID);
        nvPushData (2, dDrawSubchannelOffset(NV_DD_SPARE) + NV088_IMAGE_OUT_POINT | 0x400000);
        nvPushData (3, asmMergeCoords(nSubDstX, nSubDstY));
        nvPushData (4, asmMergeCoords(nSubDstW, nSubDstH));
        nvPushData (5, (NV088_IMAGE_OUT_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | dwPitch422);
        nvPushData (6, dwMixOffset);                                            // 422 destination pixel area
        nvPushData (7, 0x100000);
        nvPushData (8, 0x100000);
        nvPushData (9, asmMergeCoords(dwDstSurfaceWidth, dwDstSurfaceHeight));
        nvPushData (10, (NV088_IMAGE_IN_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | dwPitch422);
        nvPushData (11, dwMixOffset);                                          // 422 source pixel area
        nvPushData (12, ((asmMergeCoords(nSubDstX, nSubDstY)) << 4));
        nvPushData (13, dwScaleX);
        nvPushData (14, dwScaleY);
        nvPushData (15, asmMergeCoords(dwSPSurfaceWidth, dwSPSurfaceHeight));
        nvPushData (16, (NV088_OVERLAY_FORMAT_COLOR_LE_A8CR8CB8Y8 << 16) | (pSPSurf_gbl->lPitch << 2));
        nvPushData (17, dwSPOffset);                                            // AYUV source pixel area
        nvPushData (18, ((asmMergeCoords(nSubSrcX, nSubSrcY)) << 4));
        nvPusherAdjust (19);
        nvPusherStart(TRUE);
    }

    // If the source buffer and destination buffer are the same (usually only
    // when back-end alpha blending is enabled) we need to copy the blended image
    // to the destination buffer.
    if (bNVSrcIndex == bNVDstIndex) {
        nvPushData (0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
        nvPushData (1, NV_VPP_DVD_SUBPICTURE_IID);
        nvPushData (2, dDrawSubchannelOffset(NV_DD_SPARE) + NV088_IMAGE_OUT_POINT | 0x400000);
        nvPushData (3, asmMergeCoords(0, 0));
        nvPushData (4, asmMergeCoords(dwDstSurfaceWidth, dwDstSurfaceHeight));
        nvPushData (5, (NV088_IMAGE_OUT_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | dwPitch422);
        nvPushData (6, dwDstOffset);                                            // 422 destination pixel area
        nvPushData (7, 0x100000);
        nvPushData (8, 0x100000);
        nvPushData (9, asmMergeCoords(dwDstSurfaceWidth, dwDstSurfaceHeight));
        nvPushData (10, (NV088_IMAGE_IN_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16) | dwPitch422);
        nvPushData (11, dwMixOffset);                                           // 422 source pixel area
        nvPushData (12, ((asmMergeCoords(0, 0)) << 4));
        nvPushData (13, 0x100000);
        nvPushData (14, 0x100000);
        nvPushData (15, asmMergeCoords(dwSPSurfaceWidth, dwSPSurfaceHeight));
        nvPushData (16, (NV088_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT << 16) | (pSPSurf_gbl->lPitch << 2));
        nvPushData (17, dwSPOffset);                                            // AYUV source pixel area
        nvPushData (18, ((asmMergeCoords(0, 0)) << 4));
        nvPusherAdjust (19);
    }

    // See if we need to do temporal filtering on the alpha blended image.
    lpDstSurfaceFlags->bMCFrameIsFiltered = FALSE;
    if (pDriverData->bMCTemporalFilterDisabled == FALSE) {
        nvPusherStart(TRUE);
        nvMoCompTemporalFilter(lpDstSurfaceFlags->dwMCSurfaceBase, pDriverData->bMCPercentCurrentField);
    }

    // Update reference count in case we get a status query
    lpDstSurfaceFlags->dwMCCompositeReferenceCount = getDC()->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);

    nvPusherStart(TRUE);
    pDriverData->dDrawSpareSubchannelObject = NV_VPP_DVD_SUBPICTURE_IID;

    // Set some surface flags for the destination surface.
    lpDstSurfaceFlags->bMCFrameIsComposited = PICTURE_STRUCTURE_FRAME;
    lpDstSurfaceFlags->bMCFrameAlreadyFormatConverted = 15;
    lpDstSurfaceFlags->bMCPictureStructure  = lpSrcSurfaceFlags->bMCPictureStructure;
    lpDstSurfaceFlags->bMCPictureCodingType = lpSrcSurfaceFlags->bMCPictureCodingType;
    lpDstSurfaceFlags->bMCTopFieldFirst     = lpSrcSurfaceFlags->bMCTopFieldFirst;
    lpDstSurfaceFlags->bMCSecondField       = lpSrcSurfaceFlags->bMCSecondField;
    lpDstSurfaceFlags->bMCFrameType         = lpSrcSurfaceFlags->bMCFrameType;

    return DD_OK;

} /* nvDXVACompositeSubpicture */


/*
 * nvUpdateDXVAIndexTables
 *
 * Recalculates the table pDriverData->bDXVAIndexToNVIndex[8] which is used to convert surface indexes
 * sent by DXVA into our internal NV indexes.  Because the Win/ME DDFlip operation swaps surface
 * pointers, this table may need to be updated if a Flip command came since the last time it was
 * calculated.
 *
 */
 void __stdcall nvUpdateDXVAIndexTable(GLOBALDATA *pDriverData)
 {
    WORD    wDXVAIndex;
    BYTE    bNVIndex;
    DWORD   dwTableVidMem, dwSurfVidMem;

    // Compare the values in the bDXVAIndexToNVIndex and bDXVAIndexToVidMem tables.
    // If they don't match, search through the IndexToVidMem table to see if you can find a match.
    for (wDXVAIndex = 0; wDXVAIndex < 8; wDXVAIndex++) {
        dwTableVidMem = pDriverData->dwDXVAIndexToVidMem[wDXVAIndex];
        if (dwTableVidMem) {
            bNVIndex = pDriverData->bDXVAIndexToNVIndex[wDXVAIndex];
            if (pDriverData->dwMCNV12Surface[bNVIndex]) {
                dwSurfVidMem = ((LPDDRAWI_DDRAWSURFACE_LCL)(pDriverData->dwMCNV12Surface[bNVIndex]))->lpGbl->fpVidMem;
                if (dwTableVidMem != dwSurfVidMem) {
                    for (bNVIndex = 0; bNVIndex < 8; bNVIndex++) {
                        if (pDriverData->dwMCNV12Surface[bNVIndex]) {
                            dwSurfVidMem = ((LPDDRAWI_DDRAWSURFACE_LCL)(pDriverData->dwMCNV12Surface[bNVIndex]))->lpGbl->fpVidMem;
                            if (dwTableVidMem == dwSurfVidMem) {
                                pDriverData->bDXVAIndexToNVIndex[wDXVAIndex] = bNVIndex;
                                break;
                            }
                        }
                    }
                }
            }
        }
    }
 }  // nvUpdateDXVAIndexTables


/*
 * nvMoCompFrameStatus
 *
 * This is a variation of getFrameStatusOverlay for motion comp overlay surfaces only.
 * It does additional checking for "previous flip from" surfaces which the other function
 * skips because of WHQL test requirements.
 *
 */
DWORD __stdcall nvMoCompFrameStatus(FLATPTR fpVidMem)
{
    if (getDC()->flipOverlayRecord.bFlipFlag &&
        ((fpVidMem == getDC()->flipOverlayRecord.fpFlipFrom) ||
         (fpVidMem == getDC()->flipOverlayRecord.fpPreviousFlipFrom))) {

        NvNotification *pPioFlipOverlayNotifier = pDriverData->pPioFlipOverlayNotifierFlat;

        if (fpVidMem == getDC()->flipOverlayRecord.fpPreviousFlipFrom) {
            LONGLONG timeNow = 0;
            // only need for one to flush out, no way to really determine this on NV10,
            // but if we wait at least one CRTC refresh since it was issued, we can
            // guarantee it has been flushed through
            if ((pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) &&
                (pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) {
                QueryPerformanceCounter((LARGE_INTEGER *) &timeNow);
                if ((timeNow - getDC()->flipOverlayRecord.llFlipTime) < (getDC()->flipPrimaryRecord.dwFlipDuration * 2)) {
                    return (DDERR_WASSTILLDRAWING);
                }
            }
        } else {
            if (fpVidMem == getDC()->flipOverlayRecord.fpFlipFrom) {
                // need to wait for both flips to flush out
                if (((volatile)pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) &&
                    ((volatile)pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) {
                    return (DDERR_WASSTILLDRAWING);
                } else {
                    getDC()->flipOverlayRecord.bFlipFlag = FALSE;
                }
            }
        }
        return (DD_OK);
    }
    return (DD_OK);
}  // nvMoCompFrameStatus


/*
 * nvDXVABackEndAlphaBlend
 *
 * This function blends the current subpicture graphic into the selected frame.
 * It can be called from MoComp or Flip functions.
 * Note: pDriverData should be set before this function is called.
 *
 */
DWORD __stdcall nvDXVABackEndAlphaBlend(FLATPTR fpVidMem)
{
    WORD                        wDXVAIndex;
    DXVA_BlendCombination       DXVABlendCombination = {0};
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    LPNVMCFRAMEDATA             lpNvMCFrameData;

    // Look up index of target surface to blend into.
    for (wDXVAIndex = 0; wDXVAIndex < 8; wDXVAIndex++) {
        if (pDriverData->dwDXVAIndexToVidMem[wDXVAIndex] == (DWORD)fpVidMem)
            break;
    }
    if (wDXVAIndex > 7)
        wDXVAIndex = 0;

    // Get pointer to NVMC surface used to store parameters.
    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCNVMCSurface;
    lpNvMCFrameData = (LPNVMCFRAMEDATA)VIDMEM_ADDR(pSurf_lcl->lpGbl->fpVidMem);

    // Set up DXVA_BlendCombination structure with subpicture parameters.
    DXVABlendCombination.wPictureSourceIndex = wDXVAIndex;
    DXVABlendCombination.wBlendedDestinationIndex = wDXVAIndex;
    DXVABlendCombination.PictureSourceRect16thPel.left   = 0;
    DXVABlendCombination.PictureSourceRect16thPel.top    = 0;
    DXVABlendCombination.PictureSourceRect16thPel.right  = lpNvMCFrameData->wDXVAPicWidthInMB * 16 * 16;
    DXVABlendCombination.PictureSourceRect16thPel.bottom = lpNvMCFrameData->wDXVAPicHeightInMB * 16 * 16;
    DXVABlendCombination.PictureDestinationRect.left   = 0;
    DXVABlendCombination.PictureDestinationRect.top    = 0;
    DXVABlendCombination.PictureDestinationRect.right  = lpNvMCFrameData->wDXVAPicWidthInMB * 16;
    DXVABlendCombination.PictureDestinationRect.bottom = lpNvMCFrameData->wDXVAPicHeightInMB * 16;
    DXVABlendCombination.GraphicSourceRect      = lpNvMCFrameData->rcGraphicSourceRect;
    DXVABlendCombination.GraphicDestinationRect = lpNvMCFrameData->rcGraphicDestinationRect;

    nvMoCompExecute(lpNvMCFrameData->dwMCMultiMonID,
                    EXECUTE_DXVA_ALPHA_BLENDING,
                    (LPVOID)&DXVABlendCombination,
                    sizeof(DXVA_BlendCombination),
                    0);

    return DD_OK;
}


#endif  // NVARCH >= 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\MoCompExKelvin.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*==========================================================================;
 *
 *  Copyright (C) 2000 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       MoCompExKelvin.cpp
 *  Content:    Windows98 DirectDraw 32 bit driver
 *
 ***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

#include "dxshare.h"

extern NVMOCOMPPARAMS           nvMoCompParams;

#ifndef WINNT
    extern DISPDRVDIRECTXCOMMON    *pDXShare;
#endif // WINNT

extern BOOL __fastcall nvMoCompCheckFieldPredictionEqual(LPNVDECODEMACROBLOCK pMacroblock0,
                                                         LPNVDECODEMACROBLOCK pMacroblock1, BYTE macroblockType);

extern DWORD __stdcall nvInitKelvinForMoComp(void);
extern DWORD __stdcall nvInitKelvinForMoCompPrediction(void);
extern DWORD __stdcall nvInitKelvinForMoCompCorrection();
extern void __stdcall nvDoKelvinBidirectionalDVDFieldPrediction(BOOL);
extern void __stdcall nvDoTwoKelvinBidirectionalDVDFieldPredictions(BOOL);
extern void __stdcall nvDoKelvinForwardDVDFieldPrediction(BOOL);
extern void __stdcall nvDoTwoKelvinForwardDVDFieldPredictions(BOOL);
extern void __stdcall nvDoKelvinBackwardDVDFieldPrediction(BOOL);
extern void __stdcall nvDoTwoKelvinBackwardDVDFieldPredictions(BOOL);
extern void __stdcall nvDoAllKelvinIntraDVDFieldCorrections(long correctionYIncr, long numBlocks);
extern void __stdcall nvDoAllKelvinDVDFieldCorrections(long correctionYIncr, long numBlocks);
extern void __stdcall nvDoKelvinIntraDVDFieldCorrection(void);
extern void __stdcall nvDoOptimizedKelvinIntraDVDFieldCorrection(void);
extern void __stdcall nvDoKelvinDVDFieldCorrection(void);
extern void __stdcall nvDoAllKelvinIntraFrameCorrections(void);
extern void __stdcall nvDoAllKelvinFrameCorrections(void);
extern void __stdcall nvDoKelvinIntraFrameCorrection(void);
extern void __stdcall nvDoKelvinFrameCorrection(void);
extern DWORD __stdcall nvPredictKelvinFrameLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks);
extern DWORD __stdcall nvPredictKelvinFieldLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks);
extern DWORD __stdcall nvPredictKelvinFrameChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks);
extern DWORD __stdcall nvPredictKelvinFieldChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks);
extern void __stdcall nvCorrectKelvinIntraFrame(LPNVDECODEMACROBLOCK pMacroblock, long macroblockCount);
extern void __stdcall nvCorrectKelvinFrameLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType);
extern void __stdcall nvCorrectKelvinFullFrameLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType);
extern void __stdcall nvCorrectKelvinFrameChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType);
extern void __stdcall nvCorrectKelvinFullFrameChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType);
extern void __stdcall nvCorrectKelvinIntraField(LPNVDECODEMACROBLOCK pMacroblock, long macroblockCount);
extern void __stdcall nvCorrectKelvinFieldMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType);

extern PNVMCPREDFUNC nvDoBidirectionalFieldPrediction;
extern PNVMCPREDFUNC nvDoTwoBidirectionalFieldPredictions;
extern PNVMCPREDFUNC nvDoForwardFieldPrediction;
extern PNVMCPREDFUNC nvDoTwoForwardFieldPredictions;
extern PNVMCPREDFUNC nvDoBackwardFieldPrediction;
extern PNVMCPREDFUNC nvDoTwoBackwardFieldPredictions;

extern PNVMCPREDFUNC2 nvPredictFrameLumaMacroblock;
extern PNVMCPREDFUNC2 nvPredictFieldLumaMacroblock;
extern PNVMCPREDFUNC2 nvPredictFrameChromaMacroblock;
extern PNVMCPREDFUNC2 nvPredictFieldChromaMacroblock;

extern PNVMCCORRFUNC2 nvDoAllIntraFieldCorrections;
extern PNVMCCORRFUNC2 nvDoAllFieldCorrections;
extern PNVMCCORRFUNC nvDoAllIntraFrameCorrections;
extern PNVMCCORRFUNC nvDoAllFrameCorrections;
extern PNVMCCORRFUNC nvDoIntraFieldCorrection;
extern PNVMCCORRFUNC nvDoOptimizedIntraFieldCorrection;
extern PNVMCCORRFUNC nvDoFieldCorrection;
extern PNVMCCORRFUNC nvDoIntraFrameCorrection;
extern PNVMCCORRFUNC nvDoFrameCorrection;


/*
 * nvMoCompProcessKelvinFrameMacroblocks
 *
 * Parses the current macroblock command stream and performs the necessary operations on
 * each macroblock.
 *
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvMoCompProcessKelvinFrameMacroblocks(LPNVDECODEMACROBLOCK pMacroblocks,
                                                      DWORD numMacroblocks, BYTE formatConversionStatus)
{
    LPDDRAWI_DDRAWSURFACE_LCL   dstx = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   dst = dstx->lpGbl;
    LPNVDECODEMACROBLOCK        pMacroblock;
    LPNVDECODEMACROBLOCK        pLastMacroblock;
    LPNVDECODEMACROBLOCK        pMacroblock1;
    unsigned long               dwFirstAlignedIDCTOffset;
    unsigned long               dwSurfaceOffset;
    unsigned long               surfacePitch;
    unsigned long               moCompCorrectionICW;
    unsigned long               moCompNonPrebiasedCorrectionICW;
    long                        macroblockLimit;
    long                        n;
    long                        macroblockIndex;
    BYTE                        surfaceDecodeStatus = 0;
    BYTE                        numCombinedMacroblocks[256];
    short                       maxHeight = (short)dst->wHeight - 16;
    short                       maxWidth = (short)dst->wWidth - 16;
    BOOL                        hasFieldPredictions = FALSE;
    int                         index, i;
    int                         firstAlignedIDCTIndex;

    nvMoCompParams.vertexMode = 0; // Initialize vertexMode to an invalid value
    nvMoCompParams.surfaceLumaPitch = dst->lPitch;
    nvMoCompParams.surfaceLumaHeight = (dst->wHeight + 1) & ~1;
    nvMoCompParams.surfaceOffset = VIDMEM_OFFSET(dst->fpVidMem);
    nvMoCompParams.surfaceChromaOffset = nvMoCompParams.surfaceLumaPitch * nvMoCompParams.surfaceLumaHeight;
    nvMoCompParams.surfaceBiasedIntraBlockOffset =
        (dst->lPitch * dst->wHeight) + (dst->lPitch * (dst->wHeight >> 1) + (8 * dst->lPitch));

    if (pDriverData->bMCPictureCodingType != PICTURE_TYPE_I) {

        if (!(nvInitKelvinForMoCompPrediction()))
            return FALSE;

        nvDoBidirectionalFieldPrediction = nvDoKelvinBidirectionalDVDFieldPrediction;
        nvDoTwoBidirectionalFieldPredictions = nvDoTwoKelvinBidirectionalDVDFieldPredictions;
        nvDoForwardFieldPrediction = nvDoKelvinForwardDVDFieldPrediction;
        nvDoTwoForwardFieldPredictions = nvDoTwoKelvinForwardDVDFieldPredictions;
        nvDoBackwardFieldPrediction = nvDoKelvinBackwardDVDFieldPrediction;
        nvDoTwoBackwardFieldPredictions = nvDoTwoKelvinBackwardDVDFieldPredictions;

        nvPredictFrameLumaMacroblock = nvPredictKelvinFrameLumaMacroblock;
        nvPredictFrameChromaMacroblock = nvPredictKelvinFrameChromaMacroblock;
        nvPredictFieldLumaMacroblock = nvPredictKelvinFieldLumaMacroblock;
        nvPredictFieldChromaMacroblock = nvPredictKelvinFieldChromaMacroblock;

        nvMoCompParams.currentForwardField = 0;
        nvMoCompParams.currentBackwardField = 0;
        nvMoCompParams.currentDestinationField = 0;

        pMacroblock = pMacroblocks;
        n = numMacroblocks;
        macroblockIndex = 0;

        surfacePitch = (nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch;

        // Must temporarily set destination surface pitch back to it's normal frame pitch
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_SURFACE_PITCH | 0x40000);
        nvPushData(3, surfacePitch);

        // Must also change texture pitches back to normal frame pitch so that quarter pel addressing works correctly
        nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                       NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
        nvPushData(5, surfacePitch << 16);
        nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                       NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
        nvPushData(7, surfacePitch << 16);

        nvPusherAdjust(8);

        // Perform luma prediction pass
        while (n > 0) {
            numCombinedMacroblocks[macroblockIndex] = 1;
            if (pMacroblock->macroblockType == MB_MOTION_FORWARD) {
                if (n > 1) {
                    pMacroblock1 = pMacroblock + 1;
                    if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME){
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_FORWARD) &&
								(pMacroblock1->motionType == FRAME_STRUCTURE_MOTION_FRAME) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(*(long *)&pMacroblock->PMV[0][0][0] == *(long *)&pMacroblock1->PMV[0][0][0])) {
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
							if(n <= i+1)
								break;	//no more macroblock left
							pMacroblock1++;	

						}
					} else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD){
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_FORWARD) &&
								(pMacroblock1->motionType == FRAME_STRUCTURE_MOTION_FIELD) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(nvMoCompCheckFieldPredictionEqual(pMacroblock, pMacroblock1, pMacroblock->macroblockType))){
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
	
							if(n <= i+1)
								break;
							pMacroblock1++;							
						}
                    }
                }

                if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME)
                    nvPredictFrameLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
                else
                    hasFieldPredictions = TRUE;

                pMacroblock += numCombinedMacroblocks[macroblockIndex];
                n -= numCombinedMacroblocks[macroblockIndex];
            } else if (pMacroblock->macroblockType == MB_MOTION_BACKWARD) {
                if (n > 1) {
                    pMacroblock1 = pMacroblock + 1;
                    if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME) {
                    	//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_BACKWARD) &&
								(pMacroblock1->motionType == FRAME_STRUCTURE_MOTION_FRAME) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(*(long *)&pMacroblock->PMV[0][1][0] == *(long *)&pMacroblock1->PMV[0][1][0])) {
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
							if(n <= i+1)
								break;
							pMacroblock1++;
						}
                    } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD) {
  						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_BACKWARD) &&
								(pMacroblock1->motionType == FRAME_STRUCTURE_MOTION_FIELD) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(nvMoCompCheckFieldPredictionEqual(pMacroblock, pMacroblock1, pMacroblock->macroblockType))){
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
							if(n <= i+1)
								break;
							pMacroblock1 ++;
						}
                    }
                }

                if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME)
                    nvPredictFrameLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
                else
                    hasFieldPredictions = TRUE;

                pMacroblock += numCombinedMacroblocks[macroblockIndex];
                n -= numCombinedMacroblocks[macroblockIndex];
            } else if (pMacroblock->macroblockType == (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) {
                if (n > 1) {
                    pMacroblock1 = pMacroblock + 1;
                    if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME) {
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) &&
								(pMacroblock1->motionType == FRAME_STRUCTURE_MOTION_FRAME) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(*(long *)&pMacroblock->PMV[0][0][0] == *(long *)&pMacroblock1->PMV[0][0][0]) &&
								(*(long *)&pMacroblock->PMV[0][1][0] == *(long *)&pMacroblock1->PMV[0][1][0])) {
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
							if(n <= i+1)
								break;
							pMacroblock1 ++;
						}                        
                    } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD) {
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) &&
								(pMacroblock1->motionType == FRAME_STRUCTURE_MOTION_FIELD) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(nvMoCompCheckFieldPredictionEqual(pMacroblock, pMacroblock1, pMacroblock->macroblockType))){
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
							if(n <= i+1)
								break;
							pMacroblock1 ++;
						}
                    }
                }

                if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME)
                    nvPredictFrameLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
                else
                    hasFieldPredictions = TRUE;

                pMacroblock += numCombinedMacroblocks[macroblockIndex];
                n -= numCombinedMacroblocks[macroblockIndex];
            } else {
                if (pMacroblock->macroblockType != MB_INTRA) {

                    if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME)
                        nvPredictFrameLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
                    else
                        hasFieldPredictions = TRUE;

                }
                pMacroblock++;
                n--;
            }
            macroblockIndex++;
        }

        nvPusherStart(TRUE);

        pMacroblock = pMacroblocks;
        n = numMacroblocks;
        macroblockIndex = 0;

#ifdef  DEBUG
        if (moCompDebugLevel < 3) {
#endif  // DEBUG

        // Change surface offsets to chroma portion of surface
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(3, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceChromaOffset);

        nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
        nvPushData(5, pDriverData->dwMCForwardSurfaceOffset + nvMoCompParams.surfaceChromaOffset);

        nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
        nvPushData(7, pDriverData->dwMCBackwardSurfaceOffset + nvMoCompParams.surfaceChromaOffset);

        nvPusherAdjust(8);

        nvMoCompParams.currentForwardField = 0;
        nvMoCompParams.currentBackwardField = 0;
        nvMoCompParams.currentDestinationField = 0;

        // Perform chroma prediction pass
        while (n > 0) {
            if (pMacroblock->macroblockType != MB_INTRA) {

                if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME)
                    nvPredictFrameChromaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);

            }
            pMacroblock += numCombinedMacroblocks[macroblockIndex];
            n -= numCombinedMacroblocks[macroblockIndex];
            macroblockIndex++;
        }

        nvPusherStart(TRUE);

#ifdef  DEBUG
        }
#endif  // DEBUG

        // Now do non-frame structured predictions if any are necessary
        if (hasFieldPredictions) {

            // Restore offsets and pitches to field based pitches
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_NO_OPERATION | 0x40000);
            nvPushData(1, 0);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
            nvPushData(3, nvMoCompParams.surfaceOffset);

            nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
            nvPushData(5, pDriverData->dwMCForwardSurfaceOffset);

            nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(7, pDriverData->dwMCBackwardSurfaceOffset);

            nvPusherAdjust(8);

            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_SURFACE_PITCH | 0x40000);
            nvPushData(1, (surfacePitch << 1));

            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
            nvPushData(3, surfacePitch << 17);
            nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
            nvPushData(5, surfacePitch << 17);

            nvPusherAdjust(6);

            pMacroblock = pMacroblocks;
            n = numMacroblocks;
            macroblockIndex = 0;

            nvMoCompParams.currentForwardField = 0;
            nvMoCompParams.currentBackwardField = 0;
            nvMoCompParams.currentDestinationField = 0;
            nvMoCompParams.destinationFieldIs0 = TRUE; // First process all destination field 0 updates

            // Perform luma prediction pass
            while (n > 0) {
                if (pMacroblock->macroblockType != MB_INTRA) {

                    if (pMacroblock->motionType != FRAME_STRUCTURE_MOTION_FRAME)
                        nvPredictFrameLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);

                }
                pMacroblock += numCombinedMacroblocks[macroblockIndex];
                n -= numCombinedMacroblocks[macroblockIndex];
                macroblockIndex++;
            }

            nvPusherStart(TRUE);

            // Change surface offsets to chroma portion of surface
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_NO_OPERATION | 0x40000);
            nvPushData(1, 0);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
            nvPushData(3, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceChromaOffset);

            nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
            nvPushData(5, pDriverData->dwMCForwardSurfaceOffset + nvMoCompParams.surfaceChromaOffset);

            nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(7, pDriverData->dwMCBackwardSurfaceOffset + nvMoCompParams.surfaceChromaOffset);

            nvPusherAdjust(8);

            pMacroblock = pMacroblocks;
            n = numMacroblocks;
            macroblockIndex = 0;

            nvMoCompParams.currentForwardField = 0;
            nvMoCompParams.currentBackwardField = 0;
            nvMoCompParams.currentDestinationField = 0;
            nvMoCompParams.destinationFieldIs0 = TRUE; // First process all destination field 0 updates

            // Perform chroma prediction pass
            while (n > 0) {
                if (pMacroblock->macroblockType != MB_INTRA) {

                    if (pMacroblock->motionType != FRAME_STRUCTURE_MOTION_FRAME)
                        nvPredictFrameChromaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);

                }
                pMacroblock += numCombinedMacroblocks[macroblockIndex];
                n -= numCombinedMacroblocks[macroblockIndex];
                macroblockIndex++;
            }

            nvPusherStart(TRUE);
        }
    }

    if (!(nvInitKelvinForMoCompCorrection()))
        return FALSE;

    SET_KELVIN_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

    nvDoAllIntraFieldCorrections = nvDoAllKelvinIntraDVDFieldCorrections;
    nvDoAllFieldCorrections = nvDoAllKelvinDVDFieldCorrections;
    nvDoIntraFieldCorrection = nvDoKelvinIntraDVDFieldCorrection;
    nvDoOptimizedIntraFieldCorrection = nvDoOptimizedKelvinIntraDVDFieldCorrection;
    nvDoFieldCorrection = nvDoKelvinDVDFieldCorrection;

    nvDoAllIntraFrameCorrections = nvDoAllKelvinIntraFrameCorrections;
    nvDoAllFrameCorrections = nvDoAllKelvinFrameCorrections;
    nvDoIntraFrameCorrection = nvDoKelvinIntraFrameCorrection;
    nvDoFrameCorrection = nvDoKelvinFrameCorrection;

    // Default motion comp correction ICW
    moCompCorrectionICW = (NV097_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                          (NV097_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                          (NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                          (NV097_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NORMAL << 21) |
                          (NV097_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                          (NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                          (NV097_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                          (NV097_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                          (NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1 << 8) |

                          (NV097_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                          (NV097_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                           NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    // Non-prebiased motion comp correction ICW
    moCompNonPrebiasedCorrectionICW = (NV097_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                                      (NV097_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                                      (NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                                      (NV097_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                                      (NV097_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                                      (NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                                      (NV097_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                                      (NV097_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                                      (NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0 << 8) |

                                      (NV097_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                                      (NV097_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                                       NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0;

    nvMoCompParams.currentDestinationField = 0;
    nvMoCompParams.destinationField = 0;

    pMacroblock = pMacroblocks;
    n = numMacroblocks;

    // This assumes that the first IDCT index of the first macroblock in the command stream is the
    // lowest index in the entire command stream for this call.

    dwSurfaceOffset = pDriverData->dwMCDestinationSurfaceOffset;

    macroblockIndex = 0;
    index = 0;

    while (n > 0) {

        macroblockLimit = n;

        if (macroblockLimit > 32)
            macroblockLimit = 32;

        pDriverData->dwMCFirstAlignedIDCTIndex = pMacroblock->firstIDCTIndex & ~1;

        // Attempt to sanity check index
        if ((pDriverData->dwMCFirstAlignedIDCTIndex << 6) > pDriverData->dwMCIDCTAGPCtxDmaSize[0])
            pDriverData->dwMCFirstAlignedIDCTIndex = 0;

        dwFirstAlignedIDCTOffset = pDriverData->dwMCFirstAlignedIDCTIndex * 64; // 64 bytes per IDCT block

        // Force both texture caches to flush
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(3, dwSurfaceOffset);

        nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
        nvPushData(5, dwFirstAlignedIDCTOffset);
        nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
        nvPushData(7, dwSurfaceOffset);

        nvPusherAdjust(8);

        if (pDriverData->bMCCurrentExecuteFunction ==
            EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
            // Modify combiners to perform non-prebiased intrablock correction
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_COMBINER_COLOR_ICW(0) | 0x40000);
            nvPushData(1, moCompNonPrebiasedCorrectionICW);

            nvPusherAdjust(2);

            SET_KELVIN_UNBIASED_CORRECTION_DATA_FORMAT();
        } else {
            SET_KELVIN_CORRECTION_DATA_FORMAT();
        }   

        if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_I) &&
            (pMacroblock->codedBlockPattern == 0xFF)) {
            nvCorrectKelvinIntraFrame(pMacroblock, macroblockLimit);
            pMacroblock += macroblockLimit;
            n -= macroblockLimit;
        } else {
            long saveMacroblockLimit = macroblockLimit;
            long fieldTypeCount = 0;
            BOOL hasPartialCorrections = FALSE;

            pMacroblock1 = pMacroblock;

            nvMoCompParams.destinationFieldIs0 = TRUE;

            // Change texture1 surface offset to point to block of half bias values (0x80)
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

            // Change texture0 pitch to 16 bytes
            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
            nvPushData(3, 16 << 16);
            nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
            nvPushData(5, 16 << 16); // half bias Intra block pitch

            nvPusherAdjust(6);

            // Perform first correction pass
            while (--macroblockLimit >= 0) {
                if ((pMacroblock->overflowCodedBlockPattern != 0) && (pMacroblock->macroblockType != MB_INTRA))
                    numCombinedMacroblocks[macroblockIndex++] = (BYTE) index;
                index++;
                if ((pMacroblock->DCTType != DCT_FIELD) && (pMacroblock->macroblockType == MB_INTRA)) {
                    if (pMacroblock->codedBlockPattern >= 0xFC) {
                        nvCorrectKelvinFullFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                    } else if (pMacroblock->codedBlockPattern != 0) {
                        // Change texture0 pitch to it's default value of 8 bytes
                        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                       NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                        nvPushData(1, 8 << 16);

                        nvPusherAdjust(2);

                        nvCorrectKelvinFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);

                        // Change texture0 pitch to 16 bytes
                        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                       NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                        nvPushData(1, 16 << 16);

                        nvPusherAdjust(2);

                    }
                } else
                    fieldTypeCount++;

                pMacroblock++;
                --n;
            }

            nvPusherStart(TRUE);

            if (pDriverData->bMCCurrentExecuteFunction == EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
                SET_KELVIN_UNBIASED_CHROMA_CORRECTION_DATA_FORMAT();
            } else {
                SET_KELVIN_CHROMA_CORRECTION_DATA_FORMAT();
            }   

            pMacroblock = pMacroblock1;
            macroblockLimit = saveMacroblockLimit;

            while (--macroblockLimit >= 0) {
                if (pMacroblock->macroblockType == MB_INTRA) {
                    if (pMacroblock->codedBlockPattern == 0xFF) {
                        nvCorrectKelvinFullFrameChromaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                    } else if (pMacroblock->codedBlockPattern != 0) {
                        nvCorrectKelvinFrameChromaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                    }
                }
                pMacroblock++;
            }

            nvPusherStart(TRUE);

            // Force both texture caches to flush
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_NO_OPERATION | 0x40000);
            nvPushData(1, 0);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(3, dwSurfaceOffset);

            nvPusherAdjust(4);

            // Change texture0 pitch to 16 bytes
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
            nvPushData(1, 16 << 16);
            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
            nvPushData(3, nvMoCompParams.surfaceLumaPitch << 16);

            nvPusherAdjust(4);

            nvMoCompParams.destinationFieldIs0 = TRUE;

            pMacroblock = pMacroblock1;
            macroblockLimit = saveMacroblockLimit;

            if (pDriverData->bMCCurrentExecuteFunction ==
                EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
                // Modify combiners to perform interblock correction
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_COMBINER_COLOR_ICW(0) | 0x40000);
                nvPushData(1, moCompCorrectionICW);

                nvPusherAdjust(2);

            }    

            SET_KELVIN_CORRECTION_DATA_FORMAT();

            // Perform first correction pass
            while (--macroblockLimit >= 0) {
                if ((pMacroblock->DCTType != DCT_FIELD) && (pMacroblock->macroblockType != MB_INTRA)) {
                    if (pMacroblock->codedBlockPattern >= 0xFC) {
                        nvCorrectKelvinFullFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                    } else if (pMacroblock->codedBlockPattern != 0) {
                        // Change texture0 pitch to it's default value of 8 bytes
                        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                       NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                        nvPushData(1, 8 << 16);

                        nvPusherAdjust(2);

                        nvCorrectKelvinFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);

                        // Change texture0 pitch to 16 bytes
                        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                       NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                        nvPushData(1, 16 << 16);

                        nvPusherAdjust(2);

                    }
                }
                pMacroblock++;
            }

            nvPusherStart(TRUE);

            SET_KELVIN_CHROMA_CORRECTION_DATA_FORMAT();

            pMacroblock = pMacroblock1;
            macroblockLimit = saveMacroblockLimit;

            while (--macroblockLimit >= 0) {
                if (pMacroblock->macroblockType != MB_INTRA) {
                    if (pMacroblock->codedBlockPattern == 0xFF) {
                        nvCorrectKelvinFullFrameChromaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                    } else if (pMacroblock->codedBlockPattern != 0) {
                        nvCorrectKelvinFrameChromaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                    }
                }
                pMacroblock++;
            }

            if (fieldTypeCount > 0) {

                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_NO_OPERATION | 0x40000);
                nvPushData(1, 0);

                // Change destination pitch to field pitch
                nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_SURFACE_PITCH | 0x40000);
                nvPushData(3, ((nvMoCompParams.surfaceLumaPitch << 17) | (nvMoCompParams.surfaceLumaPitch << 1)));

                // Change texture1 surface offset to point to block of half bias values (0x80)
                nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(5, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

                // Change texture0 pitch to 16 bytes
                nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(7, 16 << 16);
                nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
                nvPushData(9, 16 << 16); // half bias Intra block pitch

                nvPusherAdjust(10);

                if (pDriverData->bMCCurrentExecuteFunction ==
                    EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
                    // Modify combiners to perform non-prebiased intrablock correction
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                  NV097_SET_COMBINER_COLOR_ICW(0) | 0x40000);
                    nvPushData(1, moCompNonPrebiasedCorrectionICW);

                    nvPusherAdjust(2);

                    SET_KELVIN_UNBIASED_CORRECTION_DATA_FORMAT();
                } else {
                    SET_KELVIN_CORRECTION_DATA_FORMAT();
                }    

                pMacroblock = pMacroblock1;
                macroblockLimit = saveMacroblockLimit;

                while (--macroblockLimit >= 0) {
                    if ((pMacroblock->DCTType == DCT_FIELD) && (pMacroblock->macroblockType == MB_INTRA)) {
                        if (pMacroblock->codedBlockPattern >= 0xFC) {
                            nvCorrectKelvinFullFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                        } else if (pMacroblock->codedBlockPattern != 0) {
                            // Change texture0 pitch to it's default value of 8 bytes
                            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                           NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                            nvPushData(1, 8 << 16);

                            nvPusherAdjust(2);

                            hasPartialCorrections = TRUE;

                            nvCorrectKelvinFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);

                            // Change texture0 pitch to 16 bytes
                            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                           NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                            nvPushData(1, 16 << 16);

                            nvPusherAdjust(2);
                        }
                    }
                    pMacroblock++;
                }

                // Force both texture caches to flush
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_NO_OPERATION | 0x40000);
                nvPushData(1, 0);

                nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
                nvPushData(3, dwFirstAlignedIDCTOffset);
                nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(5, dwSurfaceOffset);

                nvPusherAdjust(6);

                // Change texture0 pitch to 16 bytes
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 16 << 16);
                nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
                nvPushData(3, nvMoCompParams.surfaceLumaPitch << 16);

                nvPusherAdjust(4);

                if (pDriverData->bMCCurrentExecuteFunction ==
                    EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
                    // Modify combiners to perform interblock correction
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                  NV097_SET_COMBINER_COLOR_ICW(0) | 0x40000);
                    nvPushData(1, moCompCorrectionICW);

                    nvPusherAdjust(2);
                }    

                SET_KELVIN_CORRECTION_DATA_FORMAT();

                nvMoCompParams.destinationFieldIs0 = TRUE;

                pMacroblock = pMacroblock1;
                macroblockLimit = saveMacroblockLimit;

                while (--macroblockLimit >= 0) {
                    if ((pMacroblock->DCTType == DCT_FIELD) && (pMacroblock->macroblockType != MB_INTRA)) {
                        if (pMacroblock->codedBlockPattern >= 0xFC) {
                            nvCorrectKelvinFullFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                        } else if (pMacroblock->codedBlockPattern != 0) {
                            // Change texture0 pitch to it's default value of 8 bytes
                            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                           NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                            nvPushData(1, 8 << 16);

                            nvPusherAdjust(2);

                            hasPartialCorrections = TRUE;

                            nvCorrectKelvinFrameLumaMacroblock(pMacroblock, CORRECTION_FIRST_PASS);

                            // Change texture0 pitch to 16 bytes
                            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                           NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                            nvPushData(1, 16 << 16);

                            nvPusherAdjust(2);
                        }
                    }
                    pMacroblock++;
                }

                // Restore surface pitch
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_SURFACE_PITCH | 0x40000);
                nvPushData(1, ((nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch));

                nvPusherAdjust(2);
            }
        }
        nvPusherStart(TRUE);
    }

    pLastMacroblock = pMacroblock - 1;

    if ((pDriverData->bMCPictureCodingType != PICTURE_TYPE_I) && (macroblockIndex > 0)) {
        long saveN = macroblockIndex;

        n = macroblockIndex;
        macroblockIndex = 0;
        pMacroblock1 = pMacroblocks;
        index = -32;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        // DO NOT REMOVE: This is necessary to work around an NV10 texture cache bug
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(3, dwSurfaceOffset);

        nvPusherAdjust(4);

        nvMoCompParams.currentDestinationField = 0;
        nvMoCompParams.destinationField = 0;

        // Change destination pitch back to frame pitch
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_SURFACE_PITCH | 0x40000);
        nvPushData(1, ((nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch));

        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                       NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
        nvPushData(3, nvMoCompParams.surfaceOffset);

        // Change texture0 pitch to 16 bytes
        nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                       NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
        nvPushData(5, 16 << 16);
        nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                       NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
        nvPushData(7, nvMoCompParams.surfaceLumaPitch << 16);

        nvPusherAdjust(8);

        if (pDriverData->bMCCurrentExecuteFunction ==
            EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
            // Modify combiners to perform interblock correction
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_COMBINER_COLOR_ICW(0) | 0x40000);
            nvPushData(1, moCompCorrectionICW);

            nvPusherAdjust(2);
        }    

        SET_KELVIN_CHROMA_CORRECTION_DATA_FORMAT();

        while (--n >= 0) {

            pMacroblock = &pMacroblock1[numCombinedMacroblocks[macroblockIndex]];

            firstAlignedIDCTIndex = pMacroblock->firstIDCTIndex & ~1;

            if (firstAlignedIDCTIndex - index >= 32) {
                pDriverData->dwMCFirstAlignedIDCTIndex = firstAlignedIDCTIndex;

                index = firstAlignedIDCTIndex;

                // Attempt to sanity check index
                if ((pDriverData->dwMCFirstAlignedIDCTIndex << 6) > pDriverData->dwMCIDCTAGPCtxDmaSize[0])
                    pDriverData->dwMCFirstAlignedIDCTIndex = 0;

                dwFirstAlignedIDCTOffset = pDriverData->dwMCFirstAlignedIDCTIndex * 64; // 64 bytes per IDCT block

                // Force both texture caches to flush
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
                nvPushData(1, dwFirstAlignedIDCTOffset);
                nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(3, dwSurfaceOffset);

                nvPusherAdjust(4);

                nvMoCompParams.currentDestinationField = 0;
                nvMoCompParams.destinationField = 0;
            }

            // Perform chroma overflow correction pass
            nvCorrectKelvinFrameChromaMacroblock(pMacroblock, CORRECTION_OVERFLOW_PASS);

            macroblockIndex++;
        }

        nvPusherStart(TRUE);

        n = saveN;
        macroblockIndex = 0;
        index = -32;

        // Change texture0 pitch to it's default value of 8 bytes
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
        nvPushData(1, 8 << 16);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
        nvPushData(3, nvMoCompParams.surfaceLumaPitch << 16);

        nvPusherAdjust(4);

        SET_KELVIN_CORRECTION_DATA_FORMAT();

        while (--n >= 0) {

            pMacroblock = &pMacroblock1[numCombinedMacroblocks[macroblockIndex]];

            firstAlignedIDCTIndex = pMacroblock->firstIDCTIndex & ~1;

            if (firstAlignedIDCTIndex - index >= 32) {
                pDriverData->dwMCFirstAlignedIDCTIndex = firstAlignedIDCTIndex;

                index = firstAlignedIDCTIndex;

                // Attempt to sanity check index
                if ((pDriverData->dwMCFirstAlignedIDCTIndex << 6) > pDriverData->dwMCIDCTAGPCtxDmaSize[0])
                    pDriverData->dwMCFirstAlignedIDCTIndex = 0;

                dwFirstAlignedIDCTOffset = pDriverData->dwMCFirstAlignedIDCTIndex * 64; // 64 bytes per IDCT block

                // Force both texture caches to flush
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
                nvPushData(1, dwFirstAlignedIDCTOffset);
                nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(3, dwSurfaceOffset);

                nvPusherAdjust(4);

                nvMoCompParams.currentDestinationField = 0;
                nvMoCompParams.destinationField = 0;
            }


            // Perform luma overflow correction pass
            if (pMacroblock->DCTType == DCT_FIELD) {

                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_NO_OPERATION | 0x40000);
                nvPushData(1, 0);

                nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_SURFACE_PITCH | 0x40000);
                nvPushData(3, ((nvMoCompParams.surfaceLumaPitch << 17) | (nvMoCompParams.surfaceLumaPitch << 1)));

                // Change texture0 pitch to default value of 8 bytes
                nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(5, 8 << 16);
                nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
                nvPushData(7, nvMoCompParams.surfaceLumaPitch << 17);

                nvPusherAdjust(8);

                nvCorrectKelvinFrameLumaMacroblock(pMacroblock, CORRECTION_OVERFLOW_PASS);

                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_NO_OPERATION | 0x40000);
                nvPushData(1, 0);

                // Restore surface pitch
                nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_SURFACE_PITCH | 0x40000);
                nvPushData(3, ((nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch));

                // Change texture0 pitch to default value of 8 bytes
                nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(5, 8 << 16);
                nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
                nvPushData(7, nvMoCompParams.surfaceLumaPitch << 16);

                nvPusherAdjust(8);

            } else
                nvCorrectKelvinFrameLumaMacroblock(pMacroblock, CORRECTION_OVERFLOW_PASS);

            macroblockIndex++;
        }

        nvPusherStart(TRUE);
    }

    if ((pLastMacroblock->vOffset >= maxHeight) && (pLastMacroblock->hOffset >= maxWidth))
        surfaceDecodeStatus = 15;
    else if ((unsigned long)pLastMacroblock->vOffset > (nvMoCompParams.surfaceLumaHeight - (nvMoCompParams.surfaceLumaHeight >> 2)))
        surfaceDecodeStatus = 7;
    else if ((unsigned long)pLastMacroblock->vOffset > (nvMoCompParams.surfaceLumaHeight >> 1))
        surfaceDecodeStatus = 3;
    else if ((unsigned long)pLastMacroblock->vOffset > (nvMoCompParams.surfaceLumaHeight >> 2))
        surfaceDecodeStatus = 1;

    if (surfaceDecodeStatus > formatConversionStatus) {
        LPNVMCSURFACEFLAGS lpSurfaceFlags;

        nvMoCompConvertSurfaceFormat(dst->fpVidMem, TRUE, (DWORD)surfaceDecodeStatus);

        lpSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

        while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
               (lpSurfaceFlags->dwMCSurfaceBase != dst->fpVidMem))
            lpSurfaceFlags++;

            if ((lpSurfaceFlags->bMCFrameAlreadyFormatConverted == 15) &&
                (lpSurfaceFlags->bMCFrameIsFiltered == FALSE) &&
                (pDriverData->bMCTemporalFilterDisabled == FALSE))
                nvMoCompTemporalFilter(dst->fpVidMem, pDriverData->bMCPercentCurrentField);
    }

    return TRUE;

} /* nvMoCompProcessKelvinFrameMacroblocks */


/*
 * nvMoCompProcessKelvinFieldMacroblocks
 *
 * Parses the current macroblock command stream and performs the necessary operations on
 * each macroblock.
 *
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvMoCompProcessKelvinFieldMacroblocks(LPNVDECODEMACROBLOCK pMacroblocks,
                                                      DWORD numMacroblocks, BYTE formatConversionStatus)
{
    LPDDRAWI_DDRAWSURFACE_LCL   dstx = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   dst = dstx->lpGbl;
    LPNVDECODEMACROBLOCK        pMacroblock;
    LPNVDECODEMACROBLOCK        pLastMacroblock;
    LPNVDECODEMACROBLOCK        pMacroblock1;
    unsigned long               dwFirstAlignedIDCTOffset;
    unsigned long               dwSurfaceOffset;
    unsigned long               moCompCorrectionICW;
    unsigned long               moCompNonPrebiasedCorrectionICW;
    long                        macroblockLimit;
    long                        n;
    long                        macroblockIndex;
    BYTE                        surfaceDecodeStatus = 0;
    BYTE                        numCombinedMacroblocks[256];
    short                       maxHeight = (short)(dst->wHeight >> 1) - 16;
    short                       maxWidth = (short)dst->wWidth - 16;
    int                         index,i;
    int                         firstAlignedIDCTIndex;

    nvMoCompParams.vertexMode = 0; // Initialize vertexMode to an invalid value
    nvMoCompParams.surfaceLumaPitch = dst->lPitch;
    nvMoCompParams.surfaceLumaHeight = (dst->wHeight + 1) & ~1;
    nvMoCompParams.surfaceOffset = VIDMEM_OFFSET(dst->fpVidMem);
    nvMoCompParams.surfaceChromaOffset = nvMoCompParams.surfaceLumaPitch * nvMoCompParams.surfaceLumaHeight;
    nvMoCompParams.surfaceBiasedIntraBlockOffset =
        (dst->lPitch * dst->wHeight) + (dst->lPitch * (dst->wHeight >> 1) + (8 * dst->lPitch));

    if (pDriverData->bMCPictureCodingType != PICTURE_TYPE_I) {

        if (!(nvInitKelvinForMoCompPrediction()))
            return FALSE;

        nvDoBidirectionalFieldPrediction = nvDoKelvinBidirectionalDVDFieldPrediction;
        nvDoTwoBidirectionalFieldPredictions = nvDoTwoKelvinBidirectionalDVDFieldPredictions;
        nvDoForwardFieldPrediction = nvDoKelvinForwardDVDFieldPrediction;
        nvDoTwoForwardFieldPredictions = nvDoTwoKelvinForwardDVDFieldPredictions;
        nvDoBackwardFieldPrediction = nvDoKelvinBackwardDVDFieldPrediction;
        nvDoTwoBackwardFieldPredictions = nvDoTwoKelvinBackwardDVDFieldPredictions;

        nvPredictFrameLumaMacroblock = nvPredictKelvinFrameLumaMacroblock;
        nvPredictFrameChromaMacroblock = nvPredictKelvinFrameChromaMacroblock;
        nvPredictFieldLumaMacroblock = nvPredictKelvinFieldLumaMacroblock;
        nvPredictFieldChromaMacroblock = nvPredictKelvinFieldChromaMacroblock;

        nvMoCompParams.currentForwardField = 0;
        nvMoCompParams.currentBackwardField = 0;
        nvMoCompParams.currentDestinationField = 0;

        if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_BOTTOM_FIELD) {

            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_NO_OPERATION | 0x40000);
            nvPushData(1, 0);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
            nvPushData(3, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceLumaPitch);

            nvPusherAdjust(4);

            nvMoCompParams.currentDestinationField = 1;
        }

        pMacroblock = pMacroblocks;
        n = numMacroblocks;
        macroblockIndex = 0;

        // Perform luma prediction pass
        while (n > 0) {
            numCombinedMacroblocks[macroblockIndex] = 1;
            if (pMacroblock->macroblockType == MB_MOTION_FORWARD) {
                if (n > 1) {
                    pMacroblock1 = pMacroblock + 1;
                    if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) {
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_FORWARD) &&
								(pMacroblock1->motionType == FIELD_STRUCTURE_MOTION_FIELD) &&
                                ((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
                                (pMacroblock->fieldSelect[0][0] == pMacroblock1->fieldSelect[0][0]) &&
								(*(long *)&pMacroblock->PMV[0][0][0] == *(long *)&pMacroblock1->PMV[0][0][0])) {
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
							if(n <= i+1)
								break;		//no more macroblock left
							pMacroblock1++;
                        }
					}else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_FORWARD) &&
								(pMacroblock1->motionType == FIELD_STRUCTURE_MOTION_16X8) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(nvMoCompCheckFieldPredictionEqual(pMacroblock, pMacroblock1, pMacroblock->macroblockType))){
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
							if(n <= i+1)
								break;
							pMacroblock1++;
						}
					}
                }
                nvPredictFieldLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
                pMacroblock += numCombinedMacroblocks[macroblockIndex];
                n -= numCombinedMacroblocks[macroblockIndex];
            } else if (pMacroblock->macroblockType == MB_MOTION_BACKWARD) {
                if (n > 1) {
                    pMacroblock1 = pMacroblock + 1;
                    if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) {
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_BACKWARD) &&
								(pMacroblock1->motionType == FIELD_STRUCTURE_MOTION_FIELD) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(pMacroblock->fieldSelect[0][1] == pMacroblock1->fieldSelect[0][1]) &&
								(*(long *)&pMacroblock->PMV[0][1][0] == *(long *)&pMacroblock1->PMV[0][1][0])) {
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
	
							if(n <= i+1)
								break;
							pMacroblock1++;
						}
                            
					} else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == MB_MOTION_BACKWARD) &&
								(pMacroblock1->motionType == FIELD_STRUCTURE_MOTION_16X8) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(nvMoCompCheckFieldPredictionEqual(pMacroblock, pMacroblock1, pMacroblock->macroblockType))){
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
	
							if(n <= i+1)
								break;
							pMacroblock1++;
						}
                    }
                }
                nvPredictFieldLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
                pMacroblock += numCombinedMacroblocks[macroblockIndex];
                n -= numCombinedMacroblocks[macroblockIndex];
            } else if (pMacroblock->macroblockType == (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) {
                if (n > 1) {
                    pMacroblock1 = pMacroblock + 1;
                    if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) {
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) &&
								(pMacroblock1->motionType == FIELD_STRUCTURE_MOTION_FIELD) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(nvMoCompCheckFieldPredictionEqual(pMacroblock, pMacroblock1, pMacroblock->macroblockType))) {
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
	
							if(n <= i+1)
								break;
							pMacroblock1++;
						}
                            
                    } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {
						//combine up to 5 adjacent macroblocks together
						for( i = 1; i <= 5; i++){
							if ((pMacroblock1->macroblockType == (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) &&
								(pMacroblock1->motionType == FIELD_STRUCTURE_MOTION_16X8) &&
								((pMacroblock1->hOffset - pMacroblock->hOffset) == 16 * i) &&
								(nvMoCompCheckFieldPredictionEqual(pMacroblock, pMacroblock1, pMacroblock->macroblockType))){
									numCombinedMacroblocks[macroblockIndex]++;
							}else
								break;
	
							if(n <= i+1)
								break;
							pMacroblock1++;
						}
                    }
                }
                nvPredictFieldLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
                pMacroblock += numCombinedMacroblocks[macroblockIndex];
                n -= numCombinedMacroblocks[macroblockIndex];
            } else {
                if (pMacroblock->macroblockType != MB_INTRA)
                    nvPredictFieldLumaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
                pMacroblock++;
                n--;
            }
            macroblockIndex++;
        }

        nvPusherStart(TRUE);

        pMacroblock = pMacroblocks;
        n = numMacroblocks;
        macroblockIndex = 0;

#ifdef  DEBUG
        if (moCompDebugLevel < 3) {
#endif  // DEBUG

        // Change surface offsets to chroma portion of surface
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);

        if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_BOTTOM_FIELD) {
            nvMoCompParams.currentDestinationField = 1;
            nvPushData(3, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceChromaOffset + nvMoCompParams.surfaceLumaPitch);
        } else {
            nvMoCompParams.currentDestinationField = 0;
            nvPushData(3, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceChromaOffset);
        }

        nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
        nvPushData(5, pDriverData->dwMCForwardSurfaceOffset + nvMoCompParams.surfaceChromaOffset);

        nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
        nvPushData(7, pDriverData->dwMCBackwardSurfaceOffset + nvMoCompParams.surfaceChromaOffset);

        nvPusherAdjust(8);

        nvMoCompParams.currentForwardField = 0;
        nvMoCompParams.currentBackwardField = 0;

        // Perform chroma prediction pass
        while (n > 0) {
            if (pMacroblock->macroblockType != MB_INTRA)
                nvPredictFieldChromaMacroblock(pMacroblock, numCombinedMacroblocks[macroblockIndex]);
            pMacroblock += numCombinedMacroblocks[macroblockIndex];
            n -= numCombinedMacroblocks[macroblockIndex];
            macroblockIndex++;
        }

        nvPusherStart(TRUE);

#ifdef  DEBUG
        }
#endif  // DEBUG
    }

    if (!(nvInitKelvinForMoCompCorrection()))
        return FALSE;

    SET_KELVIN_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

    nvDoAllIntraFieldCorrections = nvDoAllKelvinIntraDVDFieldCorrections;
    nvDoAllFieldCorrections = nvDoAllKelvinDVDFieldCorrections;
    nvDoIntraFieldCorrection = nvDoKelvinIntraDVDFieldCorrection;
    nvDoOptimizedIntraFieldCorrection = nvDoOptimizedKelvinIntraDVDFieldCorrection;
    nvDoFieldCorrection = nvDoKelvinDVDFieldCorrection;

    nvDoAllIntraFrameCorrections = nvDoAllKelvinIntraFrameCorrections;
    nvDoAllFrameCorrections = nvDoAllKelvinFrameCorrections;
    nvDoIntraFrameCorrection = nvDoKelvinIntraFrameCorrection;
    nvDoFrameCorrection = nvDoKelvinFrameCorrection;

    // Default motion comp correction ICW
    moCompCorrectionICW = (NV097_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                          (NV097_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                          (NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                          (NV097_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NORMAL << 21) |
                          (NV097_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                          (NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                          (NV097_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                          (NV097_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                          (NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1 << 8) |

                          (NV097_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                          (NV097_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                           NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    // Non-prebiased motion comp correction ICW
    moCompNonPrebiasedCorrectionICW = (NV097_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                                      (NV097_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                                      (NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                                      (NV097_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                                      (NV097_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                                      (NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                                      (NV097_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                                      (NV097_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                                      (NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0 << 8) |

                                      (NV097_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                                      (NV097_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                                       NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0;

    nvMoCompParams.currentDestinationField = 0;

    pMacroblock = pMacroblocks;
    n = numMacroblocks;

    // This assumes that the first IDCT index of the first macroblock in the command stream is the
    // lowest index in the entire command stream for this call.

    dwSurfaceOffset = pDriverData->dwMCDestinationSurfaceOffset;

    macroblockIndex = 0;

    index = 0;

    while (n > 0) {

        macroblockLimit = n;

        if (macroblockLimit > 32)
            macroblockLimit = 32;

        pDriverData->dwMCFirstAlignedIDCTIndex = pMacroblock->firstIDCTIndex & ~1;

        dwFirstAlignedIDCTOffset = pDriverData->dwMCFirstAlignedIDCTIndex * 64; // 64 bytes per IDCT block

        // Force both texture caches to flush
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
        nvPushData(1, dwFirstAlignedIDCTOffset);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
        nvPushData(3, dwSurfaceOffset);

        nvPusherAdjust(4);

        if (pDriverData->bMCCurrentExecuteFunction ==
            EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
            // Modify combiners to perform non-prebiased intrablock correction
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_COMBINER_COLOR_ICW(0) | 0x40000);
            nvPushData(1, moCompNonPrebiasedCorrectionICW);

            nvPusherAdjust(2);

            SET_KELVIN_UNBIASED_CORRECTION_DATA_FORMAT();
        } else {
            SET_KELVIN_CORRECTION_DATA_FORMAT();
        }    

        // Perform first correction pass
        if (pDriverData->bMCPictureCodingType == PICTURE_TYPE_I) {
            nvCorrectKelvinIntraField(pMacroblock, macroblockLimit);
            pMacroblock += macroblockLimit;
            n -= macroblockLimit;
        } else {
            long saveMacroblockLimit = macroblockLimit;

            pMacroblock1 = pMacroblock;

            // Change texture1 surface offset to point to block of half bias values (0x80)
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

            // Change texture0 pitch to 16 bytes
            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
            nvPushData(3, 16 << 16);
            nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
            nvPushData(5, 16 << 16); // half bias Intra block pitch

            nvPusherAdjust(6);

            while (--macroblockLimit >= 0) {
                if ((pMacroblock->overflowCodedBlockPattern != 0) && (pMacroblock->macroblockType != MB_INTRA))
                    numCombinedMacroblocks[macroblockIndex++] = (BYTE) index;
                index++;
                if ((pMacroblock->codedBlockPattern != 0) && (pMacroblock->macroblockType == MB_INTRA))
                     nvCorrectKelvinFieldMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                pMacroblock++;
                --n;
            }

            nvPusherStart(TRUE);

            // Force both texture caches to flush
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_NO_OPERATION | 0x40000);
            nvPushData(1, 0);

            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
            nvPushData(3, dwFirstAlignedIDCTOffset);
            nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(5, dwSurfaceOffset);

            nvPusherAdjust(6);

            // Change texture0 pitch to 16 bytes
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
            nvPushData(1, 16 << 16);
            nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
            nvPushData(3, nvMoCompParams.surfaceLumaPitch << 17);

            nvPusherAdjust(4);

            if (pDriverData->bMCCurrentExecuteFunction ==
                EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
                // Modify combiners to perform interblock correction
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_COMBINER_COLOR_ICW(0) | 0x40000);
                nvPushData(1, moCompCorrectionICW);

                nvPusherAdjust(2);
            }    

            SET_KELVIN_CORRECTION_DATA_FORMAT();

            nvMoCompParams.currentDestinationField = 0;

            pMacroblock = pMacroblock1;
            macroblockLimit = saveMacroblockLimit;

            while (--macroblockLimit >= 0) {
                if ((pMacroblock->codedBlockPattern != 0) && (pMacroblock->macroblockType != MB_INTRA))
                     nvCorrectKelvinFieldMacroblock(pMacroblock, CORRECTION_FIRST_PASS);
                pMacroblock++;
            }
        }

        nvPusherStart(TRUE);
    }

    pLastMacroblock = pMacroblock - 1;

    if ((pDriverData->bMCPictureCodingType != PICTURE_TYPE_I) && (macroblockIndex > 0)) {

        pMacroblock = pMacroblocks;
        n = macroblockIndex;
        macroblockIndex = 0;
        index = -32;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_NO_OPERATION | 0x40000);
        nvPushData(1, 0);

        // DO NOT REMOVE: This is necessary to work around an NV10 texture cache bug
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
        nvPushData(3, dwSurfaceOffset);

        nvPusherAdjust(4);

        if (pDriverData->bMCCurrentExecuteFunction ==
            EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
            // Modify combiners to perform interblock correction
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                          NV097_SET_COMBINER_COLOR_ICW(0) | 0x40000);
            nvPushData(1, moCompCorrectionICW);

            nvPusherAdjust(2);
        }    

        SET_KELVIN_CORRECTION_DATA_FORMAT();

        while (--n >= 0) {

            firstAlignedIDCTIndex = (&pMacroblock[numCombinedMacroblocks[macroblockIndex]])->firstIDCTIndex & ~1;

            if (firstAlignedIDCTIndex - index >= 32) {
                pDriverData->dwMCFirstAlignedIDCTIndex = firstAlignedIDCTIndex;

                index = firstAlignedIDCTIndex;

                // Attempt to sanity check index
                if ((pDriverData->dwMCFirstAlignedIDCTIndex << 6) > pDriverData->dwMCIDCTAGPCtxDmaSize[0])
                    pDriverData->dwMCFirstAlignedIDCTIndex = 0;

                dwFirstAlignedIDCTOffset = pDriverData->dwMCFirstAlignedIDCTIndex * 64; // 64 bytes per IDCT block

                // Force both texture caches to flush
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
                nvPushData(1, dwFirstAlignedIDCTOffset);
                nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(3, dwSurfaceOffset);

                nvPusherAdjust(4);

                nvMoCompParams.currentDestinationField = 0;
            }

            // Perform overflow correction pass
            nvCorrectKelvinFieldMacroblock((&pMacroblock[numCombinedMacroblocks[macroblockIndex]]), CORRECTION_OVERFLOW_PASS);

            macroblockIndex++;
        }

        nvPusherStart(TRUE);
    }

    if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD) {
        if ((pLastMacroblock->vOffset >= maxHeight) && (pLastMacroblock->hOffset >= maxWidth))
            surfaceDecodeStatus = 3;
        else if ((unsigned long)pLastMacroblock->vOffset > (nvMoCompParams.surfaceLumaHeight >> 2))
            surfaceDecodeStatus = 1;
    } else {
        if ((pLastMacroblock->vOffset >= maxHeight) && (pLastMacroblock->hOffset >= maxWidth))
            surfaceDecodeStatus = 12;
        else if ((unsigned long)pLastMacroblock->vOffset > (nvMoCompParams.surfaceLumaHeight >> 2))
            surfaceDecodeStatus = 4;
    }

    if (surfaceDecodeStatus > formatConversionStatus) {
        LPNVMCSURFACEFLAGS lpSurfaceFlags;

        nvMoCompConvertSurfaceFormat(dst->fpVidMem, TRUE, (DWORD)surfaceDecodeStatus);

        lpSurfaceFlags = (LPNVMCSURFACEFLAGS)&pDriverData->nvMCSurfaceFlags[0];

        while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
               (lpSurfaceFlags->dwMCSurfaceBase != dst->fpVidMem))
            lpSurfaceFlags++;

            if ((lpSurfaceFlags->bMCFrameAlreadyFormatConverted == 15) &&
                (lpSurfaceFlags->bMCFrameIsFiltered == FALSE) &&
                (pDriverData->bMCTemporalFilterDisabled == FALSE))
                nvMoCompTemporalFilter(dst->fpVidMem, pDriverData->bMCPercentCurrentField);
    }

    return TRUE;

} /* nvMoCompProcessKelvinFieldMacroblocks */


#endif  // NVARCH >= 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\MoCorrKelvin.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       MoCorrKelvin.cpp
 *  Content:    Windows98 DirectDraw 32 bit driver
 *
 ***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)


extern NVMOCOMPPARAMS nvMoCompParams;

extern PNVMCCORRFUNC2 nvDoAllIntraFieldCorrections;
extern PNVMCCORRFUNC2 nvDoAllFieldCorrections;
extern PNVMCCORRFUNC nvDoIntraFieldCorrection;
extern PNVMCCORRFUNC nvDoOptimizedIntraFieldCorrection;
extern PNVMCCORRFUNC nvDoFieldCorrection;

extern PNVMCCORRFUNC nvDoAllIntraFrameCorrections;
extern PNVMCCORRFUNC nvDoAllFrameCorrections;
extern PNVMCCORRFUNC nvDoIntraFrameCorrection;
extern PNVMCCORRFUNC nvDoFrameCorrection;

#ifdef  DEBUG
extern unsigned long moCompDebugLevel;
#endif  // DEBUG




/*
 * nvDoKelvinIntraFrameCorrection
 *
 * Performs frame correction on a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoKelvinIntraFrameCorrection(void)
{
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1;
    long                        texture1BlockY1;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0 = (nvMoCompParams.correctionY << 2); // Assumes textures with 8 byte pitch
    long                        texture0BlockX1;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;
    
    texture1BlockX1 = nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX;
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    // Change texture1 surface offset to point to block of half bias values (0x80)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

    // Change texture1 pitch to 16 bytes
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(3, 16 << 16); // half bias Intra block pitch

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(5, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40300000);

    nvPushKelvinMoCompQuadData(7);

    nvPushData(19, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(20, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(21);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoKelvinIntraFrameCorrection */


/*
 * nvDoAllKelvinIntraFrameCorrections
 *
 * Performs frame correction on all blocks in a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoAllKelvinIntraFrameCorrections(void)
{
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1;
    long                        texture1BlockY1;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0 = (nvMoCompParams.correctionY << 2); // Assumes textures with 8 byte pitch
    long                        texture0BlockX1;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;
    long                        nextBlockYOffset = 32 << 16;
    
    texture1BlockX1 = nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX;
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    // Change texture1 surface offset to point to block of half bias values (0x80)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

    // Change texture1 pitch to 16 bytes
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(3, 16 << 16); // half bias Intra block pitch

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(5, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40C00000);

    nvPushKelvinMoCompQuadData(7);

    texture0BlockY0 += nextBlockYOffset;
    texture0BlockY1 += nextBlockYOffset;
    blockX0 += 32;
    blockX1 += 32;
    
    nvPushKelvinMoCompQuadData(19);

    texture0BlockY0 += nextBlockYOffset;
    texture0BlockY1 += nextBlockYOffset;
    blockX0 -= 32;
    blockX1 -= 32;
    blockY0 += nextBlockYOffset;
    blockY1 += nextBlockYOffset;

    nvPushKelvinMoCompQuadData(31);

    texture0BlockY0 += nextBlockYOffset;
    texture0BlockY1 += nextBlockYOffset;
    blockX0 += 32;
    blockX1 += 32;

    nvPushKelvinMoCompQuadData(43);

    nvPushData(55, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(56, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(57);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoAllKelvinIntraFrameCorrections */



/*
 * nvDoKelvinFrameCorrection
 *
 * Performs frame correction on a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoKelvinFrameCorrection(void)
{
    // Texture1 and the destination surface are the same surface
    long texture1BlockX0;
    long texture1BlockY0;
    long texture1BlockX1;
    long texture1BlockY1;
    long texture0BlockX0 = 0;
    long texture0BlockY0 = nvMoCompParams.correctionY << 2; // Assumes textures with 8 byte pitch
    long texture0BlockX1;
    long texture0BlockY1;
    long blockX0;
    long blockX1;
    long blockY0;
    long blockY1;
    
    texture1BlockX0 = nvMoCompParams.blockX;
    texture1BlockY0 = nvMoCompParams.blockY;
    texture1BlockY0 <<= 16;
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX;
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40300000);

    nvPushKelvinMoCompQuadData(3);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoKelvinFrameCorrection */


/*
 * nvDoAllKelvinFrameCorrections
 *
 * Performs frame correction on all blocks in a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoAllKelvinFrameCorrections(void)
{
    // Texture1 and the destination surface are the same surface
    long texture1BlockX0;
    long texture1BlockY0;
    long texture1BlockX1;
    long texture1BlockY1;
    long texture0BlockX0 = 0;
    long texture0BlockY0 = nvMoCompParams.correctionY << 2; // Assumes textures with 8 byte pitch
    long texture0BlockX1;
    long texture0BlockY1;
    long blockX0;
    long blockX1;
    long blockY0;
    long blockY1;
    long nextBlockYOffset = 32 << 16;
    
    texture1BlockX0 = nvMoCompParams.blockX;
    texture1BlockY0 = nvMoCompParams.blockY;
    texture1BlockY0 <<= 16;
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;
    
    blockX0 = nvMoCompParams.blockX;
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40C00000);

    nvPushKelvinMoCompQuadData(3);

    texture1BlockX0 += 32;
    texture1BlockX1 += 32;
    texture0BlockY0 += nextBlockYOffset;
    texture0BlockY1 += nextBlockYOffset;
    blockX0 += 32;
    blockX1 += 32;
    
    nvPushKelvinMoCompQuadData(15);

    texture1BlockX0 -= 32;
    texture1BlockX1 -= 32;
    texture1BlockY0 += nextBlockYOffset;
    texture1BlockY1 += nextBlockYOffset;
    texture0BlockY0 += nextBlockYOffset;
    texture0BlockY1 += nextBlockYOffset;
    blockX0 -= 32;
    blockX1 -= 32;
    blockY0 += nextBlockYOffset;
    blockY1 += nextBlockYOffset;

    nvPushKelvinMoCompQuadData(27);

    texture1BlockX0 += 32;
    texture1BlockX1 += 32;
    texture0BlockY0 += nextBlockYOffset;
    texture0BlockY1 += nextBlockYOffset;
    blockX0 += 32;
    blockX1 += 32;

    nvPushKelvinMoCompQuadData(39);

    nvPushData(51, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(52, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(53);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoAllKelvinFrameCorrections */


/*
 * nvCorrectKelvinIntraFrame                                             
 *
 * Processes LUMA blocks in an IntraFrame then makes a 2nd pass and processes chroma blocks
 *
 * Note: All destination geometry sent to correction functions is in quarter pel units.  This is to avoid
 *       the need to update the composite transform as we alternate between prediction and correction.
 *       All correction (IDCT) texture geometry is in quarter pel units.
 *
 *       Due to celcius class limitations, the maximum post-transformed texture y coordinate is 2047 which
 *       corresponds to a maximum (IDCTIndex - firstAlignedIDCTIndex) value of 255 assuming all blocks are 8 texels high (by 8 texels wide).
 *
 */
void __stdcall nvCorrectKelvinIntraFrame(LPNVDECODEMACROBLOCK pFirstMacroblock, long macroblockCount)
{
    unsigned long               firstAlignedIndex = pDriverData->dwMCFirstAlignedIDCTIndex;
    LPNVDECODEMACROBLOCK        pMacroblock;
    unsigned long               IDCTIndex;
    long                        chromaVOffset;
    BYTE                        blockPattern;
    unsigned long               dstSurfacePitch;
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1 = 64;
    long                        texture1BlockY1 = 32 << 16;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0;
    long                        texture0BlockX1 = 64;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;
    int                         n;
    int                         i;
    
    dstSurfacePitch = (nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch;
            
    chromaVOffset = nvMoCompParams.surfaceLumaHeight << 2; // surfaceLumaHeight * 4 (for quarter pel coords)

    pMacroblock = pFirstMacroblock;
    n = macroblockCount;

    if (pMacroblock->codedBlockPattern == 0xFF) {
        // Change texture0 pitch to 16 bytes
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                       NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
        nvPushData(1, 16 << 16);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                       NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
        nvPushData(3, 16 << 16); // half bias Intra block pitch

        nvPusherAdjust(4);
    }   
    
    i = 0;
    
    nvMoCompParams.destinationField = 0;

    while (--n >= 0) {
    
        IDCTIndex = pMacroblock->firstIDCTIndex;
        blockPattern = pMacroblock->codedBlockPattern;

        if (pMacroblock->DCTType != DCT_FIELD) {
            nvMoCompParams.correctionField = 0;
            nvMoCompParams.destinationField = 0;
            nvMoCompParams.blockX = pMacroblock->hOffset << 2;
            nvMoCompParams.blockY = pMacroblock->vOffset << 2;

            if (blockPattern >= 0xFC) {
                nvMoCompParams.blockWidth = 64;
                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                nvDoIntraFrameCorrection();
            } else {
                // Change texture0 pitch to 8 bytes
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 8 << 16);
                nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
                nvPushData(3, 8 << 16); // half bias Intra block pitch

                nvPusherAdjust(4);

                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 32;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high
                nvDoAllIntraFrameCorrections();

                // Change texture0 pitch to 16 bytes
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 16 << 16);
                nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
                nvPushData(3, 16 << 16); // half bias Intra block pitch

                nvPusherAdjust(4);
            }

        } else
            i++;

        pMacroblock++;
    }
    
    nvPusherStart(TRUE);

    if (i > 0) { // if there were any DCT_FIELD macroblocks

        pMacroblock = pFirstMacroblock;
        n = macroblockCount;

        // Must temporarily set destination surface pitch back to double it's normal frame pitch
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_SURFACE_PITCH | 0x40000);
        nvPushData(1, dstSurfacePitch << 1);

        nvPusherAdjust(2);
                
        while (--n >= 0) {
        
            IDCTIndex = pMacroblock->firstIDCTIndex;
            blockPattern = pMacroblock->codedBlockPattern;

            if (pMacroblock->DCTType == DCT_FIELD) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.destinationField = 0;
                if (blockPattern >= 0xFC) {
                    nvMoCompParams.blockWidth = 64;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                } else {    
                    nvMoCompParams.blockWidth = 32;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                }
                nvMoCompParams.blockHeight = 32;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 1;

                if (blockPattern >= 0xFC) {
                    nvDoIntraFieldCorrection();
                } else {
                    // Change texture0 pitch to 8 bytes
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                  NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                    nvPushData(1, 8 << 16);
                    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                  NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
                    nvPushData(3, 8 << 16); // half bias Intra block pitch

                    nvPusherAdjust(4);

                    nvDoAllIntraFieldCorrections(8, 2);

                    // Change texture0 pitch to 16 bytes
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                  NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                    nvPushData(1, 16 << 16);
                    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                  NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
                    nvPushData(3, 16 << 16); // half bias Intra block pitch

                    nvPusherAdjust(4);
                }
            }

            pMacroblock++;
        }

        nvPusherStart(TRUE);

        pMacroblock = pFirstMacroblock;
        n = macroblockCount;

        while (--n >= 0) {
        
            IDCTIndex = pMacroblock->firstIDCTIndex;
            blockPattern = pMacroblock->codedBlockPattern;

            if (pMacroblock->DCTType == DCT_FIELD) {
                nvMoCompParams.blockHeight = 32;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 1;

                if (blockPattern >= 0xFC) {
                    nvMoCompParams.blockWidth = 64;
                    nvMoCompParams.destinationField = 1;
                    nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoIntraFieldCorrection();
                } else {
                    // Change texture0 pitch to 8 bytes
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                  NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                    nvPushData(1, 8 << 16);
                    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                  NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
                    nvPushData(3, 8 << 16); // half bias Intra block pitch

                    nvPusherAdjust(4);

                    nvMoCompParams.blockWidth = 32;
                    nvMoCompParams.destinationField = 1;
                    nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    nvDoAllIntraFieldCorrections(8, 2);

                    // Change texture0 pitch to 16 bytes
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                  NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                    nvPushData(1, 16 << 16);
                    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                  NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
                    nvPushData(3, 16 << 16); // half bias Intra block pitch

                    nvPusherAdjust(4);
                }
            }

            pMacroblock++;
        }

        nvPusherStart(TRUE);

    }
    

#ifdef  DEBUG
    if (moCompDebugLevel < 3) {
#endif  // DEBUG

    if (pDriverData->bMCCurrentExecuteFunction == EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
        SET_KELVIN_UNBIASED_CHROMA_CORRECTION_DATA_FORMAT();
    } else {
        SET_KELVIN_CHROMA_CORRECTION_DATA_FORMAT();
    }    

    // Chroma IDCTs are always frame based
    pMacroblock = pFirstMacroblock;
    n = macroblockCount;

    nvMoCompParams.destinationField = 0;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_PITCH | 0x40000);
    nvPushData(1, dstSurfacePitch);

    // Change texture1 surface offset to point to block of half bias values (0x80)
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(3, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

    // Temporarily change texture0 pitch to 16 bytes
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
    nvPushData(5, 16 << 16);
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(7, 16 << 16); // half bias Intra block pitch

    nvPusherAdjust(8);

    texture0BlockX1 = 32;
    texture1BlockX1 = 32;
 
    while (n >= 8) {

        n -= 8;
        
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_BEGIN_END | 0x40000);
        nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_INLINE_ARRAY | 0x41800000);

        i = 3;
        
        while (i < 99) {        
            IDCTIndex = pMacroblock->firstIDCTIndex + 4;

            texture0BlockY0 = (IDCTIndex - firstAlignedIndex) << 4; // Assumes textures with 8 byte pitch
            texture0BlockY1 = texture0BlockY0 + 32;
            texture0BlockY1 <<= 16;
            texture0BlockY0 <<= 16;

            nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);

            blockX0 = pMacroblock->hOffset << 1;
            blockY0 = nvMoCompParams.blockY;
            blockY0 <<= 16;
            blockX1 = blockX0 + 32;
            blockY1 = nvMoCompParams.blockY + 32;
            blockY1 <<= 16;

            nvPushKelvinMoCompQuadData(i);
            
            i += 12;

            pMacroblock++;
        }
        
        nvPushData(i, dDrawSubchannelOffset(NV_DD_KELVIN) +
                       NV097_SET_BEGIN_END | 0x40000);
        i++;
                       
        nvPushData(i, NV097_SET_BEGIN_END_OP_END);
        
        i++;

        nvPusherAdjust(i);

#ifdef  DEBUG
        if (moCompDebugLevel > 1)
            nvPusherStart(TRUE);
#endif  // DEBUG
    }

    while (--n >= 0) {
    
        IDCTIndex = pMacroblock->firstIDCTIndex + 4;

        texture0BlockY0 = (IDCTIndex - firstAlignedIndex) << 4; // Assumes textures with 8 byte pitch
        texture0BlockY1 = texture0BlockY0 + 32;
        texture0BlockY1 <<= 16;
        texture0BlockY0 <<= 16;

        nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);

        blockX0 = pMacroblock->hOffset << 1;
        blockY0 = nvMoCompParams.blockY;
        blockY0 <<= 16;
        blockX1 = blockX0 + 32;
        blockY1 = nvMoCompParams.blockY + 32;
        blockY1 <<= 16;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_BEGIN_END | 0x40000);
        nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_INLINE_ARRAY | 0x40300000);

        nvPushKelvinMoCompQuadData(3);

        nvPushData(15, dDrawSubchannelOffset(NV_DD_KELVIN) +
                       NV097_SET_BEGIN_END | 0x40000);
        nvPushData(16, NV097_SET_BEGIN_END_OP_END);

        nvPusherAdjust(17);

#ifdef  DEBUG
        if (moCompDebugLevel > 1)
            nvPusherStart(TRUE);
#endif  // DEBUG

        pMacroblock++;
    }

#ifdef  DEBUG
    }
#endif  // DEBUG

} /* nvCorrectKelvinIntraFrame */



/*
 * nvCorrectKelvinFullFrameLumaMacroblock
 *
 * Performs correction on all blocks in macroblock assuming Y0/Y1/Y2/Y3 are in NV optimized format
 *
 * Note: All destination geometry sent to correction functions is in quarter pel units.  This is to avoid
 *       the need to update the composite transform as we alternate between prediction and correction.
 *       All correction (IDCT) texture geometry is in quarter pel units.
 *
 *       Due to celcius class limitations, the maximum post-transformed texture y coordinate is 2047 which
 *       corresponds to a maximum (IDCTIndex - firstAlignedIDCTIndex) value of 255 assuming all blocks are 8 texels high (by 8 texels wide).
 *
 */
void __stdcall nvCorrectKelvinFullFrameLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType)
{
    unsigned long IDCTIndex = pMacroblock->firstIDCTIndex;
    unsigned long firstAlignedIndex = pDriverData->dwMCFirstAlignedIDCTIndex;
    unsigned long dstSurfacePitch;
    
    if (pMacroblock->DCTType == DCT_FIELD) {

        dstSurfacePitch = (nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch;

        nvMoCompParams.correctionField = 0;
        nvMoCompParams.destinationField = 0;
        nvMoCompParams.blockWidth = 64;
        nvMoCompParams.blockHeight = 32;
        nvMoCompParams.blockX = pMacroblock->hOffset << 2;
        nvMoCompParams.blockY = pMacroblock->vOffset << 1;

        if (pMacroblock->macroblockType != MB_INTRA) {           

            // Temporarily change texture1 pitch to match destination surface pitch
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
            nvPushData(1, dstSurfacePitch << 17);

            nvPusherAdjust(2);

            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
            nvDoFieldCorrection();
            nvMoCompParams.destinationField = 1;
            nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
            nvDoFieldCorrection();
            
            // Restore texture1 pitch to it's default value
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
            nvPushData(1, nvMoCompParams.surfaceLumaPitch << 16);

            nvPusherAdjust(2);

        } else {
            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
            nvDoIntraFieldCorrection();
            nvMoCompParams.destinationField = 1;
            nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
            nvDoIntraFieldCorrection();
        }

    } else {
        nvMoCompParams.correctionField = 0;
        nvMoCompParams.destinationField = 0;
        nvMoCompParams.blockX = pMacroblock->hOffset << 2;
        nvMoCompParams.blockY = pMacroblock->vOffset << 2;

        nvMoCompParams.blockWidth = 64;
        nvMoCompParams.blockHeight = 64;
        nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high

        if (pMacroblock->macroblockType != MB_INTRA) {
            nvDoFrameCorrection();
        } else
            nvDoIntraFrameCorrection();

    }

} /* nvCorrectKelvinFullFrameLumaMacroblock */


/*
 * nvCorrectKelvinFullFrameChromaMacroblock
 *
 * Performs correction on all blocks in macroblock assuming Y0/Y1/Y2/Y3 are in NV optimized format
 *
 * Note: All destination geometry sent to correction functions is in quarter pel units.  This is to avoid
 *       the need to update the composite transform as we alternate between prediction and correction.
 *       All correction (IDCT) texture geometry is in quarter pel units.
 *
 *       Due to celcius class limitations, the maximum post-transformed texture y coordinate is 2047 which
 *       corresponds to a maximum (IDCTIndex - firstAlignedIDCTIndex) value of 255 assuming all blocks are 8 texels high (by 8 texels wide).
 *
 */
void __stdcall nvCorrectKelvinFullFrameChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType)
{
    unsigned long IDCTIndex = pMacroblock->firstIDCTIndex;
    unsigned long firstAlignedIndex = pDriverData->dwMCFirstAlignedIDCTIndex;
    long chromaVOffset;
    
    chromaVOffset = nvMoCompParams.surfaceLumaHeight << 2; // surfaceLumaHeight * 4 (for quarter pel coords)

    IDCTIndex += 4;

#ifdef  DEBUG
    if (moCompDebugLevel < 3) {
#endif  // DEBUG

    // Chroma IDCTs are always frame based
    nvMoCompParams.correctionField = 0;
    nvMoCompParams.destinationField = 0;
    nvMoCompParams.blockWidth = 32;
    nvMoCompParams.blockHeight = 32;
    nvMoCompParams.blockX = pMacroblock->hOffset << 1;
    nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);
    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high

    if (pMacroblock->macroblockType != MB_INTRA)           
        nvDoFrameCorrection();
    else
        nvDoIntraFrameCorrection();

#ifdef  DEBUG
    }
#endif  // DEBUG

} /* nvCorrectKelvinFullFrameChromaMacroblock */


/*
 * nvCorrectKelvinFrameLumaMacroblock
 *
 * Determines which blocks in the block pattern need correction and calls the appropriate function
 *
 * Note: All destination geometry sent to correction functions is in quarter pel units.  This is to avoid
 *       the need to update the composite transform as we alternate between prediction and correction.
 *       All correction (IDCT) texture geometry is in quarter pel units.
 *
 *       Due to celcius class limitations, the maximum post-transformed texture y coordinate is 2047 which
 *       corresponds to a maximum (IDCTIndex - firstAlignedIDCTIndex) value of 255 assuming all blocks are 8 texels high (by 8 texels wide).
 *
 */
void __stdcall nvCorrectKelvinFrameLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType)
{
    unsigned long IDCTIndex = pMacroblock->firstIDCTIndex;
    unsigned long firstAlignedIndex = pDriverData->dwMCFirstAlignedIDCTIndex;
    BYTE blockPattern;
    unsigned long dstSurfacePitch;
    
    if (correctionType == CORRECTION_FIRST_PASS) {

        blockPattern = pMacroblock->codedBlockPattern;

    } else {

        blockPattern = pMacroblock->codedBlockPattern;
        if (blockPattern & CBP_Y0)
            IDCTIndex++;
        if (blockPattern & CBP_Y1)
            IDCTIndex++;
        if (blockPattern & CBP_Y2)
            IDCTIndex++;
        if (blockPattern & CBP_Y3)
            IDCTIndex++;
        if (blockPattern & (CBP_CR | CBP_CB))
            IDCTIndex += 2;
        blockPattern = pMacroblock->overflowCodedBlockPattern;
    }

    if (pMacroblock->DCTType == DCT_FIELD) {
        // Must temporarily set destination surface pitch back to double it's normal frame pitch
        dstSurfacePitch = (nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch;

        if (pMacroblock->macroblockType != MB_INTRA) {           
            // Temporarily change texture1 pitch to match destination surface pitch
            nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                           NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
            nvPushData(1, dstSurfacePitch << 17);

            nvPusherAdjust(2);
        }
    }

    if ((blockPattern & (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)) == (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)) {

        if (pMacroblock->DCTType == DCT_FIELD) {
            nvMoCompParams.correctionField = 0;
            nvMoCompParams.destinationField = 0;
            nvMoCompParams.blockHeight = 32;
            nvMoCompParams.blockX = pMacroblock->hOffset << 2;
            nvMoCompParams.blockY = pMacroblock->vOffset << 1;

            if (pMacroblock->macroblockType != MB_INTRA) {           

                if (blockPattern >= 0xFC) {

                    // Temporarily change texture0 pitch to 16 bytes
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                   NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                    nvPushData(1, 16 << 16);

                    nvPusherAdjust(2);

                    nvMoCompParams.blockWidth = 64;

                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoFieldCorrection();
                    nvMoCompParams.destinationField = 1;
                    nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoFieldCorrection();

                    // Restore texture0 pitch to default value
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                   NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                    nvPushData(1, 8 << 16);

                    nvPusherAdjust(2);

                } else {

                    nvMoCompParams.blockWidth = 32;

                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    nvDoAllFieldCorrections(8, 2);
                    nvMoCompParams.destinationField = 1;
                    nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    nvDoAllFieldCorrections(8, 2);
                }
                
            } else {
                if (blockPattern >= 0xFC) {
                    // Temporarily change texture0 pitch to 16 bytes
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                   NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                    nvPushData(1, 16 << 16);

                    nvPusherAdjust(2);

                    nvMoCompParams.blockWidth = 64;

                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoIntraFieldCorrection();
                    nvMoCompParams.destinationField = 1;
                    nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoIntraFieldCorrection();

                    // Restore texture0 pitch to default value
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                                   NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                    nvPushData(1, 8 << 16);

                    nvPusherAdjust(2);
                } else {
                    nvMoCompParams.blockWidth = 32;

                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    nvDoAllIntraFieldCorrections(8, 2);
                    nvMoCompParams.destinationField = 1;
                    nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    nvDoAllIntraFieldCorrections(8, 2);
                }
            }
            
            if (pMacroblock->macroblockType != MB_INTRA) {           
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
                nvPushData(1, nvMoCompParams.surfaceLumaPitch << 16);

                nvPusherAdjust(2);
            }
        } else {
            nvMoCompParams.correctionField = 0;
            nvMoCompParams.destinationField = 0;
            nvMoCompParams.blockX = pMacroblock->hOffset << 2;
            nvMoCompParams.blockY = pMacroblock->vOffset << 2;

            if (blockPattern >= 0xFC) {
                nvMoCompParams.blockWidth = 64;
                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high

                // Temporarily change texture0 pitch to 16 bytes
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 16 << 16);

                nvPusherAdjust(2);

                if (pMacroblock->macroblockType != MB_INTRA) {          
                    nvDoFrameCorrection();
                } else
                    nvDoIntraFrameCorrection();

                // Restore texture0 pitch to default value
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 8 << 16);

                nvPusherAdjust(2);
            } else {
                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 32;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high

                if (pMacroblock->macroblockType != MB_INTRA) {          
                    nvDoAllFrameCorrections();
                } else
                    nvDoAllIntraFrameCorrections();
            }
        }

        IDCTIndex += 4;

    } else {

        nvMoCompParams.blockWidth = 32;
        nvMoCompParams.blockHeight = 32;

        if (blockPattern & CBP_Y0) {

            nvMoCompParams.correctionField = 0;
            nvMoCompParams.destinationField = 0; // Component Y0 is in destination field 0
            nvMoCompParams.blockX = pMacroblock->hOffset << 2;
            if (pMacroblock->DCTType == DCT_FIELD)
                nvMoCompParams.blockY = pMacroblock->vOffset << 1;
            else
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high

            if (pMacroblock->macroblockType != MB_INTRA)           
                nvDoFieldCorrection();
            else
                nvDoIntraFieldCorrection();

            IDCTIndex++;
        }

        if (blockPattern & CBP_Y1) {
            nvMoCompParams.correctionField = 0;
            nvMoCompParams.destinationField = 0; // Component Y1 is in destination field 0
            nvMoCompParams.blockX = (pMacroblock->hOffset + 8) << 2;
            if (pMacroblock->DCTType == DCT_FIELD)
                nvMoCompParams.blockY = pMacroblock->vOffset << 1;
            else
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
            
            if (pMacroblock->macroblockType != MB_INTRA)           
                nvDoFieldCorrection();
            else
                nvDoIntraFieldCorrection();

            IDCTIndex++;
        }

        if (blockPattern & CBP_Y2) {
            nvMoCompParams.correctionField = 0;
            nvMoCompParams.blockX = pMacroblock->hOffset << 2;
            if (pMacroblock->DCTType == DCT_FIELD) {
                nvMoCompParams.destinationField = 1; // Component Y2 is in destination field 1
                nvMoCompParams.blockY = pMacroblock->vOffset << 1;
            } else {
                nvMoCompParams.destinationField = 0;
                nvMoCompParams.blockY = (pMacroblock->vOffset + 8) << 2;
            }
            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high

            if (pMacroblock->macroblockType != MB_INTRA)           
                nvDoFieldCorrection();
            else
                nvDoIntraFieldCorrection();

            IDCTIndex++;
        }

        if (blockPattern & CBP_Y3) {
            nvMoCompParams.correctionField = 0;
            nvMoCompParams.blockX = (pMacroblock->hOffset + 8) << 2;
            if (pMacroblock->DCTType == DCT_FIELD) {
                nvMoCompParams.destinationField = 1; // Component Y3 is in destination field 1
                nvMoCompParams.blockY = pMacroblock->vOffset << 1;
            } else {
                nvMoCompParams.destinationField = 0;
                nvMoCompParams.blockY = (pMacroblock->vOffset + 8) << 2;
            }
            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high

            if (pMacroblock->macroblockType != MB_INTRA)           
                nvDoFieldCorrection();
            else
                nvDoIntraFieldCorrection();

            IDCTIndex++;
        }

        if (pMacroblock->DCTType == DCT_FIELD) {
            // Must temporarily set destination surface pitch back to double it's normal frame pitch
            dstSurfacePitch = (nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch;

            if (pMacroblock->macroblockType != MB_INTRA) {           
                // Temporarily change texture1 pitch to match destination surface pitch
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
                nvPushData(1, nvMoCompParams.surfaceLumaPitch << 16);

                nvPusherAdjust(2);
            }
        }
    }

} /* nvCorrectKelvinFrameLumaMacroblock */


/*
 * nvCorrectKelvinFrameChromaMacroblock
 *
 * Determines which blocks in the block pattern need correction and calls the appropriate function
 *
 * Note: All destination geometry sent to correction functions is in quarter pel units.  This is to avoid
 *       the need to update the composite transform as we alternate between prediction and correction.
 *       All correction (IDCT) texture geometry is in quarter pel units.
 *
 *       Due to celcius class limitations, the maximum post-transformed texture y coordinate is 2047 which
 *       corresponds to a maximum (IDCTIndex - firstAlignedIDCTIndex) value of 255 assuming all blocks are 8 texels high (by 8 texels wide).
 *
 */
void __stdcall nvCorrectKelvinFrameChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType)
{
    unsigned long IDCTIndex = pMacroblock->firstIDCTIndex;
    unsigned long firstAlignedIndex = pDriverData->dwMCFirstAlignedIDCTIndex;
    long chromaVOffset;
    BYTE blockPattern;
    
    chromaVOffset = nvMoCompParams.surfaceLumaHeight << 2; // surfaceLumaHeight * 4 (for quarter pel coords)

    if (correctionType == CORRECTION_FIRST_PASS) {

        blockPattern = pMacroblock->codedBlockPattern;

    } else {

        blockPattern = pMacroblock->codedBlockPattern;
        if (blockPattern & CBP_Y0)
            IDCTIndex++;
        if (blockPattern & CBP_Y1)
            IDCTIndex++;
        if (blockPattern & CBP_Y2)
            IDCTIndex++;
        if (blockPattern & CBP_Y3)
            IDCTIndex++;
        if (blockPattern & (CBP_CR | CBP_CB))
            IDCTIndex += 2;
        blockPattern = pMacroblock->overflowCodedBlockPattern;
    }

    if ((blockPattern & (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)) == (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)) {

        IDCTIndex += 4;

    } else {

        if (blockPattern & CBP_Y0)
            IDCTIndex++;

        if (blockPattern & CBP_Y1)
            IDCTIndex++;

        if (blockPattern & CBP_Y2)
            IDCTIndex++;

        if (blockPattern & CBP_Y3)
            IDCTIndex++;
    }

#ifdef  DEBUG
    if (moCompDebugLevel < 3) {
#endif  // DEBUG

    // Chroma IDCTs are always frame based

    if (blockPattern & (CBP_CB | CBP_CR)) {

        nvMoCompParams.correctionField = 0;
        nvMoCompParams.destinationField = 0;
        nvMoCompParams.blockWidth = 32;
        nvMoCompParams.blockHeight = 32;
        nvMoCompParams.blockX = pMacroblock->hOffset << 1;
        nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);
        nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high

        if (pMacroblock->macroblockType != MB_INTRA)           
            nvDoFrameCorrection();
        else
            nvDoIntraFrameCorrection();
    }

#ifdef  DEBUG
    }
#endif  // DEBUG

} /* nvCorrectKelvinFrameChromaMacroblock */




/*
 * nvDoAllKelvinIntraDVDFieldCorrections
 *
 * Performs field correction on all blocks within a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoAllKelvinIntraDVDFieldCorrections(long correctionYIncr, long numBlocks)
{
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1;
    long                        texture1BlockY1;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0 = (nvMoCompParams.correctionY << 2); // Assumes textures with 8 byte pitch
    long                        texture0BlockX1;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;
    long                        yIncr = correctionYIncr << 18;
    long                        nextBlockYOffset = 32 << 16;
    
    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture1BlockX1 = nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX;

    if (nvMoCompParams.destinationField != 0)
        blockX0 += nvMoCompParams.surfaceLumaPitch << 2; // Geometry is referenced in quarter pel coords
    
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;
    
    // Change texture1 surface offset to point to block of half bias values (0x80)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

    // Change texture1 pitch to 16 bytes
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(3, 16 << 16); // half bias Intra block pitch

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(5, NV097_SET_BEGIN_END_OP_QUADS);

    if (numBlocks == 2)
        nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_INLINE_ARRAY | 0x40600000);
    else
        nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_INLINE_ARRAY | 0x40C00000);
    
    nvPushKelvinMoCompQuadData(7);

    texture0BlockY0 += yIncr;
    texture0BlockY1 += yIncr;
    blockX0 += 32;
    blockX1 += 32;
    
    nvPushKelvinMoCompQuadData(19);

    nvPusherAdjust(31);

    if (numBlocks == 4) {

        texture0BlockY0 += yIncr;
        texture0BlockY1 += yIncr;
        blockX0 -= 32;
        blockX1 -= 32;
        blockY0 += nextBlockYOffset;
        blockY1 += nextBlockYOffset;

        nvPushKelvinMoCompQuadData(0);

        texture0BlockY0 += yIncr;
        texture0BlockY1 += yIncr;
        blockX0 += 32;
        blockX1 += 32;

        nvPushKelvinMoCompQuadData(12);

        nvPusherAdjust(24);
    }

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(2);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoAllKelvinIntraDVDFieldCorrections */



/*
 * nvDoAllKelvinDVDFieldCorrections
 *
 * Performs field correction on all blocks within a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoAllKelvinDVDFieldCorrections(long correctionYIncr, long numBlocks)
{
    // Texture1 and the destination surface are the same surface
    long texture1BlockX0;
    long texture1BlockY0;
    long texture1BlockX1;
    long texture1BlockY1;
    long texture0BlockX0 = 0;
    long texture0BlockY0 = nvMoCompParams.correctionY << 2; // Assumes textures with 8 byte pitch
    long texture0BlockX1;
    long texture0BlockY1;
    long blockX0;
    long blockX1;
    long blockY0;
    long blockY1;
    long yIncr = correctionYIncr << 18;
    long nextBlockYOffset = 32 << 16;
    
    texture1BlockX0 = nvMoCompParams.blockX;

    blockX0 = nvMoCompParams.blockX;

    if (nvMoCompParams.destinationField != 0) {
        texture1BlockX0 += nvMoCompParams.surfaceLumaPitch << 2;
        blockX0 += nvMoCompParams.surfaceLumaPitch << 2; // Geometry is referenced in quarter pel coords
    }
    
    texture1BlockY0 = nvMoCompParams.blockY;
    texture1BlockY0 <<= 16;
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;
    
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;
    
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    if (numBlocks == 2)
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_INLINE_ARRAY | 0x40600000);
    else
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_INLINE_ARRAY | 0x40C00000);

    nvPushKelvinMoCompQuadData(3);

    texture1BlockX0 += 32;
    texture1BlockX1 += 32;
    texture0BlockY0 += yIncr;
    texture0BlockY1 += yIncr;
    blockX0 += 32;
    blockX1 += 32;
    
    nvPushKelvinMoCompQuadData(15);

    nvPusherAdjust(27);

    if (numBlocks == 4) {

        texture1BlockX0 -= 32;
        texture1BlockX1 -= 32;
        texture1BlockY0 += nextBlockYOffset;
        texture1BlockY1 += nextBlockYOffset;
        texture0BlockY0 += yIncr;
        texture0BlockY1 += yIncr;
        blockX0 -= 32;
        blockX1 -= 32;
        blockY0 += nextBlockYOffset;
        blockY1 += nextBlockYOffset;

        nvPushKelvinMoCompQuadData(0);

        texture1BlockX0 += 32;
        texture1BlockX1 += 32;
        texture0BlockY0 += yIncr;
        texture0BlockY1 += yIncr;
        blockX0 += 32;
        blockX1 += 32;

        nvPushKelvinMoCompQuadData(12);

        nvPusherAdjust(24);
    }
    
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(2);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoAllKelvinDVDFieldCorrections */


/*
 * nvDoKelvinIntraDVDFieldCorrection
 *
 * Performs field correction on a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoKelvinIntraDVDFieldCorrection()
{
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1;
    long                        texture1BlockY1;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0 = (nvMoCompParams.correctionY << 2); // Assumes textures with 8 byte pitch
    long                        texture0BlockX1;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;

    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture1BlockX1 = nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX;

    if (nvMoCompParams.destinationField != 0)
        blockX0 += nvMoCompParams.surfaceLumaPitch << 2; // Geometry is referenced in quarter pel coords
    
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    // Change texture1 surface offset to point to block of half bias values (0x80)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

    // Change texture1 pitch to 16 bytes
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(3, 16 << 16); // half bias Intra block pitch

    nvPusherAdjust(4);
    
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40300000);

    nvPushKelvinMoCompQuadData(3);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoKelvinIntraDVDFieldCorrection */


/*
 * nvDoOptimizedKelvinIntraDVDFieldCorrection
 *
 * Performs field correction on a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoOptimizedKelvinIntraDVDFieldCorrection()
{
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1;
    long                        texture1BlockY1;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0 = (nvMoCompParams.correctionY << 2); // Assumes textures with 8 byte pitch
    long                        texture0BlockX1;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;

    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture1BlockX1 = nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX;

    if (nvMoCompParams.destinationField != 0)
        blockX0 += nvMoCompParams.surfaceLumaPitch << 2; // Geometry is referenced in quarter pel coords
    
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40300000);

    nvPushKelvinMoCompQuadData(3);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoOptimizedKelvinIntraDVDFieldCorrection */


/*
 * nvDoKelvinDVDFieldCorrection
 *
 * Performs field correction on a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoKelvinDVDFieldCorrection(void)
{
    // Texture1 and the destination surface are the same surface
    long texture1BlockX0;
    long texture1BlockY0;
    long texture1BlockX1;
    long texture1BlockY1;
    long texture0BlockX0 = 0;
    long texture0BlockY0 = nvMoCompParams.correctionY << 2; // Assumes textures with 8 byte pitch
    long texture0BlockX1;
    long texture0BlockY1;
    long blockX0;
    long blockX1;
    long blockY0;
    long blockY1;
    
    texture1BlockX0 = nvMoCompParams.blockX;

    blockX0 = nvMoCompParams.blockX;

    if (nvMoCompParams.destinationField != 0) {
        texture1BlockX0 += nvMoCompParams.surfaceLumaPitch << 2;
        blockX0 += nvMoCompParams.surfaceLumaPitch << 2; // Geometry is referenced in quarter pel coords
    }
    
    texture1BlockY0 = nvMoCompParams.blockY;
    texture1BlockY0 <<= 16;
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40300000);

    nvPushKelvinMoCompQuadData(3);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoKelvinDVDFieldCorrection */



/*
 * nvCorrectKelvinIntraField
 *
 * Processes LUMA blocks in an IntraField then makes a 2nd pass and processes chroma blocks
 *
 * Note: All destination geometry sent to correction functions is in quarter pel units.  This is to avoid
 *       the need to update the composite transform as we alternate between prediction and correction.
 *       All correction (IDCT) texture geometry is in quarter pel units.
 *
 *       Due to celcius class limitations, the maximum post-transformed texture y coordinate is 2047 which
 *       corresponds to a maximum (IDCTIndex - firstAlignedIDCTIndex) value of 255 assuming all blocks are 8 texels high (by 8 texels wide).
 *
 */
void __stdcall nvCorrectKelvinIntraField(LPNVDECODEMACROBLOCK pFirstMacroblock, long macroblockCount)
{
    unsigned long               firstAlignedIndex = pDriverData->dwMCFirstAlignedIDCTIndex;
    LPNVDECODEMACROBLOCK        pMacroblock;
    unsigned long               IDCTIndex;
    unsigned long               dwSurfaceOffset;
    long                        chromaVOffset;
    BYTE                        blockPattern;
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1 = 64;
    long                        texture1BlockY1 = 32 << 16;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0;
    long                        texture0BlockX1 = 64;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;
    int                         n;
    int                         i;
    
    chromaVOffset = nvMoCompParams.surfaceLumaHeight << 1;

    // Change texture1 surface offset to point to block of half bias values (0x80)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

    // Change texture1 pitch to 16 bytes
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(3, 16 << 16); // half bias Intra block pitch

    nvPusherAdjust(4);
    
    if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD)
        nvMoCompParams.destinationField = 0;
    else    
        nvMoCompParams.destinationField = 1;

    pMacroblock = pFirstMacroblock;
    n = macroblockCount;

    while (--n >= 0) {
    
        IDCTIndex = pMacroblock->firstIDCTIndex;
        blockPattern = pMacroblock->codedBlockPattern;

        if (pMacroblock->DCTType == DCT_FIELD) {
            if (blockPattern >= 0xFC) {
                nvMoCompParams.blockWidth = 64;
                nvMoCompParams.blockHeight = 16;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;

                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                nvDoOptimizedIntraFieldCorrection();
                
                nvMoCompParams.correctionField = 1;
                nvMoCompParams.blockY += 16;

                nvDoOptimizedIntraFieldCorrection();

                // IDCTIndex += 2;
                
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockY += 16;
                nvMoCompParams.correctionY += 8; // (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                nvDoOptimizedIntraFieldCorrection();
                
                nvMoCompParams.correctionField = 1;
                nvMoCompParams.blockY += 16;

                nvDoOptimizedIntraFieldCorrection();
                
            } else {
                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 16;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                nvDoAllIntraFieldCorrections(8, 4);
                
                nvMoCompParams.correctionField = 1;
                nvMoCompParams.blockY += 16;

                nvDoAllIntraFieldCorrections(8, 4);
            }
        } else {
            if (blockPattern >= 0xFC) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockWidth = 64;
                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                
                nvDoOptimizedIntraFieldCorrection();
            } else {
                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 32;

                // Temporarily change texture0 pitch to 8 bytes so that each scanline in IDCT block will be used
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 8 << 16);

                nvPusherAdjust(2);
                
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high

                nvDoOptimizedIntraFieldCorrection();

                // IDCTIndex++;

                nvMoCompParams.blockX += 32;
                nvMoCompParams.correctionY += 8; // (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high

                nvDoOptimizedIntraFieldCorrection();

                IDCTIndex++;

                nvMoCompParams.blockX -= 32;
                nvMoCompParams.blockY += 32;
                nvMoCompParams.correctionY += 8; // (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high

                nvDoOptimizedIntraFieldCorrection();

                IDCTIndex++;

                nvMoCompParams.blockX += 32;
                nvMoCompParams.correctionY += 8; // (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high

                nvDoOptimizedIntraFieldCorrection();

                // Restore texture0 pitch to it's default value of 16 bytes
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 16 << 16);

                nvPusherAdjust(2);
            }    
        }
        
        pMacroblock++;
    }
    
    nvPusherStart(TRUE);

    // Chroma IDCTs are always frame based

    dwSurfaceOffset = 0; // Assume destination field 0
    
    if (nvMoCompParams.destinationField != 0) {
        dwSurfaceOffset += nvMoCompParams.surfaceLumaPitch << 2; // Geometry is referenced in quarter pel coords
    }

    pMacroblock = pFirstMacroblock;
    n = macroblockCount;

    while (n >= 8) {

        n -= 8;
        
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_BEGIN_END | 0x40000);
        nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_INLINE_ARRAY | 0x41800000);
        
        i = 3;
        
        while (i < 99) {        
            IDCTIndex = pMacroblock->firstIDCTIndex + 4;

            texture0BlockY0 = (IDCTIndex - firstAlignedIndex) << 4; // Assumes textures with 8 byte pitch
            texture0BlockY1 = texture0BlockY0 + 32;
            texture0BlockY1 <<= 16;
            texture0BlockY0 <<= 16;

            nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);

            blockX0 = dwSurfaceOffset + (pMacroblock->hOffset << 2);
            blockY0 = nvMoCompParams.blockY;
            blockY0 <<= 16;
            blockX1 = blockX0 + 64;
            blockY1 = nvMoCompParams.blockY + 32;
            blockY1 <<= 16;

            nvPushKelvinMoCompQuadData(i);
            
            i += 12;

            pMacroblock++;
        }
        
        nvPushData(i, dDrawSubchannelOffset(NV_DD_KELVIN) +
                       NV097_SET_BEGIN_END | 0x40000);
        i++;

        nvPushData(i, NV097_SET_BEGIN_END_OP_END);

        i++;
        
        nvPusherAdjust(i);
    }

    while (--n >= 0) {
    
        IDCTIndex = pMacroblock->firstIDCTIndex + 4;

        texture0BlockY0 = (IDCTIndex - firstAlignedIndex) << 4; // Assumes textures with 8 byte pitch
        texture0BlockY1 = texture0BlockY0 + 32;
        texture0BlockY1 <<= 16;
        texture0BlockY0 <<= 16;

        nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);

        blockX0 = dwSurfaceOffset + (pMacroblock->hOffset << 2);
        blockY0 = nvMoCompParams.blockY;
        blockY0 <<= 16;
        blockX1 = blockX0 + 64;
        blockY1 = nvMoCompParams.blockY + 32;
        blockY1 <<= 16;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_BEGIN_END | 0x40000);
        nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_INLINE_ARRAY | 0x40300000);

        nvPushKelvinMoCompQuadData(3);

        nvPushData(15, dDrawSubchannelOffset(NV_DD_KELVIN) +
                       NV097_SET_BEGIN_END | 0x40000);
        nvPushData(16, NV097_SET_BEGIN_END_OP_END);

        nvPusherAdjust(17);

        pMacroblock++;
    }
} /* nvCorrectKelvinIntraField */


/*
 * nvCorrectKelvinFieldMacroblock
 *
 * Determines which blocks in the block pattern need correction and calls the appropriate function
 *
 * Note: All destination geometry sent to correction functions is in quarter pel units.  This is to avoid
 *       the need to update the composite transform as we alternate between prediction and correction.
 *       All correction (IDCT) texture geometry is in quarter pel units.
 *
 *       Due to celcius class limitations, the maximum post-transformed texture y coordinate is 2047 which
 *       corresponds to a maximum (IDCTIndex - firstAlignedIDCTIndex) value of 511 assuming all blocks are 4 texels high (by 16 texels wide with 8 texels per field).
 *
 */
void __stdcall nvCorrectKelvinFieldMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType)
{
    unsigned long               IDCTIndex = pMacroblock->firstIDCTIndex;
    unsigned long               firstAlignedIndex = pDriverData->dwMCFirstAlignedIDCTIndex;
    long                        chromaVOffset;
    BYTE                        blockPattern;
    
    chromaVOffset = nvMoCompParams.surfaceLumaHeight << 1;

    if (correctionType == CORRECTION_FIRST_PASS) {

        blockPattern = pMacroblock->codedBlockPattern;

    } else {

        blockPattern = pMacroblock->codedBlockPattern;
        if (blockPattern & CBP_Y0)
            IDCTIndex++;
        if (blockPattern & CBP_Y1)
            IDCTIndex++;
        if (blockPattern & CBP_Y2)
            IDCTIndex++;
        if (blockPattern & CBP_Y3)
            IDCTIndex++;
        if (blockPattern & (CBP_CR | CBP_CB))
            IDCTIndex += 2;
        blockPattern = pMacroblock->overflowCodedBlockPattern;
    }

    if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD)
        nvMoCompParams.destinationField = 0;
    else    
        nvMoCompParams.destinationField = 1;

    if (pMacroblock->macroblockType != MB_INTRA) {          
        if  ((blockPattern >= 0xFC) || 
            ((pMacroblock->DCTType == DCT_FIELD) &&
            ((blockPattern & (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)) == (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)))) {

            if (pMacroblock->DCTType == DCT_FIELD) {
                if (blockPattern >= 0xFC) {
                    nvMoCompParams.blockWidth = 64;
                    nvMoCompParams.blockHeight = 16;
                    nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                    nvDoFieldCorrection();
                    
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;

                    nvDoFieldCorrection();

                    // IDCTIndex += 2;
                    
                    nvMoCompParams.correctionY += 8; // (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.blockY += 16;

                    nvDoFieldCorrection();

                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;

                    nvDoFieldCorrection();
                    
                } else {
                    nvMoCompParams.blockWidth = 32;
                    nvMoCompParams.blockHeight = 16;
                    nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                    nvDoAllFieldCorrections(8, 4);
                    
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;

                    nvDoAllFieldCorrections(8, 4);
                }
            } else {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockWidth = 64;
                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                
                nvDoFieldCorrection();
            }
            
            IDCTIndex += 4;

        } else {

            if (pMacroblock->DCTType == DCT_FRAME) {
                // Temporarily change texture0 pitch to 8 bytes so that each scanline in IDCT block will be used
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 8 << 16);

                nvPusherAdjust(2);

                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 32;
            } else {
                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 16;
            }

            if (blockPattern & CBP_Y0) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    nvDoFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high
                    nvDoFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;
                    nvDoFieldCorrection();
                }

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y1) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = (pMacroblock->hOffset + 8) << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    nvDoFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY = 16;
                    nvDoFieldCorrection();
                }            

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y2) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = (pMacroblock->vOffset + 8) << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high
                    nvDoFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;
                    nvDoFieldCorrection();
                }

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y3) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = (pMacroblock->hOffset + 8) << 2;
                nvMoCompParams.blockY = (pMacroblock->vOffset + 8) << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high
                    nvDoFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;
                    nvDoFieldCorrection();
                }

                IDCTIndex++;
            }

            if (pMacroblock->DCTType == DCT_FRAME) {
                // Restore texture0 pitch to it's default value of 16 bytes
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 16 << 16);

                nvPusherAdjust(2);
            }
        }
        
#ifdef  DEBUG
        if (moCompDebugLevel < 3) {
#endif  // DEBUG

        // Chroma IDCTs are always frame based

        if (blockPattern & (CBP_CB | CBP_CR)) {

            nvMoCompParams.correctionField = 0;
            nvMoCompParams.blockWidth = 64;
            nvMoCompParams.blockHeight = 32;
            nvMoCompParams.blockX = pMacroblock->hOffset << 2;
            nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);
            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high

            nvDoFieldCorrection();
        }

#ifdef  DEBUG
        }
#endif  // DEBUG

    } else { // MB_INTRA

        // Change texture1 surface offset to point to block of half bias values (0x80)
        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
        nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

        // Change texture1 pitch to 16 bytes
        nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
        nvPushData(3, 16 << 16); // half bias Intra block pitch

        nvPusherAdjust(4);

        if  ((blockPattern >= 0xFC) || 
            ((pMacroblock->DCTType == DCT_FIELD) &&
            ((blockPattern & (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)) == (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)))) {

            if (pMacroblock->DCTType == DCT_FIELD) {
                if (blockPattern >= 0xFC) {
                    nvMoCompParams.blockWidth = 64;
                    nvMoCompParams.blockHeight = 16;
                    nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                    nvDoOptimizedIntraFieldCorrection();
                    
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;

                    nvDoOptimizedIntraFieldCorrection();

                    // IDCTIndex += 2;
                    
                    nvMoCompParams.correctionY += 8; // (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.blockY += 16;

                    nvDoOptimizedIntraFieldCorrection();
                    
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;

                    nvDoOptimizedIntraFieldCorrection();
                    
                } else {
                    nvMoCompParams.blockWidth = 32;
                    nvMoCompParams.blockHeight = 16;
                    nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                    nvDoAllIntraFieldCorrections(8, 4);
                    
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;

                    nvDoAllIntraFieldCorrections(8, 4);
                }
            } else {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockWidth = 64;
                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                
                nvDoOptimizedIntraFieldCorrection();
            }
            
            IDCTIndex += 4;

        } else {

            if (pMacroblock->DCTType == DCT_FRAME) {
                // Temporarily change texture0 pitch to 8 bytes so that each scanline in IDCT block will be used
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 8 << 16);

                nvPusherAdjust(2);

                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 32;
            } else {
                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 16;
            }
    
            if (blockPattern & CBP_Y0) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    nvDoOptimizedIntraFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high
                    nvDoOptimizedIntraFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;
                    nvDoOptimizedIntraFieldCorrection();
                }

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y1) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = (pMacroblock->hOffset + 8) << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    nvDoOptimizedIntraFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoOptimizedIntraFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY = 16;
                    nvDoOptimizedIntraFieldCorrection();
                }            

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y2) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = (pMacroblock->vOffset + 8) << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high
                    nvDoOptimizedIntraFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoOptimizedIntraFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;
                    nvDoOptimizedIntraFieldCorrection();
                }

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y3) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = (pMacroblock->hOffset + 8) << 2;
                nvMoCompParams.blockY = (pMacroblock->vOffset + 8) << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high
                    nvDoOptimizedIntraFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoOptimizedIntraFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;
                    nvDoOptimizedIntraFieldCorrection();
                }

                IDCTIndex++;
            }

            if (pMacroblock->DCTType == DCT_FRAME) {
                // Restore texture0 pitch to it's default value of 16 bytes
                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                               NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 16 << 16);

                nvPusherAdjust(2);
            }
        
        }
        
    #ifdef  DEBUG
        if (moCompDebugLevel < 3) {
    #endif  // DEBUG

        // Chroma IDCTs are always frame based

        if (blockPattern & (CBP_CB | CBP_CR)) {

            nvMoCompParams.correctionField = 0;
            nvMoCompParams.blockWidth = 64;
            nvMoCompParams.blockHeight = 32;
            nvMoCompParams.blockX = pMacroblock->hOffset << 2;
            nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);
            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high

            nvDoOptimizedIntraFieldCorrection();
        }

#ifdef  DEBUG
        }
#endif  // DEBUG
    }
} /* nvCorrectFieldMacroblock */


#endif  // NVARCH >= 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\MoCorr.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       MoCorr.cpp
 *  Content:    Windows98 DirectDraw 32 bit driver
 *
 ***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)


extern NVMOCOMPPARAMS nvMoCompParams;

extern PNVMCCORRFUNC2 nvDoAllIntraFieldCorrections;
extern PNVMCCORRFUNC2 nvDoAllFieldCorrections;
extern PNVMCCORRFUNC nvDoIntraFieldCorrection;
extern PNVMCCORRFUNC nvDoOptimizedIntraFieldCorrection;
extern PNVMCCORRFUNC nvDoFieldCorrection;

extern PNVMCCORRFUNC nvDoAllIntraFrameCorrections;
extern PNVMCCORRFUNC nvDoAllFrameCorrections;
extern PNVMCCORRFUNC nvDoIntraFrameCorrection;
extern PNVMCCORRFUNC nvDoFrameCorrection;

#ifdef  DEBUG
extern unsigned long moCompDebugLevel;
#endif  // DEBUG

/*
 * nvDoCelsiusIntraFrameCorrection
 *
 * Performs frame correction on a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoCelsiusIntraFrameCorrection(void)
{
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1;
    long                        texture1BlockY1;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0 = (nvMoCompParams.correctionY << 2); // Assumes textures with 8 byte pitch
    long                        texture0BlockX1;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;
    
    texture1BlockX1 = nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    // Change texture1 surface offset to point to block of half bias values (0x80)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

    // Change texture1 pitch to 16 bytes
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(3, 16 << 16); // half bias Intra block pitch

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(5, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x300000);

    nvPushMoCompQuadData(7);

    nvPushData(19, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(20, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(21);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoCelsiusIntraFrameCorrection */


/*
 * nvDoAllCelsiusIntraFrameCorrections
 *
 * Performs frame correction on all blocks in a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoAllCelsiusIntraFrameCorrections(void)
{
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1;
    long                        texture1BlockY1;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0 = (nvMoCompParams.correctionY << 2); // Assumes textures with 8 byte pitch
    long                        texture0BlockX1;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;
    long                        nextBlockYOffset = 32 << 16;
    
    texture1BlockX1 = nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    // Change texture1 surface offset to point to block of half bias values (0x80)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

    // Change texture1 pitch to 16 bytes
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(3, 16 << 16); // half bias Intra block pitch

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(5, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0xC00000);

    nvPushMoCompQuadData(7);

    texture0BlockY0 += nextBlockYOffset;
    texture0BlockY1 += nextBlockYOffset;
    blockX0 += 32;
    blockX1 += 32;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    
    nvPushMoCompQuadData(19);

    texture0BlockY0 += nextBlockYOffset;
    texture0BlockY1 += nextBlockYOffset;
    blockX0 -= 32;
    blockX1 -= 32;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY0 += nextBlockYOffset;
    blockY1 += nextBlockYOffset;

    nvPushMoCompQuadData(31);

    texture0BlockY0 += nextBlockYOffset;
    texture0BlockY1 += nextBlockYOffset;
    blockX0 += 32;
    blockX1 += 32;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;

    nvPushMoCompQuadData(43);

    nvPushData(55, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(56, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(57);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoAllCelsiusIntraFrameCorrections */



/*
 * nvDoCelsiusFrameCorrection
 *
 * Performs frame correction on a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoCelsiusFrameCorrection(void)
{
    // Texture1 and the destination surface are the same surface
    long texture1BlockX0;
    long texture1BlockY0;
    long texture1BlockX1;
    long texture1BlockY1;
    long texture0BlockX0 = 0;
    long texture0BlockY0 = nvMoCompParams.correctionY << 2; // Assumes textures with 8 byte pitch
    long texture0BlockX1;
    long texture0BlockY1;
    long blockX0;
    long blockX1;
    long blockY0;
    long blockY1;
    
    texture1BlockX0 = nvMoCompParams.blockX;
    texture1BlockY0 = nvMoCompParams.blockY;
    texture1BlockY0 <<= 16;
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x300000);

    nvPushMoCompQuadData(3);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoCelsiusFrameCorrection */


/*
 * nvDoAllCelsiusFrameCorrections
 *
 * Performs frame correction on all blocks in a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoAllCelsiusFrameCorrections(void)
{
    // Texture1 and the destination surface are the same surface
    long texture1BlockX0;
    long texture1BlockY0;
    long texture1BlockX1;
    long texture1BlockY1;
    long texture0BlockX0 = 0;
    long texture0BlockY0 = nvMoCompParams.correctionY << 2; // Assumes textures with 8 byte pitch
    long texture0BlockX1;
    long texture0BlockY1;
    long blockX0;
    long blockX1;
    long blockY0;
    long blockY1;
    long nextBlockYOffset = 32 << 16;
    
    texture1BlockX0 = nvMoCompParams.blockX;
    texture1BlockY0 = nvMoCompParams.blockY;
    texture1BlockY0 <<= 16;
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;
    
    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0xC00000);

    nvPushMoCompQuadData(3);

    texture1BlockX0 += 32;
    texture1BlockX1 += 32;
    texture0BlockY0 += nextBlockYOffset;
    texture0BlockY1 += nextBlockYOffset;
    blockX0 += 32;
    blockX1 += 32;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    
    nvPushMoCompQuadData(15);

    texture1BlockX0 -= 32;
    texture1BlockX1 -= 32;
    texture1BlockY0 += nextBlockYOffset;
    texture1BlockY1 += nextBlockYOffset;
    texture0BlockY0 += nextBlockYOffset;
    texture0BlockY1 += nextBlockYOffset;
    blockX0 -= 32;
    blockX1 -= 32;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY0 += nextBlockYOffset;
    blockY1 += nextBlockYOffset;

    nvPushMoCompQuadData(27);

    texture1BlockX0 += 32;
    texture1BlockX1 += 32;
    texture0BlockY0 += nextBlockYOffset;
    texture0BlockY1 += nextBlockYOffset;
    blockX0 += 32;
    blockX1 += 32;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;

    nvPushMoCompQuadData(39);

    nvPushData(51, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(52, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(53);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoAllCelsiusFrameCorrections */


/*
 * nvCorrectCelsiusIntraFrame                                             
 *
 * Processes LUMA blocks in an IntraFrame then makes a 2nd pass and processes chroma blocks
 *
 * Note: All destination geometry sent to correction functions is in quarter pel units.  This is to avoid
 *       the need to update the composite transform as we alternate between prediction and correction.
 *       All correction (IDCT) texture geometry is in quarter pel units.
 *
 *       Due to celcius class limitations, the maximum post-transformed texture y coordinate is 2047 which
 *       corresponds to a maximum (IDCTIndex - firstAlignedIDCTIndex) value of 255 assuming all blocks are 8 texels high (by 8 texels wide).
 *
 */
void __stdcall nvCorrectCelsiusIntraFrame(LPNVDECODEMACROBLOCK pFirstMacroblock, long macroblockCount)
{
    unsigned long               firstAlignedIndex = pDriverData->dwMCFirstAlignedIDCTIndex;
    LPNVDECODEMACROBLOCK        pMacroblock;
    unsigned long               IDCTIndex;
    long                        chromaVOffset;
    BYTE                        blockPattern;
    unsigned long               dstSurfacePitch;
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1 = 64;
    long                        texture1BlockY1 = 32 << 16;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0;
    long                        texture0BlockX1 = 64;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;
    int                         n;
    int                         i;
    
    dstSurfacePitch = (nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch;
            
    chromaVOffset = nvMoCompParams.surfaceLumaHeight << 2; // surfaceLumaHeight * 4 (for quarter pel coords)

    pMacroblock = pFirstMacroblock;
    n = macroblockCount;

    if (pMacroblock->codedBlockPattern == 0xFF) {
        // Change texture0 pitch to 16 bytes
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
        nvPushData(1, 16 << 16);
        nvPushData(2, 16 << 16); // half bias Intra block pitch

        nvPusherAdjust(3);
    }   
    
    i = 0;
    
    nvMoCompParams.destinationField = 0;

    while (--n >= 0) {
    
        IDCTIndex = pMacroblock->firstIDCTIndex;
        blockPattern = pMacroblock->codedBlockPattern;

        if (pMacroblock->DCTType != DCT_FIELD) {
            nvMoCompParams.correctionField = 0;
            nvMoCompParams.destinationField = 0;
            nvMoCompParams.blockX = pMacroblock->hOffset << 2;
            nvMoCompParams.blockY = pMacroblock->vOffset << 2;

            if (blockPattern >= 0xFC) {
                nvMoCompParams.blockWidth = 64;
                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                nvDoIntraFrameCorrection();
            } else {
                // Change texture0 pitch to 8 bytes
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
                nvPushData(1, 8 << 16);
                nvPushData(2, 8 << 16); // half bias Intra block pitch

                nvPusherAdjust(3);

                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 32;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high
                nvDoAllIntraFrameCorrections();

                // Change texture0 pitch to 16 bytes
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
                nvPushData(1, 16 << 16);
                nvPushData(2, 16 << 16); // half bias Intra block pitch

                nvPusherAdjust(3);
            }

        } else
            i++;

        pMacroblock++;
    }
    
    nvPusherStart(TRUE);

    if (i > 0) { // if there were any DCT_FIELD macroblocks

        pMacroblock = pFirstMacroblock;
        n = macroblockCount;

        // Must temporarily set destination surface pitch back to double it's normal frame pitch
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_SURFACE_PITCH | 0x40000);
        nvPushData(1, dstSurfacePitch << 1);

        nvPusherAdjust(2);
                
        while (--n >= 0) {
        
            IDCTIndex = pMacroblock->firstIDCTIndex;
            blockPattern = pMacroblock->codedBlockPattern;

            if (pMacroblock->DCTType == DCT_FIELD) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.destinationField = 0;
                if (blockPattern >= 0xFC) {
                    nvMoCompParams.blockWidth = 64;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                } else {    
                    nvMoCompParams.blockWidth = 32;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                }
                nvMoCompParams.blockHeight = 32;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 1;

                if (blockPattern >= 0xFC) {
                    nvDoIntraFieldCorrection();
                } else {
                    // Change texture0 pitch to 8 bytes
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                   NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
                    nvPushData(1, 8 << 16);
                    nvPushData(2, 8 << 16); // half bias Intra block pitch

                    nvPusherAdjust(3);

                    nvDoAllIntraFieldCorrections(8, 2);

                    // Change texture0 pitch to 16 bytes
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                   NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
                    nvPushData(1, 16 << 16);
                    nvPushData(2, 16 << 16); // half bias Intra block pitch

                    nvPusherAdjust(3);
                }
            }

            pMacroblock++;
        }

        nvPusherStart(TRUE);

        pMacroblock = pFirstMacroblock;
        n = macroblockCount;

        while (--n >= 0) {
        
            IDCTIndex = pMacroblock->firstIDCTIndex;
            blockPattern = pMacroblock->codedBlockPattern;

            if (pMacroblock->DCTType == DCT_FIELD) {
                nvMoCompParams.blockHeight = 32;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 1;

                if (blockPattern >= 0xFC) {
                    nvMoCompParams.blockWidth = 64;
                    nvMoCompParams.destinationField = 1;
                    nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoIntraFieldCorrection();
                } else {
                    // Change texture0 pitch to 8 bytes
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                   NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
                    nvPushData(1, 8 << 16);
                    nvPushData(2, 8 << 16); // half bias Intra block pitch

                    nvPusherAdjust(3);

                    nvMoCompParams.blockWidth = 32;
                    nvMoCompParams.destinationField = 1;
                    nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    nvDoAllIntraFieldCorrections(8, 2);

                    // Change texture0 pitch to 16 bytes
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                   NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
                    nvPushData(1, 16 << 16);
                    nvPushData(2, 16 << 16); // half bias Intra block pitch

                    nvPusherAdjust(3);
                }
            }

            pMacroblock++;
        }

        nvPusherStart(TRUE);

    }
    

#ifdef  DEBUG
    if (moCompDebugLevel < 3) {
#endif  // DEBUG

    if (pDriverData->bMCCurrentExecuteFunction == EXECUTE_NON_PREBIASED_MOTION_COMPENSATION) {
        SET_UNBIASED_CHROMA_CORRECTION_DATA_FORMAT();
    } else {
        SET_CHROMA_CORRECTION_DATA_FORMAT();
    }    
  
    // Chroma IDCTs are always frame based
    pMacroblock = pFirstMacroblock;
    n = macroblockCount;

    nvMoCompParams.destinationField = 0;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_PITCH | 0x40000);
    nvPushData(1, dstSurfacePitch);

    // Change texture1 surface offset to point to block of half bias values (0x80)
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(3, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

    // Temporarily change texture0 pitch to 16 bytes
    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
    nvPushData(5, 16 << 16);
    nvPushData(6, 16 << 16); // half bias Intra block pitch

    nvPusherAdjust(7);

    texture0BlockX1 = 32;
    texture1BlockX1 = 32;
 
    while (n >= 8) {

        n -= 8;
        
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_BEGIN_END | 0x40000);
        nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0x1800000);

        i = 3;
        
        while (i < 99) {        
            IDCTIndex = pMacroblock->firstIDCTIndex + 4;

            texture0BlockY0 = (IDCTIndex - firstAlignedIndex) << 4; // Assumes textures with 8 byte pitch
            texture0BlockY1 = texture0BlockY0 + 32;
            texture0BlockY1 <<= 16;
            texture0BlockY0 <<= 16;

            nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);

            blockX0 = (pMacroblock->hOffset << 1) - nvMoCompParams.celsiusDestinationViewportXOffset;
            blockY0 = nvMoCompParams.blockY;
            blockY0 <<= 16;
            blockX1 = blockX0 + 32;
            blockX1 &= 0x0000FFFF;
            blockX0 &= 0x0000FFFF;
            blockY1 = nvMoCompParams.blockY + 32;
            blockY1 <<= 16;

            nvPushMoCompQuadData(i);
            
            i += 12;

            pMacroblock++;
        }
        
        nvPushData(i, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_BEGIN_END | 0x40000);
        i++;
                       
        nvPushData(i, NV056_SET_BEGIN_END_OP_END);
        
        i++;

        nvPusherAdjust(i);

#ifdef  DEBUG
        if (moCompDebugLevel > 1)
            nvPusherStart(TRUE);
#endif  // DEBUG
    }

    while (--n >= 0) {
    
        IDCTIndex = pMacroblock->firstIDCTIndex + 4;

        texture0BlockY0 = (IDCTIndex - firstAlignedIndex) << 4; // Assumes textures with 8 byte pitch
        texture0BlockY1 = texture0BlockY0 + 32;
        texture0BlockY1 <<= 16;
        texture0BlockY0 <<= 16;

        nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);

        blockX0 = (pMacroblock->hOffset << 1) - nvMoCompParams.celsiusDestinationViewportXOffset;
        blockY0 = nvMoCompParams.blockY;
        blockY0 <<= 16;
        blockX1 = blockX0 + 32;
        blockX1 &= 0x0000FFFF;
        blockX0 &= 0x0000FFFF;
        blockY1 = nvMoCompParams.blockY + 32;
        blockY1 <<= 16;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_BEGIN_END | 0x40000);
        nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0x300000);

        nvPushMoCompQuadData(3);

        nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_BEGIN_END | 0x40000);
        nvPushData(16, NV056_SET_BEGIN_END_OP_END);

        nvPusherAdjust(17);

#ifdef  DEBUG
        if (moCompDebugLevel > 1)
            nvPusherStart(TRUE);
#endif  // DEBUG

        pMacroblock++;
    }

#ifdef  DEBUG
    }
#endif  // DEBUG

} /* nvCorrectCelsiusIntraFrame */


/*
 * nvCorrectCelsiusFullFrameLumaMacroblock
 *
 * Performs correction on all blocks in macroblock assuming Y0/Y1/Y2/Y3 are in NV optimized format
 *
 * Note: All destination geometry sent to correction functions is in quarter pel units.  This is to avoid
 *       the need to update the composite transform as we alternate between prediction and correction.
 *       All correction (IDCT) texture geometry is in quarter pel units.
 *
 *       Due to celcius class limitations, the maximum post-transformed texture y coordinate is 2047 which
 *       corresponds to a maximum (IDCTIndex - firstAlignedIDCTIndex) value of 255 assuming all blocks are 8 texels high (by 8 texels wide).
 *
 */
void __stdcall nvCorrectCelsiusFullFrameLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType)
{
    unsigned long IDCTIndex = pMacroblock->firstIDCTIndex;
    unsigned long firstAlignedIndex = pDriverData->dwMCFirstAlignedIDCTIndex;
    unsigned long dstSurfacePitch;
    
    if (pMacroblock->DCTType == DCT_FIELD) {

        dstSurfacePitch = (nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch;

        nvMoCompParams.correctionField = 0;
        nvMoCompParams.destinationField = 0;
        nvMoCompParams.blockWidth = 64;
        nvMoCompParams.blockHeight = 32;
        nvMoCompParams.blockX = pMacroblock->hOffset << 2;
        nvMoCompParams.blockY = pMacroblock->vOffset << 1;

        if (pMacroblock->macroblockType != MB_INTRA) {           

            // Temporarily change texture1 pitch to match destination surface pitch
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                           NV056_SET_TEXTURE_CONTROL1(1) | 0x40000);
            nvPushData(1, dstSurfacePitch << 17);

            nvPusherAdjust(2);

            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
            nvDoFieldCorrection();
            nvMoCompParams.destinationField = 1;
            nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
            nvDoFieldCorrection();
            
            // Restore texture1 pitch to it's default value
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                           NV056_SET_TEXTURE_CONTROL1(1) | 0x40000);
            nvPushData(1, nvMoCompParams.surfaceLumaPitch << 16);

            nvPusherAdjust(2);

        } else {
            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
            nvDoIntraFieldCorrection();
            nvMoCompParams.destinationField = 1;
            nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
            nvDoIntraFieldCorrection();
        }

    } else {
        nvMoCompParams.correctionField = 0;
        nvMoCompParams.destinationField = 0;
        nvMoCompParams.blockX = pMacroblock->hOffset << 2;
        nvMoCompParams.blockY = pMacroblock->vOffset << 2;

        nvMoCompParams.blockWidth = 64;
        nvMoCompParams.blockHeight = 64;
        nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
        nvPushData(1, nvMoCompParams.surfaceOffset);

        nvPusherAdjust(2);

        if (pMacroblock->macroblockType != MB_INTRA) {
            nvDoFrameCorrection();
        } else
            nvDoIntraFrameCorrection();

    }

} /* nvCorrectCelsiusFullFrameLumaMacroblock */


/*
 * nvCorrectCelsiusFullFrameChromaMacroblock
 *
 * Performs correction on all blocks in macroblock assuming Y0/Y1/Y2/Y3 are in NV optimized format
 *
 * Note: All destination geometry sent to correction functions is in quarter pel units.  This is to avoid
 *       the need to update the composite transform as we alternate between prediction and correction.
 *       All correction (IDCT) texture geometry is in quarter pel units.
 *
 *       Due to celcius class limitations, the maximum post-transformed texture y coordinate is 2047 which
 *       corresponds to a maximum (IDCTIndex - firstAlignedIDCTIndex) value of 255 assuming all blocks are 8 texels high (by 8 texels wide).
 *
 */
void __stdcall nvCorrectCelsiusFullFrameChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType)
{
    unsigned long IDCTIndex = pMacroblock->firstIDCTIndex;
    unsigned long firstAlignedIndex = pDriverData->dwMCFirstAlignedIDCTIndex;
    long chromaVOffset;
    
    chromaVOffset = nvMoCompParams.surfaceLumaHeight << 2; // surfaceLumaHeight * 4 (for quarter pel coords)

    IDCTIndex += 4;

#ifdef  DEBUG
    if (moCompDebugLevel < 3) {
#endif  // DEBUG

    // Chroma IDCTs are always frame based
    nvMoCompParams.correctionField = 0;
    nvMoCompParams.destinationField = 0;
    nvMoCompParams.blockWidth = 32;
    nvMoCompParams.blockHeight = 32;
    nvMoCompParams.blockX = pMacroblock->hOffset << 1;
    nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);
    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high

    if (pMacroblock->macroblockType != MB_INTRA)           
        nvDoFrameCorrection();
    else
        nvDoIntraFrameCorrection();

#ifdef  DEBUG
    }
#endif  // DEBUG

} /* nvCorrectCelsiusFullFrameChromaMacroblock */


/*
 * nvCorrectCelsiusFrameLumaMacroblock
 *
 * Determines which blocks in the block pattern need correction and calls the appropriate function
 *
 * Note: All destination geometry sent to correction functions is in quarter pel units.  This is to avoid
 *       the need to update the composite transform as we alternate between prediction and correction.
 *       All correction (IDCT) texture geometry is in quarter pel units.
 *
 *       Due to celcius class limitations, the maximum post-transformed texture y coordinate is 2047 which
 *       corresponds to a maximum (IDCTIndex - firstAlignedIDCTIndex) value of 255 assuming all blocks are 8 texels high (by 8 texels wide).
 *
 */
void __stdcall nvCorrectCelsiusFrameLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType)
{
    unsigned long IDCTIndex = pMacroblock->firstIDCTIndex;
    unsigned long firstAlignedIndex = pDriverData->dwMCFirstAlignedIDCTIndex;
    BYTE blockPattern;
    unsigned long dstSurfacePitch;
    
    if (correctionType == CORRECTION_FIRST_PASS) {

        blockPattern = pMacroblock->codedBlockPattern;

    } else {

        blockPattern = pMacroblock->codedBlockPattern;
        if (blockPattern & CBP_Y0)
            IDCTIndex++;
        if (blockPattern & CBP_Y1)
            IDCTIndex++;
        if (blockPattern & CBP_Y2)
            IDCTIndex++;
        if (blockPattern & CBP_Y3)
            IDCTIndex++;
        if (blockPattern & (CBP_CR | CBP_CB))
            IDCTIndex += 2;
        blockPattern = pMacroblock->overflowCodedBlockPattern;
    }

    if (pMacroblock->DCTType == DCT_FIELD) {
        // Must temporarily set destination surface pitch back to double it's normal frame pitch
        dstSurfacePitch = (nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch;

        if (pMacroblock->macroblockType != MB_INTRA) {           
            // Temporarily change texture1 pitch to match destination surface pitch
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                           NV056_SET_TEXTURE_CONTROL1(1) | 0x40000);
            nvPushData(1, dstSurfacePitch << 17);

            nvPusherAdjust(2);
        }
    }

    if ((blockPattern & (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)) == (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)) {

        if (pMacroblock->DCTType == DCT_FIELD) {
            nvMoCompParams.correctionField = 0;
            nvMoCompParams.destinationField = 0;
            nvMoCompParams.blockHeight = 32;
            nvMoCompParams.blockX = pMacroblock->hOffset << 2;
            nvMoCompParams.blockY = pMacroblock->vOffset << 1;

            if (pMacroblock->macroblockType != MB_INTRA) {           

                if (blockPattern >= 0xFC) {

                    // Temporarily change texture0 pitch to 16 bytes
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                   NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                    nvPushData(1, 16 << 16);

                    nvPusherAdjust(2);

                    nvMoCompParams.blockWidth = 64;

                    if ((nvMoCompParams.surfaceLumaPitch >= 1024) && (correctionType == CORRECTION_FIRST_PASS)) {
                        if (nvMoCompParams.destinationFieldIs0) {
                            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                            nvDoFieldCorrection();
                        } else {
                            nvMoCompParams.destinationField = 1;
                            nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                            nvDoFieldCorrection();
                        }
                    } else {
                        nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                        nvDoFieldCorrection();
                        nvMoCompParams.destinationField = 1;
                        nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                        nvDoFieldCorrection();
                    }

                    // Restore texture0 pitch to default value
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                   NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                    nvPushData(1, 8 << 16);

                    nvPusherAdjust(2);

                } else {

                    nvMoCompParams.blockWidth = 32;

                    if ((nvMoCompParams.surfaceLumaPitch >= 1024) && (correctionType == CORRECTION_FIRST_PASS)) {
                        if (nvMoCompParams.destinationFieldIs0) {
                            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                            nvDoAllFieldCorrections(8, 2);
                        } else {
                            nvMoCompParams.destinationField = 1;
                            nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                            nvDoAllFieldCorrections(8, 2);
                        }    
                    } else {
                        nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                        nvDoAllFieldCorrections(8, 2);
                        nvMoCompParams.destinationField = 1;
                        nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                        nvDoAllFieldCorrections(8, 2);
                    }
                }
                
            } else {
                if (blockPattern >= 0xFC) {
                    // Temporarily change texture0 pitch to 16 bytes
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                   NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                    nvPushData(1, 16 << 16);

                    nvPusherAdjust(2);

                    nvMoCompParams.blockWidth = 64;

                    if ((nvMoCompParams.surfaceLumaPitch >= 1024) && (correctionType == CORRECTION_FIRST_PASS)) {
                        if (nvMoCompParams.destinationFieldIs0) {
                            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                            nvDoIntraFieldCorrection();
                        } else {    
                            nvMoCompParams.destinationField = 1;
                            nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                            nvDoIntraFieldCorrection();
                        }    
                    } else {
                        nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                        nvDoIntraFieldCorrection();
                        nvMoCompParams.destinationField = 1;
                        nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                        nvDoIntraFieldCorrection();
                    }

                    // Restore texture0 pitch to default value
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                   NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                    nvPushData(1, 8 << 16);

                    nvPusherAdjust(2);
                } else {
                    nvMoCompParams.blockWidth = 32;

                    if ((nvMoCompParams.surfaceLumaPitch >= 1024) && (correctionType == CORRECTION_FIRST_PASS)) {
                        if (nvMoCompParams.destinationFieldIs0) {
                            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                            nvDoAllIntraFieldCorrections(8, 2);
                        } else {
                            nvMoCompParams.destinationField = 1;
                            nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                            nvDoAllIntraFieldCorrections(8, 2);
                        }
                    } else {
                        nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                        nvDoAllIntraFieldCorrections(8, 2);
                        nvMoCompParams.destinationField = 1;
                        nvMoCompParams.correctionY = (IDCTIndex + 2 - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                        nvDoAllIntraFieldCorrections(8, 2);
                    }    
                }
            }
            
            if (pMacroblock->macroblockType != MB_INTRA) {           
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(1) | 0x40000);
                nvPushData(1, nvMoCompParams.surfaceLumaPitch << 16);

                nvPusherAdjust(2);
            }
        } else {
            nvMoCompParams.correctionField = 0;
            nvMoCompParams.destinationField = 0;
            nvMoCompParams.blockX = pMacroblock->hOffset << 2;
            nvMoCompParams.blockY = pMacroblock->vOffset << 2;

            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                           NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(1, nvMoCompParams.surfaceOffset);

            nvPusherAdjust(2);

            if (blockPattern >= 0xFC) {
                nvMoCompParams.blockWidth = 64;
                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high

                // Temporarily change texture0 pitch to 16 bytes
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 16 << 16);

                nvPusherAdjust(2);

                if (pMacroblock->macroblockType != MB_INTRA) {          
                    nvDoFrameCorrection();
                } else
                    nvDoIntraFrameCorrection();

                // Restore texture0 pitch to default value
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 8 << 16);

                nvPusherAdjust(2);
            } else {
                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 32;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high

                if (pMacroblock->macroblockType != MB_INTRA) {          
                    nvDoAllFrameCorrections();
                } else
                    nvDoAllIntraFrameCorrections();
            }
        }

        IDCTIndex += 4;

    } else {

        nvMoCompParams.blockWidth = 32;
        nvMoCompParams.blockHeight = 32;

        if ((pMacroblock->DCTType == DCT_FIELD) && (nvMoCompParams.surfaceLumaPitch >= 1024) && (correctionType == CORRECTION_FIRST_PASS)) {

            if (blockPattern & CBP_Y0) {

                if (nvMoCompParams.destinationFieldIs0) {
                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.destinationField = 0; // Component Y0 is in destination field 0
                    nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                    nvMoCompParams.blockY = pMacroblock->vOffset << 1;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high

                    if (pMacroblock->macroblockType != MB_INTRA)           
                        nvDoFieldCorrection();
                    else
                        nvDoIntraFieldCorrection();
                }
                
                IDCTIndex++;
            }

            if (blockPattern & CBP_Y1) {

                if (nvMoCompParams.destinationFieldIs0) {
                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.destinationField = 0; // Component Y1 is in destination field 0
                    nvMoCompParams.blockX = (pMacroblock->hOffset + 8) << 2;
                    nvMoCompParams.blockY = pMacroblock->vOffset << 1;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    
                    if (pMacroblock->macroblockType != MB_INTRA)           
                        nvDoFieldCorrection();
                    else
                        nvDoIntraFieldCorrection();
                }
                
                IDCTIndex++;
            }

            if (blockPattern & CBP_Y2) {

                if (!nvMoCompParams.destinationFieldIs0) {
                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.destinationField = 1; // Component Y2 is in destination field 1
                    nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                    nvMoCompParams.blockY = pMacroblock->vOffset << 1;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high

                    if (pMacroblock->macroblockType != MB_INTRA)           
                        nvDoFieldCorrection();
                    else
                        nvDoIntraFieldCorrection();
                }
                
                IDCTIndex++;
            }

            if (blockPattern & CBP_Y3) {

                if (!nvMoCompParams.destinationFieldIs0) {
                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.destinationField = 1; // Component Y3 is in destination field 1
                    nvMoCompParams.blockX = (pMacroblock->hOffset + 8) << 2;
                    nvMoCompParams.blockY = pMacroblock->vOffset << 1;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high

                    if (pMacroblock->macroblockType != MB_INTRA)           
                        nvDoFieldCorrection();
                    else
                        nvDoIntraFieldCorrection();
                }
                
                IDCTIndex++;
            }

        } else {

            if (blockPattern & CBP_Y0) {

                nvMoCompParams.correctionField = 0;
                nvMoCompParams.destinationField = 0; // Component Y0 is in destination field 0
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                if (pMacroblock->DCTType == DCT_FIELD)
                    nvMoCompParams.blockY = pMacroblock->vOffset << 1;
                else
                    nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high

                if (pMacroblock->macroblockType != MB_INTRA)           
                    nvDoFieldCorrection();
                else
                    nvDoIntraFieldCorrection();

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y1) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.destinationField = 0; // Component Y1 is in destination field 0
                nvMoCompParams.blockX = (pMacroblock->hOffset + 8) << 2;
                if (pMacroblock->DCTType == DCT_FIELD)
                    nvMoCompParams.blockY = pMacroblock->vOffset << 1;
                else
                    nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                
                if (pMacroblock->macroblockType != MB_INTRA)           
                    nvDoFieldCorrection();
                else
                    nvDoIntraFieldCorrection();

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y2) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                if (pMacroblock->DCTType == DCT_FIELD) {
                    nvMoCompParams.destinationField = 1; // Component Y2 is in destination field 1
                    nvMoCompParams.blockY = pMacroblock->vOffset << 1;
                } else {
                    nvMoCompParams.destinationField = 0;
                    nvMoCompParams.blockY = (pMacroblock->vOffset + 8) << 2;
                }
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high

                if (pMacroblock->macroblockType != MB_INTRA)           
                    nvDoFieldCorrection();
                else
                    nvDoIntraFieldCorrection();

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y3) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = (pMacroblock->hOffset + 8) << 2;
                if (pMacroblock->DCTType == DCT_FIELD) {
                    nvMoCompParams.destinationField = 1; // Component Y3 is in destination field 1
                    nvMoCompParams.blockY = pMacroblock->vOffset << 1;
                } else {
                    nvMoCompParams.destinationField = 0;
                    nvMoCompParams.blockY = (pMacroblock->vOffset + 8) << 2;
                }
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high

                if (pMacroblock->macroblockType != MB_INTRA)           
                    nvDoFieldCorrection();
                else
                    nvDoIntraFieldCorrection();

                IDCTIndex++;
            }
        }

        if (pMacroblock->DCTType == DCT_FIELD) {
            // Must temporarily set destination surface pitch back to double it's normal frame pitch
            dstSurfacePitch = (nvMoCompParams.surfaceLumaPitch << 16) | nvMoCompParams.surfaceLumaPitch;

            if (pMacroblock->macroblockType != MB_INTRA) {           
                // Temporarily change texture1 pitch to match destination surface pitch
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(1) | 0x40000);
                nvPushData(1, nvMoCompParams.surfaceLumaPitch << 16);

                nvPusherAdjust(2);
            }
        }
    }

} /* nvCorrectCelsiusFrameLumaMacroblock */


/*
 * nvCorrectCelsiusFrameChromaMacroblock
 *
 * Determines which blocks in the block pattern need correction and calls the appropriate function
 *
 * Note: All destination geometry sent to correction functions is in quarter pel units.  This is to avoid
 *       the need to update the composite transform as we alternate between prediction and correction.
 *       All correction (IDCT) texture geometry is in quarter pel units.
 *
 *       Due to celcius class limitations, the maximum post-transformed texture y coordinate is 2047 which
 *       corresponds to a maximum (IDCTIndex - firstAlignedIDCTIndex) value of 255 assuming all blocks are 8 texels high (by 8 texels wide).
 *
 */
void __stdcall nvCorrectCelsiusFrameChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType)
{
    unsigned long IDCTIndex = pMacroblock->firstIDCTIndex;
    unsigned long firstAlignedIndex = pDriverData->dwMCFirstAlignedIDCTIndex;
    long chromaVOffset;
    BYTE blockPattern;
    
    chromaVOffset = nvMoCompParams.surfaceLumaHeight << 2; // surfaceLumaHeight * 4 (for quarter pel coords)

    if (correctionType == CORRECTION_FIRST_PASS) {

        blockPattern = pMacroblock->codedBlockPattern;

    } else {

        blockPattern = pMacroblock->codedBlockPattern;
        if (blockPattern & CBP_Y0)
            IDCTIndex++;
        if (blockPattern & CBP_Y1)
            IDCTIndex++;
        if (blockPattern & CBP_Y2)
            IDCTIndex++;
        if (blockPattern & CBP_Y3)
            IDCTIndex++;
        if (blockPattern & (CBP_CR | CBP_CB))
            IDCTIndex += 2;
        blockPattern = pMacroblock->overflowCodedBlockPattern;
    }

    if ((blockPattern & (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)) == (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)) {

        IDCTIndex += 4;

    } else {

        if (blockPattern & CBP_Y0)
            IDCTIndex++;

        if (blockPattern & CBP_Y1)
            IDCTIndex++;

        if (blockPattern & CBP_Y2)
            IDCTIndex++;

        if (blockPattern & CBP_Y3)
            IDCTIndex++;
    }

#ifdef  DEBUG
    if (moCompDebugLevel < 3) {
#endif  // DEBUG

    // Chroma IDCTs are always frame based

    if (blockPattern & (CBP_CB | CBP_CR)) {

        nvMoCompParams.correctionField = 0;
        nvMoCompParams.destinationField = 0;
        nvMoCompParams.blockWidth = 32;
        nvMoCompParams.blockHeight = 32;
        nvMoCompParams.blockX = pMacroblock->hOffset << 1;
        nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);
        nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high

        if (pMacroblock->macroblockType != MB_INTRA)           
            nvDoFrameCorrection();
        else
            nvDoIntraFrameCorrection();
    }

#ifdef  DEBUG
    }
#endif  // DEBUG

} /* nvCorrectCelsiusFrameChromaMacroblock */


/*
 * nvDoAllCelsiusIntraDVDFieldCorrections
 *
 * Performs field correction on all blocks within a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoAllCelsiusIntraDVDFieldCorrections(long correctionYIncr, long numBlocks)
{
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1;
    long                        texture1BlockY1;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0 = (nvMoCompParams.correctionY << 2); // Assumes textures with 8 byte pitch
    long                        texture0BlockX1;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;
    long                        yIncr = correctionYIncr << 18;
    long                        nextBlockYOffset = 32 << 16;
    
    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture1BlockX1 = nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (nvMoCompParams.destinationField != 0) 
        blockX0 += nvMoCompParams.celsiusFieldXOffset;
    
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;
    
    // Change texture1 surface offset to point to block of half bias values (0x80)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

    // Change texture1 pitch to 16 bytes
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(3, 16 << 16); // half bias Intra block pitch

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(5, NV056_SET_BEGIN_END_OP_QUADS);

    if (numBlocks == 2)
        nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0x600000);
    else
        nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0xC00000);
    
    nvPushMoCompQuadData(7);

    texture0BlockY0 += yIncr;
    texture0BlockY1 += yIncr;
    blockX0 += 32;
    blockX1 += 32;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    
    nvPushMoCompQuadData(19);

    nvPusherAdjust(31);

    if (numBlocks == 4) {

        texture0BlockY0 += yIncr;
        texture0BlockY1 += yIncr;
        blockX0 -= 32;
        blockX1 -= 32;
        blockX1 &= 0x0000FFFF;
        blockX0 &= 0x0000FFFF;
        blockY0 += nextBlockYOffset;
        blockY1 += nextBlockYOffset;

        nvPushMoCompQuadData(0);

        texture0BlockY0 += yIncr;
        texture0BlockY1 += yIncr;
        blockX0 += 32;
        blockX1 += 32;
        blockX1 &= 0x0000FFFF;
        blockX0 &= 0x0000FFFF;

        nvPushMoCompQuadData(12);

        nvPusherAdjust(24);
    }

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(2);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoAllCelsiusIntraDVDFieldCorrections */



/*
 * nvDoAllCelsiusDVDFieldCorrections
 *
 * Performs field correction on all blocks within a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoAllCelsiusDVDFieldCorrections(long correctionYIncr, long numBlocks)
{
    // Texture1 and the destination surface are the same surface
    long texture1BlockX0;
    long texture1BlockY0;
    long texture1BlockX1;
    long texture1BlockY1;
    long texture0BlockX0 = 0;
    long texture0BlockY0 = nvMoCompParams.correctionY << 2; // Assumes textures with 8 byte pitch
    long texture0BlockX1;
    long texture0BlockY1;
    long blockX0;
    long blockX1;
    long blockY0;
    long blockY1;
    long yIncr = correctionYIncr << 18;
    long nextBlockYOffset = 32 << 16;
    
    texture1BlockX0 = nvMoCompParams.blockX;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (nvMoCompParams.destinationField != 0) {
        texture1BlockX0 += nvMoCompParams.celsiusFieldXOffset;
        blockX0 += nvMoCompParams.celsiusFieldXOffset;
    }
    
    texture1BlockY0 = nvMoCompParams.blockY;
    texture1BlockY0 <<= 16;
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;
    
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;
    
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    if (numBlocks == 2)
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0x600000);
    else
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0xC00000);

    nvPushMoCompQuadData(3);

    texture1BlockX0 += 32;
    texture1BlockX1 += 32;
    texture0BlockY0 += yIncr;
    texture0BlockY1 += yIncr;
    blockX0 += 32;
    blockX1 += 32;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    
    nvPushMoCompQuadData(15);

    nvPusherAdjust(27);

    if (numBlocks == 4) {

        texture1BlockX0 -= 32;
        texture1BlockX1 -= 32;
        texture1BlockY0 += nextBlockYOffset;
        texture1BlockY1 += nextBlockYOffset;
        texture0BlockY0 += yIncr;
        texture0BlockY1 += yIncr;
        blockX0 -= 32;
        blockX1 -= 32;
        blockX1 &= 0x0000FFFF;
        blockX0 &= 0x0000FFFF;
        blockY0 += nextBlockYOffset;
        blockY1 += nextBlockYOffset;

        nvPushMoCompQuadData(0);

        texture1BlockX0 += 32;
        texture1BlockX1 += 32;
        texture0BlockY0 += yIncr;
        texture0BlockY1 += yIncr;
        blockX0 += 32;
        blockX1 += 32;
        blockX1 &= 0x0000FFFF;
        blockX0 &= 0x0000FFFF;

        nvPushMoCompQuadData(12);

        nvPusherAdjust(24);
    }
    
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(2);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoAllCelsiusDVDFieldCorrections */


/*
 * nvDoCelsiusIntraDVDFieldCorrection
 *
 * Performs field correction on a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoCelsiusIntraDVDFieldCorrection()
{
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1;
    long                        texture1BlockY1;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0 = (nvMoCompParams.correctionY << 2); // Assumes textures with 8 byte pitch
    long                        texture0BlockX1;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;

    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture1BlockX1 = nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (nvMoCompParams.destinationField != 0)
        blockX0 += nvMoCompParams.celsiusFieldXOffset;
    
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    // Change texture1 surface offset to point to block of half bias values (0x80)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

    // Change texture1 pitch to 16 bytes
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(3, 16 << 16); // half bias Intra block pitch

    nvPusherAdjust(4);
    
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x300000);

    nvPushMoCompQuadData(3);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoCelsiusIntraDVDFieldCorrection */


/*
 * nvDoOptimizedCelsiusIntraDVDFieldCorrection
 *
 * Performs field correction on a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoOptimizedCelsiusIntraDVDFieldCorrection()
{
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1;
    long                        texture1BlockY1;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0 = (nvMoCompParams.correctionY << 2); // Assumes textures with 8 byte pitch
    long                        texture0BlockX1;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;

    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture1BlockX1 = nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (nvMoCompParams.destinationField != 0)
        blockX0 += nvMoCompParams.celsiusFieldXOffset;
    
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x300000);

    nvPushMoCompQuadData(3);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoOptimizedCelsiusIntraDVDFieldCorrection */


/*
 * nvDoCelsiusDVDFieldCorrection
 *
 * Performs field correction on a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoCelsiusDVDFieldCorrection(void)
{
    // Texture1 and the destination surface are the same surface
    long texture1BlockX0;
    long texture1BlockY0;
    long texture1BlockX1;
    long texture1BlockY1;
    long texture0BlockX0 = 0;
    long texture0BlockY0 = nvMoCompParams.correctionY << 2; // Assumes textures with 8 byte pitch
    long texture0BlockX1;
    long texture0BlockY1;
    long blockX0;
    long blockX1;
    long blockY0;
    long blockY1;
    
    texture1BlockX0 = nvMoCompParams.blockX;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (nvMoCompParams.destinationField != 0) {
        texture1BlockX0 += nvMoCompParams.celsiusFieldXOffset;
        blockX0 += nvMoCompParams.celsiusFieldXOffset;
    }
    
    texture1BlockY0 = nvMoCompParams.blockY;
    texture1BlockY0 <<= 16;
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x300000);

    nvPushMoCompQuadData(3);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoCelsiusDVDFieldCorrection */



/*
 * nvDoAllCelsiusIntraHDFieldCorrections
 *
 * Performs field correction on all blocks within a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoAllCelsiusIntraHDFieldCorrections(long correctionYIncr, long numBlocks)
{
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1;
    long                        texture1BlockY1;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0 = (nvMoCompParams.correctionY << 2); // Assumes textures with 8 byte pitch
    long                        texture0BlockX1;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;
    long                        yIncr = correctionYIncr << 18;
    long                        nextBlockYOffset = 32 << 16;
    
    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture1BlockX1 = nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (nvMoCompParams.destinationField != 0)
        blockX0 += nvMoCompParams.celsiusFieldXOffset;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;
    
    // Change texture1 surface offset to point to block of half bias values (0x80)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

    // Change texture1 pitch to 16 bytes
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(3, 16 << 16); // half bias Intra block pitch

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(5, NV056_SET_BEGIN_END_OP_QUADS);

    if (numBlocks == 2)
        nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0x600000);
    else
        nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0xC00000);
    
    nvPushMoCompQuadData(7);

    texture0BlockY0 += yIncr;
    texture0BlockY1 += yIncr;
    blockX0 += 32;
    blockX1 += 32;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    
    nvPushMoCompQuadData(19);

    nvPusherAdjust(31);

    if (numBlocks == 4) {

        texture0BlockY0 += yIncr;
        texture0BlockY1 += yIncr;
        blockX0 -= 32;
        blockX1 -= 32;
        blockX1 &= 0x0000FFFF;
        blockX0 &= 0x0000FFFF;
        blockY0 += nextBlockYOffset;
        blockY1 += nextBlockYOffset;

        nvPushMoCompQuadData(0);

        texture0BlockY0 += yIncr;
        texture0BlockY1 += yIncr;
        blockX0 += 32;
        blockX1 += 32;
        blockX1 &= 0x0000FFFF;
        blockX0 &= 0x0000FFFF;

        nvPushMoCompQuadData(12);

        nvPusherAdjust(24);
    }

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(2);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoAllCelsiusIntraHDFieldCorrections */



/*
 * nvDoAllCelsiusHDFieldCorrections
 *
 * Performs field correction on all blocks within a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoAllCelsiusHDFieldCorrections(long correctionYIncr, long numBlocks)
{
    // Texture1 and the destination surface are the same surface
    long texture1BlockX0;
    long texture1BlockY0;
    long texture1BlockX1;
    long texture1BlockY1;
    long texture0BlockX0 = 0;
    long texture0BlockY0 = nvMoCompParams.correctionY << 2; // Assumes textures with 8 byte pitch
    long texture0BlockX1;
    long texture0BlockY1;
    long blockX0;
    long blockX1;
    long blockY0;
    long blockY1;
    long yIncr = correctionYIncr << 18;
    long nextBlockYOffset = 32 << 16;
    
    texture1BlockX0 = nvMoCompParams.blockX;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (nvMoCompParams.destinationField != 0)
        blockX0 += nvMoCompParams.celsiusFieldXOffset;

    if (nvMoCompParams.destinationField != nvMoCompParams.currentDestinationField) {

        if (nvMoCompParams.destinationField != 0) {
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceLumaPitch);
        } else {
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(1, nvMoCompParams.surfaceOffset);
        }
        nvPusherAdjust(2);

        nvMoCompParams.currentDestinationField = nvMoCompParams.destinationField;
    }

    
    texture1BlockY0 = nvMoCompParams.blockY;
    texture1BlockY0 <<= 16;
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;
    
    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;
    
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    if (numBlocks == 2)
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0x600000);
    else
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0xC00000);

    nvPushMoCompQuadData(3);

    texture1BlockX0 += 32;
    texture1BlockX1 += 32;
    texture0BlockY0 += yIncr;
    texture0BlockY1 += yIncr;
    blockX0 += 32;
    blockX1 += 32;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    
    nvPushMoCompQuadData(15);

    nvPusherAdjust(27);

    if (numBlocks == 4) {

        texture1BlockX0 -= 32;
        texture1BlockX1 -= 32;
        texture1BlockY0 += nextBlockYOffset;
        texture1BlockY1 += nextBlockYOffset;
        texture0BlockY0 += yIncr;
        texture0BlockY1 += yIncr;
        blockX0 -= 32;
        blockX1 -= 32;
        blockX1 &= 0x0000FFFF;
        blockX0 &= 0x0000FFFF;
        blockY0 += nextBlockYOffset;
        blockY1 += nextBlockYOffset;

        nvPushMoCompQuadData(0);

        texture1BlockX0 += 32;
        texture1BlockX1 += 32;
        texture0BlockY0 += yIncr;
        texture0BlockY1 += yIncr;
        blockX0 += 32;
        blockX1 += 32;
        blockX1 &= 0x0000FFFF;
        blockX0 &= 0x0000FFFF;

        nvPushMoCompQuadData(12);

        nvPusherAdjust(24);
    }
    
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(2);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoAllCelsiusHDFieldCorrections */


/*
 * nvDoCelsiusIntraHDFieldCorrection
 *
 * Performs field correction on a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoCelsiusIntraHDFieldCorrection()
{
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1;
    long                        texture1BlockY1;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0 = (nvMoCompParams.correctionY << 2); // Assumes textures with 8 byte pitch
    long                        texture0BlockX1;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;

    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture1BlockX1 = nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (nvMoCompParams.destinationField != 0)
        blockX0 += nvMoCompParams.celsiusFieldXOffset;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    // Change texture1 surface offset to point to block of half bias values (0x80)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

    // Change texture1 pitch to 16 bytes
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(3, 16 << 16); // half bias Intra block pitch

    nvPusherAdjust(4);
    
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x300000);

    nvPushMoCompQuadData(3);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoCelsiusIntraHDFieldCorrection */


/*
 * nvDoOptimizedCelsiusIntraHDFieldCorrection
 *
 * Performs field correction on a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoOptimizedCelsiusIntraHDFieldCorrection()
{
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1;
    long                        texture1BlockY1;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0 = (nvMoCompParams.correctionY << 2); // Assumes textures with 8 byte pitch
    long                        texture0BlockX1;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;

    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture1BlockX1 = nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (nvMoCompParams.destinationField != 0)
        blockX0 += nvMoCompParams.celsiusFieldXOffset;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x300000);

    nvPushMoCompQuadData(3);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoOptimizedCelsiusIntraHDFieldCorrection */


/*
 * nvDoCelsiusHDFieldCorrection
 *
 * Performs field correction on a macroblock
 *
 * Note: All destination geometry coordinates are in quarter pel units.
 *       All texture coordinates are in quarter pel units.
 *
 */
void __stdcall nvDoCelsiusHDFieldCorrection(void)
{
    // Texture1 and the destination surface are the same surface
    long texture1BlockX0;
    long texture1BlockY0;
    long texture1BlockX1;
    long texture1BlockY1;
    long texture0BlockX0 = 0;
    long texture0BlockY0 = nvMoCompParams.correctionY << 2; // Assumes textures with 8 byte pitch
    long texture0BlockX1;
    long texture0BlockY1;
    long blockX0;
    long blockX1;
    long blockY0;
    long blockY1;
    
    texture1BlockX0 = nvMoCompParams.blockX;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (nvMoCompParams.destinationField != 0)
        blockX0 += nvMoCompParams.celsiusFieldXOffset;

    if (nvMoCompParams.destinationField != nvMoCompParams.currentDestinationField) {

        if (nvMoCompParams.destinationField != 0) {
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceLumaPitch);
        } else {
            nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                          NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
            nvPushData(1, nvMoCompParams.surfaceOffset);
        }
        nvPusherAdjust(2);

        nvMoCompParams.currentDestinationField = nvMoCompParams.destinationField;
    }
    
    texture1BlockY0 = nvMoCompParams.blockY;
    texture1BlockY0 <<= 16;
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;

    if (nvMoCompParams.correctionField != 0)
        texture0BlockX0 = nvMoCompParams.blockWidth; // Start on 2nd scanline of block

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x300000);

    nvPushMoCompQuadData(3);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(16, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(17);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoCelsiusHDFieldCorrection */



/*
 * nvCorrectCelsiusIntraField
 *
 * Processes LUMA blocks in an IntraField then makes a 2nd pass and processes chroma blocks
 *
 * Note: All destination geometry sent to correction functions is in quarter pel units.  This is to avoid
 *       the need to update the composite transform as we alternate between prediction and correction.
 *       All correction (IDCT) texture geometry is in quarter pel units.
 *
 *       Due to celcius class limitations, the maximum post-transformed texture y coordinate is 2047 which
 *       corresponds to a maximum (IDCTIndex - firstAlignedIDCTIndex) value of 255 assuming all blocks are 8 texels high (by 8 texels wide).
 *
 */
void __stdcall nvCorrectCelsiusIntraField(LPNVDECODEMACROBLOCK pFirstMacroblock, long macroblockCount)
{
    unsigned long               firstAlignedIndex = pDriverData->dwMCFirstAlignedIDCTIndex;
    LPNVDECODEMACROBLOCK        pMacroblock;
    unsigned long               IDCTIndex;
    unsigned long               dwSurfaceOffset;
    long                        chromaVOffset;
    BYTE                        blockPattern;
    // Texture1 points to a field full of 0x80s
    long                        texture1BlockX0 = 0;
    long                        texture1BlockY0 = 0;
    long                        texture1BlockX1 = 64;
    long                        texture1BlockY1 = 32 << 16;
    long                        texture0BlockX0 = 0;
    long                        texture0BlockY0;
    long                        texture0BlockX1 = 64;
    long                        texture0BlockY1;
    long                        blockX0;
    long                        blockX1;
    long                        blockY0;
    long                        blockY1;
    int                         n;
    int                         i;
    
    chromaVOffset = nvMoCompParams.surfaceLumaHeight << 1;

    // Change texture1 surface offset to point to block of half bias values (0x80)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

    // Change texture1 pitch to 16 bytes
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(3, 16 << 16); // half bias Intra block pitch

    nvPusherAdjust(4);
    
    if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD)
        nvMoCompParams.destinationField = 0;
    else    
        nvMoCompParams.destinationField = 1;

    pMacroblock = pFirstMacroblock;
    n = macroblockCount;

    while (--n >= 0) {
    
        IDCTIndex = pMacroblock->firstIDCTIndex;
        blockPattern = pMacroblock->codedBlockPattern;

        if (pMacroblock->DCTType == DCT_FIELD) {
            if (blockPattern >= 0xFC) {
                nvMoCompParams.blockWidth = 64;
                nvMoCompParams.blockHeight = 16;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;

                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                nvDoOptimizedIntraFieldCorrection();
                
                nvMoCompParams.correctionField = 1;
                nvMoCompParams.blockY += 16;

                nvDoOptimizedIntraFieldCorrection();

                // IDCTIndex += 2;
                
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockY += 16;
                nvMoCompParams.correctionY += 8; // (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                nvDoOptimizedIntraFieldCorrection();
                
                nvMoCompParams.correctionField = 1;
                nvMoCompParams.blockY += 16;

                nvDoOptimizedIntraFieldCorrection();
                
            } else {
                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 16;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                nvDoAllIntraFieldCorrections(8, 4);
                
                nvMoCompParams.correctionField = 1;
                nvMoCompParams.blockY += 16;

                nvDoAllIntraFieldCorrections(8, 4);
            }
        } else {
            if (blockPattern >= 0xFC) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockWidth = 64;
                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                
                nvDoOptimizedIntraFieldCorrection();
            } else {
                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 32;

                // Temporarily change texture0 pitch to 8 bytes so that each scanline in IDCT block will be used
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 8 << 16);

                nvPusherAdjust(2);
                
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high

                nvDoOptimizedIntraFieldCorrection();

                // IDCTIndex++;

                nvMoCompParams.blockX += 32;
                nvMoCompParams.correctionY += 8; // (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high

                nvDoOptimizedIntraFieldCorrection();

                IDCTIndex++;

                nvMoCompParams.blockX -= 32;
                nvMoCompParams.blockY += 32;
                nvMoCompParams.correctionY += 8; // (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high

                nvDoOptimizedIntraFieldCorrection();

                IDCTIndex++;

                nvMoCompParams.blockX += 32;
                nvMoCompParams.correctionY += 8; // (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high

                nvDoOptimizedIntraFieldCorrection();

                // Restore texture0 pitch to it's default value of 16 bytes
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 16 << 16);

                nvPusherAdjust(2);
            }    
        }
        
        pMacroblock++;
    }
    
    nvPusherStart(TRUE);

    // Chroma IDCTs are always frame based

    dwSurfaceOffset = 0; // Assume destination field 0
    
    if (nvMoCompParams.destinationField != 0)
        dwSurfaceOffset += nvMoCompParams.surfaceLumaPitch << 2; // Geometry is referenced in quarter pel coords

    pMacroblock = pFirstMacroblock;
    n = macroblockCount;

    while (n >= 8) {

        n -= 8;
        
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_BEGIN_END | 0x40000);
        nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0x1800000);
        
        i = 3;
        
        while (i < 99) {        
            IDCTIndex = pMacroblock->firstIDCTIndex + 4;

            texture0BlockY0 = (IDCTIndex - firstAlignedIndex) << 4; // Assumes textures with 8 byte pitch
            texture0BlockY1 = texture0BlockY0 + 32;
            texture0BlockY1 <<= 16;
            texture0BlockY0 <<= 16;

            nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);

            blockX0 = dwSurfaceOffset + (pMacroblock->hOffset << 2) - nvMoCompParams.celsiusDestinationViewportXOffset;
            blockY0 = nvMoCompParams.blockY;
            blockY0 <<= 16;
            blockX1 = blockX0 + 64;
            blockX1 &= 0x0000FFFF;
            blockX0 &= 0x0000FFFF;
            blockY1 = nvMoCompParams.blockY + 32;
            blockY1 <<= 16;

            nvPushMoCompQuadData(i);
            
            i += 12;

            pMacroblock++;
        }
        
        nvPushData(i, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_BEGIN_END | 0x40000);
        i++;

        nvPushData(i, NV056_SET_BEGIN_END_OP_END);

        i++;
    
        nvPusherAdjust(i);
    }

    while (--n >= 0) {
    
        IDCTIndex = pMacroblock->firstIDCTIndex + 4;

        texture0BlockY0 = (IDCTIndex - firstAlignedIndex) << 4; // Assumes textures with 8 byte pitch
        texture0BlockY1 = texture0BlockY0 + 32;
        texture0BlockY1 <<= 16;
        texture0BlockY0 <<= 16;

        nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);

        blockX0 = dwSurfaceOffset + (pMacroblock->hOffset << 2) - nvMoCompParams.celsiusDestinationViewportXOffset;
        blockY0 = nvMoCompParams.blockY;
        blockY0 <<= 16;
        blockX1 = blockX0 + 64;
        blockX1 &= 0x0000FFFF;
        blockX0 &= 0x0000FFFF;
        blockY1 = nvMoCompParams.blockY + 32;
        blockY1 <<= 16;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_BEGIN_END | 0x40000);
        nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_INLINE_ARRAY(0) | 0x300000);

        nvPushMoCompQuadData(3);

        nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                       NV056_SET_BEGIN_END | 0x40000);
        nvPushData(16, NV056_SET_BEGIN_END_OP_END);

        nvPusherAdjust(17);

        pMacroblock++;
    }

} /* nvCorrectCelsiusIntraField */


/*
 * nvCorrectCelsiusFieldMacroblock
 *
 * Determines which blocks in the block pattern need correction and calls the appropriate function
 *
 * Note: All destination geometry sent to correction functions is in quarter pel units.  This is to avoid
 *       the need to update the composite transform as we alternate between prediction and correction.
 *       All correction (IDCT) texture geometry is in quarter pel units.
 *
 *       Due to celcius class limitations, the maximum post-transformed texture y coordinate is 2047 which
 *       corresponds to a maximum (IDCTIndex - firstAlignedIDCTIndex) value of 511 assuming all blocks are 4 texels high (by 16 texels wide with 8 texels per field).
 *
 */
void __stdcall nvCorrectCelsiusFieldMacroblock(LPNVDECODEMACROBLOCK pMacroblock, DWORD correctionType)
{
    unsigned long               IDCTIndex = pMacroblock->firstIDCTIndex;
    unsigned long               firstAlignedIndex = pDriverData->dwMCFirstAlignedIDCTIndex;
    long                        chromaVOffset;
    BYTE                        blockPattern;
    
    chromaVOffset = nvMoCompParams.surfaceLumaHeight << 1;

    if (correctionType == CORRECTION_FIRST_PASS) {

        blockPattern = pMacroblock->codedBlockPattern;

    } else {

        blockPattern = pMacroblock->codedBlockPattern;
        if (blockPattern & CBP_Y0)
            IDCTIndex++;
        if (blockPattern & CBP_Y1)
            IDCTIndex++;
        if (blockPattern & CBP_Y2)
            IDCTIndex++;
        if (blockPattern & CBP_Y3)
            IDCTIndex++;
        if (blockPattern & (CBP_CR | CBP_CB))
            IDCTIndex += 2;
        blockPattern = pMacroblock->overflowCodedBlockPattern;
    }

    if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD)
        nvMoCompParams.destinationField = 0;
    else    
        nvMoCompParams.destinationField = 1;

    if (pMacroblock->macroblockType != MB_INTRA) {          
        if  ((blockPattern >= 0xFC) || 
            ((pMacroblock->DCTType == DCT_FIELD) &&
            ((blockPattern & (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)) == (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)))) {

            if (pMacroblock->DCTType == DCT_FIELD) {
                if (blockPattern >= 0xFC) {
                    nvMoCompParams.blockWidth = 64;
                    nvMoCompParams.blockHeight = 16;
                    nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                    nvDoFieldCorrection();
                    
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;

                    nvDoFieldCorrection();

                    // IDCTIndex += 2;
                    
                    nvMoCompParams.correctionY += 8; // (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.blockY += 16;

                    nvDoFieldCorrection();

                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;

                    nvDoFieldCorrection();
                    
                } else {
                    nvMoCompParams.blockWidth = 32;
                    nvMoCompParams.blockHeight = 16;
                    nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                    nvDoAllFieldCorrections(8, 4);
                    
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;

                    nvDoAllFieldCorrections(8, 4);
                }
            } else {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockWidth = 64;
                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                
                nvDoFieldCorrection();
            }
            
            IDCTIndex += 4;

        } else {

            if (pMacroblock->DCTType == DCT_FRAME) {
                // Temporarily change texture0 pitch to 8 bytes so that each scanline in IDCT block will be used
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 8 << 16);

                nvPusherAdjust(2);

                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 32;
            } else {
                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 16;
            }

            if (blockPattern & CBP_Y0) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    nvDoFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high
                    nvDoFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;
                    nvDoFieldCorrection();
                }

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y1) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = (pMacroblock->hOffset + 8) << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    nvDoFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY = 16;
                    nvDoFieldCorrection();
                }            

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y2) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = (pMacroblock->vOffset + 8) << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high
                    nvDoFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;
                    nvDoFieldCorrection();
                }

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y3) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = (pMacroblock->hOffset + 8) << 2;
                nvMoCompParams.blockY = (pMacroblock->vOffset + 8) << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high
                    nvDoFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;
                    nvDoFieldCorrection();
                }

                IDCTIndex++;
            }

            if (pMacroblock->DCTType == DCT_FRAME) {
                // Restore texture0 pitch to it's default value of 16 bytes
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 16 << 16);

                nvPusherAdjust(2);
            }
        }
        
#ifdef  DEBUG
        if (moCompDebugLevel < 3) {
#endif  // DEBUG

        // Chroma IDCTs are always frame based

        if (blockPattern & (CBP_CB | CBP_CR)) {

            nvMoCompParams.correctionField = 0;
            nvMoCompParams.blockWidth = 64;
            nvMoCompParams.blockHeight = 32;
            nvMoCompParams.blockX = pMacroblock->hOffset << 2;
            nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);
            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high

            nvDoFieldCorrection();
        }

#ifdef  DEBUG
        }
#endif  // DEBUG

    } else { // MB_INTRA

        // Change texture1 surface offset to point to block of half bias values (0x80)
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
        nvPushData(1, nvMoCompParams.surfaceOffset + nvMoCompParams.surfaceBiasedIntraBlockOffset);

        // Change texture1 pitch to 16 bytes
        nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_CONTROL1(1) | 0x40000);
        nvPushData(3, 16 << 16); // half bias Intra block pitch

        nvPusherAdjust(4);
        
        if  ((blockPattern >= 0xFC) || 
            ((pMacroblock->DCTType == DCT_FIELD) &&
            ((blockPattern & (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)) == (CBP_Y0 | CBP_Y1 | CBP_Y2 | CBP_Y3)))) {

            if (pMacroblock->DCTType == DCT_FIELD) {
                if (blockPattern >= 0xFC) {
                    nvMoCompParams.blockWidth = 64;
                    nvMoCompParams.blockHeight = 16;
                    nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                    nvDoOptimizedIntraFieldCorrection();
                    
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;

                    nvDoOptimizedIntraFieldCorrection();

                    // IDCTIndex += 2;
                    
                    nvMoCompParams.correctionY += 8; // (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.blockY += 16;

                    nvDoOptimizedIntraFieldCorrection();
                    
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;

                    nvDoOptimizedIntraFieldCorrection();
                    
                } else {
                    nvMoCompParams.blockWidth = 32;
                    nvMoCompParams.blockHeight = 16;
                    nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high

                    nvMoCompParams.correctionField = 0;
                    nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                    nvDoAllIntraFieldCorrections(8, 4);
                    
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;

                    nvDoAllIntraFieldCorrections(8, 4);
                }
            } else {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockWidth = 64;
                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                
                nvDoOptimizedIntraFieldCorrection();
            }
            
            IDCTIndex += 4;

        } else {

            if (pMacroblock->DCTType == DCT_FRAME) {
                // Temporarily change texture0 pitch to 8 bytes so that each scanline in IDCT block will be used
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 8 << 16);

                nvPusherAdjust(2);

                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 32;
            } else {
                nvMoCompParams.blockWidth = 32;
                nvMoCompParams.blockHeight = 16;
            }
    
            if (blockPattern & CBP_Y0) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    nvDoOptimizedIntraFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16-byte wide scanlines high
                    nvDoOptimizedIntraFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;
                    nvDoOptimizedIntraFieldCorrection();
                }

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y1) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = (pMacroblock->hOffset + 8) << 2;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte blocks high
                    nvDoOptimizedIntraFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoOptimizedIntraFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY = 16;
                    nvDoOptimizedIntraFieldCorrection();
                }            

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y2) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = pMacroblock->hOffset << 2;
                nvMoCompParams.blockY = (pMacroblock->vOffset + 8) << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high
                    nvDoOptimizedIntraFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoOptimizedIntraFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;
                    nvDoOptimizedIntraFieldCorrection();
                }

                IDCTIndex++;
            }

            if (blockPattern & CBP_Y3) {
                nvMoCompParams.correctionField = 0;
                nvMoCompParams.blockX = (pMacroblock->hOffset + 8) << 2;
                nvMoCompParams.blockY = (pMacroblock->vOffset + 8) << 2;

                if (pMacroblock->DCTType == DCT_FRAME) {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 3; // IDCT blocks are 8 8 byte scanlines high
                    nvDoOptimizedIntraFieldCorrection();
                } else {
                    nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high
                    nvDoOptimizedIntraFieldCorrection();
                    nvMoCompParams.correctionField = 1;
                    nvMoCompParams.blockY += 16;
                    nvDoOptimizedIntraFieldCorrection();
                }

                IDCTIndex++;
            }

            if (pMacroblock->DCTType == DCT_FRAME) {
                // Restore texture0 pitch to it's default value of 16 bytes
                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                               NV056_SET_TEXTURE_CONTROL1(0) | 0x40000);
                nvPushData(1, 16 << 16);

                nvPusherAdjust(2);
            }
        
        }
        
    #ifdef  DEBUG
        if (moCompDebugLevel < 3) {
    #endif  // DEBUG

        // Chroma IDCTs are always frame based

        if (blockPattern & (CBP_CB | CBP_CR)) {

            nvMoCompParams.correctionField = 0;
            nvMoCompParams.blockWidth = 64;
            nvMoCompParams.blockHeight = 32;
            nvMoCompParams.blockX = pMacroblock->hOffset << 2;
            nvMoCompParams.blockY = chromaVOffset + (pMacroblock->vOffset << 1);
            nvMoCompParams.correctionY = (IDCTIndex - firstAlignedIndex) << 2; // IDCT blocks are 4 16 byte scanlines high

            nvDoOptimizedIntraFieldCorrection();
        }

#ifdef  DEBUG
        }
#endif  // DEBUG
    }
} /* nvCorrectCelsiusFieldMacroblock */


#endif  // NVARCH >= 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\MoInitKelvin.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*==========================================================================;
 *
 *  Copyright (C) 2000 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       MoInitKelvin.cpp
 *  Content:    Windows98 DirectDraw 32 bit driver
 *
 ***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

extern NVMOCOMPPARAMS nvMoCompParams;

/*
 * nvInitKelvinForMoComp
 *
 * Performs basic motion comp initialization of the kelvin class object
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvInitKelvinForMoComp(void)
{
    LPDDRAWI_DDRAWSURFACE_LCL   dstx = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   dst;
    unsigned long               surfaceWidth;
    unsigned long               surfaceHeight;
    unsigned long               surfacePitch;
    unsigned long               tmpVal;
    float                       fBuffer[16];
    unsigned long               *ftol = (unsigned long *)&fBuffer[0];
    float                       xTrans, yTrans, zTrans;

    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        if (!nvEnable32(NULL)) {
            return FALSE;
        }
    }

	if(dstx == NULL)	//it happens with WinDVD
		return FALSE;

    dst = dstx->lpGbl;
    surfaceWidth = dst->wWidth;
    surfaceHeight = dst->wHeight;
    surfacePitch = dst->lPitch;

    pDriverData->dwMostRecentHWUser = MODULE_ID_DDRAW;

    // Let D3D code know that we have touched NV
    pDriverData->TwoDRenderingOccurred = 1;

    // Clear current IDCT context Dma
    pDriverData->dwMCCurrentCelsiusIDCTCtxDma = 0;

    // Reset current vertex mode
    nvMoCompParams.vertexMode = 0;

    // Reset current data format
    nvMoCompParams.dataFormat = 0;

    // Reset the kelvin context Dmas to use the default video context Dma
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_CONTEXT_DMA_NOTIFIES | 0x40000);
    nvPushData(1, NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_CONTEXT_DMA_A | 0x40000);
    nvPushData(3, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_CONTEXT_DMA_B | 0x40000);
    nvPushData(5, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_CONTEXT_DMA_STATE | 0x40000);
    nvPushData(7, NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY);

    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_CONTEXT_DMA_COLOR | 0x40000);
    nvPushData(9, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_CONTEXT_DMA_ZETA | 0x40000);
    nvPushData(11, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_CONTEXT_DMA_VERTEX_A | 0x40000);
    nvPushData(13, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_CONTEXT_DMA_VERTEX_B | 0x40000);
    nvPushData(15, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    nvPushData(16, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_CONTEXT_DMA_SEMAPHORE | 0x40000);
    nvPushData(17, NV01_NULL_OBJECT);

    nvPushData(18, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_CONTEXT_DMA_REPORT | 0x40000);
    nvPushData(19, NV01_NULL_OBJECT);

    nvPusherAdjust(20);

    // Set surface clip rectangle
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_CLIP_HORIZONTAL | 0x40000);
    // pitch << 1
    nvPushData(1, ((surfacePitch << 17) | 0));

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_CLIP_VERTICAL | 0x40000);
    // height << 1 which is at least enough for luma height + chroma height
    nvPushData(3, ((surfaceHeight << 17) | 0));

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_WINDOW_CLIP_TYPE | 0x40000);
    nvPushData(5, NV097_SET_WINDOW_CLIP_TYPE_V_INCLUSIVE);

    // Set up one window clip rectangle to be the rendered area
    // All the other rectangles are deactivated
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_WINDOW_CLIP_HORIZONTAL(0) | 0x200000);
    nvPushData(7, ((4095 << 16) | 0));
    nvPushData(8, 0);
    nvPushData(9, 0);
    nvPushData(10, 0);
    nvPushData(11, 0);
    nvPushData(12, 0);
    nvPushData(13, 0);
    nvPushData(14, 0);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_WINDOW_CLIP_VERTICAL(0) | 0x200000);
    nvPushData(16, ((4095 << 16) | 0));
    nvPushData(17, 0);
    nvPushData(18, 0);
    nvPushData(19, 0);
    nvPushData(20, 0);
    nvPushData(21, 0);
    nvPushData(22, 0);
    nvPushData(23, 0);

    nvPusherAdjust(24);

    // Set Control0 defaults
    tmpVal = (NV097_SET_CONTROL0_COLOR_SPACE_CONVERT_PASS << 28) |
             (NV097_SET_CONTROL0_PREMULTIPLIEDALPHA_FALSE << 24) |
             (NV097_SET_CONTROL0_TEXTUREPERSPECTIVE_FALSE << 20) |
             (NV097_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE << 16) |
             (NV097_SET_CONTROL0_Z_FORMAT_FIXED << 12) |
             (NV097_SET_CONTROL0_STENCIL_WRITE_ENABLE_TRUE);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_CONTROL0 | 0x40000);
    nvPushData(1, tmpVal);

    nvPusherAdjust(2);

    // Make sure to disable any transform program which may be running in D3D
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TRANSFORM_EXECUTION_MODE | 0x40000);
    nvPushData(1, ((NV097_SET_TRANSFORM_EXECUTION_MODE_RANGE_MODE_PRIV << 2) |
                    NV097_SET_TRANSFORM_EXECUTION_MODE_MODE_FIXED));

    nvPusherAdjust(2);

    // Load Projection, ModelView, and inverse ModelView matrix with identity
    fBuffer[0]  = 1.0; fBuffer[1]  = 0.0; fBuffer[2]  = 0.0; fBuffer[3]  = 0.0;
    fBuffer[4]  = 0.0; fBuffer[5]  = 1.0; fBuffer[6]  = 0.0; fBuffer[7]  = 0.0;
    fBuffer[8]  = 0.0; fBuffer[9]  = 0.0; fBuffer[10] = 1.0; fBuffer[11] = 0.0;
    fBuffer[12] = 0.0; fBuffer[13] = 0.0; fBuffer[14] = 0.0; fBuffer[15] = 1.0;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_PROJECTION_MATRIX(0) | 0x400000);
    nvPushData(1, ftol[0]);
    nvPushData(2, ftol[4]);
    nvPushData(3, ftol[8]);
    nvPushData(4, ftol[12]);
    nvPushData(5, ftol[1]);
    nvPushData(6, ftol[5]);
    nvPushData(7, ftol[9]);
    nvPushData(8, ftol[13]);
    nvPushData(9, ftol[2]);
    nvPushData(10, ftol[6]);
    nvPushData(11, ftol[10]);
    nvPushData(12, ftol[14]);
    nvPushData(13, ftol[3]);
    nvPushData(14, ftol[7]);
    nvPushData(15, ftol[11]);
    nvPushData(16, ftol[15]);

    nvPusherAdjust(17);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_MODEL_VIEW_MATRIX0(0) | 0x400000);
    nvPushData(1, ftol[0]);
    nvPushData(2, ftol[4]);
    nvPushData(3, ftol[8]);
    nvPushData(4, ftol[12]);
    nvPushData(5, ftol[1]);
    nvPushData(6, ftol[5]);
    nvPushData(7, ftol[9]);
    nvPushData(8, ftol[13]);
    nvPushData(9, ftol[2]);
    nvPushData(10, ftol[6]);
    nvPushData(11, ftol[10]);
    nvPushData(12, ftol[14]);
    nvPushData(13, ftol[3]);
    nvPushData(14, ftol[7]);
    nvPushData(15, ftol[11]);
    nvPushData(16, ftol[15]);

    nvPusherAdjust(17);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_INVERSE_MODEL_VIEW_MATRIX0(0) | 0x400000);
    nvPushData(1, ftol[0]);
    nvPushData(2, ftol[4]);
    nvPushData(3, ftol[8]);
    nvPushData(4, ftol[12]);
    nvPushData(5, ftol[1]);
    nvPushData(6, ftol[5]);
    nvPushData(7, ftol[9]);
    nvPushData(8, ftol[13]);
    nvPushData(9, ftol[2]);
    nvPushData(10, ftol[6]);
    nvPushData(11, ftol[10]);
    nvPushData(12, ftol[14]);
    nvPushData(13, ftol[3]);
    nvPushData(14, ftol[7]);
    nvPushData(15, ftol[11]);
    nvPushData(16, ftol[15]);

    nvPusherAdjust(17);

    // Align surface pitch and set surface format and pitch
    surfacePitch |= (surfacePitch << 16);
    surfacePitch <<= 1; // Surface is always referenced by hardware in field mode

    tmpVal = (NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1 << 12) |
             (NV097_SET_SURFACE_FORMAT_TYPE_PITCH << 8) |
             (NV097_SET_SURFACE_FORMAT_ZETA_Z16 << 4) |
              NV097_SET_SURFACE_FORMAT_COLOR_LE_B8;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_FORMAT | 0x40000);
    nvPushData(1, tmpVal);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_PITCH | 0x40000);
    nvPushData(3, surfacePitch);

    nvPusherAdjust(4);

    // Set up viewport
    xTrans = (float)(1.0 / 32.0); // hardware epsilon
    yTrans = (float)(1.0 / 32.0);
    zTrans = 0.0;

    // Load composite matrix assuming quarter pel scaling of surface coordinates
    if (pDriverData->bMCHorizontallyDownscale1080i)
        fBuffer[0]  = 0.1875; // quarter pel xScale
    else
        fBuffer[0]  = 0.25; // quarter pel xScale
    fBuffer[1]  = 0.0;
    fBuffer[2]  = 0.0;
    fBuffer[3]  = 0.0;
    fBuffer[4]  = 0.0;
    fBuffer[5]  = 0.25; // quarter pel yScale
    fBuffer[6]  = 0.0;
    fBuffer[7]  = 0.0;
    fBuffer[8]  = 0.0;
    fBuffer[9]  = 0.0;
    fBuffer[10] = 1.0;
    fBuffer[11] = 0.0;
    fBuffer[12] = 0.0;
    fBuffer[13] = 0.0;
    fBuffer[14] = 0.0;
    fBuffer[15] = 1.0;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMPOSITE_MATRIX(0) | 0x400000);
    nvPushData(1, ftol[0]);
    nvPushData(2, ftol[4]);
    nvPushData(3, ftol[8]);
    nvPushData(4, ftol[12]);
    nvPushData(5, ftol[1]);
    nvPushData(6, ftol[5]);
    nvPushData(7, ftol[9]);
    nvPushData(8, ftol[13]);
    nvPushData(9, ftol[2]);
    nvPushData(10, ftol[6]);
    nvPushData(11, ftol[10]);
    nvPushData(12, ftol[14]);
    nvPushData(13, ftol[3]);
    nvPushData(14, ftol[7]);
    nvPushData(15, ftol[11]);
    nvPushData(16, ftol[15]);

    nvPusherAdjust(17);

    // Set viewport offset separately
    fBuffer[0] = xTrans;
    fBuffer[1] = yTrans;
    fBuffer[2] = zTrans;
    fBuffer[3] = 0.0;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_VIEWPORT_OFFSET(0) | 0x100000);
    nvPushData(1, ftol[0]);
    nvPushData(2, ftol[1]);
    nvPushData(3, ftol[2]);
    nvPushData(4, ftol[3]);

    nvPusherAdjust(5);

#if (NVARCH >= 0x20)
    // Set front and back clipping
    fBuffer[0] = 0.0;
    fBuffer[1] = KELVIN_Z_SCALE24;
#endif

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_CLIP_MIN | 0x80000);
    nvPushData(1, ftol[0]);
    nvPushData(2, ftol[1]);

    nvPusherAdjust(3);

    // Set light control
    tmpVal = (NV097_SET_LIGHT_CONTROL_SOUT_ZERO_OUT << 17) |
             (NV097_SET_LIGHT_CONTROL_LOCALEYE_FALSE << 16) |
              NV097_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_FALSE;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_LIGHT_CONTROL | 0x40000);
    nvPushData(1, tmpVal);

    // Disable color material
    tmpVal = (NV097_SET_COLOR_MATERIAL_BACK_SPECULAR_MATERIAL_DISABLE << 14) |
             (NV097_SET_COLOR_MATERIAL_BACK_DIFF_MATERIAL_DISABLE << 12) |
             (NV097_SET_COLOR_MATERIAL_BACK_AMBIENT_MATERIAL_DISABLE << 10) |
             (NV097_SET_COLOR_MATERIAL_BACK_EMISSIVE_MATERIAL_DISABLE << 8) |
             (NV097_SET_COLOR_MATERIAL_SPECULAR_MATERIAL_DISABLE << 6) |
             (NV097_SET_COLOR_MATERIAL_DIFF_MATERIAL_DISABLE << 4) |
             (NV097_SET_COLOR_MATERIAL_AMBIENT_MATERIAL_DISABLE << 2) |
              NV097_SET_COLOR_MATERIAL_EMISSIVE_MATERIAL_DISABLE;

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COLOR_MATERIAL | 0x40000);
    nvPushData(3, tmpVal);

    nvPusherAdjust(4);

    // Set default fog mode
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG_MODE | 0x40000);
    nvPushData(1, NV097_SET_FOG_MODE_V_LINEAR);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG_GEN_MODE | 0x40000);
//    nvPushData(3, NV097_SET_FOG_GEN_MODE_V_SPEC_ALPHA);
    nvPushData(3, NV097_SET_FOG_GEN_MODE_V_FOG_X);

    // Disable fog
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG_ENABLE | 0x40000);
    nvPushData(5, NV097_SET_FOG_ENABLE_V_FALSE);

    // Set default fog color
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG_COLOR | 0x40000);
    nvPushData(7, 0xFFFFFFFF);

    nvPusherAdjust(8);

    // Disable almost everything

    // Disable alpha test
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_ALPHA_TEST_ENABLE | 0x40000);
    nvPushData(1, NV097_SET_ALPHA_TEST_ENABLE_V_FALSE);

    // Disable blending
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BLEND_ENABLE | 0x40000);
    nvPushData(3, NV097_SET_BLEND_ENABLE_V_FALSE);

    // Disable culling
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_CULL_FACE_ENABLE | 0x40000);
    nvPushData(5, NV097_SET_CULL_FACE_ENABLE_V_FALSE);

    // Disable depth test
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_DEPTH_TEST_ENABLE | 0x40000);
    nvPushData(7, NV097_SET_DEPTH_TEST_ENABLE_V_FALSE);

    // Disable dither
    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_DITHER_ENABLE | 0x40000);
    nvPushData(9, NV097_SET_DITHER_ENABLE_V_FALSE);

    // Disable lighting
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_LIGHTING_ENABLE | 0x40000);
    nvPushData(11, NV097_SET_LIGHTING_ENABLE_V_FALSE);

    // Disable point parameters computation
    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_POINT_PARAMS_ENABLE | 0x40000);
    nvPushData(13, NV097_SET_POINT_PARAMS_ENABLE_V_FALSE);

    // Disable point smoothing
    nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_POINT_SMOOTH_ENABLE | 0x40000);
    nvPushData(15, NV097_SET_LINE_SMOOTH_ENABLE_V_FALSE);

    // Disable line smoothing
    nvPushData(16, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_LINE_SMOOTH_ENABLE | 0x40000);
    nvPushData(17, NV097_SET_LINE_SMOOTH_ENABLE_V_FALSE);

    // Disable polygon smoothing
    nvPushData(18, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_POLY_SMOOTH_ENABLE | 0x40000);
    nvPushData(19, NV097_SET_POLY_SMOOTH_ENABLE_V_FALSE);

    // Disable stippling
    nvPushData(20, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_STIPPLE_CONTROL | 0x40000);
    nvPushData(21, NV097_SET_STIPPLE_CONTROL_V_OFF);

    // Disable skinning
    nvPushData(22, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_SKIN_MODE | 0x40000);
    nvPushData(23, NV097_SET_SKIN_MODE_V_OFF);

    // Disable stencil test
    nvPushData(24, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_STENCIL_TEST_ENABLE | 0x40000);
    nvPushData(25, NV097_SET_STENCIL_TEST_ENABLE_V_FALSE);

    // Disable polygon offset point
    nvPushData(26, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_POLY_OFFSET_POINT_ENABLE | 0x40000);
    nvPushData(27, NV097_SET_POLY_OFFSET_POINT_ENABLE_V_FALSE);

    // Disable polygon offset line
    nvPushData(28, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_POLY_OFFSET_LINE_ENABLE | 0x40000);
    nvPushData(29, NV097_SET_POLY_OFFSET_LINE_ENABLE_V_FALSE);

    // Disable polygon offset fill
    nvPushData(30, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_POLY_OFFSET_FILL_ENABLE | 0x40000);
    nvPushData(31, NV097_SET_POLY_OFFSET_FILL_ENABLE_V_FALSE);

    nvPusherAdjust(32);

    // Set default alpha function
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_ALPHA_FUNC | 0x40000);
    nvPushData(1, NV097_SET_ALPHA_FUNC_V_ALWAYS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_ALPHA_REF | 0x40000);
    nvPushData(3, 0);

    // Initialize blend factors for later use
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BLEND_FUNC_SFACTOR | 0x40000);
    nvPushData(5, NV097_SET_BLEND_FUNC_SFACTOR_V_ONE);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BLEND_FUNC_DFACTOR | 0x40000);
    nvPushData(7, NV097_SET_BLEND_FUNC_DFACTOR_V_ONE);

    // Set default blend color
    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BLEND_COLOR | 0x40000);
    nvPushData(9, 0);

    // Set default blend equation
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BLEND_EQUATION | 0x40000);
    nvPushData(11, NV097_SET_BLEND_EQUATION_V_FUNC_ADD_SIGNED);

    nvPusherAdjust(12);

    // Set depth function
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_DEPTH_FUNC | 0x40000);
    nvPushData(1, NV097_SET_DEPTH_FUNC_V_ALWAYS);

    // Set color mask
    tmpVal = (NV097_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_TRUE << 24) |
             (NV097_SET_COLOR_MASK_RED_WRITE_ENABLE_TRUE << 16) |
             (NV097_SET_COLOR_MASK_GREEN_WRITE_ENABLE_TRUE << 8) |
              NV097_SET_COLOR_MASK_BLUE_WRITE_ENABLE_TRUE;

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COLOR_MASK | 0x40000);
    nvPushData(3, tmpVal);

    // Set depth mask
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_DEPTH_MASK | 0x40000);
    nvPushData(5, NV097_SET_DEPTH_MASK_V_FALSE);

    nvPusherAdjust(6);

    // Initialize stencil state (test already disabled above)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_STENCIL_MASK | 0x40000);
    nvPushData(1, 0x000000FF);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_STENCIL_FUNC | 0x40000);
    nvPushData(3, NV097_SET_STENCIL_FUNC_V_ALWAYS);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_STENCIL_FUNC_REF | 0x40000);
    nvPushData(5, 0);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_STENCIL_FUNC_MASK | 0x40000);
    nvPushData(7, 0x000000FF);

    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_STENCIL_OP_FAIL | 0x40000);
    nvPushData(9, NV097_SET_STENCIL_OP_FAIL_V_KEEP);

    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_STENCIL_OP_ZFAIL | 0x40000);
    nvPushData(11, NV097_SET_STENCIL_OP_ZFAIL_V_KEEP);

    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_STENCIL_OP_ZPASS | 0x40000);
    nvPushData(13, NV097_SET_STENCIL_OP_ZPASS_V_KEEP);

    nvPusherAdjust(14);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SHADE_MODE | 0x40000);
    nvPushData(1, NV097_SET_SHADE_MODE_V_FLAT);

    fBuffer[0] = 0.0;

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_POLYGON_OFFSET_SCALE_FACTOR | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_POLYGON_OFFSET_BIAS | 0x40000);
    nvPushData(5, ftol[0]);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FRONT_POLYGON_MODE | 0x40000);
    nvPushData(7, NV097_SET_FRONT_POLYGON_MODE_V_FILL);

    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BACK_POLYGON_MODE | 0x40000);
    nvPushData(9, NV097_SET_BACK_POLYGON_MODE_V_FILL);

    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_CULL_FACE | 0x40000);
    nvPushData(11, NV097_SET_CULL_FACE_V_BACK);

    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_FRONT_FACE | 0x40000);
    nvPushData(13, NV097_SET_FRONT_FACE_V_CCW);

    nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_NORMALIZATION_ENABLE | 0x40000);
    nvPushData(15, NV097_SET_NORMALIZATION_ENABLE_V_FALSE);

    nvPushData(16, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_EDGE_FLAG | 0x40000);
    nvPushData(17, NV097_SET_EDGE_FLAG_V_TRUE);

    nvPusherAdjust(18);

    // Set material emission
    fBuffer[0] = 0.0;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_MATERIAL_EMISSION(0) | 0xC0000);
    nvPushData(1, ftol[0]);
    nvPushData(2, ftol[0]);
    nvPushData(3, ftol[0]);

    // Disable specular
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SPECULAR_ENABLE | 0x40000);
    nvPushData(5, NV097_SET_SPECULAR_ENABLE_V_FALSE);

    // Disable all lights
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_LIGHT_ENABLE_MASK | 0x40000);
    nvPushData(7, 0);

    nvPusherAdjust(8);

    // Disable texgen modes for now (OpenGL default is EYE_LINEAR)

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXGEN_S(0) | 0x40000);
    nvPushData(1, NV097_SET_TEXGEN_S_V_DISABLE);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXGEN_T(0) | 0x40000);
    nvPushData(3, NV097_SET_TEXGEN_T_V_DISABLE);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXGEN_R(0) | 0x40000);
    nvPushData(5, NV097_SET_TEXGEN_R_V_DISABLE);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXGEN_Q(0) | 0x40000);
    nvPushData(7, NV097_SET_TEXGEN_Q_V_DISABLE);

    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXGEN_S(1) | 0x40000);
    nvPushData(9, NV097_SET_TEXGEN_S_V_DISABLE);

    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXGEN_T(1) | 0x40000);
    nvPushData(11, NV097_SET_TEXGEN_T_V_DISABLE);

    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXGEN_R(1) | 0x40000);
    nvPushData(13, NV097_SET_TEXGEN_R_V_DISABLE);

    nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXGEN_Q(1) | 0x40000);
    nvPushData(15, NV097_SET_TEXGEN_Q_V_DISABLE);

    nvPusherAdjust(16);

    // We don't use texgen so we skip setting texgen planes

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SWATH_WIDTH | 0x40000);
    nvPushData(1, NV097_SET_SWATH_WIDTH_V_OFF);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SHADER_STAGE_PROGRAM | 0x40000);
    nvPushData(3, ((NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_PROGRAM_NONE << 15) |
                   (NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_PROGRAM_NONE << 10) |
                   (NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_2D_PROJECTIVE << 5) |
                    NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_2D_PROJECTIVE));

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SHADER_CLIP_PLANE_MODE | 0x40000);
    nvPushData(5, 0);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SHADER_OTHER_STAGE_INPUT | 0x40000);
    nvPushData(7, 0);

    // This is set once and forgotten. It puts the class in OGL flat shade mode.
    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FLAT_SHADE_OP | 0x40000);
    nvPushData(9, NV097_SET_FLAT_SHADE_OP_V_LAST_VTX);

    nvPusherAdjust(10);

    fBuffer[0] = 0.0;
    fBuffer[1] = 1.0;

    // Set default fog parameters
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG_PARAMS(0) | 0xC0000);
    nvPushData(1, ftol[1]);                     // K0
    nvPushData(2, ftol[1]);                     // K1
    nvPushData(3, ftol[0]);                     // K2

    // Set fog plane
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG_PLANE(0) | 0x100000);
    nvPushData(5, ftol[0]);
    nvPushData(6, ftol[0]);
    nvPushData(7, ftol[1]);
    nvPushData(8, ftol[0]);

    nvPusherAdjust(9);

    // Initialize some vertex attributes
    fBuffer[0] = 0.0;
    fBuffer[1] = 1.0;

    // Set color for MODULATE blend mode
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_DIFFUSE_COLOR4F(0) | 0x100000);
    nvPushData(1, ftol[1]);
    nvPushData(2, ftol[1]);
    nvPushData(3, ftol[1]);
    nvPushData(4, ftol[1]);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SPECULAR_COLOR3F(0) | 0xC0000);
    nvPushData(6, ftol[0]);
    nvPushData(7, ftol[0]);
    nvPushData(8, ftol[0]);

    nvPushData(9, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXCOORD0_4F(0) | 0x100000);
    nvPushData(10, ftol[0]);
    nvPushData(11, ftol[0]);
    nvPushData(12, ftol[0]);
    nvPushData(13, ftol[1]);

    nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXCOORD1_4F(0) | 0x100000);
    nvPushData(15, ftol[0]);
    nvPushData(16, ftol[0]);
    nvPushData(17, ftol[0]);
    nvPushData(18, ftol[1]);

    nvPushData(19, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_NORMAL3F(0) | 0xC0000);
    nvPushData(20, ftol[0]);
    nvPushData(21, ftol[0]);
    nvPushData(22, ftol[1]);

    nvPushData(23, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_FOG1F | 0x40000);
    nvPushData(24, ftol[0]);

    nvPushData(25, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_WEIGHT1F | 0x40000);
    nvPushData(26, ftol[1]);

    nvPusherAdjust(27);

    // Load texture matrices assuming quarter pel scaling of texture coordinates
    if (pDriverData->bMCHorizontallyDownscale1080i)
        fBuffer[0]  = 0.1875;
    else
        fBuffer[0]  = 0.25;

                        fBuffer[1]  = 0.0;  fBuffer[2]  = 0.0; fBuffer[3]  = 0.0;
    fBuffer[4]  = 0.0;  fBuffer[5]  = 0.25; fBuffer[6]  = 0.0; fBuffer[7]  = 0.0;
    fBuffer[8]  = 0.0;  fBuffer[9]  = 0.0;  fBuffer[10] = 1.0; fBuffer[11] = 0.0;
    fBuffer[12] = 0.0;  fBuffer[13] = 0.0;  fBuffer[14] = 0.0; fBuffer[15] = 1.0;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_MATRIX0(0) | 0x400000);
    nvPushData(1, ftol[0]);
    nvPushData(2, ftol[4]);
    nvPushData(3, ftol[8]);
    nvPushData(4, ftol[12]);
    nvPushData(5, ftol[1]);
    nvPushData(6, ftol[5]);
    nvPushData(7, ftol[9]);
    nvPushData(8, ftol[13]);
    nvPushData(9, ftol[2]);
    nvPushData(10, ftol[6]);
    nvPushData(11, ftol[10]);
    nvPushData(12, ftol[14]);
    nvPushData(13, ftol[3]);
    nvPushData(14, ftol[7]);
    nvPushData(15, ftol[11]);
    nvPushData(16, ftol[15]);

    nvPushData(17, dDrawSubchannelOffset(NV_DD_KELVIN) +
        NV097_SET_TEXTURE_MATRIX1(0) | 0x400000);
    nvPushData(18, ftol[0]);
    nvPushData(19, ftol[4]);
    nvPushData(20, ftol[8]);
    nvPushData(21, ftol[12]);
    nvPushData(22, ftol[1]);
    nvPushData(23, ftol[5]);
    nvPushData(24, ftol[9]);
    nvPushData(25, ftol[13]);
    nvPushData(26, ftol[2]);
    nvPushData(27, ftol[6]);
    nvPushData(28, ftol[10]);
    nvPushData(29, ftol[14]);
    nvPushData(30, ftol[3]);
    nvPushData(31, ftol[7]);
    nvPushData(32, ftol[11]);
    nvPushData(33, ftol[15]);

    nvPusherAdjust(34);

    // Disable logic ops
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_LOGIC_OP_ENABLE | 0x40000);
    nvPushData(1, NV097_SET_LOGIC_OP_ENABLE_V_FALSE);

    // Disable Z min/max culling
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_ZMIN_MAX_CONTROL | 0x40000);
    nvPushData(3, ((NV097_SET_ZMIN_MAX_CONTROL_CULL_IGNORE_W_TRUE << 8) |
                   (NV097_SET_ZMIN_MAX_CONTROL_ZCLAMP_EN_CLAMP << 4) |
                    NV097_SET_ZMIN_MAX_CONTROL_CULL_NEAR_FAR_EN_FALSE));

    // MUST set antialiasing control sample mask even though antialiasing is disabled
    // Disable antialiasing
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_ANTI_ALIASING_CONTROL | 0x40000);
    nvPushData(5, ((0xFFFF0000) |
                    NV097_SET_ANTI_ALIASING_CONTROL_ENABLE_FALSE));

    // Disable z buffer compression
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMPRESS_ZBUFFER_EN | 0x40000);
    nvPushData(7, NV097_SET_COMPRESS_ZBUFFER_EN_V_DISABLE);

    // Disable z stencil occlusion
    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_OCCLUDE_ZSTENCIL_EN | 0x40000);
    nvPushData(9, NV097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_ZEN_DISABLE);

    // Disable two sided lighting
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TWO_SIDE_LIGHT_EN | 0x40000);
    nvPushData(11, NV097_SET_TWO_SIDE_LIGHT_EN_V_FALSE);

    // Disable z pass pixel counting
    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_ZPASS_PIXEL_COUNT_ENABLE | 0x40000);
    nvPushData(13, NV097_SET_ZPASS_PIXEL_COUNT_ENABLE_V_FALSE);

    nvPusherAdjust(14);

    nvPusherStart(TRUE);

    return TRUE;

} /* nvInitKelvinForMoComp */



/*
 * nvInitKelvinForMoCompPrediction
 *
 * Performs final kelvin object motion comp initialization for
 * the prediction portion of the algorithm.
 *
 * For prediction, texture 0 is used for forward prediction, texture 1
 * is used for backward prediction.  These textures are just passed through
 * the register combiners to the final combiner.  The final combiner is
 * configured so that the fog coordinate is used to control the contribution
 * of each texture in the final output.  A fog value of 0.0 selects forward
 * prediction, 0.5 selects bidirectional prediction, and 1.0 selects backward
 * prediction.
 *
 * In this mode the register combiners are set to:
 *
 *      INPUT: A = (1.0)constantColor0, B = texture0, C = (1.0)constantColor0, D = texture1
 *      OUTPUT: spare0 = A * B, spare1 = C * D
 *
 * And the final combiner is set to:
 *
 *      INPUT: A.rgb = Fog.a, B = spare1, C = spare0, D = 0
 *      OUTPUT: B * A + C * (1.0 - A)
 *
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvInitKelvinForMoCompPrediction(void)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl = pSurf_lcl->lpGbl;
    unsigned long               surfaceWidth = pSurf_gbl->wWidth;
    unsigned long               surfaceHeight = pSurf_gbl->wHeight;
    unsigned long               surfacePitch = pSurf_gbl->lPitch;
    unsigned long               dwSurfaceOffset;
    unsigned long               tmpVal;
    float                       fBuffer[16];
    unsigned long               *ftol = (unsigned long *)&fBuffer[0];
    unsigned long               moCompICW;
    unsigned long               moCompOCW;
    unsigned long               moCompFinalCW0;
    unsigned long               moCompFinalCW1;

    // Let D3D code know that we have touched NV
    pDriverData->TwoDRenderingOccurred = 1;

    // Initialize surface offsets
    dwSurfaceOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_NO_OPERATION | 0x40000);
    nvPushData(1, 0);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
    nvPushData(3, dwSurfaceOffset);

    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCForwardSurface;
    pSurf_gbl = pSurf_lcl->lpGbl;

    dwSurfaceOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
    nvPushData(5, dwSurfaceOffset);

    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface;
    pSurf_gbl = pSurf_lcl->lpGbl;

    dwSurfaceOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(7, dwSurfaceOffset);

    nvPusherAdjust(8);

    // Align surface pitch and set surface format and pitch
    surfacePitch |= (surfacePitch << 16);
    surfacePitch <<= 1; // Surface is always referenced by hardware in field mode

    tmpVal = (NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1 << 12) |
             (NV097_SET_SURFACE_FORMAT_TYPE_PITCH << 8) |
             (NV097_SET_SURFACE_FORMAT_ZETA_Z16 << 4) |
              NV097_SET_SURFACE_FORMAT_COLOR_LE_B8;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_FORMAT | 0x40000);
    nvPushData(1, tmpVal);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_PITCH | 0x40000);
    nvPushData(3, surfacePitch);

    nvPusherAdjust(4);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_MATRIX_ENABLE(0) | 0x100000);
    nvPushData(1, NV097_SET_TEXTURE_MATRIX_ENABLE_V_TRUE);
    nvPushData(2, NV097_SET_TEXTURE_MATRIX_ENABLE_V_TRUE);
    nvPushData(3, NV097_SET_TEXTURE_MATRIX_ENABLE_V_FALSE);
    nvPushData(4, NV097_SET_TEXTURE_MATRIX_ENABLE_V_FALSE);

    nvPusherAdjust(5);

    nvMoCompParams.dataFormat = DATA_FORMAT_LUMA;

    tmpVal = (1 << 16) | // 1 MIPMAP level
             (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8 << 8) |
             (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) |
             (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) |
             (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
              NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(0) | 0x40000);
    nvPushData(1, tmpVal);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(1) | 0x40000);
    nvPushData(3, tmpVal);
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(2) | 0x40000);
    nvPushData(5, tmpVal);
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(3) | 0x40000);
    nvPushData(7, tmpVal);

    tmpVal = (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_Q_FALSE << 24) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_P_FALSE << 20) |
             (NV097_SET_TEXTURE_ADDRESS_P_CLAMP_TO_EDGE << 16) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_V_FALSE << 12) |
             (NV097_SET_TEXTURE_ADDRESS_V_CLAMP_TO_EDGE << 8) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_U_FALSE << 4) |
              NV097_SET_TEXTURE_ADDRESS_U_CLAMP_TO_EDGE;

    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_ADDRESS(0) | 0x40000);
    nvPushData(9, tmpVal);
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_ADDRESS(1) | 0x40000);
    nvPushData(11, tmpVal);
    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_ADDRESS(2) | 0x40000);
    nvPushData(13, tmpVal);
    nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_ADDRESS(3) | 0x40000);
    nvPushData(15, tmpVal);

    nvPusherAdjust(16);

    pDriverData->dwMCTex0Control0 = (NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 18) | // MIN_LOD_CLAMP == 0.9
                                    (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
                                    (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    pDriverData->dwMCTex1Control0 = (NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 18) | // MIN_LOD_CLAMP == 0.9
                                    (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
                                    (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    tmpVal = (NV097_SET_TEXTURE_CONTROL0_ENABLE_FALSE << 30) |
             (15 << 18) | // MIN_LOD_CLAMP == 0.9
             (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
             (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
             (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
             (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
              NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(0) | 0x40000);
    nvPushData(1, pDriverData->dwMCTex0Control0);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(1) | 0x40000);
    nvPushData(3, pDriverData->dwMCTex1Control0);
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(2) | 0x40000);
    nvPushData(5, tmpVal);
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(3) | 0x40000);
    nvPushData(7, tmpVal);

    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
    nvPushData(9, surfacePitch << 16);
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(11, surfacePitch << 16);
    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(2) | 0x40000);
    nvPushData(13, surfacePitch << 16);
    nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(3) | 0x40000);
    nvPushData(15, surfacePitch << 16);

    tmpVal = (NV097_SET_TEXTURE_FILTER_BSIGNED_BIT_DISABLED << 31) |
             (NV097_SET_TEXTURE_FILTER_GSIGNED_BIT_DISABLED << 30) |
             (NV097_SET_TEXTURE_FILTER_RSIGNED_BIT_DISABLED << 29) |
             (NV097_SET_TEXTURE_FILTER_ASIGNED_BIT_DISABLED << 28) |
             (NV097_SET_TEXTURE_FILTER_MAG_TENT_LOD0 << 24) |
             (NV097_SET_TEXTURE_FILTER_MIN_TENT_LOD0 << 16) |
             (NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_QUINCUNX << 13);

    nvPushData(16, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(0) | 0x40000);
    nvPushData(17, tmpVal);
    nvPushData(18, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(1) | 0x40000);
    nvPushData(19, tmpVal);
    nvPushData(20, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(2) | 0x40000);
    nvPushData(21, tmpVal);
    nvPushData(22, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(3) | 0x40000);
    nvPushData(23, tmpVal);

    tmpVal = (4094 << 16) | 2046; // Must be even and <= 4094

    nvPushData(24, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(0) | 0x40000);
    nvPushData(25, tmpVal);
    nvPushData(26, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(1) | 0x40000);
    nvPushData(27, tmpVal);
    nvPushData(28, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(2) | 0x40000);
    nvPushData(29, tmpVal);
    nvPushData(30, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(3) | 0x40000);
    nvPushData(31, tmpVal);

    nvPusherAdjust(32);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TRANSFORM_EXECUTION_MODE | 0x40000);
    nvPushData(1, ((NV097_SET_TRANSFORM_EXECUTION_MODE_RANGE_MODE_PRIV << 2) |
                    NV097_SET_TRANSFORM_EXECUTION_MODE_MODE_FIXED));

    nvPusherAdjust(2);


    if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) {

        // Load composite and texture matrices assuming quarter pel horizontal scaling and eigth pel vertical
        // scaling of texture coordinates
        if (pDriverData->bMCHorizontallyDownscale1080i)
            fBuffer[0]  = 0.1875;
        else
            fBuffer[0]  = 0.25;

                            fBuffer[1]  = 0.0;   fBuffer[2]  = 0.0; fBuffer[3]  = 0.0;
        fBuffer[4]  = 0.0;  fBuffer[5]  = 0.125; fBuffer[6]  = 0.0; fBuffer[7]  = 0.0;
        fBuffer[8]  = 0.0;  fBuffer[9]  = 0.0;   fBuffer[10] = 1.0; fBuffer[11] = 0.0;
        fBuffer[12] = 0.0;  fBuffer[13] = 0.0;   fBuffer[14] = 0.0; fBuffer[15] = 1.0;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_COMPOSITE_MATRIX(0) | 0x400000);
        nvPushData(1, ftol[0]);
        nvPushData(2, ftol[4]);
        nvPushData(3, ftol[8]);
        nvPushData(4, ftol[12]);
        nvPushData(5, ftol[1]);
        nvPushData(6, ftol[5]);
        nvPushData(7, ftol[9]);
        nvPushData(8, ftol[13]);
        nvPushData(9, ftol[2]);
        nvPushData(10, ftol[6]);
        nvPushData(11, ftol[10]);
        nvPushData(12, ftol[14]);
        nvPushData(13, ftol[3]);
        nvPushData(14, ftol[7]);
        nvPushData(15, ftol[11]);
        nvPushData(16, ftol[15]);

        nvPusherAdjust(17);

        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_MATRIX0(0) | 0x400000);
        nvPushData(1, ftol[0]);
        nvPushData(2, ftol[4]);
        nvPushData(3, ftol[8]);
        nvPushData(4, ftol[12]);
        nvPushData(5, ftol[1]);
        nvPushData(6, ftol[5]);
        nvPushData(7, ftol[9]);
        nvPushData(8, ftol[13]);
        nvPushData(9, ftol[2]);
        nvPushData(10, ftol[6]);
        nvPushData(11, ftol[10]);
        nvPushData(12, ftol[14]);
        nvPushData(13, ftol[3]);
        nvPushData(14, ftol[7]);
        nvPushData(15, ftol[11]);
        nvPushData(16, ftol[15]);

        nvPushData(17, dDrawSubchannelOffset(NV_DD_KELVIN) +
            NV097_SET_TEXTURE_MATRIX1(0) | 0x400000);
        nvPushData(18, ftol[0]);
        nvPushData(19, ftol[4]);
        nvPushData(20, ftol[8]);
        nvPushData(21, ftol[12]);
        nvPushData(22, ftol[1]);
        nvPushData(23, ftol[5]);
        nvPushData(24, ftol[9]);
        nvPushData(25, ftol[13]);
        nvPushData(26, ftol[2]);
        nvPushData(27, ftol[6]);
        nvPushData(28, ftol[10]);
        nvPushData(29, ftol[14]);
        nvPushData(30, ftol[3]);
        nvPushData(31, ftol[7]);
        nvPushData(32, ftol[11]);
        nvPushData(33, ftol[15]);

        nvPusherAdjust(34);
    }

    // Enable fog (mocomp fog modes set during default mocomp initialization)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG_ENABLE | 0x40000);
    nvPushData(1, NV097_SET_FOG_ENABLE_V_TRUE);

    nvPusherAdjust(2);

    // Now setup combiners

    // Default register combiner settings are:
    // A = primary color
    // B = one
    // C = zero
    // D = zero

    // Our prediction moComp values
    // combiner0, RGB portion:   A = 1
    // combiner0, RGB portion:   B = texture0
    // combiner0, RGB portion:   C = 1
    // combiner0, RGB portion:   D = texture1

    moCompICW = (NV097_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_INVERT << 29) |
                (NV097_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                (NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0 << 24) |

                (NV097_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                (NV097_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                (NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                (NV097_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_INVERT << 13) |
                (NV097_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                (NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0 << 8) |

                (NV097_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                (NV097_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                 NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    // Initialize combiner ICW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_ALPHA_ICW(0) | 0x100000);
    nvPushData(1, DEFAULT_KELVIN_ALPHA_ICW);
    nvPushData(2, DEFAULT_KELVIN_ALPHA_ICW);
    nvPushData(3, DEFAULT_KELVIN_ALPHA_ICW);
    nvPushData(4, DEFAULT_KELVIN_ALPHA_ICW);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_COLOR_ICW(0) | 0x100000);
    nvPushData(6, moCompICW);
    nvPushData(7, DEFAULT_KELVIN_COLOR_ICW);
    nvPushData(8, DEFAULT_KELVIN_COLOR_ICW);
    nvPushData(9, DEFAULT_KELVIN_COLOR_ICW);

    // Load combination factors
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_FACTOR0(0) | 0x40000);
    nvPushData(11, 0xFFFFFFFF); // 100%

    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_FACTOR1(0) | 0x40000);
    nvPushData(13, 0xFFFFFFFF); // 100%

    nvPusherAdjust(14);

    // combiner0, RGB portion:   spare0 = texture0, spare1 = texture1
    moCompOCW = (NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_DISABLE << 19) |
                (NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_DISABLE << 18) |
                (NV097_SET_COMBINER_COLOR_OCW_OP_NOSHIFT << 15) |
                (NV097_SET_COMBINER_COLOR_OCW_MUX_ENABLE_FALSE << 14) |
                (NV097_SET_COMBINER_COLOR_OCW_AB_DOT_ENABLE_FALSE << 13) |
                (NV097_SET_COMBINER_COLOR_OCW_CD_DOT_ENABLE_FALSE << 12) |
                (NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_0 << 8) |
                (NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_C << 4) |
                 NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_D;

    // Initialize combiner OCW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_ALPHA_OCW(0) | 0x100000);
    nvPushData(1, DEFAULT_KELVIN_ALPHA_OCW);
    nvPushData(2, DEFAULT_KELVIN_ALPHA_OCW);
    nvPushData(3, DEFAULT_KELVIN_ALPHA_OCW);
    nvPushData(4, DEFAULT_KELVIN_ALPHA_OCW);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_COLOR_OCW(0) | 0x100000);
    nvPushData(6, moCompOCW);
    nvPushData(7, DEFAULT_KELVIN_COLOR_OCW);
    nvPushData(8, DEFAULT_KELVIN_COLOR_OCW);
    nvPushData(9, DEFAULT_KELVIN_COLOR_OCW);

    tmpVal = (NV097_SET_COMBINER_CONTROL_FACTOR1_SAME_FACTOR_ALL << 16) |
             (NV097_SET_COMBINER_CONTROL_FACTOR0_SAME_FACTOR_ALL << 12) |
             (NV097_SET_COMBINER_CONTROL_MUX_SELECT_MSB << 8) |
              NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_ONE;

    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_CONTROL | 0x40000);
    nvPushData(11, tmpVal);

    nvPusherAdjust(12);

    // Reconfigure fog unit to interpolate
    // fog factor in alpha
    // fog = 0.0: all texture0
    // fog = 0.5: equal parts of texture0 and texture1
    // fog = 1.0: all texture1

    moCompFinalCW0 = (NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_FALSE << 29) |
                     (NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_TRUE << 28) |
                     (NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_3 << 24) |   // fog

                     (NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_FALSE << 21) |
                     (NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_FALSE << 20) |
                     (NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_D << 16) |   // spare1

                     (NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_FALSE << 13) |
                     (NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_FALSE << 12) |
                     (NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_C << 8) |    // spare0

                     (NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_FALSE << 5) |
                     (NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_FALSE << 4) |
                      NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_0;           // 0

    moCompFinalCW1 = (NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_FALSE << 29) |
                     (NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_FALSE << 28) |
                     (NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0 << 24) |   // 0

                     (NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_FALSE << 21) |
                     (NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_FALSE << 20) |
                     (NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0 << 16) |   // 0

                     (NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_TRUE << 13) |
                     (NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_TRUE << 12) |
                     (NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_0 << 8) |    // 0xFF

                     (NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_TRUE << 7) |
                     (NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_FALSE << 6) |
                      NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_FALSE;

    // Initialize combiner final CW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_SPECULAR_FOG_CW0 | 0x40000);
    nvPushData(1, moCompFinalCW0);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_SPECULAR_FOG_CW1 | 0x40000);
    nvPushData(3, moCompFinalCW1);

    nvPusherAdjust(4);

    nvPusherStart(TRUE);

    return TRUE;

} /* nvInitKelvinForMoCompPrediction */


/*
 * nvInitKelvinForMoCompCorrection
 *
 * Performs final kelvin object motion comp initialization for
 * the correction portion of the algorithm.
 *
 * For correction, texture 0 is used for the error terms, texture 1
 * is mapped over the source/destination.  The error terms are signed
 * and the textures are unsigned so the register combiners need to be
 * setup appropriately.
 *
 * In this mode the register combiners are set to:
 *
 *      INPUT: A = (1.0)constantColor0, B = (signed)texture0, C = (1.0)constantColor0, D = (unsigned)texture1
 *      OUTPUT: spare0 = A * B + C * D
 *
 * And the final combiner is set to:
 *
 *      INPUT: C = spare0
 *      OUTPUT: C = spare0
 *
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvInitKelvinForMoCompCorrection(void)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl = pSurf_lcl->lpGbl;
    unsigned long               surfaceWidth = pSurf_gbl->wWidth;
    unsigned long               surfaceHeight = pSurf_gbl->wHeight;
    unsigned long               surfacePitch = pSurf_gbl->lPitch;
    unsigned long               dwSurfaceOffset;
    unsigned long               texturePitch0;
    unsigned long               texturePitch1 = pSurf_gbl->lPitch;
    unsigned long               tmpVal;
    unsigned long               textureFormat0;
    unsigned long               textureFormat1;
    float                       fBuffer[16];
    unsigned long               *ftol = (unsigned long *)&fBuffer[0];
    unsigned long               moCompICW;
    unsigned long               moCompOCW;

    // Let D3D code know that we have touched NV
    pDriverData->TwoDRenderingOccurred = 1;

    // Initialize surface offsets
    dwSurfaceOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_NO_OPERATION | 0x40000);
    nvPushData(1, 0);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
    nvPushData(3, dwSurfaceOffset);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
    nvPushData(5, 0);
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(7, dwSurfaceOffset);

    nvPusherAdjust(8);

    // Align surface pitch and set surface format and pitch
    surfacePitch |= (surfacePitch << 16);

    if (pDriverData->bMCPictureStructure != PICTURE_STRUCTURE_FRAME)
        surfacePitch <<= 1; // Field surface is always referenced by hardware using double pitch

    tmpVal = (NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1 << 12) |
             (NV097_SET_SURFACE_FORMAT_TYPE_PITCH << 8) |
             (NV097_SET_SURFACE_FORMAT_ZETA_Z16 << 4) |
              NV097_SET_SURFACE_FORMAT_COLOR_LE_B8;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_FORMAT | 0x40000);
    nvPushData(1, tmpVal);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_PITCH | 0x40000);
    nvPushData(3, surfacePitch);

    nvPusherAdjust(4);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_MATRIX_ENABLE(0) | 0x100000);
    nvPushData(1, NV097_SET_TEXTURE_MATRIX_ENABLE_V_TRUE);
    nvPushData(2, NV097_SET_TEXTURE_MATRIX_ENABLE_V_TRUE);
    nvPushData(3, NV097_SET_TEXTURE_MATRIX_ENABLE_V_FALSE);
    nvPushData(4, NV097_SET_TEXTURE_MATRIX_ENABLE_V_FALSE);

    nvPusherAdjust(5);

    nvMoCompParams.dataFormat = DATA_FORMAT_CORRECTION;

    // Signed Y8
    textureFormat0 = (1 << 16) | // 1 MIPMAP level
                     (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SY8 << 8) |
                     (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) |
                     (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) |
                     (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
                      NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_B;

    // Unsigned Y8
    textureFormat1 = (1 << 16) | // 1 MIPMAP level
                     (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8 << 8) |
                     (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) |
                     (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) |
                     (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
                      NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(0) | 0x40000);
    nvPushData(1, textureFormat0);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(1) | 0x40000);
    nvPushData(3, textureFormat1);
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(2) | 0x40000);
    nvPushData(5, textureFormat1);
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(3) | 0x40000);
    nvPushData(7, textureFormat1);

    tmpVal = (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_Q_FALSE << 24) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_P_FALSE << 20) |
             (NV097_SET_TEXTURE_ADDRESS_P_CLAMP_TO_EDGE << 16) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_V_FALSE << 12) |
             (NV097_SET_TEXTURE_ADDRESS_V_CLAMP_TO_EDGE << 8) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_U_FALSE << 4) |
              NV097_SET_TEXTURE_ADDRESS_U_CLAMP_TO_EDGE;

    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_ADDRESS(0) | 0x40000);
    nvPushData(9, tmpVal);
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_ADDRESS(1) | 0x40000);
    nvPushData(11, tmpVal);
    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_ADDRESS(2) | 0x40000);
    nvPushData(13, tmpVal);
    nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_ADDRESS(3) | 0x40000);
    nvPushData(15, tmpVal);

    nvPusherAdjust(16);

    // Correction textures ALWAYS have 8 byte frame pitches or 16 byte field pitches
    if (pDriverData->bMCPictureStructure != PICTURE_STRUCTURE_FRAME)
        texturePitch0 = 16;
    else {
        texturePitch0 = 8;

        // Load composite and texture matrices assuming quarter pel scaling of texture coordinates
        if (pDriverData->bMCHorizontallyDownscale1080i)
            fBuffer[0]  = 0.1875;
        else
            fBuffer[0]  = 0.25;

                            fBuffer[1]  = 0.0;  fBuffer[2]  = 0.0; fBuffer[3]  = 0.0;
        fBuffer[4]  = 0.0;  fBuffer[5]  = 0.25; fBuffer[6]  = 0.0; fBuffer[7]  = 0.0;
        fBuffer[8]  = 0.0;  fBuffer[9]  = 0.0;  fBuffer[10] = 1.0; fBuffer[11] = 0.0;
        fBuffer[12] = 0.0;  fBuffer[13] = 0.0;  fBuffer[14] = 0.0; fBuffer[15] = 1.0;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_COMPOSITE_MATRIX(0) | 0x400000);
        nvPushData(1, ftol[0]);
        nvPushData(2, ftol[4]);
        nvPushData(3, ftol[8]);
        nvPushData(4, ftol[12]);
        nvPushData(5, ftol[1]);
        nvPushData(6, ftol[5]);
        nvPushData(7, ftol[9]);
        nvPushData(8, ftol[13]);
        nvPushData(9, ftol[2]);
        nvPushData(10, ftol[6]);
        nvPushData(11, ftol[10]);
        nvPushData(12, ftol[14]);
        nvPushData(13, ftol[3]);
        nvPushData(14, ftol[7]);
        nvPushData(15, ftol[11]);
        nvPushData(16, ftol[15]);

        nvPusherAdjust(17);

        if (pDriverData->bMCHorizontallyDownscale1080i)
            fBuffer[0]  = 0.25;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_TEXTURE_MATRIX0(0) | 0x400000);
        nvPushData(1, ftol[0]);
        nvPushData(2, ftol[4]);
        nvPushData(3, ftol[8]);
        nvPushData(4, ftol[12]);
        nvPushData(5, ftol[1]);
        nvPushData(6, ftol[5]);
        nvPushData(7, ftol[9]);
        nvPushData(8, ftol[13]);
        nvPushData(9, ftol[2]);
        nvPushData(10, ftol[6]);
        nvPushData(11, ftol[10]);
        nvPushData(12, ftol[14]);
        nvPushData(13, ftol[3]);
        nvPushData(14, ftol[7]);
        nvPushData(15, ftol[11]);
        nvPushData(16, ftol[15]);

        if (pDriverData->bMCHorizontallyDownscale1080i)
            fBuffer[0]  = 0.1875;

        nvPushData(17, dDrawSubchannelOffset(NV_DD_KELVIN) +
            NV097_SET_TEXTURE_MATRIX1(0) | 0x400000);
        nvPushData(18, ftol[0]);
        nvPushData(19, ftol[4]);
        nvPushData(20, ftol[8]);
        nvPushData(21, ftol[12]);
        nvPushData(22, ftol[1]);
        nvPushData(23, ftol[5]);
        nvPushData(24, ftol[9]);
        nvPushData(25, ftol[13]);
        nvPushData(26, ftol[2]);
        nvPushData(27, ftol[6]);
        nvPushData(28, ftol[10]);
        nvPushData(29, ftol[14]);
        nvPushData(30, ftol[3]);
        nvPushData(31, ftol[7]);
        nvPushData(32, ftol[11]);
        nvPushData(33, ftol[15]);

        nvPusherAdjust(34);
    }

    if (pDriverData->bMCPictureStructure != PICTURE_STRUCTURE_FRAME)
        texturePitch1 <<= 1; // Field textures are always referenced by hardware using double pitch

    pDriverData->dwMCTex0Control0 = (NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 18) | // MIN_LOD_CLAMP == 0.9
                                    (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
                                    (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    pDriverData->dwMCTex1Control0 = (NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 18) | // MIN_LOD_CLAMP == 0.9
                                    (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
                                    (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    tmpVal = (NV097_SET_TEXTURE_CONTROL0_ENABLE_FALSE << 30) |
             (15 << 18) | // MIN_LOD_CLAMP == 0.9
             (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
             (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
             (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
             (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
              NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(0) | 0x40000);
    nvPushData(1, pDriverData->dwMCTex0Control0);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(1) | 0x40000);
    nvPushData(3, pDriverData->dwMCTex1Control0);
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(2) | 0x40000);
    nvPushData(5, tmpVal);
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(3) | 0x40000);
    nvPushData(7, tmpVal);

    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
    nvPushData(9, texturePitch0 << 16);
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(11, texturePitch1 << 16);
    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(2) | 0x40000);
    nvPushData(13, texturePitch1 << 16);
    nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(3) | 0x40000);
    nvPushData(15, texturePitch1 << 16);

    tmpVal = (NV097_SET_TEXTURE_FILTER_BSIGNED_BIT_DISABLED << 31) |
             (NV097_SET_TEXTURE_FILTER_GSIGNED_BIT_DISABLED << 30) |
             (NV097_SET_TEXTURE_FILTER_RSIGNED_BIT_DISABLED << 29) |
             (NV097_SET_TEXTURE_FILTER_ASIGNED_BIT_DISABLED << 28) |
             (NV097_SET_TEXTURE_FILTER_MAG_BOX_LOD0 << 24) |
             (NV097_SET_TEXTURE_FILTER_MIN_BOX_LOD0 << 16) |
             (NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_QUINCUNX << 13);

    nvPushData(16, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(0) | 0x40000);
    nvPushData(17, tmpVal);
    nvPushData(18, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(1) | 0x40000);
    nvPushData(19, tmpVal);
    nvPushData(20, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(2) | 0x40000);
    nvPushData(21, tmpVal);
    nvPushData(22, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(3) | 0x40000);
    nvPushData(23, tmpVal);

    tmpVal = (4094 << 16) | 2046; // Must be even and <= 4094

    nvPushData(24, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(0) | 0x40000);
    nvPushData(25, (16 << 16) | 2044); // Must be even and <= 2046
    nvPushData(26, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(1) | 0x40000);
    nvPushData(27, tmpVal);
    nvPushData(28, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(2) | 0x40000);
    nvPushData(29, tmpVal);
    nvPushData(30, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(3) | 0x40000);
    nvPushData(31, tmpVal);

    nvPusherAdjust(32);

    // Disable fog
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG_ENABLE | 0x40000);
    nvPushData(1, NV097_SET_FOG_ENABLE_V_FALSE);

    nvPusherAdjust(2);

    // Now setup combiners

    // Default register combiner settings are:
    // A = primary color
    // B = one
    // C = zero
    // D = zero

    // Our correction moComp values
    // combiner0, RGB portion:   A = 1
    // combiner0, RGB portion:   B = (signed)texture0
    // combiner0, RGB portion:   C = 1
    // combiner0, RGB portion:   D = (unsigned)texture1

    moCompICW = (NV097_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                (NV097_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                (NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                (NV097_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NORMAL << 21) |
                (NV097_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                (NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                (NV097_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                (NV097_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                (NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1 << 8) |

                (NV097_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                (NV097_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                 NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    // Initialize combiner ICW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_ALPHA_ICW(0) | 0x100000);
    nvPushData(1, DEFAULT_KELVIN_ALPHA_ICW);
    nvPushData(2, DEFAULT_KELVIN_ALPHA_ICW);
    nvPushData(3, DEFAULT_KELVIN_ALPHA_ICW);
    nvPushData(4, DEFAULT_KELVIN_ALPHA_ICW);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_COLOR_ICW(0) | 0x100000);
    nvPushData(6, moCompICW);
    nvPushData(7, DEFAULT_KELVIN_COLOR_ICW);
    nvPushData(8, DEFAULT_KELVIN_COLOR_ICW);
    nvPushData(9, DEFAULT_KELVIN_COLOR_ICW);

    // Load combination factors
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_FACTOR0(0) | 0x40000);
    nvPushData(11, 0xFFFFFFFF); // 100%

    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_FACTOR1(0) | 0x40000);
    nvPushData(13, 0x0); // 0%

    nvPusherAdjust(14);

    // combiner0, RGB portion:   texture0 + texture1
    // spare0 = A * B + C * D
    moCompOCW = (NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_DISABLE << 19) |
                (NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_DISABLE << 18) |
                (NV097_SET_COMBINER_COLOR_OCW_OP_NOSHIFT << 15) |
                (NV097_SET_COMBINER_COLOR_OCW_MUX_ENABLE_FALSE << 14) |
                (NV097_SET_COMBINER_COLOR_OCW_AB_DOT_ENABLE_FALSE << 13) |
                (NV097_SET_COMBINER_COLOR_OCW_CD_DOT_ENABLE_FALSE << 12) |
                (NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_C << 8) |
                (NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_0 << 4) |
                 NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_0;

    // Initialize combiner OCW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_ALPHA_OCW(0) | 0x100000);
    nvPushData(1, DEFAULT_KELVIN_ALPHA_OCW);
    nvPushData(2, DEFAULT_KELVIN_ALPHA_OCW);
    nvPushData(3, DEFAULT_KELVIN_ALPHA_OCW);
    nvPushData(4, DEFAULT_KELVIN_ALPHA_OCW);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_COLOR_OCW(0) | 0x100000);
    nvPushData(6, moCompOCW);
    nvPushData(7, DEFAULT_KELVIN_COLOR_OCW);
    nvPushData(8, DEFAULT_KELVIN_COLOR_OCW);
    nvPushData(9, DEFAULT_KELVIN_COLOR_OCW);

    tmpVal = (NV097_SET_COMBINER_CONTROL_FACTOR1_SAME_FACTOR_ALL << 16) |
             (NV097_SET_COMBINER_CONTROL_FACTOR0_SAME_FACTOR_ALL << 12) |
             (NV097_SET_COMBINER_CONTROL_MUX_SELECT_MSB << 8) |
              NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_ONE;

    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_CONTROL | 0x40000);
    nvPushData(11, tmpVal);

    nvPusherAdjust(12);

    // Load final stages with default values
    // Initialize combiner final CW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_SPECULAR_FOG_CW0 | 0x40000);
    nvPushData(1, DEFAULT_KELVIN_FINAL_CW0);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_SPECULAR_FOG_CW1 | 0x40000);
    nvPushData(3, DEFAULT_KELVIN_FINAL_CW1);

    nvPusherAdjust(4);

    nvPusherStart(TRUE);

    return TRUE;

} /* nvInitKelvinForMoCompCorrection */



/*
 * nvInitKelvinForMoCompConversion
 *
 * Performs final kelvin object motion comp initialization for
 * the format conversion portion of the algorithm.
 *
 * For conversion, texture0 is used to convert the luma values to 0x00Y100Y0 and
 * texture1 is used to convert the chroma values to 0xV000U000 which are then added together
 * thus allowing the conversion to take place in one pass.  The textures are modulated
 * with constant colors to select which component comes from which texture.
 * The output texture is just passed through the register combiners to the final combiner.
 *
 * In this mode the register combiners are set to:
 *
 *      INPUT: A = constantColor0, B = texture0, C = constantColor1, D = texture1
 *      OUTPUT: spare0 = A * B + C * D
 *
 * And the final combiner is set to:
 *
 *      INPUT: C = spare0
 *      OUTPUT: C = spare0
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvInitKelvinForMoCompConversion(void)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl = pSurf_lcl->lpGbl;
    unsigned long               surfaceWidth = pSurf_gbl->wWidth;
    unsigned long               surfaceHeight = pSurf_gbl->wHeight;
    unsigned long               surfacePitch = pSurf_gbl->lPitch;
    unsigned long               texturePitch = pSurf_gbl->lPitch;
    unsigned long               tmpVal;
    unsigned long               moCompAlphaICW;
    unsigned long               moCompColorICW;
    unsigned long               moCompAlphaOCW;
    unsigned long               moCompColorOCW;
    float                       fBuffer[16];
    unsigned long               *ftol = (unsigned long *)&fBuffer[0];

    // Let D3D code know that we have touched NV
    pDriverData->TwoDRenderingOccurred = 1;

    if (pDriverData->bMCHorizontallyDownscale1080i) {
        // Restore default composite and texture matrices assuming quarter pel scaling of texture coordinates
        fBuffer[0]  = (float)0.1875; fBuffer[1]  = 0.0;  fBuffer[2]  = 0.0; fBuffer[3]  = 0.0;
        fBuffer[4]  = 0.0;           fBuffer[5]  = 0.25; fBuffer[6]  = 0.0; fBuffer[7]  = 0.0;
        fBuffer[8]  = 0.0;           fBuffer[9]  = 0.0;  fBuffer[10] = 1.0; fBuffer[11] = 0.0;
        fBuffer[12] = 0.0;           fBuffer[13] = 0.0;  fBuffer[14] = 0.0; fBuffer[15] = 1.0;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                      NV097_SET_COMPOSITE_MATRIX(0) | 0x400000);
        nvPushData(1, ftol[0]);
        nvPushData(2, ftol[4]);
        nvPushData(3, ftol[8]);
        nvPushData(4, ftol[12]);
        nvPushData(5, ftol[1]);
        nvPushData(6, ftol[5]);
        nvPushData(7, ftol[9]);
        nvPushData(8, ftol[13]);
        nvPushData(9, ftol[2]);
        nvPushData(10, ftol[6]);
        nvPushData(11, ftol[10]);
        nvPushData(12, ftol[14]);
        nvPushData(13, ftol[3]);
        nvPushData(14, ftol[7]);
        nvPushData(15, ftol[11]);
        nvPushData(16, ftol[15]);

        nvPusherAdjust(17);
    }

    // Surface offsets are initialized in the format conversion function

    // Align surface pitch and set surface format and pitch
    surfacePitch = ((surfaceWidth << 1) + 127) & ~127; // YUY2 destination is twice the surface width
    surfacePitch |= (surfacePitch << 16);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_NO_OPERATION | 0x40000);
    nvPushData(1, 0);

    tmpVal = (NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1 << 12) |
             (NV097_SET_SURFACE_FORMAT_TYPE_PITCH << 8) |
             (NV097_SET_SURFACE_FORMAT_ZETA_Z16 << 4) |
              NV097_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8;

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_FORMAT | 0x40000);
    nvPushData(3, tmpVal);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_PITCH | 0x40000);
    nvPushData(5, surfacePitch);

    nvPusherAdjust(6);

    // Just disable both texture matrices since these texture coordinates are unscaled
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_MATRIX_ENABLE(0) | 0x100000);
    nvPushData(1, NV097_SET_TEXTURE_MATRIX_ENABLE_V_FALSE);
    nvPushData(2, NV097_SET_TEXTURE_MATRIX_ENABLE_V_FALSE);
    nvPushData(3, NV097_SET_TEXTURE_MATRIX_ENABLE_V_FALSE);
    nvPushData(4, NV097_SET_TEXTURE_MATRIX_ENABLE_V_FALSE);

    nvPusherAdjust(5);

    nvMoCompParams.dataFormat = DATA_FORMAT_FOURCC_CONVERSION;

    tmpVal = (1 << 16) | // 1 MIPMAP level
             (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8B8 << 8) |
             (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) |
             (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) |
             (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
              NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(0) | 0x40000);
    nvPushData(1, tmpVal);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(1) | 0x40000);
    nvPushData(3, tmpVal);
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(2) | 0x40000);
    nvPushData(5, tmpVal);
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(3) | 0x40000);
    nvPushData(7, tmpVal);

    tmpVal = (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_Q_FALSE << 24) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_P_FALSE << 20) |
             (NV097_SET_TEXTURE_ADDRESS_P_CLAMP_TO_EDGE << 16) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_V_FALSE << 12) |
             (NV097_SET_TEXTURE_ADDRESS_V_CLAMP_TO_EDGE << 8) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_U_FALSE << 4) |
              NV097_SET_TEXTURE_ADDRESS_U_CLAMP_TO_EDGE;

    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_ADDRESS(0) | 0x40000);
    nvPushData(9, tmpVal);
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_ADDRESS(1) | 0x40000);
    nvPushData(11, tmpVal);
    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_ADDRESS(2) | 0x40000);
    nvPushData(13, tmpVal);
    nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_ADDRESS(3) | 0x40000);
    nvPushData(15, tmpVal);

    nvPusherAdjust(16);

    pDriverData->dwMCTex0Control0 = (NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 18) | // MIN_LOD_CLAMP == 0.9
                                    (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
                                    (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    pDriverData->dwMCTex1Control0 = (NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 18) | // MIN_LOD_CLAMP == 0.9
                                    (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
                                    (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    tmpVal = (NV097_SET_TEXTURE_CONTROL0_ENABLE_FALSE << 30) |
             (15 << 18) | // MIN_LOD_CLAMP == 0.9
             (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
             (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
             (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
             (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
              NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(0) | 0x40000);
    nvPushData(1, pDriverData->dwMCTex0Control0);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(1) | 0x40000);
    nvPushData(3, pDriverData->dwMCTex1Control0);
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(2) | 0x40000);
    nvPushData(5, tmpVal);
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(3) | 0x40000);
    nvPushData(7, tmpVal);

    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
    nvPushData(9, texturePitch << 16);
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(11, texturePitch << 16);
    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(2) | 0x40000);
    nvPushData(13, texturePitch << 16);
    nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(3) | 0x40000);
    nvPushData(15, texturePitch << 16);

    tmpVal = (NV097_SET_TEXTURE_FILTER_BSIGNED_BIT_DISABLED << 31) |
             (NV097_SET_TEXTURE_FILTER_GSIGNED_BIT_DISABLED << 30) |
             (NV097_SET_TEXTURE_FILTER_RSIGNED_BIT_DISABLED << 29) |
             (NV097_SET_TEXTURE_FILTER_ASIGNED_BIT_DISABLED << 28) |
             (NV097_SET_TEXTURE_FILTER_MAG_BOX_LOD0 << 24) |
             (NV097_SET_TEXTURE_FILTER_MIN_BOX_LOD0 << 16) |
             (NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_QUINCUNX << 13);

    nvPushData(16, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(0) | 0x40000);
    nvPushData(17, tmpVal);
    nvPushData(18, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(1) | 0x40000);
    nvPushData(19, tmpVal);
    nvPushData(20, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(2) | 0x40000);
    nvPushData(21, tmpVal);
    nvPushData(22, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(3) | 0x40000);
    nvPushData(23, tmpVal);

    tmpVal = (4094 << 16) | 2046; // Must be even and <= 4094

    nvPushData(24, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(0) | 0x40000);
    nvPushData(25, tmpVal);
    nvPushData(26, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(1) | 0x40000);
    nvPushData(27, tmpVal);
    nvPushData(28, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(2) | 0x40000);
    nvPushData(29, tmpVal);
    nvPushData(30, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(3) | 0x40000);
    nvPushData(31, tmpVal);

    nvPusherAdjust(32);

    // Disable fog
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG_ENABLE | 0x40000);
    nvPushData(1, NV097_SET_FOG_ENABLE_V_FALSE);

    nvPusherAdjust(2);

    // Now setup combiners

    // Default register combiner settings are:
    // A = primary color
    // B = one
    // C = zero
    // D = zero

    // Our format conversion moComp values
    // combiner0, Alpha portion:   A = 0
    // combiner0, Alpha portion:   B = 0
    // combiner0, Alpha portion:   C = constantColor1 (0xFF00FF00)
    // combiner0, Alpha portion:   D = texture1
    // combiner0, RGB portion:   A = constantColor0 (0x00FF00FF)
    // combiner0, RGB portion:   B = texture0
    // combiner0, RGB portion:   C = constantColor1 (0xFF00FF00)
    // combiner0, RGB portion:   D = texture1

    moCompAlphaICW = (NV097_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                     (NV097_SET_COMBINER_COLOR_ICW_A_ALPHA_TRUE << 28) |
                     (NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0 << 24) |

                     (NV097_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                     (NV097_SET_COMBINER_COLOR_ICW_B_ALPHA_TRUE << 20) |
                     (NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0 << 16) |

                     (NV097_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                     (NV097_SET_COMBINER_COLOR_ICW_C_ALPHA_TRUE << 12) |
                     (NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2 << 8) |

                     (NV097_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                     (NV097_SET_COMBINER_COLOR_ICW_D_ALPHA_TRUE << 4) |
                      NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    moCompColorICW = (NV097_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                     (NV097_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                     (NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                     (NV097_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                     (NV097_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                     (NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                     (NV097_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                     (NV097_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                     (NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2 << 8) |

                     (NV097_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                     (NV097_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                      NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    // Initialize combiner ICW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_ALPHA_ICW(0) | 0x100000);
    nvPushData(1, moCompAlphaICW);
    nvPushData(2, DEFAULT_KELVIN_ALPHA_ICW);
    nvPushData(3, DEFAULT_KELVIN_ALPHA_ICW);
    nvPushData(4, DEFAULT_KELVIN_ALPHA_ICW);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_COLOR_ICW(0) | 0x100000);
    nvPushData(6, moCompColorICW);
    nvPushData(7, DEFAULT_KELVIN_COLOR_ICW);
    nvPushData(8, DEFAULT_KELVIN_COLOR_ICW);
    nvPushData(9, DEFAULT_KELVIN_COLOR_ICW);

    // Load combination factors
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_FACTOR0(0) | 0x40000);
    nvPushData(11, 0x00FF00FF); // luma

    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_FACTOR1(0) | 0x40000);
    nvPushData(13, 0xFF00FF00); // chroma

    nvPusherAdjust(14);

    // combiner0, Alpha portion:    spare0 = A * B + C * D = texture1
    moCompAlphaOCW = (NV097_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT << 15) |
                     (NV097_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE << 14) |
                     (NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C << 8) |
                     (NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0 << 4) |
                      NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0;

    // combiner0, RGB portion:      spare0 = A * B + C * D = texture0 + texture1
    moCompColorOCW = (NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_DISABLE << 19) |
                     (NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_DISABLE << 18) |
                     (NV097_SET_COMBINER_COLOR_OCW_OP_NOSHIFT << 15) |
                     (NV097_SET_COMBINER_COLOR_OCW_MUX_ENABLE_FALSE << 14) |
                     (NV097_SET_COMBINER_COLOR_OCW_AB_DOT_ENABLE_FALSE << 13) |
                     (NV097_SET_COMBINER_COLOR_OCW_CD_DOT_ENABLE_FALSE << 12) |
                     (NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_C << 8) |
                     (NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_0 << 4) |
                      NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_0;

    // Initialize combiner OCW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_ALPHA_OCW(0) | 0x100000);
    nvPushData(1, moCompAlphaOCW);
    nvPushData(2, DEFAULT_KELVIN_ALPHA_OCW);
    nvPushData(3, DEFAULT_KELVIN_ALPHA_OCW);
    nvPushData(4, DEFAULT_KELVIN_ALPHA_OCW);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_COLOR_OCW(0) | 0x100000);
    nvPushData(6, moCompColorOCW);
    nvPushData(7, DEFAULT_KELVIN_COLOR_OCW);
    nvPushData(8, DEFAULT_KELVIN_COLOR_OCW);
    nvPushData(9, DEFAULT_KELVIN_COLOR_OCW);

    tmpVal = (NV097_SET_COMBINER_CONTROL_FACTOR1_SAME_FACTOR_ALL << 16) |
             (NV097_SET_COMBINER_CONTROL_FACTOR0_SAME_FACTOR_ALL << 12) |
             (NV097_SET_COMBINER_CONTROL_MUX_SELECT_MSB << 8) |
              NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_ONE;

    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_CONTROL | 0x40000);
    nvPushData(11, tmpVal);

    nvPusherAdjust(12);

    // Load final stages with default values
    // Initialize combiner final CW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_SPECULAR_FOG_CW0 | 0x40000);
    nvPushData(1, DEFAULT_KELVIN_FINAL_CW0);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_SPECULAR_FOG_CW1 | 0x40000);
    nvPushData(3, DEFAULT_KELVIN_FINAL_CW1);

    nvPusherAdjust(4);

    nvPusherStart(TRUE);

    return TRUE;

} /* nvInitKelvinForMoCompConversion */


/*
 * nvInitKelvinForMoCompTemporalFilter
 *
 * Performs final kelvin object motion comp initialization for
 * the intra frame field temporal filtering portion of the algorithm.
 *
 * For temporal filtering, texture0 is used to reference the top field and
 * texture1 is used to reference the bottom field which are then added together
 * thus allowing the filter to complete in one pass.  The textures are modulated
 * with constant colors to select the fraction of coverage which comes from which texture.
 * The output texture is just passed through the register combiners to the final combiner.
 *
 * In this mode the register combiners are set to:
 *
 *      INPUT: A = constantColor0, B = texture0, C = constantColor1, D = texture1
 *      OUTPUT: spare0 = A * B + C * D
 *
 * And the final combiner is set to:
 *
 *      INPUT: C = spare0
 *      OUTPUT: C = spare0
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvInitKelvinForMoCompTemporalFilter(void)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl = pSurf_lcl->lpGbl;
    unsigned long               surfaceWidth = pSurf_gbl->wWidth;
    unsigned long               surfaceHeight = pSurf_gbl->wHeight;
    unsigned long               surfacePitch;
    unsigned long               tmpVal;
    unsigned long               moCompAlphaICW;
    unsigned long               moCompColorICW;
    unsigned long               moCompAlphaOCW;
    unsigned long               moCompColorOCW;

    // Let D3D code know that we have touched NV
    pDriverData->TwoDRenderingOccurred = 1;

    // Surface offsets are initialized in the temporal filter function

    // Align surface pitch and set surface format and pitch
    surfacePitch = (pSurf_gbl->wWidth + 3) & ~3;
    surfacePitch = ((surfacePitch << 1) + 127) & ~127; // YUY2 destination is twice the surface width
    surfacePitch |= (surfacePitch << 16);
    surfacePitch <<= 1;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_NO_OPERATION | 0x40000);
    nvPushData(1, 0);

    tmpVal = (NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1 << 12) |
             (NV097_SET_SURFACE_FORMAT_TYPE_PITCH << 8) |
             (NV097_SET_SURFACE_FORMAT_ZETA_Z16 << 4) |
              NV097_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8;

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_FORMAT | 0x40000);
    nvPushData(3, tmpVal);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_SURFACE_PITCH | 0x40000);
    nvPushData(5, surfacePitch);

    nvPusherAdjust(6);

    // Enable both texture matrices since these texture coordinates are in quarter pel
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_MATRIX_ENABLE(0) | 0x100000);
    nvPushData(1, NV097_SET_TEXTURE_MATRIX_ENABLE_V_TRUE);
    nvPushData(2, NV097_SET_TEXTURE_MATRIX_ENABLE_V_TRUE);
    nvPushData(3, NV097_SET_TEXTURE_MATRIX_ENABLE_V_FALSE);
    nvPushData(4, NV097_SET_TEXTURE_MATRIX_ENABLE_V_FALSE);

    nvPusherAdjust(5);

    nvMoCompParams.dataFormat = DATA_FORMAT_TEMPORAL_FILTER;

    tmpVal = (1 << 16) | // 1 MIPMAP level
             (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8R8G8B8 << 8) |
             (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) |
             (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) |
             (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
              NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(0) | 0x40000);
    nvPushData(1, tmpVal);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(1) | 0x40000);
    nvPushData(3, tmpVal);
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(2) | 0x40000);
    nvPushData(5, tmpVal);
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_FORMAT(3) | 0x40000);
    nvPushData(7, tmpVal);

    tmpVal = (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_Q_FALSE << 24) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_P_FALSE << 20) |
             (NV097_SET_TEXTURE_ADDRESS_P_CLAMP_TO_EDGE << 16) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_V_FALSE << 12) |
             (NV097_SET_TEXTURE_ADDRESS_V_CLAMP_TO_EDGE << 8) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_U_FALSE << 4) |
              NV097_SET_TEXTURE_ADDRESS_U_CLAMP_TO_EDGE;

    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_ADDRESS(0) | 0x40000);
    nvPushData(9, tmpVal);
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_ADDRESS(1) | 0x40000);
    nvPushData(11, tmpVal);
    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_ADDRESS(2) | 0x40000);
    nvPushData(13, tmpVal);
    nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_ADDRESS(3) | 0x40000);
    nvPushData(15, tmpVal);

    nvPusherAdjust(16);

    pDriverData->dwMCTex0Control0 = (NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 18) | // MIN_LOD_CLAMP == 0.9
                                    (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
                                    (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    pDriverData->dwMCTex1Control0 = (NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 18) | // MIN_LOD_CLAMP == 0.9
                                    (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
                                    (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    tmpVal = (NV097_SET_TEXTURE_CONTROL0_ENABLE_FALSE << 30) |
             (15 << 18) | // MIN_LOD_CLAMP == 0.9
             (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
             (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
             (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
             (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
              NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(0) | 0x40000);
    nvPushData(1, pDriverData->dwMCTex0Control0);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(1) | 0x40000);
    nvPushData(3, pDriverData->dwMCTex1Control0);
    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(2) | 0x40000);
    nvPushData(5, tmpVal);
    nvPushData(6, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_TEXTURE_CONTROL0(3) | 0x40000);
    nvPushData(7, tmpVal);

    nvPushData(8, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
    nvPushData(9, surfacePitch << 16);
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
    nvPushData(11, surfacePitch << 16);
    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(2) | 0x40000);
    nvPushData(13, surfacePitch << 16);
    nvPushData(14, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_CONTROL1(3) | 0x40000);
    nvPushData(15, surfacePitch << 16);

    tmpVal = (NV097_SET_TEXTURE_FILTER_BSIGNED_BIT_DISABLED << 31) |
             (NV097_SET_TEXTURE_FILTER_GSIGNED_BIT_DISABLED << 30) |
             (NV097_SET_TEXTURE_FILTER_RSIGNED_BIT_DISABLED << 29) |
             (NV097_SET_TEXTURE_FILTER_ASIGNED_BIT_DISABLED << 28) |
             (NV097_SET_TEXTURE_FILTER_MAG_TENT_LOD0 << 24) |
             (NV097_SET_TEXTURE_FILTER_MIN_TENT_LOD0 << 16) |
             (NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_QUINCUNX << 13);

    nvPushData(16, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(0) | 0x40000);
    nvPushData(17, tmpVal);
    nvPushData(18, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(1) | 0x40000);
    nvPushData(19, tmpVal);
    nvPushData(20, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(2) | 0x40000);
    nvPushData(21, tmpVal);
    nvPushData(22, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_FILTER(3) | 0x40000);
    nvPushData(23, tmpVal);

    tmpVal = (4094 << 16) | 2046; // Must be even and <= 4094

    nvPushData(24, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(0) | 0x40000);
    nvPushData(25, tmpVal);
    nvPushData(26, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(1) | 0x40000);
    nvPushData(27, tmpVal);
    nvPushData(28, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(2) | 0x40000);
    nvPushData(29, tmpVal);
    nvPushData(30, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_TEXTURE_IMAGE_RECT(3) | 0x40000);
    nvPushData(31, tmpVal);

    nvPusherAdjust(32);

    // Disable fog
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG_ENABLE | 0x40000);
    nvPushData(1, NV097_SET_FOG_ENABLE_V_FALSE);

    nvPusherAdjust(2);

    // Now setup combiners

    // Default register combiner settings are:
    // A = primary color
    // B = one
    // C = zero
    // D = zero

    // Our temporal filter moComp values
    // combiner0, RGB portion:   A = constantColor0
    // combiner0, RGB portion:   B = texture0
    // combiner0, RGB portion:   C = constantColor1
    // combiner0, RGB portion:   D = texture1

    moCompAlphaICW = (NV097_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                     (NV097_SET_COMBINER_ALPHA_ICW_A_ALPHA_TRUE << 28) |
                     (NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1 << 24) |

                     (NV097_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                     (NV097_SET_COMBINER_ALPHA_ICW_B_ALPHA_TRUE << 20) |
                     (NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_8 << 16) |

                     (NV097_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                     (NV097_SET_COMBINER_ALPHA_ICW_C_ALPHA_TRUE << 12) |
                     (NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_2 << 8) |

                     (NV097_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                     (NV097_SET_COMBINER_ALPHA_ICW_D_ALPHA_TRUE << 4) |
                      NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_9;

    moCompColorICW = (NV097_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                     (NV097_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                     (NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                     (NV097_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                     (NV097_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                     (NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                     (NV097_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                     (NV097_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                     (NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2 << 8) |

                     (NV097_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                     (NV097_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                      NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    // Initialize combiner ICW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_ALPHA_ICW(0) | 0x100000);
    nvPushData(1, moCompAlphaICW);
    nvPushData(2, DEFAULT_KELVIN_ALPHA_ICW);
    nvPushData(3, DEFAULT_KELVIN_ALPHA_ICW);
    nvPushData(4, DEFAULT_KELVIN_ALPHA_ICW);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_COLOR_ICW(0) | 0x100000);
    nvPushData(6, moCompColorICW);
    nvPushData(7, DEFAULT_KELVIN_COLOR_ICW);
    nvPushData(8, DEFAULT_KELVIN_COLOR_ICW);
    nvPushData(9, DEFAULT_KELVIN_COLOR_ICW);

    // Load combination factors
    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_FACTOR0(0) | 0x40000);
    nvPushData(11, 0x80808080); // % of top field

    nvPushData(12, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_FACTOR1(0) | 0x40000);
    nvPushData(13, 0x80808080); // % of bottom field

    nvPusherAdjust(14);

    // combiner0, RGB portion:      spare0 = A * B + C * D = texture0 + texture1
    moCompAlphaOCW = (NV097_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT << 15) |
                     (NV097_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE << 14) |
                     (NV097_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C << 8) |
                     (NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0 << 4) |
                      NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0;

    moCompColorOCW = (NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_DISABLE << 19) |
                     (NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_DISABLE << 18) |
                     (NV097_SET_COMBINER_COLOR_OCW_OP_NOSHIFT << 15) |
                     (NV097_SET_COMBINER_COLOR_OCW_MUX_ENABLE_FALSE << 14) |
                     (NV097_SET_COMBINER_COLOR_OCW_AB_DOT_ENABLE_FALSE << 13) |
                     (NV097_SET_COMBINER_COLOR_OCW_CD_DOT_ENABLE_FALSE << 12) |
                     (NV097_SET_COMBINER_COLOR_OCW_SUM_DST_REG_C << 8) |
                     (NV097_SET_COMBINER_COLOR_OCW_AB_DST_REG_0 << 4) |
                      NV097_SET_COMBINER_COLOR_OCW_CD_DST_REG_0;

    // Initialize combiner OCW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_ALPHA_OCW(0) | 0x100000);
    nvPushData(1, moCompAlphaOCW);
    nvPushData(2, DEFAULT_KELVIN_ALPHA_OCW);
    nvPushData(3, DEFAULT_KELVIN_ALPHA_OCW);
    nvPushData(4, DEFAULT_KELVIN_ALPHA_OCW);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_COLOR_OCW(0) | 0x100000);
    nvPushData(6, moCompColorOCW);
    nvPushData(7, DEFAULT_KELVIN_COLOR_OCW);
    nvPushData(8, DEFAULT_KELVIN_COLOR_OCW);
    nvPushData(9, DEFAULT_KELVIN_COLOR_OCW);

    tmpVal = (NV097_SET_COMBINER_CONTROL_FACTOR1_SAME_FACTOR_ALL << 16) |
             (NV097_SET_COMBINER_CONTROL_FACTOR0_SAME_FACTOR_ALL << 12) |
             (NV097_SET_COMBINER_CONTROL_MUX_SELECT_MSB << 8) |
              NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_ONE;

    nvPushData(10, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_CONTROL | 0x40000);
    nvPushData(11, tmpVal);

    nvPusherAdjust(12);

    // Load final stages with default values
    // Initialize combiner final CW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_SPECULAR_FOG_CW0 | 0x40000);
    nvPushData(1, DEFAULT_KELVIN_FINAL_CW0);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_COMBINER_SPECULAR_FOG_CW1 | 0x40000);
    nvPushData(3, DEFAULT_KELVIN_FINAL_CW1);

    nvPusherAdjust(4);

    nvPusherStart(TRUE);

    return TRUE;

} /* nvInitKelvinForMoCompTemporalFilter */



#endif  // NVARCH >= 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\MoInit.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*==========================================================================;
 *
 *  Copyright (C) 1999 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       MoInit.cpp
 *  Content:    Windows98 DirectDraw 32 bit driver
 *
 ***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

NVMOCOMPPARAMS nvMoCompParams;

/*
 * nvInitCelsiusForMoComp
 *
 * Performs basic motion comp initialization of the celcius class object
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvInitCelsiusForMoComp(void)
{
    LPDDRAWI_DDRAWSURFACE_LCL   dstx = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   dst;
    unsigned long               surfaceWidth;
    unsigned long               surfaceHeight;
    unsigned long               surfacePitch;
    unsigned long               tmpVal;
    float                       fBuffer[16];
    unsigned long               *ftol = (unsigned long *)&fBuffer[0];
    float                       xTrans, yTrans, zTrans;

    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        if (!nvEnable32(NULL)) {
            return FALSE;
        }
    }

	if(dstx == NULL)		//It happnes for WinDVD
		return FALSE;

    dst = dstx->lpGbl;
    surfaceWidth = dst->wWidth;
    surfaceHeight = dst->wHeight;
    surfacePitch = dst->lPitch;

    pDriverData->dwMostRecentHWUser = MODULE_ID_DDRAW;

    // Let D3D code know that we have touched NV
    pDriverData->TwoDRenderingOccurred = 1;

    // Clear current IDCT context Dma
    pDriverData->dwMCCurrentCelsiusIDCTCtxDma = 0;

    // Reset current vertex mode
    nvMoCompParams.vertexMode = 0;

    // Reset current data format
    nvMoCompParams.dataFormat = 0;

    // Reset the celsius context Dmas to use the default video context Dma
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_CONTEXT_DMA_A | 0x40000);
    nvPushData(1, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_CONTEXT_DMA_B | 0x40000);
    nvPushData(3, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_CONTEXT_DMA_VERTEX | 0x40000);
    nvPushData(5, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_CONTEXT_DMA_STATE | 0x40000);
    nvPushData(7, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    nvPushData(8, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_CONTEXT_DMA_COLOR | 0x40000);
    nvPushData(9, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    nvPushData(10, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_CONTEXT_DMA_ZETA | 0x40000);
    nvPushData(11, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    nvPusherAdjust(12);

    // Set up one window clip rectangle to be the rendered area
    // All the other rectangles are deactivated
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_WINDOW_CLIP_HORIZONTAL(0) | 0x200000);
    nvPushData(1, ((2047 << 16) | (-2048 & 0xfff)));
    nvPushData(2, 0);
    nvPushData(3, 0);
    nvPushData(4, 0);
    nvPushData(5, 0);
    nvPushData(6, 0);
    nvPushData(7, 0);
    nvPushData(8, 0);

    nvPushData(9, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_WINDOW_CLIP_VERTICAL(0) | 0x200000);
    nvPushData(10, ((2047 << 16) | (-2048 & 0xfff)));
    nvPushData(11, 0);
    nvPushData(12, 0);
    nvPushData(13, 0);
    nvPushData(14, 0);
    nvPushData(15, 0);
    nvPushData(16, 0);
    nvPushData(17, 0);

    nvPushData(18, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_WINDOW_CLIP_TYPE | 0x40000);
    nvPushData(19, NV056_SET_WINDOW_CLIP_TYPE_V_INCLUSIVE);

    nvPushData(20, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_SURFACE_CLIP_HORIZONTAL | 0x40000);
    // pitch << 1
    nvPushData(21, ((surfacePitch << 17) | 0));

    nvPushData(22, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_SURFACE_CLIP_VERTICAL | 0x40000);
    // height << 1 which is at least enough for luma height + chroma height
    nvPushData(23, ((surfaceHeight << 17) | 0));

    nvPusherAdjust(24);

    // Enable transforms
    tmpVal = (NV056_SET_TLMODE_W_DIVIDE_1_ENABLE << 2) |
             (NV056_SET_TLMODE_W_DIVIDE_0_ENABLE << 1) |
              NV056_SET_TLMODE_PASSTHROUGH_FALSE;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TLMODE | 0x40000);
    nvPushData(1, tmpVal);

    nvPusherAdjust(2);

    // Set Control0 defaults
    tmpVal = (NV056_SET_CONTROL0_PREMULTIPLIEDALPHA_FALSE << 24) |
             (NV056_SET_CONTROL0_TEXTUREPERSPECTIVE_FALSE << 20) |
             (NV056_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE << 16) |
             (NV056_SET_CONTROL0_Z_FORMAT_FIXED << 12) |
             (NV056_SET_CONTROL0_WBUFFER_SELECT_0 << 8) |
             (NV056_SET_CONTROL0_STENCIL_WRITE_ENABLE_TRUE);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_CONTROL0 | 0x40000);
    nvPushData(1, tmpVal);

    nvPusherAdjust(2);

    // Load ModelView matrix and inverse ModelView matrix with identity
    fBuffer[0]  = 1.0; fBuffer[1]  = 0.0; fBuffer[2]  = 0.0; fBuffer[3]  = 0.0;
    fBuffer[4]  = 0.0; fBuffer[5]  = 1.0; fBuffer[6]  = 0.0; fBuffer[7]  = 0.0;
    fBuffer[8]  = 0.0; fBuffer[9]  = 0.0; fBuffer[10] = 1.0; fBuffer[11] = 0.0;
    fBuffer[12] = 0.0; fBuffer[13] = 0.0; fBuffer[14] = 0.0; fBuffer[15] = 1.0;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_MODEL_VIEW_MATRIX0(0) | 0x400000);
    nvPushData(1, ftol[0]);
    nvPushData(2, ftol[4]);
    nvPushData(3, ftol[8]);
    nvPushData(4, ftol[12]);
    nvPushData(5, ftol[1]);
    nvPushData(6, ftol[5]);
    nvPushData(7, ftol[9]);
    nvPushData(8, ftol[13]);
    nvPushData(9, ftol[2]);
    nvPushData(10, ftol[6]);
    nvPushData(11, ftol[10]);
    nvPushData(12, ftol[14]);
    nvPushData(13, ftol[3]);
    nvPushData(14, ftol[7]);
    nvPushData(15, ftol[11]);
    nvPushData(16, ftol[15]);

    nvPushData(17, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_INVERSE_MODEL_VIEW_MATRIX0(0) | 0x400000);
    nvPushData(18, ftol[0]);
    nvPushData(19, ftol[4]);
    nvPushData(20, ftol[8]);
    nvPushData(21, ftol[12]);
    nvPushData(22, ftol[1]);
    nvPushData(23, ftol[5]);
    nvPushData(24, ftol[9]);
    nvPushData(25, ftol[13]);
    nvPushData(26, ftol[2]);
    nvPushData(27, ftol[6]);
    nvPushData(28, ftol[10]);
    nvPushData(29, ftol[14]);
    nvPushData(30, ftol[3]);
    nvPushData(31, ftol[7]);
    nvPushData(32, ftol[11]);
    nvPushData(33, ftol[15]);

    nvPusherAdjust(34);

    // Align surface pitch and set surface format and pitch
    surfacePitch |= (surfacePitch << 16);
    surfacePitch <<= 1; // Surface is always referenced by hardware in field mode

    tmpVal = (NV056_SET_SURFACE_FORMAT_TYPE_PITCH << 8) |
              NV056_SET_SURFACE_FORMAT_COLOR_LE_B8;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_FORMAT | 0x40000);
    nvPushData(1, tmpVal);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_PITCH | 0x40000);
    nvPushData(3, surfacePitch);

    nvPusherAdjust(4);

    // Set up viewport
//    xTrans = (float)(-2048 - (1.0 / 32.0)); // hardware epsilon
    // Changed to allow destination X coordinate range of -2046 - 2046 for optimal 1080i performance
    xTrans = (float)(-2 - (1.0 / 32.0)); // hardware epsilon
    yTrans = (float)(-2048 - (1.0 / 32.0));
    zTrans = 0.0;

    // Load composite matrix assuming quarter pel scaling of surface coordinates
    if (pDriverData->bMCHorizontallyDownscale1080i)
        fBuffer[0]  = 0.1875; // quarter pel xScale
    else
        fBuffer[0]  = 0.25; // quarter pel xScale
    fBuffer[1]  = 0.0;
    fBuffer[2]  = 0.0;
    fBuffer[3]  = 0.0;
    fBuffer[4]  = 0.0;
    fBuffer[5]  = 0.25; // quarter pel yScale
    fBuffer[6]  = 0.0;
    fBuffer[7]  = 0.0;
    fBuffer[8]  = 0.0;
    fBuffer[9]  = 0.0;
    fBuffer[10] = 1.0;
    fBuffer[11] = 0.0;
    fBuffer[12] = 0.0;
    fBuffer[13] = 0.0;
    fBuffer[14] = 0.0;
    fBuffer[15] = 1.0;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMPOSITE_MATRIX(0) | 0x400000);
    nvPushData(1, ftol[0]);
    nvPushData(2, ftol[4]);
    nvPushData(3, ftol[8]);
    nvPushData(4, ftol[12]);
    nvPushData(5, ftol[1]);
    nvPushData(6, ftol[5]);
    nvPushData(7, ftol[9]);
    nvPushData(8, ftol[13]);
    nvPushData(9, ftol[2]);
    nvPushData(10, ftol[6]);
    nvPushData(11, ftol[10]);
    nvPushData(12, ftol[14]);
    nvPushData(13, ftol[3]);
    nvPushData(14, ftol[7]);
    nvPushData(15, ftol[11]);
    nvPushData(16, ftol[15]);

    nvPusherAdjust(17);

    // Set viewport offset separately
    fBuffer[0] = xTrans;
    fBuffer[1] = yTrans;
    fBuffer[2] = zTrans;
    fBuffer[3] = 0.0;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_VIEWPORT_OFFSET(0) | 0x100000);
    nvPushData(1, ftol[0]);
    nvPushData(2, ftol[1]);
    nvPushData(3, ftol[2]);
    nvPushData(4, ftol[3]);

    nvPusherAdjust(5);

    // Set front and back clipping
    fBuffer[0] = 0.0;
    fBuffer[1] = 1.0;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_CLIP_MIN | 0x80000);
    nvPushData(1, ftol[0]);
    nvPushData(2, ftol[1]);

    nvPusherAdjust(3);

    // Disable almost everything

    // Disable alpha test
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_ALPHA_TEST_ENABLE | 0x40000);
    nvPushData(1, NV056_SET_ALPHA_TEST_ENABLE_V_FALSE);

    // Disable blending
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BLEND_ENABLE | 0x40000);
    nvPushData(3, NV056_SET_BLEND_ENABLE_V_FALSE);

    // Disable culling
    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_CULL_FACE_ENABLE | 0x40000);
    nvPushData(5, NV056_SET_CULL_FACE_ENABLE_V_FALSE);

    // Disable depth test
    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_DEPTH_TEST_ENABLE | 0x40000);
    nvPushData(7, NV056_SET_DEPTH_TEST_ENABLE_V_FALSE);

    // Disable dither
    nvPushData(8, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_DITHER_ENABLE | 0x40000);
    nvPushData(9, NV056_SET_DITHER_ENABLE_V_FALSE);

    // Disable lighting
    nvPushData(10, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_LIGHTING_ENABLE | 0x40000);
    nvPushData(11, NV056_SET_LIGHTING_ENABLE_V_FALSE);

    // Disable point parameters computation
    nvPushData(12, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_POINT_PARAMS_ENABLE | 0x40000);
    nvPushData(13, NV056_SET_POINT_PARAMS_ENABLE_V_FALSE);

    // Disable point smoothing
    nvPushData(14, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_POINT_SMOOTH_ENABLE | 0x40000);
    nvPushData(15, NV056_SET_LINE_SMOOTH_ENABLE_V_FALSE);

    // Disable line smoothing
    nvPushData(16, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_LINE_SMOOTH_ENABLE | 0x40000);
    nvPushData(17, NV056_SET_LINE_SMOOTH_ENABLE_V_FALSE);

    // Disable polygon smoothing
    nvPushData(18, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_POLY_SMOOTH_ENABLE | 0x40000);
    nvPushData(19, NV056_SET_POLY_SMOOTH_ENABLE_V_FALSE);

    // Disable skinning
    nvPushData(20, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_SKIN_ENABLE | 0x40000);
    nvPushData(21, NV056_SET_SKIN_ENABLE_V_FALSE);

    // Disable stencil test
    nvPushData(22, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_STENCIL_TEST_ENABLE | 0x40000);
    nvPushData(23, NV056_SET_STENCIL_TEST_ENABLE_V_FALSE);

    // Disable polygon offset point
    nvPushData(24, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_POLY_OFFSET_POINT_ENABLE | 0x40000);
    nvPushData(25, NV056_SET_POLY_OFFSET_POINT_ENABLE_V_FALSE);

    // Disable polygon offset line
    nvPushData(26, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_POLY_OFFSET_LINE_ENABLE | 0x40000);
    nvPushData(27, NV056_SET_POLY_OFFSET_LINE_ENABLE_V_FALSE);

    // Disable polygon offset fill
    nvPushData(28, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_POLY_OFFSET_FILL_ENABLE | 0x40000);
    nvPushData(29, NV056_SET_POLY_OFFSET_FILL_ENABLE_V_FALSE);

    nvPusherAdjust(30);

    // Set light control
    tmpVal = (NV056_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_FALSE << 1) |
              NV056_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_FALSE;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_LIGHT_CONTROL | 0x40000);
    nvPushData(1, tmpVal);

    // Disable color material
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COLOR_MATERIAL | 0x40000);
    nvPushData(3, NV056_SET_COLOR_MATERIAL_V_DISABLED);

    // Set material emission
    fBuffer[0] = 0.0;

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_MATERIAL_EMISSION(0) | 0xC0000);
    nvPushData(5, ftol[0]);
    nvPushData(6, ftol[0]);
    nvPushData(7, ftol[0]);

    // Disable specular
    nvPushData(8, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SPECULAR_ENABLE | 0x40000);
    nvPushData(9, NV056_SET_SPECULAR_ENABLE_V_FALSE);

    // Disable all lights
    nvPushData(10, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_LIGHT_ENABLE_MASK | 0x40000);
    nvPushData(11, 0);

    nvPusherAdjust(12);

    // Disable texgen modes for now (OpenGL default is EYE_LINEAR)

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXGEN_S(0) | 0x40000);
    nvPushData(1, NV056_SET_TEXGEN_S_V_DISABLE);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXGEN_T(0) | 0x40000);
    nvPushData(3, NV056_SET_TEXGEN_T_V_DISABLE);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXGEN_R(0) | 0x40000);
    nvPushData(5, NV056_SET_TEXGEN_R_V_DISABLE);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXGEN_Q(0) | 0x40000);
    nvPushData(7, NV056_SET_TEXGEN_Q_V_DISABLE);

    nvPushData(8, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXGEN_S(1) | 0x40000);
    nvPushData(9, NV056_SET_TEXGEN_S_V_DISABLE);

    nvPushData(10, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXGEN_T(1) | 0x40000);
    nvPushData(11, NV056_SET_TEXGEN_T_V_DISABLE);

    nvPushData(12, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXGEN_R(1) | 0x40000);
    nvPushData(13, NV056_SET_TEXGEN_R_V_DISABLE);

    nvPushData(14, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXGEN_Q(1) | 0x40000);
    nvPushData(15, NV056_SET_TEXGEN_Q_V_DISABLE);

    nvPusherAdjust(16);

    // Set default texgen planes
    fBuffer[0] = 0.0;
    fBuffer[1] = 1.0;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXGEN_SPLANE0(0) | 0x100000);
    nvPushData(1, ftol[1]);
    nvPushData(2, ftol[0]);
    nvPushData(3, ftol[0]);
    nvPushData(4, ftol[0]);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXGEN_TPLANE0(0) | 0x100000);
    nvPushData(6, ftol[0]);
    nvPushData(7, ftol[1]);
    nvPushData(8, ftol[0]);
    nvPushData(9, ftol[0]);

    nvPushData(10, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXGEN_RPLANE0(0) | 0x100000);
    nvPushData(11, ftol[0]);
    nvPushData(12, ftol[0]);
    nvPushData(13, ftol[0]);
    nvPushData(14, ftol[0]);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXGEN_QPLANE0(0) | 0x100000);
    nvPushData(16, ftol[0]);
    nvPushData(17, ftol[0]);
    nvPushData(18, ftol[0]);
    nvPushData(19, ftol[0]);

    nvPushData(20, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXGEN_SPLANE1(0) | 0x100000);
    nvPushData(21, ftol[1]);
    nvPushData(22, ftol[0]);
    nvPushData(23, ftol[0]);
    nvPushData(24, ftol[0]);

    nvPushData(25, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXGEN_TPLANE1(0) | 0x100000);
    nvPushData(26, ftol[0]);
    nvPushData(27, ftol[1]);
    nvPushData(28, ftol[0]);
    nvPushData(29, ftol[0]);

    nvPushData(30, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXGEN_RPLANE1(0) | 0x100000);
    nvPushData(31, ftol[0]);
    nvPushData(32, ftol[0]);
    nvPushData(33, ftol[0]);
    nvPushData(34, ftol[0]);

    nvPushData(35, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXGEN_QPLANE1(0) | 0x100000);
    nvPushData(36, ftol[0]);
    nvPushData(37, ftol[0]);
    nvPushData(38, ftol[0]);
    nvPushData(39, ftol[0]);

    nvPusherAdjust(40);

    // Set default fog mode
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG_MODE | 0x40000);
    nvPushData(1, NV056_SET_FOG_MODE_FOG_MODE_LINEAR);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG_GEN_MODE | 0x40000);
    nvPushData(3, NV056_SET_FOG_GEN_MODE_FOG_GEN_MODE_USE_INPUT);

    // Disable fog
    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG_ENABLE | 0x40000);
    nvPushData(5, NV056_SET_FOG_ENABLE_V_FALSE);

    // Set default fog parameters
    fBuffer[0] = 1.0;                           // K0
    fBuffer[1] = 1.0;                           // K1
    fBuffer[2] = 0.0;                           // K2

    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG_PARAMS(0) | 0xC0000);
    nvPushData(7, ftol[0]);
    nvPushData(8, ftol[1]);
    nvPushData(9, ftol[2]);

    // Set default fog color
    nvPushData(10, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_FOG_COLOR | 0x40000);
    nvPushData(11, 0xFFFFFFFF);

    nvPusherAdjust(12);

    // Set default alpha function
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_ALPHA_FUNC | 0x40000);
    nvPushData(1, NV056_SET_ALPHA_FUNC_V_ALWAYS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_ALPHA_REF | 0x40000);
    nvPushData(3, 0);

    // Set default blend equation
    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BLEND_EQUATION | 0x40000);
    nvPushData(5, NV056_SET_BLEND_EQUATION_V_FUNC_ADD);

    // Set default blend color
    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BLEND_COLOR | 0x40000);
    nvPushData(7, 0);

    // Set default blend func source factor
    nvPushData(8, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BLEND_FUNC_SFACTOR | 0x40000);
    nvPushData(9, NV056_SET_BLEND_FUNC_SFACTOR_V_ONE);

    // Set default blend func destination factor
    nvPushData(10, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BLEND_FUNC_DFACTOR | 0x40000);
    nvPushData(11, NV056_SET_BLEND_FUNC_DFACTOR_V_ZERO);

    nvPusherAdjust(12);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FRONT_FACE | 0x40000);
    nvPushData(1, NV056_SET_FRONT_FACE_V_CCW);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_CULL_FACE | 0x40000);
    nvPushData(3, NV056_SET_CULL_FACE_V_BACK);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SHADE_MODE | 0x40000);
    nvPushData(5, NV056_SET_SHADE_MODE_V_SMOOTH);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FRONT_POLYGON_MODE | 0x40000);
    nvPushData(7, NV056_SET_FRONT_POLYGON_MODE_V_FILL);

    nvPushData(8, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BACK_POLYGON_MODE | 0x40000);
    nvPushData(9, NV056_SET_BACK_POLYGON_MODE_V_FILL);

    fBuffer[0] = 0.0;

    nvPushData(10, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_POLYGON_OFFSET_SCALE_FACTOR | 0x40000);
    nvPushData(11, ftol[0]);

    nvPushData(12, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_POLYGON_OFFSET_BIAS | 0x40000);
    nvPushData(13, ftol[0]);

    nvPushData(14, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_EDGE_FLAG | 0x40000);
    nvPushData(15, 1);

    nvPusherAdjust(16);

    // Initialize some vertex attributes
    fBuffer[0] = 0.0;
    fBuffer[1] = 1.0;

    // Set color for MODULATE blend mode
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_DIFFUSE_COLOR4F(0) | 0x100000);
    nvPushData(1, ftol[1]);
    nvPushData(2, ftol[1]);
    nvPushData(3, ftol[1]);
    nvPushData(4, ftol[1]);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SPECULAR_COLOR3F(0) | 0xC0000);
    nvPushData(6, ftol[0]);
    nvPushData(7, ftol[0]);
    nvPushData(8, ftol[0]);

    nvPushData(9, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXCOORD0_4F(0) | 0x100000);
    nvPushData(10, ftol[0]);
    nvPushData(11, ftol[0]);
    nvPushData(12, ftol[0]);
    nvPushData(13, ftol[1]);

    nvPushData(14, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXCOORD1_4F(0) | 0x100000);
    nvPushData(15, ftol[0]);
    nvPushData(16, ftol[0]);
    nvPushData(17, ftol[0]);
    nvPushData(18, ftol[1]);

    nvPushData(19, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_NORMAL3F(0) | 0xC0000);
    nvPushData(20, ftol[0]);
    nvPushData(21, ftol[0]);
    nvPushData(22, ftol[1]);

    nvPushData(23, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_FOG1F | 0x40000);
    nvPushData(24, ftol[0]);

    nvPushData(25, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_WEIGHT1F | 0x40000);
    nvPushData(26, ftol[1]);

    nvPusherAdjust(27);

    // Set depth function
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_DEPTH_FUNC | 0x40000);
    nvPushData(1, NV056_SET_DEPTH_FUNC_V_ALWAYS);

    // Set color mask
    tmpVal = (NV056_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_TRUE << 24) |
             (NV056_SET_COLOR_MASK_RED_WRITE_ENABLE_TRUE << 16) |
             (NV056_SET_COLOR_MASK_GREEN_WRITE_ENABLE_TRUE << 8) |
              NV056_SET_COLOR_MASK_BLUE_WRITE_ENABLE_TRUE;

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COLOR_MASK | 0x40000);
    nvPushData(3, tmpVal);

    // Set depth mask
    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_DEPTH_MASK | 0x40000);
    nvPushData(5, NV056_SET_DEPTH_MASK_V_FALSE);

    nvPusherAdjust(6);

    // Initialize stencil state (test already disabled above)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_STENCIL_FUNC | 0x40000);
    nvPushData(1, NV056_SET_STENCIL_FUNC_V_ALWAYS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_STENCIL_FUNC_REF | 0x40000);
    nvPushData(3, 0);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_STENCIL_FUNC_MASK | 0x40000);
    nvPushData(5, 0x000000FF);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_STENCIL_OP_FAIL | 0x40000);
    nvPushData(7, NV056_SET_STENCIL_OP_FAIL_V_KEEP);

    nvPushData(8, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_STENCIL_OP_ZFAIL | 0x40000);
    nvPushData(9, NV056_SET_STENCIL_OP_ZFAIL_V_KEEP);

    nvPushData(10, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_STENCIL_OP_ZPASS | 0x40000);
    nvPushData(11, NV056_SET_STENCIL_OP_ZPASS_V_KEEP);

    nvPushData(12, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_STENCIL_MASK | 0x40000);
    nvPushData(13, 0x000000FF);

    nvPusherAdjust(14);

    // This is set once and forgotten. It puts the class in OGL flat shade mode.
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FLAT_SHADE_OP | 0x40000);
    nvPushData(1, NV056_SET_FLAT_SHADE_OP_V_LAST_VTX);

    nvPusherAdjust(2);

    // Load texture matrices assuming quarter pel scaling of texture coordinates
    if (pDriverData->bMCHorizontallyDownscale1080i)
        fBuffer[0]  = 0.1875;
    else
        fBuffer[0]  = 0.25;

                        fBuffer[1]  = 0.0;  fBuffer[2]  = 0.0; fBuffer[3]  = 0.0;
    fBuffer[4]  = 0.0;  fBuffer[5]  = 0.25; fBuffer[6]  = 0.0; fBuffer[7]  = 0.0;
    fBuffer[8]  = 0.0;  fBuffer[9]  = 0.0;  fBuffer[10] = 1.0; fBuffer[11] = 0.0;
    fBuffer[12] = 0.0;  fBuffer[13] = 0.0;  fBuffer[14] = 0.0; fBuffer[15] = 1.0;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_MATRIX0(0) | 0x400000);
    nvPushData(1, ftol[0]);
    nvPushData(2, ftol[4]);
    nvPushData(3, ftol[8]);
    nvPushData(4, ftol[12]);
    nvPushData(5, ftol[1]);
    nvPushData(6, ftol[5]);
    nvPushData(7, ftol[9]);
    nvPushData(8, ftol[13]);
    nvPushData(9, ftol[2]);
    nvPushData(10, ftol[6]);
    nvPushData(11, ftol[10]);
    nvPushData(12, ftol[14]);
    nvPushData(13, ftol[3]);
    nvPushData(14, ftol[7]);
    nvPushData(15, ftol[11]);
    nvPushData(16, ftol[15]);

    nvPushData(17, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXTURE_MATRIX1(0) | 0x400000);
    nvPushData(18, ftol[0]);
    nvPushData(19, ftol[4]);
    nvPushData(20, ftol[8]);
    nvPushData(21, ftol[12]);
    nvPushData(22, ftol[1]);
    nvPushData(23, ftol[5]);
    nvPushData(24, ftol[9]);
    nvPushData(25, ftol[13]);
    nvPushData(26, ftol[2]);
    nvPushData(27, ftol[6]);
    nvPushData(28, ftol[10]);
    nvPushData(29, ftol[14]);
    nvPushData(30, ftol[3]);
    nvPushData(31, ftol[7]);
    nvPushData(32, ftol[11]);
    nvPushData(33, ftol[15]);

    nvPusherAdjust(34);

    nvPusherStart(TRUE);

    return TRUE;

} /* nvInitCelsiusForMoComp */



/*
 * nvInitCelsiusForMoCompPrediction
 *
 * Performs final celsius object motion comp initialization for
 * the prediction portion of the algorithm.
 *
 * For prediction, texture 0 is used for forward prediction, texture 1
 * is used for backward prediction.  These textures are just passed through
 * the register combiners to the final combiner.  The final combiner is
 * configured so that the fog coordinate is used to control the contribution
 * of each texture in the final output.  A fog value of 0.0 selects forward
 * prediction, 0.5 selects bidirectional prediction, and 1.0 selects backward
 * prediction.
 *
 * In this mode the register combiners are set to:
 *
 *      INPUT: A = (1.0)constantColor0, B = texture0, C = (1.0)constantColor0, D = texture1
 *      OUTPUT: spare0 = A * B, spare1 = C * D
 *
 * And the final combiner is set to:
 *
 *      INPUT: A.rgb = Fog.a, B = spare1, C = spare0, D = 0
 *      OUTPUT: B * A + C * (1.0 - A)
 *
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvInitCelsiusForMoCompPrediction(void)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl = pSurf_lcl->lpGbl;
    unsigned long               surfaceWidth = pSurf_gbl->wWidth;
    unsigned long               surfaceHeight = pSurf_gbl->wHeight;
    unsigned long               surfacePitch = pSurf_gbl->lPitch;
    unsigned long               dwSurfaceOffset;
    unsigned long               tmpVal;
    float                       fBuffer[16];
    unsigned long               *ftol = (unsigned long *)&fBuffer[0];
    unsigned long               moCompICW;
    unsigned long               moCompOCW;
    unsigned long               moCompFinalCW0;
    unsigned long               moCompFinalCW1;

    // Let D3D code know that we have touched NV
    pDriverData->TwoDRenderingOccurred = 1;

    // Initialize surface offsets
    dwSurfaceOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_NO_OPERATION | 0x40000);
    nvPushData(1, 0);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
    nvPushData(3, dwSurfaceOffset);

    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCForwardSurface;
    pSurf_gbl = pSurf_lcl->lpGbl;

    dwSurfaceOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_OFFSET(0) | 0x40000);
    nvPushData(5, dwSurfaceOffset);

    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface;
    pSurf_gbl = pSurf_lcl->lpGbl;

    dwSurfaceOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
    nvPushData(7, dwSurfaceOffset);

    nvPusherAdjust(8);

    // Align surface pitch and set surface format and pitch
    surfacePitch |= (surfacePitch << 16);
    surfacePitch <<= 1; // Surface is always referenced by hardware in field mode

    tmpVal = (NV056_SET_SURFACE_FORMAT_TYPE_PITCH << 8) |
              NV056_SET_SURFACE_FORMAT_COLOR_LE_B8;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_FORMAT | 0x40000);
    nvPushData(1, tmpVal);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_PITCH | 0x40000);
    nvPushData(3, surfacePitch);

    nvPusherAdjust(4);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_MATRIX0_ENABLE | 0x40000);
    nvPushData(1, NV056_SET_TEXTURE_MATRIX0_ENABLE_V_TRUE);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_MATRIX1_ENABLE | 0x40000);
    nvPushData(3, NV056_SET_TEXTURE_MATRIX1_ENABLE_V_TRUE);

    nvMoCompParams.dataFormat = DATA_FORMAT_LUMA;

    tmpVal = (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) |
             (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) |
             (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) |
             (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) |
             (1 << 12) | // 1 MIPMAP level
             (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_Y8 << 7) |
             (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) |
             (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) |
             (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
              NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A;

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_FORMAT(0) | 0x80000);
    nvPushData(5, tmpVal);
    nvPushData(6, tmpVal);

    pDriverData->dwMCTex0Control0 = (NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 8) | // huh ?  default MAX_LOD_CLAMP from OGL (no clamping)
                                    (NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    pDriverData->dwMCTex1Control0 = (NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 8) | // huh ?  default MAX_LOD_CLAMP from OGL (no clamping)
                                    (NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    nvPushData(7, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL0(0) | 0x80000);
    nvPushData(8, pDriverData->dwMCTex0Control0);
    nvPushData(9, pDriverData->dwMCTex1Control0);

    nvPushData(10, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
    nvPushData(11, surfacePitch << 16);
    nvPushData(12, surfacePitch << 16);

    nvPushData(13, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXTURE_CONTROL2(0) | 0x80000);
    nvPushData(14, 0);
    nvPushData(15, 0);

//    tmpVal = (2044 << 16) | (surfaceHeight << 1); // Must be even and <= 2046
    tmpVal = (2044 << 16) | 2046; // Must be even and <= 2046

    nvPushData(16, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXTURE_IMAGE_RECT(0) | 0x80000);
    nvPushData(17, tmpVal);
    nvPushData(18, tmpVal);

    tmpVal = (NV056_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR << 28) |
             (NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR << 24);

    nvPushData(19, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXTURE_FILTER(0) | 0x80000);
    nvPushData(20, tmpVal);
    nvPushData(21, tmpVal);

    nvPusherAdjust(22);

    if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) {

        // Load composite and texture matrices assuming quarter pel horizontal scaling and eigth pel vertical
        // scaling of texture coordinates
        if (pDriverData->bMCHorizontallyDownscale1080i)
            fBuffer[0]  = 0.1875;
        else
            fBuffer[0]  = 0.25;

                            fBuffer[1]  = 0.0;   fBuffer[2]  = 0.0; fBuffer[3]  = 0.0;
        fBuffer[4]  = 0.0;  fBuffer[5]  = 0.125; fBuffer[6]  = 0.0; fBuffer[7]  = 0.0;
        fBuffer[8]  = 0.0;  fBuffer[9]  = 0.0;   fBuffer[10] = 1.0; fBuffer[11] = 0.0;
        fBuffer[12] = 0.0;  fBuffer[13] = 0.0;   fBuffer[14] = 0.0; fBuffer[15] = 1.0;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_COMPOSITE_MATRIX(0) | 0x400000);
        nvPushData(1, ftol[0]);
        nvPushData(2, ftol[4]);
        nvPushData(3, ftol[8]);
        nvPushData(4, ftol[12]);
        nvPushData(5, ftol[1]);
        nvPushData(6, ftol[5]);
        nvPushData(7, ftol[9]);
        nvPushData(8, ftol[13]);
        nvPushData(9, ftol[2]);
        nvPushData(10, ftol[6]);
        nvPushData(11, ftol[10]);
        nvPushData(12, ftol[14]);
        nvPushData(13, ftol[3]);
        nvPushData(14, ftol[7]);
        nvPushData(15, ftol[11]);
        nvPushData(16, ftol[15]);

        nvPusherAdjust(17);

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_MATRIX0(0) | 0x400000);
        nvPushData(1, ftol[0]);
        nvPushData(2, ftol[4]);
        nvPushData(3, ftol[8]);
        nvPushData(4, ftol[12]);
        nvPushData(5, ftol[1]);
        nvPushData(6, ftol[5]);
        nvPushData(7, ftol[9]);
        nvPushData(8, ftol[13]);
        nvPushData(9, ftol[2]);
        nvPushData(10, ftol[6]);
        nvPushData(11, ftol[10]);
        nvPushData(12, ftol[14]);
        nvPushData(13, ftol[3]);
        nvPushData(14, ftol[7]);
        nvPushData(15, ftol[11]);
        nvPushData(16, ftol[15]);

        nvPushData(17, dDrawSubchannelOffset(NV_DD_CELSIUS) +
            NV056_SET_TEXTURE_MATRIX1(0) | 0x400000);
        nvPushData(18, ftol[0]);
        nvPushData(19, ftol[4]);
        nvPushData(20, ftol[8]);
        nvPushData(21, ftol[12]);
        nvPushData(22, ftol[1]);
        nvPushData(23, ftol[5]);
        nvPushData(24, ftol[9]);
        nvPushData(25, ftol[13]);
        nvPushData(26, ftol[2]);
        nvPushData(27, ftol[6]);
        nvPushData(28, ftol[10]);
        nvPushData(29, ftol[14]);
        nvPushData(30, ftol[3]);
        nvPushData(31, ftol[7]);
        nvPushData(32, ftol[11]);
        nvPushData(33, ftol[15]);

        nvPusherAdjust(34);
    }

    // Enable fog (mocomp fog modes set during default mocomp initialization)
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG_ENABLE | 0x40000);
    nvPushData(1, NV056_SET_FOG_ENABLE_V_TRUE);

    nvPusherAdjust(2);

    // Now setup combiners

    // Default register combiner settings are:
    // A = primary color
    // B = one
    // C = zero
    // D = zero

    // Our prediction moComp values
    // combiner0, RGB portion:   A = 1
    // combiner0, RGB portion:   B = texture0
    // combiner0, RGB portion:   C = 1
    // combiner0, RGB portion:   D = texture1

    moCompICW = (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_INVERT << 29) |
                (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0 << 24) |

                (NV056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_INVERT << 13) |
                (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0 << 8) |

                (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                 NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    // Initialize combiner ICW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_ALPHA_ICW(0) | 0x80000);
    nvPushData(1, DEFAULT_ALPHA_ICW);
    nvPushData(2, DEFAULT_ALPHA_ICW);

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_COLOR_ICW(0) | 0x80000);
    nvPushData(4, moCompICW);
    nvPushData(5, DEFAULT_COLOR_ICW);

    // Load combination factors
    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINE_FACTOR(0) | 0x80000);
    nvPushData(7, 0xFFFFFFFF); // 100%
    nvPushData(8, 0xFFFFFFFF); // 100%

    nvPusherAdjust(9);

    // combiner0, RGB portion:   spare0 = texture0, spare1 = texture1
    moCompOCW = (NV056_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT << 15) |
                (NV056_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_FALSE << 14) |
                (NV056_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_FALSE << 13) |
                (NV056_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_FALSE << 12) |
                (NV056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_0 << 8) |
                (NV056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_C << 4) |
                 NV056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_D;

    // Initialize combiner OCW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_ALPHA_OCW(0) | 0x80000);
    nvPushData(1, DEFAULT_ALPHA_OCW);
    nvPushData(2, DEFAULT_ALPHA_OCW);

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER0_COLOR_OCW | 0x40000);
    nvPushData(4, moCompOCW);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER1_COLOR_OCW | 0x40000);
    nvPushData(6, DEFAULT_C1_COLOR_OCW);

    nvPusherAdjust(7);

    // Reconfigure fog unit to interpolate
    // fog factor in alpha
    // fog = 0.0: all texture0
    // fog = 0.5: equal parts of texture0 and texture1
    // fog = 1.0: all texture1

    moCompFinalCW0 = (NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_FALSE << 29) |
                     (NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_TRUE << 28) |
                     (NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_3 << 24) |   // fog

                     (NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_FALSE << 21) |
                     (NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_FALSE << 20) |
                     (NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_D << 16) |   // spare1

                     (NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_FALSE << 13) |
                     (NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_FALSE << 12) |
                     (NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_C << 8) |    // spare0

                     (NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_FALSE << 5) |
                     (NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_FALSE << 4) |
                      NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_0;           // 0

    moCompFinalCW1 = (NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_FALSE << 29) |
                     (NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_FALSE << 28) |
                     (NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0 << 24) |   // 0

                     (NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_FALSE << 21) |
                     (NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_FALSE << 20) |
                     (NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0 << 16) |   // 0

                     (NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_TRUE << 13) |
                     (NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_TRUE << 12) |
                     (NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_0 << 8) |    // 0xFF

                     (NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_TRUE << 7) |
                     (NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_FALSE << 6) |
                      NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_FALSE;

    // Initialize combiner final CW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_SPECULAR_FOG_CW0 | 0x40000);
    nvPushData(1, moCompFinalCW0);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_SPECULAR_FOG_CW1 | 0x40000);
    nvPushData(3, moCompFinalCW1);

    nvPusherAdjust(4);

    nvPusherStart(TRUE);

    return TRUE;

} /* nvInitCelsiusForMoCompPrediction */


/*
 * nvInitCelsiusForMoCompCorrection
 *
 * Performs final celcius object motion comp initialization for
 * the correction portion of the algorithm.
 *
 * For correction, texture 0 is used for the error terms, texture 1
 * is mapped over the source/destination.  The error terms are signed
 * and the textures are unsigned so the register combiners need to be
 * setup appropriately.
 *
 * In this mode the register combiners are set to:
 *
 *      INPUT: A = (1.0)constantColor0, B = (signed)texture0, C = (1.0)constantColor0, D = (unsigned)texture1
 *      OUTPUT: spare0 = A * B + C * D
 *
 * And the final combiner is set to:
 *
 *      INPUT: C = spare0
 *      OUTPUT: C = spare0
 *
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvInitCelsiusForMoCompCorrection(void)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl = pSurf_lcl->lpGbl;
    unsigned long               surfaceWidth = pSurf_gbl->wWidth;
    unsigned long               surfaceHeight = pSurf_gbl->wHeight;
    unsigned long               surfacePitch = pSurf_gbl->lPitch;
    unsigned long               dwSurfaceOffset;
    unsigned long               texturePitch0;
    unsigned long               texturePitch1 = pSurf_gbl->lPitch;
    unsigned long               tmpVal;
    unsigned long               textureFormat0;
    unsigned long               textureFormat1;
    float                       fBuffer[16];
    unsigned long               *ftol = (unsigned long *)&fBuffer[0];
    unsigned long               moCompICW;
    unsigned long               moCompOCW;

    // Let D3D code know that we have touched NV
    pDriverData->TwoDRenderingOccurred = 1;

    // Initialize surface offsets
    dwSurfaceOffset = VIDMEM_OFFSET(pSurf_gbl->fpVidMem);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_NO_OPERATION | 0x40000);
    nvPushData(1, 0);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
    nvPushData(3, dwSurfaceOffset);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
    nvPushData(5, 0);
    nvPushData(6, dwSurfaceOffset);

    nvPusherAdjust(7);

    // Align surface pitch and set surface format and pitch
    surfacePitch |= (surfacePitch << 16);

    if (pDriverData->bMCPictureStructure != PICTURE_STRUCTURE_FRAME)
        surfacePitch <<= 1; // Field surface is always referenced by hardware using double pitch

    tmpVal = (NV056_SET_SURFACE_FORMAT_TYPE_PITCH << 8) |
              NV056_SET_SURFACE_FORMAT_COLOR_LE_B8;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_FORMAT | 0x40000);
    nvPushData(1, tmpVal);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_PITCH | 0x40000);
    nvPushData(3, surfacePitch);

    nvPusherAdjust(4);

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_MATRIX0_ENABLE | 0x40000);
    nvPushData(1, NV056_SET_TEXTURE_MATRIX0_ENABLE_V_TRUE);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_MATRIX1_ENABLE | 0x40000);
    nvPushData(3, NV056_SET_TEXTURE_MATRIX1_ENABLE_V_TRUE);

    nvMoCompParams.dataFormat = DATA_FORMAT_CORRECTION;

    // Signed Y8
    textureFormat0 = (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) |
                     (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) |
                     (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) |
                     (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) |
                     (1 << 12) | // 1 MIPMAP level
                     (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SY8 << 7) |
                     (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) |
                     (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) |
                     (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
                      NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_B;
    // Unsigned Y8
    textureFormat1 = (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) |
                     (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) |
                     (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) |
                     (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) |
                     (1 << 12) | // 1 MIPMAP level
                     (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_Y8 << 7) |
                     (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) |
                     (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) |
                     (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
                      NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A;

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_FORMAT(0) | 0x80000);
    nvPushData(5, textureFormat0);
    nvPushData(6, textureFormat1);

    pDriverData->dwMCTex0Control0 = (NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 8) | // huh ?  default MAX_LOD_CLAMP from OGL (no clamping)
                                    (NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    pDriverData->dwMCTex1Control0 = (NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 8) | // huh ?  default MAX_LOD_CLAMP from OGL (no clamping)
                                    (NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    nvPushData(7, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL0(0) | 0x80000);
    nvPushData(8, pDriverData->dwMCTex0Control0);
    nvPushData(9, pDriverData->dwMCTex1Control0);

    nvPusherAdjust(10);

    // Correction textures ALWAYS have 8 byte frame pitches or 16 byte field pitches
    if (pDriverData->bMCPictureStructure != PICTURE_STRUCTURE_FRAME)
        texturePitch0 = 16;
    else {
        texturePitch0 = 8;

        // Load composite and texture matrices assuming quarter pel scaling of texture coordinates
        if (pDriverData->bMCHorizontallyDownscale1080i)
            fBuffer[0]  = 0.1875;
        else
            fBuffer[0]  = 0.25;

                            fBuffer[1]  = 0.0;  fBuffer[2]  = 0.0; fBuffer[3]  = 0.0;
        fBuffer[4]  = 0.0;  fBuffer[5]  = 0.25; fBuffer[6]  = 0.0; fBuffer[7]  = 0.0;
        fBuffer[8]  = 0.0;  fBuffer[9]  = 0.0;  fBuffer[10] = 1.0; fBuffer[11] = 0.0;
        fBuffer[12] = 0.0;  fBuffer[13] = 0.0;  fBuffer[14] = 0.0; fBuffer[15] = 1.0;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_COMPOSITE_MATRIX(0) | 0x400000);
        nvPushData(1, ftol[0]);
        nvPushData(2, ftol[4]);
        nvPushData(3, ftol[8]);
        nvPushData(4, ftol[12]);
        nvPushData(5, ftol[1]);
        nvPushData(6, ftol[5]);
        nvPushData(7, ftol[9]);
        nvPushData(8, ftol[13]);
        nvPushData(9, ftol[2]);
        nvPushData(10, ftol[6]);
        nvPushData(11, ftol[10]);
        nvPushData(12, ftol[14]);
        nvPushData(13, ftol[3]);
        nvPushData(14, ftol[7]);
        nvPushData(15, ftol[11]);
        nvPushData(16, ftol[15]);

        nvPusherAdjust(17);

        if (pDriverData->bMCHorizontallyDownscale1080i)
            fBuffer[0]  = 0.25;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_MATRIX0(0) | 0x400000);
        nvPushData(1, ftol[0]);
        nvPushData(2, ftol[4]);
        nvPushData(3, ftol[8]);
        nvPushData(4, ftol[12]);
        nvPushData(5, ftol[1]);
        nvPushData(6, ftol[5]);
        nvPushData(7, ftol[9]);
        nvPushData(8, ftol[13]);
        nvPushData(9, ftol[2]);
        nvPushData(10, ftol[6]);
        nvPushData(11, ftol[10]);
        nvPushData(12, ftol[14]);
        nvPushData(13, ftol[3]);
        nvPushData(14, ftol[7]);
        nvPushData(15, ftol[11]);
        nvPushData(16, ftol[15]);

        if (pDriverData->bMCHorizontallyDownscale1080i)
            fBuffer[0]  = 0.1875;

        nvPushData(17, dDrawSubchannelOffset(NV_DD_CELSIUS) +
            NV056_SET_TEXTURE_MATRIX1(0) | 0x400000);
        nvPushData(18, ftol[0]);
        nvPushData(19, ftol[4]);
        nvPushData(20, ftol[8]);
        nvPushData(21, ftol[12]);
        nvPushData(22, ftol[1]);
        nvPushData(23, ftol[5]);
        nvPushData(24, ftol[9]);
        nvPushData(25, ftol[13]);
        nvPushData(26, ftol[2]);
        nvPushData(27, ftol[6]);
        nvPushData(28, ftol[10]);
        nvPushData(29, ftol[14]);
        nvPushData(30, ftol[3]);
        nvPushData(31, ftol[7]);
        nvPushData(32, ftol[11]);
        nvPushData(33, ftol[15]);

        nvPusherAdjust(34);
    }

    if (pDriverData->bMCPictureStructure != PICTURE_STRUCTURE_FRAME)
        texturePitch1 <<= 1; // Field textures are always referenced by hardware using double pitch

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
    nvPushData(1, texturePitch0 << 16);
    nvPushData(2, texturePitch1 << 16);

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL2(0) | 0x80000);
    nvPushData(4, 0);
    nvPushData(5, 0);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_IMAGE_RECT(0) | 0x80000);
    nvPushData(7, (16 << 16) | 2044); // Must be even and <= 2046
//    nvPushData(8, ((2044 << 16) | (surfaceHeight << 1))); // Must be even and <= 2046
    nvPushData(8, ((2044 << 16) | 2046)); // Must be even and <= 2046

    tmpVal = (NV056_SET_TEXTURE_FILTER_TEXTUREMAG_NEAREST << 28) |
             (NV056_SET_TEXTURE_FILTER_TEXTUREMIN_NEAREST << 24);

    nvPushData(9, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_FILTER(0) | 0x80000);
    nvPushData(10, tmpVal);
    nvPushData(11, tmpVal);

    nvPusherAdjust(12);

    // Disable fog
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG_ENABLE | 0x40000);
    nvPushData(1, NV056_SET_FOG_ENABLE_V_FALSE);

    nvPusherAdjust(2);

    // Now setup combiners

    // Default register combiner settings are:
    // A = primary color
    // B = one
    // C = zero
    // D = zero

    // Our correction moComp values
    // combiner0, RGB portion:   A = 1
    // combiner0, RGB portion:   B = (signed)texture0
    // combiner0, RGB portion:   C = 1
    // combiner0, RGB portion:   D = (unsigned)texture1

    moCompICW = (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                (NV056_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NORMAL << 21) |
                (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1 << 8) |

                (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                 NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    // Initialize combiner ICW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_ALPHA_ICW(0) | 0x80000);
    nvPushData(1, DEFAULT_ALPHA_ICW);
    nvPushData(2, DEFAULT_ALPHA_ICW);

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_COLOR_ICW(0) | 0x80000);
    nvPushData(4, moCompICW);
    nvPushData(5, DEFAULT_COLOR_ICW);

    // Load combination factors
    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINE_FACTOR(0) | 0x80000);
    nvPushData(7, 0xFFFFFFFF); // 100%
    nvPushData(8, 0); // 0%

    nvPusherAdjust(9);

    // combiner0, RGB portion:   texture0 + texture1
    // spare0 = A * B + C * D
    moCompOCW = (NV056_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT << 15) |
                (NV056_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_FALSE << 14) |
                (NV056_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_FALSE << 13) |
                (NV056_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_FALSE << 12) |
                (NV056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_C << 8) |
                (NV056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_0 << 4) |
                 NV056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_0;

    // Initialize combiner OCW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_ALPHA_OCW(0) | 0x80000);
    nvPushData(1, DEFAULT_ALPHA_OCW);
    nvPushData(2, DEFAULT_ALPHA_OCW);

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER0_COLOR_OCW | 0x40000);
    nvPushData(4, moCompOCW);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER1_COLOR_OCW | 0x40000);
    nvPushData(6, DEFAULT_C1_COLOR_OCW);

    nvPusherAdjust(7);

    // Load final stages with default values
    // Initialize combiner final CW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_SPECULAR_FOG_CW0 | 0x40000);
    nvPushData(1, DEFAULT_FINAL_CW0);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_SPECULAR_FOG_CW1 | 0x40000);
    nvPushData(3, DEFAULT_FINAL_CW1);

    nvPusherAdjust(4);

    nvPusherStart(TRUE);

    return TRUE;

} /* nvInitCelsiusForMoCompCorrection */

#if 0 // Until NV17

/*
 * nvInitCelsiusForMoCompNV12LumaSubpictureCompositing
 *
 * Performs final celsius object motion comp initialization for
 * A8V8U8Y8 subpicture compositing with an NV12 surface luma portion resulting in an
 * output surface also in NV12 format.
 *
 * For luma subpicture compositing, texture0 is the subpicture in A8V8U8Y8 format from
 * which we extract the A8 and Y8 components and alpha blend with the Y8 components of
 * the NV12 source surface in texture1 to produce alpha blended Y8 components in NV12
 * format in the destination surface.
 * The output texture is just passed through the register combiners to the final combiner.
 *
 * In this mode the register combiners are set to:
 *
 *      INPUT: A = texture0 alpha, B = texture0 color B(Y), C = !texture0 alpha, D = texture1 color B(Y)
 *      OUTPUT: spare0 = A * B + C * D
 *
 * And the final combiner is set to:
 *
 *      INPUT: C = spare0
 *      OUTPUT: C = spare0
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvInitCelsiusForMoCompNV12LumaSubpictureCompositing(void)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl = pSurf_lcl->lpGbl;
    unsigned long               surfaceWidth = pSurf_gbl->wWidth;
    unsigned long               surfaceHeight = pSurf_gbl->wHeight;
    unsigned long               surfacePitch = pSurf_gbl->lPitch;
    unsigned long               texturePitch = pSurf_gbl->lPitch;
    unsigned long               tmpVal;
    unsigned long               moCompColorICW;
    unsigned long               moCompAlphaOCW;
    unsigned long               moCompColorOCW;
    float                       fBuffer[16];
    unsigned long               *ftol = (unsigned long *)&fBuffer[0];

    // Let D3D code know that we have touched NV
    pDriverData->TwoDRenderingOccurred = 1;

    // Surface offsets are initialized in the subpicture compositing function

    // Align surface pitch and set surface format and pitch
    surfacePitch |= (surfacePitch << 16);

    tmpVal = (NV056_SET_SURFACE_FORMAT_TYPE_PITCH << 8) |
              NV056_SET_SURFACE_FORMAT_COLOR_LE_B8;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_NO_OPERATION | 0x40000);
    nvPushData(1, 0);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_FORMAT | 0x40000);
    nvPushData(3, tmpVal);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_PITCH | 0x40000);
    nvPushData(5, surfacePitch);

    nvPusherAdjust(6);

    // Just disable both texture matrices since these texture coordinates are unscaled

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_MATRIX0_ENABLE | 0x40000);
    nvPushData(1, NV056_SET_TEXTURE_MATRIX0_ENABLE_V_FALSE);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_MATRIX1_ENABLE | 0x40000);
    nvPushData(3, NV056_SET_TEXTURE_MATRIX1_ENABLE_V_FALSE);

    nvPusherAdjust(4);

    nvMoCompParams.dataFormat = DATA_FORMAT_SUBPICTURE_LUMA_BLEND;

    tmpVal = (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) |
             (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) |
             (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) |
             (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) |
             (1 << 12) | // 1 MIPMAP level
             (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A8R8G8B8 << 7) |
             (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) |
             (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) |
             (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
              NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_FORMAT(0) | 0x80000);
    nvPushData(1, tmpVal);
    
    tmpVal = (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) |
             (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) |
             (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) |
             (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) |
             (1 << 12) | // 1 MIPMAP level
             (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_Y8 << 7) |
             (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) |
             (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) |
             (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
              NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A;

    nvPushData(2, tmpVal);

    pDriverData->dwMCTex0Control0 = (NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 8) | // huh ?  default MAX_LOD_CLAMP from OGL (no clamping)
                                    (NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    pDriverData->dwMCTex1Control0 = (NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 8) | // huh ?  default MAX_LOD_CLAMP from OGL (no clamping)
                                    (NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL0(0) | 0x80000);
    nvPushData(4, pDriverData->dwMCTex0Control0);
    nvPushData(5, pDriverData->dwMCTex1Control0);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
    nvPushData(7, texturePitch << 16);
    nvPushData(8, texturePitch << 16);

    nvPushData(9, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL2(0) | 0x80000);
    nvPushData(10, 0);
    nvPushData(11, 0);

//    tmpVal = (2044 << 16) | (surfaceHeight << 1); // Must be even and <= 2046
    tmpVal = (2044 << 16) | 2046; // Must be even and <= 2046

    nvPushData(12, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXTURE_IMAGE_RECT(0) | 0x80000);
    nvPushData(13, tmpVal);
    nvPushData(14, tmpVal);

    tmpVal = (NV056_SET_TEXTURE_FILTER_TEXTUREMAG_NEAREST << 28) |
             (NV056_SET_TEXTURE_FILTER_TEXTUREMIN_NEAREST << 24);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXTURE_FILTER(0) | 0x80000);
    nvPushData(16, tmpVal);
    nvPushData(17, tmpVal);

    nvPusherAdjust(18);

    // Disable fog
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG_ENABLE | 0x40000);
    nvPushData(1, NV056_SET_FOG_ENABLE_V_FALSE);

    nvPusherAdjust(2);

    // Now setup combiners

    // Default register combiner settings are:
    // A = primary color
    // B = one
    // C = zero
    // D = zero

    // Our subpictue luma alpha blending moComp values
    // combiner0, RGB portion:   A = texture0(Alpha)
    // combiner0, RGB portion:   B = texture0(RGB(VUY))
    // combiner0, RGB portion:   C = texture0(!Alpha)
    // combiner0, RGB portion:   D = texture1(BBB(YYY))

    moCompColorICW = (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                     (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_TRUE << 28) |
                     (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_8 << 24) |

                     (NV056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                     (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                     (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                     (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_INVERT << 13) |
                     (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_TRUE << 12) |
                     (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_8 << 8) |

                     (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                     (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                      NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    // Initialize combiner ICW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_ALPHA_ICW(0) | 0x80000);
    nvPushData(1, DEFAULT_ALPHA_ICW);
    nvPushData(2, DEFAULT_ALPHA_ICW);

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_COLOR_ICW(0) | 0x80000);
    nvPushData(4, moCompColorICW);
    nvPushData(5, DEFAULT_COLOR_ICW);

    // Load combination factors
    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINE_FACTOR(0) | 0x80000);
    nvPushData(7, 0xFF0000FF); // 100%
    nvPushData(8, 0xFF0000FF); // 100%

    nvPusherAdjust(9);

    // combiner0, RGB portion:      spare0 = A * B + C * D = texture0 alpha * texture0 B(Y) + !texture0 alpha * texture1 B(Y)
    moCompColorOCW = (NV056_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT << 15) |
                     (NV056_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_FALSE << 14) |
                     (NV056_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_FALSE << 13) |
                     (NV056_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_FALSE << 12) |
                     (NV056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_C << 8) |
                     (NV056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_0 << 4) |
                      NV056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_0;

    // Initialize combiner OCW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_ALPHA_OCW(0) | 0x80000);
    nvPushData(1, DEFAULT_ALPHA_OCW);
    nvPushData(2, DEFAULT_ALPHA_OCW);

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER0_COLOR_OCW | 0x40000);
    nvPushData(4, moCompColorOCW);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER1_COLOR_OCW | 0x40000);
    nvPushData(6, DEFAULT_C1_COLOR_OCW);

    nvPusherAdjust(7);

    // Load final stages with default values
    // Initialize combiner final CW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_SPECULAR_FOG_CW0 | 0x40000);
    nvPushData(1, DEFAULT_FINAL_CW0);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_SPECULAR_FOG_CW1 | 0x40000);
    nvPushData(3, DEFAULT_FINAL_CW1);

    nvPusherAdjust(4);


    nvPusherStart(TRUE);

    return TRUE;

} /* nvInitCelsiusForMoCompNV12LumaSubpictureCompositing */


/*
 * nvInitCelsiusForMoCompNV12ChromaSubpictureCompositing
 *
 * Performs final celsius object motion comp initialization for
 * A8V8U8Y8 subpicture compositing with an NV12 surface chroma portion resulting in an
 * output surface also in NV12 format.
 *
 * For chroma subpicture compositing, texture0 is the subpicture in A8V8U8Y8 format from
 * which we extract the A8 and V8U8 components and alpha blend with the V8U8 components of
 * the NV12 source surface in texture1 to produce alpha blended V8U8 components in NV12
 * format in the destination surface.
 *
 * In this mode the register combiners are set to:
 *
 * COMBINER0:
 *      INPUT: A = texture0 alpha, B = texture0 color RGB(VUY), C = !texture0 alpha, D = texture1 color RBB(VUU)
 *      OUTPUT: spare0 = A * B + C * D
 * COMBINER1:
 *      INPUT: A = constant0 (0,1,0)(U), B = spare0 color (VUU), C = constant1(1,0,0)(V), D = spare0 color (VUU)
 *      OUTPUT: OCW C = A . B = UUU, OCW D = C . D = VVV
 *
 * And the final combiner is set to:
 *
 *      INPUT: C = UUU, D = VVV
 *      OUTPUT: C = VU
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvInitCelsiusForMoCompNV12ChromaSubpictureCompositing(void)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl = pSurf_lcl->lpGbl;
    unsigned long               surfaceWidth = pSurf_gbl->wWidth;
    unsigned long               surfaceHeight = pSurf_gbl->wHeight;
    unsigned long               surfacePitch = pSurf_gbl->lPitch;
    unsigned long               texturePitch = pSurf_gbl->lPitch;
    unsigned long               tmpVal;
    unsigned long               moCompColorICW;
    unsigned long               moCompColorOCW;
    unsigned long               moCompFinalCW;
    float                       fBuffer[16];
    unsigned long               *ftol = (unsigned long *)&fBuffer[0];

    // Let D3D code know that we have touched NV
    pDriverData->TwoDRenderingOccurred = 1;

    // Surface offsets are initialized in the subpicture compositing function

    // Align surface pitch and set surface format and pitch
    surfacePitch |= (surfacePitch << 16);

    tmpVal = (NV056_SET_SURFACE_FORMAT_TYPE_PITCH << 8) |
              NV056_SET_SURFACE_FORMAT_COLOR_LE_G8B8;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_NO_OPERATION | 0x40000);
    nvPushData(1, 0);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_FORMAT | 0x40000);
    nvPushData(3, tmpVal);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_PITCH | 0x40000);
    nvPushData(5, surfacePitch);

    nvPusherAdjust(6);

    // Just disable both texture matrices since these texture coordinates are unscaled

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_MATRIX0_ENABLE | 0x40000);
    nvPushData(1, NV056_SET_TEXTURE_MATRIX0_ENABLE_V_FALSE);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_MATRIX1_ENABLE | 0x40000);
    nvPushData(3, NV056_SET_TEXTURE_MATRIX1_ENABLE_V_FALSE);

    nvPusherAdjust(4);

    nvMoCompParams.dataFormat = DATA_FORMAT_SUBPICTURE_CHROMA_BLEND;

    tmpVal = (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) |
             (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) |
             (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) |
             (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) |
             (1 << 12) | // 1 MIPMAP level
             (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A8R8G8B8 << 7) |
             (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) |
             (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) |
             (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
              NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_FORMAT(0) | 0x80000);
    nvPushData(1, tmpVal);
    
    tmpVal = (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) |
             (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) |
             (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) |
             (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) |
             (1 << 12) | // 1 MIPMAP level
             (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_R8B8 << 7) |
             (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) |
             (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) |
             (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
              NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A;

    nvPushData(2, tmpVal);

    pDriverData->dwMCTex0Control0 = (NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 8) | // huh ?  default MAX_LOD_CLAMP from OGL (no clamping)
                                    (NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    pDriverData->dwMCTex1Control0 = (NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 8) | // huh ?  default MAX_LOD_CLAMP from OGL (no clamping)
                                    (NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL0(0) | 0x80000);
    nvPushData(4, pDriverData->dwMCTex0Control0);
    nvPushData(5, pDriverData->dwMCTex1Control0);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
    nvPushData(7, texturePitch << 16);
    nvPushData(8, texturePitch << 16);

    nvPushData(9, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL2(0) | 0x80000);
    nvPushData(10, 0);
    nvPushData(11, 0);

//    tmpVal = (2044 << 16) | (surfaceHeight << 1); // Must be even and <= 2046
    tmpVal = (2044 << 16) | 2046; // Must be even and <= 2046

    nvPushData(12, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXTURE_IMAGE_RECT(0) | 0x80000);
    nvPushData(13, tmpVal);
    nvPushData(14, tmpVal);

    tmpVal = (NV056_SET_TEXTURE_FILTER_TEXTUREMAG_NEAREST << 28) |
             (NV056_SET_TEXTURE_FILTER_TEXTUREMIN_NEAREST << 24);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXTURE_FILTER(0) | 0x80000);
    nvPushData(16, tmpVal);
    nvPushData(17, tmpVal);

    nvPusherAdjust(18);

    // Disable fog
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG_ENABLE | 0x40000);
    nvPushData(1, NV056_SET_FOG_ENABLE_V_FALSE);

    nvPusherAdjust(2);

    // Now setup combiners

    // Default register combiner settings are:
    // A = primary color
    // B = one
    // C = zero
    // D = zero

    // Our subpicture chroma alpha blending moComp values for combiner0
    // combiner0, RGB portion:   A = texture0(Alpha)
    // combiner0, RGB portion:   B = texture0(RGB(VUY))
    // combiner0, RGB portion:   C = texture0(!Alpha)
    // combiner0, RGB portion:   D = texture1(RBB(VUU))

    moCompColorICW = (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                     (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_TRUE << 28) |
                     (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_8 << 24) |

                     (NV056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                     (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                     (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                     (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_INVERT << 13) |
                     (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_TRUE << 12) |
                     (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_8 << 8) |

                     (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                     (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                      NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    // Initialize combiner ICW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_ALPHA_ICW(0) | 0x80000);
    nvPushData(1, DEFAULT_ALPHA_ICW);
    nvPushData(2, DEFAULT_ALPHA_ICW);

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_COLOR_ICW(0) | 0x80000);
    nvPushData(4, moCompColorICW);

    // Our subpicture chroma alpha blending moComp values for combiner1
    // combiner1, RGB portion:   A = constant0(0,1,0)(U)
    // combiner1, RGB portion:   B = combiner0 color (final VUU)
    // combiner1, RGB portion:   C = constant1(1,0,0)(V)
    // combiner1, RGB portion:   D = combiner0 color (final VUU)

    moCompColorICW = (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                     (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                     (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                     (NV056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                     (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                     (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_C << 16) |

                     (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                     (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                     (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2 << 8) |

                     (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                     (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                      NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_C;

    nvPushData(5, moCompColorICW);

    // Load combination factors
    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINE_FACTOR(0) | 0x80000);
    nvPushData(7, 0x0000FF00); // 100%
    nvPushData(8, 0x00FF0000); // 100%

    nvPusherAdjust(9);

    // combiner0, RGB portion:      spare0 = A * B + C * D = texture0 alpha * texture0 RGB(VUY) + !texture0 alpha * texture1 RBB(VUU)
    moCompColorOCW = (NV056_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT << 15) |
                     (NV056_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_FALSE << 14) |
                     (NV056_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_FALSE << 13) |
                     (NV056_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_FALSE << 12) |
                     (NV056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_C << 8) |
                     (NV056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_0 << 4) |
                      NV056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_0;

    // Initialize combiner OCW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_ALPHA_OCW(0) | 0x80000);
    nvPushData(1, DEFAULT_ALPHA_OCW);
    nvPushData(2, DEFAULT_ALPHA_OCW);

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER0_COLOR_OCW | 0x40000);
    nvPushData(4, moCompColorOCW);

    // combiner1, RGB portion:      OCW C = A . B = constant0 (0,1,0) * final U, OCW D = C . D = constant1(1,0,0) * final V
    moCompColorOCW = (NV056_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_TWO << 28) |
                     (NV056_SET_COMBINER1_COLOR_OCW_MUX_SELECT_MSB << 27) |
                     (NV056_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT << 15) |
                     (NV056_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_FALSE << 14) |
                     (NV056_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_TRUE << 13) |
                     (NV056_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_TRUE << 12) |
                     (NV056_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_0 << 8) |
                     (NV056_SET_COMBINER1_COLOR_OCW_AB_DST_REG_C << 4) |
                      NV056_SET_COMBINER1_COLOR_OCW_CD_DST_REG_D;

    nvPushData(5, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER1_COLOR_OCW | 0x40000);
    nvPushData(6, moCompColorOCW);

    nvPusherAdjust(7);

    // Load final stages: final output (VU) = constant0(0,1,0) * OCW D (VVV) + (1 - constant0)(1,0,1) * OCW C (UUU) + 0
    // Initialize combiner final CW methods

    moCompFinalCW = (NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_FALSE << 29) |
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_FALSE << 28) |
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_1 << 24) |
                                                                                          
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_FALSE << 21) |
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_FALSE << 20) |
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_D << 16) |
                                                                                           
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_FALSE << 13) |
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_FALSE << 12) |
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_C << 8) |
                                                                                         
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_FALSE << 5) |
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_FALSE << 4) |
                     NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_0;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_SPECULAR_FOG_CW0 | 0x40000);
    nvPushData(1, moCompFinalCW);
    
    moCompFinalCW = (NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_FALSE << 29) |
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_FALSE << 28) |
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0 << 24) |
                                                                                          
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_FALSE << 21) |
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_FALSE << 20) |
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0 << 16) |
                                                                                      
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_FALSE << 13) |
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_FALSE << 12) |
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_0 << 8) |
                                                                                          
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_TRUE << 7) |
                    (NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_FALSE << 6) |
                     NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_FALSE;
    
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_SPECULAR_FOG_CW1 | 0x40000);
    nvPushData(3, moCompFinalCW);

    nvPusherAdjust(4);


    nvPusherStart(TRUE);

    return TRUE;

} /* nvInitCelsiusForMoCompNV12ChromaSubpictureCompositing */

#endif // Until NV17

/*
 * nvInitCelsiusForMoCompConversion
 *
 * Performs final celsius object motion comp initialization for
 * the format conversion portion of the algorithm.
 *
 * For conversion, texture0 is used to convert the luma values to 0x00Y100Y0 and
 * texture1 is used to convert the chroma values to 0xV000U000 which are then added together
 * thus allowing the conversion to take place in one pass.  The textures are modulated
 * with constant colors to select which component comes from which texture.
 * The output texture is just passed through the register combiners to the final combiner.
 *
 * In this mode the register combiners are set to:
 *
 *      INPUT: A = constantColor0, B = texture0, C = constantColor1, D = texture1
 *      OUTPUT: spare0 = A * B + C * D
 *
 * And the final combiner is set to:
 *
 *      INPUT: C = spare0
 *      OUTPUT: C = spare0
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvInitCelsiusForMoCompConversion(void)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl = pSurf_lcl->lpGbl;
    unsigned long               surfaceWidth = pSurf_gbl->wWidth;
    unsigned long               surfaceHeight = pSurf_gbl->wHeight;
    unsigned long               surfacePitch = pSurf_gbl->lPitch;
    unsigned long               texturePitch = pSurf_gbl->lPitch;
    unsigned long               tmpVal;
    unsigned long               moCompAlphaICW;
    unsigned long               moCompColorICW;
    unsigned long               moCompAlphaOCW;
    unsigned long               moCompColorOCW;
    float                       fBuffer[16];
    unsigned long               *ftol = (unsigned long *)&fBuffer[0];

    // Let D3D code know that we have touched NV
    pDriverData->TwoDRenderingOccurred = 1;

    if (pDriverData->bMCHorizontallyDownscale1080i) {
        // Restore default composite and texture matrices assuming quarter pel scaling of texture coordinates
        fBuffer[0]  = 0.1875; fBuffer[1]  = 0.0;  fBuffer[2]  = 0.0; fBuffer[3]  = 0.0;
        fBuffer[4]  = 0.0;    fBuffer[5]  = 0.25; fBuffer[6]  = 0.0; fBuffer[7]  = 0.0;
        fBuffer[8]  = 0.0;    fBuffer[9]  = 0.0;  fBuffer[10] = 1.0; fBuffer[11] = 0.0;
        fBuffer[12] = 0.0;    fBuffer[13] = 0.0;  fBuffer[14] = 0.0; fBuffer[15] = 1.0;

        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_COMPOSITE_MATRIX(0) | 0x400000);
        nvPushData(1, ftol[0]);
        nvPushData(2, ftol[4]);
        nvPushData(3, ftol[8]);
        nvPushData(4, ftol[12]);
        nvPushData(5, ftol[1]);
        nvPushData(6, ftol[5]);
        nvPushData(7, ftol[9]);
        nvPushData(8, ftol[13]);
        nvPushData(9, ftol[2]);
        nvPushData(10, ftol[6]);
        nvPushData(11, ftol[10]);
        nvPushData(12, ftol[14]);
        nvPushData(13, ftol[3]);
        nvPushData(14, ftol[7]);
        nvPushData(15, ftol[11]);
        nvPushData(16, ftol[15]);

        nvPusherAdjust(17);
    }

    // Surface offsets are initialized in the format conversion function

    // Align surface pitch and set surface format and pitch
    surfacePitch = ((surfaceWidth << 1) + 127) & ~127; // YUY2 destination is twice the surface width
    surfacePitch |= (surfacePitch << 16);

    tmpVal = (NV056_SET_SURFACE_FORMAT_TYPE_PITCH << 8) |
              NV056_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_NO_OPERATION | 0x40000);
    nvPushData(1, 0);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_FORMAT | 0x40000);
    nvPushData(3, tmpVal);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_PITCH | 0x40000);
    nvPushData(5, surfacePitch);

    nvPusherAdjust(6);

    // Just disable both texture matrices since these texture coordinates are unscaled

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_MATRIX0_ENABLE | 0x40000);
    nvPushData(1, NV056_SET_TEXTURE_MATRIX0_ENABLE_V_FALSE);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_MATRIX1_ENABLE | 0x40000);
    nvPushData(3, NV056_SET_TEXTURE_MATRIX1_ENABLE_V_FALSE);

    nvPusherAdjust(4);

    nvMoCompParams.dataFormat = DATA_FORMAT_FOURCC_CONVERSION;

    tmpVal = (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) |
             (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) |
             (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) |
             (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) |
             (1 << 12) | // 1 MIPMAP level
             (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_R8B8 << 7) |
             (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) |
             (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) |
             (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
              NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_FORMAT(0) | 0x80000);
    nvPushData(1, tmpVal);
    nvPushData(2, tmpVal);

    pDriverData->dwMCTex0Control0 = (NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 8) | // huh ?  default MAX_LOD_CLAMP from OGL (no clamping)
                                    (NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    pDriverData->dwMCTex1Control0 = (NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 8) | // huh ?  default MAX_LOD_CLAMP from OGL (no clamping)
                                    (NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL0(0) | 0x80000);
    nvPushData(4, pDriverData->dwMCTex0Control0);
    nvPushData(5, pDriverData->dwMCTex1Control0);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
    nvPushData(7, texturePitch << 16);
    nvPushData(8, texturePitch << 16);

    nvPushData(9, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL2(0) | 0x80000);
    nvPushData(10, 0);
    nvPushData(11, 0);

//    tmpVal = (2044 << 16) | (surfaceHeight << 1); // Must be even and <= 2046
    tmpVal = (2044 << 16) | 2046; // Must be even and <= 2046

    nvPushData(12, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXTURE_IMAGE_RECT(0) | 0x80000);
    nvPushData(13, tmpVal);
    nvPushData(14, tmpVal);

    tmpVal = (NV056_SET_TEXTURE_FILTER_TEXTUREMAG_NEAREST << 28) |
             (NV056_SET_TEXTURE_FILTER_TEXTUREMIN_NEAREST << 24);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXTURE_FILTER(0) | 0x80000);
    nvPushData(16, tmpVal);
    nvPushData(17, tmpVal);

    nvPusherAdjust(18);

    // Disable fog
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG_ENABLE | 0x40000);
    nvPushData(1, NV056_SET_FOG_ENABLE_V_FALSE);

    nvPusherAdjust(2);

    // Now setup combiners

    // Default register combiner settings are:
    // A = primary color
    // B = one
    // C = zero
    // D = zero

    // Our format conversion moComp values
    // combiner0, Alpha portion:   A = 0
    // combiner0, Alpha portion:   B = 0
    // combiner0, Alpha portion:   C = constantColor1 (0xFF00FF00)
    // combiner0, Alpha portion:   D = texture1
    // combiner0, RGB portion:   A = constantColor0 (0x00FF00FF)
    // combiner0, RGB portion:   B = texture0
    // combiner0, RGB portion:   C = constantColor1 (0xFF00FF00)
    // combiner0, RGB portion:   D = texture1

    moCompAlphaICW = (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                     (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_TRUE << 28) |
                     (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0 << 24) |

                     (NV056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                     (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_TRUE << 20) |
                     (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0 << 16) |

                     (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                     (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_TRUE << 12) |
                     (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2 << 8) |

                     (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                     (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_TRUE << 4) |
                      NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    moCompColorICW = (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                     (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                     (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                     (NV056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                     (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                     (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                     (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                     (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                     (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2 << 8) |

                     (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                     (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                      NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    // Initialize combiner ICW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_ALPHA_ICW(0) | 0x80000);
    nvPushData(1, moCompAlphaICW);
    nvPushData(2, DEFAULT_ALPHA_ICW);

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_COLOR_ICW(0) | 0x80000);
    nvPushData(4, moCompColorICW);
    nvPushData(5, DEFAULT_COLOR_ICW);

    // Load combination factors
    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINE_FACTOR(0) | 0x80000);
    nvPushData(7, 0x00FF00FF); // luma
    nvPushData(8, 0xFF00FF00); // chroma

    nvPusherAdjust(9);

    // combiner0, Alpha portion:    spare0 = A * B + C * D = texture1
    moCompAlphaOCW = (NV056_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT << 15) |
                     (NV056_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE << 14) |
                     (NV056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C << 8) |
                     (NV056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0 << 4) |
                      NV056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0;

    // combiner0, RGB portion:      spare0 = A * B + C * D = texture0 + texture1
    moCompColorOCW = (NV056_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT << 15) |
                     (NV056_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_FALSE << 14) |
                     (NV056_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_FALSE << 13) |
                     (NV056_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_FALSE << 12) |
                     (NV056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_C << 8) |
                     (NV056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_0 << 4) |
                      NV056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_0;

    // Initialize combiner OCW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_ALPHA_OCW(0) | 0x80000);
    nvPushData(1, moCompAlphaOCW);
    nvPushData(2, DEFAULT_ALPHA_OCW);

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER0_COLOR_OCW | 0x40000);
    nvPushData(4, moCompColorOCW);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER1_COLOR_OCW | 0x40000);
    nvPushData(6, DEFAULT_C1_COLOR_OCW);

    nvPusherAdjust(7);

    // Load final stages with default values
    // Initialize combiner final CW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_SPECULAR_FOG_CW0 | 0x40000);
    nvPushData(1, DEFAULT_FINAL_CW0);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_SPECULAR_FOG_CW1 | 0x40000);
    nvPushData(3, DEFAULT_FINAL_CW1);

    nvPusherAdjust(4);


    nvPusherStart(TRUE);

    return TRUE;

} /* nvInitCelsiusForMoCompConversion */


/*
 * nvInitCelsiusForMoCompTemporalFilter
 *
 * Performs final celsius object motion comp initialization for
 * the intra frame field temporal filtering portion of the algorithm.
 *
 * For temporal filtering, texture0 is used to reference the top field and
 * texture1 is used to reference the bottom field which are then added together
 * thus allowing the filter to complete in one pass.  The textures are modulated
 * with constant colors to select the fraction of coverage which comes from which texture.
 * The output texture is just passed through the register combiners to the final combiner.
 *
 * In this mode the register combiners are set to:
 *
 *      INPUT: A = constantColor0, B = texture0, C = constantColor1, D = texture1
 *      OUTPUT: spare0 = A * B + C * D
 *
 * And the final combiner is set to:
 *
 *      INPUT: C = spare0
 *      OUTPUT: C = spare0
 *
 * Note that pDriverData must be set before calling this function
 *
 */
DWORD __stdcall nvInitCelsiusForMoCompTemporalFilter(void)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl = pSurf_lcl->lpGbl;
    unsigned long               surfaceWidth = pSurf_gbl->wWidth;
    unsigned long               surfaceHeight = pSurf_gbl->wHeight;
    unsigned long               surfacePitch;
    unsigned long               tmpVal;
    unsigned long               moCompAlphaICW;
    unsigned long               moCompColorICW;
    unsigned long               moCompAlphaOCW;
    unsigned long               moCompColorOCW;

    // Let D3D code know that we have touched NV
    pDriverData->TwoDRenderingOccurred = 1;

    // Surface offsets are initialized in the temporal filter function

    // Align surface pitch and set surface format and pitch
    surfacePitch = (pSurf_gbl->wWidth + 3) & ~3;
    surfacePitch = ((surfacePitch << 1) + 127) & ~127; // YUY2 destination is twice the surface width
    surfacePitch |= (surfacePitch << 16);
    surfacePitch <<= 1;

    tmpVal = (NV056_SET_SURFACE_FORMAT_TYPE_PITCH << 8) |
              NV056_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_NO_OPERATION | 0x40000);
    nvPushData(1, 0);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_FORMAT | 0x40000);
    nvPushData(3, tmpVal);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_SURFACE_PITCH | 0x40000);
    nvPushData(5, surfacePitch);

    nvPusherAdjust(6);

    // Enable both texture matrices since these texture coordinates are in quarter pel
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_MATRIX0_ENABLE | 0x40000);
    nvPushData(1, NV056_SET_TEXTURE_MATRIX0_ENABLE_V_TRUE);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_MATRIX1_ENABLE | 0x40000);
    nvPushData(3, NV056_SET_TEXTURE_MATRIX1_ENABLE_V_TRUE);

    nvPusherAdjust(4);

    nvMoCompParams.dataFormat = DATA_FORMAT_TEMPORAL_FILTER;

    tmpVal = (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) |
             (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) |
             (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) |
             (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) |
             (1 << 12) | // 1 MIPMAP level
             (NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A8R8G8B8 << 7) |
             (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) |
             (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) |
             (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
              NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_FORMAT(0) | 0x80000);
    nvPushData(1, tmpVal);
    nvPushData(2, tmpVal);

    pDriverData->dwMCTex0Control0 = (NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 8) | // huh ?  default MAX_LOD_CLAMP from OGL (no clamping)
                                    (NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    pDriverData->dwMCTex1Control0 = (NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                                    (15 << 8) | // huh ?  default MAX_LOD_CLAMP from OGL (no clamping)
                                    (NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                                    (NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                                    (NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                                     NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL0(0) | 0x80000);
    nvPushData(4, pDriverData->dwMCTex0Control0);
    nvPushData(5, pDriverData->dwMCTex1Control0);

    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
    nvPushData(7, (surfacePitch << 16));
    nvPushData(8, (surfacePitch << 16));

    nvPushData(9, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_TEXTURE_CONTROL2(0) | 0x80000);
    nvPushData(10, 0);
    nvPushData(11, 0);

//    tmpVal = (2044 << 16) | (surfaceHeight << 1); // Must be even and <= 2046
    tmpVal = (2044 << 16) | 2046; // Must be even and <= 2046

    nvPushData(12, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXTURE_IMAGE_RECT(0) | 0x80000);
    nvPushData(13, tmpVal);
    nvPushData(14, tmpVal);

    tmpVal = (NV056_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR << 28) |
             (NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR << 24);

    nvPushData(15, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_TEXTURE_FILTER(0) | 0x80000);
    nvPushData(16, tmpVal);
    nvPushData(17, tmpVal);

    nvPusherAdjust(18);

    // Disable fog
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG_ENABLE | 0x40000);
    nvPushData(1, NV056_SET_FOG_ENABLE_V_FALSE);

    nvPusherAdjust(2);

    // Now setup combiners

    // Default register combiner settings are:
    // A = primary color
    // B = one
    // C = zero
    // D = zero

    // Our temporal filter moComp values
    // combiner0, RGB portion:   A = constantColor0
    // combiner0, RGB portion:   B = texture0
    // combiner0, RGB portion:   C = constantColor1
    // combiner0, RGB portion:   D = texture1

    moCompAlphaICW = (NV056_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                     (NV056_SET_COMBINER_ALPHA_ICW_A_ALPHA_TRUE << 28) |
                     (NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1 << 24) |

                     (NV056_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                     (NV056_SET_COMBINER_ALPHA_ICW_B_ALPHA_TRUE << 20) |
                     (NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_8 << 16) |

                     (NV056_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                     (NV056_SET_COMBINER_ALPHA_ICW_C_ALPHA_TRUE << 12) |
                     (NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_2 << 8) |

                     (NV056_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                     (NV056_SET_COMBINER_ALPHA_ICW_D_ALPHA_TRUE << 4) |
                      NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_9;

    moCompColorICW = (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                     (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                     (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                     (NV056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                     (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                     (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                     (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                     (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                     (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2 << 8) |

                     (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                     (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                      NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9;

    // Initialize combiner ICW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_ALPHA_ICW(0) | 0x80000);
    nvPushData(1, moCompAlphaICW);
    nvPushData(2, DEFAULT_ALPHA_ICW);

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_COLOR_ICW(0) | 0x80000);
    nvPushData(4, moCompColorICW);
    nvPushData(5, DEFAULT_COLOR_ICW);

    // Load combination factors
    nvPushData(6, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINE_FACTOR(0) | 0x80000);
    nvPushData(7, 0x80808080); // % of top field
    nvPushData(8, 0x80808080); // % of bottom field

    nvPusherAdjust(9);

    // combiner0, RGB portion:      spare0 = A * B + C * D = texture0 + texture1
    moCompAlphaOCW = (NV056_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT << 15) |
                     (NV056_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE << 14) |
                     (NV056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C << 8) |
                     (NV056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0 << 4) |
                      NV056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0;

    moCompColorOCW = (NV056_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT << 15) |
                     (NV056_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_FALSE << 14) |
                     (NV056_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_FALSE << 13) |
                     (NV056_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_FALSE << 12) |
                     (NV056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_C << 8) |
                     (NV056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_0 << 4) |
                      NV056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_0;

    // Initialize combiner OCW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_ALPHA_OCW(0) | 0x80000);
    nvPushData(1, moCompAlphaOCW);
    nvPushData(2, DEFAULT_ALPHA_OCW);

    nvPushData(3, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER0_COLOR_OCW | 0x40000);
    nvPushData(4, moCompColorOCW);

    nvPushData(5, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER1_COLOR_OCW | 0x40000);
    nvPushData(6, DEFAULT_C1_COLOR_OCW);

    nvPusherAdjust(7);

    // Load final stages with default values
    // Initialize combiner final CW methods
    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_SPECULAR_FOG_CW0 | 0x40000);
    nvPushData(1, DEFAULT_FINAL_CW0);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_COMBINER_SPECULAR_FOG_CW1 | 0x40000);
    nvPushData(3, DEFAULT_FINAL_CW1);

    nvPusherAdjust(4);

    nvPusherStart(TRUE);

    return TRUE;

} /* nvInitCelsiusForMoCompTemporalFilter */



#endif  // NVARCH >= 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\MoPredKelvin.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       MoPredKelvin.cpp
 *  Content:    Windows98 DirectDraw 32 bit driver
 *
 ***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

extern NVMOCOMPPARAMS nvMoCompParams;

extern PNVMCPREDFUNC nvDoBidirectionalFieldPrediction;
extern PNVMCPREDFUNC nvDoTwoBidirectionalFieldPredictions;
extern PNVMCPREDFUNC nvDoForwardFieldPrediction;
extern PNVMCPREDFUNC nvDoTwoForwardFieldPredictions;
extern PNVMCPREDFUNC nvDoBackwardFieldPrediction;
extern PNVMCPREDFUNC nvDoTwoBackwardFieldPredictions;

#ifdef  DEBUG
extern unsigned long moCompDebugLevel;
#endif  // DEBUG


/*
 * nvDoKelvinBidirectionalDVDFieldPrediction
 *
 * Performs bidirectional field prediction on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoKelvinBidirectionalDVDFieldPrediction(BOOL isChroma)
{
    float           fBuffer = 0.5;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    unsigned long   dwSurfacePitch;
    unsigned long   dwSurfaceOffset = 0;
    long            texture1BlockX0;
    long            texture1BlockY0;
    long            texture1BlockX1;
    long            texture1BlockY1;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_KELVIN_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.forwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.forwardVerticalVector;

    texture1BlockX0 = nvMoCompParams.blockX + nvMoCompParams.backwardHorizontalVector;

    texture1BlockY0 = nvMoCompParams.blockY + nvMoCompParams.backwardVerticalVector;

    blockX0 = nvMoCompParams.blockX;

    if (isChroma)
        dwSurfacePitch = nvMoCompParams.surfaceLumaPitch << 1;
    else
        dwSurfacePitch = nvMoCompParams.surfaceLumaPitch << 2;

    if (nvMoCompParams.forwardField != 0)
        texture0BlockX0 += dwSurfacePitch;

    if (nvMoCompParams.backwardField != 0)
        texture1BlockX0 += dwSurfacePitch;
    
    if (nvMoCompParams.destinationField != 0) 
        blockX0 += dwSurfacePitch;
    
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = texture1BlockY0 + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;
    texture1BlockY0 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40300000);

    nvPushKelvinMoCompQuadData(5);

    nvPushData(17, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(18, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(19);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoKelvinBidirectionalDVDFieldPrediction */


/*
 * nvDoTwoKelvinBidirectionalDVDFieldPredictions
 *
 * Performs two bidirectional field predictions on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoTwoKelvinBidirectionalDVDFieldPredictions(BOOL isChroma)
{
    float           fBuffer = 0.5;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    unsigned long   dwSurfacePitch;
    long            texture1BlockX0;
    long            texture1BlockY0;
    long            texture1BlockX1;
    long            texture1BlockY1;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_KELVIN_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

    if (isChroma)
        dwSurfacePitch = nvMoCompParams.surfaceLumaPitch << 1;
    else
        dwSurfacePitch = nvMoCompParams.surfaceLumaPitch << 2;

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.forwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.forwardVerticalVector;

    texture1BlockX0 = nvMoCompParams.blockX + nvMoCompParams.backwardHorizontalVector;

    texture1BlockY0 = nvMoCompParams.blockY + nvMoCompParams.backwardVerticalVector;

    if (nvMoCompParams.forwardField != 0)
        texture0BlockX0 += dwSurfacePitch;

    if (nvMoCompParams.backwardField != 0)
        texture1BlockX0 += dwSurfacePitch;
    
    blockX0 = nvMoCompParams.blockX;

    if (nvMoCompParams.destinationField != 0) 
        blockX0 += dwSurfacePitch;
    
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = texture1BlockY0 + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;
    texture1BlockY0 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40600000);

    nvPushKelvinMoCompQuadData(5);

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.forwardHorizontalVector2;

    texture0BlockY0 = nvMoCompParams.blockY2 + nvMoCompParams.forwardVerticalVector2;

    texture1BlockX0 = nvMoCompParams.blockX + nvMoCompParams.backwardHorizontalVector2;

    texture1BlockY0 = nvMoCompParams.blockY2 + nvMoCompParams.backwardVerticalVector2;

    if (nvMoCompParams.forwardField2 != 0)
        texture0BlockX0 += dwSurfacePitch;

    if (nvMoCompParams.backwardField2 != 0)
        texture1BlockX0 += dwSurfacePitch;
    
    blockX0 = nvMoCompParams.blockX;

    if (nvMoCompParams.destinationField2 != 0) 
        blockX0 += dwSurfacePitch;
    
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = texture1BlockY0 + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;
    texture1BlockY0 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY2;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY2 + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushKelvinMoCompQuadData(17);

    nvPushData(29, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(30, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(31);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoTwoKelvinBidirectionalDVDFieldPredictions */


/*
 * nvDoKelvinForwardDVDFieldPrediction
 *
 * Performs forward field prediction on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoKelvinForwardDVDFieldPrediction(BOOL isChroma)
{
    float           fBuffer = 0.0;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    unsigned long   dwSurfacePitch;
    unsigned long   dwSurfaceOffset = 0;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_KELVIN_FORWARD_VERTEX_ARRAY_MODE();

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.forwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.forwardVerticalVector;

    blockX0 = nvMoCompParams.blockX;

    if (isChroma)
        dwSurfacePitch = nvMoCompParams.surfaceLumaPitch << 1;
    else
        dwSurfacePitch = nvMoCompParams.surfaceLumaPitch << 2;

    if (nvMoCompParams.forwardField != 0)
        texture0BlockX0 += dwSurfacePitch;

    if (nvMoCompParams.destinationField != 0)
        blockX0 += dwSurfacePitch;
    
    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40200000);

    nvPushData(5, blockY0 | blockX0);
    nvPushData(6, texture0BlockY0 | texture0BlockX0);
    nvPushData(7, blockY1 | blockX0);
    nvPushData(8, texture0BlockY1 | texture0BlockX0);
    nvPushData(9, blockY1 | blockX1);
    nvPushData(10, texture0BlockY1 | texture0BlockX1);
    nvPushData(11, blockY0 | blockX1);
    nvPushData(12, texture0BlockY0 | texture0BlockX1);

    nvPushData(13, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(14, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(15);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoKelvinForwardDVDFieldPrediction */


/*
 * nvDoTwoKelvinForwardDVDFieldPredictions
 *
 * Performs two forward field predictions on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoTwoKelvinForwardDVDFieldPredictions(BOOL isChroma)
{
    float           fBuffer = 0.0;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    unsigned long   dwSurfacePitch;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_KELVIN_FORWARD_VERTEX_ARRAY_MODE();

    if (isChroma)
        dwSurfacePitch = nvMoCompParams.surfaceLumaPitch << 1;
    else
        dwSurfacePitch = nvMoCompParams.surfaceLumaPitch << 2;

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.forwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.forwardVerticalVector;

    if (nvMoCompParams.forwardField != 0)
        texture0BlockX0 += dwSurfacePitch;

    blockX0 = nvMoCompParams.blockX;

    if (nvMoCompParams.destinationField != 0)
        blockX0 += dwSurfacePitch;
    
    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40400000);

    nvPushData(5, blockY0 | blockX0);
    nvPushData(6, texture0BlockY0 | texture0BlockX0);
    nvPushData(7, blockY1 | blockX0);
    nvPushData(8, texture0BlockY1 | texture0BlockX0);
    nvPushData(9, blockY1 | blockX1);
    nvPushData(10, texture0BlockY1 | texture0BlockX1);
    nvPushData(11, blockY0 | blockX1);
    nvPushData(12, texture0BlockY0 | texture0BlockX1);

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.forwardHorizontalVector2;

    texture0BlockY0 = nvMoCompParams.blockY2 + nvMoCompParams.forwardVerticalVector2;

    if (nvMoCompParams.forwardField2 != 0)
        texture0BlockX0 += dwSurfacePitch;

    blockX0 = nvMoCompParams.blockX;

    if (nvMoCompParams.destinationField2 != 0)
        blockX0 += dwSurfacePitch;
    
    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY2;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY2 + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(13, blockY0 | blockX0);
    nvPushData(14, texture0BlockY0 | texture0BlockX0);
    nvPushData(15, blockY1 | blockX0);
    nvPushData(16, texture0BlockY1 | texture0BlockX0);
    nvPushData(17, blockY1 | blockX1);
    nvPushData(18, texture0BlockY1 | texture0BlockX1);
    nvPushData(19, blockY0 | blockX1);
    nvPushData(20, texture0BlockY0 | texture0BlockX1);

    nvPushData(21, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(22, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(23);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoTwoKelvinForwardDVDFieldPredictions */



/*
 * nvDoKelvinBackwardDVDFieldPrediction
 *
 * Performs backward field prediction on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoKelvinBackwardDVDFieldPrediction(BOOL isChroma)
{
    float           fBuffer = 1.0;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    unsigned long   dwSurfacePitch;
    unsigned long   dwSurfaceOffset = 0;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_KELVIN_BACKWARD_VERTEX_ARRAY_MODE();

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.backwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.backwardVerticalVector;

    blockX0 = nvMoCompParams.blockX;

    if (isChroma)
        dwSurfacePitch = nvMoCompParams.surfaceLumaPitch << 1;
    else
        dwSurfacePitch = nvMoCompParams.surfaceLumaPitch << 2;

    if (nvMoCompParams.backwardField != 0)
        texture0BlockX0 += dwSurfacePitch;

    if (nvMoCompParams.destinationField != 0)
        blockX0 += dwSurfacePitch;
    
    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40200000);

    nvPushData(5, blockY0 | blockX0);
    nvPushData(6, texture0BlockY0 | texture0BlockX0);
    nvPushData(7, blockY1 | blockX0);
    nvPushData(8, texture0BlockY1 | texture0BlockX0);
    nvPushData(9, blockY1 | blockX1);
    nvPushData(10, texture0BlockY1 | texture0BlockX1);
    nvPushData(11, blockY0 | blockX1);
    nvPushData(12, texture0BlockY0 | texture0BlockX1);

    nvPushData(13, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(14, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(15);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoKelvinBackwardDVDFieldPrediction */


/*
 * nvDoTwoKelvinBackwardDVDFieldPredictions
 *
 * Performs two backward field predictions on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoTwoKelvinBackwardDVDFieldPredictions(BOOL isChroma)
{
    float           fBuffer = 1.0;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    unsigned long   dwSurfacePitch;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_KELVIN_BACKWARD_VERTEX_ARRAY_MODE();

    if (isChroma)
        dwSurfacePitch = nvMoCompParams.surfaceLumaPitch << 1;
    else
        dwSurfacePitch = nvMoCompParams.surfaceLumaPitch << 2;

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.backwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.backwardVerticalVector;

    if (nvMoCompParams.backwardField != 0)
        texture0BlockX0 += dwSurfacePitch;

    blockX0 = nvMoCompParams.blockX;

    if (nvMoCompParams.destinationField != 0)
        blockX0 += dwSurfacePitch;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV097_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_KELVIN) +
                  NV097_INLINE_ARRAY | 0x40400000);

    nvPushData(5, blockY0 | blockX0);
    nvPushData(6, texture0BlockY0 | texture0BlockX0);
    nvPushData(7, blockY1 | blockX0);
    nvPushData(8, texture0BlockY1 | texture0BlockX0);
    nvPushData(9, blockY1 | blockX1);
    nvPushData(10, texture0BlockY1 | texture0BlockX1);
    nvPushData(11, blockY0 | blockX1);
    nvPushData(12, texture0BlockY0 | texture0BlockX1);

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.backwardHorizontalVector2;

    texture0BlockY0 = nvMoCompParams.blockY2 + nvMoCompParams.backwardVerticalVector2;

    if (nvMoCompParams.backwardField2 != 0)
        texture0BlockX0 += dwSurfacePitch;

    blockX0 = nvMoCompParams.blockX;

    if (nvMoCompParams.destinationField2 != 0)
        blockX0 += dwSurfacePitch;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY2;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockY1 = nvMoCompParams.blockY2 + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(13, blockY0 | blockX0);
    nvPushData(14, texture0BlockY0 | texture0BlockX0);
    nvPushData(15, blockY1 | blockX0);
    nvPushData(16, texture0BlockY1 | texture0BlockX0);
    nvPushData(17, blockY1 | blockX1);
    nvPushData(18, texture0BlockY1 | texture0BlockX1);
    nvPushData(19, blockY0 | blockX1);
    nvPushData(20, texture0BlockY0 | texture0BlockX1);

    nvPushData(21, dDrawSubchannelOffset(NV_DD_KELVIN) +
                   NV097_SET_BEGIN_END | 0x40000);
    nvPushData(22, NV097_SET_BEGIN_END_OP_END);

    nvPusherAdjust(23);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoTwoKelvinBackwardFieldPredictions */


#if 0
/*
 * nvDualPrimeArithmetic
 *
 * Performs new prediction motion vectors from original and differential vectors
 *
 */
void __stdcall nvDualPrimeArithmetic(short DMV[][2],
                                     short *differentialMotionVector,
                                     short horizontalMotionVector,
                                     short verticalMotionVector)
{

    if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) {
        if (pDriverData->bMCTopFieldFirst) {
            // Vector for prediction of top field from bottom field
            DMV[0][0] = ((horizontalMotionVector + (horizontalMotionVector > 0)) >> 1) +
                          differentialMotionVector[0];
            DMV[0][1] = ((verticalMotionVector + (verticalMotionVector > 0)) >> 1) +
                          differentialMotionVector[1] - 1;

            // Vector for prediction of bottom field from top field
            DMV[1][0] = ((3*horizontalMotionVector + (horizontalMotionVector > 0)) >> 1) +
                          differentialMotionVector[0];
            DMV[1][1] = ((3*verticalMotionVector + (verticalMotionVector > 0)) >> 1) +
                          differentialMotionVector[1] + 1;
        } else {
            // Vector for prediction of top field from bottom field
            DMV[0][0] = ((3*horizontalMotionVector + (horizontalMotionVector > 0)) >> 1) +
                          differentialMotionVector[0];
            DMV[0][1] = ((3*verticalMotionVector + (verticalMotionVector > 0)) >> 1) +
                          differentialMotionVector[1] - 1;

            // Vector for prediction of bottom field from top field
            DMV[1][0] = ((horizontalMotionVector + (horizontalMotionVector > 0)) >> 1) +
                          differentialMotionVector[0];
            DMV[1][1] = ((verticalMotionVector + (verticalMotionVector > 0)) >> 1) +
                          differentialMotionVector[1] + 1;
        }
    } else { // Vector for prediction for field of opposite 'parity'
        DMV[0][0] = ((horizontalMotionVector + (horizontalMotionVector > 0)) >> 1) +
                      differentialMotionVector[0];
        DMV[0][1] = ((verticalMotionVector + (verticalMotionVector > 0)) >> 1) +
                      differentialMotionVector[1];

        // Correct for vertical field shift
        if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD)
            DMV[0][1]--;
        else
            DMV[0][1]++;
    }

} /* nvDualPrimeArithmetic */

#endif

/*
 * nvPredictKelvinFrameLumaMacroblock
 *
 * Determines what type of prediction to apply to the macroblock and
 * calls the appropriate function.
 *
 * Note: All geometry sent to prediction functions is in quarter pel units
 *
 */
DWORD __stdcall nvPredictKelvinFrameLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
//    short dmvector[2];
//    short DMV[2][2];

    SET_KELVIN_LUMA_DATA_FORMAT();
    
    // We don't currently support spatial scalability

    nvMoCompParams.blockWidth = 64 * numCombinedMacroblocks;
    nvMoCompParams.blockX = pMacroblock->hOffset << 2;

    if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_B) &&
        ((pMacroblock->macroblockType & (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) ==
        (MB_MOTION_FORWARD | MB_MOTION_BACKWARD))) {

        if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME) { // Frame based prediction

            nvMoCompParams.forwardField = 0;
            nvMoCompParams.backwardField = 0;
            nvMoCompParams.destinationField = 0;
            nvMoCompParams.blockHeight = 128;
            nvMoCompParams.blockY = pMacroblock->vOffset << 3;
            nvMoCompParams.forwardHorizontalVector = pMacroblock->PMV[0][0][0] << 1;
            nvMoCompParams.forwardVerticalVector = pMacroblock->PMV[0][0][1] << 2;
            nvMoCompParams.backwardHorizontalVector = pMacroblock->PMV[0][1][0] << 1;
            nvMoCompParams.backwardVerticalVector = pMacroblock->PMV[0][1][1] << 2;

            nvDoBidirectionalFieldPrediction(FALSE);

        } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD) { // Field based prediction

            nvMoCompParams.blockHeight = 64;
            nvMoCompParams.blockY = pMacroblock->vOffset << 2;

            // Top field prediction
            nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
            nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
            nvMoCompParams.destinationField = 0;
            *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
            *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0] << 1) & 0xFFFEFFFF;

            nvMoCompParams.blockY2 = nvMoCompParams.blockY;

            // Bottom field prediction
            nvMoCompParams.forwardField2 = pMacroblock->fieldSelect[1][0];
            nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
            nvMoCompParams.destinationField2 = 1;
            *(long *)&nvMoCompParams.forwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;
            *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

            nvDoTwoBidirectionalFieldPredictions(FALSE);
            
        } else {
            // Error
            return FALSE;
        }
    } else {
        if ((pMacroblock->macroblockType & MB_MOTION_FORWARD) ||
            (pDriverData->bMCPictureCodingType == PICTURE_TYPE_P)) {

            if ((pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME) ||
                (!(pMacroblock->macroblockType & MB_MOTION_FORWARD))) {
                
                nvMoCompParams.forwardField = 0;
                nvMoCompParams.destinationField = 0;
                nvMoCompParams.blockHeight = 128;
                nvMoCompParams.blockY = pMacroblock->vOffset << 3;
                nvMoCompParams.forwardHorizontalVector = pMacroblock->PMV[0][0][0] << 1;
                nvMoCompParams.forwardVerticalVector = pMacroblock->PMV[0][0][1] << 2;

                nvDoForwardFieldPrediction(FALSE);

            } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD) { // Field based prediction

                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                // Top field prediction
                nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                nvMoCompParams.destinationField = 0;
                *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;

                nvMoCompParams.blockY2 = nvMoCompParams.blockY;

                // Bottom field prediction
                nvMoCompParams.forwardField2 = pMacroblock->fieldSelect[1][0];
                nvMoCompParams.destinationField2 = 1;
                *(long *)&nvMoCompParams.forwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;

                nvDoTwoForwardFieldPredictions(FALSE);
                
            } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_DP) { // Dual prime prediction

                // Calculate derived motion vectors
                // nvDualPrimeArithmetic(DMV,
                //                      dmvector,
                //                      pMacroblock->PMV[0][0][0],
                //                      (short)(pMacroblock->PMV[0][0][1] >> 1));

                pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDualPrimeSurface;

                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(1, VIDMEM_OFFSET(pSurf_lcl->lpGbl->fpVidMem));

                nvPusherAdjust(2);

                // Predict top field from top field
                // and add to top field from bottom field
                nvMoCompParams.forwardField = 0;
                nvMoCompParams.backwardField = 1;
                nvMoCompParams.destinationField = 0;
                *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;

                nvDoBidirectionalFieldPrediction(FALSE);

                // Predict bottom field from bottom field
                // and add to bottom field from top field
                nvMoCompParams.forwardField = 1;
                nvMoCompParams.backwardField = 0;
                nvMoCompParams.destinationField = 1;
                *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

                nvDoBidirectionalFieldPrediction(FALSE);

                pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface;

                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(1, VIDMEM_OFFSET(pSurf_lcl->lpGbl->fpVidMem));

                nvPusherAdjust(2);
                
            } else {
                // Error
                return FALSE;
            }
        }

        if (pMacroblock->macroblockType & MB_MOTION_BACKWARD) {

            if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME) { // Frame based prediction

                nvMoCompParams.backwardField = 0;
                nvMoCompParams.destinationField = 0;
                nvMoCompParams.blockHeight = 128;
                nvMoCompParams.blockY = pMacroblock->vOffset << 3;
                nvMoCompParams.backwardHorizontalVector = pMacroblock->PMV[0][1][0] << 1;
                nvMoCompParams.backwardVerticalVector = pMacroblock->PMV[0][1][1] << 2;

                nvDoBackwardFieldPrediction(FALSE);

            } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD) { // Field based prediction

                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                // Top field prediction
                nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                nvMoCompParams.destinationField = 0;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0] << 1) & 0xFFFEFFFF;

                nvMoCompParams.blockY2 = nvMoCompParams.blockY;

                // Bottom field prediction
                nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
                nvMoCompParams.destinationField2 = 1;
                *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

                nvDoTwoBackwardFieldPredictions(FALSE);
            }
        }
    }

    return TRUE;

} /* nvPredictKelvinFrameLumaMacroblock */


/*
 * nvPredictKelvinFrameChromaMacroblock
 *
 * Determines what type of prediction to apply to the macroblock and
 * calls the appropriate function.
 *
 * Note: All geometry sent to prediction functions is in quarter pel units.
 *       This function assumes chroma format is interleaved CrCb so predictions are
 *       performed at twice the horizontal offset and width so that only 1 pass is required.
 *       This 16 bit pixel format also requires that the prediction functions be notified
 *       that they must use a pitch of half the default size when attempting to access field 1.
 *
 */
DWORD __stdcall nvPredictKelvinFrameChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
//    short dmvector[2];
//    short DMV[2][2];

    SET_KELVIN_CHROMA_DATA_FORMAT();
    
    // We don't currently support spatial scalability

    nvMoCompParams.destinationField = 0;
    nvMoCompParams.forwardField = 0;
    nvMoCompParams.backwardField = 0;
    nvMoCompParams.blockWidth = 32 * numCombinedMacroblocks;
    nvMoCompParams.blockX = pMacroblock->hOffset << 1;

    if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_B) &&
        ((pMacroblock->macroblockType & (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) ==
        (MB_MOTION_FORWARD | MB_MOTION_BACKWARD))) {

        if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME) { // Frame based prediction

            if (pMacroblock->PMV[0][0][0] < 0) 
                pMacroblock->PMV[0][0][0] += 1; // round toward 0

            if (pMacroblock->PMV[0][0][1] < 0) 
                pMacroblock->PMV[0][0][1] += 1; // round toward 0

            if (pMacroblock->PMV[0][1][0] < 0) 
                pMacroblock->PMV[0][1][0] += 1; // round toward 0

            if (pMacroblock->PMV[0][1][1] < 0) 
                pMacroblock->PMV[0][1][1] += 1; // round toward 0

            nvMoCompParams.blockHeight = 64;
            nvMoCompParams.blockY = pMacroblock->vOffset << 2;
            nvMoCompParams.forwardHorizontalVector = pMacroblock->PMV[0][0][0] & 0xFFFE;
            nvMoCompParams.forwardVerticalVector = (pMacroblock->PMV[0][0][1] & 0xFFFE) << 1;
            nvMoCompParams.backwardHorizontalVector = pMacroblock->PMV[0][1][0] & 0xFFFE;
            nvMoCompParams.backwardVerticalVector = (pMacroblock->PMV[0][1][1] & 0xFFFE) << 1;

            nvDoBidirectionalFieldPrediction(TRUE);

        } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD) { // Field based prediction

            nvMoCompParams.blockHeight = 32;
            nvMoCompParams.blockY = pMacroblock->vOffset << 1;

            if (pMacroblock->PMV[0][0][0] < 0) 
                pMacroblock->PMV[0][0][0] += 1; // round toward 0

            if (pMacroblock->PMV[0][0][1] < 0) 
                pMacroblock->PMV[0][0][1] += 1; // round toward 0

            if (pMacroblock->PMV[0][1][0] < 0) 
                pMacroblock->PMV[0][1][0] += 1; // round toward 0

            if (pMacroblock->PMV[0][1][1] < 0) 
                pMacroblock->PMV[0][1][1] += 1; // round toward 0

            if (pMacroblock->PMV[1][0][0] < 0) 
                pMacroblock->PMV[1][0][0] += 1; // round toward 0

            if (pMacroblock->PMV[1][0][1] < 0) 
                pMacroblock->PMV[1][0][1] += 1; // round toward 0

            if (pMacroblock->PMV[1][1][0] < 0) 
                pMacroblock->PMV[1][1][0] += 1; // round toward 0

            if (pMacroblock->PMV[1][1][1] < 0) 
                pMacroblock->PMV[1][1][1] += 1; // round toward 0

            // Top field prediction
            nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
            nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
            nvMoCompParams.destinationField = 0;
            *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]) & 0xFFFEFFFE;
            *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0]) & 0xFFFEFFFE;

            nvMoCompParams.blockY2 = nvMoCompParams.blockY;

            // Bottom field prediction
            nvMoCompParams.forwardField2 = pMacroblock->fieldSelect[1][0];
            nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
            nvMoCompParams.destinationField2 = 1;
            *(long *)&nvMoCompParams.forwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][0][0]) & 0xFFFEFFFE;
            *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0]) & 0xFFFEFFFE;

            nvDoTwoBidirectionalFieldPredictions(TRUE);
        } else {
            // Error
            return FALSE;
        }
    } else {
        if ((pMacroblock->macroblockType & MB_MOTION_FORWARD) ||
            (pDriverData->bMCPictureCodingType == PICTURE_TYPE_P)) {

            if ((pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME) ||
                (!(pMacroblock->macroblockType & MB_MOTION_FORWARD))) {
            
                if (pMacroblock->PMV[0][0][0] < 0) 
                    pMacroblock->PMV[0][0][0] += 1; // round toward 0

                if (pMacroblock->PMV[0][0][1] < 0) 
                    pMacroblock->PMV[0][0][1] += 1; // round toward 0

                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.forwardHorizontalVector = pMacroblock->PMV[0][0][0] & 0xFFFE;
                nvMoCompParams.forwardVerticalVector = (pMacroblock->PMV[0][0][1] & 0xFFFE) << 1;

                nvDoForwardFieldPrediction(TRUE);

            } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD) { // Field based prediction

                nvMoCompParams.blockHeight = 32;
                nvMoCompParams.blockY = pMacroblock->vOffset << 1;

                if (pMacroblock->PMV[0][0][0] < 0) 
                    pMacroblock->PMV[0][0][0] += 1; // round toward 0

                if (pMacroblock->PMV[0][0][1] < 0) 
                    pMacroblock->PMV[0][0][1] += 1; // round toward 0

                if (pMacroblock->PMV[1][0][0] < 0) 
                    pMacroblock->PMV[1][0][0] += 1; // round toward 0
                    
                if (pMacroblock->PMV[1][0][1] < 0) 
                    pMacroblock->PMV[1][0][1] += 1; // round toward 0
                
                // Top field prediction
                nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                nvMoCompParams.destinationField = 0;
                *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]) & 0xFFFEFFFE;

                nvMoCompParams.blockY2 = nvMoCompParams.blockY;

                // Bottom field prediction
                nvMoCompParams.forwardField2 = pMacroblock->fieldSelect[1][0];
                nvMoCompParams.destinationField2 = 1;
                *(long *)&nvMoCompParams.forwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][0][0]) & 0xFFFEFFFE;

                nvDoTwoForwardFieldPredictions(TRUE);

            } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_DP) { // Dual prime prediction

                // Calculate derived motion vectors
                // nvDualPrimeArithmetic(DMV,
                //                      dmvector,
                //                      pMacroblock->PMV[0][0][0],
                //                      (short)(pMacroblock->PMV[0][0][1] >> 1));

                pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDualPrimeSurface;

                nvMoCompParams.blockHeight = 32;
                nvMoCompParams.blockY = pMacroblock->vOffset << 1;

                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(1, VIDMEM_OFFSET((pSurf_lcl->lpGbl->fpVidMem + nvMoCompParams.surfaceChromaOffset)));

                nvPusherAdjust(2);

                if (pMacroblock->PMV[0][0][0] < 0) 
                    pMacroblock->PMV[0][0][0] += 1; // round toward 0

                if (pMacroblock->PMV[0][0][1] < 0) 
                    pMacroblock->PMV[0][0][1] += 1; // round toward 0

                if (pMacroblock->PMV[1][0][0] < 0) 
                    pMacroblock->PMV[1][0][0] += 1; // round toward 0

                if (pMacroblock->PMV[1][0][1] < 0) 
                    pMacroblock->PMV[1][0][1] += 1; // round toward 0

                if (pMacroblock->PMV[1][1][0] < 0) 
                    pMacroblock->PMV[1][1][0] += 1; // round toward 0

                if (pMacroblock->PMV[1][1][1] < 0) 
                    pMacroblock->PMV[1][1][1] += 1; // round toward 0

                // Predict top field from top field
                // and add to top field from bottom field
                nvMoCompParams.forwardField = 0;
                nvMoCompParams.backwardField = 1;
                nvMoCompParams.destinationField = 0;
                *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]) & 0xFFFEFFFE;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0]) & 0xFFFEFFFE;

                nvDoBidirectionalFieldPrediction(TRUE);

                // Predict bottom field from bottom field
                // and add to bottom field from top field
                nvMoCompParams.forwardField = 1;
                nvMoCompParams.backwardField = 0;
                nvMoCompParams.destinationField = 1;
                *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]) & 0xFFFEFFFE;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][1][0]) & 0xFFFEFFFE;

                nvDoBidirectionalFieldPrediction(TRUE);

                pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface;

                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(1, VIDMEM_OFFSET((pSurf_lcl->lpGbl->fpVidMem + nvMoCompParams.surfaceChromaOffset)));

                nvPusherAdjust(2);
            } else {
                // Error
                return FALSE;
            }
        }

        if (pMacroblock->macroblockType & MB_MOTION_BACKWARD) {

            if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME) { // Frame based prediction

                if (pMacroblock->PMV[0][1][0] < 0) 
                    pMacroblock->PMV[0][1][0] += 1; // round toward 0

                if (pMacroblock->PMV[0][1][1] < 0) 
                    pMacroblock->PMV[0][1][1] += 1; // round toward 0

                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.backwardHorizontalVector = pMacroblock->PMV[0][1][0] & 0xFFFE;
                nvMoCompParams.backwardVerticalVector = (pMacroblock->PMV[0][1][1] & 0xFFFE) << 1;

                nvDoBackwardFieldPrediction(TRUE);

            } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD) { // Field based prediction

                nvMoCompParams.blockHeight = 32;
                nvMoCompParams.blockY = pMacroblock->vOffset << 1;

                if (pMacroblock->PMV[0][1][0] < 0) 
                    pMacroblock->PMV[0][1][0] += 1; // round toward 0

                if (pMacroblock->PMV[0][1][1] < 0) 
                    pMacroblock->PMV[0][1][1] += 1; // round toward 0

                if (pMacroblock->PMV[1][1][0] < 0) 
                    pMacroblock->PMV[1][1][0] += 1; // round toward 0

                if (pMacroblock->PMV[1][1][1] < 0) 
                    pMacroblock->PMV[1][1][1] += 1; // round toward 0

                // Top field prediction
                nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                nvMoCompParams.destinationField = 0;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0]) & 0xFFFEFFFE;

                nvMoCompParams.blockY2 = nvMoCompParams.blockY;

                // Bottom field prediction
                nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
                nvMoCompParams.destinationField2 = 1;
                *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0]) & 0xFFFEFFFE;

                nvDoTwoBackwardFieldPredictions(TRUE);
            }
        }
    }

    return TRUE;

} /* nvPredictKelvinFrameChromaMacroblock */


/*
 * nvPredictKelvinFieldLumaMacroblock
 *
 * Determines what type of prediction to apply to the macroblock and
 * calls the appropriate function.
 *
 * Note: All geometry sent to prediction functions is in quarter pel units
 *
 */
DWORD __stdcall nvPredictKelvinFieldLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    unsigned long currentField;
    unsigned long doBackwardPrediction;
//    short dmvector[2];
//    short DMV[2][2];

    SET_KELVIN_LUMA_DATA_FORMAT();
    
    // We don't currently support spatial scalability

    // Destination field offset already set at init time
    nvMoCompParams.destinationField = 0;

    nvMoCompParams.blockWidth = 64 * numCombinedMacroblocks;
    nvMoCompParams.blockX = pMacroblock->hOffset << 2;
    nvMoCompParams.blockY = pMacroblock->vOffset << 2;

    if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_B) &&
        ((pMacroblock->macroblockType & (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) ==
        (MB_MOTION_FORWARD | MB_MOTION_BACKWARD))) {

        // Field based prediction
        if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) {

            nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
            nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
            nvMoCompParams.blockHeight = 64;
            *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
            *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0] << 1) & 0xFFFEFFFF;

            nvDoBidirectionalFieldPrediction(FALSE);

        } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {

            nvMoCompParams.blockHeight = 32;

            // Top half
            nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
            nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
            *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
            *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0] << 1) & 0xFFFEFFFF;

            // Bottom half
            nvMoCompParams.destinationField2 = nvMoCompParams.destinationField;
            nvMoCompParams.forwardField2 = pMacroblock->fieldSelect[1][0];
            nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
            nvMoCompParams.blockY2 = nvMoCompParams.blockY + 32;
            *(long *)&nvMoCompParams.forwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;
            *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

            nvDoTwoBidirectionalFieldPredictions(FALSE);
        } else {
            // Error
            return FALSE;
        }
    } else {
        if ((pMacroblock->macroblockType & MB_MOTION_FORWARD) ||
            (pDriverData->bMCPictureCodingType == PICTURE_TYPE_P)) {

            if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD)
                currentField = 0;
            else
                currentField = 1;

            doBackwardPrediction = 0; // previous frame

            // Determine which frame to use for prediction
            if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_P) &&
                 pDriverData->bMCSecondField &&
                (currentField != pMacroblock->fieldSelect[0][0]))
                doBackwardPrediction = 1; // same frame

            // Field based prediction
            if ((pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) ||
                (!(pMacroblock->macroblockType & MB_MOTION_FORWARD))) {

                nvMoCompParams.blockHeight = 64;

                if (doBackwardPrediction) {
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;

                    nvDoBackwardFieldPrediction(FALSE);
                } else {
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;

                    nvDoForwardFieldPrediction(FALSE);
                }
            } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {

                nvMoCompParams.blockHeight = 32;

                if (doBackwardPrediction) {
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;

                    nvDoBackwardFieldPrediction(FALSE);
                } else {
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;

                    nvDoForwardFieldPrediction(FALSE);
                }

                doBackwardPrediction = 0; // previous frame

                // Determine which frame to use for lower prediction
                if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_P) &&
                     pDriverData->bMCSecondField &&
                    (currentField != pMacroblock->fieldSelect[1][0]))
                    doBackwardPrediction = 1; // same frame

                nvMoCompParams.blockY += 32;

                if (doBackwardPrediction) {
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[1][0];
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;

                    nvDoBackwardFieldPrediction(FALSE);
                } else {
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[1][0];
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;

                    nvDoForwardFieldPrediction(FALSE);
                }
            } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_DP) { // Dual prime prediction

                if (pDriverData->bMCSecondField)
                    doBackwardPrediction = 1; // same frame
                else
                    doBackwardPrediction = 0; // previous frame

                // Calculate derived motion vectors
                // nvDualPrimeArithmetic(DMV,
                //                      dmvector,
                //                      pMacroblock->PMV[0][0][0],
                //                      pMacroblock->PMV[0][0][1]);


                if (doBackwardPrediction)
                    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
                else
                    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDualPrimeSurface;

                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(1, VIDMEM_OFFSET(pSurf_lcl->lpGbl->fpVidMem));

                nvPusherAdjust(2);
                
                // Predict from field of same parity
                // added to field of opposite parity
                nvMoCompParams.forwardField = (BYTE)currentField;
                nvMoCompParams.backwardField = (BYTE)currentField ^ 1;
                nvMoCompParams.blockHeight = 64;
                *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
                // nvMoCompParams.backwardHorizontalVector = DMV[0][0];
                // nvMoCompParams.backwardVerticalVector = DMV[0][1];
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;

                nvDoBidirectionalFieldPrediction(FALSE);

                pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface;

                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(1, VIDMEM_OFFSET(pSurf_lcl->lpGbl->fpVidMem));

                nvPusherAdjust(2);

            } else {
                // Error
                return FALSE;
            }
        }

        if (pMacroblock->macroblockType & MB_MOTION_BACKWARD) {

            // Field based prediction
            if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) {

                nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                nvMoCompParams.blockHeight = 64;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0] << 1) & 0xFFFEFFFF;

                nvDoBackwardFieldPrediction(FALSE);

            } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {

                nvMoCompParams.blockHeight = 32;

                nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0] << 1) & 0xFFFEFFFF;

                nvMoCompParams.destinationField2 = nvMoCompParams.destinationField;
                nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
                nvMoCompParams.blockY2 = nvMoCompParams.blockY + 32;
                *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

                nvDoTwoBackwardFieldPredictions(FALSE);

            } else {
                // Error
                return FALSE;
            }
        }
    }

    return TRUE;

} /* nvPredictKelvinFieldLumaMacroblock */


/*
 * nvPredictKelvinFieldChromaMacroblock
 *
 * Determines what type of prediction to apply to the macroblock and
 * calls the appropriate function.
 *
 * Note: All geometry sent to prediction functions is in quarter pel units.
 *       This function assumes chroma format is interleaved CrCb so predictions are
 *       performed at twice the horizontal offset and width so that only 1 pass is required.
 *       This 16 bit pixel format also requires that the prediction functions be notified
 *       that they must use a pitch of half the default size when attempting to access field 1.
 *
 */
DWORD __stdcall nvPredictKelvinFieldChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    unsigned long currentField;
    unsigned long doBackwardPrediction;
//    short dmvector[2];
//    short DMV[2][2];

    SET_KELVIN_CHROMA_DATA_FORMAT();
    
    // We don't currently support spatial scalability

    // Destination field offset already set at init time
    nvMoCompParams.destinationField = 0;

    nvMoCompParams.blockWidth = 32 * numCombinedMacroblocks;
    nvMoCompParams.blockX = pMacroblock->hOffset << 1;
    nvMoCompParams.blockY = pMacroblock->vOffset << 1;

    if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_B) &&
        ((pMacroblock->macroblockType & (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) ==
        (MB_MOTION_FORWARD | MB_MOTION_BACKWARD))) {

        // Field based prediction
        if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) {

            nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
            nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
            nvMoCompParams.blockHeight = 32;
            *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]);
            *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0]);

            nvDoBidirectionalFieldPrediction(TRUE);

        } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {

            nvMoCompParams.blockHeight = 16;

            // Top half
            nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
            nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
            *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]);
            *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0]);

            // Bottom half
            nvMoCompParams.destinationField2 = nvMoCompParams.destinationField;
            nvMoCompParams.forwardField2 = pMacroblock->fieldSelect[1][0];
            nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
            nvMoCompParams.blockY2 = nvMoCompParams.blockY + 16;
            *(long *)&nvMoCompParams.forwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][0][0]);
            *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0]);

            nvDoTwoBidirectionalFieldPredictions(TRUE);

        } else {
            // Error
            return FALSE;
        }
    } else {
        if ((pMacroblock->macroblockType & MB_MOTION_FORWARD) ||
            (pDriverData->bMCPictureCodingType == PICTURE_TYPE_P)) {

            if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD)
                currentField = 0;
            else
                currentField = 1;

            doBackwardPrediction = 0; // previous frame

            // Determine which frame to use for prediction
            if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_P) &&
                 pDriverData->bMCSecondField &&
                (currentField != pMacroblock->fieldSelect[0][0]))
                doBackwardPrediction = 1; // same frame

            // Field based prediction
            if ((pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) ||
                (!(pMacroblock->macroblockType & MB_MOTION_FORWARD))) {

                nvMoCompParams.blockHeight = 32;

                if (doBackwardPrediction) {

                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]);

                    nvDoBackwardFieldPrediction(TRUE);
                } else {
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]);

                    nvDoForwardFieldPrediction(TRUE);
                }
            } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {

                nvMoCompParams.blockHeight = 16;

                if (doBackwardPrediction) {
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]);

                    nvDoBackwardFieldPrediction(TRUE);
                } else {
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]);

                    nvDoForwardFieldPrediction(TRUE);
                }

                doBackwardPrediction = 0; // previous frame

                // Determine which frame to use for lower prediction
                if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_P) &&
                     pDriverData->bMCSecondField &&
                    (currentField != pMacroblock->fieldSelect[1][0]))
                    doBackwardPrediction = 1; // same frame

                nvMoCompParams.blockY += 16;

                if (doBackwardPrediction) {
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[1][0];
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0]);

                    nvDoBackwardFieldPrediction(TRUE);
                } else {
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[1][0];
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0]);

                    nvDoForwardFieldPrediction(TRUE);
                }
            } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_DP) { // Dual prime prediction

                if (pDriverData->bMCSecondField)
                    doBackwardPrediction = 1; // same frame
                else
                    doBackwardPrediction = 0; // previous frame

                // Calculate derived motion vectors
                // nvDualPrimeArithmetic(DMV,
                //                      dmvector,
                //                      pMacroblock->PMV[0][0][0],
                //                      pMacroblock->PMV[0][0][1]);

                if (doBackwardPrediction)
                    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
                else
                    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDualPrimeSurface;

                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(1, VIDMEM_OFFSET((pSurf_lcl->lpGbl->fpVidMem + nvMoCompParams.surfaceChromaOffset)));

                nvPusherAdjust(2);

                // Predict from field of same parity
                // added to field of opposite parity
                nvMoCompParams.forwardField = (BYTE)currentField;
                nvMoCompParams.backwardField = (BYTE)currentField ^ 1;
                nvMoCompParams.blockHeight = 32;
                *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]);
                // nvMoCompParams.backwardHorizontalVector = DMV[0][0] >> 1;
                // nvMoCompParams.backwardVerticalVector = DMV[0][1] >> 1;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0]);

                nvDoBidirectionalFieldPrediction(TRUE);

                pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface;

                nvPushData(0, dDrawSubchannelOffset(NV_DD_KELVIN) +
                              NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(1, VIDMEM_OFFSET((pSurf_lcl->lpGbl->fpVidMem + nvMoCompParams.surfaceChromaOffset)));

                nvPusherAdjust(2);

            } else {
                // Error
                return FALSE;
            }
        }

        if (pMacroblock->macroblockType & MB_MOTION_BACKWARD) {

            // Field based prediction
            if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) {

                nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                nvMoCompParams.blockHeight = 32;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0]);

                nvDoBackwardFieldPrediction(TRUE);

            } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {

                nvMoCompParams.blockHeight = 16;

                nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0]);

                nvMoCompParams.destinationField2 = nvMoCompParams.destinationField;
                nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
                nvMoCompParams.blockY2 = nvMoCompParams.blockY + 16;
                *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0]);

                nvDoTwoBackwardFieldPredictions(TRUE);

            } else {
                // Error
                return FALSE;
            }
        }
    }

    return TRUE;

} /* nvPredictKelvinFieldChromaMacroblock */


#endif  // NVARCH >= 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nv4Tables.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nv4Tables.cpp                                                     *
*   NV4 Triangle Inner Loops. (Originally Machine Generated)                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal          05/23/98    NV4 development                    *
*       Craig Duttweiler     29Oct99     converted to general               *
*                                        repository of tables for nv4       *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

DWORD dwDrawPrimitiveTable[DRAW_PRIM_TABLE_ENTRIES+4] =
{
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x040*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x080*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x0c0*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x100*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x140*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x180*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x1c0*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x200*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x240*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x280*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x2c0*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x300*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x340*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x380*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x3c0*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x400*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x440*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x480*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x4c0*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x500*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x540*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x580*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x5c0*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x600*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x640*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x680*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x6c0*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x700*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x740*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x780*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x7c0*/
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x800*/
    (DWORD)NULL,
    (DWORD)nvDX5TriangleSetup,
    (DWORD)NULL,
    (DWORD)nvDX6TriangleSetup
};

DWORD nv4DP2OpToStride [D3D_DP2OP_MAX+1] =
{
    ~0,                             //   0  invalid
    ~0,                             //   1  D3DDP2OP_POINTS
    ~0,                             //   2  D3DDP2OP_INDEXEDLINELIST
    LEGACY_STRIDES,                 //   3  D3DDP2OP_INDEXEDTRIANGLELIST
    ~0,                             //   4  invalid
    ~0,                             //   5  invalid
    ~0,                             //   6  invalid
    ~0,                             //   7  invalid
    ~0,                             //   8  D3DDP2OP_RENDERSTATE
    ~0,                             //   9  invalid
    ~0,                             //  10  invalid
    ~0,                             //  11  invalid
    ~0,                             //  12  invalid
    ~0,                             //  13  invalid
    ~0,                             //  14  invalid
    ~0,                             //  15  D3DDP2OP_LINELIST
    ~0,                             //  16  D3DDP2OP_LINESTRIP
    ~0,                             //  17  D3DDP2OP_INDEXEDLINESTRIP
    LIST_STRIDES,                   //  18  D3DDP2OP_TRIANGLELIST
    STRIP_STRIDES,                  //  19  D3DDP2OP_TRIANGLESTRIP
    STRIP_STRIDES,                  //  20  D3DDP2OP_INDEXEDTRIANGLESTRIP
    FAN_STRIDES,                    //  21  D3DDP2OP_TRIANGLEFAN
    FAN_STRIDES,                    //  22  D3DDP2OP_INDEXEDTRIANGLEFAN
    FAN_STRIDES,                    //  23  D3DDP2OP_TRIANGLEFAN_IMM
    ~0,                             //  24  D3DDP2OP_LINELIST_IMM
    ~0,                             //  25  D3DDP2OP_TEXTURESTAGESTATE
    LIST_STRIDES,                   //  26  D3DDP2OP_INDEXEDTRIANGLELIST2
    ~0,                             //  27  D3DDP2OP_INDEXEDLINELIST2
    ~0,                             //  28  D3DDP2OP_VIEWPORTINFO
    ~0,                             //  29  D3DDP2OP_WINFO
    ~0,                             //  30  D3DDP2OP_SETPALETTE
    ~0,                             //  31  D3DDP2OP_UPDATEPALETTE
    ~0,                             //  32  D3DDP2OP_ZRANGE
    ~0,                             //  33  D3DDP2OP_SETMATERIAL
    ~0,                             //  34  D3DDP2OP_SETLIGHT
    ~0,                             //  35  D3DDP2OP_CREATELIGHT
    ~0,                             //  36  D3DDP2OP_SETTRANSFORM
    ~0,                             //  37  D3DDP2OP_EXT
    ~0,                             //  38  D3DDP2OP_TEXBLT
    ~0,                             //  39  D3DDP2OP_STATESET
    ~0,                             //  40  D3DDP2OP_SETPRIORITY
    ~0,                             //  41  D3DDP2OP_SETRENDERTARGET
    ~0,                             //  42  D3DDP2OP_CLEAR
    ~0,                             //  43  D3DDP2OP_SETTEXLOD
    ~0                              //  44  D3DDP2OP_SETCLIPPLANE
};

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\MoPred.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#include "nvprecomp.h"

/*==========================================================================;
 *
 *  Copyright (C) 1999-2000 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       MoPred.cpp
 *  Content:    Windows98 DirectDraw 32 bit driver
 *
 ***************************************************************************/

#if (NVARCH >= 0x10)

extern NVMOCOMPPARAMS nvMoCompParams;

extern PNVMCPREDFUNC nvDoBidirectionalFieldPrediction;
extern PNVMCPREDFUNC nvDoTwoBidirectionalFieldPredictions;
extern PNVMCPREDFUNC nvDoForwardFieldPrediction;
extern PNVMCPREDFUNC nvDoTwoForwardFieldPredictions;
extern PNVMCPREDFUNC nvDoBackwardFieldPrediction;
extern PNVMCPREDFUNC nvDoTwoBackwardFieldPredictions;

#ifdef  DEBUG
extern unsigned long moCompDebugLevel;
#endif  // DEBUG


/*
 * nvDoCelsiusBidirectionalDVDFieldPrediction
 *
 * Performs bidirectional field prediction on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoCelsiusBidirectionalDVDFieldPrediction(BOOL isChroma)
{
    float           fBuffer = 0.5;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    unsigned long   dwSurfaceOffset = 0;
    long            texture1BlockX0;
    long            texture1BlockY0;
    long            texture1BlockX1;
    long            texture1BlockY1;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.forwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.forwardVerticalVector;

    texture1BlockX0 = nvMoCompParams.blockX + nvMoCompParams.backwardHorizontalVector;

    texture1BlockY0 = nvMoCompParams.blockY + nvMoCompParams.backwardVerticalVector;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (isChroma) {
        if (nvMoCompParams.forwardField != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;

        if (nvMoCompParams.backwardField != 0)
            texture1BlockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    
        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    } else {
        if (nvMoCompParams.forwardField != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset;

        if (nvMoCompParams.backwardField != 0)
            texture1BlockX0 += nvMoCompParams.celsiusFieldXOffset;
    
        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset;
    }
    
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = texture1BlockY0 + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;
    texture1BlockY0 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x300000);

    nvPushMoCompQuadData(5);

    nvPushData(17, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(18, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(19);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoCelsiusBidirectionalDVDFieldPrediction */


/*
 * nvDoTwoCelsiusBidirectionalDVDFieldPredictions
 *
 * Performs two bidirectional field predictions on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoTwoCelsiusBidirectionalDVDFieldPredictions(BOOL isChroma)
{
    float           fBuffer = 0.5;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    long            texture1BlockX0;
    long            texture1BlockY0;
    long            texture1BlockX1;
    long            texture1BlockY1;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.forwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.forwardVerticalVector;

    texture1BlockX0 = nvMoCompParams.blockX + nvMoCompParams.backwardHorizontalVector;

    texture1BlockY0 = nvMoCompParams.blockY + nvMoCompParams.backwardVerticalVector;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (isChroma) {
        if (nvMoCompParams.forwardField != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;

        if (nvMoCompParams.backwardField != 0)
            texture1BlockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    
        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    } else {
        if (nvMoCompParams.forwardField != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset;

        if (nvMoCompParams.backwardField != 0)
            texture1BlockX0 += nvMoCompParams.celsiusFieldXOffset;
    
        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset;
    }
    
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = texture1BlockY0 + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;
    texture1BlockY0 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x600000);

    nvPushMoCompQuadData(5);

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.forwardHorizontalVector2;

    texture0BlockY0 = nvMoCompParams.blockY2 + nvMoCompParams.forwardVerticalVector2;

    texture1BlockX0 = nvMoCompParams.blockX + nvMoCompParams.backwardHorizontalVector2;

    texture1BlockY0 = nvMoCompParams.blockY2 + nvMoCompParams.backwardVerticalVector2;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (isChroma) {
        if (nvMoCompParams.forwardField2 != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;

        if (nvMoCompParams.backwardField2 != 0)
            texture1BlockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    
        if (nvMoCompParams.destinationField2 != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    } else {
        if (nvMoCompParams.forwardField2 != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset;

        if (nvMoCompParams.backwardField2 != 0)
            texture1BlockX0 += nvMoCompParams.celsiusFieldXOffset;
    
        if (nvMoCompParams.destinationField2 != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset;
    }

    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = texture1BlockY0 + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;
    texture1BlockY0 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY2;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY2 + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushMoCompQuadData(17);

    nvPushData(29, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(30, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(31);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoTwoCelsiusBidirectionalDVDFieldPredictions */


/*
 * nvDoCelsiusForwardDVDFieldPrediction
 *
 * Performs forward field prediction on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoCelsiusForwardDVDFieldPrediction(BOOL isChroma)
{
    float           fBuffer = 0.0;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    unsigned long   dwSurfaceOffset = 0;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_FORWARD_VERTEX_ARRAY_MODE();

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.forwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.forwardVerticalVector;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (isChroma) {
        if (nvMoCompParams.forwardField != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;

        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    } else {
        if (nvMoCompParams.forwardField != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset;

        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset;
    }
    
    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x200000);

    nvPushData(5, texture0BlockY0 | texture0BlockX0);
    nvPushData(6, blockY0 | blockX0);
    nvPushData(7, texture0BlockY1 | texture0BlockX0);
    nvPushData(8, blockY1 | blockX0);
    nvPushData(9, texture0BlockY1 | texture0BlockX1);
    nvPushData(10, blockY1 | blockX1);
    nvPushData(11, texture0BlockY0 | texture0BlockX1);
    nvPushData(12, blockY0 | blockX1);

    nvPushData(13, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(14, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(15);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoCelsiusForwardDVDFieldPrediction */


/*
 * nvDoTwoCelsiusForwardDVDFieldPredictions
 *
 * Performs two forward field predictions on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoTwoCelsiusForwardDVDFieldPredictions(BOOL isChroma)
{
    float           fBuffer = 0.0;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_FORWARD_VERTEX_ARRAY_MODE();

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.forwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.forwardVerticalVector;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (isChroma) {
        if (nvMoCompParams.forwardField != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;

        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    } else {
        if (nvMoCompParams.forwardField != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset;

        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset;
    }

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x400000);

    nvPushData(5, texture0BlockY0 | texture0BlockX0);
    nvPushData(6, blockY0 | blockX0);
    nvPushData(7, texture0BlockY1 | texture0BlockX0);
    nvPushData(8, blockY1 | blockX0);
    nvPushData(9, texture0BlockY1 | texture0BlockX1);
    nvPushData(10, blockY1 | blockX1);
    nvPushData(11, texture0BlockY0 | texture0BlockX1);
    nvPushData(12, blockY0 | blockX1);

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.forwardHorizontalVector2;

    texture0BlockY0 = nvMoCompParams.blockY2 + nvMoCompParams.forwardVerticalVector2;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (isChroma) {
        if (nvMoCompParams.forwardField2 != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;

        if (nvMoCompParams.destinationField2 != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    } else {
        if (nvMoCompParams.forwardField2 != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset;

        if (nvMoCompParams.destinationField2 != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset;
    }
    
    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY2;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY2 + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(13, texture0BlockY0 | texture0BlockX0);
    nvPushData(14, blockY0 | blockX0);
    nvPushData(15, texture0BlockY1 | texture0BlockX0);
    nvPushData(16, blockY1 | blockX0);
    nvPushData(17, texture0BlockY1 | texture0BlockX1);
    nvPushData(18, blockY1 | blockX1);
    nvPushData(19, texture0BlockY0 | texture0BlockX1);
    nvPushData(20, blockY0 | blockX1);

    nvPushData(21, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(22, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(23);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoTwoCelsiusForwardDVDFieldPredictions */



/*
 * nvDoCelsiusBackwardDVDFieldPrediction
 *
 * Performs backward field prediction on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoCelsiusBackwardDVDFieldPrediction(BOOL isChroma)
{
    float           fBuffer = 1.0;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    unsigned long   dwSurfaceOffset = 0;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_BACKWARD_VERTEX_ARRAY_MODE();

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.backwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.backwardVerticalVector;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (isChroma) {
        if (nvMoCompParams.backwardField != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    
        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    } else {
        if (nvMoCompParams.backwardField != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset;
    
        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset;
    }
    
    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x200000);

    nvPushData(5, texture0BlockY0 | texture0BlockX0);
    nvPushData(6, blockY0 | blockX0);
    nvPushData(7, texture0BlockY1 | texture0BlockX0);
    nvPushData(8, blockY1 | blockX0);
    nvPushData(9, texture0BlockY1 | texture0BlockX1);
    nvPushData(10, blockY1 | blockX1);
    nvPushData(11, texture0BlockY0 | texture0BlockX1);
    nvPushData(12, blockY0 | blockX1);

    nvPushData(13, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(14, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(15);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoCelsiusBackwardDVDFieldPrediction */


/*
 * nvDoTwoCelsiusBackwardDVDFieldPredictions
 *
 * Performs two backward field predictions on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoTwoCelsiusBackwardDVDFieldPredictions(BOOL isChroma)
{
    float           fBuffer = 1.0;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_BACKWARD_VERTEX_ARRAY_MODE();

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.backwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.backwardVerticalVector;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (isChroma) {
        if (nvMoCompParams.backwardField != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    
        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    } else {
        if (nvMoCompParams.backwardField != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset;
    
        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset;
    }

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x400000);

    nvPushData(5, texture0BlockY0 | texture0BlockX0);
    nvPushData(6, blockY0 | blockX0);
    nvPushData(7, texture0BlockY1 | texture0BlockX0);
    nvPushData(8, blockY1 | blockX0);
    nvPushData(9, texture0BlockY1 | texture0BlockX1);
    nvPushData(10, blockY1 | blockX1);
    nvPushData(11, texture0BlockY0 | texture0BlockX1);
    nvPushData(12, blockY0 | blockX1);

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.backwardHorizontalVector2;

    texture0BlockY0 = nvMoCompParams.blockY2 + nvMoCompParams.backwardVerticalVector2;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (isChroma) {
        if (nvMoCompParams.backwardField2 != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    
        if (nvMoCompParams.destinationField2 != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    } else {
        if (nvMoCompParams.backwardField2 != 0)
            texture0BlockX0 += nvMoCompParams.celsiusFieldXOffset;
    
        if (nvMoCompParams.destinationField2 != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset;
    }

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY2;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY2 + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(13, texture0BlockY0 | texture0BlockX0);
    nvPushData(14, blockY0 | blockX0);
    nvPushData(15, texture0BlockY1 | texture0BlockX0);
    nvPushData(16, blockY1 | blockX0);
    nvPushData(17, texture0BlockY1 | texture0BlockX1);
    nvPushData(18, blockY1 | blockX1);
    nvPushData(19, texture0BlockY0 | texture0BlockX1);
    nvPushData(20, blockY0 | blockX1);

    nvPushData(21, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(22, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(23);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoTwoCelsiusBackwardFieldPredictions */


/*
 * nvDoCelsiusBidirectionalHDFieldPrediction
 *
 * Performs bidirectional field prediction on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoCelsiusBidirectionalHDFieldPrediction(BOOL isChroma)
{
    float           fBuffer = 0.5;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    unsigned long   dwSurfaceOffset = 0;
    long            texture1BlockX0;
    long            texture1BlockY0;
    long            texture1BlockX1;
    long            texture1BlockY1;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_BIDIRECTIONAL_VERTEX_ARRAY_MODE();

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.forwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.forwardVerticalVector;

    texture1BlockX0 = nvMoCompParams.blockX + nvMoCompParams.backwardHorizontalVector;

    texture1BlockY0 = nvMoCompParams.blockY + nvMoCompParams.backwardVerticalVector;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (isChroma) {
        dwSurfaceOffset = nvMoCompParams.surfaceChromaOffset;
        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    } else {
        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset;
    }

    if (nvMoCompParams.forwardField != nvMoCompParams.currentForwardField) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_OFFSET(0) | 0x40000);
        if (nvMoCompParams.forwardField != 0) {
            nvPushData(1, pDriverData->dwMCForwardSurfaceOffset + nvMoCompParams.surfaceLumaPitch + dwSurfaceOffset);
        } else {
            nvPushData(1, pDriverData->dwMCForwardSurfaceOffset + dwSurfaceOffset);
        }
        nvPusherAdjust(2);
        nvMoCompParams.currentForwardField = nvMoCompParams.forwardField;
    }

    if (nvMoCompParams.backwardField != nvMoCompParams.currentBackwardField) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
        if (nvMoCompParams.backwardField != 0) {
            nvPushData(1, pDriverData->dwMCBackwardSurfaceOffset + nvMoCompParams.surfaceLumaPitch + dwSurfaceOffset);
        } else {
            nvPushData(1, pDriverData->dwMCBackwardSurfaceOffset + dwSurfaceOffset);
        }
        nvPusherAdjust(2);
        nvMoCompParams.currentBackwardField = nvMoCompParams.backwardField;
    }
    
    texture1BlockX1 = texture1BlockX0 + nvMoCompParams.blockWidth;
    texture1BlockY1 = texture1BlockY0 + nvMoCompParams.blockHeight;
    texture1BlockY1 <<= 16;
    texture1BlockY0 <<= 16;

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x300000);

    nvPushMoCompQuadData(5);

    nvPushData(17, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(18, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(19);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoCelsiusBidirectionalHDFieldPrediction */


/*
 * nvDoCelsiusForwardHDFieldPrediction
 *
 * Performs forward field prediction on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoCelsiusForwardHDFieldPrediction(BOOL isChroma)
{
    float           fBuffer = 0.0;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    unsigned long   dwSurfaceOffset = 0;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_FORWARD_VERTEX_ARRAY_MODE();

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.forwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.forwardVerticalVector;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (isChroma) {
        dwSurfaceOffset = nvMoCompParams.surfaceChromaOffset;
        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    } else {
        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset;
    }
    
    if (nvMoCompParams.forwardField != nvMoCompParams.currentForwardField) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_OFFSET(0) | 0x40000);
        if (nvMoCompParams.forwardField != 0) {
            nvPushData(1, pDriverData->dwMCForwardSurfaceOffset + nvMoCompParams.surfaceLumaPitch + dwSurfaceOffset);
        } else {
            nvPushData(1, pDriverData->dwMCForwardSurfaceOffset + dwSurfaceOffset);
        }
        nvPusherAdjust(2);
        nvMoCompParams.currentForwardField = nvMoCompParams.forwardField;
    }

    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x200000);

    nvPushData(5, texture0BlockY0 | texture0BlockX0);
    nvPushData(6, blockY0 | blockX0);
    nvPushData(7, texture0BlockY1 | texture0BlockX0);
    nvPushData(8, blockY1 | blockX0);
    nvPushData(9, texture0BlockY1 | texture0BlockX1);
    nvPushData(10, blockY1 | blockX1);
    nvPushData(11, texture0BlockY0 | texture0BlockX1);
    nvPushData(12, blockY0 | blockX1);

    nvPushData(13, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(14, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(15);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoCelsiusForwardHDFieldPrediction */



/*
 * nvDoCelsiusBackwardHDFieldPrediction
 *
 * Performs backward field prediction on a macroblock
 *
 * Note: All geometry coordinates are in quarter pel units
 *
 */
void __stdcall nvDoCelsiusBackwardHDFieldPrediction(BOOL isChroma)
{
    float           fBuffer = 1.0;
    unsigned long   *ftol = (unsigned long *)&fBuffer;
    unsigned long   dwSurfaceOffset = 0;
    long            texture0BlockX0;
    long            texture0BlockY0;
    long            texture0BlockX1;
    long            texture0BlockY1;
    long            blockX0;
    long            blockX1;
    long            blockY0;
    long            blockY1;
    
    SET_BACKWARD_VERTEX_ARRAY_MODE();

    texture0BlockX0 = nvMoCompParams.blockX + nvMoCompParams.backwardHorizontalVector;

    texture0BlockY0 = nvMoCompParams.blockY + nvMoCompParams.backwardVerticalVector;

    blockX0 = nvMoCompParams.blockX - nvMoCompParams.celsiusDestinationViewportXOffset;

    if (isChroma) {
        dwSurfaceOffset = nvMoCompParams.surfaceChromaOffset;
        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset >> 1;
    } else {
        if (nvMoCompParams.destinationField != 0) 
            blockX0 += nvMoCompParams.celsiusFieldXOffset;
    }
    
    if (nvMoCompParams.backwardField != nvMoCompParams.currentBackwardField) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                      NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
        if (nvMoCompParams.backwardField != 0) {
            nvPushData(1, pDriverData->dwMCBackwardSurfaceOffset + nvMoCompParams.surfaceLumaPitch + dwSurfaceOffset);
        } else {
            nvPushData(1, pDriverData->dwMCBackwardSurfaceOffset + dwSurfaceOffset);
        }
        nvPusherAdjust(2);
        nvMoCompParams.currentBackwardField = nvMoCompParams.backwardField;
    }
    
    texture0BlockX1 = texture0BlockX0 + nvMoCompParams.blockWidth;
    texture0BlockY1 = texture0BlockY0 + nvMoCompParams.blockHeight;
    texture0BlockY1 <<= 16;
    texture0BlockY0 <<= 16;

    blockY0 = nvMoCompParams.blockY;
    blockY0 <<= 16;
    blockX1 = blockX0 + nvMoCompParams.blockWidth;
    blockX1 &= 0x0000FFFF;
    blockX0 &= 0x0000FFFF;
    blockY1 = nvMoCompParams.blockY + nvMoCompParams.blockHeight;
    blockY1 <<= 16;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_BEGIN_END | 0x40000);
    nvPushData(1, NV056_SET_BEGIN_END_OP_QUADS);

    nvPushData(2, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_SET_FOG1F | 0x40000);
    nvPushData(3, ftol[0]);

    nvPushData(4, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                  NV056_INLINE_ARRAY(0) | 0x200000);

    nvPushData(5, texture0BlockY0 | texture0BlockX0);
    nvPushData(6, blockY0 | blockX0);
    nvPushData(7, texture0BlockY1 | texture0BlockX0);
    nvPushData(8, blockY1 | blockX0);
    nvPushData(9, texture0BlockY1 | texture0BlockX1);
    nvPushData(10, blockY1 | blockX1);
    nvPushData(11, texture0BlockY0 | texture0BlockX1);
    nvPushData(12, blockY0 | blockX1);

    nvPushData(13, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                   NV056_SET_BEGIN_END | 0x40000);
    nvPushData(14, NV056_SET_BEGIN_END_OP_END);

    nvPusherAdjust(15);

#ifdef  DEBUG
    if (moCompDebugLevel > 1)
        nvPusherStart(TRUE);
#endif  // DEBUG

} /* nvDoCelsiusBackwardHDFieldPrediction */



#if 0
/*
 * nvDualPrimeArithmetic
 *
 * Performs new prediction motion vectors from original and differential vectors
 *
 */
void __stdcall nvDualPrimeArithmetic(short DMV[][2],
                                     short *differentialMotionVector,
                                     short horizontalMotionVector,
                                     short verticalMotionVector)
{

    if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_FRAME) {
        if (pDriverData->bMCTopFieldFirst) {
            // Vector for prediction of top field from bottom field
            DMV[0][0] = ((horizontalMotionVector + (horizontalMotionVector > 0)) >> 1) +
                          differentialMotionVector[0];
            DMV[0][1] = ((verticalMotionVector + (verticalMotionVector > 0)) >> 1) +
                          differentialMotionVector[1] - 1;

            // Vector for prediction of bottom field from top field
            DMV[1][0] = ((3*horizontalMotionVector + (horizontalMotionVector > 0)) >> 1) +
                          differentialMotionVector[0];
            DMV[1][1] = ((3*verticalMotionVector + (verticalMotionVector > 0)) >> 1) +
                          differentialMotionVector[1] + 1;
        } else {
            // Vector for prediction of top field from bottom field
            DMV[0][0] = ((3*horizontalMotionVector + (horizontalMotionVector > 0)) >> 1) +
                          differentialMotionVector[0];
            DMV[0][1] = ((3*verticalMotionVector + (verticalMotionVector > 0)) >> 1) +
                          differentialMotionVector[1] - 1;

            // Vector for prediction of bottom field from top field
            DMV[1][0] = ((horizontalMotionVector + (horizontalMotionVector > 0)) >> 1) +
                          differentialMotionVector[0];
            DMV[1][1] = ((verticalMotionVector + (verticalMotionVector > 0)) >> 1) +
                          differentialMotionVector[1] + 1;
        }
    } else { // Vector for prediction for field of opposite 'parity'
        DMV[0][0] = ((horizontalMotionVector + (horizontalMotionVector > 0)) >> 1) +
                      differentialMotionVector[0];
        DMV[0][1] = ((verticalMotionVector + (verticalMotionVector > 0)) >> 1) +
                      differentialMotionVector[1];

        // Correct for vertical field shift
        if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD)
            DMV[0][1]--;
        else
            DMV[0][1]++;
    }

} /* nvDualPrimeArithmetic */

#endif

/*
 * nvPredictCelsiusFrameLumaMacroblock
 *
 * Determines what type of prediction to apply to the macroblock and
 * calls the appropriate function.
 *
 * Note: All geometry sent to prediction functions is in quarter pel units
 *
 */
DWORD __stdcall nvPredictCelsiusFrameLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
//    short dmvector[2];
//    short DMV[2][2];

    SET_LUMA_DATA_FORMAT();
    
    // We don't currently support spatial scalability

    nvMoCompParams.blockWidth = 64 * numCombinedMacroblocks;
    nvMoCompParams.blockX = pMacroblock->hOffset << 2;

    if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_B) &&
        ((pMacroblock->macroblockType & (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) ==
        (MB_MOTION_FORWARD | MB_MOTION_BACKWARD))) {

        if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME) { // Frame based prediction

            nvMoCompParams.forwardField = 0;
            nvMoCompParams.backwardField = 0;
            nvMoCompParams.destinationField = 0;
            nvMoCompParams.blockHeight = 128;
            nvMoCompParams.blockY = pMacroblock->vOffset << 3;
            nvMoCompParams.forwardHorizontalVector = pMacroblock->PMV[0][0][0] << 1;
            nvMoCompParams.forwardVerticalVector = pMacroblock->PMV[0][0][1] << 2;
            nvMoCompParams.backwardHorizontalVector = pMacroblock->PMV[0][1][0] << 1;
            nvMoCompParams.backwardVerticalVector = pMacroblock->PMV[0][1][1] << 2;

            nvDoBidirectionalFieldPrediction(FALSE);

        } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD) { // Field based prediction

            nvMoCompParams.blockHeight = 64;
            nvMoCompParams.blockY = pMacroblock->vOffset << 2;

            if (nvMoCompParams.surfaceLumaPitch >= 1024) {
            
                if (nvMoCompParams.destinationFieldIs0) {
                    // Top field prediction
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                    nvMoCompParams.destinationField = 0;
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0] << 1) & 0xFFFEFFFF;

                    nvDoBidirectionalFieldPrediction(FALSE);
                } else {
                    // Bottom field prediction
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[1][0];
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[1][1];
                    nvMoCompParams.destinationField = 1;
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

                    nvDoBidirectionalFieldPrediction(FALSE);
                }
            } else {
            
                // Top field prediction
                nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                nvMoCompParams.destinationField = 0;
                *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0] << 1) & 0xFFFEFFFF;

                nvMoCompParams.blockY2 = nvMoCompParams.blockY;

                // Bottom field prediction
                nvMoCompParams.forwardField2 = pMacroblock->fieldSelect[1][0];
                nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
                nvMoCompParams.destinationField2 = 1;
                *(long *)&nvMoCompParams.forwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;
                *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

                nvDoTwoBidirectionalFieldPredictions(FALSE);
            }
            
        } else {
            // Error
            return FALSE;
        }
    } else {
        if ((pMacroblock->macroblockType & MB_MOTION_FORWARD) ||
            (pDriverData->bMCPictureCodingType == PICTURE_TYPE_P)) {

            if ((pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME) ||
                (!(pMacroblock->macroblockType & MB_MOTION_FORWARD))) {
                
                nvMoCompParams.forwardField = 0;
                nvMoCompParams.destinationField = 0;
                nvMoCompParams.blockHeight = 128;
                nvMoCompParams.blockY = pMacroblock->vOffset << 3;
                nvMoCompParams.forwardHorizontalVector = pMacroblock->PMV[0][0][0] << 1;
                nvMoCompParams.forwardVerticalVector = pMacroblock->PMV[0][0][1] << 2;

                nvDoForwardFieldPrediction(FALSE);

            } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD) { // Field based prediction

                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                if (nvMoCompParams.surfaceLumaPitch >= 1024) {

                    if (nvMoCompParams.destinationFieldIs0) {
                        // Top field prediction
                        nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                        nvMoCompParams.destinationField = 0;
                        *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;

                        nvDoForwardFieldPrediction(FALSE);
                    } else {
                        // Bottom field prediction
                        nvMoCompParams.forwardField = pMacroblock->fieldSelect[1][0];
                        nvMoCompParams.destinationField = 1;
                        *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;

                        nvDoForwardFieldPrediction(FALSE);
                    }
                } else {
                                                                        
                    // Top field prediction
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                    nvMoCompParams.destinationField = 0;
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;

                    nvMoCompParams.blockY2 = nvMoCompParams.blockY;

                    // Bottom field prediction
                    nvMoCompParams.forwardField2 = pMacroblock->fieldSelect[1][0];
                    nvMoCompParams.destinationField2 = 1;
                    *(long *)&nvMoCompParams.forwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;

                    nvDoTwoForwardFieldPredictions(FALSE);
                }
                
            } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_DP) { // Dual prime prediction

                // Calculate derived motion vectors
                // nvDualPrimeArithmetic(DMV,
                //                      dmvector,
                //                      pMacroblock->PMV[0][0][0],
                //                      (short)(pMacroblock->PMV[0][0][1] >> 1));

                pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDualPrimeSurface;

                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                if (nvMoCompParams.surfaceLumaPitch >= 1024) {

                    if (nvMoCompParams.destinationFieldIs0) {
                        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                      NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                        nvPushData(1, VIDMEM_OFFSET(pSurf_lcl->lpGbl->fpVidMem + nvMoCompParams.surfaceLumaPitch));

                        nvPusherAdjust(2);
                        
                        nvMoCompParams.currentBackwardField = 1;

                        // Predict top field from top field
                        // and add to top field from bottom field
                        nvMoCompParams.forwardField = 0;
                        nvMoCompParams.backwardField = 1;
                        nvMoCompParams.destinationField = 0;
                        *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
                        *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;

                        nvDoBidirectionalFieldPrediction(FALSE);

                    } else {
                        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                      NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                        nvPushData(1, VIDMEM_OFFSET(pSurf_lcl->lpGbl->fpVidMem));

                        nvPusherAdjust(2);

                        nvMoCompParams.currentBackwardField = 0;

                        // Predict bottom field from bottom field
                        // and add to bottom field from top field
                        nvMoCompParams.forwardField = 1;
                        nvMoCompParams.backwardField = 0;
                        nvMoCompParams.destinationField = 1;
                        *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
                        *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

                        nvDoBidirectionalFieldPrediction(FALSE);
                    }

                    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface;

                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                    nvPushData(1, VIDMEM_OFFSET(pSurf_lcl->lpGbl->fpVidMem));

                    nvPusherAdjust(2);

                    nvMoCompParams.currentBackwardField = 0;
                    nvMoCompParams.backwardField = 0;
                    
                } else {
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                    nvPushData(1, VIDMEM_OFFSET(pSurf_lcl->lpGbl->fpVidMem));

                    nvPusherAdjust(2);

                    // Predict top field from top field
                    // and add to top field from bottom field
                    nvMoCompParams.forwardField = 0;
                    nvMoCompParams.backwardField = 1;
                    nvMoCompParams.destinationField = 0;
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;

                    nvDoBidirectionalFieldPrediction(FALSE);

                    // Predict bottom field from bottom field
                    // and add to bottom field from top field
                    nvMoCompParams.forwardField = 1;
                    nvMoCompParams.backwardField = 0;
                    nvMoCompParams.destinationField = 1;
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

                    nvDoBidirectionalFieldPrediction(FALSE);

                    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface;

                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                    nvPushData(1, VIDMEM_OFFSET(pSurf_lcl->lpGbl->fpVidMem));

                    nvPusherAdjust(2);

                }
                
            } else {
                // Error
                return FALSE;
            }
        }

        if (pMacroblock->macroblockType & MB_MOTION_BACKWARD) {

            if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME) { // Frame based prediction

                nvMoCompParams.backwardField = 0;
                nvMoCompParams.destinationField = 0;
                nvMoCompParams.blockHeight = 128;
                nvMoCompParams.blockY = pMacroblock->vOffset << 3;
                nvMoCompParams.backwardHorizontalVector = pMacroblock->PMV[0][1][0] << 1;
                nvMoCompParams.backwardVerticalVector = pMacroblock->PMV[0][1][1] << 2;

                nvDoBackwardFieldPrediction(FALSE);

            } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD) { // Field based prediction

                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;

                if (nvMoCompParams.surfaceLumaPitch >= 1024) {

                    if (nvMoCompParams.destinationFieldIs0) {
                        // Top field prediction
                        nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                        nvMoCompParams.destinationField = 0;
                        *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0] << 1) & 0xFFFEFFFF;

                        nvDoBackwardFieldPrediction(FALSE);
                    } else {
                        // Bottom field prediction
                        nvMoCompParams.backwardField = pMacroblock->fieldSelect[1][1];
                        nvMoCompParams.destinationField = 1;
                        *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

                        nvDoBackwardFieldPrediction(FALSE);
                    }
                } else {

                    // Top field prediction
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                    nvMoCompParams.destinationField = 0;
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0] << 1) & 0xFFFEFFFF;

                    nvMoCompParams.blockY2 = nvMoCompParams.blockY;

                    // Bottom field prediction
                    nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
                    nvMoCompParams.destinationField2 = 1;
                    *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

                    nvDoTwoBackwardFieldPredictions(FALSE);

                }
            }
        }
    }

    return TRUE;

} /* nvPredictCelsiusFrameLumaMacroblock */


/*
 * nvPredictCelsiusFrameChromaMacroblock
 *
 * Determines what type of prediction to apply to the macroblock and
 * calls the appropriate function.
 *
 * Note: All geometry sent to prediction functions is in quarter pel units.
 *       This function assumes chroma format is interleaved CrCb so predictions are
 *       performed at twice the horizontal offset and width so that only 1 pass is required.
 *       This 16 bit pixel format also requires that the prediction functions be notified
 *       that they must use a pitch of half the default size when attempting to access field 1.
 *
 */
DWORD __stdcall nvPredictCelsiusFrameChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
//    short dmvector[2];
//    short DMV[2][2];

    SET_CHROMA_DATA_FORMAT();
    
    // We don't currently support spatial scalability

    nvMoCompParams.destinationField = 0;
    nvMoCompParams.forwardField = 0;
    nvMoCompParams.backwardField = 0;
    nvMoCompParams.blockWidth = 32 * numCombinedMacroblocks;
    nvMoCompParams.blockX = pMacroblock->hOffset << 1;

    if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_B) &&
        ((pMacroblock->macroblockType & (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) ==
        (MB_MOTION_FORWARD | MB_MOTION_BACKWARD))) {

        if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME) { // Frame based prediction

            if (pMacroblock->PMV[0][0][0] < 0) 
                pMacroblock->PMV[0][0][0] += 1; // round toward 0

            if (pMacroblock->PMV[0][0][1] < 0) 
                pMacroblock->PMV[0][0][1] += 1; // round toward 0

            if (pMacroblock->PMV[0][1][0] < 0) 
                pMacroblock->PMV[0][1][0] += 1; // round toward 0

            if (pMacroblock->PMV[0][1][1] < 0) 
                pMacroblock->PMV[0][1][1] += 1; // round toward 0

            nvMoCompParams.blockHeight = 64;
            nvMoCompParams.blockY = pMacroblock->vOffset << 2;
            nvMoCompParams.forwardHorizontalVector = pMacroblock->PMV[0][0][0] & 0xFFFE;
            nvMoCompParams.forwardVerticalVector = (pMacroblock->PMV[0][0][1] & 0xFFFE) << 1;
            nvMoCompParams.backwardHorizontalVector = pMacroblock->PMV[0][1][0] & 0xFFFE;
            nvMoCompParams.backwardVerticalVector = (pMacroblock->PMV[0][1][1] & 0xFFFE) << 1;

            nvDoBidirectionalFieldPrediction(TRUE);

        } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD) { // Field based prediction

            nvMoCompParams.blockHeight = 32;
            nvMoCompParams.blockY = pMacroblock->vOffset << 1;

            if (nvMoCompParams.surfaceLumaPitch >= 1024) {

                if (nvMoCompParams.destinationFieldIs0) {
                
                    if (pMacroblock->PMV[0][0][0] < 0) 
                        pMacroblock->PMV[0][0][0] += 1; // round toward 0

                    if (pMacroblock->PMV[0][0][1] < 0) 
                        pMacroblock->PMV[0][0][1] += 1; // round toward 0

                    if (pMacroblock->PMV[0][1][0] < 0) 
                        pMacroblock->PMV[0][1][0] += 1; // round toward 0

                    if (pMacroblock->PMV[0][1][1] < 0) 
                        pMacroblock->PMV[0][1][1] += 1; // round toward 0

                    // Top field prediction
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                    nvMoCompParams.destinationField = 0;
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]) & 0xFFFEFFFE;
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0]) & 0xFFFEFFFE;

                    nvDoBidirectionalFieldPrediction(TRUE);

                } else {
                
                    if (pMacroblock->PMV[1][0][0] < 0) 
                        pMacroblock->PMV[1][0][0] += 1; // round toward 0

                    if (pMacroblock->PMV[1][0][1] < 0) 
                        pMacroblock->PMV[1][0][1] += 1; // round toward 0

                    if (pMacroblock->PMV[1][1][0] < 0) 
                        pMacroblock->PMV[1][1][0] += 1; // round toward 0

                    if (pMacroblock->PMV[1][1][1] < 0) 
                        pMacroblock->PMV[1][1][1] += 1; // round toward 0

                    // Bottom field prediction
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[1][0];
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[1][1];
                    nvMoCompParams.destinationField = 1;
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0]) & 0xFFFEFFFE;
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][1][0]) & 0xFFFEFFFE;

                    nvDoBidirectionalFieldPrediction(TRUE);
                }
            } else {

                if (pMacroblock->PMV[0][0][0] < 0) 
                    pMacroblock->PMV[0][0][0] += 1; // round toward 0

                if (pMacroblock->PMV[0][0][1] < 0) 
                    pMacroblock->PMV[0][0][1] += 1; // round toward 0

                if (pMacroblock->PMV[0][1][0] < 0) 
                    pMacroblock->PMV[0][1][0] += 1; // round toward 0

                if (pMacroblock->PMV[0][1][1] < 0) 
                    pMacroblock->PMV[0][1][1] += 1; // round toward 0

                if (pMacroblock->PMV[1][0][0] < 0) 
                    pMacroblock->PMV[1][0][0] += 1; // round toward 0

                if (pMacroblock->PMV[1][0][1] < 0) 
                    pMacroblock->PMV[1][0][1] += 1; // round toward 0

                if (pMacroblock->PMV[1][1][0] < 0) 
                    pMacroblock->PMV[1][1][0] += 1; // round toward 0

                if (pMacroblock->PMV[1][1][1] < 0) 
                    pMacroblock->PMV[1][1][1] += 1; // round toward 0

                // Top field prediction
                nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                nvMoCompParams.destinationField = 0;
                *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]) & 0xFFFEFFFE;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0]) & 0xFFFEFFFE;

                nvMoCompParams.blockY2 = nvMoCompParams.blockY;

                // Bottom field prediction
                nvMoCompParams.forwardField2 = pMacroblock->fieldSelect[1][0];
                nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
                nvMoCompParams.destinationField2 = 1;
                *(long *)&nvMoCompParams.forwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][0][0]) & 0xFFFEFFFE;
                *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0]) & 0xFFFEFFFE;

                nvDoTwoBidirectionalFieldPredictions(TRUE);
            }
            
        } else {
            // Error
            return FALSE;
        }
    } else {
        if ((pMacroblock->macroblockType & MB_MOTION_FORWARD) ||
            (pDriverData->bMCPictureCodingType == PICTURE_TYPE_P)) {

            if ((pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME) ||
                (!(pMacroblock->macroblockType & MB_MOTION_FORWARD))) {
            
                if (pMacroblock->PMV[0][0][0] < 0) 
                    pMacroblock->PMV[0][0][0] += 1; // round toward 0

                if (pMacroblock->PMV[0][0][1] < 0) 
                    pMacroblock->PMV[0][0][1] += 1; // round toward 0

                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.forwardHorizontalVector = pMacroblock->PMV[0][0][0] & 0xFFFE;
                nvMoCompParams.forwardVerticalVector = (pMacroblock->PMV[0][0][1] & 0xFFFE) << 1;

                nvDoForwardFieldPrediction(TRUE);

            } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD) { // Field based prediction

                nvMoCompParams.blockHeight = 32;
                nvMoCompParams.blockY = pMacroblock->vOffset << 1;

                if (nvMoCompParams.surfaceLumaPitch >= 1024) {

                    if (nvMoCompParams.destinationFieldIs0) {

                        if (pMacroblock->PMV[0][0][0] < 0) 
                            pMacroblock->PMV[0][0][0] += 1; // round toward 0

                        if (pMacroblock->PMV[0][0][1] < 0) 
                            pMacroblock->PMV[0][0][1] += 1; // round toward 0

                        // Top field prediction
                        nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                        nvMoCompParams.destinationField = 0;
                        *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]) & 0xFFFEFFFE;

                        nvDoForwardFieldPrediction(TRUE);

                    } else {

                        if (pMacroblock->PMV[1][0][0] < 0) 
                            pMacroblock->PMV[1][0][0] += 1; // round toward 0
                            
                        if (pMacroblock->PMV[1][0][1] < 0) 
                            pMacroblock->PMV[1][0][1] += 1; // round toward 0
                        
                        // Bottom field prediction
                        nvMoCompParams.forwardField = pMacroblock->fieldSelect[1][0];
                        nvMoCompParams.destinationField = 1;
                        *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0]) & 0xFFFEFFFE;

                        nvDoForwardFieldPrediction(TRUE);
                    }
                } else {

                    if (pMacroblock->PMV[0][0][0] < 0) 
                        pMacroblock->PMV[0][0][0] += 1; // round toward 0

                    if (pMacroblock->PMV[0][0][1] < 0) 
                        pMacroblock->PMV[0][0][1] += 1; // round toward 0

                    if (pMacroblock->PMV[1][0][0] < 0) 
                        pMacroblock->PMV[1][0][0] += 1; // round toward 0
                        
                    if (pMacroblock->PMV[1][0][1] < 0) 
                        pMacroblock->PMV[1][0][1] += 1; // round toward 0
                    
                    // Top field prediction
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                    nvMoCompParams.destinationField = 0;
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]) & 0xFFFEFFFE;

                    nvMoCompParams.blockY2 = nvMoCompParams.blockY;

                    // Bottom field prediction
                    nvMoCompParams.forwardField2 = pMacroblock->fieldSelect[1][0];
                    nvMoCompParams.destinationField2 = 1;
                    *(long *)&nvMoCompParams.forwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][0][0]) & 0xFFFEFFFE;

                    nvDoTwoForwardFieldPredictions(TRUE);
                }

            } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_DP) { // Dual prime prediction

                // Calculate derived motion vectors
                // nvDualPrimeArithmetic(DMV,
                //                      dmvector,
                //                      pMacroblock->PMV[0][0][0],
                //                      (short)(pMacroblock->PMV[0][0][1] >> 1));

                pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDualPrimeSurface;

                nvMoCompParams.blockHeight = 32;
                nvMoCompParams.blockY = pMacroblock->vOffset << 1;

                if (nvMoCompParams.surfaceLumaPitch >= 1024) {

                    if (nvMoCompParams.destinationFieldIs0) {
                        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                      NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                        nvPushData(1, VIDMEM_OFFSET(pSurf_lcl->lpGbl->fpVidMem + nvMoCompParams.surfaceLumaPitch + nvMoCompParams.surfaceChromaOffset));

                        nvPusherAdjust(2);

                        if (pMacroblock->PMV[0][0][0] < 0) 
                            pMacroblock->PMV[0][0][0] += 1; // round toward 0

                        if (pMacroblock->PMV[0][0][1] < 0) 
                            pMacroblock->PMV[0][0][1] += 1; // round toward 0

                        if (pMacroblock->PMV[1][0][0] < 0) 
                            pMacroblock->PMV[1][0][0] += 1; // round toward 0

                        if (pMacroblock->PMV[1][0][1] < 0) 
                            pMacroblock->PMV[1][0][1] += 1; // round toward 0

                        nvMoCompParams.currentBackwardField = 1;

                        // Predict top field from top field
                        // and add to top field from bottom field
                        nvMoCompParams.forwardField = 0;
                        nvMoCompParams.backwardField = 1;
                        nvMoCompParams.destinationField = 0;
                        *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]) & 0xFFFEFFFE;
                        *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0]) & 0xFFFEFFFE;

                        nvDoBidirectionalFieldPrediction(TRUE);

                    } else {
                        nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                      NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                        nvPushData(1, VIDMEM_OFFSET((pSurf_lcl->lpGbl->fpVidMem + nvMoCompParams.surfaceChromaOffset)));

                        nvPusherAdjust(2);

                        if (pMacroblock->PMV[1][1][0] < 0) 
                            pMacroblock->PMV[1][1][0] += 1; // round toward 0

                        if (pMacroblock->PMV[1][1][1] < 0) 
                            pMacroblock->PMV[1][1][1] += 1; // round toward 0

                        nvMoCompParams.currentBackwardField = 0;

                        // Predict bottom field from bottom field
                        // and add to bottom field from top field
                        nvMoCompParams.forwardField = 1;
                        nvMoCompParams.backwardField = 0;
                        nvMoCompParams.destinationField = 1;
                        *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]) & 0xFFFEFFFE;
                        *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][1][0]) & 0xFFFEFFFE;

                        nvDoBidirectionalFieldPrediction(TRUE);
                    }

                    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface;

                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                    nvPushData(1, VIDMEM_OFFSET(pSurf_lcl->lpGbl->fpVidMem + nvMoCompParams.surfaceChromaOffset));

                    nvPusherAdjust(2);

                    nvMoCompParams.currentBackwardField = 0;
                    nvMoCompParams.backwardField = 0;
                    
                } else {
                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                    nvPushData(1, VIDMEM_OFFSET((pSurf_lcl->lpGbl->fpVidMem + nvMoCompParams.surfaceChromaOffset)));

                    nvPusherAdjust(2);

                    if (pMacroblock->PMV[0][0][0] < 0) 
                        pMacroblock->PMV[0][0][0] += 1; // round toward 0

                    if (pMacroblock->PMV[0][0][1] < 0) 
                        pMacroblock->PMV[0][0][1] += 1; // round toward 0

                    if (pMacroblock->PMV[1][0][0] < 0) 
                        pMacroblock->PMV[1][0][0] += 1; // round toward 0

                    if (pMacroblock->PMV[1][0][1] < 0) 
                        pMacroblock->PMV[1][0][1] += 1; // round toward 0

                    if (pMacroblock->PMV[1][1][0] < 0) 
                        pMacroblock->PMV[1][1][0] += 1; // round toward 0

                    if (pMacroblock->PMV[1][1][1] < 0) 
                        pMacroblock->PMV[1][1][1] += 1; // round toward 0

                    // Predict top field from top field
                    // and add to top field from bottom field
                    nvMoCompParams.forwardField = 0;
                    nvMoCompParams.backwardField = 1;
                    nvMoCompParams.destinationField = 0;
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]) & 0xFFFEFFFE;
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0]) & 0xFFFEFFFE;

                    nvDoBidirectionalFieldPrediction(TRUE);

                    // Predict bottom field from bottom field
                    // and add to bottom field from top field
                    nvMoCompParams.forwardField = 1;
                    nvMoCompParams.backwardField = 0;
                    nvMoCompParams.destinationField = 1;
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]) & 0xFFFEFFFE;
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][1][0]) & 0xFFFEFFFE;

                    nvDoBidirectionalFieldPrediction(TRUE);

                    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface;

                    nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                                  NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                    nvPushData(1, VIDMEM_OFFSET((pSurf_lcl->lpGbl->fpVidMem + nvMoCompParams.surfaceChromaOffset)));

                    nvPusherAdjust(2);
                }
                
            } else {
                // Error
                return FALSE;
            }
        }

        if (pMacroblock->macroblockType & MB_MOTION_BACKWARD) {

            if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FRAME) { // Frame based prediction

                if (pMacroblock->PMV[0][1][0] < 0) 
                    pMacroblock->PMV[0][1][0] += 1; // round toward 0

                if (pMacroblock->PMV[0][1][1] < 0) 
                    pMacroblock->PMV[0][1][1] += 1; // round toward 0

                nvMoCompParams.blockHeight = 64;
                nvMoCompParams.blockY = pMacroblock->vOffset << 2;
                nvMoCompParams.backwardHorizontalVector = pMacroblock->PMV[0][1][0] & 0xFFFE;
                nvMoCompParams.backwardVerticalVector = (pMacroblock->PMV[0][1][1] & 0xFFFE) << 1;

                nvDoBackwardFieldPrediction(TRUE);

            } else if (pMacroblock->motionType == FRAME_STRUCTURE_MOTION_FIELD) { // Field based prediction

                nvMoCompParams.blockHeight = 32;
                nvMoCompParams.blockY = pMacroblock->vOffset << 1;

                if (nvMoCompParams.surfaceLumaPitch >= 1024) {

                    if (nvMoCompParams.destinationFieldIs0) {

                        if (pMacroblock->PMV[0][1][0] < 0) 
                            pMacroblock->PMV[0][1][0] += 1; // round toward 0

                        if (pMacroblock->PMV[0][1][1] < 0) 
                            pMacroblock->PMV[0][1][1] += 1; // round toward 0

                        // Top field prediction
                        nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                        nvMoCompParams.destinationField = 0;
                        *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0]) & 0xFFFEFFFE;

                        nvDoBackwardFieldPrediction(TRUE);

                    } else {

                        if (pMacroblock->PMV[1][1][0] < 0) 
                            pMacroblock->PMV[1][1][0] += 1; // round toward 0

                        if (pMacroblock->PMV[1][1][1] < 0) 
                            pMacroblock->PMV[1][1][1] += 1; // round toward 0

                        // Bottom field prediction
                        nvMoCompParams.backwardField = pMacroblock->fieldSelect[1][1];
                        nvMoCompParams.destinationField = 1;
                        *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][1][0]) & 0xFFFEFFFE;

                        nvDoBackwardFieldPrediction(TRUE);
                    }
                } else {

                    if (pMacroblock->PMV[0][1][0] < 0) 
                        pMacroblock->PMV[0][1][0] += 1; // round toward 0

                    if (pMacroblock->PMV[0][1][1] < 0) 
                        pMacroblock->PMV[0][1][1] += 1; // round toward 0

                    if (pMacroblock->PMV[1][1][0] < 0) 
                        pMacroblock->PMV[1][1][0] += 1; // round toward 0

                    if (pMacroblock->PMV[1][1][1] < 0) 
                        pMacroblock->PMV[1][1][1] += 1; // round toward 0

                    // Top field prediction
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                    nvMoCompParams.destinationField = 0;
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0]) & 0xFFFEFFFE;

                    nvMoCompParams.blockY2 = nvMoCompParams.blockY;

                    // Bottom field prediction
                    nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
                    nvMoCompParams.destinationField2 = 1;
                    *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0]) & 0xFFFEFFFE;

                    nvDoTwoBackwardFieldPredictions(TRUE);
                }    
            }
        }
    }

    return TRUE;

} /* nvPredictCelsiusFrameChromaMacroblock */


/*
 * nvPredictCelsiusFieldLumaMacroblock
 *
 * Determines what type of prediction to apply to the macroblock and
 * calls the appropriate function.
 *
 * Note: All geometry sent to prediction functions is in quarter pel units
 *
 */
DWORD __stdcall nvPredictCelsiusFieldLumaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    unsigned long currentField;
    unsigned long doBackwardPrediction;
//    short dmvector[2];
//    short DMV[2][2];

    SET_LUMA_DATA_FORMAT();
    
    // We don't currently support spatial scalability

    // Destination field offset already set at init time
    nvMoCompParams.destinationField = 0;

    nvMoCompParams.blockWidth = 64 * numCombinedMacroblocks;
    nvMoCompParams.blockX = pMacroblock->hOffset << 2;
    nvMoCompParams.blockY = pMacroblock->vOffset << 2;

    if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_B) &&
        ((pMacroblock->macroblockType & (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) ==
        (MB_MOTION_FORWARD | MB_MOTION_BACKWARD))) {

        // Field based prediction
        if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) {

            nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
            nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
            nvMoCompParams.blockHeight = 64;
            *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
            *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0] << 1) & 0xFFFEFFFF;

            nvDoBidirectionalFieldPrediction(FALSE);

        } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {

            nvMoCompParams.blockHeight = 32;

            // Top half
            nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
            nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
            *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
            *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0] << 1) & 0xFFFEFFFF;

            if (nvMoCompParams.surfaceLumaPitch >= 1024) {

                nvDoBidirectionalFieldPrediction(FALSE);

                // Bottom half
                nvMoCompParams.forwardField = pMacroblock->fieldSelect[1][0];
                nvMoCompParams.backwardField = pMacroblock->fieldSelect[1][1];
                nvMoCompParams.blockY += 32;
                *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

                nvDoBidirectionalFieldPrediction(FALSE);

            } else {

                // Bottom half
                nvMoCompParams.destinationField2 = nvMoCompParams.destinationField;
                nvMoCompParams.forwardField2 = pMacroblock->fieldSelect[1][0];
                nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
                nvMoCompParams.blockY2 = nvMoCompParams.blockY + 32;
                *(long *)&nvMoCompParams.forwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;
                *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

                nvDoTwoBidirectionalFieldPredictions(FALSE);
            }
        } else {
            // Error
            return FALSE;
        }
    } else {
        if ((pMacroblock->macroblockType & MB_MOTION_FORWARD) ||
            (pDriverData->bMCPictureCodingType == PICTURE_TYPE_P)) {

            if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD)
                currentField = 0;
            else
                currentField = 1;

            doBackwardPrediction = 0; // previous frame

            // Determine which frame to use for prediction
            if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_P) &&
                 pDriverData->bMCSecondField &&
                (currentField != pMacroblock->fieldSelect[0][0]))
                doBackwardPrediction = 1; // same frame

            // Field based prediction
            if ((pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) ||
                (!(pMacroblock->macroblockType & MB_MOTION_FORWARD))) {

                nvMoCompParams.blockHeight = 64;

                if (doBackwardPrediction) {
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;

                    nvDoBackwardFieldPrediction(FALSE);
                } else {
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;

                    nvDoForwardFieldPrediction(FALSE);
                }
            } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {

                nvMoCompParams.blockHeight = 32;

                if (doBackwardPrediction) {
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;

                    nvDoBackwardFieldPrediction(FALSE);
                } else {
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;

                    nvDoForwardFieldPrediction(FALSE);
                }

                doBackwardPrediction = 0; // previous frame

                // Determine which frame to use for lower prediction
                if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_P) &&
                     pDriverData->bMCSecondField &&
                    (currentField != pMacroblock->fieldSelect[1][0]))
                    doBackwardPrediction = 1; // same frame

                nvMoCompParams.blockY += 32;

                if (doBackwardPrediction) {
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[1][0];
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;

                    nvDoBackwardFieldPrediction(FALSE);
                } else {
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[1][0];
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;

                    nvDoForwardFieldPrediction(FALSE);
                }
            } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_DP) { // Dual prime prediction

                if (pDriverData->bMCSecondField)
                    doBackwardPrediction = 1; // same frame
                else
                    doBackwardPrediction = 0; // previous frame

                // Calculate derived motion vectors
                // nvDualPrimeArithmetic(DMV,
                //                      dmvector,
                //                      pMacroblock->PMV[0][0][0],
                //                      pMacroblock->PMV[0][0][1]);


                if (doBackwardPrediction)
                    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
                else
                    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDualPrimeSurface;

                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(1, VIDMEM_OFFSET(pSurf_lcl->lpGbl->fpVidMem));

                nvPusherAdjust(2);
                
                // Predict from field of same parity
                // added to field of opposite parity
                nvMoCompParams.forwardField = (BYTE)currentField;
                nvMoCompParams.backwardField = (BYTE)currentField ^ 1;
                nvMoCompParams.blockHeight = 64;
                *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0] << 1) & 0xFFFEFFFF;
                // nvMoCompParams.backwardHorizontalVector = DMV[0][0];
                // nvMoCompParams.backwardVerticalVector = DMV[0][1];
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0] << 1) & 0xFFFEFFFF;

                nvDoBidirectionalFieldPrediction(FALSE);

                pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface;

                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(1, VIDMEM_OFFSET(pSurf_lcl->lpGbl->fpVidMem));

                nvPusherAdjust(2);

            } else {
                // Error
                return FALSE;
            }
        }

        if (pMacroblock->macroblockType & MB_MOTION_BACKWARD) {

            // Field based prediction
            if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) {

                nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                nvMoCompParams.blockHeight = 64;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0] << 1) & 0xFFFEFFFF;

                nvDoBackwardFieldPrediction(FALSE);

            } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {

                nvMoCompParams.blockHeight = 32;

                nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0] << 1) & 0xFFFEFFFF;

                if (nvMoCompParams.surfaceLumaPitch >= 1024) {

                    nvDoBackwardFieldPrediction(FALSE);

                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[1][1];
                    nvMoCompParams.blockY += 32;
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

                    nvDoBackwardFieldPrediction(FALSE);

                } else {

                    nvMoCompParams.destinationField2 = nvMoCompParams.destinationField;
                    nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
                    nvMoCompParams.blockY2 = nvMoCompParams.blockY + 32;
                    *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0] << 1) & 0xFFFEFFFF;

                    nvDoTwoBackwardFieldPredictions(FALSE);
                }
            } else {
                // Error
                return FALSE;
            }
        }
    }

    return TRUE;

} /* nvPredictCelsiusFieldLumaMacroblock */


/*
 * nvPredictCelsiusFieldChromaMacroblock
 *
 * Determines what type of prediction to apply to the macroblock and
 * calls the appropriate function.
 *
 * Note: All geometry sent to prediction functions is in quarter pel units.
 *       This function assumes chroma format is interleaved CrCb so predictions are
 *       performed at twice the horizontal offset and width so that only 1 pass is required.
 *       This 16 bit pixel format also requires that the prediction functions be notified
 *       that they must use a pitch of half the default size when attempting to access field 1.
 *
 */
DWORD __stdcall nvPredictCelsiusFieldChromaMacroblock(LPNVDECODEMACROBLOCK pMacroblock, WORD numCombinedMacroblocks)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    unsigned long currentField;
    unsigned long doBackwardPrediction;
//    short dmvector[2];
//    short DMV[2][2];

    SET_CHROMA_DATA_FORMAT();
    
    // We don't currently support spatial scalability

    // Destination field offset already set at init time
    nvMoCompParams.destinationField = 0;

    nvMoCompParams.blockWidth = 32 * numCombinedMacroblocks;
    nvMoCompParams.blockX = pMacroblock->hOffset << 1;
    nvMoCompParams.blockY = pMacroblock->vOffset << 1;

    if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_B) &&
        ((pMacroblock->macroblockType & (MB_MOTION_FORWARD | MB_MOTION_BACKWARD)) ==
        (MB_MOTION_FORWARD | MB_MOTION_BACKWARD))) {

        // Field based prediction
        if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) {

            nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
            nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
            nvMoCompParams.blockHeight = 32;
            *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]);
            *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0]);

            nvDoBidirectionalFieldPrediction(TRUE);

        } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {

            nvMoCompParams.blockHeight = 16;

            // Top half
            nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
            nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
            *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]);
            *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0]);

            if (nvMoCompParams.surfaceLumaPitch >= 1024) {

                nvDoBidirectionalFieldPrediction(TRUE);

                // Bottom half
                nvMoCompParams.forwardField = pMacroblock->fieldSelect[1][0];
                nvMoCompParams.backwardField = pMacroblock->fieldSelect[1][1];
                nvMoCompParams.blockY += 16;
                *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0]);
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][1][0]);

                nvDoBidirectionalFieldPrediction(TRUE);

            } else {

                // Bottom half
                nvMoCompParams.destinationField2 = nvMoCompParams.destinationField;
                nvMoCompParams.forwardField2 = pMacroblock->fieldSelect[1][0];
                nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
                nvMoCompParams.blockY2 = nvMoCompParams.blockY + 16;
                *(long *)&nvMoCompParams.forwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][0][0]);
                *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0]);

                nvDoTwoBidirectionalFieldPredictions(TRUE);
            }
        } else {
            // Error
            return FALSE;
        }
    } else {
        if ((pMacroblock->macroblockType & MB_MOTION_FORWARD) ||
            (pDriverData->bMCPictureCodingType == PICTURE_TYPE_P)) {

            if (pDriverData->bMCPictureStructure == PICTURE_STRUCTURE_TOP_FIELD)
                currentField = 0;
            else
                currentField = 1;

            doBackwardPrediction = 0; // previous frame

            // Determine which frame to use for prediction
            if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_P) &&
                 pDriverData->bMCSecondField &&
                (currentField != pMacroblock->fieldSelect[0][0]))
                doBackwardPrediction = 1; // same frame

            // Field based prediction
            if ((pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) ||
                (!(pMacroblock->macroblockType & MB_MOTION_FORWARD))) {

                nvMoCompParams.blockHeight = 32;

                if (doBackwardPrediction) {

                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]);

                    nvDoBackwardFieldPrediction(TRUE);
                } else {
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]);

                    nvDoForwardFieldPrediction(TRUE);
                }
            } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {

                nvMoCompParams.blockHeight = 16;

                if (doBackwardPrediction) {
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]);

                    nvDoBackwardFieldPrediction(TRUE);
                } else {
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[0][0];
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]);

                    nvDoForwardFieldPrediction(TRUE);
                }

                doBackwardPrediction = 0; // previous frame

                // Determine which frame to use for lower prediction
                if ((pDriverData->bMCPictureCodingType == PICTURE_TYPE_P) &&
                     pDriverData->bMCSecondField &&
                    (currentField != pMacroblock->fieldSelect[1][0]))
                    doBackwardPrediction = 1; // same frame

                nvMoCompParams.blockY += 16;

                if (doBackwardPrediction) {
                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[1][0];
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0]);

                    nvDoBackwardFieldPrediction(TRUE);
                } else {
                    nvMoCompParams.forwardField = pMacroblock->fieldSelect[1][0];
                    *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0]);

                    nvDoForwardFieldPrediction(TRUE);
                }
            } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_DP) { // Dual prime prediction

                if (pDriverData->bMCSecondField)
                    doBackwardPrediction = 1; // same frame
                else
                    doBackwardPrediction = 0; // previous frame

                // Calculate derived motion vectors
                // nvDualPrimeArithmetic(DMV,
                //                      dmvector,
                //                      pMacroblock->PMV[0][0][0],
                //                      pMacroblock->PMV[0][0][1]);

                if (doBackwardPrediction)
                    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDestinationSurface;
                else
                    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCDualPrimeSurface;

                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(1, VIDMEM_OFFSET((pSurf_lcl->lpGbl->fpVidMem + nvMoCompParams.surfaceChromaOffset)));

                nvPusherAdjust(2);

                // Predict from field of same parity
                // added to field of opposite parity
                nvMoCompParams.forwardField = (BYTE)currentField;
                nvMoCompParams.backwardField = (BYTE)currentField ^ 1;
                nvMoCompParams.blockHeight = 32;
                *(long *)&nvMoCompParams.forwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][0][0]);
                // nvMoCompParams.backwardHorizontalVector = DMV[0][0] >> 1;
                // nvMoCompParams.backwardVerticalVector = DMV[0][1] >> 1;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][0][0]);

                nvDoBidirectionalFieldPrediction(TRUE);

                pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL)pDriverData->dwMCBackwardSurface;

                nvPushData(0, dDrawSubchannelOffset(NV_DD_CELSIUS) +
                              NV056_SET_TEXTURE_OFFSET(1) | 0x40000);
                nvPushData(1, VIDMEM_OFFSET((pSurf_lcl->lpGbl->fpVidMem + nvMoCompParams.surfaceChromaOffset)));

                nvPusherAdjust(2);

            } else {
                // Error
                return FALSE;
            }
        }

        if (pMacroblock->macroblockType & MB_MOTION_BACKWARD) {

            // Field based prediction
            if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_FIELD) {

                nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                nvMoCompParams.blockHeight = 32;
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0]);

                nvDoBackwardFieldPrediction(TRUE);

            } else if (pMacroblock->motionType == FIELD_STRUCTURE_MOTION_16X8) {

                nvMoCompParams.blockHeight = 16;

                nvMoCompParams.backwardField = pMacroblock->fieldSelect[0][1];
                *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[0][1][0]);

                if (nvMoCompParams.surfaceLumaPitch >= 1024) {

                    nvDoBackwardFieldPrediction(TRUE);

                    nvMoCompParams.backwardField = pMacroblock->fieldSelect[1][1];
                    nvMoCompParams.blockY += 16;
                    *(long *)&nvMoCompParams.backwardHorizontalVector = (*(long *)&pMacroblock->PMV[1][1][0]);

                    nvDoBackwardFieldPrediction(TRUE);

                } else {

                    nvMoCompParams.destinationField2 = nvMoCompParams.destinationField;
                    nvMoCompParams.backwardField2 = pMacroblock->fieldSelect[1][1];
                    nvMoCompParams.blockY2 = nvMoCompParams.blockY + 16;
                    *(long *)&nvMoCompParams.backwardHorizontalVector2 = (*(long *)&pMacroblock->PMV[1][1][0]);

                    nvDoTwoBackwardFieldPredictions(TRUE);
                }
            } else {
                // Error
                return FALSE;
            }
        }
    }

    return TRUE;

} /* nvPredictCelsiusFieldChromaMacroblock */


#endif  // NVARCH >= 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvAccess.cpp ===
//======================================================================
// Module:		nvAccess.cpp
// Description:	Generic kernel access routines that are neutral to the calling OS
// 
//  Copyright (C) 2000 NVidia Corporation.  All Rights Reserved.
//======================================================================

#include "nvprecomp.h"

#ifdef NV_USE_ZW_PFUNCS

NV_ZW_FILE_IO_FUNCS NvZwFileIoFuncs = { NULL, NULL, NULL, NULL };

void NvInitFileIoFuncs( PDEV *ppdev )
{
    DWORD dwReturnStatus, dwReturnSize;

    dwReturnStatus = EngDeviceIoControl( ppdev->hDriver, IOCTL_VIDEO_ZW_GET_FILE_IO_FUNCS,
                                         NULL, 0ul,
                                         &NvZwFileIoFuncs, sizeof(NvZwFileIoFuncs),
                                         &dwReturnSize );
}

#endif

void NVAnsiToUnicode(WCHAR *destString, TCHAR *srcString)
{
    int sLen;

    sLen = nvStrLen(srcString) + 1;

    while (sLen)
    {
        *destString = (USHORT)(*(UCHAR *)srcString);
        destString++;
        srcString++;
        sLen--;
    }
}

void NVUnicodeToAnsi(TCHAR *destString, WCHAR *srcString) 
{

    DWORD dwNullCnt = 0;
    DWORD dwPos = 0;

    while (srcString[dwPos] != 0) {
        destString[dwPos] = (UCHAR)srcString[dwPos];
        dwPos++;
    }
    destString[dwPos] = '\0';
}

HANDLE NvCreateFile( LPCTSTR lpFileName,                         // file name
                   DWORD dwDesiredAccess,                      // access mode
                   DWORD dwSharedMode,                          // share mode
                   LPSECURITY_ATTRIBUTES lpSecurityAttributes, // SD
                   DWORD dwCreationDisposition,                // how to create
                   DWORD dwFlagsAndAttributes,                 // file attributes
                   HANDLE hTemplateFile                        // handle to template file
                   ) {

    HANDLE hFile = INVALID_HANDLE_VALUE;

#ifndef WINNT
    // Standard Win32 file creation
    hFile = CreateFile(lpFileName, dwDesiredAccess, dwSharedMode, lpSecurityAttributes, dwCreationDisposition,
                dwFlagsAndAttributes, hTemplateFile);
#else

    NV_ZW_CREATE_FILE_IN CreateFileIn;
    TCHAR device[64];
    DWORD dwReturnStatus, dwReturnSize = 0ul;

    nvAssert( pDriverData != NULL );
    if( pDriverData == NULL ) return INVALID_HANDLE_VALUE;

    if( ppdev == NULL ) return INVALID_HANDLE_VALUE;

    // Mass parameter conversion

    if (dwDesiredAccess & GENERIC_READ) {
        CreateFileIn.ulDesiredAccess = CreateFileIn.ulDesiredAccess ^ GENERIC_READ;
        CreateFileIn.ulDesiredAccess |= FILE_GENERIC_READ;
    }
    if (dwDesiredAccess & GENERIC_WRITE) {
        CreateFileIn.ulDesiredAccess = CreateFileIn.ulDesiredAccess ^ GENERIC_WRITE;
        CreateFileIn.ulDesiredAccess |= FILE_GENERIC_WRITE;
    }
    if (dwDesiredAccess & GENERIC_EXECUTE) {
        CreateFileIn.ulDesiredAccess = CreateFileIn.ulDesiredAccess ^ GENERIC_EXECUTE;
        CreateFileIn.ulDesiredAccess |= FILE_GENERIC_EXECUTE;
    }

    // get string name and make it Unicode, with the device path (\??\c:\booyah.txt, etc...)
    nvSprintf( device, TEXT("\\??\\%s"), lpFileName);

    NVAnsiToUnicode(CreateFileIn.pwcObjectBuffer, device);
    CreateFileIn.uiObjectName.Length = (USHORT)nvStrLen(device)*sizeof(WCHAR);
    CreateFileIn.uiObjectName.MaximumLength = 256*sizeof(WCHAR);
    CreateFileIn.uiObjectName.Buffer = CreateFileIn.pwcObjectBuffer;
    InitializeObjectAttributes(&CreateFileIn.ObjectAttributes, &CreateFileIn.uiObjectName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    CreateFileIn.liAllocationSize.QuadPart = 0;

    CreateFileIn.ulShareAccess = dwSharedMode;

    //CreationDisposition
    if (dwCreationDisposition == CREATE_NEW)
        CreateFileIn.ulCreateDisposition = FILE_CREATE;
    else if (dwCreationDisposition == CREATE_ALWAYS)
        CreateFileIn.ulCreateDisposition = FILE_SUPERSEDE;
    else if (dwCreationDisposition == OPEN_EXISTING)
        CreateFileIn.ulCreateDisposition = FILE_OPEN;
    else if (dwCreationDisposition == OPEN_ALWAYS)
        CreateFileIn.ulCreateDisposition = FILE_OPEN_IF;
    else if (dwCreationDisposition == TRUNCATE_EXISTING)
        CreateFileIn.ulCreateDisposition = FILE_OVERWRITE;

    CreateFileIn.ulDesiredAccess = dwDesiredAccess;

    CreateFileIn.ulCreateOptions = FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT;

    CreateFileIn.pvEaBuffer = NULL;
    CreateFileIn.ulEaLength = 0ul;

#ifdef NV_USE_ZW_PFUNCS
    if( NvZwFileIoFuncs.pvZwCreateFile == NULL ) {
        // Init the function pointers
        NvInitFileIoFuncs( ppdev );
        if( NvZwFileIoFuncs.pvZwCreateFile == NULL )
            return NULL;
    }

    {
        IO_STATUS_BLOCK IoBlock;
        dwReturnStatus = NvZwFileIoFuncs.pvZwCreateFile( &hFile,
                                       CreateFileIn.ulDesiredAccess,
                                       &CreateFileIn.ObjectAttributes,
                                       &IoBlock,
                                       &CreateFileIn.liAllocationSize,
                                       CreateFileIn.ulFileAttributes,
                                       CreateFileIn.ulShareAccess,
                                       CreateFileIn.ulCreateDisposition,
                                       CreateFileIn.ulCreateOptions,
                                       CreateFileIn.pvEaBuffer,
                                       CreateFileIn.ulEaLength );
    }
#else
    dwReturnStatus = EngDeviceIoControl( ppdev->hDriver, IOCTL_VIDEO_ZW_CREATE_FILE,
                                         &CreateFileIn, sizeof(CreateFileIn),
                                         &hFile, sizeof(hFile),
                                         &dwReturnSize );
#endif


    if( dwReturnStatus )
        hFile = INVALID_HANDLE_VALUE;
#endif

    return hFile;

} // NvCreateFile


BOOL NvCloseHandle(HANDLE hFile) {

    BOOL bRes = FALSE;
#ifndef WINNT
    bRes = CloseHandle(hFile);
#else
    DWORD dwReturnStatus, dwReturnSize = 0ul;

    nvAssert( pDriverData != NULL );
    if( pDriverData == NULL ) return FALSE;

    if( ppdev == NULL ) return FALSE;


#ifdef NV_USE_ZW_PFUNCS
    if( NvZwFileIoFuncs.pvZwClose == NULL ) {
        // Init the function pointers
        NvInitFileIoFuncs( ppdev );
        if( NvZwFileIoFuncs.pvZwClose == NULL )
            return NULL;
    }

    dwReturnStatus = NvZwFileIoFuncs.pvZwClose( hFile );
#else
    dwReturnStatus = EngDeviceIoControl( ppdev->hDriver, IOCTL_VIDEO_ZW_CLOSE_HANDLE,
                                         &hFile, sizeof(hFile),
                                         NULL, 0ul,
                                         &dwReturnSize );
#endif

    if( dwReturnStatus )
        bRes = FALSE;
    else
        bRes = TRUE;
#endif

    return bRes;
} // NvCloseHandle


BOOL NvWriteFile( HANDLE hFile,                    // handle to file
                LPCVOID lpBuffer,                // data buffer
                DWORD nNumberOfBytesToWrite,     // number of bytes to write
                LPDWORD lpNumberOfBytesWritten,  // number of bytes written
                LPOVERLAPPED lpOverlapped        // overlapped buffer
                ) 
{
    BOOL bRes;


#ifndef WINNT
    bRes = WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
#else
    NV_ZW_RW_FILE_IN WriteFileIn;
    DWORD dwReturnStatus, dwReturnSize = 0ul;

    nvAssert( pDriverData != NULL );
    if( pDriverData == NULL ) return FALSE;

    if( ppdev == NULL ) return TRUE;

    WriteFileIn.pvFileHandle = hFile;
    WriteFileIn.pvEvent = NULL;
    WriteFileIn.pvApcRoutine = NULL;
    WriteFileIn.pvApcContext = NULL;
    WriteFileIn.pvBuffer = (LPVOID)lpBuffer;
    WriteFileIn.ulLength = nNumberOfBytesToWrite;

    if (lpOverlapped != NULL) {
        WriteFileIn.liByteOffset.QuadPart = lpOverlapped->Offset;
    }
    else {
        WriteFileIn.liByteOffset.QuadPart = 0ul;
    }

    WriteFileIn.pvKey = NULL;

#ifdef NV_USE_ZW_PFUNCS
    if( NvZwFileIoFuncs.pvZwWriteFile == NULL ) {
        // Init the function pointers
        NvInitFileIoFuncs( ppdev );
        if( NvZwFileIoFuncs.pvZwWriteFile == NULL )
            return FALSE;
    }

    {
        IO_STATUS_BLOCK IoBlock;
        dwReturnStatus = NvZwFileIoFuncs.pvZwWriteFile( WriteFileIn.pvFileHandle,
                                                        WriteFileIn.pvEvent,
                                                        WriteFileIn.pvApcRoutine,
                                                        WriteFileIn.pvApcContext,
                                                        &IoBlock,
                                                        WriteFileIn.pvBuffer,
                                                        WriteFileIn.ulLength,
                                                        &WriteFileIn.liByteOffset,
                                                        WriteFileIn.pvKey );
    }
#else
    dwReturnStatus = EngDeviceIoControl( ppdev->hDriver, IOCTL_VIDEO_ZW_WRITE_FILE,
                                        &WriteFileIn, sizeof(WriteFileIn),
                                        NULL, 0,
                                        &dwReturnSize );
#endif

    if (dwReturnStatus) {
        bRes = FALSE;
        *lpNumberOfBytesWritten = 0;
    }
    else {
        bRes = TRUE;
        *lpNumberOfBytesWritten = nNumberOfBytesToWrite;
    }
#endif
    
    return bRes;
} // NvWriteFile

BOOL NvReadFile(HANDLE hFile,                // handle to file
                LPVOID lpBuffer,             // data buffer
                DWORD nNumberOfBytesToRead,  // number of bytes to read
                LPDWORD lpNumberOfBytesRead, // number of bytes read
                LPOVERLAPPED lpOverlapped    // overlapped buffer
                )  
{
    BOOL bRes;

#ifndef WINNT
    bRes = ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
#else
    NV_ZW_RW_FILE_IN ReadFileIn;
    DWORD dwReturnStatus, dwReturnSize = 0ul;

    nvAssert( pDriverData != NULL );
    if( pDriverData == NULL ) return FALSE;

    if( ppdev == NULL ) return FALSE;

    // Convert To NT style params.
    if (lpOverlapped != NULL) {
        ReadFileIn.liByteOffset.QuadPart = lpOverlapped->Offset;
    }

    ReadFileIn.pvFileHandle = hFile;
    ReadFileIn.pvApcContext = NULL;
    ReadFileIn.pvApcRoutine = NULL;
    ReadFileIn.pvBuffer = lpBuffer;
    ReadFileIn.pvEvent = NULL;
    ReadFileIn.pvKey = NULL;
    ReadFileIn.ulLength = nNumberOfBytesToRead;

#ifdef NV_USE_ZW_PFUNCS
    if( NvZwFileIoFuncs.pvZwReadFile == NULL ) {
        // Init the function pointers
        NvInitFileIoFuncs( ppdev );
        if( NvZwFileIoFuncs.pvZwReadFile == NULL )
            return FALSE;
    }

    {
        IO_STATUS_BLOCK IoBlock;
        dwReturnStatus = NvZwFileIoFuncs.pvZwReadFile( ReadFileIn.pvFileHandle,
                                                       ReadFileIn.pvEvent,
                                                       ReadFileIn.pvApcRoutine,
                                                       ReadFileIn.pvApcContext,
                                                       &IoBlock,
                                                       ReadFileIn.pvBuffer,
                                                       ReadFileIn.ulLength,
                                                       &WriteFileIn.liByteOffset,
                                                       ReadFileIn.pvKey );
    }
#else
    dwReturnStatus = EngDeviceIoControl( ppdev->hDriver, IOCTL_VIDEO_ZW_READ_FILE,
                                        &ReadFileIn, sizeof(ReadFileIn),
                                        NULL, 0,
                                        &dwReturnSize );
#endif

    if (dwReturnStatus) {
        bRes = FALSE;
        *lpNumberOfBytesRead = 0;
    }
    else {
        bRes = TRUE;
        *lpNumberOfBytesRead = nNumberOfBytesToRead;
    }

#endif

    return bRes;
}



BOOL NvDeviceIoControl(
  HANDLE hDevice,              // handle to device
  DWORD dwIoControlCode,       // operation control code
  LPVOID lpInBuffer,           // input data buffer
  DWORD nInBufferSize,         // size of input data buffer
  LPVOID lpOutBuffer,          // output data buffer
  DWORD nOutBufferSize,        // size of output data buffer
  LPDWORD lpBytesReturned,     // byte count
  LPOVERLAPPED lpOverlapped    // overlapped information
)
{
    BOOL bRes;
#ifndef WINNT
    bRes =  DeviceIoControl(hDevice, dwIoControlCode, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesReturned,
                            lpOverlapped);
#else
    NTSTATUS status;
    NV_ZW_DEVICE_IO_CONTROL_FILE ZwDeviceIoControl;

    nvAssert( pDriverData != NULL );
    if( pDriverData == NULL ) return false;

    if( ppdev == NULL ) return false;

    ZwDeviceIoControl.hDevice = hDevice;
    ZwDeviceIoControl.ulIoControlCode = dwIoControlCode;
    ZwDeviceIoControl.pvInputBuffer = lpInBuffer;
    ZwDeviceIoControl.ulInputBufferSize = nInBufferSize;

#ifdef NV_USE_ZW_PFUNCS
    if( NvZwFileIoFuncs.pvZwDeviceIoControlFile == NULL ) {
        // Init the function pointers
        NvInitFileIoFuncs( ppdev );
        if( NvZwFileIoFuncs.pvZwDeviceIoControlFile == NULL )
            return false;
    }

    {
        IO_STATUS_BLOCK IoBlock;
        dwReturnStatus = NvZwFileIoFuncs.pvZwDeviceIoControlFile( hDevice,
                                                NULL,
                                                NULL,
                                                NULL,
                                                &IoBlock,
                                                dwIoControlCode,
                                                lpInBuffer,
                                                nInBufferSize,
                                                lpOutBuffer,
                                                nOutBufferSize );
    }
#else
    status = EngDeviceIoControl( ppdev->hDriver, IOCTL_VIDEO_CONTROL_DEVICE,
                                 &ZwDeviceIoControl, sizeof(ZwDeviceIoControl),
                                 lpOutBuffer, nOutBufferSize,
                                 lpBytesReturned );
#endif


    if (status == STATUS_SUCCESS) {
        bRes = true;
    }
    else {
        *lpBytesReturned = 0ul;
        bRes = false;
    }

#endif

    return bRes;
}

#pragma warning(disable: 4035)

DWORD NvGetTickCount()
{
#ifndef WINNT
    return GetTickCount();
#else
    __asm {
            mov     edx, 07ffe0000h
            mov     eax, [edx]
            mul     dword ptr [edx+4]
            shrd    eax,edx,18h
    };
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvAGP.cpp ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvAGP.cpp                                                         *
*   AGP Allocation routines.                                                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 01/12/99 - per context agp heap man.    *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)


//#define SANITY              // do sanity checks
//#define ANALSANITYCHECK     // do a real good job of sanity checking
//#define STATS               // print heap statistics
//#define TIME_ALLOC          // time AGPAlloc calls

#ifdef ANALSANITYCHECK
#define SANITY
#endif

//****************************************************************************
// constants
//****************************************************************************
#define REALSIZE(size)          (4 + ALIGN + GAPSIZE * 2 + (size))
#define MINCHUNKSIZE            (4 * REALSIZE(256 * 256 * 2))       // fit 4 256x256x16 textures
#define ALIGN                   (NV_TEXTURE_OFFSET_ALIGN + 1)
#define GROWSIZE                (128 * sizeof(AGPHEADER))
#define SLACK                   4

#ifdef DEBUG
#define GAPSIZE                 (ALIGN * 4) // must be aligned
#else
#define GAPSIZE                 0
#endif

//
// flags
//
#define AGPFLAG_ALLOCATED       0x00000001
#define AGPFLAG_DISCONTINUITY   0x00000002
#define AGPFLAG_UNUSED          0x00000004

//
// macros
//
#define ISALLOC(x)          ((x) & AGPFLAG_ALLOCATED)
#define ISFREE(x)           (!ISALLOC(x))
#define ISDISCONTINUOUS(x)  ((x) & AGPFLAG_DISCONTINUITY)
#define ISCONTINUOUS(x)     (!ISDISCONTINUOUS(x))
#define ISAVAILABLE(x)      ((x) & AGPFLAG_UNUSED)
#define ISUSED(x)           (!ISAVAILABLE(x))

#ifdef NV_AGP
#define LOWERGAPSTART(p)    (((p)->dwMemory - GAPSIZE))                    // lower no-mans-land
#define UPPERGAPSTART(p)    (((p)->dwMemory + (p)->dwSize))               // upper no-mans-land
#else
#define LOWERGAPSTART(p)    (AGPMEM_ADDR((p)->dwMemory - GAPSIZE))         // lower no-mans-land
#define UPPERGAPSTART(p)    (AGPMEM_ADDR((p)->dwMemory + (p)->dwSize))     // upper no-mans-land
#endif

#define HEADERPTR(dw)       (((dw) == ~0)  ? (AGPHEADER*)NULL : (AGPHEADER*)(getDC()->dwAGPHeapList + (dw)))
#define HEADERADDR(p)       (((p) == NULL) ? ~0 : ((DWORD)p - getDC()->dwAGPHeapList))

#define HASHPTR(dw)         (((dw) == ~0)  ? (AGPHASHENTRY*)NULL : (AGPHASHENTRY*)(getDC()->dwAGPHashTable + (dw)))
#define HASHADDR(p)         (((p) == NULL) ? ~0 : ((DWORD)p - getDC()->dwAGPHashTable))

#define AGPALLOCFLAG_USER   1 // return a user mode address for this allocation


//****************************************************************************
// structures
//****************************************************************************

#ifdef NV_AGP

typedef struct _AGPMAPPING
{
    NV_CFGEX_UNMAP_USER_SPACE_PARAMS addr;
    DWORD dwProcessId;
    _AGPMAPPING *pNext;
} AGPMAPPING, *PAGPMAPPING;

static DWORD      m_dwRMID;
static DWORD      m_dwRootHandle     = 0;
static DWORD      m_dwDeviceHandle   = AGP_DEVICE_HANDLE;
static AGPMAPPING m_pPendingMappings = { { 0, 0 }, 0, 0 };

#endif // NV_AGP

typedef struct
{
    DWORD  dwFlags;         // block status

    DWORD  dwRealMemory;    // actual memory block base
    DWORD  dwRealSize;      // actual memory block size (amount allocated)

    DWORD  dwMemory;        // address returned
    DWORD  dwSize;          // size requested by caller
#ifdef DEBUG
    DWORD  dwSerial;        // allocation serial number (DEBUG only)
#endif // DEBUG
#ifdef NV_AGP
    DWORD  dwRMID;          // block ID
    NV_CFGEX_UNMAP_USER_SPACE_PARAMS addr; // user mode address and memory descriptor list
    DWORD  dwProcessId;     // process ID of creator (when needed)
#else // !NV_AGP
    DWORD  _pad[2];
#endif // !NV_AGP

} AGPHEADER;

typedef struct
{
    DWORD dwAddress;        // actual user address (NULL implies a free entry)
    DWORD dwAGPListOffset;  // offset to surface descriptor (AGPHEADER)
    DWORD dwNext;           // offset to next hash table entry
    DWORD dwPrev;           // offset to prev hash table entry
} AGPHASHENTRY;

//****************************************************************************
// helpers
//****************************************************************************

#ifdef NV_AGP
inline DWORD nvMapUserSpace(AGPHEADER *pCurr)
{
    NV_CFGEX_MAP_USER_SPACE_PARAMS addr;

    addr.kAddr = (void *)pCurr->dwMemory;
    addr.mSize = pCurr->dwSize;
    addr.ppMDL = &pCurr->addr.pMDL;

    DWORD dwRes = NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_MAP_USER_SPACE, &addr, sizeof(addr));

    pCurr->addr.uAddr  = addr.uAddr;
    pCurr->dwProcessId = GetCurrentProcessId();
    DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "Mapped AGP address %08x, user space = %08x (pMDL = %08x, PID = %d)", pCurr->dwMemory, pCurr->addr.uAddr, pCurr->addr.pMDL, pCurr->dwProcessId);

    return dwRes;
}

//-------------------------------------------------------------------------

void nvPurgeAGPMappings(DWORD dwProcessId)
{
    AGPMAPPING *pPrev = &m_pPendingMappings;
    AGPMAPPING *pNext;
    DWORD dwFreed = 0, dwTotal = 0;

    for (AGPMAPPING *pMapping = m_pPendingMappings.pNext; pMapping; pMapping = pNext)
    {
        pNext = pMapping->pNext;
        if (pMapping->dwProcessId == dwProcessId) {
            NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_UNMAP_USER_SPACE, &pMapping->addr, sizeof(pMapping->addr));
            pPrev->pNext = pNext;
            dwFreed++;
            delete pMapping;
        }
        dwTotal++;
    }

    if (dwFreed) {
        DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "Cleaned out %d pending mappings for process %d (%d mappings remaining)", dwFreed, dwProcessId, dwTotal - dwFreed);
    }
}

//-------------------------------------------------------------------------

inline void nvUnmapUserSpace(AGPHEADER *pCurr)
{

    DWORD dwProcessId = GetCurrentProcessId();

    // purge any pending mappings for this process
    if (m_pPendingMappings.pNext) {
        nvPurgeAGPMappings(dwProcessId);
    }

    if (pCurr->dwProcessId == dwProcessId) {
        // unmap
        DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "   Unmapping AGP address %08x, user space = %08x (pMDL = %08x)", pCurr->dwMemory, pCurr->addr.uAddr, pCurr->addr.pMDL);
        NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_UNMAP_USER_SPACE, &pCurr->addr, sizeof(pCurr->addr));
    } else {
        // wrong process ID, add this mapping to pending list
        DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "   Pending mapping added for process %d", pCurr->dwProcessId);
        AGPMAPPING *pNewMapping = new AGPMAPPING;
        if (pNewMapping) {
            pNewMapping->addr.uAddr  = pCurr->addr.uAddr;
            pNewMapping->addr.pMDL   = pCurr->addr.pMDL;
            pNewMapping->dwProcessId = pCurr->dwProcessId;
            pNewMapping->pNext       = m_pPendingMappings.pNext;
            m_pPendingMappings.pNext = pNewMapping;
        }
    }
}
#endif // NV_AGP

//-------------------------------------------------------------------------

#if 0
void dbgValidateAGPMemory(DWORD dwMem, DWORD dwSize)
{
    DWORD dwLimit = ((dwSize + 4095) & ~4095) - 1;

    NV_CFGEX_MEM_INFO_PARAMS info;
    DWORD dwRes = NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_MEM_INFO, &info, sizeof(info));
    DPF("PAT = %08x:%08x", info.uPATHigh, info.uPATLow);
    for(int i = 0; i < 8; i++)
    {
        if (info.uMTRRphysMaskLow[i] & 0x800)
        {
            DPF("MTRRphysBase%d = %08x:%08x, MTRRphysMask%d = %08x:%08x",
                i, info.uMTRRphysBaseHigh[i], info.uMTRRphysBaseLow[i],
                i, info.uMTRRphysMaskHigh[i], info.uMTRRphysMaskLow[i]);
        }
    }
    DWORD _CR3;
    _asm {
        mov eax, cr3;
        mov [_CR3], eax
    }

    for(DWORD dwOffset = 0; dwOffset < dwLimit; dwOffset += 4 * 1024)
    {
        DWORD dwAddress   = dwMem + dwOffset;
        DWORD dwDirectory = (dwAddress >> 22);
        DWORD dwTable     = (dwAddress >> 12) & 0x3FF;
        DWORD dwPTE       = 0x80000000 | _CR3 | (dwDirectory << 2);

        DWORD dwL1 = *(DWORD*)dwPTE;
        DWORD dwL2 = 0x80000000 + (dwL1 & 0xFFFFF000) + (dwTable << 2);
        DWORD dwL3 = *(DWORD*)dwL2;
        DWORD dwCache1 = ((dwL1 >> 3) & 0x03) | ((dwL1 >> 5) & 0x04);
        DWORD dwCache2 = ((dwL3 >> 3) & 0x03) | ((dwL3 >> 5) & 0x04);
        if ((dwCache1 != 0) || (dwCache2 != 1))
        {
            DPF("cache problem @ addr %08x (%08x) %03x %03x", dwAddress, dwL3 & 0xFFFFF000, dwCache1, dwCache2);
            _asm int 3;
        }
    }
}
#endif

//-------------------------------------------------------------------------

DWORD AllocAGPHeap
(
    DWORD dwSize
)
{
    dbgTracePush ("AllocAGPHeap");

    DWORD pAGPMem;

    dwSize += NV_TEXTURE_PAD;

    // get dd global
    LPDDRAWI_DIRECTDRAW_GBL pDrv = getDC()->getDDGlobal();

#ifdef NV_AGP
    DWORD dwLimit = ((dwSize + 4095) & ~4095) - 1;
    ULONG status = NvRmAllocMemory (m_dwRootHandle, 
                                    m_dwDeviceHandle,
                                    m_dwRMID,
                                    NV01_MEMORY_SYSTEM,
                                    (DRF_DEF(OS02, _FLAGS, _LOCATION, _AGP) |
                                    DRF_DEF(OS02, _FLAGS, _COHERENCY, _WRITE_COMBINE)),
                                    (PVOID *) &pAGPMem,
                                    (unsigned long *) &dwLimit);

    if (status) {
        DPF("AllocAGPHeap failed, out of memory");
        return ERR_DXALLOC_FAILED;
    }
    NV_CFGEX_GET_AGP_OFFSET_PARAMS addr;
    addr.linaddr = (void*)pAGPMem;
    NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_GET_AGP_OFFSET, &addr, sizeof(addr));
    if (addr.offset + dwLimit > pDriverData->regMaxAGPLimit) {
        // memory was allocated, but lies outside the context dma range, free it and return an error
        NvRmFree (m_dwRootHandle, m_dwDeviceHandle, m_dwRMID);
        DPF("AllocAGPHeap failed, out of range");
        return ERR_DXALLOC_FAILED;
    }
#else
    pAGPMem = (DWORD)DDHAL32_VidMemAlloc(pDrv, AGP_HEAP, dwSize, 1);
#endif

    DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "Allocated AGP block at %08x (size = %08x)", pAGPMem, dwSize);

    dbgTracePop();
    return pAGPMem;
}

//-------------------------------------------------------------------------

BOOL FreeAGPHeap
(
    AGPHEADER *pCurr
)
{
    dbgTracePush("FreeAgpHeap");

    // get dd global
    LPDDRAWI_DIRECTDRAW_GBL pDrv = getDC()->getDDGlobal();

#ifdef NV_AGP
    // there should be no user mapping on a free block
    nvAssert(pCurr->addr.uAddr == 0);

    if (NvRmFree (m_dwRootHandle, m_dwDeviceHandle, pCurr->dwRMID)) {
        DPF("FreeAGPHeap failed");
        nvAssert (0);
        return FALSE;
    }
#else
    DDHAL32_VidMemFree(pDrv, AGP_HEAP, pCurr->dwRealMemory);
#endif

    DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "Freed AGP block at %08x (size = %08x)", pCurr->dwRealMemory, pCurr->dwRealSize);
    
    dbgTracePop();
    return TRUE;
}

//
// nvAGPAddBackPointer
//
// adds an address to the list of back pointers
//
BOOL nvAGPAddBackPointer
(
    DWORD      dwAddress,
    AGPHEADER *pHeader
)
{
    nvAssert(dwAddress);

    // get hash table index
    DWORD  dwIndex    = ((dwAddress >> 16) ^ (dwAddress >> 8)) & 255;
    DWORD *pHashTable = (DWORD*)getDC()->dwAGPHashTableHead;

    // if have no hash table list yet, get one
    if (!pHashTable)
    {
        getDC()->dwAGPHashTableHead = (DWORD)AllocIPM(4 * 256);
        pHashTable = (DWORD*)getDC()->dwAGPHashTableHead;
        assert (pHashTable);
        memset (pHashTable,~0,4 * 256);
    }

    for (AGPHASHENTRY *pEntry = HASHPTR(0);;)
    {
        // find a free hash table entry
        AGPHASHENTRY *pMax = (AGPHASHENTRY*)(getDC()->dwAGPHashTable + getDC()->dwAGPHashTableMax);
        for (; pEntry < pMax; pEntry++)
        {
            if (!pEntry->dwAddress)
            {
                // add to list (this becomes the new first entry)
                pEntry->dwAddress        = dwAddress;
                pEntry->dwAGPListOffset  = HEADERADDR(pHeader);
                pEntry->dwNext           = pHashTable[dwIndex];
                pEntry->dwPrev           = HASHADDR(NULL);
                AGPHASHENTRY *pEntryOld  = HASHPTR(pHashTable[dwIndex]);
                pHashTable[dwIndex]      = HASHADDR(pEntry);
                if (pEntryOld)
                {
                    pEntryOld->dwPrev    = pHashTable[dwIndex];
                }
                // done
                return TRUE;
            }
        }

        // out of space, make more space
        DWORD dwOldMax = getDC()->dwAGPHashTableMax;
        getDC()->dwAGPHashTableMax += sizeof(AGPHASHENTRY) * 256;
        void *pNewMem;
        if (!ReallocIPM((void*)getDC()->dwAGPHashTable, getDC()->dwAGPHashTableMax, &pNewMem))
        {
            DPF("nvAGPAddBackPointer: ReallocIPM failed");
            return FALSE;
        }
        getDC()->dwAGPHashTable = (DWORD)pNewMem;

        // clear out new part
        memset ((void*)(getDC()->dwAGPHashTable + dwOldMax),0,sizeof(AGPHASHENTRY) * 256);

        // loop back so we can find an entry. we know where one is, so we help a little
        pEntry = (AGPHASHENTRY*)(getDC()->dwAGPHashTable + dwOldMax);
    }

    dbgD3DError();
    return TRUE;
}

//
// nvAGPRemoveBackPointer
//
// removes a back pointer from the hash table
//
void nvAGPRemoveBackPointer
(
    AGPHASHENTRY *pEntry
)
{
    AGPHASHENTRY *pNext = HASHPTR(pEntry->dwNext);
    AGPHASHENTRY *pPrev = HASHPTR(pEntry->dwPrev);
    nvAssert(pEntry->dwAddress);
    if (pNext) pNext->dwPrev = pEntry->dwPrev;
    if (pPrev) pPrev->dwNext = pEntry->dwNext;
    else
    {
        DWORD  dwAddress    = pEntry->dwAddress;
        DWORD  dwIndex      = ((dwAddress >> 16) ^ (dwAddress >> 8)) & 255;
        DWORD *pHashTable   = (DWORD*)getDC()->dwAGPHashTableHead;
        pHashTable[dwIndex] = HASHADDR(pNext);
    }

#ifdef DEBUG
    memset (pEntry,0,sizeof(*pEntry));
#else
    pEntry->dwAddress = 0;
#endif
}

//
// nvAGPFindBackPointer
//
// finds the AGPHEADER that matches the given address
//
AGPHASHENTRY* nvAGPFindBackPointer
(
    DWORD dwAddress
)
{
    // valid hash table?
    if (!getDC()->dwAGPHashTable)
    {
        return NULL;
    }

    // get hash table index
    DWORD  dwIndex    = ((dwAddress >> 16) ^ (dwAddress >> 8)) & 255;
    DWORD *pHashTable = (DWORD*)getDC()->dwAGPHashTableHead;

    // find the address
    AGPHASHENTRY *pEntry = HASHPTR(pHashTable[dwIndex]);
    while (pEntry)
    {
#ifdef DEBUG
        if (!pEntry->dwAddress)
        {
            DPF("nvAGPFindBackPointer: AGP heap insane - empty table entry");
            __asm int 3;
            return NULL;
        }
#endif // DEBUG

        // test
        if (pEntry->dwAddress == dwAddress)
        {
            // got it
            return pEntry;
        }

        // next
        pEntry = HASHPTR(pEntry->dwNext);
    }

    // not found
    return NULL;
}


// debug stuff
#ifdef DEBUG

DWORD dwSerial      = 0;
DWORD dwSerialBreak = 0;

//
// nvAGPDebugTestSetup
//
// fills the no-mans-land around a surface with a known value so we can track
// cases where stuff overwrites the assigned boundaries or something else
// corrupts our memory
//
void nvAGPDebugTestSetup
(
    AGPHEADER *pHeader
)
{
    void *pLowerGapStart = (void*)LOWERGAPSTART(pHeader);
    void *pUpperGapStart = (void*)UPPERGAPSTART(pHeader);

    memset (pLowerGapStart, 0xe7, GAPSIZE);
    memset (pUpperGapStart, 0xe7, GAPSIZE);
}

//
// nvAGPDebugTest
//
// checks that the preset no-mans-land is intact. fail if not.
//
void nvAGPDebugTest
(
    AGPHEADER *pHeader
)
{
    DWORD dwLowerGapStart = LOWERGAPSTART(pHeader);
    DWORD dwUpperGapStart = UPPERGAPSTART(pHeader);
    DWORD dw,cnt;

    for (cnt = GAPSIZE,dw = dwLowerGapStart; cnt; dw++, cnt--)
    {
        if ((*(BYTE*)dw) != 0xe7)
        {
            DPF("AGPHeap underfill : Gap %08x : Fail %08x",dwLowerGapStart,dw);
            DPF("                    pHeader  = %08x",pHeader);
            DPF("                    S#       = %08x",pHeader->dwSerial);
            dbgD3DError();
        }
    }

    for (cnt = GAPSIZE,dw = dwUpperGapStart; cnt; dw++, cnt--)
    {
        if ((*(BYTE*)dw) != 0xe7)
        {
            DPF("AGPHeap overfill : Gap %08x : Fail %08x",dwUpperGapStart,dw);
            DPF("                   pHeader  = %08x",pHeader);
            DPF("                   S#       = %08x",pHeader->dwSerial);
            dbgD3DError();
        }
    }
}

//
// nvAGPHeapDump
//
// shows all memory block
//
void nvAGPHeapDump
(
    void
)
{
    DWORD i, j;

    for (i = getDC()->dwAGPHeapListMax, j = 0; i; j += sizeof(AGPHEADER), i -= sizeof(AGPHEADER))
    {
        char       s1[256];
        char       s2[256];
        AGPHEADER *pCurr = HEADERPTR(j);

        nvSprintf (s1,"%08x:",j);
        if (pCurr->dwFlags & AGPFLAG_DISCONTINUITY)
        {
            nvStrCat (s1," dis");
        }
        if (pCurr->dwFlags & AGPFLAG_UNUSED)
        {
            nvStrCat (s1," empty");
        }
        else
        {
            nvSprintf (s2," rm=0x%08x rs=%d", pCurr->dwRealMemory, pCurr->dwRealSize);
            nvStrCat (s1,s2);

            if (pCurr->dwFlags & AGPFLAG_ALLOCATED)
            {
                nvSprintf (s2," m=0x%08x s=%d #=0x%x", pCurr->dwMemory, pCurr->dwSize, pCurr->dwSerial);
                nvStrCat (s1,s2);
            }
            else
            {
                nvStrCat (s1," free");
            }
        }

        DPF("%s.",s1);
    }
}

//
// nvAGPHeapSanity
//
// checks that the agp heap is intact and setup properly
//
void nvAGPHeapSanity
(
    void
)
{
    DWORD i,j;

    for (i = getDC()->dwAGPHeapListMax, j = 0; i; j += sizeof(AGPHEADER),i -= sizeof(AGPHEADER))
    {
        AGPHEADER *pCurr = HEADERPTR(j);

        // find next
        DWORD      k      = i      - sizeof(AGPHEADER);
        AGPHEADER *pNext = pCurr + 1;
        while (k && ISAVAILABLE(pNext->dwFlags))
        {
            pNext ++;
            k      -= sizeof(AGPHEADER);
        }
        if (!k) pNext = NULL;

        // test back pointer
        if (ISALLOC(pCurr->dwFlags))
        {
            DWORD         dwMemory = pCurr->dwMemory;
            AGPHASHENTRY *pEntry  = nvAGPFindBackPointer(dwMemory);
            DWORD         dwTemp   = pEntry->dwAGPListOffset;

            if (dwTemp != j)
            {
                DPF("nvAGPHeapSanity: back pointer invalid");
                DPF("                 pCurr    = %08x",pCurr);
                DPF("                 dwMemory = %08x",dwMemory);
                DPF("                 dwTemp   = %08x",dwTemp);
                DPF("                 j        = %08x",j);
                DPF("                 S#       = %08x",pCurr->dwSerial);
                DPF("Hit F5 to dump heap blocks...");
                dbgD3DError();
                nvAGPHeapDump();
                __asm int 3;
            }
        }

        // test size
        if ((pNext)
         && ISUSED(pCurr->dwFlags)
         && ISUSED(pNext->dwFlags)
         && ISCONTINUOUS(pNext->dwFlags))
        {
            // real size & memory check out?
            if (pCurr->dwRealMemory + pCurr->dwRealSize != pNext->dwRealMemory)
            {
                DPF("nvAGPHeapSanity: real memory addr & size does not check out");
                DPF("                 pCurr    = %08x",pCurr);
                DPF("                 j        = %08x",j);
                DPF("                 S#       = %08x",pCurr->dwSerial);
                DPF("Hit F5 to dump heap blocks...");
                dbgD3DError();
                nvAGPHeapDump();
                __asm int 3;
            }
        }

        // is memory contained properly and aligned strict enough?
        if (ISALLOC(pCurr->dwFlags))
        {
            DWORD dwRealEnd = pCurr->dwRealMemory + pCurr->dwRealSize;
            DWORD dwEnd     = pCurr->dwMemory     + pCurr->dwSize;

            if ((pCurr->dwMemory < pCurr->dwRealMemory)
             || (dwEnd > dwRealEnd)
             || (pCurr->dwMemory & (ALIGN - 1)))
            {
                DPF("nvAGPHeapSanity: memory outsize of valid range Or not aligned");
                DPF("                 pCurr    = %08x",pCurr);
                DPF("                 dwMemory = %08x",pCurr->dwMemory);
                DPF("                 j        = %08x",j);
                DPF("                 S#       = %08x",pCurr->dwSerial);
                DPF("Hit F5 to dump heap blocks...");
                dbgD3DError();
                nvAGPHeapDump();
                __asm int 3;
            }

#ifdef ANALSANITYCHECK
            // test for over/underrun
            nvAGPDebugTest(pCurr);
#endif
        }
    }
}
#endif // DEBUG

#ifdef STATS
//
// nvAGPShowStats
//
// prints usage statistics
//
void nvAGPShowStats
(
    void
)
{
    DWORD dwTotalAlloc = 0;
    DWORD dwTotalUsed  = 0;
    DWORD i,j;

    for (i = getDC()->dwAGPHeapListMax, j = 0; i; j += sizeof(AGPHEADER),i -= sizeof(AGPHEADER))
    {
        AGPHEADER *pCurr = HEADERPTR(j);

        if (ISUSED(pCurr->dwFlags))
        {
            dwTotalAlloc += pCurr->dwRealSize;

            if (ISALLOC(pCurr->dwFlags))
            {
                dwTotalUsed += pCurr->dwRealSize;
            }
        }

    }

    DPF ("AGPHeap: %d/%d (%d%%) used", dwTotalUsed,dwTotalAlloc,(dwTotalUsed * 100) / dwTotalAlloc);
}
#endif //STATS

//
// nvAGPListInsertFree
//
// creates a free entry right after dwStart
//  returns TRUE on success
//
BOOL nvAGPListInsertFree
(
    DWORD dwStart,
    DWORD *pdwNew
)
{
    // do we want a specific entry or just one at the end of the list?
    // dwStart == ~0 to request eol
    //
    if (dwStart == ~0)
    {
        DWORD      dwMax;
        AGPHEADER *pCurr;

        // get a free header at end of list
        dwMax = getDC()->dwAGPHeapListMax;
        if (dwMax && (ISAVAILABLE((HEADERPTR(dwMax) - 1)->dwFlags))) // at least one available
        {
            // find first used block from the end of the list
            *pdwNew = dwMax;
            pCurr = HEADERPTR(*pdwNew);
            while (*pdwNew && ISAVAILABLE((pCurr - 1)->dwFlags))
            {
                pCurr --;
                *pdwNew -= sizeof(AGPHEADER);
            }

            // allow some slack space if we can - this introduce bubbles in the
            // list to make insertion faster
            if ((dwMax - *pdwNew) > SLACK * sizeof(AGPHEADER))
            {
                *pdwNew += SLACK * sizeof(AGPHEADER);
                pCurr += SLACK;
            }

            // return it
            return TRUE;
        }
        else
        {
            AGPHEADER *pHeader;
            *pdwNew = dwMax; // start of new block
            DWORD i;

            // alloc more space
            dwMax += GROWSIZE;
            void *pNewMem;
            if (!ReallocIPM((void*)getDC()->dwAGPHeapList, dwMax, &pNewMem))
            {
                DPF("nvAGPListInsertFree, ReallocIPM failed");
                return FALSE;
            }
            getDC()->dwAGPHeapList     = (DWORD)pNewMem;
            getDC()->dwAGPHeapListMax  = dwMax;

            // fill with empty headers
            for (pHeader = HEADERPTR(*pdwNew), i = *pdwNew; i < dwMax; pHeader++, i += sizeof(AGPHEADER))
            {
#ifdef DEBUG
                memset (pHeader,0x77,sizeof(*pHeader));
#endif
                pHeader->dwFlags = AGPFLAG_UNUSED;
            }

            // return appropriate entry (with some slack space)
            *pdwNew += SLACK * sizeof(AGPHEADER);
            return TRUE;
        }
    }
    else
    {
        DWORD      dwCount;
        DWORD      dwMax;
        AGPHEADER *pHeader;
        AGPHEADER *pFree;

        // find first free entry after start
        dwCount = 0;
        *pdwNew = dwStart;
        dwMax   = getDC()->dwAGPHeapListMax;
        pHeader   = HEADERPTR(dwStart);

        while ((*pdwNew < dwMax) && !ISAVAILABLE(pHeader->dwFlags))
        {
            dwCount ++;
            pHeader   ++;
            *pdwNew += sizeof(AGPHEADER);
        }

        // if we have not found one add it to the end
        if (*pdwNew >= dwMax)
        {
            // since we get here we know there are no free entries left
            // the following call will return (grow list) a free entry
            // that we just need to move into place
            //
            if (!nvAGPListInsertFree(~0, pdwNew))
            {
                DPF("nvAGPListInsertFree: nvAGPListInsertFree failed");
                return FALSE;
            }
            pHeader   = HEADERPTR(*pdwNew);
            dwCount = (*pdwNew - dwStart) / sizeof(AGPHEADER);
            dwMax   = getDC()->dwAGPHeapListMax;
        }

        // if the free pointer is not adjacent to start,
        // move the header list to make it so
        // also decrement dwCount so we know how many items to move
        if (--dwCount)
        {
            DWORD i;

            *pdwNew = dwStart + sizeof(AGPHEADER);
            pFree  = HEADERPTR(*pdwNew);
            memmove (pFree + 1,pFree,dwCount * sizeof(AGPHEADER));

            // update the back pointers
            pFree ++;
            for (i = dwCount; i; i--, pFree++)
            {
                if (ISALLOC(pFree->dwFlags)) // is in use
                {
                    AGPHASHENTRY *pEntry = nvAGPFindBackPointer(pFree->dwMemory);
                    if (pEntry)
                    {
                        pEntry->dwAGPListOffset += sizeof(AGPHEADER);
                    }
                }
            }
        }

        // done
        return TRUE;
    }
}

/*****************************************************************************
 * exports
 *****************************************************************************/

// CreateAGPHeap
// top-level routine for creation of the texture heap in AGP memory

BOOL nvAGPCreateHeap(void)
{
    dbgTracePush ("CreateAGPHeap");

    DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "nvAGPCreateHeap");

    // shouldn't create the heap more than once
    nvAssert(!pDriverData->nvD3DTexHeapData.dwHandle);
    
    // should only do this if AGP is available
    nvAssert(pDriverData->GARTLinearBase);

    // create context DMA
    if (D3DCreateTextureContexts (pDriverData->GARTLinearBase, pDriverData->regMaxAGPLimit)) {
        dbgTracePop();
        return FALSE;
    }

    // set the handle to indicate heap has been created
    pDriverData->nvD3DTexHeapData.dwHandle = 1;

    nvAGPResetHeap();

#ifdef NV_AGP
    char devName[128];
    DWORD res = NvRmAllocRoot(&m_dwRootHandle);
//    DWORD res = NvAllocRoot(pDriverData->ppdev->hDriver, NV01_ROOT_USER, &m_dwRootHandle);
    nvAssert(res == NVOS01_STATUS_SUCCESS);
    *((DWORD*)devName) = 0;
    res = NvRmAllocDevice (m_dwRootHandle, m_dwDeviceHandle, NV01_DEVICE_0, (BYTE*)devName);
    nvAssert(res == NVOS06_STATUS_SUCCESS);
#endif

    dbgTracePop();
    return TRUE;
}

BOOL nvAGPDestroyHeap(void)
{
    dbgTracePush ("DestroyTextureHeap");

    DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "nvAGPDestroyHeap");

    D3DDestroyTextureContexts (pDriverData);

    // Can't destroy a heap if there isn't one.
    nvAssert (getDC()->nvD3DTexHeapData.dwHandle);

    if (!(getDC()->nvD3DTexHeapData.dwHandle)) { 
        return TRUE;
    }

    // should only do this if AGP is available
    nvAssert(pDriverData->GARTLinearBase);

    getDC()->nvD3DTexHeapData.dwHandle = 0;

    dbgTracePop();
    return TRUE;
}

//
// nvAGPCombine
//
// walks all of the local agp heap and merge adjacent free blocks
//
void nvAGPCombine
(
    void
)
{
    DWORD      dwMax;
    DWORD      dwCurr;
    AGPHEADER *pCurr;

    // for all blocks
    dwMax = getDC()->dwAGPHeapListMax;
    for (dwCurr = 0,pCurr = HEADERPTR(0); dwCurr < dwMax;)
    {
        if (ISUSED(pCurr->dwFlags))
        {
            // get next block
            DWORD      dwNext = dwCurr + sizeof(AGPHEADER);
            AGPHEADER *pNext = pCurr + 1;

            while ((dwNext < dwMax) && ISAVAILABLE(pNext->dwFlags))
            {
                dwNext += sizeof(AGPHEADER);
                pNext ++;
            }
            if (dwNext >= dwMax) break;

            // test if both are free and we do not cross a discontinuous boundary
            if (ISFREE(pCurr->dwFlags)
             && ISFREE(pNext->dwFlags)
             && ISCONTINUOUS(pNext->dwFlags))
            {
                // consolidate two blocks
                pCurr->dwRealSize += pNext->dwRealSize;
                pCurr->dwMemory    = 0;
                pCurr->dwSize      = 0;

#ifdef NV_AGP
                // there should be no user mapping on a free block
                nvAssert(pCurr->addr.uAddr == 0);
#endif

                // remove "next" entry from active list
                pNext->dwFlags = AGPFLAG_UNUSED;

                // do not increment dwCurr
                continue;
            }
            else
            // test if we have a dummy block - i.e. no real size
            if (ISFREE(pCurr->dwFlags)
             && (pCurr->dwRealSize == 0))
            {
                // remove redundant entry from active list
                pCurr->dwFlags = AGPFLAG_UNUSED;
            }
        }

        // next
        pCurr ++;
        dwCurr += sizeof(AGPHEADER);
    }

#ifdef SANITY
    nvAGPHeapSanity();
#endif
}

//
// nvAGPReclaim
//
// try to free up unsued memory. usually called after a nvAGPCombine for max effect
//
void nvAGPReclaim
(
    void
)
{
    DWORD      dwMax;
    DWORD      dwCurr;
    AGPHEADER *pCurr;

    // for all blocks
    dwMax = getDC()->dwAGPHeapListMax;
    for (dwCurr = 0,pCurr = HEADERPTR(0); dwCurr < dwMax;)
    {
        if (ISUSED(pCurr->dwFlags))
        {
            // get next block
            DWORD      dwNext = dwCurr + sizeof(AGPHEADER);
            AGPHEADER *pNext = pCurr + 1;
            while ((dwNext < dwMax) && ISAVAILABLE(pNext->dwFlags))
            {
                dwNext += sizeof(AGPHEADER);
                pNext ++;
            }
            if (dwNext >= dwMax) pNext = NULL;

            // see if the whole allocated block is available for freeing
            //  - current block must be free and a discontinuous boundary
            //  - next must either not exist or must be a discontinuous boundary
            if (((pNext && ISDISCONTINUOUS(pNext->dwFlags))
              || (!pNext))
             && ISFREE(pCurr->dwFlags)
             && ISDISCONTINUOUS(pCurr->dwFlags))
            {
                // free AGP memory
                FreeAGPHeap (pCurr);

                // remove block from active list
                pCurr->dwFlags = AGPFLAG_UNUSED;
            }
        }

        // next
        pCurr ++;
        dwCurr += sizeof(AGPHEADER);
    }

#ifdef SANITY
    nvAGPHeapSanity();
#endif
}

//
// nvAGPResetHeap
//
// cleans up the current agp heap if possible, and reset as empty
//
void nvAGPResetHeap
(
    void
)
{
    // combine and reclaim as much memory as possible
    nvAGPCombine();
    nvAGPReclaim();

    // hash table
    if (getDC()->dwAGPHashTable)
    {
        FreeIPM ((void*)getDC()->dwAGPHashTable);
    }
    if (getDC()->dwAGPHashTableHead)
    {
        FreeIPM ((void*)getDC()->dwAGPHashTableHead);
    }
    getDC()->dwAGPHashTableHead = 0;
    getDC()->dwAGPHashTable     = 0;
    getDC()->dwAGPHashTableMax  = 0;

    // zero out
    if (getDC()->dwAGPHeapList)
    {
        FreeIPM ((void*)getDC()->dwAGPHeapList);
    }
    getDC()->dwAGPHeapList    = 0;
    getDC()->dwAGPHeapListMax = 0;

    //  mark the heap as valid
    getDC()->bAGPHeapValid = TRUE;
#ifdef NV_AGP
    m_dwRMID = AGP_MEMORY_OBJECT_LO;
    if (m_dwRootHandle) {
        DWORD res = NvRmFree (m_dwRootHandle, NV01_NULL_OBJECT, m_dwRootHandle);
        m_dwRootHandle = 0;
        nvAssert(res == NVOS00_STATUS_SUCCESS);
    }
#endif
}

//
// nvAGPInvalidate
//
// marks the heap as invalid. useful when MS rips the heap out from under us
// with no warning whatsoever. calling this function will prevent all heap
// access until it's been reallocated and reset
//
void nvAGPInvalidate
(
    void
)
{
    getDC()->bAGPHeapValid = FALSE;
}

#ifdef NV_AGP
//
// nvAGPGetUserAddr
//
// return a user space mapping for the supplied AGP address
//
DWORD nvAGPGetUserAddr(DWORD dwAddr)
{
    AGPHASHENTRY *pEntry = nvAGPFindBackPointer(dwAddr);

    if (!pEntry)
    {
        DPF("nvGetUserModeAddr: Surface is not in our memory context");
        nvAssert(0);
        return NULL;
    }

    AGPHEADER *pCurr = HEADERPTR(pEntry->dwAGPListOffset);
    nvAssert(pCurr);

    // check if we already have a user space mapping
    if (pCurr->addr.uAddr) {
        DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "User mapping for %08x already exists at %08x", pCurr->dwMemory, pCurr->addr.uAddr);
        return (DWORD)pCurr->addr.uAddr;
    }

    // create a user space mapping
    nvMapUserSpace(pCurr);

    return (DWORD)pCurr->addr.uAddr;
}

#endif

//
// nvAGPAlloc
//
// allocates agp memory for textures
//
void* nvAGPAlloc
(
    DWORD dwSize
)
{
    DWORD dwRealSize;
    DWORD i;

    nvAssert (getDC()->bAGPHeapValid);

    // calculate how much memory we really need to allocate
    dwRealSize = REALSIZE(dwSize);

    // try to allocate the memory:
    //  pass 1 - see if we can find a large enough block out of existing set
    //  pass 2 - try to combine adjacent free blocks and try pass 1 again
    //  pass 3 - allocate a large enouch chunk and retry pass 1 - this is guaranteed to work
    for (i = 0; i < 3; i++)
    {
        DWORD      dwMax;
        DWORD      dwCurr;
        AGPHEADER *pCurr;

        // find free space
        dwMax = getDC()->dwAGPHeapListMax;
        for (dwCurr = 0,pCurr = HEADERPTR(0); dwCurr < dwMax; pCurr ++,dwCurr += sizeof(AGPHEADER))
        {
            if (ISUSED(pCurr->dwFlags)
             && ISFREE(pCurr->dwFlags))
            {
                // check if aligned block matches exactly (implies that this alloc matches a previous alloc & free)
                if (pCurr->dwSize == dwSize)
                {
                    // update flags
                    pCurr->dwFlags |= AGPFLAG_ALLOCATED;

                    // debug preps
#ifdef DEBUG
                    nvAGPDebugTestSetup (pCurr);
                    pCurr->dwSerial = ++dwSerial;
                    if (dwSerial == dwSerialBreak) __asm int 3;
#endif //DEBUG
                    // add back pointer to hash table
                    nvAGPAddBackPointer (pCurr->dwMemory,pCurr);

                    // debug checks
#ifdef SANITY
                    nvAGPHeapSanity();
#endif
#ifdef STATS
                    nvAGPShowStats();
#endif

#ifdef NV_AGP
                    // no user address should exist yet
                    nvAssert(pCurr->addr.uAddr == 0);
                    DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "Allocating AGP memory @ %08x", pCurr->dwMemory);
#endif

                    // done
                    return (void*)pCurr->dwMemory;
                }

                // check if we can fit a block that has to be split
                if (pCurr->dwRealSize >= dwRealSize)
                {
                    DWORD      dwSplit;
                    AGPHEADER *pSplit;

                    // get a free header
                    // reinit some variables since the header list may move in memory
                    if (!nvAGPListInsertFree(dwCurr, &dwSplit))
                    {
                        DPF("nvAGPAlloc: nvAGPListInsertFree failed");
                        nvAssert(0);
                        return (void*)ERR_DXALLOC_FAILED;
                    }
                    pSplit = HEADERPTR(dwSplit);
                    pCurr  = HEADERPTR(dwCurr);
                    dwMax  = getDC()->dwAGPHeapListMax;

#ifdef DEBUG
                    pCurr->dwSerial = ++dwSerial;
                    if (dwSerial  == dwSerialBreak) __asm int 3;
#endif //DEBUG

                    // update split block data
                    pSplit->dwFlags      = 0; // this block is always continuous and always free
                    pSplit->dwRealSize   = pCurr->dwRealSize   - dwRealSize;
                    pSplit->dwRealMemory = pCurr->dwRealMemory + dwRealSize;
                    pSplit->dwSize       = 0;
                    pSplit->dwMemory     = 0;
#ifdef NV_AGP
                    pSplit->addr.uAddr   = 0;
#endif

                    // update current block data
                    pCurr->dwRealSize  = dwRealSize;
                    pCurr->dwFlags    |= AGPFLAG_ALLOCATED;
                    pCurr->dwMemory    = (pCurr->dwRealMemory + GAPSIZE + ALIGN - 1) & ~(ALIGN - 1);
                    if ((pCurr->dwMemory - pCurr->dwRealMemory) <= GAPSIZE) pCurr->dwMemory += ALIGN;
                    pCurr->dwSize      = dwSize;

                    // debug preps
#ifdef DEBUG
                    nvAGPDebugTestSetup (pCurr);
#endif //DEBUG

                    // add back pointer to hash table
                    nvAGPAddBackPointer (pCurr->dwMemory,pCurr);

                    // debug checks
#ifdef SANITY
                    nvAGPHeapSanity();
#endif
#ifdef STATS
                    nvAGPShowStats();
#endif

#ifdef NV_AGP
                    // no user address should exist yet
                    nvAssert(pCurr->addr.uAddr == 0);
                    DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "Allocating AGP memory @ %08x", pCurr->dwMemory);
#endif

                    // done
                    return (void*)pCurr->dwMemory;
                }
            }
        }

        // nothing found
        switch (i)
        {
            case 0:
            {
                // combine free blocks now and try again
                nvAGPCombine();
                break;
            }
            case 1:
            {
                DWORD      dwCurr;
                AGPHEADER *pCurr;
                DWORD      dwNewMemory;
                DWORD      dwNewSize;

                // use this opportunity to free up unused blocks
                //  this can help / speed up the following alloc
                nvAGPReclaim();

                // allocate a new chunk to fit at least this or MINCHUNKSIZE
                dwNewSize   = max(MINCHUNKSIZE,dwRealSize);
#ifdef TIME_ALLOC
                {
                DWORD a = GetTickCount();
                DWORD b;
#endif
                dwNewMemory = AllocAGPHeap(dwNewSize);
#ifdef TIME_ALLOC
                b = GetTickCount();
                DPF ("%d ms", b-a);
                }
#endif
                if (dwNewMemory == ERR_DXALLOC_FAILED)
                {
                    return (void*)ERR_DXALLOC_FAILED;
                }

                // get a free header at end of list
                if (!nvAGPListInsertFree(~0, &dwCurr))
                {
                    DPF("nvAGPAlloc: nvAGPListInsertFree failed");
                    nvAssert(0);
                    return (void*)ERR_DXALLOC_FAILED;
                }
                pCurr = HEADERPTR(dwCurr);

                // populate
#ifdef NV_AGP
                pCurr->dwRMID       = m_dwRMID;
                pCurr->addr.uAddr   = 0;
#endif
                pCurr->dwFlags      = AGPFLAG_DISCONTINUITY;
                pCurr->dwRealMemory = dwNewMemory;
                pCurr->dwRealSize   = dwNewSize;
                pCurr->dwMemory     = 0;
                pCurr->dwSize       = 0;

#ifdef NV_AGP
                // prepare for next alloc
                m_dwRMID++;
#endif

                // free space finder is guaranteed to find enough space for this request
                break;
            }
        }
    }

    // fail utterly
    //  - this cannot really happen but if it does things are pretty insane already
    DPF("nvAGPAlloc: Reality in AGP-Heap land has failed");
    dbgD3DError();
    return (void*)ERR_DXALLOC_FAILED;
}

//
// nvAGPFree
//
// frees agp memory for textures
//
void nvAGPFree
(
    void *pMem
)
{
    if (!getDC()->bAGPHeapValid)
    {
        return;
    }

    // sanity test
    if (IsBadReadPtr(pMem,4))
    {
        // this texture was allocated with our special heap but the context has
        // been destroyed in the mean time so we cannot free thus we ignore it
        DPF("nvAGPFree: invalid request");
        dbgD3DError();
        return;
    }

    // get back pointer
    AGPHASHENTRY *pEntry = nvAGPFindBackPointer((DWORD)pMem);
    if (!pEntry)
    {
        DPF("nvAGPFree: Surface is not in our memory context. May be OK if mode");
        DPF("           switch just occurred. Ignoring.");
        nvAssert(0);
        return;
    }

    AGPHEADER *pCurr = HEADERPTR(pEntry->dwAGPListOffset);
    if (ISALLOC(pCurr->dwFlags))
    {
        DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "Freeing AGP memory @ %08x", pMem);
        // free memory
#ifdef DEBUG
        nvAGPDebugTest (pCurr);
#endif
        pCurr->dwFlags &= ~AGPFLAG_ALLOCATED;

#ifdef NV_AGP
        // delete the user space mapping
        if (pCurr->addr.uAddr) {
            nvUnmapUserSpace(pCurr);
            pCurr->addr.uAddr = 0;
        }
#endif

#ifdef DEBUG
#ifdef NV_AGP
        memset ((void*)pCurr->dwRealMemory, 0xDD, pCurr->dwRealSize);
#else
        memset ((void*)AGPMEM_ADDR(pCurr->dwRealMemory), 0xdd, pCurr->dwRealSize);
#endif
#endif

        // remove back pointer
        nvAGPRemoveBackPointer (pEntry);
    }
    else
    {
        DPF("nvAGPFree: Freeing an already free texture!");
        dbgD3DError();
        return;
    }

#ifdef SANITY
    nvAGPHeapSanity();
#endif
#ifdef STATS
    nvAGPShowStats();
#endif
}

//
// nvAGPGetMemory
//
// returns the total amount of memory we have allocated and how much of it
// is free
//
void nvAGPGetMemory
(
    DWORD *pdwTotal,
    DWORD *pdwFree
)
{
    DWORD      dwTotal = 0;
    DWORD      dwFree  = 0;
    DWORD      dwCurr;
    DWORD      dwMax;
    AGPHEADER *pCurr;

    if (getDC()->bAGPHeapValid) {
        
        // try to compact memory
        nvAGPCombine();
        
        // for all blocks
        dwMax = getDC()->dwAGPHeapListMax;
        for (dwCurr = 0, pCurr = HEADERPTR(0); dwCurr < dwMax;)
        {
            if (ISUSED(pCurr->dwFlags))
            {
                dwTotal += pCurr->dwRealSize;
                if (ISFREE(pCurr->dwFlags)) dwFree += pCurr->dwRealSize;
            }
            
            // next
            pCurr ++;
            dwCurr += sizeof(AGPHEADER);
        }
    }

    // done
    *pdwTotal = dwTotal;
    *pdwFree  = dwFree;
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvbenchmark.cpp ===
// **************************************************************************
//
//       Copyright 1993-2001 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvBenchmark.cpp
//   Utility class for benchmarking and profiling purposes
//
//  History:
//      Menelaos Levas   1/30/2001
//
//
//
//
/********************************************************************/



#include "nvprecomp.h"
#ifdef NV_PROFILE_DP2OPS

char opLookupTable[D3D_DP2OP_MAX+1][64] =
{
    " ",                                           //  0
    "D3DDP2OP_POINTS",                              //  1
    "D3DDP2OP_INDEXEDLINELIST",                     //  2
    "D3DDP2OP_INDEXEDTRIANGLELIST",                 //  3
    "D3DDP2OP_RESERVED0",                           //  4
    " ",                                           //  5
    " ",                                           //  6
    " ",                                           //  7
    "D3DDP2OP_RENDERSTATE",                         //  8
    " ",                                           //  9
    " ",                                           // 10
    "D3DDP2OP_END",                                 // 11
    " ",                                           // 12
    " ",                                           // 13
    " ",                                           // 14
    "D3DDP2OP_LINELIST",                            // 15
    "D3DDP2OP_LINESTRIP",                           // 16
    "D3DDP2OP_INDEXEDLINESTRIP",                    // 17
    "D3DDP2OP_TRIANGLELIST",                        // 18
    "D3DDP2OP_TRIANGLESTRIP",                       // 19
    "D3DDP2OP_INDEXEDTRIANGLESTRIP",                // 20
    "D3DDP2OP_TRIANGLEFAN",                         // 21
    "D3DDP2OP_INDEXEDTRIANGLEFAN",                  // 22
    "D3DDP2OP_TRIANGLEFAN_IMM",                     // 23
    "D3DDP2OP_LINELIST_IMM",                        // 24
    "D3DDP2OP_TEXTURESTAGESTATE",                   // 25
    "D3DDP2OP_INDEXEDTRIANGLELIST2",                // 26
    "D3DDP2OP_INDEXEDLINELIST2",                    // 27
    "D3DDP2OP_VIEWPORTINFO",                        // 28
    "D3DDP2OP_WINFO",                               // 29
    "D3DDP2OP_SETPALETTE",                          // 30
    "D3DDP2OP_UPDATEPALETTE",                       // 31
    "D3DDP2OP_ZRANGE",                              // 32
    "D3DDP2OP_SETMATERIAL",                         // 33
    "D3DDP2OP_SETLIGHT",                            // 34
    "D3DDP2OP_CREATELIGHT",                         // 35
    "D3DDP2OP_SETTRANSFORM",                        // 36
    "D3DDP2OP_EXT",                                 // 37
    "D3DDP2OP_TEXBLT",                              // 38
    "D3DDP2OP_STATESET",                            // 39
    "D3DDP2OP_SETPRIORITY",                         // 40
    "D3DDP2OP_SETRENDERTARGET",                     // 41
    "D3DDP2OP_CLEAR",                               // 42
    "D3DDP2OP_SETTEXLOD",                           // 43
    "D3DDP2OP_SETCLIPPLANE",                        // 44
    "D3DDP2OP_CREATEVERTEXSHADER",                  // 45
    "D3DDP2OP_DELETEVERTEXSHADER",                  // 46
    "D3DDP2OP_SETVERTEXSHADER",                     // 47
    "D3DDP2OP_SETVERTEXSHADERCONST",                // 48
    "D3DDP2OP_SETSTREAMSOURCE",                     // 49
    "D3DDP2OP_SETSTREAMSOURCEUM",                   // 50
    "D3DDP2OP_SETINDICES",                          // 51
    "D3DDP2OP_DRAWPRIMITIVE",                       // 52
    "D3DDP2OP_DRAWINDEXEDPRIMITIVE",                // 53
    "D3DDP2OP_CREATEPIXELSHADER",                   // 54
    "D3DDP2OP_DELETEPIXELSHADER",                   // 55
    "D3DDP2OP_SETPIXELSHADER",                      // 56
    "D3DDP2OP_SETPIXELSHADERCONST",                 // 57
    "D3DDP2OP_CLIPPEDTRIANGLEFAN",                  // 58
    "D3DDP2OP_DRAWPRIMITIVE2",                      // 59
    "D3DDP2OP_DRAWINDEXEDPRIMITIVE2",               // 60
    "D3DDP2OP_DRAWRECTSURFACE",                     // 61
    "D3DDP2OP_DRAWTRISURFACE",                      // 62
    "D3DDP2OP_VOLUMEBLT",                           // 63
    "D3DDP2OP_BUFFERBLT",                           // 64
    "D3DDP2OP_MULTIPLYTRANSFORM"                    // 65
};

char opTypes[D3D_DP2OP_MAX+1] = 
{
    0,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    1,
    1,
    0,
    0,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    0,
    1,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    1,
    2,
    2,
    2,
    2,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2
};


DWORD CBenchmark::resetData() {
    for (DWORD i = 0; i <= D3D_DP2OP_MAX; i++) {
        dwCallsCountTable[i] = 0;
        dwPrimsCountTable[i] = 0;
    }

    dwDrawingCalls = 0;
    dwStateCalls = 0;
    dwDrawingPrimCount = 0; 
    dwStatePrimCount = 0;
    dwCurrentFrame = 0;
    dwHWStateChanges = 0;
    dwStateBlocks = 0;
    dwDrawBlocks = 0;
    dwLastType = 0;

    dwStartPut = 0;
    dwHWStateChangeSize = 0;
    dwActiveTextures = 0;    
    dwLastPrimCount = 0;

    for (i = 0; i < 5; i++) 
        dwTexPrims[i] = 0;
    for (i = 0; i < 13; i++) 
        dwHWChanged[i] = 0;

    for (i = 0; i < 8192; i++)
        dwStateBits[i] = 0;
    
    return 0;
}

DWORD CBenchmark::logData(DWORD dwCommand, DWORD dwPrimCount) {
    dwCallsCountTable[dwCommand]++;
    dwPrimsCountTable[dwCommand] += dwPrimCount;
    if (opTypes[dwCommand] == 1) {
        dwDrawingCalls++;
        if (dwPrimCount > 1) {
            dwDrawingPrimCount += dwPrimCount;
            dwLastPrimCount = dwPrimCount;
        }
        if (dwLastType == 2)
            dwDrawBlocks++;
    }
    else if (opTypes[dwCommand] == 2) {
        dwStateCalls++;
        dwStatePrimCount += dwPrimCount;
        if (dwLastType == 1)
            dwStateBlocks++;
    }

    dwLastType = opTypes[dwCommand];

    return 0;
}

DWORD CBenchmark::logDrawPrimitive(DWORD dwCount) {
//    primitives += wCount;
    dwDrawingPrimCount += dwCount;
    dwLastPrimCount = dwCount;

    return 0;
}

DWORD CBenchmark::beginHWStateChange(DWORD dwFlags, DWORD dwPut) {

    dwStartPut = dwPut;    
    
#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        dwFlags &= KELVIN_DIRTY_REALLY_FILTHY;
        dwStateBits[dwFlags >> 16]++;
        if (dwFlags & KELVIN_DIRTY_COMBINERS_COLOR) dwHWChanged[0]++; 
        if (dwFlags & KELVIN_DIRTY_COMBINERS_SPECFOG) dwHWChanged[1]++;
        if (dwFlags & KELVIN_DIRTY_CONTROL0) dwHWChanged[2]++;
        if (dwFlags & KELVIN_DIRTY_DEFAULTS) dwHWChanged[3]++;
        if (dwFlags & KELVIN_DIRTY_FVF) dwHWChanged[4]++;
        if (dwFlags & KELVIN_DIRTY_LIGHTS) dwHWChanged[5]++;
        if (dwFlags & KELVIN_DIRTY_MISC_STATE) dwHWChanged[6]++;
        if (dwFlags & KELVIN_DIRTY_SURFACE) dwHWChanged[7]++;
        if (dwFlags & KELVIN_DIRTY_TEXTURE_STATE) { dwHWChanged[8]++; dwActiveTextures = 0; }
        if (dwFlags & KELVIN_DIRTY_TEXTURE_TRANSFORM) dwHWChanged[9]++;
        if (dwFlags & KELVIN_DIRTY_TRANSFORM) dwHWChanged[10]++;
        if (dwFlags & KELVIN_DIRTY_VERTEX_SHADER) dwHWChanged[11]++;
        if (dwFlags & KELVIN_DIRTY_PIXEL_SHADER) dwHWChanged[12]++;        
    } else
#endif
#if (NVARCH >= 0x010)
    {
        dwFlags &= CELSIUS_DIRTY_REALLY_FILTHY;
        if (dwFlags & CELSIUS_DIRTY_COMBINERS) dwHWChanged[0]++; 
        if (dwFlags & CELSIUS_DIRTY_SPECFOG_COMBINER) dwHWChanged[1]++;
        if (dwFlags & CELSIUS_DIRTY_CONTROL0) dwHWChanged[2]++;
        if (dwFlags & CELSIUS_DIRTY_DEFAULTS) dwHWChanged[3]++;
        if (dwFlags & CELSIUS_DIRTY_FVF) dwHWChanged[4]++;
        if (dwFlags & CELSIUS_DIRTY_LIGHTS) dwHWChanged[5]++;
        if (dwFlags & CELSIUS_DIRTY_MISC_STATE) dwHWChanged[6]++;
        if (dwFlags & CELSIUS_DIRTY_SURFACE) dwHWChanged[7]++;
        if (dwFlags & CELSIUS_DIRTY_TEXTURE_STATE) dwHWChanged[8]++;
        if (dwFlags & CELSIUS_DIRTY_TEXTURE_TRANSFORM) dwHWChanged[9]++;
        if (dwFlags & CELSIUS_DIRTY_TRANSFORM) dwHWChanged[10]++;
        if (dwFlags & CELSIUS_DIRTY_TL_MODE) dwHWChanged[11]++;
        if (dwFlags & CELSIUS_DIRTY_PIXEL_SHADER) dwHWChanged[12]++;    
    }
#endif

    dwHWStateChanges++;
    return 0;
}

DWORD CBenchmark::endHWStateChange(DWORD dwPut) {
    if (dwPut > dwStartPut)
        dwHWStateChangeSize += dwPut - dwStartPut;
    else 
        dwHWStateChangeSize += pDriverData->nvPusher.getBase() + pDriverData->nvPusher.getSize() - dwStartPut +
                                dwPut - pDriverData->nvPusher.getBase();

    dwTexPrims[dwActiveTextures] += dwLastPrimCount;

    return 0;
}

DWORD CBenchmark::incActiveTextures() {
    dwActiveTextures++;
    return 0;
} 

DWORD CBenchmark::outputData(DWORD dwFlags) {
    if ((dwFlags & OUTPUT_FRAMECOUNT) > dwCurrentFrame) {
        dwCurrentFrame++;
        return 0;
    }

    if (dwFlags & OUTPUT_ALL_DP2OPS) {
        for (DWORD i = 0; i <= D3D_DP2OP_MAX; i++) { 
            if ((opTypes[i] != 0) && (dwCallsCountTable[i] != 0)) 
                PF("%s: calls: %d, prims: %d, average: %f", opLookupTable[i], 
                    dwCallsCountTable[i], dwPrimsCountTable[i], 
                    dwPrimsCountTable[i]/((float)dwCallsCountTable[i]));
        }
        PF("*************************************************************");
    }

    if (dwFlags & OUTPUT_TOTALS) {
        PF("TOTALS:");
        PF("Total drawing calls: %d, prims: %d, average: %f",
            dwDrawingCalls, dwDrawingPrimCount, dwDrawingPrimCount/((float)dwDrawingCalls));

        if (dwTexPrims[0] > 0)
            PF("Untextured prims: %d (%f)", dwTexPrims[0], 100*dwTexPrims[0]/(float)dwDrawingPrimCount);
        if (dwTexPrims[1] > 0)
            PF("Single textured prims: %d (%f)", dwTexPrims[1], 100*dwTexPrims[1]/(float)dwDrawingPrimCount);
        if (dwTexPrims[2] > 0)
            PF("Dual textured prims: %d (%f)", dwTexPrims[2], 100*dwTexPrims[2]/(float)dwDrawingPrimCount);
        if (dwTexPrims[3] > 0)
            PF("Triple textured prims: %d (%f)", dwTexPrims[3], 100*dwTexPrims[3]/(float)dwDrawingPrimCount);
        if (dwTexPrims[4] > 0)
            PF("Quad textured prims: %d (%f)", dwTexPrims[4], 100*dwTexPrims[4]/(float)dwDrawingPrimCount);

        PF("Total state calls: %d, prims: %d, average: %f",
            dwStateCalls, dwStatePrimCount, dwStatePrimCount/((float)dwStateCalls));
        PF("Total uninterrupted drawing blocks: %d, average size: %f", dwDrawBlocks, dwDrawingPrimCount/(float)dwStateBlocks);
        PF("Total uninterrupted state blocks: %d, average size: %f", dwStateBlocks, dwStatePrimCount/(float)dwStateBlocks);
        PF("*************************************************************");  
    }

    if (dwFlags & OUTPUT_HWSTATE_CHANGES) { 
#if (NVARCH >= 0x020)
        PF("HW STATE BITS:");
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            for (int i = 0; i < 8191; i++) 
            {
                if (dwStateBits[i] )
                {
                    DWORD state = i;
                    state <<= 16;
                    if (state & KELVIN_DIRTY_COMBINERS_COLOR)
                        PF("KELVIN_DIRTY_COMBINERS_COLOR |");
                    if (state & KELVIN_DIRTY_COMBINERS_SPECFOG)
                        PF("KELVIN_DIRTY_COMBINERS_SPECFOG |");
                    if (state & KELVIN_DIRTY_CONTROL0)
                        PF("KELVIN_DIRTY_CONTROL0 |");
                    if (state & KELVIN_DIRTY_DEFAULTS)
                        PF("KELVIN_DIRTY_DEFAULTS |");
                    if (state & KELVIN_DIRTY_FVF)
                        PF("KELVIN_DIRTY_FVF |");
                    if (state & KELVIN_DIRTY_LIGHTS)
                        PF("KELVIN_DIRTY_LIGHTS |");
                    if (state & KELVIN_DIRTY_MISC_STATE)
                        PF("KELVIN_DIRTY_MISC_STATE |");
                    if (state & KELVIN_DIRTY_SURFACE)
                        PF("KELVIN_DIRTY_SURFACE |");
                    if (state & KELVIN_DIRTY_TEXTURE_STATE)
                        PF("KELVIN_DIRTY_TEXTURE_STATE |");
                    if (state & KELVIN_DIRTY_TEXTURE_TRANSFORM)
                        PF("KELVIN_DIRTY_TEXTURE_TRANSFORM |");
                    if (state & KELVIN_DIRTY_TRANSFORM)
                        PF("KELVIN_DIRTY_TRANSFORM |");
                    if (state & KELVIN_DIRTY_VERTEX_SHADER)
                        PF("KELVIN_DIRTY_VERTEX_SHADER |");
                    if (state & KELVIN_DIRTY_PIXEL_SHADER)
                        PF("KELVIN_DIRTY_PIXEL_SHADER |");
                    PF("  %d", dwStateBits[i]); PF("");

                
                }
            }
        }
        if (dwStateBits[8191]) 
        {
            PF("KELVIN_DIRTY_REALLY_FILTHY: %d", dwStateBits[8191]);
        }
#endif

        PF("HW STATE CHANGES:");
        PF("Total HW state change pushbuffer size: %d, average per block: %f", 
            dwHWStateChangeSize, dwHWStateChangeSize/(float)dwStateBlocks); 
        PF("Total HW state changes: %d", dwHWStateChanges);
        PF("Color combiner state changes: %d", dwHWChanged[0]);
        PF("Specfog state changes: %d", dwHWChanged[1]);
        PF("Control0 state changes: %d", dwHWChanged[2]);
        PF("Defaults state changes: %d", dwHWChanged[3]);
        PF("FVF state changes: %d", dwHWChanged[4]);
        PF("Lights state changes: %d", dwHWChanged[5]);
        PF("Misc state changes: %d", dwHWChanged[6]);
        PF("Surface state changes: %d", dwHWChanged[7]);
        PF("Texture state changes: %d", dwHWChanged[8]);
        PF("Texture transform state changes: %d", dwHWChanged[9]);        
        PF("Transform state changes: %d", dwHWChanged[10]);
        PF("TL/Vertex shader state changes: %d", dwHWChanged[11]);
        PF("Pixel Shader state changes: %d", dwHWChanged[12]);
        PF("*************************************************************");
    }

    dwCurrentFrame = 0;

    if (dwFlags & CLEAR_DATA)
        resetData();

    return 0;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvBlit.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*==========================================================================;
 *
 *  Copyright (C) 1995, 1999 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       nvBlit.cpp
 *  Content:    Windows95 DirectDraw 32 bit driver
 *
 ***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

// Convert pusher threshold from word to safe dword value
const int g_iPusherThreshold = (NVPUSHER_THRESHOLD_SIZE >> 1) - 1;

//---------------------------------------------------------------------------
// GetBltStatus32
//      DX callback
DWORD __stdcall GetBltStatus32 (LPDDHAL_GETBLTSTATUSDATA lpGetBltStatus)
{
    dbgTracePush ("GetBltStatus32");

    DDSTARTTICK(SURF4_GETBLTSTATUS);
    nvSetDriverDataPtrFromDDGbl (lpGetBltStatus->lpDD);

    if ( lpGetBltStatus->dwFlags == DDGBS_CANBLT ) {

        // CANBLT: can we add a blt?

        // make sure that we've flipped away from the destination surface
        lpGetBltStatus->ddRVal = getFlipStatus(lpGetBltStatus->lpDDSurface->lpGbl->fpVidMem,
                                               lpGetBltStatus->lpDDSurface->ddsCaps.dwCaps);

        if ( lpGetBltStatus->ddRVal == DD_OK ) {
            if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
                if (!nvEnable32(lpGetBltStatus->lpDD)) {
                    NvReleaseSemaphore(pDriverData);
                    lpGetBltStatus->ddRVal = DDERR_SURFACELOST;
                    DDENDTICK(SURF4_GETBLTSTATUS);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }
            }
            // so there was no flip going on, is there room in the fifo to add a blt?
            getDC()->nvPusher.setSyncChannelFlag();
            lpGetBltStatus->ddRVal = DD_OK;
        }
    }

    else {

        // DONEBLT: is a blt in progress?

        // Some apps call GetBltStatus many times after calling Blit even after they were told that it was done
        if (pDriverData->blitCalled == FALSE) {
            NvReleaseSemaphore(pDriverData);
            lpGetBltStatus->ddRVal = DD_OK;
            DDENDTICK(SURF4_GETBLTSTATUS);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }

        if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
            if (!nvEnable32(lpGetBltStatus->lpDD)) {
                NvReleaseSemaphore(pDriverData);
                lpGetBltStatus->ddRVal = DDERR_SURFACELOST;
                DDENDTICK(SURF4_GETBLTSTATUS);
                dbgTracePop();
                return (DDHAL_DRIVER_HANDLED);
            }
        }

        /* If a texture surface then just wait for notifier */
        if (lpGetBltStatus->lpDDSurface->ddsCaps.dwCaps & DDSCAPS_TEXTURE) {

            /*
             * Only check hardware status if we actually use HW to do texture blts.
             */
/*
            if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_TEXTURE_USEHW)
            {
                BOOL bBusy;
                CNvObject *pObj = GET_PNVOBJ(lpGetBltStatus->lpDDSurface);
                DWORD   dwClass = pObj ? pObj->getClass() : CNvObject::NVOBJ_UNKNOWN;

                switch (dwClass) {
                case CNvObject::NVOBJ_SIMPLESURFACE:
                    bBusy = lpGetBltStatus->ddRVal = pObj->getSimpleSurface()->isBusy();
                    break;
                case CNvObject::NVOBJ_TEXTURE:
                    bBusy = lpGetBltStatus->ddRVal = pObj->getTexture()->getSwizzled()->isBusy();
                    break;
                default:
                    bBusy = WaitForIdle(FALSE, FALSE);
                    break;
                } // switch

                if (bBusy) {
                    nvPusherStart(TRUE);
                    lpGetBltStatus->ddRVal = DDERR_WASSTILLDRAWING;
                } else {
                    lpGetBltStatus->ddRVal = DD_OK;
                }
            }
            else
*/
            {
                lpGetBltStatus->ddRVal = DD_OK;
            }

            NvReleaseSemaphore(pDriverData);
            DDENDTICK(SURF4_GETBLTSTATUS);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }

        /* Is there a DMA push blit synchronization in progress ? */
        if (pDriverData->syncDmaRecord.bSyncFlag) { /* if so then check status */

            if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
                if (!getDC()->pRefCount->wait (CReferenceCount::WAIT_COOPERATIVE,
                                               pDriverData->bltData.dwStatusReferenceCount,
                                               0)) {
                    lpGetBltStatus->ddRVal = DDERR_WASSTILLDRAWING;
                }
                else {
                    lpGetBltStatus->ddRVal = DD_OK;
                    pDriverData->syncDmaRecord.bSyncFlag = FALSE;
                    pDriverData->blitCalled = FALSE;
                }
            }
            else {
                if (getDC()->nvPusher.isIdle(TRUE)) {
                    pDriverData->syncDmaRecord.bSyncFlag = FALSE;
                    pDriverData->blitCalled = FALSE;
                    lpGetBltStatus->ddRVal = DD_OK;
                } else {
                    lpGetBltStatus->ddRVal = DDERR_WASSTILLDRAWING;
                    // always make sure everything has been pushed off
                    nvPusherStart(TRUE);
                }
            }
        }
        else { /* start a blit synchronization sequence */
            pDriverData->syncDmaRecord.bSyncFlag = TRUE;

            if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
                pDriverData->bltData.dwStatusReferenceCount = getDC()->pRefCount->inc (CReferenceCount::INC_LAZY);
                nvPusherStart (TRUE);
                lpGetBltStatus->ddRVal = DDERR_WASSTILLDRAWING;
            }
            else {
                if (getDC()->nvPusher.isIdle(TRUE)) {
                    pDriverData->syncDmaRecord.bSyncFlag = FALSE;
                    pDriverData->blitCalled = FALSE;
                    lpGetBltStatus->ddRVal = DD_OK;
                } else {
                    lpGetBltStatus->ddRVal = DDERR_WASSTILLDRAWING;
                    // always make sure everything has been pushed off
                    nvPusherStart(TRUE);
                }
            }
        }
    }

    NvReleaseSemaphore(pDriverData);
    DDENDTICK(SURF4_GETBLTSTATUS);
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);

} // GetBltStatus32

//---------------------------------------------------------------------------

void nvCheckQueuedBlits (void)
{
    // max queued frames is regPreRenderLimit (defaults to 3 - PC99 spec)
    DWORD dwMaxQueuedBlits = getDC()->nvD3DRegistryData.regPreRenderLimit;

    // read HW blit #
    DWORD dwCompletedBlit = getDC()->pBlitTracker->get();

    // have we progressed too far?
    while ((getDC()->dwCurrentBlit - dwCompletedBlit) > dwMaxQueuedBlits)
    {
        // kick off buffer
        nvPusherStart (TRUE);
        // wait for HW to catch up
        nvDelay();
        dwCompletedBlit = getDC()->pBlitTracker->get();
    }
}

//---------------------------------------------------------------------------

void nvUpdateBlitTracker (void)
{
    // update frame counters
    getDC()->dwCurrentBlit ++;
    getDC()->pBlitTracker->put (getDC()->dwCurrentBlit);
    // kick off buffer
    nvPusherStart (TRUE);
}

//---------------------------------------------------------------------------
// bltInit
//      Initialize blit globals
void __stdcall bltInit(void)
{
    pDriverData->bltData.dwSystemSurfaceContextDMAIndex = 0;
    pDriverData->bltSysMemInfo.dwLocale = BLTWS_UNINITIALIZED;
    pDriverData->bltAGPMemInfo.dwLocale = BLTWS_UNINITIALIZED;
    pDriverData->bltVidMemInfo.dwLocale = BLTWS_UNINITIALIZED;
    pDriverData->bltData.dwLastRop = 0xFFFFFFFF;
    pDriverData->bltData.dwLastColourKey = 0xFFFFFFF0;
    pDriverData->bltData.dwLastColourFormat = 0;
    pDriverData->bltData.dwLastCombinedPitch = 0;
    pDriverData->bltData.dwLastSrcOffset = 0xFFFFFFFF;
    pDriverData->bltData.dwLastDstOffset = 0xFFFFFFFF;
    pDriverData->bltData.dwSystemBltFallback = FALSE;
    pDriverData->bltData.dwLetItThrash = FALSE;
}

//---------------------------------------------------------------------------
// Blit32
//      DX callback.  Uber-function for calling all the blit styles
//
// Hints and rules of thumb
//      - bltSimpleCopy and blt4CCto4CC do not required Surfaces2D to be
//        initialized, all other blit functions do
//      - bltSimpleCopy can handle all combinations of sources and destinations
//        except for system memory to system memory copies
//      - bltSimpleVtoVBlt must have both source and destination is local
//        video memory
//      - Only bltSimpleVtoVBlt can handle colour keys and non-trivial ROPs
//      - bltStrBlt may return NOT_HANDLED
//      - bltStrBlt sources can be in local or system memory
//      - bltStrBlt destination must be in local video memory
//      - Error checks are required for workspace allocation
//      - When using an intermediate workspace, remember to set Surfaces2D
//      - Be careful about using workspaces for multiple things that can't
//        be done in place.  Color keyed S->V and 8 bpp strblts already use
//        local workspaces

#ifdef  STEREO_SUPPORT
#ifdef  PER_PRIMITIVE_SYNC
#define SyncToHw                                \
        StereoSync();               
#else   //PER_PRIMITIVE_SYNC==0
#define SyncToHw
#endif  //PER_PRIMITIVE_SYNC

#define CheckStereoSecondPass                   \
        if (--dwNPasses)                        \
            goto StereoSecondPass;
#else   //STEREO_SUPPORT==0
#define CheckStereoSecondPass
#define SyncToHw
#endif  //STEREO_SUPPORT

#define BLT_ABNORMAL_EXIT                       \
        {                                       \
            SyncToHw;                           \
            if (dst.bDefaultBlitChanged) {                                  \
                nvPushData(0, dDrawSubchannelOffset(NV_DD_BLIT) | 0x40000); \
                nvPushData(1, NV_DD_IMAGE_BLIT);                            \
                nvPusherAdjust(2);                                          \
            }                                           \
        if (bRewriteSurfData) {                                   \
            dst.pGbl->fpVidMem = fpOldVidMem;                           \
            dst.pGbl->lPitch = lOldPitch;                               \
            dst.pGbl->wHeight = wOldHeight;                             \
                dst.pGbl->wWidth = wOldWidth;                               \
            }                                                             \
            CheckStereoSecondPass;              \
            DDENDTICK(SURF4_BLT);               \
            NvReleaseSemaphore(pDriverData);    \
            dbgTracePop();                      \
            return retVal;                      \
        }

#define BLT_EXIT                                                            \
    {                                                                       \
      SyncToHw;                                                             \
      if (dst.bDefaultBlitChanged) {                                        \
            nvPushData(0, dDrawSubchannelOffset(NV_DD_BLIT) | 0x40000);     \
            nvPushData(1, NV_DD_IMAGE_BLIT);                                \
            nvPusherAdjust(2);                                              \
            nvPusherStart(TRUE);                                            \
        }                                                                   \
        if (bRewriteSurfData) {                             \
        dst.pGbl->fpVidMem = fpOldVidMem;                               \
        dst.pGbl->lPitch = lOldPitch;                                   \
        dst.pGbl->wHeight = wOldHeight;                                 \
            dst.pGbl->wWidth = wOldWidth;                                   \
        }                                                                   \
        if (dst.bIsLocked)                                                  \
        {                                                                   \
            if (dst.pObj->getClass()==CNvObject::NVOBJ_TEXTURE)             \
            {                                                               \
                if( dst.bUseSwizzle ) {                                     \
                    dst.pObj->getTexture()->getSwizzled()->hwUnlock();      \
                    dst.pObj->getTexture()->getSwizzled()->tagUpToDate();   \
                    dst.pObj->getTexture()->getLinear()->tagOutOfDate();    \
                } else {                                                    \
                    dst.pObj->getTexture()->getLinear()->hwUnlock();        \
                    dst.pObj->getTexture()->getLinear()->tagUpToDate();     \
                    dst.pObj->getTexture()->getSwizzled()->tagOutOfDate();  \
                }                                                           \
            } else                                                          \
                dst.pObj->getSimpleSurface()->hwUnlock();                   \
            nvPusherStart(TRUE);                                            \
            dst.bIsLocked = FALSE;                                          \
        }                                                                   \
        if (src.bIsLocked)                                                  \
        {                                                                   \
            if (src.pObj->getClass()==CNvObject::NVOBJ_TEXTURE)             \
            {                                                               \
                if( src.bUseSwizzle ) {                                     \
                    src.pObj->getTexture()->getSwizzled()->hwUnlock();      \
                    src.pObj->getTexture()->getSwizzled()->tagUpToDate();   \
                    src.pObj->getTexture()->getLinear()->tagOutOfDate();    \
                } else {                                                    \
                    src.pObj->getTexture()->getLinear()->hwUnlock();        \
                    src.pObj->getTexture()->getLinear()->tagUpToDate();     \
                    src.pObj->getTexture()->getSwizzled()->tagOutOfDate();  \
                }                                                           \
            } else                                                          \
                src.pObj->getSimpleSurface()->hwUnlock();                   \
            nvPusherStart(TRUE);                                            \
            src.bIsLocked = FALSE;                                          \
        }                                                                   \
        if (retVal == DDHAL_DRIVER_HANDLED) {                               \
            CheckStereoSecondPass;                                          \
            if (doFlushOnExit) {                                            \
                getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY); \
            }                                                               \
            DDENDTICK(SURF4_BLT);                                           \
            NvReleaseSemaphore(pDriverData);                                \
            dbgTracePop();                                                  \
            return retVal;                                                  \
        }                                                                   \
    }

//---------------------------------------------------------------------------

DWORD __stdcall Blit32( LPDDHAL_BLTDATA pbd )
{
    SURFINFO src, dst, ws;
    DWORD dwPbdFlags;
    DWORD retVal = DDHAL_DRIVER_HANDLED;
    DWORD dwBytesPerPixel;
    BOOL doStretchX, doStretchY, doStretch;
    BOOL doMirrorX, doMirrorY, doMirror;
    BOOL doFlushOnExit;
    BOOL bDoEarlyBlitFallback = FALSE;
    BOOL bStretchLinearFilter = TRUE;
    BOOL bRewriteSurfData = FALSE;
    BOOL bSrcBPPSpecified = FALSE;

    FLATPTR fpOldVidMem = NULL;
    LONG lOldPitch = 0;

#ifdef WINNT
    DWORD wOldHeight = 0;
    DWORD wOldWidth = 0;
#else
    WORD wOldHeight = 0;
    WORD wOldWidth = 0;
#endif

#ifdef  STEREO_SUPPORT
    STEREOBLTPASSINFO StereoBltPass;
    StereoBltPass.dwPass = 0;
    DWORD   dwNPasses = 1;
#endif  //STEREO_SUPPORT

    dbgTracePush ("Blit32");

    DDSTARTTICK(SURF4_BLT);

    nvSetDriverDataPtrFromDDGbl (pbd->lpDD);
    DWORD dwModeBPP = GET_MODE_BPP();

    dwPbdFlags = pbd->dwFlags;

    dwBytesPerPixel = (dwModeBPP + 1) >> 3;

    // force the blit wait flag if requested in the registry
    if (getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_FORCEBLITWAITFLAGENABLE_ENABLE) {
        dwPbdFlags |= DDBLT_WAIT;
    }

    // force flush on exit if DDBLT_WAIT flag is set & registry key is enabled
    doFlushOnExit = (getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_FLUSHAFTERBLITENABLE_ENABLE) &&
                    (dwPbdFlags & DDBLT_WAIT);

    // get commonly used surface data
    src.pLcl = pbd->lpDDSrcSurface;
    dst.pLcl = pbd->lpDDDestSurface;
    src.dwFourCC = dst.dwFourCC = 0;
    src.dwCaps = dst.dwCaps = 0;
    src.pObj = dst.pObj = NULL;
    src.pGbl = dst.pGbl = NULL;
    src.dwPitch = dst.dwPitch = 0;
    src.dwWidth = dst.dwWidth = 0;
    src.dwHeight = dst.dwHeight = 0;
    src.dwOffset = dst.dwOffset = 0;
    src.fpVidMem = dst.fpVidMem = 0;
    src.isPotentialFault = dst.isPotentialFault = FALSE;
    src.dwBytesPerPixel = dst.dwBytesPerPixel = dwBytesPerPixel;
    src.bUseSwizzle = dst.bUseSwizzle = FALSE;
    src.bIsLocked = dst.bIsLocked = FALSE;
    src.bDefaultBlitChanged = dst.bDefaultBlitChanged = FALSE;

    if(dst.pLcl){
        //have to set this BEFORE we do the
        //becuase it is used to determing the
        //ContextDMA optimization while
        //seting up the src object.
        dst.dwCaps = dst.pLcl->ddsCaps.dwCaps;
    }

    // source info
    if (src.pLcl) {
        src.pObj = GET_PNVOBJ(src.pLcl);
        src.dwCaps = src.pLcl->ddsCaps.dwCaps;
        src.pGbl = src.pLcl->lpGbl;
        src.dwSubRectX = pbd->rSrc.left;
        src.dwSubRectY = pbd->rSrc.top;
        src.dwSubRectWidth = pbd->rSrc.right - src.dwSubRectX;
        src.dwSubRectHeight = pbd->rSrc.bottom - src.dwSubRectY;
        if (src.pGbl) {
            src.fpVidMem = src.pGbl->fpVidMem;
            src.dwPitch = src.pGbl->lPitch;
            src.dwWidth = src.pGbl->wWidth;
            src.dwHeight = src.pGbl->wHeight;
            if (src.pLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) {
                bSrcBPPSpecified = TRUE;
                if (src.pGbl->ddpfSurface.dwFlags & DDPF_FOURCC) {
                    src.dwFourCC = src.pGbl->ddpfSurface.dwFourCC;
                    src.dwBytesPerPixel = 2;
                } else {
                    src.dwBytesPerPixel = (src.pGbl->ddpfSurface.dwRGBBitCount + 1) >> 3;
                }
            }
            if (src.dwCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM)) {
                if ((src.dwCaps & DDSCAPS_TEXTURE) || (dst.dwCaps & DDSCAPS_TEXTURE)) {
                    // system or AGP memory and not a texture (D3D will handle this)
                    src.dwOffset = 0;
                    src.dwContextDma = 0;
                } else if (pDriverData->bltData.dwSystemBltFallback) {
                    src.dwContextDma = 0;
                    bDoEarlyBlitFallback = TRUE;
                } else {
#ifndef WINNT
                    // don't do this for WINNT because they can sometimes hand us an aliased linear address
                    // to an AGP surface which is nowhere near the GARTLinearBase that we know about
                    if ((src.dwCaps & DDSCAPS_NONLOCALVIDMEM) && pDriverData->GARTLinearBase) {
                        // AGP memory
                        src.dwContextDma = D3D_CONTEXT_DMA_HOST_MEMORY;
                        src.dwOffset = AGPMEM_OFFSET(src.pGbl->fpVidMem);
                    } else {
#endif
                        // system memory
                        src.dwOffset = 0;
                        retVal = bltCreateContextDMA(pbd, &src);
                        if (retVal != DDHAL_DRIVER_HANDLED) {
                            src.dwContextDma = 0;
                            bDoEarlyBlitFallback = TRUE;
                        }
#ifndef WINNT
                    }
#endif
                }
            } else {
                // video memory
                src.dwOffset = VIDMEM_OFFSET(src.pGbl->fpVidMem);
                src.dwContextDma = NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY;
            }
        }
        // do this last, need the invalid one to create a context DMA
        src.pObj = IS_VALID_PNVOBJ(src.pObj) ? src.pObj : NULL;
    }

    // destination info
    if (dst.pLcl) {
        dst.pObj = GET_PNVOBJ(dst.pLcl);
        dst.dwCaps = dst.pLcl->ddsCaps.dwCaps;
        dst.pGbl = dst.pLcl->lpGbl;
        dst.dwSubRectX = pbd->rDest.left;
        dst.dwSubRectY = pbd->rDest.top;
        dst.dwSubRectWidth = pbd->rDest.right - dst.dwSubRectX;
        dst.dwSubRectHeight = pbd->rDest.bottom - dst.dwSubRectY;
        if (dst.pGbl) {
            dst.fpVidMem = dst.pGbl->fpVidMem;
            dst.dwPitch = dst.pGbl->lPitch;
            dst.dwWidth = dst.pGbl->wWidth;
            dst.dwHeight = dst.pGbl->wHeight;
            if (dst.pLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) {
                if (dst.pGbl->ddpfSurface.dwFlags & DDPF_FOURCC) {
                    dst.dwFourCC = dst.pGbl->ddpfSurface.dwFourCC;
                    dst.dwBytesPerPixel = 2;
                } else {
                    dst.dwBytesPerPixel = (dst.pGbl->ddpfSurface.dwRGBBitCount + 1) >> 3;
                }
                if (!bSrcBPPSpecified) {
                    src.dwBytesPerPixel = dst.dwBytesPerPixel;
                }
            }
            if (dst.dwCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM) 
                && (dst.dwFourCC!=FOURCC_DXT1) && (dst.dwFourCC!=FOURCC_DXT2)  
                && (dst.dwFourCC!=FOURCC_DXT3) && (dst.dwFourCC!=FOURCC_DXT4) 
                && (dst.dwFourCC!=FOURCC_DXT5)) {
                // system or AGP memory
                if (pDriverData->bltData.dwSystemBltFallback) {
                    dst.dwContextDma = 0;
                    bDoEarlyBlitFallback = TRUE;
                } else {
#ifndef WINNT
                    // don't do this for WINNT because they can sometimes hand us an aliased linear address
                    // to an AGP surface which is nowhere near the GARTLinearBase that we know about
                    if ((dst.dwCaps & DDSCAPS_NONLOCALVIDMEM) && pDriverData->GARTLinearBase) {
                        // AGP memory
                        dst.dwContextDma = D3D_CONTEXT_DMA_HOST_MEMORY;
                        dst.dwOffset = AGPMEM_OFFSET(dst.pGbl->fpVidMem);
                    } else {
#endif
                        // system memory
                        dst.dwOffset = 0;
                        retVal = bltCreateContextDMA(pbd, &dst);
                        if (retVal != DDHAL_DRIVER_HANDLED) {
                            dst.dwContextDma = 0;
                            bDoEarlyBlitFallback = TRUE;
                        }
#ifndef WINNT
                    }
#endif
                }
            } else {
                // video memory
                dst.dwOffset = VIDMEM_OFFSET(dst.pGbl->fpVidMem);
                dst.dwContextDma = NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY;
            }
        }
        // do this last, need the invalid one to create a context DMA
        dst.pObj = IS_VALID_PNVOBJ(dst.pObj) ? dst.pObj : NULL;
    }

    // update frame tracker if appropriate
    if ((dwPbdFlags & DDBLT_LAST_PRESENTATION)
        ||
        // DX7 - if registry key is set, allow at most "regPreRenderLimit" blits to primary with the
        // DDBLT_WAIT flag to queue up. this prevents horrible lag if we queue too many.
        ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_LIMITQUEUEDFBBLITSENABLE_ENABLE) &&
         (dst.dwCaps & (DDSCAPS_FRONTBUFFER | DDSCAPS_PRIMARYSURFACE | DDSCAPS_VISIBLE))))
    {
        nvCheckQueuedBlits();
        nvUpdateBlitTracker();
    }

#ifdef  STEREO_SUPPORT
StereoSecondPass:
        dwNPasses = StereoBltAdjustParameters(src, dst, StereoBltPass);
#endif  //STEREO_SUPPORT

#if (NVARCH >= 0x010)

    // Handle AA
    PNVD3DCONTEXT pContext = NULL;

    if (src.pObj) {
        pContext = nvCelsiusAAFindContext(src.pObj->getSimpleSurface());
    }

    if (!pContext && dst.pObj) {
        pContext = nvCelsiusAAFindContext(dst.pObj->getSimpleSurface());
    }

    if (pContext) {
        CSimpleSurface *pSrc = 0;
        CSimpleSurface *pDst = 0;
        bool bRewriteDst = false;
        DWORD dwWidthScale, dwHeightScale;

        if ((pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) && pContext->kelvinAA.IsEnabled()) {
            if (src.pObj && (src.pObj->getSimpleSurface() == pContext->pRenderTarget)) {
                pContext->kelvinAA.GrantAccess(CKelvinAAState::BUFFER_RT, CKelvinAAState::ACCESS_READ);
            }

            if (dst.pObj && (dst.pObj->getSimpleSurface() == pContext->pRenderTarget)) {
                if (pContext->kelvinAA.IsValid(CKelvinAAState::BUFFER_SRT) && 
                    !bDoEarlyBlitFallback &&
                    !pContext->kelvinAA.CompatibilityMode(CKelvinAAState::APPFLAGS_DOWNSAMPLE_ON_BLIT)) {
                    // Early blit fallback seems to be incompatible with destination rewriting.  This 
                    // should be looked at...

                    // Grant exclusive access
                    pContext->kelvinAA.GrantAccess(CKelvinAAState::BUFFER_SRT, CKelvinAAState::ACCESS_WRITE);
                    pDst = pContext->kelvinAA.GetSRT();
                    bRewriteDst = true;
                } else {
                    pContext->kelvinAA.GrantAccess(CKelvinAAState::BUFFER_RT, CKelvinAAState::ACCESS_WRITE);
                }
            }

            if (src.pObj && (src.pObj->getSimpleSurface() == pContext->pZetaBuffer)) {
                pContext->kelvinAA.GrantAccess(CKelvinAAState::BUFFER_ZB, CKelvinAAState::ACCESS_READ);
            }

            if (dst.pObj && (dst.pObj->getSimpleSurface() == pContext->pZetaBuffer)) {
                if (dwPbdFlags & DDBLT_DEPTHFILL) {
                    // grant exclusive access
                    pContext->kelvinAA.GrantAccess(CKelvinAAState::BUFFER_SZB, CKelvinAAState::ACCESS_WRITE);
                    pDst = pContext->kelvinAA.GetSZB();
                    bRewriteDst = true;
                } else {
                    pContext->kelvinAA.GrantAccess(CKelvinAAState::BUFFER_ZB, CKelvinAAState::ACCESS_WRITE);
                }
            }

            dwWidthScale = pContext->kelvinAA.GetWidthScale();
            dwHeightScale = pContext->kelvinAA.GetHeightScale();
        } else if (pContext->aa.isInit() && (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS)) {

            // force AA enabled if registry said so

            if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASENABLE_MASK) // aa enabled
                && ((pContext->dwRenderState[D3DRENDERSTATE_ANTIALIAS] != D3DANTIALIAS_NONE)
                || (getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASFORCEENABLE_MASK))) // aa forced
            {
                // create aa buffers
                if (nvCelsiusAACreate(pContext))
                {
                    // enable AA
                    pContext->aa.setFlags (AASTATE::FLAG_ENABLED);
                }
            }

            if (getDC()->dwAAContextCount >= 1)
            {
                // We don't support parameter rewriting when the source is our render target
                // or Z buffer, we must minify (if necessary)
                if (!pContext->aa.mAppCompat.bBlitSync) {
                    if (src.pObj && src.pObj->getSimpleSurface() == pContext->pRenderTarget) {
                        pContext->aa.Minify(pContext);
                    } else if (src.pObj && src.pObj->getSimpleSurface() == pContext->pZetaBuffer) {
                        pContext->aa.MinifyZ(pContext);
                    }
                }

                // If our destination is our render target or Z buffer, we want to
                // see which buffer is valid, and blit to that.  That way we prevent
                // unnecessary minifications/manifications.
                if (!pContext->aa.mAppCompat.bBlitSync) {
                    if (dst.pObj && dst.pObj->getSimpleSurface() == pContext->pRenderTarget) {
                        pDst = pContext->pRenderTarget;

                        if (!pContext->aa.isRenderTargetValid()) {
                            bRewriteDst = true;
                            pDst = pContext->aa.pSuperRenderTarget;
                        }
                    } else if (dst.pObj && dst.pObj->getSimpleSurface() == pContext->pZetaBuffer) {
                        pDst = pContext->pZetaBuffer;
                        if (!pContext->aa.isZetaBufferValid()) {
                            bRewriteDst = true;
                            pDst = pContext->aa.pSuperZetaBuffer;
                        }
                    }
                } else {
                    // If configuration file says so, we want to force blits to to go to the
                    // render target, not the super render target
                    if (dst.pObj && dst.pObj->getSimpleSurface() == pContext->pRenderTarget) {
                        pContext->aa.Minify(pContext);
                    } else if (dst.pObj && dst.pObj->getSimpleSurface() == pContext->pZetaBuffer) {
                        pContext->aa.MinifyZ(pContext);
                    }

                }

            }

            dwWidthScale = int(pContext->aa.fWidthAmplifier + 0.5f);
            dwHeightScale = int(pContext->aa.fHeightAmplifier + 0.5f);
        }

        if (bRewriteDst && pDst) {
            if ((src.dwSubRectWidth == dst.dwSubRectWidth) &&
                (src.dwSubRectHeight == dst.dwSubRectHeight)) {
                bStretchLinearFilter = FALSE;
            }
            
            dst.dwSubRectX      *= dwWidthScale;
            dst.dwSubRectY      *= dwHeightScale;
            dst.dwSubRectWidth  *= dwWidthScale;
            dst.dwSubRectHeight *= dwHeightScale;
            
            // Make a backup
            bRewriteSurfData = TRUE;
            
            fpOldVidMem = dst.pGbl->fpVidMem;
            lOldPitch = dst.pGbl->lPitch;
            wOldHeight = dst.pGbl->wHeight;
            wOldWidth